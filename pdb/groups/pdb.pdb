# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub pdb_temp_name {
    $blurb = 'Generates a unique temporary PDB name.';

    $help = <<'HELP';
This procedure generates a temporary PDB entry name that is guaranteed to be
unique.
HELP

    &andy_pdb_misc('1998');

    $lib_private = 1;

    @outargs = (
	{ name => 'temp_name', type => 'string',
	  desc => 'A unique temporary name for a temporary PDB entry' }
    );

    %invoke = (
	code => <<'CODE'
{
  static gint proc_number = 0;

  temp_name = g_strdup_printf ("temp-procedure-number-%d", proc_number++);
}
CODE
    );
}

sub pdb_dump {
    $blurb = 'Dumps the current contents of the procedural database';

    $help = <<'HELP';
This procedure dumps the contents of the procedural database to the specified
file. The file will contain all of the information provided for each registered
procedure.
HELP

    &std_pdb_misc;
    $author = 'Spencer Kimball & Josh MacDonald';
    $copyright = $author . ' & Peter Mattis';

    $lib_private = 1;

    @inargs = (
	{ name => 'filename', type => 'string', allow_non_utf8 => 1,
          non_empty => 1,
	  desc => 'The dump filename' }
    );

    %invoke = (
	code => <<'CODE'
{
  GFile *file = g_file_new_for_path (filename);

  success = gimp_pdb_dump (gimp->pdb, file, error);

  g_object_unref (file);
}
CODE
    );
}

sub pdb_query {
    $blurb = <<'BLURB';
Queries the procedural database for its contents using regular expression
matching.
BLURB

    $help = <<'HELP';
This procedure queries the contents of the procedural database. It is supplied
with seven arguments matching procedures on { name, blurb, help, authors,
copyright, date, procedure type}. This is accomplished using regular expression
matching. For instance, to find all procedures with "jpeg" listed in the blurb,
all seven arguments can be supplied as ".*", except for the second, which can
be supplied as ".*jpeg.*". There are two return arguments for this procedure.
The first is the number of procedures matching the query. The second is a
concatenated list of procedure names corresponding to those matching the query.
If no matching entries are found, then the returned string is NULL and the
number of entries is 0.
HELP

    &std_pdb_misc;

    $lib_private = 1;

    @inargs = (
	{ name => 'name', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure name' },
	{ name => 'blurb', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure blurb' },
	{ name => 'help', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure help' },
	{ name => 'authors', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure authors' },
	{ name => 'copyright', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure copyright' },
	{ name => 'date', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure date' },
	{ name => 'proc_type', type => 'string', allow_non_utf8 => 1,
	  desc => 'The regex for procedure type: { \'Internal GIMP procedure\',
		   \'GIMP Plug-in\', \'GIMP Extension\',
		   \'Temporary Procedure\' }' }
    );

    @outargs = (
	{ name  => 'procedure_names', type  => 'stringarray', void_ret => 1,
	  desc  => 'The list of procedure names',
	  array => { name  => 'num_matches',
		     desc  => 'The number of matching procedures' } }
    );

    %invoke = (
	code => <<CODE
{
  success = gimp_pdb_query (gimp->pdb,
                            name, blurb, help, authors,
                            copyright, date, proc_type,
                            &num_matches, &procedure_names,
                            error);
}
CODE
    );
}

sub pdb_proc_exists {
    $blurb = <<'BLURB';
Checks if the specified procedure exists in the procedural database
BLURB

    $help = <<'HELP';
This procedure checks if the specified procedure is registered in the
procedural database.
HELP

    &neo_pdb_misc('2008', '2.6');

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
	{ name => 'exists', type => 'boolean',
	  desc => 'Whether a procedure of that name is registered' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = gimp_pdb_lookup_procedure (gimp->pdb,
                                                       procedure_name);

      if (! proc)
        {
          procedure_name = gimp_pdb_lookup_compat_proc_name (gimp->pdb,
	                                                     procedure_name);

          if (procedure_name)
            proc = gimp_pdb_lookup_procedure (gimp->pdb, procedure_name);
        }

      exists = (proc != NULL);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_info {
    $blurb = <<'BLURB';
Queries the procedural database for information on the specified procedure.
BLURB

    $help = <<'HELP';
This procedure returns information on the specified procedure.  The
procedure type, number of input, and number of return values are
returned. For specific information on each input argument and return
value, use the gimp_pdb_db_proc_argument() and
gimp_pdb_db_proc_return_value() procedures.
HELP

    &std_pdb_misc;
    $date = '1997';

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
        { name => 'proc_type', type => 'enum GimpPDBProcType', void_ret => 1,
	  desc => 'The procedure type' },
        { name => 'num_args', type => 'int32',
	  desc => 'The number of input arguments' },
        { name => 'num_values', type => 'int32',
	  desc => 'The number of return values' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (proc)
        {
          proc_type  = proc->proc_type;
          num_args   = proc->num_args;
          num_values = proc->num_values;
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_image_types {
    $blurb = <<'BLURB';
Queries the procedural database for the image types supported by the
specified procedure.
BLURB

    $help = <<'HELP';
This procedure returns the image types supported by the specified procedure.
HELP

    &mitch_pdb_misc('2019', '3.0');

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
	{ name => 'image_types', type => 'string',
	  desc => 'The image types' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (GIMP_IS_PLUG_IN_PROCEDURE (proc))
        {
          image_types = g_strdup (GIMP_PLUG_IN_PROCEDURE (proc)->image_types);
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_menu_label {
    $blurb = <<'BLURB';
Queries the procedural database for the procedure's menu label.
BLURB

    $help = <<'HELP';
This procedure returns the menu label of the specified procedure.
HELP

    &mitch_pdb_misc('2019', '3.0');

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
	{ name => 'menu_label', type => 'string',
	  desc => 'The menu_label' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (GIMP_IS_PLUG_IN_PROCEDURE (proc))
        {
          menu_label = g_strdup (GIMP_PLUG_IN_PROCEDURE (proc)->menu_label);
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_menu_paths {
    $blurb = <<'BLURB';
Queries the procedural database for the procedure's menu paths.
BLURB

    $help = <<'HELP';
This procedure returns the menu paths of the specified procedure.
HELP

    &mitch_pdb_misc('2019', '3.0');

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
	{ name  => 'menu_paths', type => 'stringarray',
	  desc  => 'The menu paths of the plug-in',
	  array => { name => 'num_menu_paths',
		     desc => 'The number of menu paths' } },
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (GIMP_IS_PLUG_IN_PROCEDURE (proc))
        {
	  GimpPlugInProcedure *plug_in_proc = GIMP_PLUG_IN_PROCEDURE (proc);

          num_menu_paths = g_list_length (plug_in_proc->menu_paths);

          if (num_menu_paths > 0)
            {
              GList *list;
              gint   i;

              menu_paths = g_new0 (gchar *, num_menu_paths + 1);

              for (list = plug_in_proc->menu_paths, i = 0;
                   list;
                   list = g_list_next (list), i++)
                {
                  menu_paths[i] = g_strdup (list->data);
                }
            }
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_documentation {
    $blurb = <<'BLURB';
Queries the procedural database for documentation on the specified procedure.
BLURB

    $help = <<'HELP';
This procedure returns documentation on the specified procedure. A
short blurb, detailed help and help_id.
HELP

    &mitch_pdb_misc('2019', '3.0');

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
	{ name => 'blurb', type => 'string', void_ret => 1,
	  desc => 'A short blurb' },
	{ name => 'help', type => 'string',
	  desc => 'Detailed procedure help' },
	{ name => 'help_id', type => 'string',
	  desc => 'The procedure help_id' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (proc)
        {
          blurb   = g_strdup (gimp_procedure_get_blurb   (proc));
          help    = g_strdup (gimp_procedure_get_help    (proc));
          help_id = g_strdup (gimp_procedure_get_help_id (proc));
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_attribution {
    $blurb = <<'BLURB';
Queries the procedural database for attribution information on the
specified procedure.
BLURB

    $help = <<'HELP';
This procedure returns attribution information on the specified
procedure.  The authors, copyright information and date are returned.
HELP

    &mitch_pdb_misc('2019', '3.0');

    $lib_private = 1;

    @inargs = (
	{ name  => 'procedure_name', type  => 'string', non_empty => 1,
	  desc  => 'The procedure name' }
    );

    @outargs = (
	{ name => 'authors', type => 'string', void_ret => 1,
	  desc => 'Authors of the procedure' },
	{ name => 'copyright', type => 'string',
	  desc => 'The copyright' },
	{ name => 'date', type => 'string',
	  desc => 'Copyright date' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (proc)
        {
          authors   = g_strdup (proc->authors);
          copyright = g_strdup (proc->copyright);
          date      = g_strdup (proc->date);
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_proc_argument {
    $blurb = <<BLURB;
Queries the procedural database for information on the specified procedure's
argument.
BLURB

    $help = <<HELP;
This procedure returns the #GParamSpec of procedure_name's argument.
HELP

    &mitch_pdb_misc;
    $date = '2019';
    $since = '3.0';

    $lib_private = 1;

    @inargs = (
	{ name => 'procedure_name', type  => 'string', non_empty => 1,
	  desc => 'The procedure name' },
	{ name => 'arg_num', type => 'int32',
	  desc => 'The argument number' }
    );

    @outargs = (
	{ name => 'param_spec', type => 'param',
	  desc => "The GParamSpec of the argument" }
    );

   %invoke = (
	code => <<CODE
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (proc && (arg_num >= 0 && arg_num < proc->num_args))
        {
          param_spec = g_param_spec_ref (proc->args[arg_num]);
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
   );
}

sub pdb_proc_return_value {
    $blurb = <<BLURB;
Queries the procedural database for information on the specified procedure's
return value.
BLURB

    $help = <<HELP;
This procedure returns the #GParamSpec of procedure_name's return value.
HELP

    &mitch_pdb_misc;
    $date = '2019';
    $since = '3.0';

    $lib_private = 1;

    @inargs = (
	{ name => 'procedure_name', type  => 'string', non_empty => 1,
	  desc => 'The procedure name' },
	{ name => 'val_num', type => 'int32',
	  desc => 'The return value number' }
    );

    @outargs = (
	{ name => 'param_spec', type => 'param',
	  desc => "The GParamSpec of the return value" }
    );

   %invoke = (
	code => <<CODE
{
  if (gimp_pdb_is_canonical_procedure (procedure_name, error))
    {
      GimpProcedure *proc = lookup_procedure (gimp->pdb, procedure_name,
                                              error);

      if (proc && (val_num >= 0 && val_num < proc->num_values))
        {
          param_spec = g_param_spec_ref (proc->values[val_num]);
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
   );
}

sub pdb_get_data {
    $blurb = 'Returns data associated with the specified identifier.';

    $help = <<'HELP';
This procedure returns any data which may have been associated with the
specified identifier. The data is a variable length array of bytes. If no data
has been associated with the identifier, an error is returned.
HELP

    &std_pdb_misc;
    $date = '1997';

    $lib_private = 1;

    @inargs = (
	{ name => 'identifier', type => 'string', non_empty => 1,
	  desc => 'The identifier associated with data' }
    );

    @outargs = (
	{ name  => 'data', type  => 'int8array', void_ret => 1,
	  desc  => 'A byte array containing data',
	  array => { name => 'bytes', type => '1 <= int32',
		     desc => 'The number of bytes in the data' } }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (identifier, error))
    {
      const guint8 *orig_data;

      orig_data = gimp_plug_in_manager_get_data (gimp->plug_in_manager,
                                                 identifier, &bytes);

      if (orig_data)
        data = g_memdup (orig_data, bytes);
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_get_data_size {
    $blurb = 'Returns size of data associated with the specified identifier.';

    $help = <<'HELP';
This procedure returns the size of any data which may have been associated with
the specified identifier. If no data has been associated with the identifier,
an error is returned.
HELP

    &nick_pdb_misc('1998');

    $lib_private = 1;

    @inargs = (
	{ name => 'identifier', type => 'string', non_empty => 1,
	  desc => 'The identifier associated with data' }
    );

    @outargs = (
	{ name => 'bytes', type => '1 <= int32',
	  desc => 'The number of bytes in the data' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (identifier, error))
    {
      if (! gimp_plug_in_manager_get_data (gimp->plug_in_manager,
                                           identifier, &bytes))
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub pdb_set_data {
    $blurb = 'Associates the specified identifier with the supplied data.';

    $help = <<'HELP';
This procedure associates the supplied data with the provided identifier. The
data may be subsequently retrieved by a call to 'procedural-db-get-data'.
HELP

    &std_pdb_misc;
    $date = '1997';

    $lib_private = 1;

    @inargs = (
	{ name => 'identifier', type => 'string', non_empty => 1,
	  desc => 'The identifier associated with data' },
	{ name  => 'data', type  => 'int8array',
	  desc  => 'A byte array containing data',
	  array => { name => 'bytes', type => '1 <= int32',
		     desc => 'The number of bytes in the data' } }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_is_canonical_procedure (identifier, error))
    {
      gimp_plug_in_manager_set_data (gimp->plug_in_manager,
                                     identifier, bytes, data);
    }
  else
    success = FALSE;
}
CODE
    );
}

$extra{app}->{code} = <<'CODE';
static GimpProcedure *
lookup_procedure (GimpPDB          *pdb,
                  const gchar      *proc_name,
                  GError          **error)
{
  GimpProcedure *proc = gimp_pdb_lookup_procedure (pdb, proc_name);

  if (! proc)
    {
      const gchar *compat_name = gimp_pdb_lookup_compat_proc_name (pdb,
                                                                   proc_name);

      if (compat_name)
        proc = gimp_pdb_lookup_procedure (pdb, compat_name);
    }

  if (! proc)
    g_set_error (error, GIMP_PDB_ERROR, GIMP_PDB_ERROR_PROCEDURE_NOT_FOUND,
                 _("Procedure '%s' not found"), proc_name);

  return proc;
}
CODE

@headers = qw("libgimpbase/gimpbase.h"
              "core/gimp.h"
              "core/gimpparamspecs-desc.h"
              "plug-in/gimppluginmanager-data.h"
              "plug-in/gimppluginprocedure.h"
              "gimppdb-query.h"
              "gimppdb-utils.h"
              "gimppdberror.h"
              "gimp-pdb-compat.h"
              "gimp-intl.h");

@procs = qw(pdb_temp_name
            pdb_dump
            pdb_query
            pdb_proc_exists
            pdb_proc_info
            pdb_proc_image_types
            pdb_proc_menu_label
            pdb_proc_menu_paths
            pdb_proc_documentation
            pdb_proc_attribution
            pdb_proc_argument
            pdb_proc_return_value
	    pdb_get_data
            pdb_get_data_size
	    pdb_set_data);

%exports = (app => [@procs], lib => [@procs]);

$desc = 'Procedural database';

$lib_private = 1;

1;
