begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMP - The GIMP Library  * Copyright (C) 1995-1997 Peter Mattis and Spencer Kimball  *  * gimppickbutton-quartz.c  * Copyright (C) 2015 Kristian Rietveld<kris@loopnest.org>  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Library General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<https://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<gegl.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdkkeysyms.h>
end_include

begin_include
include|#
directive|include
file|"libgimpcolor/gimpcolor.h"
end_include

begin_include
include|#
directive|include
file|"gimpwidgetstypes.h"
end_include

begin_include
include|#
directive|include
file|"gimppickbutton.h"
end_include

begin_include
include|#
directive|include
file|"gimppickbutton-private.h"
end_include

begin_include
include|#
directive|include
file|"gimppickbutton-quartz.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GDK_WINDOWING_QUARTZ
end_ifdef

begin_empty
empty|#import<AppKit/AppKit.h>
end_empty

begin_include
include|#
directive|include
file|<Carbon/Carbon.h>
end_include

begin_comment
comment|/* For virtual key codes ... */
end_comment

begin_include
include|#
directive|include
file|<ApplicationServices/ApplicationServices.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
unit|@
name|interface
name|GimpPickWindowController
range|:
name|NSObject
block|{
DECL|variable|button
name|GimpPickButton
operator|*
name|button
block|;
DECL|variable|windows
name|NSMutableArray
operator|*
name|windows
block|; }
expr|@
name|property
argument_list|(
argument|nonatomic
argument_list|,
argument|assign
argument_list|)
name|BOOL
name|firstBecameKey
decl_stmt|;
end_decl_stmt

begin_macro
unit|@
name|property
argument_list|(
argument|readonly
argument_list|,
argument|retain
argument_list|)
end_macro

begin_decl_stmt
name|NSCursor
modifier|*
name|cursor
decl_stmt|;
end_decl_stmt

begin_expr_stmt
operator|-
operator|(
name|id
operator|)
name|initWithButton
operator|:
operator|(
name|GimpPickButton
operator|*
operator|)
name|_button
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|updateKeyWindow
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|shutdown
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|@
name|end
expr|@
name|interface
name|GimpPickView
operator|:
name|NSView
block|{
DECL|variable|button
name|GimpPickButton
operator|*
name|button
block|;
DECL|variable|controller
name|GimpPickWindowController
operator|*
name|controller
block|; }
expr|@
name|property
argument_list|(
argument|readonly
argument_list|,
argument|assign
argument_list|)
name|NSTrackingArea
operator|*
name|area
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|id
operator|)
name|initWithButton
operator|:
operator|(
name|GimpPickButton
operator|*
operator|)
name|_button
name|controller
operator|:
operator|(
name|GimpPickWindowController
operator|*
operator|)
name|controller
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|@
name|end
expr|@
name|implementation
name|GimpPickView
expr|@
name|synthesize
name|area
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|id
operator|)
name|initWithButton
operator|:
operator|(
name|GimpPickButton
operator|*
operator|)
name|_button
name|controller
operator|:
operator|(
name|GimpPickWindowController
operator|*
operator|)
name|_controller
block|{
name|self
operator|=
index|[
name|super
name|init
index|]
block|;
if|if
condition|(
name|self
condition|)
block|{
name|button
operator|=
name|_button
expr_stmt|;
name|controller
operator|=
name|_controller
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|self
return|;
end_return

begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|dealloc
block|{
index|[
name|self
name|removeTrackingArea
operator|:
name|self
operator|.
name|area
index|]
block|;
index|[
name|super
name|dealloc
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|viewDidMoveToWindow
block|{
DECL|variable|options
name|NSTrackingAreaOptions
name|options
block|;
index|[
name|super
name|viewDidMoveToWindow
index|]
block|;
if|if
condition|(
index|[
name|self
name|window
index|]
operator|==
name|nil
condition|)
return|return;
name|options
operator|=
name|NSTrackingMouseEnteredAndExited
operator||
name|NSTrackingMouseMoved
operator||
name|NSTrackingActiveAlways
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Add assume inside if mouse pointer is above this window */
end_comment

begin_if
if|if
condition|(
name|NSPointInRect
argument_list|(
argument|[NSEvent mouseLocation]
argument_list|,
argument|self.window.frame
argument_list|)
condition|)
name|options
operator||=
name|NSTrackingAssumeInside
expr_stmt|;
end_if

begin_expr_stmt
name|area
operator|=
index|[
index|[
name|NSTrackingArea
name|alloc
index|]
name|initWithRect
operator|:
name|self
operator|.
name|bounds
name|options
operator|:
name|options
name|owner
operator|:
name|self
name|userInfo
operator|:
name|nil
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
index|[
name|self
name|addTrackingArea
operator|:
name|self
operator|.
name|area
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|mouseEntered
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
comment|/* We handle the mouse cursor manually, see also the comment in    * [GimpPickWindow windowDidBecomeMain below].    */
if|if
condition|(
name|controller
operator|.
name|cursor
condition|)
index|[
name|controller
operator|.
name|cursor
name|push
index|]
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|mouseExited
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
if|if
condition|(
name|controller
operator|.
name|cursor
condition|)
index|[
name|controller
operator|.
name|cursor
name|pop
index|]
expr_stmt|;
index|[
name|controller
name|updateKeyWindow
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|mouseMoved
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
index|[
name|self
name|pickColor
operator|:
name|event
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|mouseUp
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
index|[
name|self
name|pickColor
operator|:
name|event
index|]
block|;
index|[
name|controller
name|shutdown
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|rightMouseUp
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
index|[
name|self
name|mouseUp
operator|:
name|event
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|otherMouseUp
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
index|[
name|self
name|mouseUp
operator|:
name|event
index|]
block|; }
operator|-
operator|(
name|void
operator|)
name|keyDown
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
if|if
condition|(
name|event
operator|.
name|keyCode
operator|==
name|kVK_Escape
condition|)
index|[
name|controller
name|shutdown
index|]
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|pickColor
operator|:
operator|(
name|NSEvent
operator|*
operator|)
name|event
block|{
DECL|variable|root_image_ref
name|CGImageRef
name|root_image_ref
block|;
DECL|variable|pixel_data
name|CFDataRef
name|pixel_data
block|;
DECL|variable|data
specifier|const
name|guchar
operator|*
name|data
block|;
DECL|variable|rgb
name|GimpRGB
name|rgb
block|;
DECL|variable|point
name|NSPoint
name|point
block|;
DECL|variable|profile
name|GimpColorProfile
operator|*
name|profile
operator|=
name|NULL
block|;
DECL|variable|color_space
name|CGColorSpaceRef
name|color_space
operator|=
name|NULL
block|;
comment|/* The event gives us a point in Cocoa window coordinates. The function    * CGWindowListCreateImage expects a rectangle in screen coordinates    * with the origin in the upper left (contrary to Cocoa). The origin is    * on the screen showing the menu bar (this is the screen at index 0 in the    * screens array). So, after converting the rectangle to Cocoa screen    * coordinates, we use the height of this particular screen to translate    * to the coordinate space expected by CGWindowListCreateImage.    */
name|point
operator|=
name|event
operator|.
name|locationInWindow
block|;
DECL|variable|rect
name|NSRect
name|rect
operator|=
name|NSMakeRect
argument_list|(
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
block|;
name|rect
operator|=
index|[
name|self
operator|.
name|window
name|convertRectToScreen
operator|:
name|rect
index|]
block|;
name|rect
operator|.
name|origin
operator|.
name|y
operator|=
index|[
index|[
index|[
name|NSScreen
name|screens
index|]
name|objectAtIndex
operator|:
literal|0
index|]
name|frame
index|]
operator|.
name|size
operator|.
name|height
operator|-
name|rect
operator|.
name|origin
operator|.
name|y
block|;
name|root_image_ref
operator|=
name|CGWindowListCreateImage
argument_list|(
name|rect
argument_list|,
name|kCGWindowListOptionOnScreenOnly
argument_list|,
name|kCGNullWindowID
argument_list|,
name|kCGWindowImageDefault
argument_list|)
block|;
name|pixel_data
operator|=
name|CGDataProviderCopyData
argument_list|(
name|CGImageGetDataProvider
argument_list|(
name|root_image_ref
argument_list|)
argument_list|)
block|;
name|data
operator|=
name|CFDataGetBytePtr
argument_list|(
name|pixel_data
argument_list|)
block|;
name|color_space
operator|=
name|CGImageGetColorSpace
argument_list|(
name|root_image_ref
argument_list|)
block|;
if|if
condition|(
name|color_space
condition|)
block|{
DECL|variable|icc_data
name|CFDataRef
name|icc_data
init|=
name|NULL
decl_stmt|;
name|icc_data
operator|=
name|CGColorSpaceCopyICCProfile
argument_list|(
name|color_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|icc_data
condition|)
block|{
name|UInt8
modifier|*
name|buffer
init|=
name|g_malloc
argument_list|(
name|CFDataGetLength
argument_list|(
name|icc_data
argument_list|)
argument_list|)
decl_stmt|;
name|CFDataGetBytes
argument_list|(
name|icc_data
argument_list|,
name|CFRangeMake
argument_list|(
literal|0
argument_list|,
name|CFDataGetLength
argument_list|(
name|icc_data
argument_list|)
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|profile
operator|=
name|gimp_color_profile_new_from_icc_profile
argument_list|(
name|buffer
argument_list|,
name|CFDataGetLength
argument_list|(
name|icc_data
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|icc_data
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    gimp_rgba_set_uchar
operator|(
operator|&
name|rgb
operator|,
name|data
index|[
literal|2
index|]
operator|,
name|data
index|[
literal|1
index|]
operator|,
name|data
index|[
literal|0
index|]
operator|,
literal|255
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|profile
condition|)
block|{
DECL|variable|srgb_profile
name|GimpColorProfile
modifier|*
name|srgb_profile
decl_stmt|;
DECL|variable|transform
name|GimpColorTransform
modifier|*
name|transform
decl_stmt|;
DECL|variable|format
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
DECL|variable|flags
name|GimpColorTransformFlags
name|flags
init|=
literal|0
decl_stmt|;
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A double"
argument_list|)
expr_stmt|;
name|flags
operator||=
name|GIMP_COLOR_TRANSFORM_FLAGS_NOOPTIMIZE
expr_stmt|;
name|flags
operator||=
name|GIMP_COLOR_TRANSFORM_FLAGS_BLACK_POINT_COMPENSATION
expr_stmt|;
name|srgb_profile
operator|=
name|gimp_color_profile_new_rgb_srgb
argument_list|()
expr_stmt|;
name|transform
operator|=
name|gimp_color_transform_new
argument_list|(
name|profile
argument_list|,
name|format
argument_list|,
name|srgb_profile
argument_list|,
name|format
argument_list|,
name|GIMP_COLOR_RENDERING_INTENT_PERCEPTUAL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|transform
condition|)
block|{
name|gimp_color_transform_process_pixels
argument_list|(
name|transform
argument_list|,
name|format
argument_list|,
operator|&
name|rgb
argument_list|,
name|format
argument_list|,
operator|&
name|rgb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|rgb
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|transform
argument_list|)
expr_stmt|;
block|}
name|g_object_unref
argument_list|(
name|srgb_profile
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|profile
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CGImageRelease
argument_list|(
name|root_image_ref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CFRelease
argument_list|(
name|pixel_data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|g_signal_emit_by_name
argument_list|(
name|button
argument_list|,
literal|"color-picked"
argument_list|,
operator|&
name|rgb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} @
name|end
expr|@
name|interface
name|GimpPickWindow
operator|:
name|NSWindow
operator|<
name|NSWindowDelegate
operator|>
block|{
DECL|variable|controller
name|GimpPickWindowController
operator|*
name|controller
block|; }
operator|-
operator|(
name|id
operator|)
name|initWithButton
operator|:
operator|(
name|GimpPickButton
operator|*
operator|)
name|button
name|forScreen
operator|:
operator|(
name|NSScreen
operator|*
operator|)
name|screen
name|withController
operator|:
operator|(
name|GimpPickWindowController
operator|*
operator|)
name|_controller
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|@
name|end
expr|@
name|implementation
name|GimpPickWindow
operator|-
operator|(
name|id
operator|)
name|initWithButton
operator|:
operator|(
name|GimpPickButton
operator|*
operator|)
name|button
name|forScreen
operator|:
operator|(
name|NSScreen
operator|*
operator|)
name|screen
name|withController
operator|:
operator|(
name|GimpPickWindowController
operator|*
operator|)
name|_controller
block|{
name|self
operator|=
index|[
name|super
name|initWithContentRect
operator|:
name|screen
operator|.
name|frame
name|styleMask
operator|:
name|NSBorderlessWindowMask
name|backing
operator|:
name|NSBackingStoreBuffered
name|defer
operator|:
name|NO
index|]
block|;
if|if
condition|(
name|self
condition|)
block|{
DECL|variable|view
name|GimpPickView
modifier|*
name|view
decl_stmt|;
name|controller
operator|=
name|_controller
expr_stmt|;
index|[
name|self
name|setDelegate
operator|:
name|self
index|]
expr_stmt|;
index|[
name|self
name|setAlphaValue
operator|:
literal|0.0
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Useful for debugging purposes */
block|[self setBackgroundColor:[NSColor redColor]];       [self setAlphaValue:0.2];
endif|#
directive|endif
index|[
name|self
name|setIgnoresMouseEvents
operator|:
name|NO
index|]
expr_stmt|;
index|[
name|self
name|setAcceptsMouseMovedEvents
operator|:
name|YES
index|]
expr_stmt|;
index|[
name|self
name|setHasShadow
operator|:
name|NO
index|]
expr_stmt|;
index|[
name|self
name|setOpaque
operator|:
name|NO
index|]
expr_stmt|;
comment|/* Set the highest level, so on top of everything */
index|[
name|self
name|setLevel
operator|:
name|NSScreenSaverWindowLevel
index|]
expr_stmt|;
name|view
operator|=
index|[
index|[
name|GimpPickView
name|alloc
index|]
name|initWithButton
operator|:
name|button
name|controller
operator|:
name|controller
index|]
expr_stmt|;
index|[
name|self
name|setContentView
operator|:
name|view
index|]
expr_stmt|;
index|[
name|self
name|makeFirstResponder
operator|:
name|view
index|]
expr_stmt|;
index|[
name|view
name|release
index|]
expr_stmt|;
index|[
name|self
name|disableCursorRects
index|]
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|self
return|;
end_return

begin_comment
unit|}
comment|/* Borderless windows cannot become key/main by default, so we force it  * to make it so. We need this to receive events.  */
end_comment

begin_expr_stmt
unit|-
operator|(
name|BOOL
operator|)
name|canBecomeKeyWindow
block|{
return|return
name|YES
return|;
block|}
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|BOOL
operator|)
name|canBecomeMainWindow
block|{
return|return
name|YES
return|;
block|}
end_expr_stmt

begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|windowDidBecomeKey
operator|:
operator|(
name|NSNotification
operator|*
operator|)
name|aNotification
block|{
comment|/* We cannot use the usual Cocoa method for handling cursor updates,    * since the GDK Quartz backend is interfering. Additionally, because    * one of the screen-spanning windows pops up under the mouse pointer this    * view will not receive a MouseEntered event. So, we synthesize such    * an event here and the view can set the mouse pointer in response to    * this. So, this event only has to be synthesized once and only for    * the window that pops up under the mouse cursor. Synthesizing multiple    * times messes up the mouse cursor stack.    *    * We cannot set the mouse pointer at this moment, because the GDK window    * will still receive an MouseExited event in which turn it will modify    * the cursor. So, with this synthesized event we also ensure we set    * the mouse cursor *after* the GDK window has manipulated the cursor.    */
DECL|variable|event
name|NSEvent
operator|*
name|event
block|;
if|if
condition|(
operator|!
name|controller
operator|.
name|firstBecameKey
operator|||
operator|!
name|NSPointInRect
argument_list|(
argument|[NSEvent mouseLocation]
argument_list|,
argument|self.frame
argument_list|)
condition|)
return|return;
name|controller
operator|.
name|firstBecameKey
operator|=
name|NO
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|event
operator|=
index|[
name|NSEvent
name|enterExitEventWithType
operator|:
name|NSMouseEntered
name|location
operator|:
index|[
name|self
name|mouseLocationOutsideOfEventStream
index|]
name|modifierFlags
operator|:
literal|0
name|timestamp
operator|:
index|[
index|[
name|NSApp
name|currentEvent
index|]
name|timestamp
index|]
name|windowNumber
operator|:
name|self
operator|.
name|windowNumber
name|context
operator|:
name|nil
name|eventNumber
operator|:
literal|0
name|trackingNumber
operator|:
operator|(
name|NSInteger
operator|)
index|[
index|[
name|self
name|contentView
index|]
name|area
index|]
name|userData
operator|:
name|nil
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
index|[
name|NSApp
name|postEvent
operator|:
name|event
name|atStart
operator|:
name|NO
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} @
name|end
comment|/* To properly handle multi-monitor setups we need to create a  * GimpPickWindow for each monitor (NSScreen). This is necessary because  * a window on Mac OS X (tested on 10.9) cannot span more than one  * monitor, so any approach that attempts to create one large window  * spanning all monitors cannot work. So, we have to create multiple  * windows in case of multi-monitor setups and these different windows  * are managed by GimpPickWindowController.  */
expr|@
name|implementation
name|GimpPickWindowController
expr|@
name|synthesize
name|firstBecameKey
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|@
name|synthesize
name|cursor
decl_stmt|;
end_decl_stmt

begin_expr_stmt
operator|-
operator|(
name|id
operator|)
name|initWithButton
operator|:
operator|(
name|GimpPickButton
operator|*
operator|)
name|_button
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|self
operator|=
index|[
name|super
name|init
index|]
expr_stmt|;
if|if
condition|(
name|self
condition|)
block|{
name|firstBecameKey
operator|=
name|YES
expr_stmt|;
name|button
operator|=
name|_button
expr_stmt|;
name|cursor
operator|=
index|[
name|GimpPickWindowController
name|makePickCursor
index|]
expr_stmt|;
name|windows
operator|=
index|[
index|[
name|NSMutableArray
name|alloc
index|]
name|init
index|]
expr_stmt|;
for|for
control|(
name|NSScreen
operator|*
name|screen
name|in
index|[
name|NSScreen
name|screens
index|]
control|)
block|{
DECL|variable|window
name|GimpPickWindow
modifier|*
name|window
decl_stmt|;
name|window
operator|=
index|[
index|[
name|GimpPickWindow
name|alloc
index|]
name|initWithButton
operator|:
name|button
name|forScreen
operator|:
name|screen
name|withController
operator|:
name|self
index|]
expr_stmt|;
index|[
name|window
name|orderFrontRegardless
index|]
expr_stmt|;
index|[
name|window
name|makeMainWindow
index|]
expr_stmt|;
index|[
name|windows
name|addObject
operator|:
name|window
index|]
expr_stmt|;
block|}
index|[
name|self
name|updateKeyWindow
index|]
expr_stmt|;
block|}
return|return
name|self
return|;
block|}
end_block

begin_expr_stmt
operator|-
operator|(
name|void
operator|)
name|updateKeyWindow
block|{
for|for
control|(
name|GimpPickWindow
operator|*
name|window
name|in
name|windows
control|)
block|{
if|if
condition|(
name|NSPointInRect
argument_list|(
argument|[NSEvent mouseLocation]
argument_list|,
argument|window.frame
argument_list|)
condition|)
index|[
name|window
name|makeKeyWindow
index|]
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  -
operator|(
name|void
operator|)
name|shutdown
block|{
DECL|variable|window
name|GtkWidget
operator|*
name|window
block|;
for|for
control|(
name|GimpPickWindow
operator|*
name|window
name|in
name|windows
control|)
index|[
name|window
name|close
index|]
expr_stmt|;
index|[
name|windows
name|release
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|cursor
condition|)
index|[
name|cursor
name|release
index|]
expr_stmt|;
end_if

begin_comment
comment|/* Give focus back to the window containing the pick button */
end_comment

begin_expr_stmt
name|window
operator|=
name|gtk_widget_get_toplevel
argument_list|(
name|GTK_WIDGET
argument_list|(
name|button
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gtk_window_present_with_time
argument_list|(
name|GTK_WINDOW
argument_list|(
name|window
argument_list|)
argument_list|,
name|GDK_CURRENT_TIME
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
index|[
name|self
name|release
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  +
operator|(
name|NSCursor
operator|*
operator|)
name|makePickCursor
block|{
DECL|variable|bytes
name|GBytes
operator|*
name|bytes
operator|=
name|NULL
block|;
DECL|variable|error
name|GError
operator|*
name|error
operator|=
name|NULL
block|;
name|bytes
operator|=
name|g_resources_lookup_data
argument_list|(
literal|"/org/gimp/color-picker-cursors-raw/cursor-color-picker.png"
argument_list|,
name|G_RESOURCE_LOOKUP_FLAGS_NONE
argument_list|,
operator|&
name|error
argument_list|)
block|;
if|if
condition|(
name|bytes
condition|)
block|{
DECL|variable|data
name|NSData
modifier|*
name|data
init|=
index|[
name|NSData
name|dataWithBytes
operator|:
name|g_bytes_get_data
argument_list|(
argument|bytes
argument_list|,
argument|NULL
argument_list|)
name|length
operator|:
name|g_bytes_get_size
argument_list|(
name|bytes
argument_list|)
index|]
decl_stmt|;
DECL|variable|image
name|NSImage
modifier|*
name|image
init|=
index|[
index|[
name|NSImage
name|alloc
index|]
name|initWithData
operator|:
name|data
index|]
decl_stmt|;
DECL|variable|cursor
name|NSCursor
modifier|*
name|cursor
init|=
index|[
index|[
name|NSCursor
name|alloc
index|]
name|initWithImage
operator|:
name|image
name|hotSpot
operator|:
name|NSMakePoint
argument_list|(
literal|1
argument_list|,
literal|30
argument_list|)
index|]
decl_stmt|;
index|[
name|image
name|release
index|]
expr_stmt|;
name|g_bytes_unref
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
index|[
name|cursor
name|retain
index|]
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|g_critical
argument_list|(
literal|"Failed to create cursor image: %s"
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_clear_error
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
name|NULL
return|;
end_return

begin_function
unit|} @
name|end
comment|/* entry point to this file, called from gimppickbutton.c */
name|void
DECL|function|_gimp_pick_button_quartz_pick (GimpPickButton * button)
name|_gimp_pick_button_quartz_pick
parameter_list|(
name|GimpPickButton
modifier|*
name|button
parameter_list|)
block|{
name|GimpPickWindowController
modifier|*
name|controller
decl_stmt|;
name|NSAutoreleasePool
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
index|[
index|[
name|NSAutoreleasePool
name|alloc
index|]
name|init
index|]
expr_stmt|;
name|controller
operator|=
index|[
index|[
name|GimpPickWindowController
name|alloc
index|]
name|initWithButton
operator|:
name|button
index|]
expr_stmt|;
index|[
name|pool
name|release
index|]
expr_stmt|;
block|}
end_function

end_unit

