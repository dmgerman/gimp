begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * gimprational.c  *  *  Created on: 19.09.2014  *      Author: kuhse  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"gimprational.h"
end_include

begin_function_decl
specifier|static
name|gpointer
name|rational_copy
parameter_list|(
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gpointer
name|srational_copy
parameter_list|(
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|G_DEFINE_BOXED_TYPE (Rational,rational,rational_copy,rational_free)
name|G_DEFINE_BOXED_TYPE
argument_list|(
argument|Rational
argument_list|,
argument|rational
argument_list|,
argument|rational_copy
argument_list|,
argument|rational_free
argument_list|)
end_macro

begin_macro
name|G_DEFINE_BOXED_TYPE
argument_list|(
argument|SRational
argument_list|,
argument|srational
argument_list|,
argument|srational_copy
argument_list|,
argument|srational_free
argument_list|)
end_macro

begin_comment
comment|/**  * string_to_rational:  *  * @string:     a #gchar array  * @rational:  a pointer to a #Rational struct  *  * converts a string, representing one/more rational values into  * a #Rational struct.  *  * Since: 2.10  */
end_comment

begin_function
name|void
name|string_to_rational
parameter_list|(
name|gchar
modifier|*
name|string
parameter_list|,
name|Rational
modifier|*
modifier|*
name|rational
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|nom
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|rats
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|Rational
modifier|*
name|rval
decl_stmt|;
name|GArray
modifier|*
name|rational_array
decl_stmt|;
name|rats
operator|=
name|g_strsplit
argument_list|(
name|string
argument_list|,
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rats
index|[
name|count
index|]
condition|)
name|count
operator|++
expr_stmt|;
name|rational_array
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|RationalValue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|RationalValue
name|or
decl_stmt|;
name|nom
operator|=
name|g_strsplit
argument_list|(
name|rats
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nom
index|[
literal|0
index|]
operator|&&
name|nom
index|[
literal|1
index|]
condition|)
block|{
name|or
operator|.
name|nom
operator|=
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|or
operator|.
name|denom
operator|=
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|--
expr_stmt|;
name|rational_array
operator|=
name|g_array_append_val
argument_list|(
name|rational_array
argument_list|,
name|or
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|nom
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|rats
argument_list|)
expr_stmt|;
name|rval
operator|=
name|g_slice_new
argument_list|(
name|Rational
argument_list|)
expr_stmt|;
name|rval
operator|->
name|rational_array
operator|=
name|rational_array
expr_stmt|;
name|rval
operator|->
name|length
operator|=
name|count
expr_stmt|;
operator|*
name|rational
operator|=
name|rval
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * rational_to_string:  *  * @rational : a pointer to a @Rational struct  * @nom      : a pointer to a #gint array  * @denom    : a pointer to a #gint array  * @length   : a pointer to a #gint  *  * converts a @rational to nom/denum gchar arrays  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|rational_to_int (Rational * rational,gint ** nom,gint ** denom,gint * length)
name|rational_to_int
parameter_list|(
name|Rational
modifier|*
name|rational
parameter_list|,
name|gint
modifier|*
modifier|*
name|nom
parameter_list|,
name|gint
modifier|*
modifier|*
name|denom
parameter_list|,
name|gint
modifier|*
name|length
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
modifier|*
name|_nom
decl_stmt|;
name|gint
modifier|*
name|_denom
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|rational
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_nom
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|rational
operator|->
name|length
argument_list|)
expr_stmt|;
name|_denom
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|rational
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rational
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RationalValue
name|one
decl_stmt|;
name|one
operator|=
name|g_array_index
argument_list|(
name|rational
operator|->
name|rational_array
argument_list|,
name|RationalValue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|_nom
index|[
name|i
index|]
operator|=
name|one
operator|.
name|nom
expr_stmt|;
name|_denom
index|[
name|i
index|]
operator|=
name|one
operator|.
name|denom
expr_stmt|;
block|}
operator|*
name|nom
operator|=
name|_nom
expr_stmt|;
operator|*
name|denom
operator|=
name|_denom
expr_stmt|;
operator|*
name|length
operator|=
name|rational
operator|->
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * rational_copy:  *  * @data:          a #gpointer to a #Rational structure  *  * copy part of the #Rational type  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gpointer
DECL|function|rational_copy (gpointer data)
name|rational_copy
parameter_list|(
name|gpointer
name|data
parameter_list|)
block|{
name|struct
name|_Rational
modifier|*
name|rational
init|=
operator|(
expr|struct
name|_Rational
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|_Rational
modifier|*
name|copy
init|=
name|g_slice_new
argument_list|(
name|Rational
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GArray
modifier|*
name|rlacp
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
name|rlacp
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|RationalValue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rational
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RationalValue
name|or
decl_stmt|;
name|RationalValue
name|cor
decl_stmt|;
name|or
operator|=
name|g_array_index
argument_list|(
name|rational
operator|->
name|rational_array
argument_list|,
name|RationalValue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cor
operator|.
name|nom
operator|=
name|or
operator|.
name|nom
expr_stmt|;
name|cor
operator|.
name|denom
operator|=
name|or
operator|.
name|denom
expr_stmt|;
name|rlacp
operator|=
name|g_array_append_val
argument_list|(
name|rlacp
argument_list|,
name|cor
argument_list|)
expr_stmt|;
block|}
name|copy
operator|->
name|rational_array
operator|=
name|rlacp
expr_stmt|;
name|copy
operator|->
name|length
operator|=
name|rational
operator|->
name|length
expr_stmt|;
return|return
operator|(
name|gpointer
operator|)
name|copy
return|;
block|}
end_function

begin_comment
comment|/**  * rational_free:  *  * @data:          a #gpointer to a #Rational structure  *  * free part of the #Rational type  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|rational_free (gpointer data)
name|rational_free
parameter_list|(
name|gpointer
name|data
parameter_list|)
block|{
name|struct
name|_Rational
modifier|*
name|rational
init|=
operator|(
expr|struct
name|_Rational
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|rational
condition|)
block|{
if|if
condition|(
name|rational
operator|->
name|rational_array
condition|)
name|g_array_free
argument_list|(
name|rational
operator|->
name|rational_array
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rational
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * string_to_srational:  *  * @string:     a #gchar array  * @srational: a pointer to a #Rational struct  *  * converts a string, representing one/more srational values into  * a #SRational struct.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|string_to_srational (gchar * string,SRational ** srational)
name|string_to_srational
parameter_list|(
name|gchar
modifier|*
name|string
parameter_list|,
name|SRational
modifier|*
modifier|*
name|srational
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|nom
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|srats
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|SRational
modifier|*
name|srval
decl_stmt|;
name|GArray
modifier|*
name|srational_array
decl_stmt|;
name|srats
operator|=
name|g_strsplit
argument_list|(
name|string
argument_list|,
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|srats
index|[
name|count
index|]
condition|)
name|count
operator|++
expr_stmt|;
name|srational_array
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|SRationalValue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SRationalValue
name|or
decl_stmt|;
name|nom
operator|=
name|g_strsplit
argument_list|(
name|srats
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nom
index|[
literal|0
index|]
operator|&&
name|nom
index|[
literal|1
index|]
condition|)
block|{
name|or
operator|.
name|nom
operator|=
operator|(
name|gint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|or
operator|.
name|denom
operator|=
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|--
expr_stmt|;
name|srational_array
operator|=
name|g_array_append_val
argument_list|(
name|srational_array
argument_list|,
name|or
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|nom
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|srats
argument_list|)
expr_stmt|;
name|srval
operator|=
name|g_slice_new
argument_list|(
name|SRational
argument_list|)
expr_stmt|;
name|srval
operator|->
name|srational_array
operator|=
name|srational_array
expr_stmt|;
name|srval
operator|->
name|length
operator|=
name|count
expr_stmt|;
operator|*
name|srational
operator|=
name|srval
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * srational_copy:  *  * @data:          a #gpointer to a #SRational structure  *  * copy part of the #SRational type  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gpointer
DECL|function|srational_copy (gpointer data)
name|srational_copy
parameter_list|(
name|gpointer
name|data
parameter_list|)
block|{
name|struct
name|_SRational
modifier|*
name|srational
init|=
operator|(
expr|struct
name|_SRational
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|_SRational
modifier|*
name|copy
init|=
name|g_slice_new
argument_list|(
name|SRational
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GArray
modifier|*
name|rlacp
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
name|rlacp
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|SRationalValue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srational
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SRationalValue
name|or
decl_stmt|;
name|SRationalValue
name|cor
decl_stmt|;
name|or
operator|=
name|g_array_index
argument_list|(
name|srational
operator|->
name|srational_array
argument_list|,
name|SRationalValue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cor
operator|.
name|nom
operator|=
name|or
operator|.
name|nom
expr_stmt|;
name|cor
operator|.
name|denom
operator|=
name|or
operator|.
name|denom
expr_stmt|;
name|rlacp
operator|=
name|g_array_append_val
argument_list|(
name|rlacp
argument_list|,
name|cor
argument_list|)
expr_stmt|;
block|}
name|copy
operator|->
name|srational_array
operator|=
name|rlacp
expr_stmt|;
name|copy
operator|->
name|length
operator|=
name|srational
operator|->
name|length
expr_stmt|;
return|return
operator|(
name|gpointer
operator|)
name|copy
return|;
block|}
end_function

begin_comment
comment|/**  * srational_free:  *  * @data:          a #gpointer to a #SRational structure  *  * free part of the #SRational type  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|srational_free (gpointer data)
name|srational_free
parameter_list|(
name|gpointer
name|data
parameter_list|)
block|{
name|struct
name|_SRational
modifier|*
name|srational
init|=
operator|(
expr|struct
name|_SRational
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|srational
condition|)
block|{
if|if
condition|(
name|srational
operator|->
name|srational_array
condition|)
name|g_array_free
argument_list|(
name|srational
operator|->
name|srational_array
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|srational
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

