begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMPBASE - The GIMP Basic Library  * Copyright (C) 1995-1997 Peter Mattis and Spencer Kimball  *  * gimpmetadata.c  * Copyright (C) 2013 Hartmut Kuhse<hartmutkuhse@src.gnome.org>  *                    Michael Natterer<mitch@gimp.org>  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gio/gio.h>
end_include

begin_include
include|#
directive|include
file|<gexiv2/gexiv2.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"gimprational.h"
end_include

begin_include
include|#
directive|include
file|"gimpattribute.h"
end_include

begin_include
include|#
directive|include
file|"gimpbasetypes.h"
end_include

begin_include
include|#
directive|include
file|"gimplimits.h"
end_include

begin_include
include|#
directive|include
file|"gimpmetadata.h"
end_include

begin_include
include|#
directive|include
file|"gimpunit.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/libgimp-intl.h"
end_include

begin_typedef
DECL|typedef|GimpMetadataClass
typedef|typedef
name|struct
name|_GimpMetadataClass
name|GimpMetadataClass
typedef|;
end_typedef

begin_typedef
DECL|typedef|GimpMetadataPrivate
typedef|typedef
name|struct
name|_GimpMetadataPrivate
name|GimpMetadataPrivate
typedef|;
end_typedef

begin_struct
DECL|struct|_GimpMetadataPrivate
struct|struct
name|_GimpMetadataPrivate
block|{
DECL|member|attribute_table
name|GHashTable
modifier|*
name|attribute_table
decl_stmt|;
DECL|member|sorted_to_attribute
name|GHashTable
modifier|*
name|sorted_to_attribute
decl_stmt|;
DECL|member|sorted_key_list
name|GList
modifier|*
name|sorted_key_list
decl_stmt|;
DECL|member|xmp_structure_list
name|GSList
modifier|*
name|xmp_structure_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_GimpMetadata
struct|struct
name|_GimpMetadata
block|{
DECL|member|parent_instance
name|GExiv2Metadata
name|parent_instance
decl_stmt|;
DECL|member|priv
name|GimpMetadataPrivate
modifier|*
name|priv
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_GimpMetadataClass
struct|struct
name|_GimpMetadataClass
block|{
DECL|member|parent_class
name|GExiv2MetadataClass
name|parent_class
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|gimpmetadata_parent_class
specifier|static
name|gpointer
name|gimpmetadata_parent_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|current_attribute
specifier|static
name|GimpAttribute
modifier|*
name|current_attribute
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|iter_initialized
specifier|static
name|gboolean
name|iter_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|gimp_metadata_finalize
parameter_list|(
name|GObject
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpAttribute
modifier|*
name|gimp_metadata_get_attribute_sorted
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|sorted_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_deserialize_error
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
name|error
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GQuark
name|gimp_metadata_error_quark
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_deserialize_start_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_deserialize_text
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_deserialize_end_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|gchar
modifier|*
name|gimp_metadata_name_to_value
parameter_list|(
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|has_xmp_structure
parameter_list|(
name|GSList
modifier|*
name|xmp_list
parameter_list|,
specifier|const
name|gchar
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GExiv2Metadata
modifier|*
name|gimp_metadata_new_gexiv2metadata
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GimpAttribute
modifier|*
name|gimp_metadata_from_parent
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gimp_metadata_to_parent
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gimp_metadata_add_attribute_to_list
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gimp_metadata_from_gexiv2
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gimp_metadata_to_gexiv2
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|G_DEFINE_TYPE
argument_list|(
argument|GimpMetadata
argument_list|,
argument|gimp_metadata
argument_list|,
argument|GEXIV2_TYPE_METADATA
argument_list|)
end_macro

begin_define
DECL|macro|parent_class
define|#
directive|define
name|parent_class
value|gimp_metadata_parent_class
end_define

begin_decl_stmt
specifier|static
specifier|const
name|gchar
modifier|*
name|tiff_tags
index|[]
init|=
block|{
literal|"Xmp.tiff"
block|,
literal|"Exif.Image.ImageWidth"
block|,
literal|"Exif.Image.ImageLength"
block|,
literal|"Exif.Image.BitsPerSample"
block|,
literal|"Exif.Image.Compression"
block|,
literal|"Exif.Image.PhotometricInterpretation"
block|,
literal|"Exif.Image.FillOrder"
block|,
literal|"Exif.Image.SamplesPerPixel"
block|,
literal|"Exif.Image.StripOffsets"
block|,
literal|"Exif.Image.RowsPerStrip"
block|,
literal|"Exif.Image.StripByteCounts"
block|,
literal|"Exif.Image.PlanarConfiguration"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|jpeg_tags
specifier|static
specifier|const
name|gchar
modifier|*
name|jpeg_tags
index|[]
init|=
block|{
literal|"Exif.Image.JPEGProc"
block|,
literal|"Exif.Image.JPEGInterchangeFormat"
block|,
literal|"Exif.Image.JPEGInterchangeFormatLength"
block|,
literal|"Exif.Image.JPEGRestartInterval"
block|,
literal|"Exif.Image.JPEGLosslessPredictors"
block|,
literal|"Exif.Image.JPEGPointTransforms"
block|,
literal|"Exif.Image.JPEGQTables"
block|,
literal|"Exif.Image.JPEGDCTables"
block|,
literal|"Exif.Image.JPEGACTables"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|unsupported_tags
specifier|static
specifier|const
name|gchar
modifier|*
name|unsupported_tags
index|[]
init|=
block|{
literal|"Exif.Image.SubIFDs"
block|,
literal|"Exif.Image.ClipPath"
block|,
literal|"Exif.Image.XClipPathUnits"
block|,
literal|"Exif.Image.YClipPathUnits"
block|,
literal|"Exif.Image.XPTitle"
block|,
literal|"Exif.Image.XPComment"
block|,
literal|"Exif.Image.XPAuthor"
block|,
literal|"Exif.Image.XPKeywords"
block|,
literal|"Exif.Image.XPSubject"
block|,
literal|"Exif.Image.DNGVersion"
block|,
literal|"Exif.Image.DNGBackwardVersion"
block|,
literal|"Exif.Iop"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|minimal_exif
specifier|static
specifier|const
name|guint8
name|minimal_exif
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xd8
block|,
literal|0xff
block|,
literal|0xe0
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x4a
block|,
literal|0x46
block|,
literal|0x49
block|,
literal|0x46
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xe1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|wilber_jpg
specifier|static
specifier|const
name|guint8
name|wilber_jpg
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xd8
block|,
literal|0xff
block|,
literal|0xe0
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x4a
block|,
literal|0x46
block|,
literal|0x49
block|,
literal|0x46
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xdb
block|,
literal|0x00
block|,
literal|0x43
block|,
literal|0x00
block|,
literal|0x50
block|,
literal|0x37
block|,
literal|0x3c
block|,
literal|0x46
block|,
literal|0x3c
block|,
literal|0x32
block|,
literal|0x50
block|,
literal|0x46
block|,
literal|0x41
block|,
literal|0x46
block|,
literal|0x5a
block|,
literal|0x55
block|,
literal|0x50
block|,
literal|0x5f
block|,
literal|0x78
block|,
literal|0xc8
block|,
literal|0x82
block|,
literal|0x78
block|,
literal|0x6e
block|,
literal|0x6e
block|,
literal|0x78
block|,
literal|0xf5
block|,
literal|0xaf
block|,
literal|0xb9
block|,
literal|0x91
block|,
literal|0xc8
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xdb
block|,
literal|0x00
block|,
literal|0x43
block|,
literal|0x01
block|,
literal|0x55
block|,
literal|0x5a
block|,
literal|0x5a
block|,
literal|0x78
block|,
literal|0x69
block|,
literal|0x78
block|,
literal|0xeb
block|,
literal|0x82
block|,
literal|0x82
block|,
literal|0xeb
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xc0
block|,
literal|0x00
block|,
literal|0x11
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x22
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x11
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x16
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x1e
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x31
block|,
literal|0x04
block|,
literal|0x12
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0x71
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x14
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x14
block|,
literal|0x11
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xda
block|,
literal|0x00
block|,
literal|0x0c
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x11
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x00
block|,
literal|0x3f
block|,
literal|0x00
block|,
literal|0x18
block|,
literal|0xa0
block|,
literal|0x0e
block|,
literal|0x6d
block|,
literal|0xbc
block|,
literal|0xf5
block|,
literal|0xca
block|,
literal|0xf7
block|,
literal|0x78
block|,
literal|0xb6
block|,
literal|0xfe
block|,
literal|0x3b
block|,
literal|0x23
block|,
literal|0xb2
block|,
literal|0x1d
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0xf0
block|,
literal|0x8a
block|,
literal|0x39
block|,
literal|0x4b
block|,
literal|0x74
block|,
literal|0x9c
block|,
literal|0xa5
block|,
literal|0x5f
block|,
literal|0x35
block|,
literal|0x8a
block|,
literal|0xb2
block|,
literal|0x7e
block|,
literal|0xa0
block|,
literal|0xff
block|,
literal|0xd9
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|guint
name|wilber_jpg_len
init|=
name|G_N_ELEMENTS
argument_list|(
name|wilber_jpg
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon299198650108
block|{
DECL|member|name
name|gchar
name|name
index|[
literal|1024
index|]
decl_stmt|;
DECL|member|base64
name|gboolean
name|base64
decl_stmt|;
DECL|member|type
name|GimpAttributeValueType
name|type
decl_stmt|;
DECL|member|metadata
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
DECL|typedef|GimpMetadataParseData
block|}
name|GimpMetadataParseData
typedef|;
end_typedef

begin_struct
DECL|struct|Namespaces
struct|struct
name|Namespaces
block|{
DECL|member|namespace_name
specifier|const
name|gchar
modifier|*
name|namespace_name
decl_stmt|;
DECL|member|namespace_URI
specifier|const
name|gchar
modifier|*
name|namespace_URI
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|namespaces_table
name|struct
name|Namespaces
name|namespaces_table
index|[]
init|=
block|{
block|{
literal|"gimp"
block|,
literal|"http://www.gimp.org/ns/2.10/"
block|}
block|,
block|{
literal|"dwc"
block|,
literal|"http://rs.tdwg.org/dwc/terms/"
block|}
block|,
block|{
literal|"lr"
block|,
literal|"http://ns.adobe.com/lr/1.0/"
block|}
block|,
block|{
literal|"gpano"
block|,
literal|"http://ns.google.com/photos/1.0/panorama/"
block|}
block|,
block|{
literal|"panorama"
block|,
literal|"http://ns.adobe.com/photoshop/1.0/panorama-profile/"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
DECL|function|gimp_metadata_class_init (GimpMetadataClass * klass)
specifier|static
name|void
name|gimp_metadata_class_init
parameter_list|(
name|GimpMetadataClass
modifier|*
name|klass
parameter_list|)
block|{
name|gimpmetadata_parent_class
operator|=
name|g_type_class_peek_parent
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|g_type_class_add_private
argument_list|(
name|klass
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpMetadataPrivate
argument_list|)
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
operator|->
name|get_property
operator|=
name|gimp_metadata_get_property
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
operator|->
name|set_property
operator|=
name|gimp_metadata_set_property
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
operator|->
name|finalize
operator|=
name|gimp_metadata_finalize
expr_stmt|;
block|}
end_function

begin_function
DECL|function|gimp_metadata_init (GimpMetadata * self)
specifier|static
name|void
name|gimp_metadata_init
parameter_list|(
name|GimpMetadata
modifier|*
name|self
parameter_list|)
block|{
name|self
operator|->
name|priv
operator|=
name|GIMP_METADATA_GET_PRIVATE
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|self
operator|->
name|priv
operator|->
name|attribute_table
operator|=
name|g_hash_table_new_full
argument_list|(
name|g_str_hash
argument_list|,
name|g_str_equal
argument_list|,
name|g_free
argument_list|,
name|g_object_unref
argument_list|)
expr_stmt|;
name|self
operator|->
name|priv
operator|->
name|sorted_to_attribute
operator|=
name|g_hash_table_new_full
argument_list|(
name|g_str_hash
argument_list|,
name|g_str_equal
argument_list|,
name|g_free
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|self
operator|->
name|priv
operator|->
name|sorted_key_list
operator|=
name|NULL
expr_stmt|;
name|self
operator|->
name|priv
operator|->
name|xmp_structure_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_finalize:  *  * instance finalizer  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_finalize (GObject * obj)
name|gimp_metadata_finalize
parameter_list|(
name|GObject
modifier|*
name|obj
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
name|metadata
operator|=
name|G_TYPE_CHECK_INSTANCE_CAST
argument_list|(
name|obj
argument_list|,
name|TYPE_GIMP_METADATA
argument_list|,
name|GimpMetadata
argument_list|)
expr_stmt|;
name|g_hash_table_unref
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
argument_list|)
expr_stmt|;
name|g_hash_table_unref
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_to_attribute
argument_list|)
expr_stmt|;
name|g_list_free_full
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_free
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|xmp_structure_list
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|gimpmetadata_parent_class
argument_list|)
operator|->
name|finalize
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_property  *  * instance get property  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_get_property (GObject * object,guint property_id,GValue * value,GParamSpec * pspec)
name|gimp_metadata_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * gimp_metadata_set_property  *  * instance set property  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_set_property (GObject * object,guint property_id,const GValue * value,GParamSpec * pspec)
name|gimp_metadata_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * gimp_metadata_new:  *  * returns a new #GimpMetadata object  *  * Return value:  a new @GimpMetadata object  *  * Since : 2.10  */
end_comment

begin_function
name|GimpMetadata
modifier|*
DECL|function|gimp_metadata_new (void)
name|gimp_metadata_new
parameter_list|(
name|void
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|new_metadata
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|gexiv2_initialize
argument_list|()
condition|)
block|{
name|new_metadata
operator|=
name|g_object_new
argument_list|(
name|TYPE_GIMP_METADATA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_initialize
argument_list|()
condition|)
block|{
if|if
condition|(
name|gexiv2_metadata_open_buf
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|new_metadata
argument_list|)
argument_list|,
name|wilber_jpg
argument_list|,
name|wilber_jpg_len
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
name|gexiv2_metadata_register_xmp_namespace
argument_list|(
name|n_space
operator|.
name|namespace_URI
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|new_metadata
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_size: ToDo handle size  *  * @metadata: a #GimpMetadata  *  * Return value:  a #gint: amount of #GimpAttribute objects in  * the #GimpMetadata container  *  * Since : 2.10  */
end_comment

begin_function
name|gint
DECL|function|gimp_metadata_size (GimpMetadata * metadata)
name|gimp_metadata_size
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|GimpMetadataPrivate
modifier|*
name|private
init|=
name|GIMP_METADATA_GET_PRIVATE
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
return|return
name|g_hash_table_size
argument_list|(
name|private
operator|->
name|attribute_table
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_duplicate:  *  * @metadata: a #GimpMetadata  *  * Duplicates the #GimpMetadata object with all the #GimpAttribute objects  * Return value:  a copy of the @metadata object  *  * Since : 2.10  */
end_comment

begin_function
name|GimpMetadata
modifier|*
DECL|function|gimp_metadata_duplicate (GimpMetadata * metadata)
name|gimp_metadata_duplicate
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|new_metadata
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
condition|)
block|{
name|gchar
modifier|*
name|xml
decl_stmt|;
name|xml
operator|=
name|gimp_metadata_serialize
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|new_metadata
operator|=
name|gimp_metadata_deserialize
argument_list|(
name|xml
argument_list|)
expr_stmt|;
block|}
return|return
name|new_metadata
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_table:  *  * @metadata: a #GimpMetadata  *  * Return value:  the #GHashTable  *  * Since : 2.10  */
end_comment

begin_function
name|GHashTable
modifier|*
DECL|function|gimp_metadata_get_table (GimpMetadata * metadata)
name|gimp_metadata_get_table
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
return|return
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_add_attribute:  *  * @metadata  : a #GimpMetadata  * @attribute : a #GimpAttribute  *  * stores the @attribute in the @metadata container  *  * Since : 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_add_attribute (GimpMetadata * metadata,GimpAttribute * attribute)
name|gimp_metadata_add_attribute
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
name|gchar
modifier|*
name|lowchar
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: really simply add? That means, that an older value is overwritten */
if|if
condition|(
name|g_hash_table_insert
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|lowchar
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|attribute
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|sortable_tag
decl_stmt|;
name|sortable_tag
operator|=
name|g_ascii_strdown
argument_list|(
name|gimp_attribute_get_sortable_name
argument_list|(
name|attribute
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_hash_table_insert
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_to_attribute
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|sortable_tag
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|lowchar
argument_list|)
argument_list|)
condition|)
block|{
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
operator|=
name|g_list_insert_sorted
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|sortable_tag
argument_list|)
argument_list|,
operator|(
name|GCompareFunc
operator|)
name|g_strcmp0
argument_list|)
expr_stmt|;
name|gimp_metadata_to_parent
argument_list|(
name|metadata
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_hash_table_remove
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|lowchar
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|sortable_tag
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_attribute:  *  * @metadata : a #GimpMetadata  * @name     : a #gchar array  *  * gets the #GimpAttribute object with @name  *  * Return value: the #GimpAttribute object if found, NULL otherwise.  *  * Since : 2.10  */
end_comment

begin_function
name|GimpAttribute
modifier|*
DECL|function|gimp_metadata_get_attribute (GimpMetadata * metadata,const gchar * name)
name|gimp_metadata_get_attribute
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|attribute_data
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|attribute_data
operator|=
name|gimp_metadata_from_parent
argument_list|(
name|metadata
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|attribute_data
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_attribute_sorted:  *  * @metadata: a #GimpMetadata  * @name : a #gchar array  *  * gets the #GimpAttribute object with @sorted_name as  * sortable_name  * see GimpAttribute::get_sortable_name  *  * Return value: the #GimpAttribute object if found, NULL otherwise.  *  * Since : 2.10  */
end_comment

begin_function
specifier|static
name|GimpAttribute
modifier|*
DECL|function|gimp_metadata_get_attribute_sorted (GimpMetadata * metadata,const gchar * sorted_name)
name|gimp_metadata_get_attribute_sorted
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|sorted_name
parameter_list|)
block|{
name|gchar
modifier|*
name|lowchar
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute_data
init|=
name|NULL
decl_stmt|;
name|gpointer
modifier|*
name|data
decl_stmt|;
name|gchar
modifier|*
name|name_of_tag
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|sorted_name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|sorted_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_hash_table_lookup
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_to_attribute
argument_list|,
operator|(
name|gpointer
operator|)
name|lowchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|name_of_tag
operator|=
operator|(
name|gchar
operator|*
operator|)
name|data
expr_stmt|;
name|data
operator|=
name|g_hash_table_lookup
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
argument_list|,
operator|(
name|gpointer
operator|)
name|name_of_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|attribute_data
operator|=
operator|(
name|GimpAttribute
operator|*
operator|)
name|data
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
return|return
name|attribute_data
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_remove_attribute: ToDo remove from gexiv2 ToDo rewrite  *  * @metadata : a #GimpMetadata  * @name     : a #gchar array  *  * removes the #GimpAttribute object with @name from the @metadata container  *  * Return value: TRUE, if removing was successful, FALSE otherwise.  *  * Since : 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_remove_attribute (GimpMetadata * metadata,const gchar * name)
name|gimp_metadata_remove_attribute
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|gchar
modifier|*
name|lowchar
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|GHashTableIter
name|iter_remove
decl_stmt|;
name|gpointer
name|key
decl_stmt|,
name|value
decl_stmt|;
name|gchar
modifier|*
name|tag_to_remove
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|name_of_tag
init|=
name|NULL
decl_stmt|;
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_hash_table_remove
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
argument_list|,
operator|(
name|gpointer
operator|)
name|lowchar
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|tag_list_remove
init|=
name|NULL
decl_stmt|;
name|g_hash_table_iter_init
argument_list|(
operator|&
name|iter_remove
argument_list|,
name|metadata
operator|->
name|priv
operator|->
name|sorted_to_attribute
argument_list|)
expr_stmt|;
while|while
condition|(
name|g_hash_table_iter_next
argument_list|(
operator|&
name|iter_remove
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|tag_to_remove
operator|=
operator|(
name|gchar
operator|*
operator|)
name|key
expr_stmt|;
name|name_of_tag
operator|=
operator|(
name|gchar
operator|*
operator|)
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
name|name_of_tag
argument_list|)
condition|)
break|break;
block|}
name|tag_list_remove
operator|=
name|g_strdup
argument_list|(
name|tag_to_remove
argument_list|)
expr_stmt|;
comment|/* because removing from hashtable frees tag_to_remove */
if|if
condition|(
name|g_hash_table_remove
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_to_attribute
argument_list|,
operator|(
name|gpointer
operator|)
name|tag_to_remove
argument_list|)
condition|)
block|{
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|list
operator|=
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|gchar
modifier|*
name|s_tag
init|=
operator|(
name|gchar
operator|*
operator|)
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|s_tag
argument_list|,
name|tag_list_remove
argument_list|)
condition|)
block|{
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
operator|=
name|g_list_remove
argument_list|(
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
argument_list|,
operator|(
name|gconstpointer
operator|)
name|s_tag
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|s_tag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|g_free
argument_list|(
name|tag_list_remove
argument_list|)
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name_of_tag
condition|)
name|g_free
argument_list|(
name|name_of_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_to_remove
condition|)
name|g_free
argument_list|(
name|tag_to_remove
argument_list|)
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_has_attribute:  *  * @metadata : a #GimpMetadata  * @name     : a #gchar array  *  * tests, if a #GimpAttribute object with @name is in the @metadata container  *  * Return value: TRUE if yes, FALSE otherwise.  *  * Since : 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_has_attribute (GimpMetadata * metadata,const gchar * name)
name|gimp_metadata_has_attribute
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|gchar
modifier|*
name|lowchar
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|success
operator|=
name|gexiv2_metadata_has_tag
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_new_attribute:  *  * @metadata: a #GimpMetadata  * @name    : a #gchar array  * @value   : a #gchar array  * @type    : a #GimpAttributeValueType  *  * adds a #GimpAttribute object to @metadata container.  * The #GimpAttribute object is created from the  * @name,  * @value and  * @type parameters.  *  * Return value: TRUE if successful, FALSE otherwise.  *  * Since : 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_new_attribute (GimpMetadata * metadata,const gchar * name,gchar * value,GimpAttributeValueType type)
name|gimp_metadata_new_attribute
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|,
name|GimpAttributeValueType
name|type
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
name|gimp_metadata_add_attribute
argument_list|(
name|metadata
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_serialize: ToDo handle old metadata and get data from sorted list -> attributes.c  *  * @metadata: a #GimpMetadata  *  * creates a xml representation of all #GimpAttribute objects in the #GimpMetadata container.  * see #GimpAttribute:gimp_attribute_get_xml  *  * Return value: a new #gchar array, the xml representation of the #GimpMetadata object.  *  * Since : 2.10  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_metadata_serialize (GimpMetadata * metadata)
name|gimp_metadata_serialize
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|GString
modifier|*
name|string
decl_stmt|;
name|GList
modifier|*
name|key_list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_metadata_from_gexiv2
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<?xml version='1.0' encoding='UTF-8'?>\n"
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<metadata>\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|key_list
operator|=
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
init|;
name|key_list
condition|;
name|key_list
operator|=
name|key_list
operator|->
name|next
control|)
block|{
name|gchar
modifier|*
name|xml
init|=
name|NULL
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|p_key
init|=
operator|(
name|gchar
operator|*
operator|)
name|key_list
operator|->
name|data
decl_stmt|;
name|attribute
operator|=
name|gimp_metadata_get_attribute_sorted
argument_list|(
name|metadata
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
name|xml
operator|=
name|gimp_attribute_get_xml
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%s\n"
argument_list|,
name|xml
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|xml
argument_list|)
expr_stmt|;
block|}
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"</metadata>\n"
argument_list|)
expr_stmt|;
return|return
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_deserialize:  *  * @xml: a #gchar array  *  * parses a xml representation of a #GimpMetadata container.  * see  * #GimpMetadata:gimp_metadata_deserialize_start_element  * #GimpMetadata:gimp_metadata_deserialize_end_element  * #GimpMetadata:gimp_metadata_deserialize_text  * #GimpMetadata:gimp_metadata_deserialize_error  *  * Return value: a new #GimpMetadata object.  *  * Since : 2.10  */
end_comment

begin_function
name|GimpMetadata
modifier|*
DECL|function|gimp_metadata_deserialize (const gchar * xml)
name|gimp_metadata_deserialize
parameter_list|(
specifier|const
name|gchar
modifier|*
name|xml
parameter_list|)
block|{
name|GMarkupParser
modifier|*
name|markup_parser
init|=
name|g_slice_new
argument_list|(
name|GMarkupParser
argument_list|)
decl_stmt|;
name|GimpMetadataParseData
modifier|*
name|parse_data
init|=
name|g_slice_new
argument_list|(
name|GimpMetadataParseData
argument_list|)
decl_stmt|;
name|GMarkupParseContext
modifier|*
name|context
decl_stmt|;
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xml
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|metadata
operator|=
name|gimp_metadata_new
argument_list|()
expr_stmt|;
name|parse_data
operator|->
name|metadata
operator|=
name|metadata
expr_stmt|;
name|markup_parser
operator|->
name|start_element
operator|=
name|gimp_metadata_deserialize_start_element
expr_stmt|;
name|markup_parser
operator|->
name|end_element
operator|=
name|gimp_metadata_deserialize_end_element
expr_stmt|;
name|markup_parser
operator|->
name|text
operator|=
name|gimp_metadata_deserialize_text
expr_stmt|;
name|markup_parser
operator|->
name|passthrough
operator|=
name|NULL
expr_stmt|;
name|markup_parser
operator|->
name|error
operator|=
name|gimp_metadata_deserialize_error
expr_stmt|;
name|context
operator|=
name|g_markup_parse_context_new
argument_list|(
name|markup_parser
argument_list|,
literal|0
argument_list|,
name|parse_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_markup_parse_context_parse
argument_list|(
name|context
argument_list|,
name|xml
argument_list|,
name|strlen
argument_list|(
name|xml
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_markup_parse_context_unref
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|GMarkupParser
argument_list|,
name|markup_parser
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|GimpMetadataParseData
argument_list|,
name|parse_data
argument_list|)
expr_stmt|;
return|return
name|metadata
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_from_gexiv2metadata:  * @metadata:  The metadata the gexiv2metadata will be added to, may be %NULL  * @gexiv2metadata:  The metadata in gexiv2 format  *  * Converts the @gexiv2metadata retrieved from a file into  * a #GimpMetadata object  *  * Return value: The #GimpMetadata object  *  * Since: GIMP 2.10  */
end_comment

begin_comment
comment|//GimpMetadata *
end_comment

begin_comment
comment|//gimp_metadata_from_gexiv2metadata (GimpMetadata   *metadata,
end_comment

begin_comment
comment|//                                   GimpMetadata   *gexivdata)
end_comment

begin_comment
comment|//{
end_comment

begin_comment
comment|//  const gchar               *tag_type;
end_comment

begin_comment
comment|//  GimpAttribute             *attribute;
end_comment

begin_comment
comment|//  GimpAttributeValueType     attrib_type;
end_comment

begin_comment
comment|//  gint                       i;
end_comment

begin_comment
comment|//  GimpMetadata              *new_metadata    = NULL;
end_comment

begin_comment
comment|//  GExiv2Metadata            *gexiv2metadata  = NULL;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  gexiv2metadata = GEXIV2_METADATA(gexivdata);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  if (!metadata)
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      new_metadata = gimp_metadata_new ();
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//  else
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      new_metadata = gimp_metadata_duplicate (metadata);
end_comment

begin_comment
comment|//      g_object_unref (metadata);
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  if (new_metadata)
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      gchar    **exif_data;
end_comment

begin_comment
comment|//      gchar    **xmp_data;
end_comment

begin_comment
comment|//      gchar    **iptc_data;
end_comment

begin_comment
comment|//      gboolean   no_interpreted    = TRUE; /*FIXME: No interpreted String possible */
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      exif_data = gexiv2_metadata_get_exif_tags (gexiv2metadata);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      for (i = 0; exif_data[i] != NULL; i++)
end_comment

begin_comment
comment|//        {
end_comment

begin_comment
comment|//          gchar    *interpreted_value = NULL;
end_comment

begin_comment
comment|//          gchar    *value             = NULL;
end_comment

begin_comment
comment|//          gboolean  interpreted       = FALSE;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          value = gexiv2_metadata_get_tag_string (gexiv2metadata, exif_data[i]);
end_comment

begin_comment
comment|//          interpreted_value = gexiv2_metadata_get_tag_interpreted_string (gexiv2metadata, exif_data[i]);
end_comment

begin_comment
comment|//          tag_type = gexiv2_metadata_get_tag_type (exif_data[i]);
end_comment

begin_comment
comment|//          attrib_type = gimp_attribute_get_value_type_from_string (tag_type);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          interpreted = g_strcmp0 (value, interpreted_value);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          if (!interpreted)
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              gint length;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//              length = strlen (interpreted_value);
end_comment

begin_comment
comment|//              if (length> 2048)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  g_free (interpreted_value);
end_comment

begin_comment
comment|//                  interpreted_value = g_strdup_printf ("(Size of value: %d)", length);
end_comment

begin_comment
comment|//                  interpreted = TRUE;
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          attribute = gimp_attribute_new_string (exif_data[i], value, attrib_type);
end_comment

begin_comment
comment|//          if (gimp_attribute_is_valid (attribute))
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              if (no_interpreted)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  if (interpreted)
end_comment

begin_comment
comment|//                    {
end_comment

begin_comment
comment|//                      gimp_attribute_set_interpreted_string (attribute, interpreted_value);
end_comment

begin_comment
comment|//                    }
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//              gimp_metadata_add_attribute (new_metadata, attribute);
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//          else
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              g_object_unref (attribute);
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          g_free (interpreted_value);
end_comment

begin_comment
comment|//          g_free (value);
end_comment

begin_comment
comment|//        }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      g_strfreev (exif_data);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      xmp_data = gexiv2_metadata_get_xmp_tags (gexiv2metadata);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      for (i = 0; xmp_data[i] != NULL; i++)
end_comment

begin_comment
comment|//        {
end_comment

begin_comment
comment|//          gchar    *interpreted_value = NULL;
end_comment

begin_comment
comment|//          gchar    *value             = NULL;
end_comment

begin_comment
comment|//          gboolean  interpreted       = FALSE;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          value = gexiv2_metadata_get_tag_string (gexiv2metadata, xmp_data[i]);
end_comment

begin_comment
comment|//          interpreted_value = gexiv2_metadata_get_tag_interpreted_string (gexiv2metadata, xmp_data[i]);
end_comment

begin_comment
comment|//          tag_type = gexiv2_metadata_get_tag_type (xmp_data[i]);
end_comment

begin_comment
comment|//          attrib_type = gimp_attribute_get_value_type_from_string (tag_type);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          interpreted = g_strcmp0 (value, interpreted_value);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          attribute = gimp_attribute_new_string (xmp_data[i], value, attrib_type);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          if (gimp_attribute_is_valid (attribute))
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              if (no_interpreted)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  if (interpreted)
end_comment

begin_comment
comment|//                    gimp_attribute_set_interpreted_string (attribute, interpreted_value);
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//              gimp_metadata_add_attribute (new_metadata, attribute);
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//          else
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              g_object_unref (attribute);
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          g_free (value);
end_comment

begin_comment
comment|//        }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      g_strfreev (xmp_data);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      iptc_data = gexiv2_metadata_get_iptc_tags (gexiv2metadata);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      for (i = 0; iptc_data[i] != NULL; i++)
end_comment

begin_comment
comment|//        {
end_comment

begin_comment
comment|//          gchar    *interpreted_value = NULL;
end_comment

begin_comment
comment|//          gchar    *value             = NULL;
end_comment

begin_comment
comment|//          gboolean  interpreted       = FALSE;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          value = gexiv2_metadata_get_tag_string (gexiv2metadata, iptc_data[i]);
end_comment

begin_comment
comment|//          interpreted_value = gexiv2_metadata_get_tag_interpreted_string (gexiv2metadata, iptc_data[i]);
end_comment

begin_comment
comment|//          tag_type = gexiv2_metadata_get_tag_type (iptc_data[i]);
end_comment

begin_comment
comment|//          attrib_type = gimp_attribute_get_value_type_from_string (tag_type);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          interpreted = g_strcmp0 (value, interpreted_value);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          attribute = gimp_attribute_new_string (iptc_data[i], value, attrib_type);
end_comment

begin_comment
comment|//          if (gimp_attribute_is_valid (attribute))
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              if (no_interpreted)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  if (interpreted)
end_comment

begin_comment
comment|//                    gimp_attribute_set_interpreted_string (attribute, interpreted_value);
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//              gimp_metadata_add_attribute (new_metadata, attribute);
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//          else
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              g_object_unref (attribute);
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          g_free (value);
end_comment

begin_comment
comment|//        }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      g_strfreev (iptc_data);
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//  return new_metadata;
end_comment

begin_comment
comment|//}
end_comment

begin_comment
comment|/**  * gimp_metadata_from_gexiv2:  * @metadata:  The metadata  *  * Constructs the @metadata retrieved from the gexiv2 package.  *  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_from_gexiv2 (GimpMetadata * metadata)
name|gimp_metadata_from_gexiv2
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|tag_type
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|GimpAttributeValueType
name|attrib_type
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|gexiv2metadata
init|=
name|NULL
decl_stmt|;
name|GimpMetadataPrivate
modifier|*
name|priv
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|=
name|GIMP_METADATA_GET_PRIVATE
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|attribute_table
condition|)
name|g_hash_table_unref
argument_list|(
name|priv
operator|->
name|attribute_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|sorted_to_attribute
condition|)
name|g_hash_table_unref
argument_list|(
name|priv
operator|->
name|sorted_to_attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|sorted_key_list
condition|)
name|g_list_free_full
argument_list|(
name|priv
operator|->
name|sorted_key_list
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|xmp_structure_list
condition|)
name|g_slist_free
argument_list|(
name|priv
operator|->
name|xmp_structure_list
argument_list|)
expr_stmt|;
name|priv
operator|->
name|attribute_table
operator|=
name|g_hash_table_new_full
argument_list|(
name|g_str_hash
argument_list|,
name|g_str_equal
argument_list|,
name|g_free
argument_list|,
name|g_object_unref
argument_list|)
expr_stmt|;
name|priv
operator|->
name|sorted_to_attribute
operator|=
name|g_hash_table_new_full
argument_list|(
name|g_str_hash
argument_list|,
name|g_str_equal
argument_list|,
name|g_free
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|priv
operator|->
name|sorted_key_list
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|xmp_structure_list
operator|=
name|NULL
expr_stmt|;
name|gexiv2metadata
operator|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|{
name|gchar
modifier|*
modifier|*
name|exif_data
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|xmp_data
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|iptc_data
decl_stmt|;
name|gboolean
name|no_interpreted
init|=
name|TRUE
decl_stmt|;
comment|/*FIXME: No interpreted String possible */
name|exif_data
operator|=
name|gexiv2_metadata_get_exif_tags
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|exif_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|interpreted_value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gboolean
name|interpreted
init|=
name|FALSE
decl_stmt|;
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|exif_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|interpreted_value
operator|=
name|gexiv2_metadata_get_tag_interpreted_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|exif_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tag_type
operator|=
name|gexiv2_metadata_get_tag_type
argument_list|(
name|exif_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|attrib_type
operator|=
name|gimp_attribute_get_value_type_from_string
argument_list|(
name|tag_type
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|g_strcmp0
argument_list|(
name|value
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interpreted
condition|)
block|{
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|interpreted_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|2048
condition|)
block|{
name|g_free
argument_list|(
name|interpreted_value
argument_list|)
expr_stmt|;
name|interpreted_value
operator|=
name|g_strdup_printf
argument_list|(
literal|"(Size of value: %d)"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|exif_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|,
name|attrib_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_attribute_is_valid
argument_list|(
name|attribute
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_interpreted
condition|)
block|{
if|if
condition|(
name|interpreted
condition|)
block|{
name|gimp_attribute_set_interpreted_string
argument_list|(
name|attribute
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_metadata_add_attribute_to_list
argument_list|(
name|metadata
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_object_unref
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|interpreted_value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|exif_data
argument_list|)
expr_stmt|;
name|xmp_data
operator|=
name|gexiv2_metadata_get_xmp_tags
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|interpreted_value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gboolean
name|interpreted
init|=
name|FALSE
decl_stmt|;
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|xmp_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|interpreted_value
operator|=
name|gexiv2_metadata_get_tag_interpreted_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|xmp_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tag_type
operator|=
name|gexiv2_metadata_get_tag_type
argument_list|(
name|xmp_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|attrib_type
operator|=
name|gimp_attribute_get_value_type_from_string
argument_list|(
name|tag_type
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|g_strcmp0
argument_list|(
name|value
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|xmp_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|,
name|attrib_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_attribute_is_valid
argument_list|(
name|attribute
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_interpreted
condition|)
block|{
if|if
condition|(
name|interpreted
condition|)
name|gimp_attribute_set_interpreted_string
argument_list|(
name|attribute
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
block|}
name|gimp_metadata_add_attribute_to_list
argument_list|(
name|metadata
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_object_unref
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|xmp_data
argument_list|)
expr_stmt|;
name|iptc_data
operator|=
name|gexiv2_metadata_get_iptc_tags
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|iptc_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|interpreted_value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gboolean
name|interpreted
init|=
name|FALSE
decl_stmt|;
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|iptc_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|interpreted_value
operator|=
name|gexiv2_metadata_get_tag_interpreted_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|iptc_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tag_type
operator|=
name|gexiv2_metadata_get_tag_type
argument_list|(
name|iptc_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|attrib_type
operator|=
name|gimp_attribute_get_value_type_from_string
argument_list|(
name|tag_type
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|g_strcmp0
argument_list|(
name|value
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|iptc_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|,
name|attrib_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_attribute_is_valid
argument_list|(
name|attribute
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_interpreted
condition|)
block|{
if|if
condition|(
name|interpreted
condition|)
name|gimp_attribute_set_interpreted_string
argument_list|(
name|attribute
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
block|}
name|gimp_metadata_add_attribute
argument_list|(
name|metadata
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_object_unref
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|iptc_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_add_list:  *  * @metadata  : a #GimpMetadata  * @attribute : a #GimpAttribute  *  * stores the @attribute in the @metadata container  *  * Since : 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_add_attribute_to_list (GimpMetadata * metadata,GimpAttribute * attribute)
name|gimp_metadata_add_attribute_to_list
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
name|gchar
modifier|*
name|lowchar
decl_stmt|;
name|GimpMetadataPrivate
modifier|*
name|priv
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|=
name|GIMP_METADATA_GET_PRIVATE
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|name
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: really simply add? That means, that an older value is overwritten */
if|if
condition|(
name|g_hash_table_insert
argument_list|(
name|priv
operator|->
name|attribute_table
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|lowchar
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|attribute
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|sortable_tag
decl_stmt|;
name|sortable_tag
operator|=
name|g_ascii_strdown
argument_list|(
name|gimp_attribute_get_sortable_name
argument_list|(
name|attribute
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_hash_table_insert
argument_list|(
name|priv
operator|->
name|sorted_to_attribute
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|sortable_tag
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|lowchar
argument_list|)
argument_list|)
condition|)
block|{
name|priv
operator|->
name|sorted_key_list
operator|=
name|g_list_insert_sorted
argument_list|(
name|priv
operator|->
name|sorted_key_list
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|sortable_tag
argument_list|)
argument_list|,
operator|(
name|GCompareFunc
operator|)
name|g_strcmp0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_hash_table_remove
argument_list|(
name|priv
operator|->
name|attribute_table
argument_list|,
operator|(
name|gpointer
operator|)
name|g_strdup
argument_list|(
name|lowchar
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|sortable_tag
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_from_parent:  * @metadata:  The metadata the gexiv2metadata will be added to, may be %NULL  * @gexiv2metadata:  The metadata in gexiv2 format  *  * Converts the @gexiv2metadata retrieved from a file into  * a #GimpMetadata object  *  * Return value: The #GimpMetadata object  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|GimpAttribute
modifier|*
DECL|function|gimp_metadata_from_parent (GimpMetadata * metadata,const gchar * name)
name|gimp_metadata_from_parent
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|tag_type
decl_stmt|;
name|gboolean
name|no_interpreted
init|=
name|TRUE
decl_stmt|;
comment|/*FIXME: No interpreted String possible */
name|gchar
modifier|*
name|interpreted_value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gboolean
name|interpreted
init|=
name|FALSE
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|GimpAttributeValueType
name|attrib_type
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|gexiv2metadata
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gexiv2metadata
operator|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|interpreted_value
operator|=
name|gexiv2_metadata_get_tag_interpreted_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tag_type
operator|=
name|gexiv2_metadata_get_tag_type
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|attrib_type
operator|=
name|gimp_attribute_get_value_type_from_string
argument_list|(
name|tag_type
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|g_strcmp0
argument_list|(
name|value
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interpreted
condition|)
block|{
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|interpreted_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|2048
condition|)
block|{
name|g_free
argument_list|(
name|interpreted_value
argument_list|)
expr_stmt|;
name|interpreted_value
operator|=
name|g_strdup_printf
argument_list|(
literal|"(Size of value: %d)"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|attrib_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_attribute_is_valid
argument_list|(
name|attribute
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_interpreted
condition|)
block|{
if|if
condition|(
name|interpreted
condition|)
block|{
name|gimp_attribute_set_interpreted_string
argument_list|(
name|attribute
argument_list|,
name|interpreted_value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|g_object_unref
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|interpreted_value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|attribute
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_print:  * @metadata:  The #GimpMetadata  *  * prints out information of metadata  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_print (GimpMetadata * metadata)
name|gimp_metadata_print
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|GList
modifier|*
name|key_list
init|=
name|NULL
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_metadata_from_gexiv2
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|key_list
operator|=
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
init|;
name|key_list
condition|;
name|key_list
operator|=
name|key_list
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|interpreted
decl_stmt|;
name|gchar
modifier|*
name|value
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|gchar
modifier|*
name|p_key
init|=
operator|(
name|gchar
operator|*
operator|)
name|key_list
operator|->
name|data
decl_stmt|;
name|attribute
operator|=
name|gimp_metadata_get_attribute_sorted
argument_list|(
name|metadata
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
name|tag
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_attribute_get_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|gimp_attribute_get_interpreted_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"%p: %s\n%04d. Tag: %s\n\tValue:%s\n\tInterpreted value:%s\n"
argument_list|,
name|attribute
argument_list|,
name|p_key
argument_list|,
name|i
argument_list|,
name|tag
argument_list|,
name|value
argument_list|,
name|interpreted
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_to_gexiv2metadata:  * @metadata:  The #GimpMetadata  * @gexiv2metadata:  The #GimpMetadata  * @mime_type: the mime type of the image  *  * Converts @metadata to @gexiv2metadata in gexiv2 format  *  * Since: GIMP 2.10  */
end_comment

begin_comment
comment|//void
end_comment

begin_comment
comment|//gimp_metadata_to_gexiv2metadata (GimpMetadata   *metadata,
end_comment

begin_comment
comment|//                                 GimpMetadata   *gexivdata,
end_comment

begin_comment
comment|//                                 const gchar    *mime_type)
end_comment

begin_comment
comment|//{
end_comment

begin_comment
comment|//  gchar          *o_packet            = NULL;
end_comment

begin_comment
comment|//  gboolean        write_tag           = FALSE;
end_comment

begin_comment
comment|//  gboolean        namespace           = FALSE;
end_comment

begin_comment
comment|//  gboolean        check_mime          = TRUE;
end_comment

begin_comment
comment|//  gboolean        support_exif;
end_comment

begin_comment
comment|//  gboolean        support_xmp;
end_comment

begin_comment
comment|//  gboolean        support_iptc;
end_comment

begin_comment
comment|//  GSList         *xmp_structure_list  = NULL;
end_comment

begin_comment
comment|//  GList          *key_list            = NULL;
end_comment

begin_comment
comment|//  gint            i;
end_comment

begin_comment
comment|//  GExiv2Metadata *gexiv2metadata;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  g_return_if_fail (IS_GIMP_METADATA (metadata));
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  gexiv2metadata = GEXIV2_METADATA(gexivdata);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  for (i = 0; i< G_N_ELEMENTS (namespaces_table); i++)
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      struct Namespaces n_space = namespaces_table[i];
end_comment

begin_comment
comment|//      gexiv2_metadata_register_xmp_namespace (n_space.namespace_URI, n_space.namespace_name);
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  support_exif = gexiv2_metadata_get_supports_exif (gexiv2metadata);
end_comment

begin_comment
comment|//  support_xmp  = gexiv2_metadata_get_supports_xmp  (gexiv2metadata);
end_comment

begin_comment
comment|//  support_iptc = gexiv2_metadata_get_supports_iptc (gexiv2metadata);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  for (key_list = metadata->priv->sorted_key_list; key_list; key_list = key_list->next)
end_comment

begin_comment
comment|//    {
end_comment

begin_comment
comment|//      const gchar              *tag;
end_comment

begin_comment
comment|//      const gchar              *ns_name;
end_comment

begin_comment
comment|//      gchar                    *p_key = (gchar *) key_list->data;
end_comment

begin_comment
comment|//      gchar                    *value         = NULL;
end_comment

begin_comment
comment|//      gchar                    *category      = NULL;
end_comment

begin_comment
comment|//      gboolean                  is_xmp        = FALSE;
end_comment

begin_comment
comment|//      gboolean                  has_structure = FALSE;
end_comment

begin_comment
comment|//      GimpAttribute            *attribute;
end_comment

begin_comment
comment|//      GimpAttributeValueType    tag_value_type;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      write_tag      = FALSE;
end_comment

begin_comment
comment|//      namespace      = FALSE;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      attribute      = gimp_metadata_get_attribute_sorted (metadata, p_key);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      if (! attribute)
end_comment

begin_comment
comment|//        continue;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      tag            = gimp_attribute_get_name (attribute);
end_comment

begin_comment
comment|//      has_structure  = gimp_attribute_has_structure (attribute);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      if (mime_type)
end_comment

begin_comment
comment|//        check_mime = gimp_metadata_is_tag_supported (tag, mime_type);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//      if (check_mime)
end_comment

begin_comment
comment|//        {
end_comment

begin_comment
comment|//          gchar *t_packet       = NULL;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          tag_value_type = gimp_attribute_get_value_type (attribute);
end_comment

begin_comment
comment|//          value = gimp_attribute_get_string (attribute);
end_comment

begin_comment
comment|//          category = g_ascii_strdown (gimp_attribute_get_attribute_type (attribute), -1);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          if (tag&& value&& category)
end_comment

begin_comment
comment|//            {
end_comment

begin_comment
comment|//              if(! g_strcmp0 (category, "exif")&& support_exif)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  write_tag = TRUE;
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//              else if(! g_strcmp0 (category, "xmp")&& support_xmp)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  write_tag = TRUE;
end_comment

begin_comment
comment|//                  is_xmp    = TRUE;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                  namespace = gimp_attribute_is_new_namespace (attribute);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                  if (namespace)
end_comment

begin_comment
comment|//                    {
end_comment

begin_comment
comment|//                      write_tag = FALSE;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                      ns_name = gimp_attribute_get_attribute_ifd (attribute);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                      for (i = 0; i< G_N_ELEMENTS (namespaces_table); i++)
end_comment

begin_comment
comment|//                        {
end_comment

begin_comment
comment|//                          struct Namespaces n_space = namespaces_table[i];
end_comment

begin_comment
comment|//                          if(! g_strcmp0 (ns_name, n_space.namespace_name))
end_comment

begin_comment
comment|//                            {
end_comment

begin_comment
comment|//                              write_tag = TRUE;
end_comment

begin_comment
comment|//                              break;
end_comment

begin_comment
comment|//                            }
end_comment

begin_comment
comment|//                        }
end_comment

begin_comment
comment|//                    }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                  if (write_tag&& has_structure)
end_comment

begin_comment
comment|//                    {
end_comment

begin_comment
comment|//                      gboolean                    success = TRUE;
end_comment

begin_comment
comment|//                      GSList                     *structure;
end_comment

begin_comment
comment|//                      GSList                     *list;
end_comment

begin_comment
comment|//                      GimpAttributeStructureType  structure_type;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                      structure      = gimp_attribute_get_attribute_structure (attribute);
end_comment

begin_comment
comment|//                      structure_type = gimp_attribute_get_structure_type (attribute);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                      for (list = structure; list; list = list->next)
end_comment

begin_comment
comment|//                        {
end_comment

begin_comment
comment|//                          const gchar   *structure_element = (const gchar*) list->data;
end_comment

begin_comment
comment|//                          gboolean       has_tag = gexiv2_metadata_has_tag (gexiv2metadata, structure_element);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                          if (!has_tag&& ! has_xmp_structure (xmp_structure_list, structure_element))
end_comment

begin_comment
comment|//                            {
end_comment

begin_comment
comment|//                              switch (structure_type)
end_comment

begin_comment
comment|//                              {
end_comment

begin_comment
comment|//                                case STRUCTURE_TYPE_ALT:
end_comment

begin_comment
comment|//                                  success = gexiv2_metadata_set_xmp_tag_struct (gexiv2metadata, structure_element, GEXIV2_STRUCTURE_XA_ALT); /*start block*/
end_comment

begin_comment
comment|//                                  break;
end_comment

begin_comment
comment|//                                case STRUCTURE_TYPE_BAG:
end_comment

begin_comment
comment|//                                  success = gexiv2_metadata_set_xmp_tag_struct (gexiv2metadata, structure_element, GEXIV2_STRUCTURE_XA_BAG); /*start block*/
end_comment

begin_comment
comment|//                                  break;
end_comment

begin_comment
comment|//                                case STRUCTURE_TYPE_SEQ:
end_comment

begin_comment
comment|//                                  success = gexiv2_metadata_set_xmp_tag_struct (gexiv2metadata, structure_element, GEXIV2_STRUCTURE_XA_SEQ); /*start block*/
end_comment

begin_comment
comment|//                                  break;
end_comment

begin_comment
comment|//                                default:
end_comment

begin_comment
comment|//                                  success = FALSE;
end_comment

begin_comment
comment|//                                  break;
end_comment

begin_comment
comment|//                              }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                              if (success)
end_comment

begin_comment
comment|//                                xmp_structure_list = g_slist_prepend (xmp_structure_list, (gpointer)structure_element);
end_comment

begin_comment
comment|//                            }
end_comment

begin_comment
comment|//                        }
end_comment

begin_comment
comment|//                    }
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//              else if(! g_strcmp0 (category, "iptc")&& support_iptc)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  write_tag = TRUE;
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//              else
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  write_tag = FALSE;
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//              if (write_tag)
end_comment

begin_comment
comment|//                {
end_comment

begin_comment
comment|//                  switch (tag_value_type)
end_comment

begin_comment
comment|//                  {
end_comment

begin_comment
comment|//                    case TYPE_INVALID:
end_comment

begin_comment
comment|//                      break;
end_comment

begin_comment
comment|//                    case TYPE_LONG:
end_comment

begin_comment
comment|//                    case TYPE_SLONG:
end_comment

begin_comment
comment|//                    case TYPE_FLOAT:
end_comment

begin_comment
comment|//                    case TYPE_DOUBLE:
end_comment

begin_comment
comment|//                    case TYPE_SHORT:
end_comment

begin_comment
comment|//                    case TYPE_SSHORT:
end_comment

begin_comment
comment|//                    case TYPE_DATE:
end_comment

begin_comment
comment|//                    case TYPE_TIME:
end_comment

begin_comment
comment|//                    case TYPE_ASCII:
end_comment

begin_comment
comment|//                    case TYPE_UNICODE:
end_comment

begin_comment
comment|//                    case TYPE_BYTE:
end_comment

begin_comment
comment|//                    case TYPE_RATIONAL:
end_comment

begin_comment
comment|//                    case TYPE_SRATIONAL:
end_comment

begin_comment
comment|//                      {
end_comment

begin_comment
comment|//                        gexiv2_metadata_set_tag_string (gexiv2metadata, tag, value);
end_comment

begin_comment
comment|//                      }
end_comment

begin_comment
comment|//                      break;
end_comment

begin_comment
comment|//                    case TYPE_MULTIPLE:
end_comment

begin_comment
comment|//                      {
end_comment

begin_comment
comment|//                        GValue h;
end_comment

begin_comment
comment|//                        gchar **values;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                        h = gimp_attribute_get_value (attribute);
end_comment

begin_comment
comment|//                        values = (gchar **) g_value_get_boxed (&h);
end_comment

begin_comment
comment|//                        gexiv2_metadata_set_tag_multiple (gexiv2metadata, tag, (const gchar **) values);
end_comment

begin_comment
comment|//                        g_strfreev  (values);
end_comment

begin_comment
comment|//                      }
end_comment

begin_comment
comment|//                      break;
end_comment

begin_comment
comment|//                    case TYPE_UNKNOWN:
end_comment

begin_comment
comment|//                    default:
end_comment

begin_comment
comment|//                      break;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                  }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                  if (is_xmp)
end_comment

begin_comment
comment|//                    {
end_comment

begin_comment
comment|//                      t_packet = gexiv2_metadata_generate_xmp_packet (gexiv2metadata, GEXIV2_USE_COMPACT_FORMAT | GEXIV2_OMIT_ALL_FORMATTING, 0);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                      if (! g_strcmp0 (t_packet, o_packet))
end_comment

begin_comment
comment|//                        {
end_comment

begin_comment
comment|//                          gexiv2_metadata_clear_tag (gexiv2metadata, tag);
end_comment

begin_comment
comment|//                          g_print ("cleared to gexiv2metadata:\n%s, %s\n", tag, value);
end_comment

begin_comment
comment|//                        }
end_comment

begin_comment
comment|//                      else
end_comment

begin_comment
comment|//                        {
end_comment

begin_comment
comment|//                          o_packet = g_strdup (t_packet);
end_comment

begin_comment
comment|//                        }
end_comment

begin_comment
comment|//                    }
end_comment

begin_comment
comment|//                }
end_comment

begin_comment
comment|//            }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//          if (t_packet)
end_comment

begin_comment
comment|//            g_free (t_packet);
end_comment

begin_comment
comment|//          if (value)
end_comment

begin_comment
comment|//            g_free (value);
end_comment

begin_comment
comment|//          if (category)
end_comment

begin_comment
comment|//            g_free (category);
end_comment

begin_comment
comment|//       }
end_comment

begin_comment
comment|//    }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  if (o_packet)
end_comment

begin_comment
comment|//    g_free (o_packet);
end_comment

begin_comment
comment|//  if (xmp_structure_list)
end_comment

begin_comment
comment|//    g_slist_free (xmp_structure_list);
end_comment

begin_comment
comment|//}
end_comment

begin_comment
comment|/**  * gimp_metadata_to_gexiv2:  * @metadata:  The #GimpMetadata  *  * Converts @metadata to @gexiv2metadata packet  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_to_gexiv2 (GimpMetadata * metadata)
name|gimp_metadata_to_gexiv2
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|gchar
modifier|*
name|o_packet
init|=
name|NULL
decl_stmt|;
name|gboolean
name|write_tag
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|namespace
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|support_exif
decl_stmt|;
name|gboolean
name|support_xmp
decl_stmt|;
name|gboolean
name|support_iptc
decl_stmt|;
name|GSList
modifier|*
name|xmp_structure_list
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|key_list
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|gexiv2metadata
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|gexiv2metadata
operator|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
name|gexiv2_metadata_register_xmp_namespace
argument_list|(
name|n_space
operator|.
name|namespace_URI
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
expr_stmt|;
block|}
name|support_exif
operator|=
name|gexiv2_metadata_get_supports_exif
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
name|support_xmp
operator|=
name|gexiv2_metadata_get_supports_xmp
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
name|support_iptc
operator|=
name|gexiv2_metadata_get_supports_iptc
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
for|for
control|(
name|key_list
operator|=
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
init|;
name|key_list
condition|;
name|key_list
operator|=
name|key_list
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|ns_name
decl_stmt|;
name|gchar
modifier|*
name|p_key
init|=
operator|(
name|gchar
operator|*
operator|)
name|key_list
operator|->
name|data
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|category
init|=
name|NULL
decl_stmt|;
name|gboolean
name|is_xmp
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|has_structure
init|=
name|FALSE
decl_stmt|;
name|gchar
modifier|*
name|t_packet
init|=
name|NULL
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|GimpAttributeValueType
name|tag_value_type
decl_stmt|;
name|write_tag
operator|=
name|FALSE
expr_stmt|;
name|namespace
operator|=
name|FALSE
expr_stmt|;
name|attribute
operator|=
name|gimp_metadata_get_attribute_sorted
argument_list|(
name|metadata
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
condition|)
continue|continue;
name|tag
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|has_structure
operator|=
name|gimp_attribute_has_structure
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|tag_value_type
operator|=
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_attribute_get_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|category
operator|=
name|g_ascii_strdown
argument_list|(
name|gimp_attribute_get_attribute_type
argument_list|(
name|attribute
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|value
operator|&&
name|category
condition|)
block|{
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"exif"
argument_list|)
operator|&&
name|support_exif
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"xmp"
argument_list|)
operator|&&
name|support_xmp
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
name|is_xmp
operator|=
name|TRUE
expr_stmt|;
name|namespace
operator|=
name|gimp_attribute_is_new_namespace
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespace
condition|)
block|{
name|write_tag
operator|=
name|FALSE
expr_stmt|;
name|ns_name
operator|=
name|gimp_attribute_get_attribute_ifd
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|ns_name
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|write_tag
operator|&&
name|has_structure
condition|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GSList
modifier|*
name|structure
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GimpAttributeStructureType
name|structure_type
decl_stmt|;
name|structure
operator|=
name|gimp_attribute_get_attribute_structure
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|structure_type
operator|=
name|gimp_attribute_get_structure_type
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|structure
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|structure_element
init|=
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|list
operator|->
name|data
decl_stmt|;
name|gboolean
name|has_tag
init|=
name|gexiv2_metadata_has_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|has_tag
operator|&&
operator|!
name|has_xmp_structure
argument_list|(
name|xmp_structure_list
argument_list|,
name|structure_element
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|structure_type
condition|)
block|{
case|case
name|STRUCTURE_TYPE_ALT
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_ALT
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
case|case
name|STRUCTURE_TYPE_BAG
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_BAG
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
case|case
name|STRUCTURE_TYPE_SEQ
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_SEQ
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
name|xmp_structure_list
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_structure_list
argument_list|,
operator|(
name|gpointer
operator|)
name|structure_element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"iptc"
argument_list|)
operator|&&
name|support_iptc
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|write_tag
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|write_tag
condition|)
block|{
switch|switch
condition|(
name|tag_value_type
condition|)
block|{
case|case
name|TYPE_INVALID
case|:
break|break;
case|case
name|TYPE_LONG
case|:
case|case
name|TYPE_SLONG
case|:
case|case
name|TYPE_FLOAT
case|:
case|case
name|TYPE_DOUBLE
case|:
case|case
name|TYPE_SHORT
case|:
case|case
name|TYPE_SSHORT
case|:
case|case
name|TYPE_DATE
case|:
case|case
name|TYPE_TIME
case|:
case|case
name|TYPE_ASCII
case|:
case|case
name|TYPE_UNICODE
case|:
case|case
name|TYPE_BYTE
case|:
case|case
name|TYPE_RATIONAL
case|:
case|case
name|TYPE_SRATIONAL
case|:
block|{
name|gexiv2_metadata_set_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|tag
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_MULTIPLE
case|:
block|{
name|GValue
name|h
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|values
decl_stmt|;
name|h
operator|=
name|gimp_attribute_get_value
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|values
operator|=
operator|(
name|gchar
operator|*
operator|*
operator|)
name|g_value_get_boxed
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_multiple
argument_list|(
name|gexiv2metadata
argument_list|,
name|tag
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
name|values
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNKNOWN
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|is_xmp
condition|)
block|{
comment|/* XMP packet for testing                    * There is no way to check, if storing of tags were successful, because gexiv2 has no error handling                    * The only way is to compare a xpm packet before and after the storing process. If they are equal, the storing was not successful                    * so the stored tag must be deleted, otherwise the whole xmp data is corrupt. */
name|t_packet
operator|=
name|gexiv2_metadata_generate_xmp_packet
argument_list|(
name|gexiv2metadata
argument_list|,
name|GEXIV2_USE_COMPACT_FORMAT
operator||
name|GEXIV2_OMIT_ALL_FORMATTING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|t_packet
argument_list|,
name|o_packet
argument_list|)
condition|)
block|{
name|gexiv2_metadata_clear_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"cleared to gexiv2metadata:\n%s, %s\n"
argument_list|,
name|tag
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|o_packet
operator|=
name|g_strdup
argument_list|(
name|t_packet
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|t_packet
condition|)
name|g_free
argument_list|(
name|t_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
condition|)
name|g_free
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o_packet
condition|)
name|g_free
argument_list|(
name|o_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmp_structure_list
condition|)
name|g_slist_free
argument_list|(
name|xmp_structure_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_to_parent:  * @metadata:  The #GimpMetadata  * @gexiv2metadata:  The #GimpMetadata  * @mime_type: the mime type of the image  *  * Converts @metadata to @gexiv2metadata in gexiv2 format  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_to_parent (GimpMetadata * metadata,GimpAttribute * attribute)
name|gimp_metadata_to_parent
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|gchar
modifier|*
name|o_packet
init|=
name|NULL
decl_stmt|;
name|gboolean
name|write_tag
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|namespace
init|=
name|FALSE
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|gexiv2metadata
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|ns_name
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|category
init|=
name|NULL
decl_stmt|;
name|gboolean
name|is_xmp
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|has_structure
init|=
name|FALSE
decl_stmt|;
name|GimpAttributeValueType
name|tag_value_type
decl_stmt|;
name|gchar
modifier|*
name|t_packet
init|=
name|NULL
decl_stmt|;
name|GimpMetadataPrivate
modifier|*
name|priv
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
name|gexiv2metadata
operator|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|priv
operator|=
name|GIMP_METADATA_GET_PRIVATE
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|write_tag
operator|=
name|FALSE
expr_stmt|;
name|namespace
operator|=
name|FALSE
expr_stmt|;
name|tag
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|has_structure
operator|=
name|gimp_attribute_has_structure
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|tag_value_type
operator|=
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_attribute_get_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|category
operator|=
name|g_ascii_strdown
argument_list|(
name|gimp_attribute_get_attribute_type
argument_list|(
name|attribute
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//  if (g_str_has_prefix (tag, "Xmp"))
comment|//    {
comment|//      g_print ("found xmp: %s\n", tag);
comment|//    }
comment|//
comment|//  if (g_str_has_prefix (tag, "Xmp.xmpMM.History"))
comment|//    {
comment|//      g_print ("found struct: %s\n", tag);
comment|//    }
if|if
condition|(
name|tag
operator|&&
name|value
operator|&&
name|category
condition|)
block|{
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"exif"
argument_list|)
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"xmp"
argument_list|)
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
name|is_xmp
operator|=
name|TRUE
expr_stmt|;
comment|/* XMP packet for testing before adding tag            * There is no way to check, if storing of tags were successful, because gexiv2 has no error handling            * The only way is to compare a xpm packet before and after the storing process. If they are equal, the storing was not successful            * so the stored tag must be deleted, otherwise the whole xmp data is corrupt. */
name|o_packet
operator|=
name|gexiv2_metadata_generate_xmp_packet
argument_list|(
name|gexiv2metadata
argument_list|,
name|GEXIV2_USE_COMPACT_FORMAT
operator||
name|GEXIV2_OMIT_ALL_FORMATTING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|namespace
operator|=
name|gimp_attribute_is_new_namespace
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespace
condition|)
block|{
name|write_tag
operator|=
name|FALSE
expr_stmt|;
name|ns_name
operator|=
name|gimp_attribute_get_attribute_ifd
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|ns_name
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|write_tag
operator|&&
name|has_structure
condition|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GSList
modifier|*
name|structure
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GimpAttributeStructureType
name|structure_type
decl_stmt|;
name|structure
operator|=
name|gimp_attribute_get_attribute_structure
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|structure_type
operator|=
name|gimp_attribute_get_structure_type
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|structure
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|structure_element
init|=
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|list
operator|->
name|data
decl_stmt|;
name|gboolean
name|has_tag
init|=
name|gexiv2_metadata_has_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|has_tag
operator|&&
operator|!
name|has_xmp_structure
argument_list|(
name|priv
operator|->
name|xmp_structure_list
argument_list|,
name|structure_element
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|structure_type
condition|)
block|{
case|case
name|STRUCTURE_TYPE_ALT
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_ALT
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
case|case
name|STRUCTURE_TYPE_BAG
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_BAG
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
case|case
name|STRUCTURE_TYPE_SEQ
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_SEQ
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
name|priv
operator|->
name|xmp_structure_list
operator|=
name|g_slist_prepend
argument_list|(
name|priv
operator|->
name|xmp_structure_list
argument_list|,
operator|(
name|gpointer
operator|)
name|structure_element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"iptc"
argument_list|)
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|write_tag
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|write_tag
condition|)
block|{
switch|switch
condition|(
name|tag_value_type
condition|)
block|{
case|case
name|TYPE_INVALID
case|:
break|break;
case|case
name|TYPE_LONG
case|:
case|case
name|TYPE_SLONG
case|:
case|case
name|TYPE_FLOAT
case|:
case|case
name|TYPE_DOUBLE
case|:
case|case
name|TYPE_SHORT
case|:
case|case
name|TYPE_SSHORT
case|:
case|case
name|TYPE_DATE
case|:
case|case
name|TYPE_TIME
case|:
case|case
name|TYPE_ASCII
case|:
case|case
name|TYPE_UNICODE
case|:
case|case
name|TYPE_BYTE
case|:
case|case
name|TYPE_RATIONAL
case|:
case|case
name|TYPE_SRATIONAL
case|:
block|{
name|gexiv2_metadata_set_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|tag
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_MULTIPLE
case|:
block|{
name|GValue
name|h
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|values
decl_stmt|;
name|h
operator|=
name|gimp_attribute_get_value
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|values
operator|=
operator|(
name|gchar
operator|*
operator|*
operator|)
name|g_value_get_boxed
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_multiple
argument_list|(
name|gexiv2metadata
argument_list|,
name|tag
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
name|values
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNKNOWN
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|is_xmp
condition|)
block|{
comment|/* XMP packet for testing after adding tag */
name|t_packet
operator|=
name|gexiv2_metadata_generate_xmp_packet
argument_list|(
name|gexiv2metadata
argument_list|,
name|GEXIV2_USE_COMPACT_FORMAT
operator||
name|GEXIV2_OMIT_ALL_FORMATTING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|t_packet
argument_list|,
name|o_packet
argument_list|)
condition|)
block|{
name|gexiv2_metadata_clear_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"cleared to gexiv2metadata:\n%s, %s\n"
argument_list|,
name|tag
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|t_packet
condition|)
name|g_free
argument_list|(
name|t_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
condition|)
name|g_free
argument_list|(
name|category
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_packet
condition|)
name|g_free
argument_list|(
name|o_packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_to_xmp_packet: ToDo handle xmp-packet  * @metadata:  The #GimpMetadata  * @mime_type :  a mime_type  *  * Converts @metadata to a xmp packet  * It looks like an ugly hack, but let  * gexiv2/exiv2 do all the hard work.  *  * Return value: a #gchar*, representing a xml packet.  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_metadata_to_xmp_packet (GimpMetadata * metadata,const gchar * mime_type)
name|gimp_metadata_to_xmp_packet
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|gchar
modifier|*
name|mime_type
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|packet_string
decl_stmt|;
name|gchar
modifier|*
name|o_packet
init|=
name|NULL
decl_stmt|;
name|gboolean
name|check_mime
init|=
name|TRUE
decl_stmt|;
name|gboolean
name|write_tag
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|namespace
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|support_exif
decl_stmt|;
name|gboolean
name|support_xmp
decl_stmt|;
name|gboolean
name|support_iptc
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|gexiv2metadata
decl_stmt|;
name|GSList
modifier|*
name|xmp_structure_list
init|=
name|NULL
decl_stmt|;
name|GList
modifier|*
name|key_list
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_metadata_from_gexiv2
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|gexiv2metadata
operator|=
name|gimp_metadata_new_gexiv2metadata
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
name|gexiv2_metadata_register_xmp_namespace
argument_list|(
name|n_space
operator|.
name|namespace_URI
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
expr_stmt|;
block|}
name|support_exif
operator|=
name|gexiv2_metadata_get_supports_exif
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
name|support_xmp
operator|=
name|gexiv2_metadata_get_supports_xmp
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
name|support_iptc
operator|=
name|gexiv2_metadata_get_supports_iptc
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
for|for
control|(
name|key_list
operator|=
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
init|;
name|key_list
condition|;
name|key_list
operator|=
name|key_list
operator|->
name|next
control|)
block|{
name|gchar
modifier|*
name|p_key
init|=
operator|(
name|gchar
operator|*
operator|)
name|key_list
operator|->
name|data
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|attribute_tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|ns_name
decl_stmt|;
name|gchar
modifier|*
name|new_tag
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|category
init|=
name|NULL
decl_stmt|;
name|gboolean
name|has_structure
decl_stmt|;
name|gboolean
name|temp_attribute
init|=
name|FALSE
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|GimpAttributeValueType
name|tag_value_type
decl_stmt|;
name|write_tag
operator|=
name|FALSE
expr_stmt|;
name|namespace
operator|=
name|FALSE
expr_stmt|;
name|attribute
operator|=
name|gimp_metadata_get_attribute_sorted
argument_list|(
name|metadata
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
condition|)
continue|continue;
name|tag
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|attribute_tag
operator|=
name|gimp_attribute_get_attribute_tag
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|has_structure
operator|=
name|gimp_attribute_has_structure
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|mime_type
condition|)
name|check_mime
operator|=
name|gimp_metadata_is_tag_supported
argument_list|(
name|tag
argument_list|,
name|mime_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_mime
condition|)
block|{
name|gchar
modifier|*
name|sec_tag
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|t_packet
init|=
name|NULL
decl_stmt|;
name|tag_value_type
operator|=
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_attribute_get_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|category
operator|=
name|g_ascii_strdown
argument_list|(
name|gimp_attribute_get_attribute_type
argument_list|(
name|attribute
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|value
operator|&&
name|category
condition|)
block|{
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"exif"
argument_list|)
operator|&&
name|support_exif
condition|)
block|{
name|new_tag
operator|=
name|g_strdup_printf
argument_list|(
literal|"Xmp.exif.%s"
argument_list|,
name|attribute_tag
argument_list|)
expr_stmt|;
name|write_tag
operator|=
name|TRUE
expr_stmt|;
comment|//                  /* Now for some specialities */
comment|//                  if (! g_strcmp0 (new_tag, "Xmp.exif.ISOSpeedRatings"))
comment|//                    {
comment|//                      g_print ("ungÃ¼ltig\n");
comment|//                       attribute = gimp_attribute_new_string ("Xmp.exif.ISOSpeedRatings", value, TYPE_ASCII);
comment|//                      if (attribute)
comment|//                        {
comment|//                          temp_attribute = TRUE;
comment|//                          tag_value_type = TYPE_ASCII;
comment|//                        }
comment|//                      else
comment|//                        {
comment|//                          write_tag = FALSE;
comment|//                        }
comment|//                    }
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"xmp"
argument_list|)
operator|&&
name|support_xmp
condition|)
block|{
name|new_tag
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|write_tag
operator|=
name|TRUE
expr_stmt|;
name|namespace
operator|=
name|gimp_attribute_is_new_namespace
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespace
condition|)
block|{
name|write_tag
operator|=
name|FALSE
expr_stmt|;
name|ns_name
operator|=
name|gimp_attribute_get_attribute_ifd
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|ns_name
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
condition|)
block|{
name|write_tag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|write_tag
operator|&&
name|has_structure
condition|)
block|{
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|GSList
modifier|*
name|structure
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
name|GimpAttributeStructureType
name|structure_type
decl_stmt|;
name|structure
operator|=
name|gimp_attribute_get_attribute_structure
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|structure_type
operator|=
name|gimp_attribute_get_structure_type
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|structure
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|structure_element
init|=
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|list
operator|->
name|data
decl_stmt|;
name|gboolean
name|has_tag
init|=
name|gexiv2_metadata_has_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|has_tag
operator|&&
operator|!
name|has_xmp_structure
argument_list|(
name|xmp_structure_list
argument_list|,
name|structure_element
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|structure_type
condition|)
block|{
case|case
name|STRUCTURE_TYPE_ALT
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_ALT
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
case|case
name|STRUCTURE_TYPE_BAG
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_BAG
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
case|case
name|STRUCTURE_TYPE_SEQ
case|:
name|success
operator|=
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|gexiv2metadata
argument_list|,
name|structure_element
argument_list|,
name|GEXIV2_STRUCTURE_XA_SEQ
argument_list|)
expr_stmt|;
comment|/*start block*/
break|break;
default|default:
name|success
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
name|xmp_structure_list
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_structure_list
argument_list|,
operator|(
name|gpointer
operator|)
name|structure_element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|category
argument_list|,
literal|"iptc"
argument_list|)
operator|&&
name|support_iptc
condition|)
block|{
name|new_tag
operator|=
name|g_strdup_printf
argument_list|(
literal|"Xmp.iptc.%s"
argument_list|,
name|attribute_tag
argument_list|)
expr_stmt|;
name|sec_tag
operator|=
name|g_strdup_printf
argument_list|(
literal|"Xmp.iptcExt.%s"
argument_list|,
name|attribute_tag
argument_list|)
expr_stmt|;
name|write_tag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|write_tag
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|write_tag
condition|)
block|{
switch|switch
condition|(
name|tag_value_type
condition|)
block|{
case|case
name|TYPE_INVALID
case|:
break|break;
case|case
name|TYPE_LONG
case|:
case|case
name|TYPE_SLONG
case|:
case|case
name|TYPE_FLOAT
case|:
case|case
name|TYPE_DOUBLE
case|:
case|case
name|TYPE_SHORT
case|:
case|case
name|TYPE_SSHORT
case|:
case|case
name|TYPE_DATE
case|:
case|case
name|TYPE_TIME
case|:
case|case
name|TYPE_ASCII
case|:
case|case
name|TYPE_UNICODE
case|:
case|case
name|TYPE_BYTE
case|:
case|case
name|TYPE_RATIONAL
case|:
case|case
name|TYPE_SRATIONAL
case|:
block|{
name|gexiv2_metadata_set_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|new_tag
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_tag
condition|)
block|{
name|gexiv2_metadata_set_tag_string
argument_list|(
name|gexiv2metadata
argument_list|,
name|sec_tag
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|sec_tag
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_MULTIPLE
case|:
block|{
name|GValue
name|h
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|values
decl_stmt|;
name|h
operator|=
name|gimp_attribute_get_value
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|values
operator|=
operator|(
name|gchar
operator|*
operator|*
operator|)
name|g_value_get_boxed
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_multiple
argument_list|(
name|gexiv2metadata
argument_list|,
name|new_tag
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_tag
condition|)
block|{
name|gexiv2_metadata_set_tag_multiple
argument_list|(
name|gexiv2metadata
argument_list|,
name|sec_tag
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
name|values
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|sec_tag
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNKNOWN
case|:
default|default:
break|break;
block|}
name|t_packet
operator|=
name|gexiv2_metadata_generate_xmp_packet
argument_list|(
name|gexiv2metadata
argument_list|,
name|GEXIV2_USE_COMPACT_FORMAT
operator||
name|GEXIV2_OMIT_ALL_FORMATTING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t_packet
operator|||
operator|!
name|g_strcmp0
argument_list|(
name|t_packet
argument_list|,
name|o_packet
argument_list|)
condition|)
block|{
name|gexiv2_metadata_clear_tag
argument_list|(
name|gexiv2metadata
argument_list|,
name|new_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|o_packet
operator|=
name|g_strdup
argument_list|(
name|t_packet
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|t_packet
condition|)
name|g_free
argument_list|(
name|t_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
condition|)
name|g_free
argument_list|(
name|category
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tag
condition|)
name|g_free
argument_list|(
name|new_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_attribute
condition|)
name|g_object_unref
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|o_packet
condition|)
name|g_free
argument_list|(
name|o_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmp_structure_list
condition|)
name|g_slist_free
argument_list|(
name|xmp_structure_list
argument_list|)
expr_stmt|;
name|packet_string
operator|=
name|gexiv2_metadata_generate_xmp_packet
argument_list|(
name|gexiv2metadata
argument_list|,
name|GEXIV2_USE_COMPACT_FORMAT
operator||
name|GEXIV2_WRITE_ALIAS_COMMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|packet_string
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_has_tag_type:  * @metadata:  The metadata  * @tag_type:  The #GimpAttributeTagType to test  *  * tests, if @metadata contains at least one tag of @tag_type  *  * Return value: TRUE if found, FALSE otherwise  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_has_tag_type (GimpMetadata * metadata,GimpAttributeTagType tag_type)
name|gimp_metadata_has_tag_type
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttributeTagType
name|tag_type
parameter_list|)
block|{
name|GHashTableIter
name|iter
decl_stmt|;
name|gpointer
name|p_key
decl_stmt|,
name|p_value
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_metadata_from_gexiv2
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|g_hash_table_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|metadata
operator|->
name|priv
operator|->
name|attribute_table
argument_list|)
expr_stmt|;
while|while
condition|(
name|g_hash_table_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|p_key
argument_list|,
operator|&
name|p_value
argument_list|)
condition|)
block|{
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|attribute
operator|=
operator|(
name|GimpAttribute
operator|*
operator|)
name|p_value
expr_stmt|;
if|if
condition|(
name|gimp_attribute_get_tag_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|tag_type
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|GList
modifier|*
DECL|function|gimp_metadata_iter_init (GimpMetadata * metadata,GList ** iter)
name|gimp_metadata_iter_init
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GList
modifier|*
modifier|*
name|iter
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_metadata_from_gexiv2
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
operator|*
name|iter
operator|=
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
expr_stmt|;
name|iter_initialized
operator|=
name|TRUE
expr_stmt|;
return|return
name|metadata
operator|->
name|priv
operator|->
name|sorted_key_list
return|;
block|}
end_function

begin_function
name|gboolean
DECL|function|gimp_metadata_iter_next (GimpMetadata * metadata,GimpAttribute ** attribute,GList ** prev)
name|gimp_metadata_iter_next
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpAttribute
modifier|*
modifier|*
name|attribute
parameter_list|,
name|GList
modifier|*
modifier|*
name|prev
parameter_list|)
block|{
name|gchar
modifier|*
name|sorted
decl_stmt|;
name|GList
modifier|*
name|tmp
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|attribute
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iter_initialized
condition|)
block|{
name|tmp
operator|=
name|g_list_first
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|g_list_next
argument_list|(
operator|*
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
condition|)
block|{
operator|*
name|prev
operator|=
name|tmp
expr_stmt|;
name|sorted
operator|=
operator|(
name|gchar
operator|*
operator|)
name|tmp
operator|->
name|data
expr_stmt|;
operator|*
name|attribute
operator|=
name|gimp_metadata_get_attribute_sorted
argument_list|(
name|metadata
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
block|}
name|iter_initialized
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|attribute
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_error_quark:  *  * Return value: #GQuark  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|static
name|GQuark
DECL|function|gimp_metadata_error_quark (void)
name|gimp_metadata_error_quark
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GQuark
name|quark
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|quark
operator|==
literal|0
argument_list|)
condition|)
name|quark
operator|=
name|g_quark_from_static_string
argument_list|(
literal|"gimp-metadata-error-quark"
argument_list|)
expr_stmt|;
return|return
name|quark
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_deserialize_error:  *  * Error while parsing  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_error (GMarkupParseContext * context,GError * error,gpointer user_data)
name|gimp_metadata_deserialize_error
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
name|error
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|g_printerr
argument_list|(
literal|"XML parse error: %s\n"
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_name_to_value:  *  * @attribute_names  : #gchar **  * @attribute_values : #gchar **  * @name             : #gchar *  *  * searches for values in @attribute_values by a given @name (parsing xml)  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|static
specifier|const
name|gchar
modifier|*
DECL|function|gimp_metadata_name_to_value (const gchar ** attribute_names,const gchar ** attribute_values,const gchar * name)
name|gimp_metadata_name_to_value
parameter_list|(
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
while|while
condition|(
operator|*
name|attribute_names
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|attribute_names
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|*
name|attribute_values
return|;
block|}
name|attribute_names
operator|++
expr_stmt|;
name|attribute_values
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_deserialize_start_element:  *  * @context           : #GMarkupParseContext  * @element_name      : #gchar *  * @attribute_names   : #gchar **  * @attribute_values  : #gchar **  * @user_data         : #gpointer to #GimpMetadataParseData struct  * @error             : #GError **  *  * start of a tag (parsing xml)  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_start_element (GMarkupParseContext * context,const gchar * element_name,const gchar ** attribute_names,const gchar ** attribute_values,gpointer user_data,GError ** error)
name|gimp_metadata_deserialize_start_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadataParseData
modifier|*
name|parse_data
init|=
name|user_data
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"tag"
argument_list|)
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|encoding
decl_stmt|;
name|name
operator|=
name|gimp_metadata_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|gimp_metadata_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|1001
argument_list|,
literal|"Element 'tag' does not contain required attribute 'name'."
argument_list|)
expr_stmt|;
return|return;
block|}
name|strncpy
argument_list|(
name|parse_data
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|parse_data
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|parse_data
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|parse_data
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|parse_data
operator|->
name|base64
operator|=
operator|(
name|encoding
operator|&&
operator|!
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"attribute"
argument_list|)
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|gimp_metadata_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|type
operator|=
name|gimp_metadata_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|1001
argument_list|,
literal|"Element 'tag' does not contain required attribute 'name'."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|1001
argument_list|,
literal|"Element 'tag' does not contain required attribute 'type'."
argument_list|)
expr_stmt|;
return|return;
block|}
name|strncpy
argument_list|(
name|parse_data
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|parse_data
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|parse_data
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|parse_data
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|parse_data
operator|->
name|type
operator|=
operator|(
name|GimpAttributeValueType
operator|)
name|atoi
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"value"
argument_list|)
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|encoding
init|=
name|NULL
decl_stmt|;
name|encoding
operator|=
name|gimp_metadata_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
name|parse_data
operator|->
name|base64
operator|=
operator|(
name|encoding
operator|&&
operator|!
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"interpreted"
argument_list|)
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|encoding
init|=
name|NULL
decl_stmt|;
name|encoding
operator|=
name|gimp_metadata_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
name|parse_data
operator|->
name|base64
operator|=
operator|(
name|encoding
operator|&&
operator|!
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_deserialize_text:  *  * @context           : #GMarkupParseContext  * @text              : const #gchar *  * @text_len          : #gsize  * @user_data         : #gpointer to #GimpMetadataParseData struct  * @error             : #GError **  *  * text of a tag (parsing xml)  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_text (GMarkupParseContext * context,const gchar * text,gsize text_len,gpointer user_data,GError ** error)
name|gimp_metadata_deserialize_text
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadataParseData
modifier|*
name|parse_data
init|=
name|user_data
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|current_element
decl_stmt|;
name|current_element
operator|=
name|g_markup_parse_context_get_element
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|current_element
argument_list|,
literal|"tag"
argument_list|)
condition|)
comment|/*old metadata*/
block|{
name|gchar
modifier|*
name|value
init|=
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|parse_data
operator|->
name|base64
condition|)
block|{
name|guchar
modifier|*
name|decoded
decl_stmt|;
name|gsize
name|len
decl_stmt|;
name|decoded
operator|=
name|g_base64_decode
argument_list|(
name|value
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|parse_data
operator|->
name|metadata
argument_list|)
argument_list|,
name|parse_data
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|decoded
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|parse_data
operator|->
name|metadata
argument_list|)
argument_list|,
name|parse_data
operator|->
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|current_element
argument_list|,
literal|"value"
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|value
init|=
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|parse_data
operator|->
name|base64
condition|)
block|{
name|guchar
modifier|*
name|decoded
decl_stmt|;
name|gsize
name|len
decl_stmt|;
name|decoded
operator|=
name|g_base64_decode
argument_list|(
name|value
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|parse_data
operator|->
name|name
argument_list|,
operator|(
name|gchar
operator|*
operator|)
name|decoded
argument_list|,
name|parse_data
operator|->
name|type
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attribute
operator|=
name|gimp_attribute_new_string
argument_list|(
name|parse_data
operator|->
name|name
argument_list|,
name|value
argument_list|,
name|parse_data
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
operator|&&
name|gimp_attribute_is_valid
argument_list|(
name|attribute
argument_list|)
condition|)
block|{
name|gimp_metadata_add_attribute
argument_list|(
name|parse_data
operator|->
name|metadata
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|current_attribute
operator|=
name|attribute
expr_stmt|;
block|}
else|else
name|g_object_unref
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|current_element
argument_list|,
literal|"structure"
argument_list|)
condition|)
block|{
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|attribute
operator|=
name|current_attribute
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
name|gint
name|v
decl_stmt|;
name|GimpAttributeStructureType
name|struct_type
init|=
name|STRUCTURE_TYPE_BAG
decl_stmt|;
name|value
operator|=
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
name|v
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
operator|-
literal|1
condition|)
name|struct_type
operator|=
operator|(
name|GimpAttributeStructureType
operator|)
name|v
expr_stmt|;
name|gimp_attribute_set_structure_type
argument_list|(
name|attribute
argument_list|,
name|struct_type
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|current_element
argument_list|,
literal|"interpreted"
argument_list|)
condition|)
block|{
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|attribute
operator|=
name|current_attribute
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
name|value
operator|=
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_data
operator|->
name|base64
condition|)
block|{
name|guchar
modifier|*
name|decoded
init|=
name|NULL
decl_stmt|;
name|gsize
name|len
decl_stmt|;
name|decoded
operator|=
name|g_base64_decode
argument_list|(
name|value
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|gimp_attribute_set_interpreted_string
argument_list|(
name|attribute
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|decoded
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_attribute_set_interpreted_string
argument_list|(
name|attribute
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_deserialize_end_element:  *  * @context           : #GMarkupParseContext  * @element_name      : #gchar *  * @user_data         : #gpointer to #GimpMetadataParseData struct  * @error             : #GError **  *  * end of a tag (parsing xml)  *  * Since: GIMP 2.10  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_end_element (GMarkupParseContext * context,const gchar * element_name,gpointer user_data,GError ** error)
name|gimp_metadata_deserialize_end_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadataParseData
modifier|*
name|parse_data
init|=
name|user_data
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"attribute"
argument_list|)
condition|)
block|{
name|current_attribute
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"value"
argument_list|)
condition|)
block|{
name|parse_data
operator|->
name|base64
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"interpreted"
argument_list|)
condition|)
block|{
name|parse_data
operator|->
name|base64
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|has_xmp_structure (GSList * xmp_list,const gchar * entry)
name|has_xmp_structure
parameter_list|(
name|GSList
modifier|*
name|xmp_list
parameter_list|,
specifier|const
name|gchar
modifier|*
name|entry
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|xmp_list
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
specifier|const
name|gchar
modifier|*
name|to_test
init|=
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|to_test
argument_list|,
name|entry
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_new_gexiv2metadata:  *  * Creates a new #GExiv2Metadata instance.  *  * Return value: The new #GExiv2Metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|GExiv2Metadata
modifier|*
DECL|function|gimp_metadata_new_gexiv2metadata (void)
name|gimp_metadata_new_gexiv2metadata
parameter_list|(
name|void
parameter_list|)
block|{
name|GExiv2Metadata
modifier|*
name|gexiv2metadata
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|gexiv2_initialize
argument_list|()
condition|)
block|{
name|gexiv2metadata
operator|=
name|gexiv2_metadata_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|gexiv2metadata
argument_list|,
name|wilber_jpg
argument_list|,
name|wilber_jpg_len
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|gexiv2metadata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|namespaces_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Namespaces
name|n_space
init|=
name|namespaces_table
index|[
name|i
index|]
decl_stmt|;
name|gexiv2_metadata_register_xmp_namespace
argument_list|(
name|n_space
operator|.
name|namespace_URI
argument_list|,
name|n_space
operator|.
name|namespace_name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gexiv2metadata
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_save_to_file:  * @metadata: A #GimpMetadata instance.  * @file:     The file to save the metadata to  * @error:    Return location for error message  *  * Saves @metadata to @file.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_save_to_file (GimpMetadata * metadata,GFile * file,GError ** error)
name|gimp_metadata_save_to_file
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gchar
modifier|*
name|path
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|G_IS_FILE
argument_list|(
name|file
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|path
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Can save metadata only to local files"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|G_OS_WIN32
name|filename
operator|=
name|g_win32_locale_filename_from_utf8
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
name|filename
operator|=
name|g_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|success
operator|=
name|gexiv2_metadata_save_file
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|filename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_load_from_file:  * @file:  The #GFile to load the metadata from  * @error: Return location for error message  *  * Loads #GimpMetadata from @file.  *  * Return value: The loaded #GimpMetadata.  *  * Since: 2.10  */
end_comment

begin_function
name|GimpMetadata
modifier|*
DECL|function|gimp_metadata_load_from_file (GFile * file,GError ** error)
name|gimp_metadata_load_from_file
parameter_list|(
name|GFile
modifier|*
name|file
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|metadata
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|path
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|G_IS_FILE
argument_list|(
name|file
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|path
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Can load metadata only from local files"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|G_OS_WIN32
name|filename
operator|=
name|g_win32_locale_filename_from_utf8
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
name|filename
operator|=
name|g_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_initialize
argument_list|()
condition|)
block|{
name|metadata
operator|=
name|gimp_metadata_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_path
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|filename
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|metadata
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_from_exif:  * @metadata:         A #GimpMetadata instance.  * @exif_data:        The blob of Exif data to set  * @exif_data_length: Length of @exif_data, in bytes  * @error:            Return location for error message  *  * Sets the tags from a piece of Exif data on @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_set_from_exif (GimpMetadata * metadata,const guchar * exif_data,gint exif_data_length,GError ** error)
name|gimp_metadata_set_from_exif
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|guchar
modifier|*
name|exif_data
parameter_list|,
name|gint
name|exif_data_length
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GByteArray
modifier|*
name|exif_bytes
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|exif_metadata
decl_stmt|;
name|guint8
name|data_size
index|[
literal|2
index|]
init|=
block|{
literal|0
block|, }
decl_stmt|;
specifier|const
name|guint8
name|eoi
index|[
literal|2
index|]
init|=
block|{
literal|0xff
block|,
literal|0xd9
block|}
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|exif_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|exif_data_length
operator|>
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|exif_data_length
operator|+
literal|2
operator|<
literal|65536
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exif_metadata
operator|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|data_size
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|exif_data_length
operator|+
literal|2
operator|)
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
name|data_size
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|exif_data_length
operator|+
literal|2
operator|)
operator|&
literal|0x00FF
operator|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_new
argument_list|()
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
name|minimal_exif
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|minimal_exif
argument_list|)
argument_list|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
name|data_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|exif_data
argument_list|,
name|exif_data_length
argument_list|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
name|eoi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|exif_metadata
argument_list|,
name|exif_bytes
operator|->
name|data
argument_list|,
name|exif_bytes
operator|->
name|len
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|g_byte_array_free
argument_list|(
name|exif_bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gexiv2_metadata_has_exif
argument_list|(
name|exif_metadata
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Parsing Exif data failed."
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|g_byte_array_free
argument_list|(
name|exif_bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|g_object_unref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|g_byte_array_free
argument_list|(
name|exif_bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_from_xmp:  * @metadata:        A #GimpMetadata instance.  * @xmp_data:        The blob of Exif data to set  * @xmp_data_length: Length of @exif_data, in bytes  * @error:           Return location for error message  *  * Sets the tags from a piece of XMP data on @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_set_from_xmp (GimpMetadata * metadata,const guchar * xmp_data,gint xmp_data_length,GError ** error)
name|gimp_metadata_set_from_xmp
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|guchar
modifier|*
name|xmp_data
parameter_list|,
name|gint
name|xmp_data_length
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GExiv2Metadata
modifier|*
name|xmp_metadata
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_data_length
operator|>
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xmp_metadata
operator|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|g_object_ref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|xmp_metadata
argument_list|,
name|xmp_data
argument_list|,
name|xmp_data_length
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gexiv2_metadata_has_xmp
argument_list|(
name|xmp_metadata
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Parsing XMP data failed."
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|g_object_unref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_is_tag_supported:  * @tag:       A metadata tag name  * @mime_type: A mime type  *  * Returns whether @tag is supported in a file of type @mime_type.  *  * Return value: %TRUE if the @tag supported with @mime_type, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_is_tag_supported (const gchar * tag,const gchar * mime_type)
name|gimp_metadata_is_tag_supported
parameter_list|(
specifier|const
name|gchar
modifier|*
name|tag
parameter_list|,
specifier|const
name|gchar
modifier|*
name|mime_type
parameter_list|)
block|{
name|gint
name|j
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tag
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|mime_type
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|unsupported_tags
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|tag
argument_list|,
name|unsupported_tags
index|[
name|j
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mime_type
argument_list|,
literal|"image/jpeg"
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|tiff_tags
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|tag
argument_list|,
name|tiff_tags
index|[
name|j
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mime_type
argument_list|,
literal|"image/tiff"
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|jpeg_tags
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|tag
argument_list|,
name|jpeg_tags
index|[
name|j
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_colorspace:  * @metadata: Ab #GimpMetadata instance.  *  * Returns values based on Exif.Photo.ColorSpace, Xmp.exif.ColorSpace,  * Exif.Iop.InteroperabilityIndex, Exif.Nikon3.ColorSpace,  * Exif.Canon.ColorSpace of @metadata.  *  * Return value: The colorspace specified by above tags.  *  * Since: 2.10  */
end_comment

begin_function
name|GimpMetadataColorspace
DECL|function|gimp_metadata_get_colorspace (GimpMetadata * metadata)
name|gimp_metadata_get_colorspace
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|glong
name|exif_cs
init|=
operator|-
literal|1
decl_stmt|;
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|GValue
name|val
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|GIMP_METADATA_COLORSPACE_UNSPECIFIED
argument_list|)
expr_stmt|;
comment|/*  the logic here was mostly taken from darktable and libkexiv2  */
name|attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute
condition|)
block|{
name|attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attribute
condition|)
block|{
if|if
condition|(
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|TYPE_LONG
operator|||
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|TYPE_SLONG
condition|)
block|{
name|val
operator|=
name|gimp_attribute_get_value
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|exif_cs
operator|=
name|g_value_get_long
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exif_cs
operator|==
literal|0x01
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
elseif|else
if|if
condition|(
name|exif_cs
operator|==
literal|0x02
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
else|else
block|{
if|if
condition|(
name|exif_cs
operator|==
literal|0xffff
condition|)
block|{
name|gchar
modifier|*
name|iop_index
decl_stmt|;
name|attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
name|iop_index
operator|=
name|gimp_attribute_get_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|iop_index
argument_list|,
literal|"R03"
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|iop_index
argument_list|)
expr_stmt|;
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|iop_index
argument_list|,
literal|"R98"
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|iop_index
argument_list|)
expr_stmt|;
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
name|g_free
argument_list|(
name|iop_index
argument_list|)
expr_stmt|;
block|}
name|attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
if|if
condition|(
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|TYPE_LONG
operator|||
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|TYPE_SLONG
condition|)
block|{
name|glong
name|nikon_cs
decl_stmt|;
name|val
operator|=
name|gimp_attribute_get_value
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|nikon_cs
operator|=
name|g_value_get_long
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|nikon_cs
operator|==
literal|0x01
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
elseif|else
if|if
condition|(
name|nikon_cs
operator|==
literal|0x02
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
block|}
block|}
name|attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
if|if
condition|(
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|TYPE_LONG
operator|||
name|gimp_attribute_get_value_type
argument_list|(
name|attribute
argument_list|)
operator|==
name|TYPE_SLONG
condition|)
block|{
name|glong
name|canon_cs
decl_stmt|;
name|val
operator|=
name|gimp_attribute_get_value
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|canon_cs
operator|=
name|g_value_get_long
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|canon_cs
operator|==
literal|0x01
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
elseif|else
if|if
condition|(
name|canon_cs
operator|==
literal|0x02
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
block|}
block|}
if|if
condition|(
name|exif_cs
operator|==
literal|0xffff
condition|)
return|return
name|GIMP_METADATA_COLORSPACE_UNCALIBRATED
return|;
block|}
return|return
name|GIMP_METADATA_COLORSPACE_UNSPECIFIED
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_resolution:  * @metadata: A #GimpMetadata instance.  * @xres:     Return location for the X Resolution, in ppi  * @yres:     Return location for the Y Resolution, in ppi  * @unit:     Return location for the unit unit  *  * Returns values based on Exif.Image.XResolution,  * Exif.Image.YResolution and Exif.Image.ResolutionUnit of @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_get_resolution (GimpMetadata * metadata,gdouble * xres,gdouble * yres,GimpUnit * unit)
name|gimp_metadata_get_resolution
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gdouble
modifier|*
name|xres
parameter_list|,
name|gdouble
modifier|*
name|yres
parameter_list|,
name|GimpUnit
modifier|*
name|unit
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|x_attribute
decl_stmt|;
name|GimpAttribute
modifier|*
name|y_attribute
decl_stmt|;
name|GimpAttribute
modifier|*
name|res_attribute
decl_stmt|;
name|gint
name|xnom
decl_stmt|,
name|xdenom
decl_stmt|;
name|gint
name|ynom
decl_stmt|,
name|ydenom
decl_stmt|;
name|gint
name|exif_unit
init|=
literal|2
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|x_attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.XResolution"
argument_list|)
expr_stmt|;
name|y_attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.YResolution"
argument_list|)
expr_stmt|;
name|res_attribute
operator|=
name|gimp_metadata_get_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.ResolutionUnit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_attribute
condition|)
block|{
name|GValue
name|value
decl_stmt|;
name|Rational
modifier|*
name|rats
decl_stmt|;
name|gint
modifier|*
name|_nom
decl_stmt|;
name|gint
modifier|*
name|_denom
decl_stmt|;
name|gint
name|l
decl_stmt|;
name|value
operator|=
name|gimp_attribute_get_value
argument_list|(
name|x_attribute
argument_list|)
expr_stmt|;
name|rats
operator|=
name|g_value_get_boxed
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|rational_to_int
argument_list|(
name|rats
argument_list|,
operator|&
name|_nom
argument_list|,
operator|&
name|_denom
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|xnom
operator|=
name|_nom
index|[
literal|0
index|]
expr_stmt|;
name|xdenom
operator|=
name|_denom
index|[
literal|0
index|]
expr_stmt|;
block|}
name|rational_free
argument_list|(
name|rats
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|y_attribute
condition|)
block|{
name|GValue
name|value
decl_stmt|;
name|Rational
modifier|*
name|rats
decl_stmt|;
name|gint
modifier|*
name|_nom
decl_stmt|;
name|gint
modifier|*
name|_denom
decl_stmt|;
name|gint
name|l
decl_stmt|;
name|value
operator|=
name|gimp_attribute_get_value
argument_list|(
name|y_attribute
argument_list|)
expr_stmt|;
name|rats
operator|=
name|g_value_get_boxed
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|rational_to_int
argument_list|(
name|rats
argument_list|,
operator|&
name|_nom
argument_list|,
operator|&
name|_denom
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|ynom
operator|=
name|_nom
index|[
literal|0
index|]
expr_stmt|;
name|ydenom
operator|=
name|_denom
index|[
literal|0
index|]
expr_stmt|;
block|}
name|rational_free
argument_list|(
name|rats
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|res_attribute
condition|)
block|{
name|GValue
name|value
init|=
name|gimp_attribute_get_value
argument_list|(
name|res_attribute
argument_list|)
decl_stmt|;
name|exif_unit
operator|=
operator|(
name|gint
operator|)
name|g_value_get_uint
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xnom
operator|!=
literal|0
operator|&&
name|xdenom
operator|!=
literal|0
operator|&&
name|ynom
operator|!=
literal|0
operator|&&
name|ydenom
operator|!=
literal|0
condition|)
block|{
name|gdouble
name|xresolution
init|=
operator|(
name|gdouble
operator|)
name|xnom
operator|/
operator|(
name|gdouble
operator|)
name|xdenom
decl_stmt|;
name|gdouble
name|yresolution
init|=
operator|(
name|gdouble
operator|)
name|ynom
operator|/
operator|(
name|gdouble
operator|)
name|ydenom
decl_stmt|;
if|if
condition|(
name|exif_unit
operator|==
literal|3
condition|)
block|{
name|xresolution
operator|*=
literal|2.54
expr_stmt|;
name|yresolution
operator|*=
literal|2.54
expr_stmt|;
block|}
if|if
condition|(
name|xresolution
operator|>=
name|GIMP_MIN_RESOLUTION
operator|&&
name|xresolution
operator|<=
name|GIMP_MAX_RESOLUTION
operator|&&
name|yresolution
operator|>=
name|GIMP_MIN_RESOLUTION
operator|&&
name|yresolution
operator|<=
name|GIMP_MAX_RESOLUTION
condition|)
block|{
if|if
condition|(
name|xres
condition|)
operator|*
name|xres
operator|=
name|xresolution
expr_stmt|;
if|if
condition|(
name|yres
condition|)
operator|*
name|yres
operator|=
name|yresolution
expr_stmt|;
if|if
condition|(
name|unit
condition|)
block|{
if|if
condition|(
name|exif_unit
operator|==
literal|3
condition|)
operator|*
name|unit
operator|=
name|GIMP_UNIT_MM
expr_stmt|;
else|else
operator|*
name|unit
operator|=
name|GIMP_UNIT_INCH
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_bits_per_sample:  * @metadata: A #GimpMetadata instance.  * @bps:      Bytes per pixel, per component  *  * Sets Exif.Image.BitsPerSample on @metadata.  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_bits_per_sample (GimpMetadata * metadata,gint bps)
name|gimp_metadata_set_bits_per_sample
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gint
name|bps
parameter_list|)
block|{
name|gchar
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|metadata
operator|)
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|bps
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.BitsPerSample"
argument_list|,
name|buffer
argument_list|,
name|TYPE_SHORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_pixel_size:  * @metadata: A #GimpMetadata instance.  * @width:    Width in pixels  * @height:   Height in pixels  *  * Sets Exif.Image.ImageWidth and Exif.Image.ImageLength on @metadata.  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_pixel_size (GimpMetadata * metadata,gint width,gint height)
name|gimp_metadata_set_pixel_size
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gchar
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.ImageWidth"
argument_list|,
name|buffer
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.ImageLength"
argument_list|,
name|buffer
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_colorspace:  * @metadata:   A #GimpMetadata instance.  * @colorspace: The color space.  *  * Sets Exif.Photo.ColorSpace, Xmp.exif.ColorSpace,  * Exif.Iop.InteroperabilityIndex, Exif.Nikon3.ColorSpace,  * Exif.Canon.ColorSpace of @metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_colorspace (GimpMetadata * metadata,GimpMetadataColorspace colorspace)
name|gimp_metadata_set_colorspace
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpMetadataColorspace
name|colorspace
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|colorspace
condition|)
block|{
case|case
name|GIMP_METADATA_COLORSPACE_UNSPECIFIED
case|:
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_METADATA_COLORSPACE_UNCALIBRATED
case|:
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|,
literal|"0xffff"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|,
literal|"0xffff"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_METADATA_COLORSPACE_SRGB
case|:
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|,
literal|"0x01"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|,
literal|"0x01"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|,
literal|"R98"
argument_list|,
name|TYPE_ASCII
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_metadata_has_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
condition|)
block|{
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|,
literal|"0x01"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimp_metadata_has_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
condition|)
block|{
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|,
literal|"0x01"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_METADATA_COLORSPACE_ADOBERGB
case|:
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|,
literal|"0x02"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|,
literal|"0x02"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|,
literal|"R03"
argument_list|,
name|TYPE_ASCII
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_metadata_has_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
condition|)
block|{
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|,
literal|"0x02"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimp_metadata_has_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
condition|)
block|{
name|gimp_metadata_remove_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|,
literal|"0x02"
argument_list|,
name|TYPE_LONG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_resolution:  * @metadata: A #GimpMetadata instance.  * @xres:     The image's X Resolution, in ppi  * @yres:     The image's Y Resolution, in ppi  * @unit:     The image's unit  *  * Sets Exif.Image.XResolution, Exif.Image.YResolution and  * Exif.Image.ResolutionUnit @metadata.  *  * Since: GIMP 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_resolution (GimpMetadata * metadata,gdouble xres,gdouble yres,GimpUnit unit)
name|gimp_metadata_set_resolution
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gdouble
name|xres
parameter_list|,
name|gdouble
name|yres
parameter_list|,
name|GimpUnit
name|unit
parameter_list|)
block|{
name|gchar
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|gint
name|exif_unit
decl_stmt|;
name|gint
name|factor
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|IS_GIMP_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_unit_is_metric
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|xres
operator|/=
literal|2.54
expr_stmt|;
name|yres
operator|/=
literal|2.54
expr_stmt|;
name|exif_unit
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|exif_unit
operator|=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|factor
operator|=
literal|1
init|;
name|factor
operator|<=
literal|100
comment|/* arbitrary */
condition|;
name|factor
operator|++
control|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|xres
operator|*
name|factor
operator|-
name|ROUND
argument_list|(
name|xres
operator|*
name|factor
argument_list|)
argument_list|)
operator|<
literal|0.01
operator|&&
name|fabs
argument_list|(
name|yres
operator|*
name|factor
operator|-
name|ROUND
argument_list|(
name|yres
operator|*
name|factor
argument_list|)
argument_list|)
operator|<
literal|0.01
condition|)
break|break;
block|}
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d/%d"
argument_list|,
name|ROUND
argument_list|(
name|xres
operator|*
name|factor
argument_list|)
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.XResolution"
argument_list|,
name|buffer
argument_list|,
name|TYPE_RATIONAL
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d/%d"
argument_list|,
name|ROUND
argument_list|(
name|yres
operator|*
name|factor
argument_list|)
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.YResolution"
argument_list|,
name|buffer
argument_list|,
name|TYPE_RATIONAL
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|exif_unit
argument_list|)
expr_stmt|;
name|gimp_metadata_new_attribute
argument_list|(
name|metadata
argument_list|,
literal|"Exif.Image.ResolutionUnit"
argument_list|,
name|buffer
argument_list|,
name|TYPE_SHORT
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

