begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMPBASE - The GIMP Basic Library  * Copyright (C) 1995-1997 Peter Mattis and Spencer Kimball  *  * gimpmetadata.c  * Copyright (C) 2013 Hartmut Kuhse<hartmutkuhse@src.gnome.org>  *                    Michael Natterer<mitch@gimp.org>  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gio/gio.h>
end_include

begin_include
include|#
directive|include
file|<gexiv2/gexiv2.h>
end_include

begin_include
include|#
directive|include
file|"libgimpmath/gimpmath.h"
end_include

begin_include
include|#
directive|include
file|"gimpbasetypes.h"
end_include

begin_include
include|#
directive|include
file|"gimplimits.h"
end_include

begin_include
include|#
directive|include
file|"gimpmetadata.h"
end_include

begin_include
include|#
directive|include
file|"gimpunit.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/libgimp-intl.h"
end_include

begin_typedef
DECL|typedef|GimpMetadataClass
typedef|typedef
name|struct
name|_GimpMetadataClass
name|GimpMetadataClass
typedef|;
end_typedef

begin_typedef
DECL|typedef|GimpMetadataPrivate
typedef|typedef
name|struct
name|_GimpMetadataPrivate
name|GimpMetadataPrivate
typedef|;
end_typedef

begin_struct
DECL|struct|_GimpMetadata
struct|struct
name|_GimpMetadata
block|{
DECL|member|parent_instance
name|GExiv2Metadata
name|parent_instance
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_GimpMetadataPrivate
struct|struct
name|_GimpMetadataPrivate
block|{
comment|/* dummy entry to avoid a critical warning due to size 0 */
DECL|member|_gimp_reserved1
name|gpointer
name|_gimp_reserved1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_GimpMetadataClass
struct|struct
name|_GimpMetadataClass
block|{
DECL|member|parent_class
name|GExiv2MetadataClass
name|parent_class
decl_stmt|;
comment|/* Padding for future expansion */
DECL|member|_gimp_reserved1
name|void
function_decl|(
modifier|*
name|_gimp_reserved1
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved2
name|void
function_decl|(
modifier|*
name|_gimp_reserved2
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved3
name|void
function_decl|(
modifier|*
name|_gimp_reserved3
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved4
name|void
function_decl|(
modifier|*
name|_gimp_reserved4
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved5
name|void
function_decl|(
modifier|*
name|_gimp_reserved5
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved6
name|void
function_decl|(
modifier|*
name|_gimp_reserved6
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved7
name|void
function_decl|(
modifier|*
name|_gimp_reserved7
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
DECL|member|_gimp_reserved8
name|void
function_decl|(
modifier|*
name|_gimp_reserved8
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * SECTION: gimpmetadata  * @title: gimpmetadata  * @short_description: Basic functions for handling #GimpMetadata objects.  * @see_also: gimp_image_metadata_load_prepare(),  *            gimp_image_metadata_load_finish(),  *            gimp_image_metadata_load_prepare(),  *            gimp_image_metadata_load_finish().  *  * Basic functions for handling #GimpMetadata objects.  **/
end_comment

begin_function_decl
specifier|static
name|GQuark
name|gimp_metadata_error_quark
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_metadata_add
parameter_list|(
name|GimpMetadata
modifier|*
name|src
parameter_list|,
name|GimpMetadata
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|tiff_tags
specifier|static
specifier|const
name|gchar
modifier|*
name|tiff_tags
index|[]
init|=
block|{
literal|"Xmp.tiff"
block|,
literal|"Exif.Image.ImageWidth"
block|,
literal|"Exif.Image.ImageLength"
block|,
literal|"Exif.Image.BitsPerSample"
block|,
literal|"Exif.Image.Compression"
block|,
literal|"Exif.Image.PhotometricInterpretation"
block|,
literal|"Exif.Image.FillOrder"
block|,
literal|"Exif.Image.SamplesPerPixel"
block|,
literal|"Exif.Image.StripOffsets"
block|,
literal|"Exif.Image.RowsPerStrip"
block|,
literal|"Exif.Image.StripByteCounts"
block|,
literal|"Exif.Image.PlanarConfiguration"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|jpeg_tags
specifier|static
specifier|const
name|gchar
modifier|*
name|jpeg_tags
index|[]
init|=
block|{
literal|"Exif.Image.JPEGProc"
block|,
literal|"Exif.Image.JPEGInterchangeFormat"
block|,
literal|"Exif.Image.JPEGInterchangeFormatLength"
block|,
literal|"Exif.Image.JPEGRestartInterval"
block|,
literal|"Exif.Image.JPEGLosslessPredictors"
block|,
literal|"Exif.Image.JPEGPointTransforms"
block|,
literal|"Exif.Image.JPEGQTables"
block|,
literal|"Exif.Image.JPEGDCTables"
block|,
literal|"Exif.Image.JPEGACTables"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|unsupported_tags
specifier|static
specifier|const
name|gchar
modifier|*
name|unsupported_tags
index|[]
init|=
block|{
literal|"Exif.Image.SubIFDs"
block|,
literal|"Exif.Image.ClipPath"
block|,
literal|"Exif.Image.XClipPathUnits"
block|,
literal|"Exif.Image.YClipPathUnits"
block|,
literal|"Exif.Image.XPTitle"
block|,
literal|"Exif.Image.XPComment"
block|,
literal|"Exif.Image.XPAuthor"
block|,
literal|"Exif.Image.XPKeywords"
block|,
literal|"Exif.Image.XPSubject"
block|,
literal|"Exif.Image.DNGVersion"
block|,
literal|"Exif.Image.DNGBackwardVersion"
block|,
literal|"Exif.Iop"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|minimal_exif
specifier|static
specifier|const
name|guint8
name|minimal_exif
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xd8
block|,
literal|0xff
block|,
literal|0xe0
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x4a
block|,
literal|0x46
block|,
literal|0x49
block|,
literal|0x46
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xe1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|wilber_jpg
specifier|static
specifier|const
name|guint8
name|wilber_jpg
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xd8
block|,
literal|0xff
block|,
literal|0xe0
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x4a
block|,
literal|0x46
block|,
literal|0x49
block|,
literal|0x46
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x5a
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xdb
block|,
literal|0x00
block|,
literal|0x43
block|,
literal|0x00
block|,
literal|0x50
block|,
literal|0x37
block|,
literal|0x3c
block|,
literal|0x46
block|,
literal|0x3c
block|,
literal|0x32
block|,
literal|0x50
block|,
literal|0x46
block|,
literal|0x41
block|,
literal|0x46
block|,
literal|0x5a
block|,
literal|0x55
block|,
literal|0x50
block|,
literal|0x5f
block|,
literal|0x78
block|,
literal|0xc8
block|,
literal|0x82
block|,
literal|0x78
block|,
literal|0x6e
block|,
literal|0x6e
block|,
literal|0x78
block|,
literal|0xf5
block|,
literal|0xaf
block|,
literal|0xb9
block|,
literal|0x91
block|,
literal|0xc8
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xdb
block|,
literal|0x00
block|,
literal|0x43
block|,
literal|0x01
block|,
literal|0x55
block|,
literal|0x5a
block|,
literal|0x5a
block|,
literal|0x78
block|,
literal|0x69
block|,
literal|0x78
block|,
literal|0xeb
block|,
literal|0x82
block|,
literal|0x82
block|,
literal|0xeb
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xc0
block|,
literal|0x00
block|,
literal|0x11
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x22
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x11
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x16
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x1e
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x31
block|,
literal|0x04
block|,
literal|0x12
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0x71
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x14
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xc4
block|,
literal|0x00
block|,
literal|0x14
block|,
literal|0x11
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xda
block|,
literal|0x00
block|,
literal|0x0c
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x11
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x00
block|,
literal|0x3f
block|,
literal|0x00
block|,
literal|0x18
block|,
literal|0xa0
block|,
literal|0x0e
block|,
literal|0x6d
block|,
literal|0xbc
block|,
literal|0xf5
block|,
literal|0xca
block|,
literal|0xf7
block|,
literal|0x78
block|,
literal|0xb6
block|,
literal|0xfe
block|,
literal|0x3b
block|,
literal|0x23
block|,
literal|0xb2
block|,
literal|0x1d
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0xf0
block|,
literal|0x8a
block|,
literal|0x39
block|,
literal|0x4b
block|,
literal|0x74
block|,
literal|0x9c
block|,
literal|0xa5
block|,
literal|0x5f
block|,
literal|0x35
block|,
literal|0x8a
block|,
literal|0xb2
block|,
literal|0x7e
block|,
literal|0xa0
block|,
literal|0xff
block|,
literal|0xd9
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|guint
name|wilber_jpg_len
init|=
name|G_N_ELEMENTS
argument_list|(
name|wilber_jpg
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|G_DEFINE_TYPE_WITH_PRIVATE (GimpMetadata,gimp_metadata,GEXIV2_TYPE_METADATA)
name|G_DEFINE_TYPE_WITH_PRIVATE
argument_list|(
argument|GimpMetadata
argument_list|,
argument|gimp_metadata
argument_list|,
argument|GEXIV2_TYPE_METADATA
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|gimp_metadata_class_init
parameter_list|(
name|GimpMetadataClass
modifier|*
name|klass
parameter_list|)
block|{
comment|/* this is just a placeholder class to avoid being limited by    * GExiv2Metadata in the future...    */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_init (GimpMetadata * metadata)
name|gimp_metadata_init
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
comment|/* this is just a placeholder class to avoid being limited by    * GExiv2Metadata in the future...    */
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_register_xmp_namespace:  *  * Register XMP a new namespace.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_register_xmp_namespace (const gchar * nspace,const gchar * prefix)
name|gimp_metadata_register_xmp_namespace
parameter_list|(
specifier|const
name|gchar
modifier|*
name|nspace
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefix
parameter_list|)
block|{
name|gboolean
name|gexiv2_registered_namespace
decl_stmt|;
name|gexiv2_registered_namespace
operator|=
name|gexiv2_metadata_register_xmp_namespace
argument_list|(
name|nspace
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_registered_namespace
operator|==
name|FALSE
condition|)
block|{
name|g_printerr
argument_list|(
literal|"Failed to register %s namespace\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_register_xmp_namespaces:  *  * Register XMP namespaces for GIMP and DICOM.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_register_xmp_namespaces (void)
name|gimp_metadata_register_xmp_namespaces
parameter_list|(
name|void
parameter_list|)
block|{
name|gimp_metadata_register_xmp_namespace
argument_list|(
literal|"http://ns.adobe.com/DICOM/"
argument_list|,
literal|"DICOM"
argument_list|)
expr_stmt|;
comment|/* Usage example Xmp.GIMP.tagname */
name|gimp_metadata_register_xmp_namespace
argument_list|(
literal|"http://www.gimp.org/xmp/"
argument_list|,
literal|"GIMP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_guid:  *  * Generate Version 4 UUID/GUID.  *  * Return value: The new GUID/UUID string.  *  * Since: 2.10  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_metadata_get_guid (void)
name|gimp_metadata_get_guid
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|int
name|DALLOC
init|=
literal|36
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|long
name|time
decl_stmt|;
name|gint
name|shake
decl_stmt|;
name|gint
name|bake
decl_stmt|;
name|gchar
modifier|*
name|GUID
decl_stmt|;
name|gchar
modifier|*
name|szHex
decl_stmt|;
for|for
control|(
name|shake
operator|=
literal|0
init|;
name|shake
operator|<
literal|10
condition|;
name|shake
operator|++
control|)
block|{
name|timespec_get
argument_list|(
operator|&
name|ts
argument_list|,
name|TIME_UTC
argument_list|)
expr_stmt|;
name|time
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|srand
argument_list|(
name|time
argument_list|)
expr_stmt|;
block|}
name|GUID
operator|=
operator|(
name|gchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|DALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GUID
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|GUID
argument_list|,
literal|0
argument_list|,
name|DALLOC
argument_list|)
expr_stmt|;
name|bake
operator|=
literal|0
expr_stmt|;
name|szHex
operator|=
literal|"0123456789abcdef-"
expr_stmt|;
for|for
control|(
name|bake
operator|=
literal|0
init|;
name|bake
operator|<
name|DALLOC
condition|;
name|bake
operator|++
control|)
block|{
name|int
name|r
init|=
name|rand
argument_list|()
operator|%
literal|16
decl_stmt|;
name|char
name|c
init|=
literal|' '
decl_stmt|;
switch|switch
condition|(
name|bake
condition|)
block|{
default|default :
name|c
operator|=
name|szHex
index|[
name|r
index|]
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|c
operator|=
name|szHex
index|[
name|r
operator|&
literal|0x03
operator||
literal|0x08
index|]
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|13
case|:
case|case
literal|18
case|:
case|case
literal|23
case|:
name|c
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|c
operator|=
literal|'4'
expr_stmt|;
break|break;
block|}
name|GUID
index|[
name|bake
index|]
operator|=
operator|(
name|bake
operator|<
name|DALLOC
operator|)
condition|?
name|c
else|:
literal|0x00
expr_stmt|;
block|}
return|return
name|GUID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_add_history:  *  * Add XMP mm History data to file metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_add_xmp_history (GimpMetadata * metadata,gchar * state_status)
name|gimp_metadata_add_xmp_history
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gchar
modifier|*
name|state_status
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|now_tm
decl_stmt|;
name|char
name|timestr
index|[
literal|256
index|]
decl_stmt|;
name|char
name|tzstr
index|[
literal|7
index|]
decl_stmt|;
name|gchar
name|iid_data
index|[
literal|256
index|]
decl_stmt|;
name|gchar
name|strdata
index|[
literal|1024
index|]
decl_stmt|;
name|gchar
name|tagstr
index|[
literal|1024
index|]
decl_stmt|;
name|gchar
modifier|*
name|uuid
decl_stmt|;
name|gint
name|id_count
decl_stmt|;
name|gint
name|found
decl_stmt|;
name|gint
name|lastfound
decl_stmt|;
name|gchar
modifier|*
name|tags
index|[]
init|=
block|{
literal|"Xmp.xmpMM.InstanceID"
block|,
literal|"Xmp.xmpMM.DocumentID"
block|,
literal|"Xmp.xmpMM.OriginalDocumentID"
block|,
literal|"Xmp.xmpMM.History"
block|}
decl_stmt|;
name|gchar
modifier|*
name|history_tags
index|[]
init|=
block|{
literal|"/stEvt:action"
block|,
literal|"/stEvt:instanceID"
block|,
literal|"/stEvt:when"
block|,
literal|"/stEvt:softwareAgent"
block|,
literal|"/stEvt:changed"
block|}
decl_stmt|;
comment|/* Update new Instance ID */
name|uuid
operator|=
name|gimp_metadata_get_guid
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|iid_data
argument_list|,
literal|"xmp.iid:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|iid_data
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
name|tags
index|[
literal|0
index|]
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|iid_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuid
condition|)
name|g_free
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
comment|/* Update new Document ID if none found */
name|gchar
modifier|*
name|did
init|=
name|gexiv2_metadata_get_tag_interpreted_string
argument_list|(
name|metadata
argument_list|,
name|tags
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|did
operator|||
name|strlen
argument_list|(
name|did
argument_list|)
operator|<
literal|1
condition|)
block|{
name|gchar
name|did_data
index|[
literal|256
index|]
decl_stmt|;
name|uuid
operator|=
name|gimp_metadata_get_guid
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|did_data
argument_list|,
literal|"gimp:docid:gimp:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|did_data
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
name|tags
index|[
literal|1
index|]
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|did_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuid
condition|)
name|g_free
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
block|}
comment|/* Update new Original Document ID if none found */
name|gchar
modifier|*
name|odid
init|=
name|gexiv2_metadata_get_tag_interpreted_string
argument_list|(
name|metadata
argument_list|,
name|tags
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|odid
operator|||
name|strlen
argument_list|(
name|odid
argument_list|)
operator|<
literal|1
condition|)
block|{
name|gchar
name|did_data
index|[
literal|256
index|]
decl_stmt|;
name|gchar
modifier|*
name|uuid
init|=
name|gimp_metadata_get_guid
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|did_data
argument_list|,
literal|"xmp.did:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|did_data
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
name|tags
index|[
literal|2
index|]
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|did_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuid
condition|)
name|g_free
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
block|}
comment|/* Handle Xmp.xmpMM.History */
name|gexiv2_metadata_set_xmp_tag_struct
argument_list|(
name|metadata
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|GEXIV2_STRUCTURE_XA_SEQ
argument_list|)
expr_stmt|;
comment|/* Find current number of entries for Xmp.xmpMM.History */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gint
name|count
init|=
literal|1
init|;
name|count
operator|<
literal|65536
condition|;
name|count
operator|++
control|)
block|{
name|lastfound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
literal|5
condition|;
name|ii
operator|++
control|)
block|{
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"%s[%d]%s"
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|count
argument_list|,
name|history_tags
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|metadata
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|)
condition|)
block|{
name|lastfound
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastfound
operator|==
literal|0
condition|)
break|break;
name|found
operator|++
expr_stmt|;
block|}
name|id_count
operator|=
name|found
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
name|tagstr
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strdata
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"%s[%d]%s"
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|id_count
argument_list|,
name|history_tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"saved"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tagstr
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strdata
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|uuid
operator|=
name|gimp_metadata_get_guid
argument_list|()
expr_stmt|;
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"%s[%d]%s"
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|id_count
argument_list|,
name|history_tags
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|strdata
argument_list|,
literal|"xmp.iid:%s"
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|strdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuid
condition|)
name|g_free
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tagstr
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strdata
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"%s[%d]%s"
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|id_count
argument_list|,
name|history_tags
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* get local time */
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|now_tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* get timezone and fix format */
name|strftime
argument_list|(
name|tzstr
argument_list|,
literal|7
argument_list|,
literal|"%z"
argument_list|,
name|now_tm
argument_list|)
expr_stmt|;
name|tzstr
index|[
literal|5
index|]
operator|=
name|tzstr
index|[
literal|4
index|]
expr_stmt|;
name|tzstr
index|[
literal|4
index|]
operator|=
name|tzstr
index|[
literal|3
index|]
expr_stmt|;
name|tzstr
index|[
literal|3
index|]
operator|=
literal|':'
expr_stmt|;
comment|/* get current time and timezone string */
name|strftime
argument_list|(
name|timestr
argument_list|,
literal|256
argument_list|,
literal|"%Y-%m-%dT%H:%M:%S"
argument_list|,
name|now_tm
argument_list|)
expr_stmt|;
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|timestr
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|timestr
argument_list|,
name|tzstr
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|timestr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tagstr
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strdata
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"%s[%d]%s"
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|id_count
argument_list|,
name|history_tags
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"Gimp 2.9/2.10 "
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
literal|"(Windows)"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
literal|"(Linux)"
block|)
function|;
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MACH__
argument_list|)
end_elif

begin_expr_stmt
literal|"(Mac OS)"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|unix
argument_list|)
operator|||
name|defined
argument_list|(
name|__unix__
argument_list|)
operator|||
name|defined
argument_list|(
name|__unix
argument_list|)
end_elif

begin_expr_stmt
literal|"(Unix)"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|"(Unknown)"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|memset
argument_list|(
name|tagstr
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|memset
argument_list|(
name|strdata
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|g_sprintf
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
literal|"%s[%d]%s"
argument_list|,
name|tags
index|[
literal|3
index|]
argument_list|,
name|id_count
argument_list|,
name|history_tags
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strcpy
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|strdata
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strcat
argument_list|(
operator|(
name|gchar
operator|*
operator|)
operator|&
name|strdata
argument_list|,
name|state_status
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gexiv2_metadata_set_tag_string
argument_list|(
name|metadata
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|tagstr
argument_list|,
operator|(
name|gchar
operator|*
operator|)
operator|&
name|strdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**  * gimp_metadata_new:  *  * Creates a new #GimpMetadata instance.  *  * Return value: The new #GimpMetadata.  *  * Since: 2.10  */
end_comment

begin_expr_stmt
unit|GimpMetadata
operator|*
DECL|function|gimp_metadata_new (void)
name|gimp_metadata_new
argument_list|(
argument|void
argument_list|)
block|{
name|GimpMetadata
operator|*
name|metadata
operator|=
name|NULL
block|;
if|if
condition|(
name|gexiv2_initialize
argument_list|()
condition|)
block|{
name|metadata
operator|=
name|g_object_new
argument_list|(
name|GIMP_TYPE_METADATA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gexiv2_metadata_new
argument_list|()
expr_stmt|;
name|gimp_metadata_register_xmp_namespaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|wilber_jpg
argument_list|,
name|wilber_jpg_len
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    return
name|metadata
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**  * gimp_metadata_duplicate:  * @metadata: The object to duplicate, or %NULL.  *  * Duplicates a #GimpMetadata instance.  *  * Return value: The new #GimpMetadata, or %NULL if @metadata is %NULL.  *  * Since: 2.10  */
end_comment

begin_expr_stmt
unit|GimpMetadata
operator|*
DECL|function|gimp_metadata_duplicate (GimpMetadata * metadata)
name|gimp_metadata_duplicate
argument_list|(
argument|GimpMetadata *metadata
argument_list|)
block|{
name|GimpMetadata
operator|*
name|new_metadata
operator|=
name|NULL
block|;
name|g_return_val_if_fail
argument_list|(
name|metadata
operator|==
name|NULL
operator|||
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
block|;
if|if
condition|(
name|metadata
condition|)
block|{
name|gchar
modifier|*
name|xml
decl_stmt|;
name|xml
operator|=
name|gimp_metadata_serialize
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|new_metadata
operator|=
name|gimp_metadata_deserialize
argument_list|(
name|xml
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|xml
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|new_metadata
return|;
end_return

begin_struct
unit|}  typedef
struct|struct
DECL|struct|__anon2b2f2ef40108
block|{
DECL|member|name
name|gchar
name|name
index|[
literal|1024
index|]
decl_stmt|;
DECL|member|base64
name|gboolean
name|base64
decl_stmt|;
DECL|member|metadata
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
DECL|typedef|GimpMetadataParseData
block|}
name|GimpMetadataParseData
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|gchar
modifier|*
DECL|function|gimp_metadata_attribute_name_to_value (const gchar ** attribute_names,const gchar ** attribute_values,const gchar * name)
name|gimp_metadata_attribute_name_to_value
parameter_list|(
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
while|while
condition|(
operator|*
name|attribute_names
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|attribute_names
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|*
name|attribute_values
return|;
block|}
name|attribute_names
operator|++
expr_stmt|;
name|attribute_values
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_start_element (GMarkupParseContext * context,const gchar * element_name,const gchar ** attribute_names,const gchar ** attribute_values,gpointer user_data,GError ** error)
name|gimp_metadata_deserialize_start_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadataParseData
modifier|*
name|parse_data
init|=
name|user_data
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"tag"
argument_list|)
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|encoding
decl_stmt|;
name|name
operator|=
name|gimp_metadata_attribute_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|gimp_metadata_attribute_name_to_value
argument_list|(
name|attribute_names
argument_list|,
name|attribute_values
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|1001
argument_list|,
literal|"Element 'tag' does not contain required attribute 'name'."
argument_list|)
expr_stmt|;
return|return;
block|}
name|strncpy
argument_list|(
name|parse_data
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|parse_data
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|parse_data
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|parse_data
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|parse_data
operator|->
name|base64
operator|=
operator|(
name|encoding
operator|&&
operator|!
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_end_element (GMarkupParseContext * context,const gchar * element_name,gpointer user_data,GError ** error)
name|gimp_metadata_deserialize_end_element
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_text (GMarkupParseContext * context,const gchar * text,gsize text_len,gpointer user_data,GError ** error)
name|gimp_metadata_deserialize_text
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadataParseData
modifier|*
name|parse_data
init|=
name|user_data
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|current_element
decl_stmt|;
name|current_element
operator|=
name|g_markup_parse_context_get_element
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|current_element
argument_list|,
literal|"tag"
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|value
init|=
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|parse_data
operator|->
name|base64
condition|)
block|{
name|guchar
modifier|*
name|decoded
decl_stmt|;
name|gsize
name|len
decl_stmt|;
name|decoded
operator|=
name|g_base64_decode
argument_list|(
name|value
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|parse_data
operator|->
name|metadata
argument_list|)
argument_list|,
name|parse_data
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|decoded
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|parse_data
operator|->
name|metadata
argument_list|)
argument_list|,
name|parse_data
operator|->
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_deserialize_error (GMarkupParseContext * context,GError * error,gpointer user_data)
name|gimp_metadata_deserialize_error
parameter_list|(
name|GMarkupParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
name|error
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|g_printerr
argument_list|(
literal|"Metadata parse error: %s\n"
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_deserialize:  * @metadata_xml: A string of serialized metadata XML.  *  * Deserializes a string of XML that has been created by  * gimp_metadata_serialize().  *  * Return value: The new #GimpMetadata.  *  * Since: 2.10  */
end_comment

begin_function
name|GimpMetadata
modifier|*
DECL|function|gimp_metadata_deserialize (const gchar * metadata_xml)
name|gimp_metadata_deserialize
parameter_list|(
specifier|const
name|gchar
modifier|*
name|metadata_xml
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
name|GMarkupParser
name|markup_parser
decl_stmt|;
name|GimpMetadataParseData
name|parse_data
decl_stmt|;
name|GMarkupParseContext
modifier|*
name|context
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|metadata_xml
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|metadata
operator|=
name|gimp_metadata_new
argument_list|()
expr_stmt|;
name|parse_data
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|markup_parser
operator|.
name|start_element
operator|=
name|gimp_metadata_deserialize_start_element
expr_stmt|;
name|markup_parser
operator|.
name|end_element
operator|=
name|gimp_metadata_deserialize_end_element
expr_stmt|;
name|markup_parser
operator|.
name|text
operator|=
name|gimp_metadata_deserialize_text
expr_stmt|;
name|markup_parser
operator|.
name|passthrough
operator|=
name|NULL
expr_stmt|;
name|markup_parser
operator|.
name|error
operator|=
name|gimp_metadata_deserialize_error
expr_stmt|;
name|context
operator|=
name|g_markup_parse_context_new
argument_list|(
operator|&
name|markup_parser
argument_list|,
literal|0
argument_list|,
operator|&
name|parse_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_markup_parse_context_parse
argument_list|(
name|context
argument_list|,
name|metadata_xml
argument_list|,
name|strlen
argument_list|(
name|metadata_xml
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_markup_parse_context_unref
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|metadata
return|;
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_metadata_escape (const gchar * name,const gchar * value,gboolean * base64)
name|gimp_metadata_escape
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|value
parameter_list|,
name|gboolean
modifier|*
name|base64
parameter_list|)
block|{
if|if
condition|(
operator|!
name|g_utf8_validate
argument_list|(
name|value
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|encoded
decl_stmt|;
name|encoded
operator|=
name|g_base64_encode
argument_list|(
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g_printerr
argument_list|(
literal|"Invalid UTF-8 in metadata value %s, encoding as base64: %s\n"
argument_list|,
name|name
argument_list|,
name|encoded
argument_list|)
expr_stmt|;
operator|*
name|base64
operator|=
name|TRUE
expr_stmt|;
return|return
name|encoded
return|;
block|}
operator|*
name|base64
operator|=
name|FALSE
expr_stmt|;
return|return
name|g_markup_escape_text
argument_list|(
name|value
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_append_tag (GString * string,const gchar * name,gchar * value,gboolean base64)
name|gimp_metadata_append_tag
parameter_list|(
name|GString
modifier|*
name|string
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|,
name|gboolean
name|base64
parameter_list|)
block|{
if|if
condition|(
name|value
condition|)
block|{
if|if
condition|(
name|base64
condition|)
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<tag name=\"%s\" encoding=\"base64\">%s</tag>\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<tag name=\"%s\">%s</tag>\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_serialize:  * @metadata: A #GimpMetadata instance.  *  * Serializes @metadata into an XML string that can later be deserialized  * using gimp_metadata_deserialize().  *  * Return value: The serialized XML string.  *  * Since: 2.10  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_metadata_serialize (GimpMetadata * metadata)
name|gimp_metadata_serialize
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|GString
modifier|*
name|string
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|exif_data
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|iptc_data
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|xmp_data
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|value
decl_stmt|;
name|gchar
modifier|*
name|escaped
decl_stmt|;
name|gboolean
name|base64
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<?xml version='1.0' encoding='UTF-8'?>\n"
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"<metadata>\n"
argument_list|)
expr_stmt|;
name|exif_data
operator|=
name|gexiv2_metadata_get_exif_tags
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exif_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|exif_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|exif_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|escaped
operator|=
name|gimp_metadata_escape
argument_list|(
name|exif_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|,
operator|&
name|base64
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|gimp_metadata_append_tag
argument_list|(
name|string
argument_list|,
name|exif_data
index|[
name|i
index|]
argument_list|,
name|escaped
argument_list|,
name|base64
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|exif_data
argument_list|)
expr_stmt|;
block|}
name|xmp_data
operator|=
name|gexiv2_metadata_get_xmp_tags
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmp_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|xmp_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|escaped
operator|=
name|gimp_metadata_escape
argument_list|(
name|xmp_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|,
operator|&
name|base64
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|gimp_metadata_append_tag
argument_list|(
name|string
argument_list|,
name|xmp_data
index|[
name|i
index|]
argument_list|,
name|escaped
argument_list|,
name|base64
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|xmp_data
argument_list|)
expr_stmt|;
block|}
name|iptc_data
operator|=
name|gexiv2_metadata_get_iptc_tags
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptc_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|iptc_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|iptc_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|escaped
operator|=
name|gimp_metadata_escape
argument_list|(
name|iptc_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|,
operator|&
name|base64
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|gimp_metadata_append_tag
argument_list|(
name|string
argument_list|,
name|iptc_data
index|[
name|i
index|]
argument_list|,
name|escaped
argument_list|,
name|base64
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|iptc_data
argument_list|)
expr_stmt|;
block|}
name|g_string_append
argument_list|(
name|string
argument_list|,
literal|"</metadata>\n"
argument_list|)
expr_stmt|;
return|return
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_load_from_file:  * @file:  The #GFile to load the metadata from  * @error: Return location for error message  *  * Loads #GimpMetadata from @file.  *  * Return value: The loaded #GimpMetadata.  *  * Since: 2.10  */
end_comment

begin_function
name|GimpMetadata
modifier|*
DECL|function|gimp_metadata_load_from_file (GFile * file,GError ** error)
name|gimp_metadata_load_from_file
parameter_list|(
name|GFile
modifier|*
name|file
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|meta
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|path
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|G_IS_FILE
argument_list|(
name|file
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|path
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Can load metadata only from local files"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|G_OS_WIN32
name|filename
operator|=
name|g_win32_locale_filename_from_utf8
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
name|filename
operator|=
name|g_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_initialize
argument_list|()
condition|)
block|{
name|meta
operator|=
name|g_object_new
argument_list|(
name|GIMP_TYPE_METADATA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_metadata_register_xmp_namespaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_path
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|meta
argument_list|)
argument_list|,
name|filename
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|meta
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_save_to_file:  * @metadata: A #GimpMetadata instance.  * @file:     The file to save the metadata to  * @error:    Return location for error message  *  * Saves @metadata to @file.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_save_to_file (GimpMetadata * metadata,GFile * file,GError ** error)
name|gimp_metadata_save_to_file
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gchar
modifier|*
name|path
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|G_IS_FILE
argument_list|(
name|file
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|path
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Can save metadata only to local files"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|G_OS_WIN32
name|filename
operator|=
name|g_win32_locale_filename_from_utf8
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
name|filename
operator|=
name|g_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|success
operator|=
name|gexiv2_metadata_save_file
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|filename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_from_exif:  * @metadata:         A #GimpMetadata instance.  * @exif_data:        The blob of Exif data to set  * @exif_data_length: Length of @exif_data, in bytes  * @error:            Return location for error message  *  * Sets the tags from a piece of Exif data on @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_set_from_exif (GimpMetadata * metadata,const guchar * exif_data,gint exif_data_length,GError ** error)
name|gimp_metadata_set_from_exif
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|guchar
modifier|*
name|exif_data
parameter_list|,
name|gint
name|exif_data_length
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GByteArray
modifier|*
name|exif_bytes
decl_stmt|;
name|GimpMetadata
modifier|*
name|exif_metadata
decl_stmt|;
name|guint8
name|data_size
index|[
literal|2
index|]
init|=
block|{
literal|0
block|, }
decl_stmt|;
specifier|const
name|guint8
name|eoi
index|[
literal|2
index|]
init|=
block|{
literal|0xff
block|,
literal|0xd9
block|}
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|exif_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|exif_data_length
operator|>
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|exif_data_length
operator|+
literal|2
operator|<
literal|65536
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|data_size
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|exif_data_length
operator|+
literal|2
operator|)
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
name|data_size
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|exif_data_length
operator|+
literal|2
operator|)
operator|&
literal|0x00FF
operator|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_new
argument_list|()
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
name|minimal_exif
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|minimal_exif
argument_list|)
argument_list|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
name|data_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
operator|(
name|guint8
operator|*
operator|)
name|exif_data
argument_list|,
name|exif_data_length
argument_list|)
expr_stmt|;
name|exif_bytes
operator|=
name|g_byte_array_append
argument_list|(
name|exif_bytes
argument_list|,
name|eoi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exif_metadata
operator|=
name|gimp_metadata_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|exif_metadata
argument_list|)
argument_list|,
name|exif_bytes
operator|->
name|data
argument_list|,
name|exif_bytes
operator|->
name|len
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|g_byte_array_free
argument_list|(
name|exif_bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gexiv2_metadata_has_exif
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|exif_metadata
argument_list|)
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Parsing Exif data failed."
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|g_byte_array_free
argument_list|(
name|exif_bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_metadata_add
argument_list|(
name|exif_metadata
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|exif_metadata
argument_list|)
expr_stmt|;
name|g_byte_array_free
argument_list|(
name|exif_bytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_from_iptc:  * @metadata:        A #GimpMetadata instance.  * @iptc_data:       The blob of Ipc data to set  * @iptc_data_length:Length of @iptc_data, in bytes  * @error:           Return location for error message  *  * Sets the tags from a piece of IPTC data on @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_set_from_iptc (GimpMetadata * metadata,const guchar * iptc_data,gint iptc_data_length,GError ** error)
name|gimp_metadata_set_from_iptc
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|guchar
modifier|*
name|iptc_data
parameter_list|,
name|gint
name|iptc_data_length
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|iptc_metadata
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|iptc_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|iptc_data_length
operator|>
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|iptc_metadata
operator|=
name|gimp_metadata_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|iptc_metadata
argument_list|,
name|iptc_data
argument_list|,
name|iptc_data_length
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|iptc_metadata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gexiv2_metadata_has_iptc
argument_list|(
name|iptc_metadata
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Parsing IPTC data failed."
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|iptc_metadata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_metadata_add
argument_list|(
name|iptc_metadata
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|iptc_metadata
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_from_xmp:  * @metadata:        A #GimpMetadata instance.  * @xmp_data:        The blob of Exif data to set  * @xmp_data_length: Length of @exif_data, in bytes  * @error:           Return location for error message  *  * Sets the tags from a piece of XMP data on @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_set_from_xmp (GimpMetadata * metadata,const guchar * xmp_data,gint xmp_data_length,GError ** error)
name|gimp_metadata_set_from_xmp
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
specifier|const
name|guchar
modifier|*
name|xmp_data
parameter_list|,
name|gint
name|xmp_data_length
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpMetadata
modifier|*
name|xmp_metadata
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_data_length
operator|>
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|error
operator|==
name|NULL
operator|||
operator|*
name|error
operator|==
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|xmp_metadata
operator|=
name|gimp_metadata_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gexiv2_metadata_open_buf
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|xmp_metadata
argument_list|)
argument_list|,
name|xmp_data
argument_list|,
name|xmp_data_length
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|g_object_unref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|gexiv2_metadata_has_xmp
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|xmp_metadata
argument_list|)
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|gimp_metadata_error_quark
argument_list|()
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Parsing XMP data failed."
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_metadata_add
argument_list|(
name|xmp_metadata
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|xmp_metadata
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_pixel_size:  * @metadata: A #GimpMetadata instance.  * @width:    Width in pixels  * @height:   Height in pixels  *  * Sets Exif.Image.ImageWidth and Exif.Image.ImageLength on @metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_pixel_size (GimpMetadata * metadata,gint width,gint height)
name|gimp_metadata_set_pixel_size
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gchar
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.ImageWidth"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.ImageLength"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_bits_per_sample:  * @metadata:        A #GimpMetadata instance.  * @bits_per_sample: Bits per pixel, per component  *  * Sets Exif.Image.BitsPerSample on @metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_bits_per_sample (GimpMetadata * metadata,gint bits_per_sample)
name|gimp_metadata_set_bits_per_sample
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gint
name|bits_per_sample
parameter_list|)
block|{
name|gchar
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d %d %d"
argument_list|,
name|bits_per_sample
argument_list|,
name|bits_per_sample
argument_list|,
name|bits_per_sample
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.BitsPerSample"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_resolution:  * @metadata: A #GimpMetadata instance.  * @xres:     Return location for the X Resolution, in ppi  * @yres:     Return location for the Y Resolution, in ppi  * @unit:     Return location for the unit unit  *  * Returns values based on Exif.Image.XResolution,  * Exif.Image.YResolution and Exif.Image.ResolutionUnit of @metadata.  *  * Return value: %TRUE on success, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_get_resolution (GimpMetadata * metadata,gdouble * xres,gdouble * yres,GimpUnit * unit)
name|gimp_metadata_get_resolution
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gdouble
modifier|*
name|xres
parameter_list|,
name|gdouble
modifier|*
name|yres
parameter_list|,
name|GimpUnit
modifier|*
name|unit
parameter_list|)
block|{
name|gint
name|xnom
decl_stmt|,
name|xdenom
decl_stmt|;
name|gint
name|ynom
decl_stmt|,
name|ydenom
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_get_exif_tag_rational
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.XResolution"
argument_list|,
operator|&
name|xnom
argument_list|,
operator|&
name|xdenom
argument_list|)
operator|&&
name|gexiv2_metadata_get_exif_tag_rational
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.YResolution"
argument_list|,
operator|&
name|ynom
argument_list|,
operator|&
name|ydenom
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|un
decl_stmt|;
name|gint
name|exif_unit
init|=
literal|2
decl_stmt|;
name|un
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.ResolutionUnit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
condition|)
block|{
name|exif_unit
operator|=
name|atoi
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|un
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xnom
operator|!=
literal|0
operator|&&
name|xdenom
operator|!=
literal|0
operator|&&
name|ynom
operator|!=
literal|0
operator|&&
name|ydenom
operator|!=
literal|0
condition|)
block|{
name|gdouble
name|xresolution
init|=
operator|(
name|gdouble
operator|)
name|xnom
operator|/
operator|(
name|gdouble
operator|)
name|xdenom
decl_stmt|;
name|gdouble
name|yresolution
init|=
operator|(
name|gdouble
operator|)
name|ynom
operator|/
operator|(
name|gdouble
operator|)
name|ydenom
decl_stmt|;
if|if
condition|(
name|exif_unit
operator|==
literal|3
condition|)
block|{
name|xresolution
operator|*=
literal|2.54
expr_stmt|;
name|yresolution
operator|*=
literal|2.54
expr_stmt|;
block|}
if|if
condition|(
name|xresolution
operator|>=
name|GIMP_MIN_RESOLUTION
operator|&&
name|xresolution
operator|<=
name|GIMP_MAX_RESOLUTION
operator|&&
name|yresolution
operator|>=
name|GIMP_MIN_RESOLUTION
operator|&&
name|yresolution
operator|<=
name|GIMP_MAX_RESOLUTION
condition|)
block|{
if|if
condition|(
name|xres
condition|)
operator|*
name|xres
operator|=
name|xresolution
expr_stmt|;
if|if
condition|(
name|yres
condition|)
operator|*
name|yres
operator|=
name|yresolution
expr_stmt|;
if|if
condition|(
name|unit
condition|)
block|{
if|if
condition|(
name|exif_unit
operator|==
literal|3
condition|)
operator|*
name|unit
operator|=
name|GIMP_UNIT_MM
expr_stmt|;
else|else
operator|*
name|unit
operator|=
name|GIMP_UNIT_INCH
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_resolution:  * @metadata: A #GimpMetadata instance.  * @xres:     The image's X Resolution, in ppi  * @yres:     The image's Y Resolution, in ppi  * @unit:     The image's unit  *  * Sets Exif.Image.XResolution, Exif.Image.YResolution and  * Exif.Image.ResolutionUnit of @metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_resolution (GimpMetadata * metadata,gdouble xres,gdouble yres,GimpUnit unit)
name|gimp_metadata_set_resolution
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|gdouble
name|xres
parameter_list|,
name|gdouble
name|yres
parameter_list|,
name|GimpUnit
name|unit
parameter_list|)
block|{
name|gchar
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|gint
name|exif_unit
decl_stmt|;
name|gint
name|factor
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GEXIV2_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_unit_is_metric
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|xres
operator|/=
literal|2.54
expr_stmt|;
name|yres
operator|/=
literal|2.54
expr_stmt|;
name|exif_unit
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|exif_unit
operator|=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|factor
operator|=
literal|1
init|;
name|factor
operator|<=
literal|100
comment|/* arbitrary */
condition|;
name|factor
operator|++
control|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|xres
operator|*
name|factor
operator|-
name|ROUND
argument_list|(
name|xres
operator|*
name|factor
argument_list|)
argument_list|)
operator|<
literal|0.01
operator|&&
name|fabs
argument_list|(
name|yres
operator|*
name|factor
operator|-
name|ROUND
argument_list|(
name|yres
operator|*
name|factor
argument_list|)
argument_list|)
operator|<
literal|0.01
condition|)
break|break;
block|}
name|gexiv2_metadata_set_exif_tag_rational
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.XResolution"
argument_list|,
name|ROUND
argument_list|(
name|xres
operator|*
name|factor
argument_list|)
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_exif_tag_rational
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.YResolution"
argument_list|,
name|ROUND
argument_list|(
name|yres
operator|*
name|factor
argument_list|)
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|exif_unit
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Image.ResolutionUnit"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_get_colorspace:  * @metadata: A #GimpMetadata instance.  *  * Returns values based on Exif.Photo.ColorSpace, Xmp.exif.ColorSpace,  * Exif.Iop.InteroperabilityIndex, Exif.Nikon3.ColorSpace,  * Exif.Canon.ColorSpace of @metadata.  *  * Return value: The colorspace specified by above tags.  *  * Since: 2.10  */
end_comment

begin_function
name|GimpMetadataColorspace
DECL|function|gimp_metadata_get_colorspace (GimpMetadata * metadata)
name|gimp_metadata_get_colorspace
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|)
block|{
name|glong
name|exif_cs
init|=
operator|-
literal|1
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
name|GIMP_METADATA_COLORSPACE_UNSPECIFIED
argument_list|)
expr_stmt|;
comment|/*  the logic here was mostly taken from darktable and libkexiv2  */
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|)
condition|)
block|{
name|exif_cs
operator|=
name|gexiv2_metadata_get_tag_long
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
condition|)
block|{
name|exif_cs
operator|=
name|gexiv2_metadata_get_tag_long
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exif_cs
operator|==
literal|0x01
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
elseif|else
if|if
condition|(
name|exif_cs
operator|==
literal|0x02
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
else|else
block|{
if|if
condition|(
name|exif_cs
operator|==
literal|0xffff
condition|)
block|{
name|gchar
modifier|*
name|iop_index
decl_stmt|;
name|iop_index
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|iop_index
argument_list|,
literal|"R03"
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|iop_index
argument_list|)
expr_stmt|;
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|iop_index
argument_list|,
literal|"R98"
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|iop_index
argument_list|)
expr_stmt|;
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
name|g_free
argument_list|(
name|iop_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
condition|)
block|{
name|glong
name|nikon_cs
decl_stmt|;
name|nikon_cs
operator|=
name|gexiv2_metadata_get_tag_long
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nikon_cs
operator|==
literal|0x01
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
elseif|else
if|if
condition|(
name|nikon_cs
operator|==
literal|0x02
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
block|}
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
condition|)
block|{
name|glong
name|canon_cs
decl_stmt|;
name|canon_cs
operator|=
name|gexiv2_metadata_get_tag_long
argument_list|(
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|canon_cs
operator|==
literal|0x01
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_SRGB
return|;
block|}
elseif|else
if|if
condition|(
name|canon_cs
operator|==
literal|0x02
condition|)
block|{
return|return
name|GIMP_METADATA_COLORSPACE_ADOBERGB
return|;
block|}
block|}
if|if
condition|(
name|exif_cs
operator|==
literal|0xffff
condition|)
return|return
name|GIMP_METADATA_COLORSPACE_UNCALIBRATED
return|;
block|}
return|return
name|GIMP_METADATA_COLORSPACE_UNSPECIFIED
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_set_colorspace:  * @metadata:   A #GimpMetadata instance.  * @colorspace: The color space.  *  * Sets Exif.Photo.ColorSpace, Xmp.exif.ColorSpace,  * Exif.Iop.InteroperabilityIndex, Exif.Nikon3.ColorSpace,  * Exif.Canon.ColorSpace of @metadata.  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_metadata_set_colorspace (GimpMetadata * metadata,GimpMetadataColorspace colorspace)
name|gimp_metadata_set_colorspace
parameter_list|(
name|GimpMetadata
modifier|*
name|metadata
parameter_list|,
name|GimpMetadataColorspace
name|colorspace
parameter_list|)
block|{
name|GExiv2Metadata
modifier|*
name|g2metadata
init|=
name|GEXIV2_METADATA
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|colorspace
condition|)
block|{
case|case
name|GIMP_METADATA_COLORSPACE_UNSPECIFIED
case|:
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_METADATA_COLORSPACE_UNCALIBRATED
case|:
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
expr_stmt|;
name|gexiv2_metadata_clear_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_METADATA_COLORSPACE_SRGB
case|:
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_string
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|,
literal|"R98"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_METADATA_COLORSPACE_ADOBERGB
case|:
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Photo.ColorSpace"
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Xmp.exif.ColorSpace"
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_string
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Iop.InteroperabilityIndex"
argument_list|,
literal|"R03"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Nikon3.ColorSpace"
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
if|if
condition|(
name|gexiv2_metadata_has_tag
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|)
condition|)
name|gexiv2_metadata_set_tag_long
argument_list|(
name|g2metadata
argument_list|,
literal|"Exif.Canon.ColorSpace"
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_metadata_is_tag_supported:  * @tag:       A metadata tag name  * @mime_type: A mime type  *  * Returns whether @tag is supported in a file of type @mime_type.  *  * Return value: %TRUE if the @tag supported with @mime_type, %FALSE otherwise.  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_metadata_is_tag_supported (const gchar * tag,const gchar * mime_type)
name|gimp_metadata_is_tag_supported
parameter_list|(
specifier|const
name|gchar
modifier|*
name|tag
parameter_list|,
specifier|const
name|gchar
modifier|*
name|mime_type
parameter_list|)
block|{
name|gint
name|j
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|tag
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|mime_type
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|unsupported_tags
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|tag
argument_list|,
name|unsupported_tags
index|[
name|j
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mime_type
argument_list|,
literal|"image/jpeg"
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|tiff_tags
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|tag
argument_list|,
name|tiff_tags
index|[
name|j
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mime_type
argument_list|,
literal|"image/tiff"
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|jpeg_tags
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|tag
argument_list|,
name|jpeg_tags
index|[
name|j
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* private functions */
end_comment

begin_function
specifier|static
name|GQuark
DECL|function|gimp_metadata_error_quark (void)
name|gimp_metadata_error_quark
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GQuark
name|quark
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|G_UNLIKELY
argument_list|(
name|quark
operator|==
literal|0
argument_list|)
condition|)
name|quark
operator|=
name|g_quark_from_static_string
argument_list|(
literal|"gimp-metadata-error-quark"
argument_list|)
expr_stmt|;
return|return
name|quark
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_metadata_add (GimpMetadata * src,GimpMetadata * dest)
name|gimp_metadata_add
parameter_list|(
name|GimpMetadata
modifier|*
name|src
parameter_list|,
name|GimpMetadata
modifier|*
name|dest
parameter_list|)
block|{
name|GExiv2Metadata
modifier|*
name|g2src
init|=
name|GEXIV2_METADATA
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|GExiv2Metadata
modifier|*
name|g2dest
init|=
name|GEXIV2_METADATA
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|gchar
modifier|*
name|value
decl_stmt|;
name|gint
name|i
decl_stmt|;
if|if
condition|(
name|gexiv2_metadata_get_supports_exif
argument_list|(
name|g2src
argument_list|)
operator|&&
name|gexiv2_metadata_get_supports_exif
argument_list|(
name|g2dest
argument_list|)
condition|)
block|{
name|gchar
modifier|*
modifier|*
name|exif_data
init|=
name|gexiv2_metadata_get_exif_tags
argument_list|(
name|g2src
argument_list|)
decl_stmt|;
if|if
condition|(
name|exif_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|exif_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|g2src
argument_list|,
name|exif_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|g2dest
argument_list|,
name|exif_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|exif_data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gexiv2_metadata_get_supports_xmp
argument_list|(
name|g2src
argument_list|)
operator|&&
name|gexiv2_metadata_get_supports_xmp
argument_list|(
name|g2dest
argument_list|)
condition|)
block|{
name|gchar
modifier|*
modifier|*
name|xmp_data
init|=
name|gexiv2_metadata_get_xmp_tags
argument_list|(
name|g2src
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmp_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|g2src
argument_list|,
name|xmp_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|g2dest
argument_list|,
name|xmp_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|xmp_data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gexiv2_metadata_get_supports_iptc
argument_list|(
name|g2src
argument_list|)
operator|&&
name|gexiv2_metadata_get_supports_iptc
argument_list|(
name|g2dest
argument_list|)
condition|)
block|{
name|gchar
modifier|*
modifier|*
name|iptc_data
init|=
name|gexiv2_metadata_get_iptc_tags
argument_list|(
name|g2src
argument_list|)
decl_stmt|;
if|if
condition|(
name|iptc_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|iptc_data
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|gexiv2_metadata_get_tag_string
argument_list|(
name|g2src
argument_list|,
name|iptc_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gexiv2_metadata_set_tag_string
argument_list|(
name|g2dest
argument_list|,
name|iptc_data
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|g_strfreev
argument_list|(
name|iptc_data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

