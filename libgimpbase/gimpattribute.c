begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMP - The GIMP Library  * Copyright (C) 1995-1997 Spencer Kimball and Peter Mattis  *  * gimpattribute.c  * Copyright (C) 2014  Hartmut Kuhse<hatti@gimp.org>  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib-object.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gimpbasetypes.h"
end_include

begin_include
include|#
directive|include
file|"gimpattribute.h"
end_include

begin_include
include|#
directive|include
file|"gimprational.h"
end_include

begin_define
DECL|macro|_g_free0 (var)
define|#
directive|define
name|_g_free0
parameter_list|(
name|var
parameter_list|)
value|(var = (g_free (var), NULL))
end_define

begin_define
DECL|macro|_g_regex_unref0 (var)
define|#
directive|define
name|_g_regex_unref0
parameter_list|(
name|var
parameter_list|)
value|((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
end_define

begin_define
DECL|macro|_g_error_free0 (var)
define|#
directive|define
name|_g_error_free0
parameter_list|(
name|var
parameter_list|)
value|((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
end_define

begin_typedef
DECL|typedef|TagTime
typedef|typedef
name|struct
name|_TagTime
name|TagTime
typedef|;
end_typedef

begin_typedef
DECL|typedef|TagDate
typedef|typedef
name|struct
name|_TagDate
name|TagDate
typedef|;
end_typedef

begin_struct
DECL|struct|_TagTime
struct|struct
name|_TagTime
block|{
DECL|member|tag_time_sec
name|int
name|tag_time_sec
decl_stmt|;
DECL|member|tag_time_min
name|int
name|tag_time_min
decl_stmt|;
DECL|member|tag_time_hour
name|int
name|tag_time_hour
decl_stmt|;
DECL|member|tag_tz_hour
name|int
name|tag_tz_hour
decl_stmt|;
DECL|member|tag_tz_min
name|int
name|tag_tz_min
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_TagDate
struct|struct
name|_TagDate
block|{
DECL|member|tag_year
name|int
name|tag_year
decl_stmt|;
DECL|member|tag_month
name|int
name|tag_month
decl_stmt|;
DECL|member|tag_day
name|int
name|tag_day
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
DECL|typedef|GimpAttributeClass
typedef|typedef
name|struct
name|_GimpAttributeClass
name|GimpAttributeClass
typedef|;
end_typedef

begin_typedef
DECL|typedef|GimpAttributePrivate
typedef|typedef
name|struct
name|_GimpAttributePrivate
name|GimpAttributePrivate
typedef|;
end_typedef

begin_struct
DECL|struct|_GimpAttribute
struct|struct
name|_GimpAttribute
block|{
DECL|member|parent_instance
name|GObject
name|parent_instance
decl_stmt|;
DECL|member|priv
name|GimpAttributePrivate
modifier|*
name|priv
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_GimpAttributeClass
struct|struct
name|_GimpAttributeClass
block|{
DECL|member|parent_class
name|GObjectClass
name|parent_class
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_GimpAttributePrivate
struct|struct
name|_GimpAttributePrivate
block|{
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|sorted_name
name|gchar
modifier|*
name|sorted_name
decl_stmt|;
DECL|member|tag_value
name|gchar
modifier|*
name|tag_value
decl_stmt|;
DECL|member|interpreted_value
name|gchar
modifier|*
name|interpreted_value
decl_stmt|;
DECL|member|exif_type
name|gchar
modifier|*
name|exif_type
decl_stmt|;
DECL|member|value_type
name|GimpAttributeValueType
name|value_type
decl_stmt|;
DECL|member|tag_type
name|GimpAttributeTagType
name|tag_type
decl_stmt|;
DECL|member|attribute_type
name|gchar
modifier|*
name|attribute_type
decl_stmt|;
DECL|member|attribute_ifd
name|gchar
modifier|*
name|attribute_ifd
decl_stmt|;
DECL|member|attribute_tag
name|gchar
modifier|*
name|attribute_tag
decl_stmt|;
DECL|member|is_new_name_space
name|gboolean
name|is_new_name_space
decl_stmt|;
DECL|member|has_structure
name|gboolean
name|has_structure
decl_stmt|;
DECL|member|structure_type
name|GimpAttributeStructureType
name|structure_type
decl_stmt|;
DECL|member|attribute_structure
name|GSList
modifier|*
name|attribute_structure
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
DECL|enum|__anon290b02740103
enum|enum
block|{
DECL|enumerator|PROP_0
name|PROP_0
block|,
DECL|enumerator|PROP_NAME
name|PROP_NAME
block|,
DECL|enumerator|PROP_LONG_VALUE
name|PROP_LONG_VALUE
block|,
DECL|enumerator|PROP_SLONG_VALUE
name|PROP_SLONG_VALUE
block|,
DECL|enumerator|PROP_SHORT_VALUE
name|PROP_SHORT_VALUE
block|,
DECL|enumerator|PROP_SSHORT_VALUE
name|PROP_SSHORT_VALUE
block|,
DECL|enumerator|PROP_DATE_VALUE
name|PROP_DATE_VALUE
block|,
DECL|enumerator|PROP_TIME_VALUE
name|PROP_TIME_VALUE
block|,
DECL|enumerator|PROP_ASCII_VALUE
name|PROP_ASCII_VALUE
block|,
DECL|enumerator|PROP_BYTE_VALUE
name|PROP_BYTE_VALUE
block|,
DECL|enumerator|PROP_MULTIPLE_VALUE
name|PROP_MULTIPLE_VALUE
block|,
DECL|enumerator|PROP_RATIONAL_VALUE
name|PROP_RATIONAL_VALUE
block|,
DECL|enumerator|PROP_SRATIONAL_VALUE
name|PROP_SRATIONAL_VALUE
block|}
enum|;
end_enum

begin_decl_stmt
DECL|variable|xmp_namespaces
specifier|static
specifier|const
name|gchar
modifier|*
name|xmp_namespaces
index|[]
init|=
block|{
literal|"dc"
block|,
literal|"xmp"
block|,
literal|"xmpRights"
block|,
literal|"xmpMM"
block|,
literal|"xmpBJ"
block|,
literal|"xmpTPg"
block|,
literal|"xmpDM"
block|,
literal|"pdf"
block|,
literal|"photoshop"
block|,
literal|"crs"
block|,
literal|"tiff"
block|,
literal|"exif"
block|,
literal|"aux"
block|,
literal|"plus"
block|,
literal|"digiKam"
block|,
literal|"iptc"
block|,
literal|"iptcExt"
block|,
literal|"Iptc4xmpCore"
block|,
literal|"Iptc4xmpExt"
block|,
literal|"MicrosoftPhoto"
block|,
literal|"kipi"
block|,
literal|"mediapro"
block|,
literal|"expressionmedia"
block|,
literal|"MP"
block|,
literal|"MPRI"
block|,
literal|"MPReg"
block|,
literal|"mwg-rs"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimp_attribute_parent_class
specifier|static
name|gpointer
name|gimp_attribute_parent_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|counter
specifier|static
name|gint
name|counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GimpAttribute
modifier|*
name|gimp_attribute_construct
parameter_list|(
name|GType
name|object_type
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_attribute_finalize
parameter_list|(
name|GObject
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_attribute_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_attribute_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_attribute_set_name
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|,
specifier|const
name|gchar
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|get_tag_time
parameter_list|(
name|gchar
modifier|*
name|input
parameter_list|,
name|TagTime
modifier|*
name|tm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|get_tag_date
parameter_list|(
name|gchar
modifier|*
name|input
parameter_list|,
name|TagDate
modifier|*
name|dt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|gimp_attribute_escape_value
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|,
name|gboolean
modifier|*
name|encoded
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|gimp_attribute_get_structure_number
parameter_list|(
name|gchar
modifier|*
name|cptag
parameter_list|,
name|gint
name|start
parameter_list|,
name|gint
modifier|*
name|struct_number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|string_replace_str
parameter_list|(
specifier|const
name|gchar
modifier|*
name|original
parameter_list|,
specifier|const
name|gchar
modifier|*
name|old_pattern
parameter_list|,
specifier|const
name|gchar
modifier|*
name|replacement
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|string_index_of
parameter_list|(
name|gchar
modifier|*
name|haystack
parameter_list|,
name|gchar
modifier|*
name|needle
parameter_list|,
name|gint
name|start_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|string_strnlen
parameter_list|(
name|gchar
modifier|*
name|str
parameter_list|,
name|glong
name|maxlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|string_substring
parameter_list|(
name|gchar
modifier|*
name|attribute
parameter_list|,
name|glong
name|offset
parameter_list|,
name|glong
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * gimp_attribute_new_string:  *  * @name:         a constant #gchar that describes the name of the attribute  * @value:        a #gchar value, representing a time  * @type:         a #GimpAttributeTagType  *  * Creates a new #GimpAttribute object with @name as name and a #gchar @value  * as value of type @type.  * @value is converted to the correct type.  *  * Return value:  a new @GimpAttribute  *  * Since: 2.10  */
end_comment

begin_function
name|GimpAttribute
modifier|*
DECL|function|gimp_attribute_new_string (const gchar * name,gchar * value,GimpAttributeValueType type)
name|gimp_attribute_new_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|,
name|GimpAttributeValueType
name|type
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|attribute
operator|=
name|gimp_attribute_construct
argument_list|(
name|GIMP_TYPE_ATTRIBUTE
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|private
operator|->
name|tag_value
operator|=
name|g_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|private
operator|->
name|value_type
operator|=
name|type
expr_stmt|;
block|}
return|return
name|attribute
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_name:  *  * @attribute:    a @GimpAttribute  *  * Return value: full name of the #GimpAttribute object  * e.g. "Exif.Image.XResolution"  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_attribute_get_name (GimpAttribute * attribute)
name|gimp_attribute_get_name
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_sortable_name:  *  * @attribute:    a @GimpAttribute  *  * Return value: name of the #GimpAttribute object for sorting  * e.g. from tag:  *  "xmp.xmpMM.History[2]..."  * it returns:  *  "xmp.xmpMM.History[000002]..."  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_attribute_get_sortable_name (GimpAttribute * attribute)
name|gimp_attribute_get_sortable_name
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|sorted_name
condition|)
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|sorted_name
return|;
else|else
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_attribute_type:  *  * @attribute:    a @GimpAttribute  *  * Return value: attribute type of the #GimpAttribute object  * e.g. "exif", "iptc", ...  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_attribute_get_attribute_type (GimpAttribute * attribute)
name|gimp_attribute_get_attribute_type
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|attribute_type
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_attribute_ifd:  *  * @attribute:    a @GimpAttribute  *  * Return value: ifd of the #GimpAttribute object  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_attribute_get_attribute_ifd (GimpAttribute * attribute)
name|gimp_attribute_get_attribute_ifd
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|attribute_ifd
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_attribute_tag:  *  * @attribute:    a @GimpAttribute  *  * Return value: tag of the #GimpAttribute object  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_attribute_get_attribute_tag (GimpAttribute * attribute)
name|gimp_attribute_get_attribute_tag
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|attribute_tag
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_set_value_type:  *  * @attribute:    a @GimpAttribute  * @value_type:   a @GimpAttributeValueType  *  * sets value type of the #GimpAttribute object  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_attribute_set_value_type (GimpAttribute * attribute,GimpAttributeValueType value_type)
name|gimp_attribute_set_value_type
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|,
name|GimpAttributeValueType
name|value_type
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|private
operator|->
name|value_type
operator|=
name|value_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_value_type:  *  * @attribute:    a @GimpAttribute  *  * Return value: value type of the #GimpAttribute object  *  * Since: 2.10  */
end_comment

begin_function
name|GimpAttributeValueType
DECL|function|gimp_attribute_get_value_type (GimpAttribute * attribute)
name|gimp_attribute_get_value_type
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|TYPE_INVALID
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
name|private
operator|->
name|value_type
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_attribute_structure:  *  * @attribute:    a @GimpAttribute  *  * Return value: attribute_structure of the #GimpAttribute object  * This is the start value of a xmpBag sequence.  *  * Since: 2.10  */
end_comment

begin_function
name|GSList
modifier|*
DECL|function|gimp_attribute_get_attribute_structure (GimpAttribute * attribute)
name|gimp_attribute_get_attribute_structure
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
name|private
operator|->
name|attribute_structure
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_is_new_namespace:  *  * @attribute:    a @GimpAttribute  *  * Return value: if namespace must be defined or not  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gboolean
DECL|function|gimp_attribute_is_new_namespace (GimpAttribute * attribute)
name|gimp_attribute_is_new_namespace
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|gboolean
operator|)
name|private
operator|->
name|is_new_name_space
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_value:  *  * @attribute:    a @GimpAttribute  *  * Return value:  #GValue of the #GimpAttribute object  * The type of value is represented by glib-types  *  * Since: 2.10  */
end_comment

begin_function
name|GValue
DECL|function|gimp_attribute_get_value (GimpAttribute * attribute)
name|gimp_attribute_get_value
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|GValue
name|val
init|=
name|G_VALUE_INIT
decl_stmt|;
name|gchar
modifier|*
name|value_string
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|value_string
operator|=
name|private
operator|->
name|tag_value
expr_stmt|;
switch|switch
condition|(
name|private
operator|->
name|value_type
condition|)
block|{
case|case
name|TYPE_LONG
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_ULONG
argument_list|)
expr_stmt|;
name|g_value_set_ulong
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|gulong
operator|)
name|atol
argument_list|(
name|value_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SLONG
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_LONG
argument_list|)
expr_stmt|;
name|g_value_set_long
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|glong
operator|)
name|atol
argument_list|(
name|value_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SHORT
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_UINT
argument_list|)
expr_stmt|;
name|g_value_set_uint
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|value_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SSHORT
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_INT
argument_list|)
expr_stmt|;
name|g_value_set_int
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|gint
operator|)
name|atoi
argument_list|(
name|value_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DATE
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_STRING
argument_list|)
expr_stmt|;
name|g_value_set_string
argument_list|(
operator|&
name|val
argument_list|,
name|value_string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_TIME
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_STRING
argument_list|)
expr_stmt|;
name|g_value_set_string
argument_list|(
operator|&
name|val
argument_list|,
name|value_string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_ASCII
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_STRING
argument_list|)
expr_stmt|;
name|g_value_set_string
argument_list|(
operator|&
name|val
argument_list|,
name|value_string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNICODE
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_STRING
argument_list|)
expr_stmt|;
name|g_value_set_string
argument_list|(
operator|&
name|val
argument_list|,
name|value_string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_BYTE
case|:
block|{
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_UCHAR
argument_list|)
expr_stmt|;
name|g_value_set_uchar
argument_list|(
operator|&
name|val
argument_list|,
name|value_string
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_MULTIPLE
case|:
block|{
name|gchar
modifier|*
modifier|*
name|result
decl_stmt|;
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_STRV
argument_list|)
expr_stmt|;
name|result
operator|=
name|g_strsplit
argument_list|(
name|value_string
argument_list|,
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_value_set_boxed
argument_list|(
operator|&
name|val
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_RATIONAL
case|:
block|{
name|gchar
modifier|*
modifier|*
name|nom
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|rats
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|Rational
modifier|*
name|rval
decl_stmt|;
name|GArray
modifier|*
name|rational_array
decl_stmt|;
name|rats
operator|=
name|g_strsplit
argument_list|(
name|value_string
argument_list|,
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rats
index|[
name|count
index|]
condition|)
name|count
operator|++
expr_stmt|;
name|rational_array
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|RationalValue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|RationalValue
name|or
decl_stmt|;
name|nom
operator|=
name|g_strsplit
argument_list|(
name|rats
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nom
index|[
literal|0
index|]
operator|&&
name|nom
index|[
literal|1
index|]
condition|)
block|{
name|or
operator|.
name|nom
operator|=
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|or
operator|.
name|denom
operator|=
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|--
expr_stmt|;
name|rational_array
operator|=
name|g_array_append_val
argument_list|(
name|rational_array
argument_list|,
name|or
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|nom
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|g_slice_new
argument_list|(
name|Rational
argument_list|)
expr_stmt|;
name|rval
operator|->
name|rational_array
operator|=
name|rational_array
expr_stmt|;
name|rval
operator|->
name|length
operator|=
name|count
expr_stmt|;
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|GIMP_TYPE_RATIONAL
argument_list|)
expr_stmt|;
name|g_value_set_boxed
argument_list|(
operator|&
name|val
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|rats
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SRATIONAL
case|:
block|{
name|gchar
modifier|*
modifier|*
name|nom
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|srats
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|SRational
modifier|*
name|srval
decl_stmt|;
name|GArray
modifier|*
name|srational_array
decl_stmt|;
name|srats
operator|=
name|g_strsplit
argument_list|(
name|value_string
argument_list|,
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|srats
index|[
name|count
index|]
condition|)
name|count
operator|++
expr_stmt|;
name|srational_array
operator|=
name|g_array_new
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
sizeof|sizeof
argument_list|(
name|SRationalValue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SRationalValue
name|or
decl_stmt|;
name|nom
operator|=
name|g_strsplit
argument_list|(
name|srats
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nom
index|[
literal|0
index|]
operator|&&
name|nom
index|[
literal|1
index|]
condition|)
block|{
name|or
operator|.
name|nom
operator|=
operator|(
name|gint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|or
operator|.
name|denom
operator|=
operator|(
name|guint
operator|)
name|atoi
argument_list|(
name|nom
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|--
expr_stmt|;
name|srational_array
operator|=
name|g_array_append_val
argument_list|(
name|srational_array
argument_list|,
name|or
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|nom
argument_list|)
expr_stmt|;
block|}
name|srval
operator|=
name|g_slice_new
argument_list|(
name|SRational
argument_list|)
expr_stmt|;
name|srval
operator|->
name|srational_array
operator|=
name|srational_array
expr_stmt|;
name|srval
operator|->
name|length
operator|=
name|count
expr_stmt|;
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|GIMP_TYPE_SRATIONAL
argument_list|)
expr_stmt|;
name|g_value_set_boxed
argument_list|(
operator|&
name|val
argument_list|,
name|srval
argument_list|)
expr_stmt|;
name|g_strfreev
argument_list|(
name|srats
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNKNOWN
case|:
default|default:
break|break;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_string:  *  * @attribute:    a @GimpAttribute  *  * Return value:  newly allocated #gchar string representation of the #GimpAttribute object.  * The return is always a valid value according to the #GimpAttributeValueType  *  * Since: 2.10  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_attribute_get_string (GimpAttribute * attribute)
name|gimp_attribute_get_string
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|gchar
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
name|TagDate
name|dt
init|=
block|{
literal|0
block|}
decl_stmt|;
name|TagTime
name|tm
init|=
block|{
literal|0
block|}
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|private
operator|->
name|value_type
condition|)
block|{
case|case
name|TYPE_INVALID
case|:
break|break;
case|case
name|TYPE_LONG
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%lu"
argument_list|,
operator|(
name|gulong
operator|)
name|atol
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SLONG
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%ld"
argument_list|,
operator|(
name|glong
operator|)
name|atol
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_FLOAT
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%.5f"
argument_list|,
operator|(
name|gfloat
operator|)
name|atof
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DOUBLE
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%.6f"
argument_list|,
operator|(
name|gdouble
operator|)
name|atof
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SHORT
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%u"
argument_list|,
operator|(
name|gushort
operator|)
name|atoi
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SSHORT
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|gshort
operator|)
name|atoi
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DATE
case|:
block|{
name|get_tag_date
argument_list|(
name|private
operator|->
name|tag_value
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%4d-%02d-%02d"
argument_list|,
name|dt
operator|.
name|tag_year
argument_list|,
name|dt
operator|.
name|tag_month
argument_list|,
name|dt
operator|.
name|tag_day
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_TIME
case|:
block|{
name|gchar
modifier|*
name|tz_h
init|=
name|NULL
decl_stmt|;
name|get_tag_time
argument_list|(
name|private
operator|->
name|tag_value
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|tz_h
operator|=
name|tm
operator|.
name|tag_tz_hour
operator|<
literal|0
condition|?
name|g_strdup_printf
argument_list|(
literal|"-%02d"
argument_list|,
name|tm
operator|.
name|tag_tz_hour
argument_list|)
else|:
name|g_strdup_printf
argument_list|(
literal|"+%02d"
argument_list|,
name|tm
operator|.
name|tag_tz_hour
argument_list|)
expr_stmt|;
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%02d:%02d:%02d%s:%02d"
argument_list|,
name|tm
operator|.
name|tag_time_hour
argument_list|,
name|tm
operator|.
name|tag_time_min
argument_list|,
name|tm
operator|.
name|tag_time_sec
argument_list|,
name|tz_h
argument_list|,
name|tm
operator|.
name|tag_tz_min
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tz_h
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_ASCII
case|:
block|{
name|val
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNICODE
case|:
block|{
name|val
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_BYTE
case|:
block|{
name|val
operator|=
name|g_strdup_printf
argument_list|(
literal|"%c"
argument_list|,
name|private
operator|->
name|tag_value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_MULTIPLE
case|:
block|{
name|val
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_RATIONAL
case|:
block|{
name|gint
name|i
decl_stmt|;
name|GString
modifier|*
name|string
decl_stmt|;
name|Rational
modifier|*
name|rational
decl_stmt|;
name|string_to_rational
argument_list|(
name|private
operator|->
name|tag_value
argument_list|,
operator|&
name|rational
argument_list|)
expr_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rational
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RationalValue
name|or
decl_stmt|;
name|or
operator|=
name|g_array_index
argument_list|(
name|rational
operator|->
name|rational_array
argument_list|,
name|RationalValue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%u/%u "
argument_list|,
name|or
operator|.
name|nom
argument_list|,
name|or
operator|.
name|denom
argument_list|)
expr_stmt|;
block|}
name|g_string_truncate
argument_list|(
name|string
argument_list|,
name|string
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SRATIONAL
case|:
block|{
name|gint
name|i
decl_stmt|;
name|GString
modifier|*
name|string
decl_stmt|;
name|SRational
modifier|*
name|srational
decl_stmt|;
name|string_to_srational
argument_list|(
name|private
operator|->
name|tag_value
argument_list|,
operator|&
name|srational
argument_list|)
expr_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srational
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SRationalValue
name|or
decl_stmt|;
name|or
operator|=
name|g_array_index
argument_list|(
name|srational
operator|->
name|srational_array
argument_list|,
name|SRationalValue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%u/%u "
argument_list|,
name|or
operator|.
name|nom
argument_list|,
name|or
operator|.
name|denom
argument_list|)
expr_stmt|;
block|}
name|g_string_truncate
argument_list|(
name|string
argument_list|,
name|string
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_UNKNOWN
case|:
default|default:
break|break;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_interpreted_string:  *  * @attribute:    a #GimpAttribute  *  * returns the interpreted value or the pure string, if no  * interpreted value is found  *  * Since: 2.10  */
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_attribute_get_interpreted_string (GimpAttribute * attribute)
name|gimp_attribute_get_interpreted_string
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|interpreted_value
condition|)
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|interpreted_value
return|;
else|else
return|return
operator|(
specifier|const
name|gchar
operator|*
operator|)
name|private
operator|->
name|tag_value
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_set_interpreted_string:  *  * @attribute:    a #GimpAttribute  * @value:        a constant #gchar  *  * sets the interpreted string of the #GimpAttribute object to  * a @value  *  * @value can be freed after  *  * Since: 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_attribute_set_interpreted_string (GimpAttribute * attribute,const gchar * value)
name|gimp_attribute_set_interpreted_string
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|,
specifier|const
name|gchar
modifier|*
name|value
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|private
operator|->
name|interpreted_value
operator|=
name|g_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_tag_type:  *  * @attribute:    a @GimpAttribute  *  *  * Return value:  #GimpAttributeTagType  * The tag type of the Attribute  *  * Since: 2.10  */
end_comment

begin_function
name|GimpAttributeTagType
DECL|function|gimp_attribute_get_tag_type (GimpAttribute * attribute)
name|gimp_attribute_get_tag_type
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|TAG_INVALID
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
name|private
operator|->
name|tag_type
return|;
block|}
end_function

begin_function
name|void
DECL|function|gimp_attribute_print (GimpAttribute * attribute)
name|gimp_attribute_print
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|tag
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|interpreted
decl_stmt|;
name|gchar
modifier|*
name|value
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|=
name|gimp_attribute_get_name
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|value
operator|=
name|gimp_attribute_get_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|interpreted
operator|=
name|gimp_attribute_get_interpreted_string
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"---\n%p\nTag: %s\n\tValue:%s\n\tInterpreted value:%s\n"
argument_list|,
name|attribute
argument_list|,
name|tag
argument_list|,
name|value
argument_list|,
name|interpreted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_gps_degree:  *  * @attribute:    a @GimpAttribute  *  * returns the degree representation of the #GimpAttribute GPS value,  * -999.9 otherwise.  *  * Return value:  #gdouble degree representation of the #GimpAttributes GPS value  *  * Since: 2.10  */
end_comment

begin_function
name|gdouble
DECL|function|gimp_attribute_get_gps_degree (GimpAttribute * attribute)
name|gimp_attribute_get_gps_degree
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|gdouble
name|return_val
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|TAG_INVALID
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|value_type
operator|==
name|TYPE_RATIONAL
condition|)
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|r_val
init|=
literal|0.0
decl_stmt|;
name|Rational
modifier|*
name|rational
decl_stmt|;
name|string_to_rational
argument_list|(
name|private
operator|->
name|tag_value
argument_list|,
operator|&
name|rational
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rational
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RationalValue
name|or
decl_stmt|;
name|or
operator|=
name|g_array_index
argument_list|(
name|rational
operator|->
name|rational_array
argument_list|,
name|RationalValue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|r_val
operator|=
operator|(
name|gfloat
operator|)
name|or
operator|.
name|nom
operator|/
operator|(
name|gfloat
operator|)
name|or
operator|.
name|denom
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|return_val
operator|=
name|r_val
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|return_val
operator|=
name|return_val
operator|+
operator|(
name|r_val
operator|/
literal|60
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|return_val
operator|=
name|return_val
operator|+
operator|(
name|r_val
operator|/
literal|3600
operator|)
expr_stmt|;
else|else
return|return
operator|-
literal|999.9
return|;
block|}
return|return
name|return_val
return|;
block|}
else|else
return|return
operator|-
literal|999.9
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_xml:  *  * @attribute:    a @GimpAttribute  *  * returns the xml representation of the #GimpAttribute  * in form:  *  *<tag name="name" type="GimpAttributeValueType">  *<value [encoding=base64]>value</value>  * [<interpreted [encoding=base64]>interpreted value</interpreted>]  *</tag>  *  * Return value:  #gchar xml representation of the #GimpAttribute object  *  * Since: 2.10  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_attribute_get_xml (GimpAttribute * attribute)
name|gimp_attribute_get_xml
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|gchar
modifier|*
name|v_escaped
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|i_escaped
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|interpreted_tag_elem
init|=
name|NULL
decl_stmt|;
name|gboolean
name|is_interpreted
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|encoded
decl_stmt|;
name|gchar
modifier|*
name|start_tag_elem
decl_stmt|;
name|gchar
modifier|*
name|end_tag_elem
decl_stmt|;
name|gchar
modifier|*
name|value_tag_elem
decl_stmt|;
name|gchar
modifier|*
name|struct_tag_elem
init|=
name|NULL
decl_stmt|;
name|gboolean
name|utf
init|=
name|TRUE
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|GString
modifier|*
name|xml
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|xml
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|interpreted_value
operator|&&
name|g_strcmp0
argument_list|(
name|private
operator|->
name|tag_value
argument_list|,
name|private
operator|->
name|interpreted_value
argument_list|)
condition|)
block|{
name|is_interpreted
operator|=
name|TRUE
expr_stmt|;
block|}
name|v_escaped
operator|=
name|gimp_attribute_escape_value
argument_list|(
name|private
operator|->
name|name
argument_list|,
name|private
operator|->
name|tag_value
argument_list|,
operator|&
name|encoded
argument_list|)
expr_stmt|;
name|start_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"<attribute name=\"%s\" type=\"%d\">\n"
argument_list|,
name|private
operator|->
name|name
argument_list|,
name|private
operator|->
name|value_type
argument_list|)
expr_stmt|;
name|end_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"</attribute>"
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|xml
argument_list|,
name|start_tag_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded
condition|)
block|{
name|value_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"<value encoding=\"base64\">%s</value>\n"
argument_list|,
name|v_escaped
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"<value>%s</value>\n"
argument_list|,
name|v_escaped
argument_list|)
expr_stmt|;
block|}
name|g_string_append
argument_list|(
name|xml
argument_list|,
name|value_tag_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|has_structure
condition|)
block|{
name|struct_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"<structure>%d</structure>\n"
argument_list|,
name|private
operator|->
name|structure_type
argument_list|)
expr_stmt|;
name|g_string_append
argument_list|(
name|xml
argument_list|,
name|struct_tag_elem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_interpreted
operator|&&
name|utf
condition|)
block|{
name|i_escaped
operator|=
name|gimp_attribute_escape_value
argument_list|(
name|private
operator|->
name|name
argument_list|,
name|private
operator|->
name|interpreted_value
argument_list|,
operator|&
name|encoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded
condition|)
block|{
name|interpreted_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"<interpreted encoding=\"base64\">%s</interpreted>\n"
argument_list|,
name|i_escaped
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interpreted_tag_elem
operator|=
name|g_strdup_printf
argument_list|(
literal|"<interpreted>%s</interpreted>\n"
argument_list|,
name|i_escaped
argument_list|)
expr_stmt|;
block|}
name|g_string_append
argument_list|(
name|xml
argument_list|,
name|interpreted_tag_elem
argument_list|)
expr_stmt|;
block|}
name|g_string_append
argument_list|(
name|xml
argument_list|,
name|end_tag_elem
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|v_escaped
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|start_tag_elem
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|end_tag_elem
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value_tag_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_escaped
condition|)
name|g_free
argument_list|(
name|i_escaped
argument_list|)
expr_stmt|;
if|if
condition|(
name|interpreted_tag_elem
condition|)
name|g_free
argument_list|(
name|interpreted_tag_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_tag_elem
condition|)
name|g_free
argument_list|(
name|interpreted_tag_elem
argument_list|)
expr_stmt|;
return|return
name|g_string_free
argument_list|(
name|xml
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_value_type_from_string:  *  * @exiv_tag_type_string:    a @gchar  *  * converts a string representation tag type from gexiv2/exiv2  * to a #GimpAttributeValueType  *  * Return value: #GimpAttributeValueType  *  * Since: 2.10  */
end_comment

begin_function
name|GimpAttributeValueType
DECL|function|gimp_attribute_get_value_type_from_string (const gchar * string)
name|gimp_attribute_get_value_type_from_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|string
parameter_list|)
block|{
name|GimpAttributeValueType
name|type
decl_stmt|;
name|gchar
modifier|*
name|lowchar
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
return|return
name|TYPE_INVALID
return|;
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|string
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"invalid"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_INVALID
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"byte"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_BYTE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"ascii"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"short"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"long"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_LONG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"rational"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_RATIONAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"sbyte"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_BYTE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"undefined"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"sshort"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_SSHORT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"slong"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_SLONG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"srational"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_SRATIONAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"float"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_FLOAT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"double"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"ifd"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"string"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_UNICODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"date"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_DATE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"time"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_TIME
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"comment"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_UNICODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"directory"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_UNICODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"xmptext"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"xmpalt"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MULTIPLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"xmpbag"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MULTIPLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"xmpseq"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MULTIPLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"langalt"
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MULTIPLE
expr_stmt|;
else|else
name|type
operator|=
name|TYPE_INVALID
expr_stmt|;
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_is_valid:  *  * @attribute:    a @GimpAttribute  *  * checks, if @attribute is valid.  * A @GimpAttribute is valid, if the @GimpAttributeValueType  * has a valid entry.  *  * Return value: @gboolean: TRUE if valid, FALSE otherwise  *  * Since: 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_attribute_is_valid (GimpAttribute * attribute)
name|gimp_attribute_is_valid
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|value_type
operator|==
name|TYPE_INVALID
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * internal functions  */
end_comment

begin_comment
comment|/**  * gimp_attribute_set_name:  *  * @attribute:    a #GimpAttribute  * @value:        a constant #gchar  *  * sets the name of the #GimpAttribute object to  * a @value  *  * @value can be freed after  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_attribute_set_name (GimpAttribute * attribute,const gchar * value)
name|gimp_attribute_set_name
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|,
specifier|const
name|gchar
modifier|*
name|value
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|split_name
decl_stmt|;
name|gchar
modifier|*
name|lowchar
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|_g_free0
argument_list|(
name|private
operator|->
name|name
argument_list|)
expr_stmt|;
name|private
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|private
operator|->
name|name
operator|=
name|string_replace_str
argument_list|(
name|private
operator|->
name|name
argument_list|,
literal|"Iptc4xmpExt"
argument_list|,
literal|"iptcExt"
argument_list|)
expr_stmt|;
name|private
operator|->
name|name
operator|=
name|string_replace_str
argument_list|(
name|private
operator|->
name|name
argument_list|,
literal|"Iptc4xmpCore"
argument_list|,
literal|"iptc"
argument_list|)
expr_stmt|;
comment|//  if (! g_strcmp0 (private->name, "Exif.Image.ResolutionUnit"))
comment|//    {
comment|//      g_print ("found: %s\n", private->name);
comment|//    }
name|split_name
operator|=
name|g_strsplit
argument_list|(
name|private
operator|->
name|name
argument_list|,
literal|"."
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_name
index|[
literal|0
index|]
condition|)
name|private
operator|->
name|attribute_type
operator|=
name|split_name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|split_name
index|[
literal|1
index|]
condition|)
name|private
operator|->
name|attribute_ifd
operator|=
name|split_name
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|split_name
index|[
literal|2
index|]
condition|)
name|private
operator|->
name|attribute_tag
operator|=
name|split_name
index|[
literal|2
index|]
expr_stmt|;
name|attribute
operator|->
name|priv
operator|->
name|is_new_name_space
operator|=
name|FALSE
expr_stmt|;
name|lowchar
operator|=
name|g_ascii_strdown
argument_list|(
name|private
operator|->
name|attribute_type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"exif"
argument_list|)
condition|)
block|{
name|private
operator|->
name|tag_type
operator|=
name|TAG_EXIF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"xmp"
argument_list|)
condition|)
block|{
name|gint
name|j
decl_stmt|;
name|gint
name|p1
init|=
literal|0
decl_stmt|;
name|gint
name|p2
init|=
literal|0
decl_stmt|;
name|gboolean
name|is_known
init|=
name|FALSE
decl_stmt|;
name|gchar
modifier|*
name|structure_tag_name
init|=
name|NULL
decl_stmt|;
name|structure_tag_name
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|name
argument_list|)
expr_stmt|;
name|private
operator|->
name|tag_type
operator|=
name|TAG_XMP
expr_stmt|;
while|while
condition|(
name|p2
operator|!=
operator|-
literal|1
condition|)
block|{
name|p2
operator|=
name|string_index_of
argument_list|(
name|structure_tag_name
argument_list|,
literal|"["
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|>
operator|-
literal|1
condition|)
block|{
name|gchar
modifier|*
name|struct_string
init|=
name|NULL
decl_stmt|;
name|gint
name|struct_number
decl_stmt|;
name|private
operator|->
name|has_structure
operator|=
name|TRUE
expr_stmt|;
name|private
operator|->
name|structure_type
operator|=
name|STRUCTURE_TYPE_BAG
expr_stmt|;
comment|/* there's no way to get the real type from gexiv2 */
name|struct_string
operator|=
name|string_substring
argument_list|(
name|structure_tag_name
argument_list|,
literal|0
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|private
operator|->
name|attribute_structure
operator|=
name|g_slist_prepend
argument_list|(
name|private
operator|->
name|attribute_structure
argument_list|,
name|struct_string
argument_list|)
expr_stmt|;
name|structure_tag_name
operator|=
name|gimp_attribute_get_structure_number
argument_list|(
name|structure_tag_name
argument_list|,
name|p2
argument_list|,
operator|&
name|struct_number
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g_strcmp0
argument_list|(
name|private
operator|->
name|name
argument_list|,
name|structure_tag_name
argument_list|)
condition|)
name|private
operator|->
name|sorted_name
operator|=
name|structure_tag_name
expr_stmt|;
else|else
name|private
operator|->
name|sorted_name
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|G_N_ELEMENTS
argument_list|(
name|xmp_namespaces
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|private
operator|->
name|attribute_ifd
argument_list|,
name|xmp_namespaces
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|is_known
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|is_known
condition|)
block|{
name|private
operator|->
name|is_new_name_space
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"iptc"
argument_list|)
condition|)
block|{
name|private
operator|->
name|tag_type
operator|=
name|TAG_IPTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|g_strcmp0
argument_list|(
name|lowchar
argument_list|,
literal|"gimp"
argument_list|)
condition|)
block|{
name|private
operator|->
name|tag_type
operator|=
name|TAG_GIMP
expr_stmt|;
block|}
else|else
block|{
name|private
operator|->
name|tag_type
operator|=
name|TAG_MISC
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lowchar
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_set_structure_type:  *  * @attribute:    a #GimpAttribute  * @value:        a GimpAttributeStructureType  *  * Sets the structure type, Bag, Seq, None, etc.  * The structure is not checked.  * The structure type is only relevant for  * GimpAttribute, that are part of a structure.  *  * Since : 2.10  */
end_comment

begin_function
name|void
DECL|function|gimp_attribute_set_structure_type (GimpAttribute * attribute,GimpAttributeStructureType value)
name|gimp_attribute_set_structure_type
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|,
name|GimpAttributeStructureType
name|value
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|private
operator|->
name|structure_type
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_structure_type:  *  * @attribute:    a #GimpAttribute  *  * The structure type, Bag, Seq, None, etc.  * Return value: a #GimpAttributeStructureType  *  * Since : 2.10  */
end_comment

begin_function
name|GimpAttributeStructureType
DECL|function|gimp_attribute_get_structure_type (GimpAttribute * attribute)
name|gimp_attribute_get_structure_type
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|STRUCTURE_TYPE_NONE
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
name|private
operator|->
name|structure_type
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_has_structure:  *  * @attribute:    a #GimpAttribute  *  * Return value:  TRUE, if @attribute is part  * of a structure.  *  * Since : 2.10  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_attribute_has_structure (GimpAttribute * attribute)
name|gimp_attribute_has_structure
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|attribute
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
return|return
name|private
operator|->
name|has_structure
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_escape_value:  *  * @name: a gchar *  * @value: a gchar*  * @encoded: a pointer to a gboolean  *  * converts @value into an escaped string for GMarkup.  * If @value is not valid UTF-8, it is converted  * into a base64 coded string and @encoded is set to TRUE,  * otherwise FALSE  *  * Return value:  a new allocated @gchar *  *  * Since : 2.10  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_attribute_escape_value (gchar * name,gchar * value,gboolean * encoded)
name|gimp_attribute_escape_value
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|,
name|gboolean
modifier|*
name|encoded
parameter_list|)
block|{
if|if
condition|(
operator|!
name|g_utf8_validate
argument_list|(
name|value
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|enc_val
init|=
name|NULL
decl_stmt|;
operator|*
name|encoded
operator|=
name|TRUE
expr_stmt|;
name|enc_val
operator|=
name|g_base64_encode
argument_list|(
operator|(
specifier|const
name|guchar
operator|*
operator|)
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|enc_val
return|;
block|}
operator|*
name|encoded
operator|=
name|FALSE
expr_stmt|;
return|return
name|g_markup_escape_text
argument_list|(
name|value
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_copy:  *  * @attribute:  a #GimpAttribute  *  * duplicates a  #GimpAttribute object  *  * Return value:  a new @GimpAttribute or %NULL  *  * Since : 2.10  */
end_comment

begin_function
name|GimpAttribute
modifier|*
DECL|function|gimp_attribute_copy (GimpAttribute * attribute)
name|gimp_attribute_copy
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|new_attribute
init|=
name|NULL
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|new_private
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|attribute
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_attribute
operator|=
operator|(
name|GimpAttribute
operator|*
operator|)
name|g_object_new
argument_list|(
name|GIMP_TYPE_ATTRIBUTE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_attribute
condition|)
block|{
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|new_private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|new_attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|name
condition|)
name|new_private
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|tag_value
condition|)
name|new_private
operator|->
name|tag_value
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|interpreted_value
condition|)
name|new_private
operator|->
name|interpreted_value
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|interpreted_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|exif_type
condition|)
name|new_private
operator|->
name|exif_type
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|exif_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_type
condition|)
name|new_private
operator|->
name|attribute_type
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|attribute_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_ifd
condition|)
name|new_private
operator|->
name|attribute_ifd
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|attribute_ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_tag
condition|)
name|new_private
operator|->
name|attribute_tag
operator|=
name|g_strdup
argument_list|(
name|private
operator|->
name|attribute_tag
argument_list|)
expr_stmt|;
name|new_private
operator|->
name|is_new_name_space
operator|=
name|private
operator|->
name|is_new_name_space
expr_stmt|;
name|new_private
operator|->
name|value_type
operator|=
name|private
operator|->
name|value_type
expr_stmt|;
name|new_private
operator|->
name|tag_type
operator|=
name|private
operator|->
name|tag_type
expr_stmt|;
return|return
name|new_attribute
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_construct:  *  * @object_type:  a #GType  * @name:         a constant #gchar that describes the name of the attribute  *  * constructs a new #GimpAttribute object  *  * Return value:  a new @GimpAttribute or %NULL if no @name is set  *  * Since : 2.10  */
end_comment

begin_function
specifier|static
name|GimpAttribute
modifier|*
DECL|function|gimp_attribute_construct (GType object_type,const gchar * name)
name|gimp_attribute_construct
parameter_list|(
name|GType
name|object_type
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|attribute
operator|=
operator|(
name|GimpAttribute
operator|*
operator|)
name|g_object_new
argument_list|(
name|object_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attribute
condition|)
block|{
name|gimp_attribute_set_name
argument_list|(
name|attribute
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|attribute
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_class_init:  *  * class initializer  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_attribute_class_init (GimpAttributeClass * klass)
name|gimp_attribute_class_init
parameter_list|(
name|GimpAttributeClass
modifier|*
name|klass
parameter_list|)
block|{
name|gimp_attribute_parent_class
operator|=
name|g_type_class_peek_parent
argument_list|(
name|klass
argument_list|)
expr_stmt|;
name|g_type_class_add_private
argument_list|(
name|klass
argument_list|,
sizeof|sizeof
argument_list|(
name|GimpAttributePrivate
argument_list|)
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
operator|->
name|get_property
operator|=
name|gimp_attribute_get_property
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
operator|->
name|set_property
operator|=
name|gimp_attribute_set_property
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|klass
argument_list|)
operator|->
name|finalize
operator|=
name|gimp_attribute_finalize
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_instance_init:  *  * instance initializer  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_attribute_instance_init (GimpAttribute * attribute)
name|gimp_attribute_instance_init
parameter_list|(
name|GimpAttribute
modifier|*
name|attribute
parameter_list|)
block|{
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|attribute
operator|->
name|priv
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|private
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|sorted_name
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|tag_value
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|interpreted_value
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|exif_type
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|value_type
operator|=
name|TYPE_INVALID
expr_stmt|;
name|private
operator|->
name|attribute_type
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|attribute_ifd
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|attribute_tag
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|attribute_structure
operator|=
name|NULL
expr_stmt|;
name|private
operator|->
name|is_new_name_space
operator|=
name|FALSE
expr_stmt|;
name|private
operator|->
name|has_structure
operator|=
name|FALSE
expr_stmt|;
name|private
operator|->
name|structure_type
operator|=
name|STRUCTURE_TYPE_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_finalize:  *  * instance finalizer  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_attribute_finalize (GObject * obj)
name|gimp_attribute_finalize
parameter_list|(
name|GObject
modifier|*
name|obj
parameter_list|)
block|{
name|GimpAttribute
modifier|*
name|attribute
decl_stmt|;
name|GimpAttributePrivate
modifier|*
name|private
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_ATTRIBUTE
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|attribute
operator|=
name|GIMP_ATTRIBUTE
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|private
operator|=
name|GIMP_ATTRIBUTE_GET_PRIVATE
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|name
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|sorted_name
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|sorted_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|tag_value
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|tag_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|interpreted_value
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|interpreted_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|exif_type
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|exif_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_type
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|attribute_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_ifd
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|attribute_ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_tag
condition|)
name|_g_free0
argument_list|(
name|private
operator|->
name|attribute_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|->
name|attribute_structure
condition|)
name|g_slist_free_full
argument_list|(
name|private
operator|->
name|attribute_structure
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|G_OBJECT_CLASS
argument_list|(
name|gimp_attribute_parent_class
argument_list|)
operator|->
name|finalize
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_property  *  * instance get property  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_attribute_get_property (GObject * object,guint property_id,GValue * value,GParamSpec * pspec)
name|gimp_attribute_get_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * gimp_attribute_set_property  *  * instance set property  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_attribute_set_property (GObject * object,guint property_id,const GValue * value,GParamSpec * pspec)
name|gimp_attribute_set_property
parameter_list|(
name|GObject
modifier|*
name|object
parameter_list|,
name|guint
name|property_id
parameter_list|,
specifier|const
name|GValue
modifier|*
name|value
parameter_list|,
name|GParamSpec
modifier|*
name|pspec
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_attribute_get_structure_number (gchar * cptag,gint start,gint * number)
name|gimp_attribute_get_structure_number
parameter_list|(
name|gchar
modifier|*
name|cptag
parameter_list|,
name|gint
name|start
parameter_list|,
name|gint
modifier|*
name|number
parameter_list|)
block|{
name|gint
name|p1
decl_stmt|;
name|gchar
modifier|*
name|tag
decl_stmt|;
name|gchar
modifier|*
name|new_tag
decl_stmt|;
name|gchar
modifier|*
name|oldnr
decl_stmt|;
name|gchar
modifier|*
name|newnr
decl_stmt|;
name|start
operator|++
expr_stmt|;
name|tag
operator|=
name|g_strdup
argument_list|(
name|cptag
argument_list|)
expr_stmt|;
name|p1
operator|=
name|string_index_of
argument_list|(
name|tag
argument_list|,
literal|"]"
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|>
operator|-
literal|1
condition|)
block|{
name|gchar
modifier|*
name|number_string
init|=
name|NULL
decl_stmt|;
name|gint
name|len
decl_stmt|;
name|len
operator|=
name|p1
operator|-
name|start
expr_stmt|;
name|number_string
operator|=
name|string_substring
argument_list|(
name|tag
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|number
operator|=
name|atoi
argument_list|(
name|number_string
argument_list|)
expr_stmt|;
name|oldnr
operator|=
name|g_strdup_printf
argument_list|(
literal|"[%d]"
argument_list|,
operator|*
name|number
argument_list|)
expr_stmt|;
name|newnr
operator|=
name|g_strdup_printf
argument_list|(
literal|"[%06d]"
argument_list|,
operator|*
name|number
argument_list|)
expr_stmt|;
name|new_tag
operator|=
name|string_replace_str
argument_list|(
name|tag
argument_list|,
name|oldnr
argument_list|,
name|newnr
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|oldnr
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|newnr
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|number_string
argument_list|)
expr_stmt|;
return|return
name|new_tag
return|;
block|}
else|else
block|{
operator|*
name|number
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_attribute_get_type  *  * Return value: #GimpAttribute type  */
end_comment

begin_function
name|GType
DECL|function|gimp_attribute_get_type (void)
name|gimp_attribute_get_type
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|volatile
name|gsize
name|gimp_attribute_type_id__volatile
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|g_once_init_enter
argument_list|(
operator|&
name|gimp_attribute_type_id__volatile
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|GTypeInfo
name|g_define_type_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|GimpAttributeClass
argument_list|)
block|,
operator|(
name|GBaseInitFunc
operator|)
name|NULL
block|,
operator|(
name|GBaseFinalizeFunc
operator|)
name|NULL
block|,
operator|(
name|GClassInitFunc
operator|)
name|gimp_attribute_class_init
block|,
operator|(
name|GClassFinalizeFunc
operator|)
name|NULL
block|,
name|NULL
block|,
sizeof|sizeof
argument_list|(
name|GimpAttribute
argument_list|)
block|,
literal|0
block|,
operator|(
name|GInstanceInitFunc
operator|)
name|gimp_attribute_instance_init
block|,
name|NULL
block|}
decl_stmt|;
name|GType
name|gimp_attribute_type_id
decl_stmt|;
name|gimp_attribute_type_id
operator|=
name|g_type_register_static
argument_list|(
name|G_TYPE_OBJECT
argument_list|,
literal|"GimpAttribute"
argument_list|,
operator|&
name|g_define_type_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_once_init_leave
argument_list|(
operator|&
name|gimp_attribute_type_id__volatile
argument_list|,
name|gimp_attribute_type_id
argument_list|)
expr_stmt|;
block|}
return|return
name|gimp_attribute_type_id__volatile
return|;
block|}
end_function

begin_comment
comment|/*  * Helper functions  */
end_comment

begin_comment
comment|/**  * get_tag_time:  *  * @input:        a #gchar array  * @tm:           a pointer to a #TagTime struct  *  * converts a ISO 8601 IPTC Time to a TagTime structure  * Input is:  *  HHMMSS  *  HHMMSS:HHMM  *  * Return value:  #gboolean for success  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|get_tag_time (gchar * input,TagTime * tm)
name|get_tag_time
parameter_list|(
name|gchar
modifier|*
name|input
parameter_list|,
name|TagTime
modifier|*
name|tm
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|GString
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|tmpdate
decl_stmt|;
name|gboolean
name|flong
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|input
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|input
operator|=
name|g_strstrip
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input
operator|==
literal|'\0'
operator|||
operator|!
name|g_ascii_isdigit
argument_list|(
operator|*
name|input
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|25
condition|)
comment|/* HH:MM:SS+/-HH:MM */
block|{
name|flong
operator|=
name|FALSE
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%02ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flong
operator|=
name|TRUE
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%06ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flong
condition|)
comment|/* exactly 2 times */
block|{
name|input
operator|++
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%02ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|input
operator|++
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%02ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|tmpdate
operator|=
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|tmpdate
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|tmpdate
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* hhmmss */
name|tm
operator|->
name|tag_time_sec
operator|=
name|val
operator|%
literal|100
expr_stmt|;
name|tm
operator|->
name|tag_time_min
operator|=
operator|(
name|val
operator|%
literal|10000
operator|)
operator|/
literal|100
expr_stmt|;
name|tm
operator|->
name|tag_time_hour
operator|=
name|val
operator|/
literal|10000
expr_stmt|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flong
condition|)
comment|/* :HHSS for time zone */
block|{
name|val
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
operator|*
name|input
operator|==
literal|':'
condition|)
block|{
name|input
operator|++
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%05ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
operator|*
name|input
operator|==
literal|'+'
operator|||
operator|*
name|input
operator|==
literal|'-'
condition|)
comment|/* +/- HH:MM for time zone */
block|{
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%02ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|input
operator|++
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%02ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%04ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|tmpdate
operator|=
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|tmpdate
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|tmpdate
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tag_tz_min
operator|=
operator|(
name|val
operator|%
literal|100
operator|)
operator|/
literal|100
expr_stmt|;
name|tm
operator|->
name|tag_tz_hour
operator|=
name|val
operator|/
literal|100
expr_stmt|;
return|return
operator|*
name|input
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/**  * get_tag_date:  *  * @input:        a #gchar array  * @dt:           a pointer to a #TagDate struct  *  * converts a ISO 8601 IPTC Date to a TagDate structure  * Input is:  * CCYYMMDD  *  * Return value:  #gboolean for success  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|get_tag_date (gchar * input,TagDate * dt)
name|get_tag_date
parameter_list|(
name|gchar
modifier|*
name|input
parameter_list|,
name|TagDate
modifier|*
name|dt
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|GString
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|tmpdate
decl_stmt|;
name|gboolean
name|eod
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|input
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|input
operator|=
name|g_strstrip
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input
operator|==
literal|'\0'
operator|||
operator|!
name|g_ascii_isdigit
argument_list|(
operator|*
name|input
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|string
operator|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|eod
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|eod
condition|)
block|{
name|val
operator|=
name|strtoul
argument_list|(
name|input
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|input
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input
operator|==
literal|'-'
operator|||
operator|*
name|input
operator|==
literal|':'
condition|)
block|{
name|input
operator|++
expr_stmt|;
block|}
else|else
block|{
name|eod
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
literal|10
condition|)
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%02ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|tmpdate
operator|=
name|g_string_free
argument_list|(
name|string
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|tmpdate
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|tmpdate
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* YYYYMMDD */
name|dt
operator|->
name|tag_day
operator|=
name|val
operator|%
literal|100
expr_stmt|;
name|dt
operator|->
name|tag_month
operator|=
operator|(
name|val
operator|%
literal|10000
operator|)
operator|/
literal|100
expr_stmt|;
name|dt
operator|->
name|tag_year
operator|=
name|val
operator|/
literal|10000
expr_stmt|;
return|return
operator|*
name|input
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/**  * string_replace_str:  *  * @original:          the original string  * @old_pattern:       the pattern to replace  * @replacement:       the replacement  *  * replaces @old_pattern by @replacement in @original  * This routine is copied from VALA.  *  * Return value: the new string.  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|string_replace_str (const gchar * original,const gchar * old_pattern,const gchar * replacement)
name|string_replace_str
parameter_list|(
specifier|const
name|gchar
modifier|*
name|original
parameter_list|,
specifier|const
name|gchar
modifier|*
name|old_pattern
parameter_list|,
specifier|const
name|gchar
modifier|*
name|replacement
parameter_list|)
block|{
name|gchar
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|GError
modifier|*
name|_inner_error_
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|original
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|old_pattern
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|replacement
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|{
name|GRegex
modifier|*
name|regex
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|_tmp0_
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|_tmp1_
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|_tmp2_
init|=
name|NULL
decl_stmt|;
name|GRegex
modifier|*
name|_tmp3_
init|=
name|NULL
decl_stmt|;
name|GRegex
modifier|*
name|_tmp4_
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|_tmp5_
init|=
name|NULL
decl_stmt|;
name|GRegex
modifier|*
name|_tmp6_
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|_tmp7_
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|_tmp8_
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|_tmp9_
init|=
name|NULL
decl_stmt|;
name|_tmp0_
operator|=
name|old_pattern
expr_stmt|;
name|_tmp1_
operator|=
name|g_regex_escape_string
argument_list|(
name|_tmp0_
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_tmp2_
operator|=
name|_tmp1_
expr_stmt|;
name|_tmp3_
operator|=
name|g_regex_new
argument_list|(
name|_tmp2_
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|_inner_error_
argument_list|)
expr_stmt|;
name|_tmp4_
operator|=
name|_tmp3_
expr_stmt|;
name|_g_free0
argument_list|(
name|_tmp2_
argument_list|)
expr_stmt|;
name|regex
operator|=
name|_tmp4_
expr_stmt|;
if|if
condition|(
name|_inner_error_
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|_inner_error_
operator|->
name|domain
operator|==
name|G_REGEX_ERROR
condition|)
block|{
goto|goto
name|__catch0_g_regex_error
goto|;
block|}
name|g_critical
argument_list|(
literal|"file %s: line %d: unexpected error: %s (%s, %d)"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|_inner_error_
operator|->
name|message
argument_list|,
name|g_quark_to_string
argument_list|(
name|_inner_error_
operator|->
name|domain
argument_list|)
argument_list|,
name|_inner_error_
operator|->
name|code
argument_list|)
expr_stmt|;
name|g_clear_error
argument_list|(
operator|&
name|_inner_error_
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|_tmp6_
operator|=
name|regex
expr_stmt|;
name|_tmp7_
operator|=
name|replacement
expr_stmt|;
name|_tmp8_
operator|=
name|g_regex_replace_literal
argument_list|(
name|_tmp6_
argument_list|,
name|original
argument_list|,
call|(
name|gssize
call|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|_tmp7_
argument_list|,
literal|0
argument_list|,
operator|&
name|_inner_error_
argument_list|)
expr_stmt|;
name|_tmp5_
operator|=
name|_tmp8_
expr_stmt|;
if|if
condition|(
name|_inner_error_
operator|!=
name|NULL
condition|)
block|{
name|_g_regex_unref0
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|_inner_error_
operator|->
name|domain
operator|==
name|G_REGEX_ERROR
condition|)
block|{
goto|goto
name|__catch0_g_regex_error
goto|;
block|}
name|_g_regex_unref0
argument_list|(
name|regex
argument_list|)
expr_stmt|;
name|g_critical
argument_list|(
literal|"file %s: line %d: unexpected error: %s (%s, %d)"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|_inner_error_
operator|->
name|message
argument_list|,
name|g_quark_to_string
argument_list|(
name|_inner_error_
operator|->
name|domain
argument_list|)
argument_list|,
name|_inner_error_
operator|->
name|code
argument_list|)
expr_stmt|;
name|g_clear_error
argument_list|(
operator|&
name|_inner_error_
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|_tmp9_
operator|=
name|_tmp5_
expr_stmt|;
name|_tmp5_
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|_tmp9_
expr_stmt|;
name|_g_free0
argument_list|(
name|_tmp5_
argument_list|)
expr_stmt|;
name|_g_regex_unref0
argument_list|(
name|regex
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
goto|goto
name|__finally0
goto|;
name|__catch0_g_regex_error
label|:
block|{
name|GError
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|e
operator|=
name|_inner_error_
expr_stmt|;
name|_inner_error_
operator|=
name|NULL
expr_stmt|;
name|g_assert_not_reached
argument_list|()
expr_stmt|;
name|_g_error_free0
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|__finally0
label|:
if|if
condition|(
name|_inner_error_
operator|!=
name|NULL
condition|)
block|{
name|g_critical
argument_list|(
literal|"file %s: line %d: uncaught error: %s (%s, %d)"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|_inner_error_
operator|->
name|message
argument_list|,
name|g_quark_to_string
argument_list|(
name|_inner_error_
operator|->
name|domain
argument_list|)
argument_list|,
name|_inner_error_
operator|->
name|code
argument_list|)
expr_stmt|;
name|g_clear_error
argument_list|(
operator|&
name|_inner_error_
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * string_index_of:  *  * @haystack:          a #gchar  * @needle:            a #gchar  * @start_index:       a #gint  *  *  * Return value:  #gint that points to the position  * of @needle in @haystack, starting at @start_index,  * or -1, if @needle is not found  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|string_index_of (gchar * haystack,gchar * needle,gint start_index)
name|string_index_of
parameter_list|(
name|gchar
modifier|*
name|haystack
parameter_list|,
name|gchar
modifier|*
name|needle
parameter_list|,
name|gint
name|start_index
parameter_list|)
block|{
name|gint
name|result
init|=
literal|0
decl_stmt|;
name|gchar
modifier|*
name|temp1_
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|haystack
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|needle
operator|!=
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|temp1_
operator|=
name|strstr
argument_list|(
operator|(
operator|(
name|gchar
operator|*
operator|)
name|haystack
operator|)
operator|+
name|start_index
argument_list|,
name|needle
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1_
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
call|(
name|gint
call|)
argument_list|(
name|temp1_
operator|-
operator|(
operator|(
name|gchar
operator|*
operator|)
name|haystack
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * string_strnlen:  *  * @str:          a #gchar  * @maxlen:       a #glong  *  * Returns the length of @str or @maxlen, if @str  * is longer that @maxlen  *  * Return value:  #glong  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|glong
DECL|function|string_strnlen (gchar * str,glong maxlen)
name|string_strnlen
parameter_list|(
name|gchar
modifier|*
name|str
parameter_list|,
name|glong
name|maxlen
parameter_list|)
block|{
name|glong
name|result
init|=
literal|0L
decl_stmt|;
name|gchar
modifier|*
name|temp1_
init|=
name|NULL
decl_stmt|;
name|temp1_
operator|=
name|memchr
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
operator|(
name|gsize
operator|)
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1_
operator|==
name|NULL
condition|)
block|{
return|return
name|maxlen
return|;
block|}
else|else
block|{
name|result
operator|=
call|(
name|glong
call|)
argument_list|(
name|temp1_
operator|-
name|str
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * string_substring:  *  * @string:          a #gchar  * @offset:          a #glong  * @len:             a #glong  *  * Returns a substring of @string, starting at @offset  * with a legth of @len  *  * Return value:  #gchar to be freed if no longer use  *  * Since: 2.10  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|string_substring (gchar * string,glong offset,glong len)
name|string_substring
parameter_list|(
name|gchar
modifier|*
name|string
parameter_list|,
name|glong
name|offset
parameter_list|,
name|glong
name|len
parameter_list|)
block|{
name|gchar
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|glong
name|string_length
init|=
literal|0L
decl_stmt|;
name|gboolean
name|_tmp0_
init|=
name|FALSE
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|string
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
operator|(
operator|(
name|glong
operator|)
literal|0
operator|)
condition|)
block|{
name|_tmp0_
operator|=
name|len
operator|>=
operator|(
operator|(
name|glong
operator|)
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|_tmp0_
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|_tmp0_
condition|)
block|{
name|string_length
operator|=
name|string_strnlen
argument_list|(
operator|(
name|gchar
operator|*
operator|)
name|string
argument_list|,
name|offset
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_length
operator|=
operator|(
name|glong
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
operator|(
operator|(
name|glong
operator|)
literal|0
operator|)
condition|)
block|{
name|offset
operator|=
name|string_length
operator|+
name|offset
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|offset
operator|>=
operator|(
operator|(
name|glong
operator|)
literal|0
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_return_val_if_fail
argument_list|(
name|offset
operator|<=
name|string_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
operator|(
operator|(
name|glong
operator|)
literal|0
operator|)
condition|)
block|{
name|len
operator|=
name|string_length
operator|-
name|offset
expr_stmt|;
block|}
name|g_return_val_if_fail
argument_list|(
operator|(
name|offset
operator|+
name|len
operator|)
operator|<=
name|string_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|g_strndup
argument_list|(
operator|(
operator|(
name|gchar
operator|*
operator|)
name|string
operator|)
operator|+
name|offset
argument_list|,
operator|(
name|gsize
operator|)
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

