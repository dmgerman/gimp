begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMP - The GIMP Library  * Copyright (C) 1995-2000 Peter Mattis and Spencer Kimball  *  * gimpimage_pdb.c  *  * This library is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 2 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library; if not, write to the  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,  * Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* NOTE: This file is autogenerated by pdbgen.pl */
end_comment

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_comment
comment|/**  * gimp_image_list:  * @num_images: The number of images currently open.  *  * Returns the list of images currently open.  *  * This procedure returns the list of images currently open in the  * GIMP.  *  * Returns: The list of images currently open.  */
end_comment

begin_function
name|gint
modifier|*
DECL|function|gimp_image_list (gint * num_images)
name|gimp_image_list
parameter_list|(
name|gint
modifier|*
name|num_images
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
modifier|*
name|image_ids
init|=
name|NULL
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_list"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
operator|*
name|num_images
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
operator|*
name|num_images
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|image_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
operator|*
name|num_images
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|image_ids
argument_list|,
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32array
argument_list|,
operator|*
name|num_images
operator|*
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|image_ids
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_new:  * @width: The width of the image.  * @height: The height of the image.  * @type: The type of image.  *  * Creates a new image with the specified width, height, and type.  *  * Creates a new image, undisplayed with the specified extents and  * type. A layer should be created and added before this image is  * displayed, or subsequent calls to 'gimp_display_new' with this image  * as an argument will fail. Layers can be created using the  * 'gimp_layer_new' commands. They can be added to an image using the  * 'gimp_image_add_layer' command.  *  * Returns: The ID of the newly created image.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_new (gint width,gint height,GimpImageBaseType type)
name|gimp_image_new
parameter_list|(
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpImageBaseType
name|type
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_new"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|width
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|height
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|type
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|image_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_resize:  * @image_ID: The image.  * @new_width: New image width.  * @new_height: New image height.  * @offx: x offset between upper left corner of old and new images: (new - old).  * @offy: y offset between upper left corner of old and new images: (new - old).  *  * Resize the image to the specified extents.  *  * This procedure resizes the image so that it's new width and height  * are equal to the supplied parameters. Offsets are also provided  * which describe the position of the previous image's content. No  * bounds checking is currently provided, so don't supply parameters  * that are out of bounds. All channels within the image are resized  * according to the specified parameters; this includes the image  * selection mask. All layers within the image are repositioned  * according to the specified offsets.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_resize (gint32 image_ID,gint new_width,gint new_height,gint offx,gint offy)
name|gimp_image_resize
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|,
name|gint
name|offx
parameter_list|,
name|gint
name|offy
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_resize"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|new_width
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|new_height
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|offx
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|offy
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_scale:  * @image_ID: The image.  * @new_width: New image width.  * @new_height: New image height.  *  * Scale the image to the specified extents.  *  * This procedure scales the image so that it's new width and height  * are equal to the supplied parameters. Offsets are also provided  * which describe the position of the previous image's content. No  * bounds checking is currently provided, so don't supply parameters  * that are out of bounds. All channels within the image are scaled  * according to the specified parameters; this includes the image  * selection mask. All layers within the image are repositioned  * according to the specified offsets.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_scale (gint32 image_ID,gint new_width,gint new_height)
name|gimp_image_scale
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|new_width
parameter_list|,
name|gint
name|new_height
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|new_width
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|new_height
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_delete:  * @image_ID: The image.  *  * Delete the specified image.  *  * If there are no displays associated with this image it will be  * deleted. This means that you can not delete an image through the PDB  * that was created by the user. If the associated display was however  * created through the PDB and you know the display ID, you may delete  * the display. Removal of the last associated display will then delete  * the image.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_delete (gint32 image_ID)
name|gimp_image_delete
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_delete"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_free_shadow:  * @image_ID: The image.  *  * Free the specified image's shadow data (if it exists).  *  * This procedure is intended as a memory saving device. If any shadow  * memory has been allocated, it will be freed automatically on a call  * to 'gimp_image_delete'.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_free_shadow (gint32 image_ID)
name|gimp_image_free_shadow
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_free_shadow"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_layers:  * @image_ID: The image.  * @num_layers: The number of layers contained in the image.  *  * Returns the list of layers contained in the specified image.  *  * This procedure returns the list of layers contained in the specified  * image. The order of layers is from topmost to bottommost.  *  * Returns: The list of layers contained in the image.  */
end_comment

begin_function
name|gint
modifier|*
DECL|function|gimp_image_get_layers (gint32 image_ID,gint * num_layers)
name|gimp_image_get_layers
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
modifier|*
name|num_layers
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
modifier|*
name|layer_ids
init|=
name|NULL
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_layers"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
operator|*
name|num_layers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
operator|*
name|num_layers
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|layer_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
operator|*
name|num_layers
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|layer_ids
argument_list|,
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32array
argument_list|,
operator|*
name|num_layers
operator|*
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|layer_ids
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_channels:  * @image_ID: The image.  * @num_channels: The number of channels contained in the image.  *  * Returns the list of channels contained in the specified image.  *  * This procedure returns the list of channels contained in the  * specified image. This does not include the selection mask, or layer  * masks. The order is from topmost to bottommost.  *  * Returns: The list of channels contained in the image.  */
end_comment

begin_function
name|gint
modifier|*
DECL|function|gimp_image_get_channels (gint32 image_ID,gint * num_channels)
name|gimp_image_get_channels
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
modifier|*
name|num_channels
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
modifier|*
name|channel_ids
init|=
name|NULL
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_channels"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
operator|*
name|num_channels
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
operator|*
name|num_channels
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|channel_ids
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
operator|*
name|num_channels
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|channel_ids
argument_list|,
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32array
argument_list|,
operator|*
name|num_channels
operator|*
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|channel_ids
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_unset_active_channel:  * @image_ID: The image.  *  * Unsets the active channel in the specified image.  *  * If an active channel exists, it is unset. There then exists no  * active channel, and if desired, one can be set through a call to  * 'Set Active Channel'. No error is returned in the case of no  * existing active channel.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_unset_active_channel (gint32 image_ID)
name|gimp_image_unset_active_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_unset_active_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_pick_correlate_layer:  * @image_ID: The image.  * @x: The x coordinate for the pick.  * @y: The y coordinate for the pick.  *  * Find the layer visible at the specified coordinates.  *  * This procedure finds the layer which is visible at the specified  * coordinates. Layers which do not qualify are those whose extents do  * not pass within the specified coordinates, or which are transparent  * at the specified coordinates. This procedure will return -1 if no  * layer is found.  *  * Returns: The layer found at the specified coordinates.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_pick_correlate_layer (gint32 image_ID,gint x,gint y)
name|gimp_image_pick_correlate_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_pick_correlate_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|x
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|y
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|layer_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|layer_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_raise_layer:  * @image_ID: The image.  * @layer_ID: The layer to raise.  *  * Raise the specified layer in the image's layer stack  *  * This procedure raises the specified layer one step in the existing  * layer stack. It will not move the layer if there is no layer above  * it, or the layer has no alpha channel.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer (gint32 image_ID,gint32 layer_ID)
name|gimp_image_raise_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_raise_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_lower_layer:  * @image_ID: The image.  * @layer_ID: The layer to lower.  *  * Lower the specified layer in the image's layer stack  *  * This procedure lowers the specified layer one step in the existing  * layer stack. It will not move the layer if there is no layer below  * it, or the layer has no alpha channel.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer (gint32 image_ID,gint32 layer_ID)
name|gimp_image_lower_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_lower_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_raise_layer_to_top:  * @image_ID: The image.  * @layer_ID: The layer to raise to top.  *  * Raise the specified layer in the image's layer stack to top of stack  *  * This procedure raises the specified layer to top of the existing  * layer stack. It will not move the layer if there is no layer above  * it, or the layer has no alpha channel.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_raise_layer_to_top (gint32 image_ID,gint32 layer_ID)
name|gimp_image_raise_layer_to_top
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_raise_layer_to_top"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_lower_layer_to_bottom:  * @image_ID: The image.  * @layer_ID: The layer to lower to bottom.  *  * Lower the specified layer in the image's layer stack to bottom of  * stack  *  * This procedure lowers the specified layer to bottom of the existing  * layer stack. It will not move the layer if there is no layer below  * it, or the layer has no alpha channel.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_lower_layer_to_bottom (gint32 image_ID,gint32 layer_ID)
name|gimp_image_lower_layer_to_bottom
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_lower_layer_to_bottom"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_merge_visible_layers:  * @image_ID: The image.  * @merge_type: The type of merge.  *  * Merge the visible image layers into one.  *  * This procedure combines the visible layers into a single layer using  * the specified merge type. A merge type of EXPAND_AS_NECESSARY  * expands the final layer to encompass the areas of the visible  * layers. A merge type of CLIP_TO_IMAGE clips the final layer to the  * extents of the image. A merge type of CLIP_TO_BOTTOM_LAYER clips the  * final layer to the size of the bottommost layer.  *  * Returns: The resulting layer.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_merge_visible_layers (gint32 image_ID,GimpMergeType merge_type)
name|gimp_image_merge_visible_layers
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|GimpMergeType
name|merge_type
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_merge_visible_layers"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|merge_type
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|layer_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|layer_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_merge_down:  * @image_ID: The image.  * @merge_layer_ID: The layer to merge down from.  * @merge_type: The type of merge.  *  * Merge the layer passed and the first visible layer below.  *  * This procedure combines the passed layer and the first visible layer  * below it using the specified merge type. A merge type of  * EXPAND_AS_NECESSARY expands the final layer to encompass the areas  * of the visible layers. A merge type of CLIP_TO_IMAGE clips the final  * layer to the extents of the image. A merge type of  * CLIP_TO_BOTTOM_LAYER clips the final layer to the size of the  * bottommost layer.  *  * Returns: The resulting layer.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_merge_down (gint32 image_ID,gint32 merge_layer_ID,GimpMergeType merge_type)
name|gimp_image_merge_down
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|merge_layer_ID
parameter_list|,
name|GimpMergeType
name|merge_type
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_merge_down"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|merge_layer_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|merge_type
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|layer_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|layer_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_flatten:  * @image_ID: The image.  *  * Flatten all visible layers into a single layer. Discard all  * invisible layers.  *  * This procedure combines the visible layers in a manner analogous to  * merging with the CLIP_TO_IMAGE merge type. Non-visible layers are  * discarded, and the resulting image is stripped of its alpha channel.  *  * Returns: The resulting layer.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_flatten (gint32 image_ID)
name|gimp_image_flatten
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_flatten"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|layer_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|layer_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_add_layer:  * @image_ID: The image.  * @layer_ID: The layer.  * @position: The layer position.  *  * Add the specified layer to the image.  *  * This procedure adds the specified layer to the gimage at the given  * position. If the position is specified as -1, then the layer is  * inserted at the top of the layer stack. If the layer to be added has  * no alpha channel, it must be added at position 0. The layer type  * must be compatible with the image base type.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_add_layer (gint32 image_ID,gint32 layer_ID,gint position)
name|gimp_image_add_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_add_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|position
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_remove_layer:  * @image_ID: The image.  * @layer_ID: The layer.  *  * Remove the specified layer from the image.  *  * This procedure removes the specified layer from the image. If the  * layer doesn't exist, an error is returned. If there are no layers  * left in the image, this call will fail. If this layer is the last  * layer remaining, the image will become empty and have no active  * layer.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_remove_layer (gint32 image_ID,gint32 layer_ID)
name|gimp_image_remove_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_remove_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_add_layer_mask:  * @image_ID: The image.  * @layer_ID: The layer to receive the mask.  * @mask_ID: The mask to add to the layer.  *  * Add a layer mask to the specified layer.  *  * This procedure adds a layer mask to the specified layer. Layer masks  * serve as an additional alpha channel for a layer. This procedure  * will fail if a number of prerequisites aren't met. The layer cannot  * already have a layer mask. The specified mask must exist and have  * the same dimensions as the layer. Both the mask and the layer must  * have been created for use with the specified image.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_add_layer_mask (gint32 image_ID,gint32 layer_ID,gint32 mask_ID)
name|gimp_image_add_layer_mask
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|,
name|gint32
name|mask_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_add_layer_mask"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_CHANNEL
argument_list|,
name|mask_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_remove_layer_mask:  * @image_ID: The image.  * @layer_ID: The layer from which to remove mask.  * @mode: Removal mode.  *  * Remove the specified layer mask from the layer.  *  * This procedure removes the specified layer mask from the layer. If  * the mask doesn't exist, an error is returned.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_remove_layer_mask (gint32 image_ID,gint32 layer_ID,GimpMaskApplyMode mode)
name|gimp_image_remove_layer_mask
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|,
name|GimpMaskApplyMode
name|mode
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_remove_layer_mask"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|mode
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_raise_channel:  * @image_ID: The image.  * @channel_ID: The channel to raise.  *  * Raise the specified channel in the image's channel stack  *  * This procedure raises the specified channel one step in the existing  * channel stack. It will not move the channel if there is no channel  * above it.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_raise_channel (gint32 image_ID,gint32 channel_ID)
name|gimp_image_raise_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|channel_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_raise_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_CHANNEL
argument_list|,
name|channel_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_lower_channel:  * @image_ID: The image.  * @layer_ID: The layer to lower.  *  * Lower the specified layer in the image's layer stack  *  * This procedure lowers the specified layer one step in the existing  * layer stack. It will not move the layer if there is no layer below  * it, or the layer has no alpha channel.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_lower_channel (gint32 image_ID,gint32 layer_ID)
name|gimp_image_lower_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_lower_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_add_channel:  * @image_ID: The image.  * @channel_ID: The channel.  * @position: The channel position.  *  * Add the specified channel to the image.  *  * This procedure adds the specified channel to the image. The position  * channel is not currently used, so the channel is always inserted at  * the top of the channel stack.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_add_channel (gint32 image_ID,gint32 channel_ID,gint position)
name|gimp_image_add_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|channel_ID
parameter_list|,
name|gint
name|position
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_add_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_CHANNEL
argument_list|,
name|channel_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|position
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_remove_channel:  * @image_ID: The image.  * @channel_ID: The channel.  *  * Remove the specified channel from the image.  *  * This procedure removes the specified channel from the image. If the  * channel doesn't exist, an error is returned.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_remove_channel (gint32 image_ID,gint32 channel_ID)
name|gimp_image_remove_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|channel_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_remove_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_CHANNEL
argument_list|,
name|channel_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_active_drawable:  * @image_ID: The image.  *  * Get the image's active drawable  *  * This procedure returns the ID of the image's active drawable. This  * can be either a layer, a channel, or a layer mask. The active  * drawable is specified by the active image channel. If that is -1,  * then by the active image layer. If the active image layer has a  * layer mask and the layer mask is in edit mode, then the layer mask  * is the active drawable.  *  * Returns: The active drawable.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_active_drawable (gint32 image_ID)
name|gimp_image_active_drawable
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|drawable_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_active_drawable"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|drawable_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_drawable
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|drawable_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_base_type:  * @image_ID: The image.  *  * Get the base type of the image.  *  * This procedure returns the image's base type. Layers in the image  * must be of this subtype, but can have an optional alpha channel.  *  * Returns: The image's base type.  */
end_comment

begin_function
name|GimpImageBaseType
DECL|function|gimp_image_base_type (gint32 image_ID)
name|gimp_image_base_type
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|GimpImageBaseType
name|base_type
init|=
literal|0
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_base_type"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|base_type
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|base_type
return|;
block|}
end_function

begin_comment
comment|/**  * _gimp_image_get_cmap:  * @image_ID: The image.  * @num_bytes: Number of bytes in the colormap array.  *  * Returns the image's colormap  *  * This procedure returns an actual pointer to the image's colormap, as  * well as the number of bytes contained in the colormap. The actual  * number of colors in the transmitted colormap will be \"num_bytes\" /  * 3. If the image is not of base type INDEXED, this pointer will be  * NULL.  *  * Returns: The image's colormap.  */
end_comment

begin_function
name|guint8
modifier|*
DECL|function|_gimp_image_get_cmap (gint32 image_ID,gint * num_bytes)
name|_gimp_image_get_cmap
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
modifier|*
name|num_bytes
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|guint8
modifier|*
name|cmap
init|=
name|NULL
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_cmap"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
operator|*
name|num_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
operator|*
name|num_bytes
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|cmap
operator|=
name|g_new
argument_list|(
name|guint8
argument_list|,
operator|*
name|num_bytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cmap
argument_list|,
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int8array
argument_list|,
operator|*
name|num_bytes
operator|*
sizeof|sizeof
argument_list|(
name|guint8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|cmap
return|;
block|}
end_function

begin_comment
comment|/**  * _gimp_image_set_cmap:  * @image_ID: The image.  * @num_bytes: Number of bytes in the colormap array.  * @cmap: The new colormap values.  *  * Sets the entries in the image's colormap.  *  * This procedure sets the entries in the specified image's colormap.  * The number of entries is specified by the \"num_bytes\" parameter  * and corresponds to the number of INT8 triples that must be contained  * in the \"cmap\" array. The actual number of colors in the  * transmitted colormap is \"num_bytes\" / 3.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|_gimp_image_set_cmap (gint32 image_ID,gint num_bytes,guint8 * cmap)
name|_gimp_image_set_cmap
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|num_bytes
parameter_list|,
name|guint8
modifier|*
name|cmap
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_cmap"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|num_bytes
argument_list|,
name|GIMP_PDB_INT8ARRAY
argument_list|,
name|cmap
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_undo_is_enabled:  * @image_ID: The image.  *  * Check if the image's undo stack is enabled.  *  * This procedure checks if the image's undo stack is currently enabled  * or disabled. This is useful when several plugins or scripts call  * each other and want to check if their caller has already used  * 'gimp_image_undo_disable' or 'gimp_image_undo_freeze'.  *  * Returns: True if undo is enabled for this image.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_is_enabled (gint32 image_ID)
name|gimp_image_undo_is_enabled
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|enabled
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_undo_is_enabled"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|enabled
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|enabled
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_undo_enable:  * @image_ID: The image.  *  * Enable the image's undo stack.  *  * This procedure enables the image's undo stack, allowing subsequent  * operations to store their undo steps. This is generally called in  * conjunction with 'gimp_image_undo_disable' to temporarily disable an  * image undo stack.  *  * Returns: True if the image undo has been enabled.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_enable (gint32 image_ID)
name|gimp_image_undo_enable
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|enabled
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_undo_enable"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|enabled
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|enabled
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_undo_disable:  * @image_ID: The image.  *  * Disable the image's undo stack.  *  * This procedure disables the image's undo stack, allowing subsequent  * operations to ignore their undo steps. This is generally called in  * conjunction with 'gimp_image_undo_enable' to temporarily disable an  * image undo stack. This is advantageous because saving undo steps can  * be time and memory intensive.  *  * Returns: True if the image undo has been disabled.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_disable (gint32 image_ID)
name|gimp_image_undo_disable
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|disabled
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_undo_disable"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|disabled
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|disabled
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_undo_freeze:  * @image_ID: The image.  *  * Freeze the image's undo stack.  *  * This procedure freezes the image's undo stack, allowing subsequent  * operations to ignore their undo steps. This is generally called in  * conjunction with 'gimp_image_undo_thaw' to temporarily disable an  * image undo stack. This is advantageous because saving undo steps can  * be time and memory intensive. 'gimp_image_undo_{freeze,thaw}' and  * 'gimp_image_undo_{disable,enable}' differ in that the former does  * not free up all undo steps when undo is thawed, so is more suited to  * interactive in-situ previews. It is important in this case that the  * image is back to the same state it was frozen in before thawing,  * else 'undo' behaviour is undefined.  *  * Returns: True if the image undo has been frozen.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_freeze (gint32 image_ID)
name|gimp_image_undo_freeze
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|frozen
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_undo_freeze"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|frozen
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|frozen
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_undo_thaw:  * @image_ID: The image.  *  * Thaw the image's undo stack.  *  * This procedure thaws the image's undo stack, allowing subsequent  * operations to store their undo steps. This is generally called in  * conjunction with 'gimp_image_undo_freeze' to temporarily freeze an  * image undo stack. 'gimp_image_undo_thaw' does NOT free the undo  * stack as 'gimp_image_undo_enable' does, so is suited for situations  * where one wishes to leave the undo stack in the same state in which  * one found it despite non-destructively playing with the image in the  * meantime. An example would be in-situ plugin previews. Balancing  * freezes and thaws and ensuring image consistancy is the  * responsibility of the caller.  *  * Returns: True if the image undo has been thawed.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_undo_thaw (gint32 image_ID)
name|gimp_image_undo_thaw
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|thawed
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_undo_thaw"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|thawed
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|thawed
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_clean_all:  * @image_ID: The image.  *  * Set the image dirty count to 0.  *  * This procedure sets the specified image's dirty count to 0, allowing  * operations to occur without having a 'dirtied' image. This is  * especially useful for creating and loading images which should not  * initially be considered dirty, even though layers must be created,  * filled, and installed in the image.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_clean_all (gint32 image_ID)
name|gimp_image_clean_all
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_clean_all"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_floating_selection:  * @image_ID: The image.  *  * Return the floating selection of the image.  *  * This procedure returns the image's floating_sel, if it exists. If it  * doesn't exist, -1 is returned as the layer ID.  *  * Returns: The image's floating selection.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_floating_selection (gint32 image_ID)
name|gimp_image_floating_selection
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|floating_sel_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_floating_selection"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|floating_sel_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|floating_sel_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_floating_sel_attached_to:  * @image_ID: The image.  *  * Return the drawable the floating selection is attached to.  *  * This procedure returns the drawable the image's floating selection  * is attached to, if it exists. If it doesn't exist, -1 is returned as  * the drawable ID.  *  * Returns: The drawable the floating selection is attached to.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_floating_sel_attached_to (gint32 image_ID)
name|gimp_image_floating_sel_attached_to
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|drawable_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_floating_sel_attached_to"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|drawable_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_drawable
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|drawable_ID
return|;
block|}
end_function

begin_comment
comment|/**  * _gimp_image_thumbnail:  * @image_ID: The image.  * @width: The thumbnail width.  * @height: The thumbnail height.  * @ret_width: The previews width.  * @ret_height: The previews height.  * @bpp: The previews bpp.  * @thumbnail_data_count: The number of bytes in thumbnail data.  * @thumbnail_data: The thumbnail data.  *  * Get a thumbnail of an image.  *  * This function gets data from which a thumbnail of an image preview  * can be created. Maximum x or y dimension is 128 pixels. The pixles  * are returned in the RGB[A] format. The bpp return value gives the  * number of bytes in the image. The alpha channel also returned if the  * image has one.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|_gimp_image_thumbnail (gint32 image_ID,gint width,gint height,gint * ret_width,gint * ret_height,gint * bpp,gint * thumbnail_data_count,guint8 ** thumbnail_data)
name|_gimp_image_thumbnail
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
modifier|*
name|ret_width
parameter_list|,
name|gint
modifier|*
name|ret_height
parameter_list|,
name|gint
modifier|*
name|bpp
parameter_list|,
name|gint
modifier|*
name|thumbnail_data_count
parameter_list|,
name|guint8
modifier|*
modifier|*
name|thumbnail_data
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_thumbnail"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|width
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|height
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
operator|*
name|ret_width
operator|=
literal|0
expr_stmt|;
operator|*
name|ret_height
operator|=
literal|0
expr_stmt|;
operator|*
name|bpp
operator|=
literal|0
expr_stmt|;
operator|*
name|thumbnail_data_count
operator|=
literal|0
expr_stmt|;
operator|*
name|thumbnail_data
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
operator|*
name|ret_width
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|ret_height
operator|=
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|bpp
operator|=
name|return_vals
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|thumbnail_data_count
operator|=
name|return_vals
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|thumbnail_data
operator|=
name|g_new
argument_list|(
name|guint8
argument_list|,
operator|*
name|thumbnail_data_count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|thumbnail_data
argument_list|,
name|return_vals
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int8array
argument_list|,
operator|*
name|thumbnail_data_count
operator|*
sizeof|sizeof
argument_list|(
name|guint8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_tattoo_state:  * @image_ID: The image.  * @tattoo: The new tattoo state of the image.  *  * Set the tattoo state associated with the image.  *  * This procedure sets the tattoo state of the image. Use only by  * save/load plugins that wish to preserve an images tattoo state.  * Using this function at other times will produce unexpected results.  * A full check of uniqueness of states in layers, channels and paths  * will be performed by this procedure and a execution failure will be  * returned if this fails. A failure will also be returned if the new  * tattoo state value is less than the maximum tattoo value from all of  * the tattoos from the paths,layers and channels. After the image data  * has been loaded and all the tattoos have been set then this is the  * last procedure that should be called. If effectively does a status  * check on the tattoo values that have been set to make sure that all  * is OK.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_tattoo_state (gint32 image_ID,gint tattoo)
name|gimp_image_set_tattoo_state
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|tattoo
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_tattoo_state"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|tattoo
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_tattoo_state:  * @image_ID: The image.  *  * Returns the tattoo state associated with the image.  *  * This procedure returns the tattoo state of the image. Use only by  * save/load plugins that wish to preserve an images tattoo state.  * Using this function at other times will produce unexpected results.  *  * Returns: The tattoo state associated with the image.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_get_tattoo_state (gint32 image_ID)
name|gimp_image_get_tattoo_state
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
name|tattoo
init|=
literal|0
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_tattoo_state"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|tattoo
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|tattoo
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_width:  * @image_ID: The image.  *  * Return the width of the image  *  * This procedure returns the image's width. This value is independent  * of any of the layers in this image. This is the \"canvas\" width.  *  * Returns: The image's width.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_width (gint32 image_ID)
name|gimp_image_width
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
name|width
init|=
literal|0
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_width"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|width
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|width
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_height:  * @image_ID: The image.  *  * Return the height of the image  *  * This procedure returns the image's width. This value is independent  * of any of the layers in this image. This is the \"canvas\" height.  *  * Returns: The image's height.  */
end_comment

begin_function
name|gint
DECL|function|gimp_image_height (gint32 image_ID)
name|gimp_image_height
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
name|height
init|=
literal|0
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_height"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|height
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|height
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_active_layer:  * @image_ID: The image.  *  * Returns if the specified image's active layer.  *  * If there is an active layer, its ID will be returned, otherwise, -1.  * If a channel is currently active, then no layer will be. If a layer  * mask is active, then this will return the associated layer.  *  * Returns: The active layer.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_get_active_layer (gint32 image_ID)
name|gimp_image_get_active_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|active_layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_active_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|active_layer_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|active_layer_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_active_layer:  * @image_ID: The image.  * @active_layer_ID: The new image active layer.  *  * Sets if the specified image's active layer.  *  * If the layer exists, it is set as the active layer in the image. Any  * previous active layer or channel is set to inactive. An exception is  * a previously existing floating selection, in which case this  * procedure will return an execution error.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_active_layer (gint32 image_ID,gint32 active_layer_ID)
name|gimp_image_set_active_layer
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|active_layer_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_active_layer"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_LAYER
argument_list|,
name|active_layer_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_active_channel:  * @image_ID: The image.  *  * Returns if the specified image's active channel.  *  * If there is an active channel, this will return the channel ID,  * otherwise, -1.  *  * Returns: The active channel.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_get_active_channel (gint32 image_ID)
name|gimp_image_get_active_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|active_channel_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_active_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|active_channel_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_channel
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|active_channel_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_active_channel:  * @image_ID: The image.  * @active_channel_ID: The new image active channel.  *  * Sets if the specified image's active channel.  *  * If the channel exists, it is set as the active channel in the image.  * Any previous active channel or channel is set to inactive. An  * exception is a previously existing floating selection, in which case  * this procedure will return an execution error.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_active_channel (gint32 image_ID,gint32 active_channel_ID)
name|gimp_image_set_active_channel
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|active_channel_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_active_channel"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_CHANNEL
argument_list|,
name|active_channel_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_selection:  * @image_ID: The image.  *  * Returns if the specified image's selection.  *  * This will always return a valid ID for a selection--which is  * represented as a channel internally.  *  * Returns: The selection channel.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_get_selection (gint32 image_ID)
name|gimp_image_get_selection
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|selection_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_selection"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|selection_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_selection
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|selection_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_component_active:  * @image_ID: The image.  * @component: The image component.  *  * Returns if the specified image's image component is active.  *  * This procedure returns if the specified image's image component  * (i.e. Red, Green, Blue intensity channels in an RGB image) is active  * or inactive--whether or not it can be modified. If the specified  * component is not valid for the image type, an error is returned.  *  * Returns: Component is active.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_get_component_active (gint32 image_ID,GimpChannelType component)
name|gimp_image_get_component_active
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|GimpChannelType
name|component
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|active
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_component_active"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|component
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|active
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|active
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_component_active:  * @image_ID: The image.  * @component: The image component.  * @active: Component is active.  *  * Sets if the specified image's image component is active.  *  * This procedure sets if the specified image's image component (i.e.  * Red, Green, Blue intensity channels in an RGB image) is active or  * inactive--whether or not it can be modified. If the specified  * component is not valid for the image type, an error is returned.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_component_active (gint32 image_ID,GimpChannelType component,gboolean active)
name|gimp_image_set_component_active
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|GimpChannelType
name|component
parameter_list|,
name|gboolean
name|active
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_component_active"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|component
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|active
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_component_visible:  * @image_ID: The image.  * @component: The image component.  *  * Returns if the specified image's image component is visible.  *  * This procedure returns if the specified image's image component  * (i.e. Red, Green, Blue intensity channels in an RGB image) is  * visible or invisible--whether or not it can be seen. If the  * specified component is not valid for the image type, an error is  * returned.  *  * Returns: Component is visible.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_get_component_visible (gint32 image_ID,GimpChannelType component)
name|gimp_image_get_component_visible
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|GimpChannelType
name|component
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|visible
init|=
name|FALSE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_component_visible"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|component
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|visible
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|visible
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_component_visible:  * @image_ID: The image.  * @component: The image component.  * @visible: Component is visible.  *  * Sets if the specified image's image component is visible.  *  * This procedure sets if the specified image's image component (i.e.  * Red, Green, Blue intensity channels in an RGB image) is visible or  * invisible--whether or not it can be seen. If the specified component  * is not valid for the image type, an error is returned.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_component_visible (gint32 image_ID,GimpChannelType component,gboolean visible)
name|gimp_image_set_component_visible
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|GimpChannelType
name|component
parameter_list|,
name|gboolean
name|visible
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_component_visible"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|component
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|visible
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_filename:  * @image_ID: The image.  *  * Returns if the specified image's filename.  *  * This procedure returns if the specified image's filename--if it was  * loaded or has since been saved. Otherwise, returns NULL.  *  * Returns: The filename.  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_image_get_filename (gint32 image_ID)
name|gimp_image_get_filename
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gchar
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_filename"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|filename
operator|=
name|g_strdup
argument_list|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_filename:  * @image_ID: The image.  * @filename: The new image filename.  *  * Sets if the specified image's filename.  *  * This procedure sets if the specified image's filename.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_filename (gint32 image_ID,gchar * filename)
name|gimp_image_set_filename
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_filename"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|filename
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_resolution:  * @image_ID: The image.  * @xresolution: The resolutionin the x-axis, in dots per inch.  * @yresolution: The resolutionin the y-axis, in dots per inch.  *  * Returns if the specified image's resolution.  *  * This procedure returns if the specified image's resolution in dots  * per inch. This value is independent of any of the layers in this  * image.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_get_resolution (gint32 image_ID,gdouble * xresolution,gdouble * yresolution)
name|gimp_image_get_resolution
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gdouble
modifier|*
name|xresolution
parameter_list|,
name|gdouble
modifier|*
name|yresolution
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_resolution"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
operator|*
name|xresolution
operator|=
literal|0.0
expr_stmt|;
operator|*
name|yresolution
operator|=
literal|0.0
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
operator|*
name|xresolution
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
operator|*
name|yresolution
operator|=
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_resolution:  * @image_ID: The image.  * @xresolution: The new image resolution in the x-axis, in dots per inch.  * @yresolution: The new image resolution in the y-axis, in dots per inch.  *  * Sets if the specified image's resolution.  *  * This procedure sets if the specified image's resolution in dots per  * inch. This value is independent of any of the layers in this image.  * No scaling or resizing is performed.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_resolution (gint32 image_ID,gdouble xresolution,gdouble yresolution)
name|gimp_image_set_resolution
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gdouble
name|xresolution
parameter_list|,
name|gdouble
name|yresolution
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_resolution"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_FLOAT
argument_list|,
name|xresolution
argument_list|,
name|GIMP_PDB_FLOAT
argument_list|,
name|yresolution
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_unit:  * @image_ID: The image.  *  * Returns if the specified image's unit.  *  * This procedure returns if the specified image's unit. This value is  * independent of any of the layers in this image. See the gimp_unit_*  * procedure definitions for the valid range of unit IDs and a  * description of the unit system.  *  * Returns: The unit.  */
end_comment

begin_function
name|GimpUnit
DECL|function|gimp_image_get_unit (gint32 image_ID)
name|gimp_image_get_unit
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|GimpUnit
name|unit
init|=
literal|0
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_unit"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|unit
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_unit
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_set_unit:  * @image_ID: The image.  * @unit: The new image unit.  *  * Sets if the specified image's unit.  *  * This procedure sets if the specified image's unit. No scaling or  * resizing is performed. This value is independent of any of the  * layers in this image. See the gimp_unit_* procedure definitions for  * the valid range of unit IDs and a description of the unit system.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_image_set_unit (gint32 image_ID,GimpUnit unit)
name|gimp_image_set_unit
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|GimpUnit
name|unit
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_set_unit"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|unit
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|success
operator|=
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_layer_by_tattoo:  * @image_ID: The image.  * @tattoo: The tattoo of the layer to find.  *  * Find a layer with a given tattoo in an image.  *  * This procedure returns the layer with the given tattoo in the  * specified image.  *  * Returns: The layer with the specified tattoo.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_get_layer_by_tattoo (gint32 image_ID,gint tattoo)
name|gimp_image_get_layer_by_tattoo
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|tattoo
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_layer_by_tattoo"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|tattoo
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|layer_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_layer
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|layer_ID
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_image_get_channel_by_tattoo:  * @image_ID: The image.  * @tattoo: The tattoo of the channel to find.  *  * Find a channel with a given tattoo in an image.  *  * This procedure returns the channel with the given tattoo in the  * specified image.  *  * Returns: The channel with the specified tattoo.  */
end_comment

begin_function
name|gint32
DECL|function|gimp_image_get_channel_by_tattoo (gint32 image_ID,gint tattoo)
name|gimp_image_get_channel_by_tattoo
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gint
name|tattoo
parameter_list|)
block|{
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint32
name|channel_ID
init|=
operator|-
literal|1
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_get_channel_by_tattoo"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|tattoo
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
name|channel_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_channel
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|channel_ID
return|;
block|}
end_function

end_unit

