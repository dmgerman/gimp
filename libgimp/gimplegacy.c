begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMP - The GIMP Library  * Copyright (C) 1995-1997 Peter Mattis and Spencer Kimball  *  * gimplegacy.c  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Library General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<https://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpprotocol.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpwire.h"
end_include

begin_include
include|#
directive|include
file|"gimp-shm.h"
end_include

begin_include
include|#
directive|include
file|"gimp-private.h"
end_include

begin_include
include|#
directive|include
file|"gimpgpcompat.h"
end_include

begin_include
include|#
directive|include
file|"gimpgpparams.h"
end_include

begin_include
include|#
directive|include
file|"gimppdb_pdb.h"
end_include

begin_include
include|#
directive|include
file|"gimpplugin_pdb.h"
end_include

begin_include
include|#
directive|include
file|"gimplegacy-private.h"
end_include

begin_include
include|#
directive|include
file|"libgimp-intl.h"
end_include

begin_define
DECL|macro|WRITE_BUFFER_SIZE
define|#
directive|define
name|WRITE_BUFFER_SIZE
value|1024
end_define

begin_define
DECL|macro|ASSERT_NO_PLUG_IN_EXISTS (strfunc)
define|#
directive|define
name|ASSERT_NO_PLUG_IN_EXISTS
parameter_list|(
name|strfunc
parameter_list|)
define|\
value|if (gimp_get_plug_in ())                                              \     {                                                                   \       g_printerr ("%s ERROR: %s() cannot be called when using the "     \                   "new plug-in API\n",                                  \                   g_get_prgname (), strfunc);                           \       gimp_quit ();                                                     \     }
end_define

begin_function_decl
specifier|static
name|void
name|gimp_loop
parameter_list|(
name|GimpRunProc
name|run_proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_process_message
parameter_list|(
name|GimpWireMessage
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_proc_run
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_plugin_io_error_handler
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|GIOCondition
name|cond
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_write
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|guint8
modifier|*
name|buf
parameter_list|,
name|gulong
name|count
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_flush
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_set_pdb_error
parameter_list|(
name|GimpValueArray
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|_gimp_readchannel
name|GIOChannel
modifier|*
name|_gimp_readchannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|_gimp_writechannel
name|GIOChannel
modifier|*
name|_gimp_writechannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|write_buffer
specifier|static
name|gchar
name|write_buffer
index|[
name|WRITE_BUFFER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|write_buffer_index
specifier|static
name|gulong
name|write_buffer_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|static
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pdb_error_status
specifier|static
name|GimpPDBStatusType
name|pdb_error_status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pdb_error_message
specifier|static
name|gchar
modifier|*
name|pdb_error_message
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * gimp_main_legacy:  * @info: the #GimpPlugInInfo structure  * @argc: the number of arguments  * @argv: (array length=argc): the arguments  *  * The main procedure that must be called with the #GimpPlugInInfo  * structure and the 'argc' and 'argv' that are passed to "main".  *  * Returns: an exit status as defined by the C library,  *          on success EXIT_SUCCESS.  **/
end_comment

begin_function
name|gint
DECL|function|gimp_main_legacy (const GimpPlugInInfo * info,gint argc,gchar * argv[])
name|gimp_main_legacy
parameter_list|(
specifier|const
name|GimpPlugInInfo
modifier|*
name|info
parameter_list|,
name|gint
name|argc
parameter_list|,
name|gchar
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|_gimp_main_internal
argument_list|(
name|G_TYPE_NONE
argument_list|,
name|info
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_install_procedure:  * @name:                                      the procedure's name.  * @blurb:                                     a short text describing what the procedure does.  * @help:                                      the help text for the procedure (usually considerably  *                                             longer than @blurb).  * @authors:                                   the procedure's authors.  * @copyright:                                 the procedure's copyright.  * @date:                                      the date the procedure was added.  * @menu_label:                                the label to use for the procedure's menu entry,  *                                             or %NULL if the procedure has no menu entry.  * @image_types:                               the drawable types the procedure can handle.  * @type:                                      the type of the procedure.  * @n_params:                                  the number of parameters the procedure takes.  * @n_return_vals:                             the number of return values the procedure returns.  * @params: (array length=n_params):           the procedure's parameters.  * @return_vals: (array length=n_return_vals): the procedure's return values.  *  * Installs a new procedure with the PDB (procedural database).  *  * Call this function from within your plug-in's query() function for  * each procedure your plug-in implements.  *  * The @name parameter is mandatory and should be unique, or it will  * overwrite an already existing procedure (overwrite procedures only  * if you know what you're doing).  *  * The @blurb, @help, @authors, @copyright and @date parameters are  * optional but then you shouldn't write procedures without proper  * documentation, should you.  *  * @menu_label defines the label that should be used for the  * procedure's menu entry. The position where to register in the menu  * hierarchy is chosen using gimp_plugin_menu_register().  *  * It is possible to register a procedure only for keyboard-shortcut  * activation by passing a @menu_label to gimp_install_procedure() but  * not registering any menu path with gimp_plugin_menu_register(). In  * this case, the given @menu_label will only be used as the  * procedure's user-visible name in the keyboard shortcut editor.  *  * @image_types is a comma separated list of image types, or actually  * drawable types, that this procedure can deal with. Wildcards are  * possible here, so you could say "RGB*" instead of "RGB, RGBA" or  * "*" for all image types. If the procedure doesn't need an image to  * run, use the empty string.  *  * @type must be one of %GIMP_PLUGIN or %GIMP_EXTENSION. Note that  * temporary procedures must be installed using  * gimp_install_temp_proc().  *  * NOTE: Unlike the GIMP 1.2 API, %GIMP_EXTENSION no longer means  * that the procedure's menu prefix is&lt;Toolbox&gt;, but that  * it will install temporary procedures. Therefore, the GIMP core  * will wait until the %GIMP_EXTENSION procedure has called  * gimp_extension_ack(), which means that the procedure has done  * its initialization, installed its temporary procedures and is  * ready to run.  *  *<emphasis>Not calling gimp_extension_ack() from a %GIMP_EXTENSION  * procedure will cause the GIMP core to lock up.</emphasis>  *  * Additionally, a %GIMP_EXTENSION procedure with no parameters  * (@n_params == 0 and @params == %NULL) is an "automatic" extension  * that will be automatically started on each GIMP startup.  **/
end_comment

begin_function
name|void
DECL|function|gimp_install_procedure (const gchar * name,const gchar * blurb,const gchar * help,const gchar * authors,const gchar * copyright,const gchar * date,const gchar * menu_label,const gchar * image_types,GimpPDBProcType type,gint n_params,gint n_return_vals,const GimpParamDef * params,const GimpParamDef * return_vals)
name|gimp_install_procedure
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|blurb
parameter_list|,
specifier|const
name|gchar
modifier|*
name|help
parameter_list|,
specifier|const
name|gchar
modifier|*
name|authors
parameter_list|,
specifier|const
name|gchar
modifier|*
name|copyright
parameter_list|,
specifier|const
name|gchar
modifier|*
name|date
parameter_list|,
specifier|const
name|gchar
modifier|*
name|menu_label
parameter_list|,
specifier|const
name|gchar
modifier|*
name|image_types
parameter_list|,
name|GimpPDBProcType
name|type
parameter_list|,
name|gint
name|n_params
parameter_list|,
name|gint
name|n_return_vals
parameter_list|,
specifier|const
name|GimpParamDef
modifier|*
name|params
parameter_list|,
specifier|const
name|GimpParamDef
modifier|*
name|return_vals
parameter_list|)
block|{
name|GPProcInstall
name|proc_install
decl_stmt|;
name|GList
modifier|*
name|pspecs
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|type
operator|!=
name|GIMP_INTERNAL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|n_params
operator|==
literal|0
operator|&&
name|params
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n_params
operator|>
literal|0
operator|&&
name|params
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|n_return_vals
operator|==
literal|0
operator|&&
name|return_vals
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n_return_vals
operator|>
literal|0
operator|&&
name|return_vals
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|proc_install
operator|.
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
name|proc_install
operator|.
name|blurb
operator|=
operator|(
name|gchar
operator|*
operator|)
name|blurb
expr_stmt|;
name|proc_install
operator|.
name|help
operator|=
operator|(
name|gchar
operator|*
operator|)
name|help
expr_stmt|;
name|proc_install
operator|.
name|help_id
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
name|proc_install
operator|.
name|authors
operator|=
operator|(
name|gchar
operator|*
operator|)
name|authors
expr_stmt|;
name|proc_install
operator|.
name|copyright
operator|=
operator|(
name|gchar
operator|*
operator|)
name|copyright
expr_stmt|;
name|proc_install
operator|.
name|date
operator|=
operator|(
name|gchar
operator|*
operator|)
name|date
expr_stmt|;
name|proc_install
operator|.
name|menu_label
operator|=
operator|(
name|gchar
operator|*
operator|)
name|menu_label
expr_stmt|;
name|proc_install
operator|.
name|image_types
operator|=
operator|(
name|gchar
operator|*
operator|)
name|image_types
expr_stmt|;
name|proc_install
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|proc_install
operator|.
name|nparams
operator|=
name|n_params
expr_stmt|;
name|proc_install
operator|.
name|nreturn_vals
operator|=
name|n_return_vals
expr_stmt|;
name|proc_install
operator|.
name|params
operator|=
name|g_new0
argument_list|(
name|GPParamDef
argument_list|,
name|n_params
argument_list|)
expr_stmt|;
name|proc_install
operator|.
name|return_vals
operator|=
name|g_new0
argument_list|(
name|GPParamDef
argument_list|,
name|n_return_vals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_params
condition|;
name|i
operator|++
control|)
block|{
name|GParamSpec
modifier|*
name|pspec
init|=
name|_gimp_gp_compat_param_spec
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|description
argument_list|)
decl_stmt|;
name|_gimp_param_spec_to_gp_param_def
argument_list|(
name|pspec
argument_list|,
operator|&
name|proc_install
operator|.
name|params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pspecs
operator|=
name|g_list_prepend
argument_list|(
name|pspecs
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_return_vals
condition|;
name|i
operator|++
control|)
block|{
name|GParamSpec
modifier|*
name|pspec
init|=
name|_gimp_gp_compat_param_spec
argument_list|(
name|return_vals
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|return_vals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|return_vals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|return_vals
index|[
name|i
index|]
operator|.
name|description
argument_list|)
decl_stmt|;
name|_gimp_param_spec_to_gp_param_def
argument_list|(
name|pspec
argument_list|,
operator|&
name|proc_install
operator|.
name|return_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pspecs
operator|=
name|g_list_prepend
argument_list|(
name|pspecs
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gp_proc_install_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_install
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|g_list_foreach
argument_list|(
name|pspecs
argument_list|,
operator|(
name|GFunc
operator|)
name|g_param_spec_ref_sink
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_list_free_full
argument_list|(
name|pspecs
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_param_spec_unref
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|proc_install
operator|.
name|params
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|proc_install
operator|.
name|return_vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_read_expect_msg (GimpWireMessage * msg,gint type)
name|_gimp_legacy_read_expect_msg
parameter_list|(
name|GimpWireMessage
modifier|*
name|msg
parameter_list|,
name|gint
name|type
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|gimp_wire_read_msg
argument_list|(
name|_gimp_readchannel
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|type
operator|==
name|type
condition|)
return|return;
comment|/* up to the caller to call wire_destroy() */
if|if
condition|(
name|msg
operator|->
name|type
operator|==
name|GP_TEMP_PROC_RUN
operator|||
name|msg
operator|->
name|type
operator|==
name|GP_QUIT
condition|)
block|{
name|gimp_process_message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_error
argument_list|(
literal|"unexpected message: %d"
argument_list|,
name|msg
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|gimp_wire_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GimpValueArray
modifier|*
DECL|function|gimp_run_procedure_array (const gchar * name,const GimpValueArray * arguments)
name|gimp_run_procedure_array
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|arguments
parameter_list|)
block|{
name|GPProcRun
name|proc_run
decl_stmt|;
name|GPProcReturn
modifier|*
name|proc_return
decl_stmt|;
name|GimpWireMessage
name|msg
decl_stmt|;
name|GimpValueArray
modifier|*
name|return_values
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|arguments
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|proc_run
operator|.
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
name|proc_run
operator|.
name|nparams
operator|=
name|gimp_value_array_length
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|proc_run
operator|.
name|params
operator|=
name|_gimp_value_array_to_gp_params
argument_list|(
name|arguments
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_proc_run_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_run
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|_gimp_legacy_read_expect_msg
argument_list|(
operator|&
name|msg
argument_list|,
name|GP_PROC_RETURN
argument_list|)
expr_stmt|;
name|proc_return
operator|=
name|msg
operator|.
name|data
expr_stmt|;
name|return_values
operator|=
name|_gimp_gp_params_to_value_array
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|proc_return
operator|->
name|params
argument_list|,
name|proc_return
operator|->
name|nparams
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|gimp_set_pdb_error
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_get_pdb_error:  *  * Retrieves the error message from the last procedure call.  *  * If a procedure call fails, then it might pass an error message with  * the return values. Plug-ins that are using the libgimp C wrappers  * don't access the procedure return values directly. Thus libgimp  * stores the error message and makes it available with this  * function. The next procedure call unsets the error message again.  *  * The returned string is owned by libgimp and must not be freed or  * modified.  *  * Returns: the error message  *  * Since: 2.6  **/
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_get_pdb_error (void)
name|gimp_get_pdb_error
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdb_error_message
operator|&&
name|strlen
argument_list|(
name|pdb_error_message
argument_list|)
condition|)
return|return
name|pdb_error_message
return|;
switch|switch
condition|(
name|pdb_error_status
condition|)
block|{
case|case
name|GIMP_PDB_SUCCESS
case|:
comment|/*  procedure executed successfully  */
return|return
name|_
argument_list|(
literal|"success"
argument_list|)
return|;
case|case
name|GIMP_PDB_EXECUTION_ERROR
case|:
comment|/*  procedure execution failed       */
return|return
name|_
argument_list|(
literal|"execution error"
argument_list|)
return|;
case|case
name|GIMP_PDB_CALLING_ERROR
case|:
comment|/*  procedure called incorrectly     */
return|return
name|_
argument_list|(
literal|"calling error"
argument_list|)
return|;
case|case
name|GIMP_PDB_CANCEL
case|:
comment|/*  procedure execution cancelled    */
return|return
name|_
argument_list|(
literal|"cancelled"
argument_list|)
return|;
default|default:
return|return
literal|"invalid return status"
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_initialize (const GimpPlugInInfo * info,GIOChannel * read_channel,GIOChannel * write_channel)
name|_gimp_legacy_initialize
parameter_list|(
specifier|const
name|GimpPlugInInfo
modifier|*
name|info
parameter_list|,
name|GIOChannel
modifier|*
name|read_channel
parameter_list|,
name|GIOChannel
modifier|*
name|write_channel
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|PLUG_IN_INFO
operator|=
operator|*
name|info
expr_stmt|;
name|_gimp_readchannel
operator|=
name|read_channel
expr_stmt|;
name|_gimp_writechannel
operator|=
name|write_channel
expr_stmt|;
name|gp_init
argument_list|()
expr_stmt|;
name|gimp_wire_set_writer
argument_list|(
name|gimp_write
argument_list|)
expr_stmt|;
name|gimp_wire_set_flusher
argument_list|(
name|gimp_flush
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_query (void)
name|_gimp_legacy_query
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|init_proc
condition|)
name|gp_has_init_write
argument_list|(
name|_gimp_writechannel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|query_proc
condition|)
name|PLUG_IN_INFO
operator|.
name|query_proc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_init (void)
name|_gimp_legacy_init
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|init_proc
condition|)
name|PLUG_IN_INFO
operator|.
name|init_proc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_run (void)
name|_gimp_legacy_run
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|g_io_add_watch
argument_list|(
name|_gimp_readchannel
argument_list|,
name|G_IO_ERR
operator||
name|G_IO_HUP
argument_list|,
name|gimp_plugin_io_error_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_loop
argument_list|(
name|PLUG_IN_INFO
operator|.
name|run_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_quit (void)
name|_gimp_legacy_quit
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|quit_proc
condition|)
name|PLUG_IN_INFO
operator|.
name|quit_proc
argument_list|()
expr_stmt|;
name|_gimp_shm_close
argument_list|()
expr_stmt|;
name|gp_quit_write
argument_list|(
name|_gimp_writechannel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  cruft from other places  */
end_comment

begin_comment
comment|/**  * gimp_plugin_menu_register:  * @procedure_name: The procedure for which to install the menu path.  * @menu_path: The procedure's additional menu path.  *  * Register an additional menu path for a plug-in procedure.  *  * This procedure installs an additional menu entry for the given  * procedure.  *  * Returns: TRUE on success.  *  * Since: 2.2  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_menu_register (const gchar * procedure_name,const gchar * menu_path)
name|gimp_plugin_menu_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|menu_path
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_menu_register
argument_list|(
name|procedure_name
argument_list|,
name|menu_path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_icon_register:  * @procedure_name: The procedure for which to install the icon.  * @icon_type: The type of the icon.  * @icon_data: The procedure's icon. The format depends on @icon_type.  *  * Register an icon for a plug-in procedure.  *  * This procedure installs an icon for the given procedure.  *  * Returns: TRUE on success.  *  * Since: 2.2  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_icon_register (const gchar * procedure_name,GimpIconType icon_type,gconstpointer icon_data)
name|gimp_plugin_icon_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
name|GimpIconType
name|icon_type
parameter_list|,
name|gconstpointer
name|icon_data
parameter_list|)
block|{
name|guint8
modifier|*
name|data
decl_stmt|;
name|gsize
name|data_length
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|procedure_name
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|icon_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|icon_type
condition|)
block|{
case|case
name|GIMP_ICON_TYPE_ICON_NAME
case|:
name|data
operator|=
operator|(
name|guint8
operator|*
operator|)
name|icon_data
expr_stmt|;
name|data_length
operator|=
name|strlen
argument_list|(
name|icon_data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|GIMP_ICON_TYPE_PIXBUF
case|:
if|if
condition|(
operator|!
name|gdk_pixbuf_save_to_buffer
argument_list|(
operator|(
name|GdkPixbuf
operator|*
operator|)
name|icon_data
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|,
operator|&
name|data_length
argument_list|,
literal|"png"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|GIMP_ICON_TYPE_IMAGE_FILE
case|:
name|data
operator|=
operator|(
name|guint8
operator|*
operator|)
name|g_file_get_uri
argument_list|(
operator|(
name|GFile
operator|*
operator|)
name|icon_data
argument_list|)
expr_stmt|;
name|data_length
operator|=
name|strlen
argument_list|(
name|icon_data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|g_return_val_if_reached
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|_gimp_plugin_icon_register
argument_list|(
name|procedure_name
argument_list|,
name|icon_type
argument_list|,
name|data_length
argument_list|,
name|data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|icon_type
condition|)
block|{
case|case
name|GIMP_ICON_TYPE_ICON_NAME
case|:
break|break;
case|case
name|GIMP_ICON_TYPE_PIXBUF
case|:
case|case
name|GIMP_ICON_TYPE_IMAGE_FILE
case|:
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_magic_load_handler:  * @procedure_name: The name of the procedure to be used for loading.  * @extensions: comma separated list of extensions this handler can load (i.e. "jpg,jpeg").  * @prefixes: comma separated list of prefixes this handler can load (i.e. "http:,ftp:").  * @magics: comma separated list of magic file information this handler can load (i.e. "0,string,GIF").  *  * Registers a file load handler procedure.  *  * Registers a procedural database procedure to be called to load files  * of a particular file format using magic file information.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_magic_load_handler (const gchar * procedure_name,const gchar * extensions,const gchar * prefixes,const gchar * magics)
name|gimp_register_magic_load_handler
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|extensions
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefixes
parameter_list|,
specifier|const
name|gchar
modifier|*
name|magics
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_magic_load_handler
argument_list|(
name|procedure_name
argument_list|,
name|extensions
argument_list|,
name|prefixes
argument_list|,
name|magics
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_load_handler:  * @procedure_name: The name of the procedure to be used for loading.  * @extensions: comma separated list of extensions this handler can load (i.e. "jpg,jpeg").  * @prefixes: comma separated list of prefixes this handler can load (i.e. "http:,ftp:").  *  * Registers a file load handler procedure.  *  * Registers a procedural database procedure to be called to load files  * of a particular file format.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_load_handler (const gchar * procedure_name,const gchar * extensions,const gchar * prefixes)
name|gimp_register_load_handler
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|extensions
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefixes
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_load_handler
argument_list|(
name|procedure_name
argument_list|,
name|extensions
argument_list|,
name|prefixes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_save_handler:  * @procedure_name: The name of the procedure to be used for saving.  * @extensions: comma separated list of extensions this handler can save (i.e. "jpg,jpeg").  * @prefixes: comma separated list of prefixes this handler can save (i.e. "http:,ftp:").  *  * Registers a file save handler procedure.  *  * Registers a procedural database procedure to be called to save files  * in a particular file format.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_save_handler (const gchar * procedure_name,const gchar * extensions,const gchar * prefixes)
name|gimp_register_save_handler
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|extensions
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefixes
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_save_handler
argument_list|(
name|procedure_name
argument_list|,
name|extensions
argument_list|,
name|prefixes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_file_handler_priority:  * @procedure_name: The name of the procedure to set the priority of.  * @priority: The procedure priority.  *  * Sets the priority of a file handler procedure.  *  * Sets the priority of a file handler procedure. When more than one  * procedure matches a given file, the procedure with the lowest  * priority is used; if more than one procedure has the lowest  * priority, it is unspecified which one of them is used. The default  * priority for file handler procedures is 0.  *  * Returns: TRUE on success.  *  * Since: 2.10.6  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_file_handler_priority (const gchar * procedure_name,gint priority)
name|gimp_register_file_handler_priority
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
name|gint
name|priority
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_file_handler_priority
argument_list|(
name|procedure_name
argument_list|,
name|priority
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_file_handler_mime:  * @procedure_name: The name of the procedure to associate a MIME type with.  * @mime_types: A comma-separated list of MIME types, such as \"image/jpeg\".  *  * Associates MIME types with a file handler procedure.  *  * Registers MIME types for a file handler procedure. This allows GIMP  * to determine the MIME type of the file opened or saved using this  * procedure. It is recommended that only one MIME type is registered  * per file procedure; when registering more than one MIME type, GIMP  * will associate the first one with files opened or saved with this  * procedure.  *  * Returns: TRUE on success.  *  * Since: 2.2  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_file_handler_mime (const gchar * procedure_name,const gchar * mime_types)
name|gimp_register_file_handler_mime
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|mime_types
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_file_handler_mime
argument_list|(
name|procedure_name
argument_list|,
name|mime_types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_file_handler_uri:  * @procedure_name: The name of the procedure to enable URIs for.  *  * Registers a file handler procedure as capable of handling URIs.  *  * Registers a file handler procedure as capable of handling URIs. This  * allows GIMP to call the procedure directly for all kinds of URIs,  * and the 'filename' traditionally passed to file procedures turns  * into an URI.  *  * Returns: TRUE on success.  *  * Since: 2.10  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_file_handler_uri (const gchar * procedure_name)
name|gimp_register_file_handler_uri
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_file_handler_uri
argument_list|(
name|procedure_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_register_thumbnail_loader:  * @load_proc: The name of the procedure the thumbnail loader with.  * @thumb_proc: The name of the thumbnail load procedure.  *  * Associates a thumbnail loader with a file load procedure.  *  * Some file formats allow for embedded thumbnails, other file formats  * contain a scalable image or provide the image data in different  * resolutions. A file plug-in for such a format may register a special  * procedure that allows GIMP to load a thumbnail preview of the image.  * This procedure is then associated with the standard load procedure  * using this function.  *  * Returns: TRUE on success.  *  * Since: 2.2  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_register_thumbnail_loader (const gchar * load_proc,const gchar * thumb_proc)
name|gimp_register_thumbnail_loader
parameter_list|(
specifier|const
name|gchar
modifier|*
name|load_proc
parameter_list|,
specifier|const
name|gchar
modifier|*
name|thumb_proc
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_register_thumbnail_loader
argument_list|(
name|load_proc
argument_list|,
name|thumb_proc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_loop (GimpRunProc run_proc)
name|gimp_loop
parameter_list|(
name|GimpRunProc
name|run_proc
parameter_list|)
block|{
name|GimpWireMessage
name|msg
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|gimp_wire_read_msg
argument_list|(
name|_gimp_readchannel
argument_list|,
operator|&
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|msg
operator|.
name|type
condition|)
block|{
case|case
name|GP_QUIT
case|:
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
case|case
name|GP_CONFIG
case|:
name|_gimp_config
argument_list|(
name|msg
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TILE_REQ
case|:
case|case
name|GP_TILE_ACK
case|:
case|case
name|GP_TILE_DATA
case|:
name|g_warning
argument_list|(
literal|"unexpected tile message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RUN
case|:
name|gimp_proc_run
argument_list|(
name|msg
operator|.
name|data
argument_list|,
name|run_proc
argument_list|)
expr_stmt|;
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
case|case
name|GP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc return message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RUN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc run message received (should not happen"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc return message received (should not happen"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_INSTALL
case|:
name|g_warning
argument_list|(
literal|"unexpected proc install message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_HAS_INIT
case|:
name|g_warning
argument_list|(
literal|"unexpected has init message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_process_message (GimpWireMessage * msg)
name|gimp_process_message
parameter_list|(
name|GimpWireMessage
modifier|*
name|msg
parameter_list|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|GP_QUIT
case|:
name|gimp_quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|GP_CONFIG
case|:
name|_gimp_config
argument_list|(
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TILE_REQ
case|:
case|case
name|GP_TILE_ACK
case|:
case|case
name|GP_TILE_DATA
case|:
name|g_warning
argument_list|(
literal|"unexpected tile message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RUN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc run message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc return message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RUN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc run message received (support removed)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc return message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_INSTALL
case|:
name|g_warning
argument_list|(
literal|"unexpected proc install message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_HAS_INIT
case|:
name|g_warning
argument_list|(
literal|"unexpected has init message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_proc_run (GPProcRun * proc_run,GimpRunProc run_proc)
name|gimp_proc_run
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|)
block|{
name|GPProcReturn
name|proc_return
decl_stmt|;
name|GimpValueArray
modifier|*
name|arguments
decl_stmt|;
name|GimpValueArray
modifier|*
name|return_values
init|=
name|NULL
decl_stmt|;
name|GimpParam
modifier|*
name|params
decl_stmt|;
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|n_params
decl_stmt|;
name|gint
name|n_return_vals
decl_stmt|;
name|arguments
operator|=
name|_gimp_gp_params_to_value_array
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|proc_run
operator|->
name|params
argument_list|,
name|proc_run
operator|->
name|nparams
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|n_params
operator|=
name|gimp_value_array_length
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|params
operator|=
name|_gimp_value_array_to_params
argument_list|(
name|arguments
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|run_proc
argument_list|(
name|proc_run
operator|->
name|name
argument_list|,
name|n_params
argument_list|,
name|params
argument_list|,
operator|&
name|n_return_vals
argument_list|,
operator|&
name|return_vals
argument_list|)
expr_stmt|;
name|return_values
operator|=
name|_gimp_params_to_value_array
argument_list|(
name|return_vals
argument_list|,
name|n_return_vals
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|gimp_value_array_unref
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|proc_return
operator|.
name|name
operator|=
name|proc_run
operator|->
name|name
expr_stmt|;
name|proc_return
operator|.
name|nparams
operator|=
name|gimp_value_array_length
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
name|proc_return
operator|.
name|params
operator|=
name|_gimp_value_array_to_gp_params
argument_list|(
name|return_values
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_value_array_unref
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_proc_return_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_return
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_plugin_io_error_handler (GIOChannel * channel,GIOCondition cond,gpointer data)
name|gimp_plugin_io_error_handler
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|GIOCondition
name|cond
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|g_printerr
argument_list|(
literal|"%s: fatal error: GIMP crashed\n"
argument_list|,
name|gimp_get_progname
argument_list|()
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
comment|/* never reached */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_write (GIOChannel * channel,const guint8 * buf,gulong count,gpointer user_data)
name|gimp_write
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|guint8
modifier|*
name|buf
parameter_list|,
name|gulong
name|count
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|gulong
name|bytes
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|write_buffer_index
operator|+
name|count
operator|)
operator|>=
name|WRITE_BUFFER_SIZE
condition|)
block|{
name|bytes
operator|=
name|WRITE_BUFFER_SIZE
operator|-
name|write_buffer_index
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|write_buffer
index|[
name|write_buffer_index
index|]
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|write_buffer_index
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_wire_flush
argument_list|(
name|channel
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|bytes
operator|=
name|count
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|write_buffer
index|[
name|write_buffer_index
index|]
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|write_buffer_index
operator|+=
name|bytes
expr_stmt|;
block|}
name|buf
operator|+=
name|bytes
expr_stmt|;
name|count
operator|-=
name|bytes
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_flush (GIOChannel * channel,gpointer user_data)
name|gimp_flush
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|GIOStatus
name|status
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|gsize
name|count
decl_stmt|;
name|gsize
name|bytes
decl_stmt|;
if|if
condition|(
name|write_buffer_index
operator|>
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|!=
name|write_buffer_index
condition|)
block|{
do|do
block|{
name|bytes
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|g_io_channel_write_chars
argument_list|(
name|channel
argument_list|,
operator|&
name|write_buffer
index|[
name|count
index|]
argument_list|,
operator|(
name|write_buffer_index
operator|-
name|count
operator|)
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|status
operator|==
name|G_IO_STATUS_AGAIN
condition|)
do|;
if|if
condition|(
name|status
operator|!=
name|G_IO_STATUS_NORMAL
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: gimp_flush(): error: %s"
argument_list|,
name|g_get_prgname
argument_list|()
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_error_free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"%s: gimp_flush(): error"
argument_list|,
name|g_get_prgname
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|count
operator|+=
name|bytes
expr_stmt|;
block|}
name|write_buffer_index
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_set_pdb_error (GimpValueArray * return_values)
name|gimp_set_pdb_error
parameter_list|(
name|GimpValueArray
modifier|*
name|return_values
parameter_list|)
block|{
name|g_clear_pointer
argument_list|(
operator|&
name|pdb_error_message
argument_list|,
name|g_free
argument_list|)
expr_stmt|;
name|pdb_error_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
if|if
condition|(
name|gimp_value_array_length
argument_list|(
name|return_values
argument_list|)
operator|>
literal|0
condition|)
block|{
name|pdb_error_status
operator|=
name|g_value_get_enum
argument_list|(
name|gimp_value_array_index
argument_list|(
name|return_values
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pdb_error_status
condition|)
block|{
case|case
name|GIMP_PDB_SUCCESS
case|:
case|case
name|GIMP_PDB_PASS_THROUGH
case|:
break|break;
case|case
name|GIMP_PDB_EXECUTION_ERROR
case|:
case|case
name|GIMP_PDB_CALLING_ERROR
case|:
case|case
name|GIMP_PDB_CANCEL
case|:
if|if
condition|(
name|gimp_value_array_length
argument_list|(
name|return_values
argument_list|)
operator|>
literal|1
condition|)
block|{
name|GValue
modifier|*
name|value
init|=
name|gimp_value_array_index
argument_list|(
name|return_values
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|G_VALUE_HOLDS_STRING
argument_list|(
name|value
argument_list|)
condition|)
name|pdb_error_message
operator|=
name|g_value_dup_string
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

end_unit

