begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LIBGIMP - The GIMP Library  * Copyright (C) 1995-1997 Peter Mattis and Spencer Kimball  *  * gimplegacy.c  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Library General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<https://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpprotocol.h"
end_include

begin_include
include|#
directive|include
file|"libgimpbase/gimpwire.h"
end_include

begin_include
include|#
directive|include
file|"gimp-shm.h"
end_include

begin_include
include|#
directive|include
file|"gimp-private.h"
end_include

begin_include
include|#
directive|include
file|"gimpgpcompat.h"
end_include

begin_include
include|#
directive|include
file|"gimpgpparams.h"
end_include

begin_include
include|#
directive|include
file|"gimppdb_pdb.h"
end_include

begin_include
include|#
directive|include
file|"gimpplugin_pdb.h"
end_include

begin_include
include|#
directive|include
file|"gimplegacy-private.h"
end_include

begin_comment
comment|/**  * SECTION: gimplegacy  * @title: GimpLegacy  * @short_description: Main functions needed for building a GIMP plug-in.  *                     This is the old legacy API, please use GimpPlugIn  *                     and GimpProcedure for all new plug-ins.  *  * Main functions needed for building a GIMP plug-in. Compat cruft.  **/
end_comment

begin_define
DECL|macro|WRITE_BUFFER_SIZE
define|#
directive|define
name|WRITE_BUFFER_SIZE
value|1024
end_define

begin_define
DECL|macro|ASSERT_NO_PLUG_IN_EXISTS (strfunc)
define|#
directive|define
name|ASSERT_NO_PLUG_IN_EXISTS
parameter_list|(
name|strfunc
parameter_list|)
define|\
value|if (gimp_get_plug_in ())                                              \     {                                                                   \       g_printerr ("%s ERROR: %s() cannot be called when using the "     \                   "new plug-in API\n",                                  \                   g_get_prgname (), strfunc);                           \       gimp_quit ();                                                     \     }
end_define

begin_function_decl
specifier|static
name|void
name|gimp_loop
parameter_list|(
name|GimpRunProc
name|run_proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_process_message
parameter_list|(
name|GimpWireMessage
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_single_message
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_extension_read
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|GIOCondition
name|condition
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_proc_run
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_temp_proc_run
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gimp_proc_run_internal
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|,
name|GPProcReturn
modifier|*
name|proc_return
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_plugin_io_error_handler
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|GIOCondition
name|cond
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_write
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|guint8
modifier|*
name|buf
parameter_list|,
name|gulong
name|count
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|gimp_flush
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|_gimp_readchannel
name|GIOChannel
modifier|*
name|_gimp_readchannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|_gimp_writechannel
name|GIOChannel
modifier|*
name|_gimp_writechannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|write_buffer
specifier|static
name|gchar
name|write_buffer
index|[
name|WRITE_BUFFER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|write_buffer_index
specifier|static
name|gulong
name|write_buffer_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|static
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimp_temp_proc_ht
specifier|static
name|GHashTable
modifier|*
name|gimp_temp_proc_ht
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * gimp_main_legacy:  * @info: the #GimpPlugInInfo structure  * @argc: the number of arguments  * @argv: (array length=argc): the arguments  *  * The main procedure that must be called with the #GimpPlugInInfo  * structure and the 'argc' and 'argv' that are passed to "main".  *  * Returns: an exit status as defined by the C library,  *          on success EXIT_SUCCESS.  **/
end_comment

begin_function
name|gint
DECL|function|gimp_main_legacy (const GimpPlugInInfo * info,gint argc,gchar * argv[])
name|gimp_main_legacy
parameter_list|(
specifier|const
name|GimpPlugInInfo
modifier|*
name|info
parameter_list|,
name|gint
name|argc
parameter_list|,
name|gchar
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|_gimp_main_internal
argument_list|(
name|G_TYPE_NONE
argument_list|,
name|info
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_install_procedure:  * @name:                                      the procedure's name.  * @blurb:                                     a short text describing what the procedure does.  * @help:                                      the help text for the procedure (usually considerably  *                                             longer than @blurb).  * @author:                                    the procedure's author(s).  * @copyright:                                 the procedure's copyright.  * @date:                                      the date the procedure was added.  * @menu_label:                                the label to use for the procedure's menu entry,  *                                             or %NULL if the procedure has no menu entry.  * @image_types:                               the drawable types the procedure can handle.  * @type:                                      the type of the procedure.  * @n_params:                                  the number of parameters the procedure takes.  * @n_return_vals:                             the number of return values the procedure returns.  * @params: (array length=n_params):           the procedure's parameters.  * @return_vals: (array length=n_return_vals): the procedure's return values.  *  * Installs a new procedure with the PDB (procedural database).  *  * Call this function from within your plug-in's query() function for  * each procedure your plug-in implements.  *  * The @name parameter is mandatory and should be unique, or it will  * overwrite an already existing procedure (overwrite procedures only  * if you know what you're doing).  *  * The @blurb, @help, @author, @copyright and @date parameters are  * optional but then you shouldn't write procedures without proper  * documentation, should you.  *  * @menu_label defines the label that should be used for the  * procedure's menu entry. The position where to register in the menu  * hierarchy is chosen using gimp_plugin_menu_register().  *  * It is possible to register a procedure only for keyboard-shortcut  * activation by passing a @menu_label to gimp_install_procedure() but  * not registering any menu path with gimp_plugin_menu_register(). In  * this case, the given @menu_label will only be used as the  * procedure's user-visible name in the keyboard shortcut editor.  *  * @image_types is a comma separated list of image types, or actually  * drawable types, that this procedure can deal with. Wildcards are  * possible here, so you could say "RGB*" instead of "RGB, RGBA" or  * "*" for all image types. If the procedure doesn't need an image to  * run, use the empty string.  *  * @type must be one of %GIMP_PLUGIN or %GIMP_EXTENSION. Note that  * temporary procedures must be installed using  * gimp_install_temp_proc().  *  * NOTE: Unlike the GIMP 1.2 API, %GIMP_EXTENSION no longer means  * that the procedure's menu prefix is&lt;Toolbox&gt;, but that  * it will install temporary procedures. Therefore, the GIMP core  * will wait until the %GIMP_EXTENSION procedure has called  * gimp_extension_ack(), which means that the procedure has done  * its initialization, installed its temporary procedures and is  * ready to run.  *  *<emphasis>Not calling gimp_extension_ack() from a %GIMP_EXTENSION  * procedure will cause the GIMP core to lock up.</emphasis>  *  * Additionally, a %GIMP_EXTENSION procedure with no parameters  * (@n_params == 0 and @params == %NULL) is an "automatic" extension  * that will be automatically started on each GIMP startup.  **/
end_comment

begin_function
name|void
DECL|function|gimp_install_procedure (const gchar * name,const gchar * blurb,const gchar * help,const gchar * author,const gchar * copyright,const gchar * date,const gchar * menu_label,const gchar * image_types,GimpPDBProcType type,gint n_params,gint n_return_vals,const GimpParamDef * params,const GimpParamDef * return_vals)
name|gimp_install_procedure
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|blurb
parameter_list|,
specifier|const
name|gchar
modifier|*
name|help
parameter_list|,
specifier|const
name|gchar
modifier|*
name|author
parameter_list|,
specifier|const
name|gchar
modifier|*
name|copyright
parameter_list|,
specifier|const
name|gchar
modifier|*
name|date
parameter_list|,
specifier|const
name|gchar
modifier|*
name|menu_label
parameter_list|,
specifier|const
name|gchar
modifier|*
name|image_types
parameter_list|,
name|GimpPDBProcType
name|type
parameter_list|,
name|gint
name|n_params
parameter_list|,
name|gint
name|n_return_vals
parameter_list|,
specifier|const
name|GimpParamDef
modifier|*
name|params
parameter_list|,
specifier|const
name|GimpParamDef
modifier|*
name|return_vals
parameter_list|)
block|{
name|GPProcInstall
name|proc_install
decl_stmt|;
name|GList
modifier|*
name|pspecs
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|type
operator|!=
name|GIMP_INTERNAL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|n_params
operator|==
literal|0
operator|&&
name|params
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n_params
operator|>
literal|0
operator|&&
name|params
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|n_return_vals
operator|==
literal|0
operator|&&
name|return_vals
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n_return_vals
operator|>
literal|0
operator|&&
name|return_vals
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|proc_install
operator|.
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
name|proc_install
operator|.
name|blurb
operator|=
operator|(
name|gchar
operator|*
operator|)
name|blurb
expr_stmt|;
name|proc_install
operator|.
name|help
operator|=
operator|(
name|gchar
operator|*
operator|)
name|help
expr_stmt|;
name|proc_install
operator|.
name|help_id
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
name|proc_install
operator|.
name|authors
operator|=
operator|(
name|gchar
operator|*
operator|)
name|author
expr_stmt|;
name|proc_install
operator|.
name|copyright
operator|=
operator|(
name|gchar
operator|*
operator|)
name|copyright
expr_stmt|;
name|proc_install
operator|.
name|date
operator|=
operator|(
name|gchar
operator|*
operator|)
name|date
expr_stmt|;
name|proc_install
operator|.
name|menu_label
operator|=
operator|(
name|gchar
operator|*
operator|)
name|menu_label
expr_stmt|;
name|proc_install
operator|.
name|image_types
operator|=
operator|(
name|gchar
operator|*
operator|)
name|image_types
expr_stmt|;
name|proc_install
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|proc_install
operator|.
name|nparams
operator|=
name|n_params
expr_stmt|;
name|proc_install
operator|.
name|nreturn_vals
operator|=
name|n_return_vals
expr_stmt|;
name|proc_install
operator|.
name|params
operator|=
name|g_new0
argument_list|(
name|GPParamDef
argument_list|,
name|n_params
argument_list|)
expr_stmt|;
name|proc_install
operator|.
name|return_vals
operator|=
name|g_new0
argument_list|(
name|GPParamDef
argument_list|,
name|n_return_vals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_params
condition|;
name|i
operator|++
control|)
block|{
name|GParamSpec
modifier|*
name|pspec
init|=
name|_gimp_gp_compat_param_spec
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|description
argument_list|)
decl_stmt|;
name|_gimp_param_spec_to_gp_param_def
argument_list|(
name|pspec
argument_list|,
operator|&
name|proc_install
operator|.
name|params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pspecs
operator|=
name|g_list_prepend
argument_list|(
name|pspecs
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_return_vals
condition|;
name|i
operator|++
control|)
block|{
name|GParamSpec
modifier|*
name|pspec
init|=
name|_gimp_gp_compat_param_spec
argument_list|(
name|return_vals
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|return_vals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|return_vals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|return_vals
index|[
name|i
index|]
operator|.
name|description
argument_list|)
decl_stmt|;
name|_gimp_param_spec_to_gp_param_def
argument_list|(
name|pspec
argument_list|,
operator|&
name|proc_install
operator|.
name|return_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pspecs
operator|=
name|g_list_prepend
argument_list|(
name|pspecs
argument_list|,
name|pspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gp_proc_install_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_install
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|g_list_foreach
argument_list|(
name|pspecs
argument_list|,
operator|(
name|GFunc
operator|)
name|g_param_spec_ref_sink
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_list_free_full
argument_list|(
name|pspecs
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|g_param_spec_unref
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|proc_install
operator|.
name|params
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|proc_install
operator|.
name|return_vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_install_temp_proc:  * @name:          the procedure's name.  * @blurb:         a short text describing what the procedure does.  * @help:          the help text for the procedure (usually considerably  *                 longer than @blurb).  * @author:        the procedure's author(s).  * @copyright:     the procedure's copyright.  * @date:          the date the procedure was added.  * @menu_label:    the procedure's menu label, or %NULL if the procedure has  *                 no menu entry.  * @image_types:   the drawable types the procedure can handle.  * @type:          the type of the procedure.  * @n_params:      the number of parameters the procedure takes.  * @n_return_vals: the number of return values the procedure returns.  * @params: (array length=n_params):  *                 the procedure's parameters.  * @return_vals: (array length=n_return_vals):  *                 the procedure's return values.  * @run_proc: (closure) (scope async):  *                 the function to call for executing the procedure.  *  * Installs a new temporary procedure with the PDB (procedural database).  *  * A temporary procedure is a procedure which is only available while  * one of your plug-in's "real" procedures is running.  *  * See gimp_install_procedure() for most details.  *  * @type<emphasis>must</emphasis> be %GIMP_TEMPORARY or the function  * will fail.  *  * @run_proc is the function which will be called to execute the  * procedure.  *  * NOTE: Normally, plug-in communication is triggered by the plug-in  * and the GIMP core only responds to the plug-in's requests. You must  * explicitly enable receiving of temporary procedure run requests  * using either gimp_extension_enable() or  * gimp_extension_process(). See this functions' documentation for  * details.  **/
end_comment

begin_function
name|void
DECL|function|gimp_install_temp_proc (const gchar * name,const gchar * blurb,const gchar * help,const gchar * author,const gchar * copyright,const gchar * date,const gchar * menu_label,const gchar * image_types,GimpPDBProcType type,gint n_params,gint n_return_vals,const GimpParamDef * params,const GimpParamDef * return_vals,GimpRunProc run_proc)
name|gimp_install_temp_proc
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|blurb
parameter_list|,
specifier|const
name|gchar
modifier|*
name|help
parameter_list|,
specifier|const
name|gchar
modifier|*
name|author
parameter_list|,
specifier|const
name|gchar
modifier|*
name|copyright
parameter_list|,
specifier|const
name|gchar
modifier|*
name|date
parameter_list|,
specifier|const
name|gchar
modifier|*
name|menu_label
parameter_list|,
specifier|const
name|gchar
modifier|*
name|image_types
parameter_list|,
name|GimpPDBProcType
name|type
parameter_list|,
name|gint
name|n_params
parameter_list|,
name|gint
name|n_return_vals
parameter_list|,
specifier|const
name|GimpParamDef
modifier|*
name|params
parameter_list|,
specifier|const
name|GimpParamDef
modifier|*
name|return_vals
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|n_params
operator|==
literal|0
operator|&&
name|params
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n_params
operator|>
literal|0
operator|&&
name|params
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
operator|(
name|n_return_vals
operator|==
literal|0
operator|&&
name|return_vals
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n_return_vals
operator|>
literal|0
operator|&&
name|return_vals
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|type
operator|==
name|GIMP_TEMPORARY
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|run_proc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|name
argument_list|,
name|blurb
argument_list|,
name|help
argument_list|,
name|author
argument_list|,
name|copyright
argument_list|,
name|date
argument_list|,
name|menu_label
argument_list|,
name|image_types
argument_list|,
name|type
argument_list|,
name|n_params
argument_list|,
name|n_return_vals
argument_list|,
name|params
argument_list|,
name|return_vals
argument_list|)
expr_stmt|;
comment|/*  Insert the temp proc run function into the hash table  */
name|g_hash_table_insert
argument_list|(
name|gimp_temp_proc_ht
argument_list|,
name|g_strdup
argument_list|(
name|name
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|run_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_uninstall_temp_proc:  * @name: the procedure's name  *  * Uninstalls a temporary procedure which has previously been  * installed using gimp_install_temp_proc().  **/
end_comment

begin_function
name|void
DECL|function|gimp_uninstall_temp_proc (const gchar * name)
name|gimp_uninstall_temp_proc
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GPProcUninstall
name|proc_uninstall
decl_stmt|;
name|gpointer
name|hash_name
decl_stmt|;
name|gboolean
name|found
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|proc_uninstall
operator|.
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|gp_proc_uninstall_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_uninstall
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|found
operator|=
name|g_hash_table_lookup_extended
argument_list|(
name|gimp_temp_proc_ht
argument_list|,
name|name
argument_list|,
operator|&
name|hash_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|g_hash_table_remove
argument_list|(
name|gimp_temp_proc_ht
argument_list|,
operator|(
name|gpointer
operator|)
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|hash_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_extension_ack:  *  * Notify the main GIMP application that the extension has been properly  * initialized and is ready to run.  *  * This function<emphasis>must</emphasis> be called from every  * procedure that was registered as #GIMP_EXTENSION.  *  * Subsequently, extensions can process temporary procedure run  * requests using either gimp_extension_enable() or  * gimp_extension_process().  *  * See also: gimp_install_procedure(), gimp_install_temp_proc()  **/
end_comment

begin_function
name|void
DECL|function|gimp_extension_ack (void)
name|gimp_extension_ack
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_extension_ack_write
argument_list|(
name|_gimp_writechannel
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_extension_enable:  *  * Enables asynchronous processing of messages from the main GIMP  * application.  *  * Normally, a plug-in is not called by GIMP except for the call to  * the procedure it implements. All subsequent communication is  * triggered by the plug-in and all messages sent from GIMP to the  * plug-in are just answers to requests the plug-in made.  *  * If the plug-in however registered temporary procedures using  * gimp_install_temp_proc(), it needs to be able to receive requests  * to execute them. Usually this will be done by running  * gimp_extension_process() in an endless loop.  *  * If the plug-in cannot use gimp_extension_process(), i.e. if it has  * a GUI and is hanging around in a #GMainLoop, it must call  * gimp_extension_enable().  *  * Note that the plug-in does not need to be a #GIMP_EXTENSION to  * register temporary procedures.  *  * See also: gimp_install_procedure(), gimp_install_temp_proc()  **/
end_comment

begin_function
name|void
DECL|function|gimp_extension_enable (void)
name|gimp_extension_enable
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|gboolean
name|callback_added
init|=
name|FALSE
decl_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callback_added
condition|)
block|{
name|g_io_add_watch
argument_list|(
name|_gimp_readchannel
argument_list|,
name|G_IO_IN
operator||
name|G_IO_PRI
argument_list|,
name|gimp_extension_read
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|callback_added
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_extension_process:  * @timeout: The timeout (in ms) to use for the select() call.  *  * Processes one message sent by GIMP and returns.  *  * Call this function in an endless loop after calling  * gimp_extension_ack() to process requests for running temporary  * procedures.  *  * See gimp_extension_enable() for an asynchronous way of doing the  * same if running an endless loop is not an option.  *  * See also: gimp_install_procedure(), gimp_install_temp_proc()  **/
end_comment

begin_function
name|void
DECL|function|gimp_extension_process (guint timeout)
name|gimp_extension_process
parameter_list|(
name|guint
name|timeout
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|G_OS_WIN32
name|gint
name|select_val
decl_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
do|do
block|{
name|fd_set
name|readfds
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
if|if
condition|(
name|timeout
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|g_io_channel_unix_get_fd
argument_list|(
name|_gimp_readchannel
argument_list|)
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|select_val
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|gimp_single_message
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|select_val
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
literal|"gimp_extension_process"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|select_val
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
else|#
directive|else
comment|/* Zero means infinite wait for us, but g_poll and    * g_io_channel_win32_poll use -1 to indicate    * infinite wait.    */
name|GPollFD
name|pollfd
decl_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
name|g_io_channel_win32_make_pollfd
argument_list|(
name|_gimp_readchannel
argument_list|,
name|G_IO_IN
argument_list|,
operator|&
name|pollfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_io_channel_win32_poll
argument_list|(
operator|&
name|pollfd
argument_list|,
literal|1
argument_list|,
name|timeout
argument_list|)
operator|==
literal|1
condition|)
name|gimp_single_message
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_read_expect_msg (GimpWireMessage * msg,gint type)
name|_gimp_legacy_read_expect_msg
parameter_list|(
name|GimpWireMessage
modifier|*
name|msg
parameter_list|,
name|gint
name|type
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|gimp_wire_read_msg
argument_list|(
name|_gimp_readchannel
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|type
operator|==
name|type
condition|)
return|return;
comment|/* up to the caller to call wire_destroy() */
if|if
condition|(
name|msg
operator|->
name|type
operator|==
name|GP_TEMP_PROC_RUN
operator|||
name|msg
operator|->
name|type
operator|==
name|GP_QUIT
condition|)
block|{
name|gimp_process_message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_error
argument_list|(
literal|"unexpected message: %d"
argument_list|,
name|msg
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|gimp_wire_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * gimp_run_procedure: (skip)  * @name:          the name of the procedure to run  * @n_return_vals: return location for the number of return values  * @...:           list of procedure parameters  *  * This function calls a GIMP procedure and returns its return values.  *  * The procedure's parameters are given by a va_list in the format  * (type, value, type, value) and must be terminated by %GIMP_PDB_END.  *  * This function converts the va_list of parameters into an array and  * passes them to gimp_run_procedure2(). Please look there for further  * information.  *  * Returns: the procedure's return values unless there was an error,  * in which case the zero-th return value will be the error status, and  * the first return value will be a string detailing the error.  **/
end_comment

begin_function
name|GimpParam
modifier|*
DECL|function|gimp_run_procedure (const gchar * name,gint * n_return_vals,...)
name|gimp_run_procedure
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
modifier|*
name|n_return_vals
parameter_list|,
modifier|...
parameter_list|)
block|{
name|GimpPDBArgType
name|param_type
decl_stmt|;
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|GimpParam
modifier|*
name|params
init|=
name|NULL
decl_stmt|;
name|gint
name|n_params
init|=
literal|0
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_return_vals
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|n_return_vals
argument_list|)
expr_stmt|;
name|param_type
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpPDBArgType
argument_list|)
expr_stmt|;
while|while
condition|(
name|param_type
operator|!=
name|GIMP_PDB_END
condition|)
block|{
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|GIMP_PDB_INT32
case|:
case|case
name|GIMP_PDB_DISPLAY
case|:
case|case
name|GIMP_PDB_IMAGE
case|:
case|case
name|GIMP_PDB_ITEM
case|:
case|case
name|GIMP_PDB_LAYER
case|:
case|case
name|GIMP_PDB_CHANNEL
case|:
case|case
name|GIMP_PDB_DRAWABLE
case|:
case|case
name|GIMP_PDB_SELECTION
case|:
case|case
name|GIMP_PDB_VECTORS
case|:
case|case
name|GIMP_PDB_STATUS
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOAT
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gdouble
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_STRING
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gchar
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT32ARRAY
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16ARRAY
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint16
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8ARRAY
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint8
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOATARRAY
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gdouble
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_STRINGARRAY
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gchar
operator|*
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_COLOR
case|:
case|case
name|GIMP_PDB_COLORARRAY
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpRGB
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_PARASITE
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpParasite
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_END
case|:
break|break;
block|}
name|n_params
operator|++
expr_stmt|;
name|param_type
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpPDBArgType
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|params
operator|=
name|g_new0
argument_list|(
name|GimpParam
argument_list|,
name|n_params
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|n_return_vals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_params
condition|;
name|i
operator|++
control|)
block|{
name|params
index|[
name|i
index|]
operator|.
name|type
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpPDBArgType
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|params
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|GIMP_PDB_INT32
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int32
operator|=
operator|(
name|gint32
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int16
operator|=
operator|(
name|gint16
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int8
operator|=
operator|(
name|guint8
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOAT
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_float
operator|=
operator|(
name|gdouble
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|gdouble
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_STRING
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gchar
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT32ARRAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int32array
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16ARRAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int16array
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint16
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8ARRAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int8array
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|guint8
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOATARRAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_floatarray
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gdouble
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_STRINGARRAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_stringarray
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gchar
operator|*
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_COLOR
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_color
operator|=
operator|*
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpRGB
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_ITEM
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_item
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_DISPLAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_display
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_IMAGE
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_LAYER
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_layer
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_CHANNEL
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_channel
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_DRAWABLE
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_drawable
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_SELECTION
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_selection
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_COLORARRAY
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_colorarray
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpRGB
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_VECTORS
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_vectors
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_PARASITE
case|:
block|{
name|GimpParasite
modifier|*
name|parasite
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|GimpParasite
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|parasite
operator|==
name|NULL
condition|)
block|{
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|name
operator|=
name|parasite
operator|->
name|name
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|flags
operator|=
name|parasite
operator|->
name|flags
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|size
operator|=
name|parasite
operator|->
name|size
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|data
operator|=
name|parasite
operator|->
name|data
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GIMP_PDB_STATUS
case|:
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|gint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_END
case|:
break|break;
block|}
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure2
argument_list|(
name|name
argument_list|,
name|n_return_vals
argument_list|,
name|n_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|params
argument_list|)
expr_stmt|;
return|return
name|return_vals
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_run_procedure2: (rename-to gimp_run_procedure)  * @name:          the name of the procedure to run  * @n_return_vals: return location for the number of return values  * @n_params:      the number of parameters the procedure takes.  * @params:        the procedure's parameters array.  *  * This function calls a GIMP procedure and returns its return values.  * To get more information about the available procedures and the  * parameters they expect, please have a look at the Procedure Browser  * as found in the Xtns menu in GIMP's toolbox.  *  * As soon as you don't need the return values any longer, you should  * free them using gimp_destroy_params().  *  * Returns: the procedure's return values unless there was an error,  * in which case the zero-th return value will be the error status, and  * if there are two values returned, the other return value will be a  * string detailing the error.  **/
end_comment

begin_function
name|GimpParam
modifier|*
DECL|function|gimp_run_procedure2 (const gchar * name,gint * n_return_vals,gint n_params,const GimpParam * params)
name|gimp_run_procedure2
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
modifier|*
name|n_return_vals
parameter_list|,
name|gint
name|n_params
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|params
parameter_list|)
block|{
name|GimpValueArray
modifier|*
name|arguments
decl_stmt|;
name|GimpValueArray
modifier|*
name|return_values
decl_stmt|;
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_return_vals
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|arguments
operator|=
name|_gimp_params_to_value_array
argument_list|(
name|params
argument_list|,
name|n_params
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|return_values
operator|=
name|gimp_run_procedure_array
argument_list|(
name|name
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|gimp_value_array_unref
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
operator|*
name|n_return_vals
operator|=
name|gimp_value_array_length
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
name|return_vals
operator|=
name|_gimp_value_array_to_params
argument_list|(
name|return_values
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_value_array_unref
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
return|return
name|return_vals
return|;
block|}
end_function

begin_function
name|GimpValueArray
modifier|*
DECL|function|gimp_run_procedure_array (const gchar * name,const GimpValueArray * arguments)
name|gimp_run_procedure_array
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|arguments
parameter_list|)
block|{
name|GPProcRun
name|proc_run
decl_stmt|;
name|GPProcReturn
modifier|*
name|proc_return
decl_stmt|;
name|GimpWireMessage
name|msg
decl_stmt|;
name|GimpValueArray
modifier|*
name|return_values
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|arguments
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|proc_run
operator|.
name|name
operator|=
operator|(
name|gchar
operator|*
operator|)
name|name
expr_stmt|;
name|proc_run
operator|.
name|nparams
operator|=
name|gimp_value_array_length
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|proc_run
operator|.
name|params
operator|=
name|_gimp_value_array_to_gp_params
argument_list|(
name|arguments
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_proc_run_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_run
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|_gimp_legacy_read_expect_msg
argument_list|(
operator|&
name|msg
argument_list|,
name|GP_PROC_RETURN
argument_list|)
expr_stmt|;
name|proc_return
operator|=
name|msg
operator|.
name|data
expr_stmt|;
name|return_values
operator|=
name|_gimp_gp_params_to_value_array
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|proc_return
operator|->
name|params
argument_list|,
name|proc_return
operator|->
name|nparams
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|_gimp_set_pdb_error
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_destroy_params:  * @params:   the #GimpParam array to destroy  * @n_params: the number of elements in the array  *  * Destroys a #GimpParam array as returned by gimp_run_procedure() or  * gimp_run_procedure2().  **/
end_comment

begin_function
name|void
DECL|function|gimp_destroy_params (GimpParam * params,gint n_params)
name|gimp_destroy_params
parameter_list|(
name|GimpParam
modifier|*
name|params
parameter_list|,
name|gint
name|n_params
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_params
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|params
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|GIMP_PDB_INT32
case|:
case|case
name|GIMP_PDB_INT16
case|:
case|case
name|GIMP_PDB_INT8
case|:
case|case
name|GIMP_PDB_FLOAT
case|:
case|case
name|GIMP_PDB_COLOR
case|:
case|case
name|GIMP_PDB_ITEM
case|:
case|case
name|GIMP_PDB_DISPLAY
case|:
case|case
name|GIMP_PDB_IMAGE
case|:
case|case
name|GIMP_PDB_LAYER
case|:
case|case
name|GIMP_PDB_CHANNEL
case|:
case|case
name|GIMP_PDB_DRAWABLE
case|:
case|case
name|GIMP_PDB_SELECTION
case|:
case|case
name|GIMP_PDB_VECTORS
case|:
case|case
name|GIMP_PDB_STATUS
case|:
break|break;
case|case
name|GIMP_PDB_STRING
case|:
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT32ARRAY
case|:
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int32array
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16ARRAY
case|:
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int16array
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8ARRAY
case|:
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_int8array
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOATARRAY
case|:
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_floatarray
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_STRINGARRAY
case|:
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|params
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|GIMP_PDB_INT32
operator|)
condition|)
block|{
name|gint
name|count
init|=
name|params
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
decl_stmt|;
name|gint
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_stringarray
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_stringarray
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_PDB_COLORARRAY
case|:
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_colorarray
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_PARASITE
case|:
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|name
condition|)
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|data
operator|.
name|d_parasite
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_END
case|:
break|break;
block|}
block|}
name|g_free
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * gimp_destroy_paramdefs:  * @paramdefs: the #GimpParamDef array to destroy  * @n_params:  the number of elements in the array  *  * Destroys a #GimpParamDef array as returned by  * gimp_procedural_db_proc_info().  **/
end_comment

begin_function
name|void
DECL|function|gimp_destroy_paramdefs (GimpParamDef * paramdefs,gint n_params)
name|gimp_destroy_paramdefs
parameter_list|(
name|GimpParamDef
modifier|*
name|paramdefs
parameter_list|,
name|gint
name|n_params
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_params
operator|--
condition|)
block|{
name|g_free
argument_list|(
name|paramdefs
index|[
name|n_params
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|paramdefs
index|[
name|n_params
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|paramdefs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_initialize (const GimpPlugInInfo * info,GIOChannel * read_channel,GIOChannel * write_channel)
name|_gimp_legacy_initialize
parameter_list|(
specifier|const
name|GimpPlugInInfo
modifier|*
name|info
parameter_list|,
name|GIOChannel
modifier|*
name|read_channel
parameter_list|,
name|GIOChannel
modifier|*
name|write_channel
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|PLUG_IN_INFO
operator|=
operator|*
name|info
expr_stmt|;
name|_gimp_readchannel
operator|=
name|read_channel
expr_stmt|;
name|_gimp_writechannel
operator|=
name|write_channel
expr_stmt|;
name|gp_init
argument_list|()
expr_stmt|;
name|gimp_wire_set_writer
argument_list|(
name|gimp_write
argument_list|)
expr_stmt|;
name|gimp_wire_set_flusher
argument_list|(
name|gimp_flush
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_query (void)
name|_gimp_legacy_query
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|init_proc
condition|)
name|gp_has_init_write
argument_list|(
name|_gimp_writechannel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|query_proc
condition|)
name|PLUG_IN_INFO
operator|.
name|query_proc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_init (void)
name|_gimp_legacy_init
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|init_proc
condition|)
name|PLUG_IN_INFO
operator|.
name|init_proc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_run (void)
name|_gimp_legacy_run
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
name|gimp_temp_proc_ht
operator|=
name|g_hash_table_new
argument_list|(
name|g_str_hash
argument_list|,
name|g_str_equal
argument_list|)
expr_stmt|;
name|g_io_add_watch
argument_list|(
name|_gimp_readchannel
argument_list|,
name|G_IO_ERR
operator||
name|G_IO_HUP
argument_list|,
name|gimp_plugin_io_error_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_loop
argument_list|(
name|PLUG_IN_INFO
operator|.
name|run_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|_gimp_legacy_quit (void)
name|_gimp_legacy_quit
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLUG_IN_INFO
operator|.
name|quit_proc
condition|)
name|PLUG_IN_INFO
operator|.
name|quit_proc
argument_list|()
expr_stmt|;
name|_gimp_shm_close
argument_list|()
expr_stmt|;
name|gp_quit_write
argument_list|(
name|_gimp_writechannel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  cruft from other places  */
end_comment

begin_comment
comment|/**  * gimp_plugin_domain_register:  * @domain_name: The name of the textdomain (must be unique).  * @domain_path: The absolute path to the compiled message catalog (may be NULL).  *  * Registers a textdomain for localisation.  *  * This procedure adds a textdomain to the list of domains Gimp  * searches for strings when translating its menu entries. There is no  * need to call this function for plug-ins that have their strings  * included in the 'gimp-std-plugins' domain as that is used by  * default. If the compiled message catalog is not in the standard  * location, you may specify an absolute path to another location. This  * procedure can only be called in the query function of a plug-in and  * it has to be called before any procedure is installed.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_domain_register (const gchar * domain_name,const gchar * domain_path)
name|gimp_plugin_domain_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|domain_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|domain_path
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_domain_register
argument_list|(
name|domain_name
argument_list|,
name|domain_path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_help_register:  * @domain_name: The XML namespace of the plug-in's help pages.  * @domain_uri: The root URI of the plug-in's help pages.  *  * Register a help path for a plug-in.  *  * This procedure registers user documentation for the calling plug-in  * with the GIMP help system. The domain_uri parameter points to the  * root directory where the plug-in help is installed. For each  * supported language there should be a file called 'gimp-help.xml'  * that maps the help IDs to the actual help files.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_help_register (const gchar * domain_name,const gchar * domain_uri)
name|gimp_plugin_help_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|domain_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|domain_uri
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_help_register
argument_list|(
name|domain_name
argument_list|,
name|domain_uri
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_menu_branch_register:  * @menu_path: The sub-menu's menu path.  * @menu_name: The name of the sub-menu.  *  * Register a sub-menu.  *  * This procedure installs a sub-menu which does not belong to any  * procedure. The menu-name should be the untranslated menu label. GIMP  * will look up the translation in the textdomain registered for the  * plug-in.  *  * Returns: TRUE on success.  *  * Since: 2.4  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_menu_branch_register (const gchar * menu_path,const gchar * menu_name)
name|gimp_plugin_menu_branch_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|menu_path
parameter_list|,
specifier|const
name|gchar
modifier|*
name|menu_name
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_menu_branch_register
argument_list|(
name|menu_path
argument_list|,
name|menu_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_set_pdb_error_handler:  * @handler: Who is responsible for handling procedure call errors.  *  * Sets an error handler for procedure calls.  *  * This procedure changes the way that errors in procedure calls are  * handled. By default GIMP will raise an error dialog if a procedure  * call made by a plug-in fails. Using this procedure the plug-in can  * change this behavior. If the error handler is set to  * %GIMP_PDB_ERROR_HANDLER_PLUGIN, then the plug-in is responsible for  * calling gimp_get_pdb_error() and handling the error whenever one if  * its procedure calls fails. It can do this by displaying the error  * message or by forwarding it in its own return values.  *  * Returns: TRUE on success.  *  * Since: 2.6  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_set_pdb_error_handler (GimpPDBErrorHandler handler)
name|gimp_plugin_set_pdb_error_handler
parameter_list|(
name|GimpPDBErrorHandler
name|handler
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_set_pdb_error_handler
argument_list|(
name|handler
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_get_pdb_error_handler:  *  * Retrieves the active error handler for procedure calls.  *  * This procedure retrieves the currently active error handler for  * procedure calls made by the calling plug-in. See  * gimp_plugin_set_pdb_error_handler() for details.  *  * Returns: Who is responsible for handling procedure call errors.  *  * Since: 2.6  **/
end_comment

begin_function
name|GimpPDBErrorHandler
DECL|function|gimp_plugin_get_pdb_error_handler (void)
name|gimp_plugin_get_pdb_error_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_get_pdb_error_handler
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_menu_register:  * @procedure_name: The procedure for which to install the menu path.  * @menu_path: The procedure's additional menu path.  *  * Register an additional menu path for a plug-in procedure.  *  * This procedure installs an additional menu entry for the given  * procedure.  *  * Returns: TRUE on success.  *  * Since: 2.2  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_menu_register (const gchar * procedure_name,const gchar * menu_path)
name|gimp_plugin_menu_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|menu_path
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_plugin_menu_register
argument_list|(
name|procedure_name
argument_list|,
name|menu_path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_plugin_icon_register:  * @procedure_name: The procedure for which to install the icon.  * @icon_type: The type of the icon.  * @icon_data: The procedure's icon. The format depends on @icon_type.  *  * Register an icon for a plug-in procedure.  *  * This procedure installs an icon for the given procedure.  *  * Returns: TRUE on success.  *  * Since: 2.2  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_plugin_icon_register (const gchar * procedure_name,GimpIconType icon_type,gconstpointer icon_data)
name|gimp_plugin_icon_register
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
name|GimpIconType
name|icon_type
parameter_list|,
name|gconstpointer
name|icon_data
parameter_list|)
block|{
name|guint8
modifier|*
name|data
decl_stmt|;
name|gsize
name|data_length
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|procedure_name
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|icon_data
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|icon_type
condition|)
block|{
case|case
name|GIMP_ICON_TYPE_ICON_NAME
case|:
name|data
operator|=
operator|(
name|guint8
operator|*
operator|)
name|icon_data
expr_stmt|;
name|data_length
operator|=
name|strlen
argument_list|(
name|icon_data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|GIMP_ICON_TYPE_PIXBUF
case|:
if|if
condition|(
operator|!
name|gdk_pixbuf_save_to_buffer
argument_list|(
operator|(
name|GdkPixbuf
operator|*
operator|)
name|icon_data
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|,
operator|&
name|data_length
argument_list|,
literal|"png"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|GIMP_ICON_TYPE_IMAGE_FILE
case|:
name|data
operator|=
operator|(
name|guint8
operator|*
operator|)
name|g_file_get_uri
argument_list|(
operator|(
name|GFile
operator|*
operator|)
name|icon_data
argument_list|)
expr_stmt|;
name|data_length
operator|=
name|strlen
argument_list|(
name|icon_data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|g_return_val_if_reached
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|_gimp_plugin_icon_register
argument_list|(
name|procedure_name
argument_list|,
name|icon_type
argument_list|,
name|data_length
argument_list|,
name|data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|icon_type
condition|)
block|{
case|case
name|GIMP_ICON_TYPE_ICON_NAME
case|:
break|break;
case|case
name|GIMP_ICON_TYPE_PIXBUF
case|:
case|case
name|GIMP_ICON_TYPE_IMAGE_FILE
case|:
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_temp_name:  *  * Generates a unique temporary PDB name.  *  * This procedure generates a temporary PDB entry name that is  * guaranteed to be unique.  *  * Returns: (transfer full): A unique temporary name for a temporary PDB entry.  *          The returned value must be freed with g_free().  **/
end_comment

begin_function
name|gchar
modifier|*
DECL|function|gimp_pdb_temp_name (void)
name|gimp_pdb_temp_name
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_pdb_temp_name
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_dump:  * @filename: The dump filename.  *  * Dumps the current contents of the procedural database  *  * This procedure dumps the contents of the procedural database to the  * specified file. The file will contain all of the information  * provided for each registered procedure.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_pdb_dump (const gchar * filename)
name|gimp_pdb_dump
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_pdb_dump
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_query:  * @name: The regex for procedure name.  * @blurb: The regex for procedure blurb.  * @help: The regex for procedure help.  * @author: The regex for procedure author.  * @copyright: The regex for procedure copyright.  * @date: The regex for procedure date.  * @proc_type: The regex for procedure type: { 'Internal GIMP procedure', 'GIMP Plug-in', 'GIMP Extension', 'Temporary Procedure' }.  * @num_matches: (out): The number of matching procedures.  * @procedure_names: (out) (array length=num_matches) (element-type gchar*) (transfer full): The list of procedure names.  *  * Queries the procedural database for its contents using regular  * expression matching.  *  * This procedure queries the contents of the procedural database. It  * is supplied with seven arguments matching procedures on { name,  * blurb, help, author, copyright, date, procedure type}. This is  * accomplished using regular expression matching. For instance, to  * find all procedures with \"jpeg\" listed in the blurb, all seven  * arguments can be supplied as \".*\", except for the second, which  * can be supplied as \".*jpeg.*\". There are two return arguments for  * this procedure. The first is the number of procedures matching the  * query. The second is a concatenated list of procedure names  * corresponding to those matching the query. If no matching entries  * are found, then the returned string is NULL and the number of  * entries is 0.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_pdb_query (const gchar * name,const gchar * blurb,const gchar * help,const gchar * author,const gchar * copyright,const gchar * date,const gchar * proc_type,gint * num_matches,gchar *** procedure_names)
name|gimp_pdb_query
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|blurb
parameter_list|,
specifier|const
name|gchar
modifier|*
name|help
parameter_list|,
specifier|const
name|gchar
modifier|*
name|author
parameter_list|,
specifier|const
name|gchar
modifier|*
name|copyright
parameter_list|,
specifier|const
name|gchar
modifier|*
name|date
parameter_list|,
specifier|const
name|gchar
modifier|*
name|proc_type
parameter_list|,
name|gint
modifier|*
name|num_matches
parameter_list|,
name|gchar
modifier|*
modifier|*
modifier|*
name|procedure_names
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_pdb_query
argument_list|(
name|name
argument_list|,
name|blurb
argument_list|,
name|help
argument_list|,
name|author
argument_list|,
name|copyright
argument_list|,
name|date
argument_list|,
name|proc_type
argument_list|,
name|num_matches
argument_list|,
name|procedure_names
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_proc_exists:  * @procedure_name: The procedure name.  *  * Checks if the specified procedure exists in the procedural database  *  * This procedure checks if the specified procedure is registered in  * the procedural database.  *  * Returns: Whether a procedure of that name is registered.  *  * Since: 2.6  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_pdb_proc_exists (const gchar * procedure_name)
name|gimp_pdb_proc_exists
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|)
block|{
name|ASSERT_NO_PLUG_IN_EXISTS
argument_list|(
name|G_STRFUNC
argument_list|)
expr_stmt|;
return|return
name|_gimp_pdb_proc_exists
argument_list|(
name|procedure_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_proc_info:  * @procedure: The procedure name.  * @blurb: A short blurb.  * @help: Detailed procedure help.  * @author: Author(s) of the procedure.  * @copyright: The copyright.  * @date: Copyright date.  * @proc_type: The procedure type.  * @num_args: The number of input arguments.  * @num_values: The number of return values.  * @args: The input arguments.  * @return_vals: The return values.  *  * Queries the procedural database for information on the specified  * procedure.  *  * This procedure returns information on the specified procedure. A  * short blurb, detailed help, author(s), copyright information,  * procedure type, number of input, and number of return values are  * returned. Additionally this function returns specific information  * about each input argument and return value.  *  * Returns: TRUE on success.  */
end_comment

begin_function
name|gboolean
DECL|function|gimp_pdb_proc_info (const gchar * procedure_name,gchar ** blurb,gchar ** help,gchar ** author,gchar ** copyright,gchar ** date,GimpPDBProcType * proc_type,gint * num_args,gint * num_values,GimpParamDef ** args,GimpParamDef ** return_vals)
name|gimp_pdb_proc_info
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
name|gchar
modifier|*
modifier|*
name|blurb
parameter_list|,
name|gchar
modifier|*
modifier|*
name|help
parameter_list|,
name|gchar
modifier|*
modifier|*
name|author
parameter_list|,
name|gchar
modifier|*
modifier|*
name|copyright
parameter_list|,
name|gchar
modifier|*
modifier|*
name|date
parameter_list|,
name|GimpPDBProcType
modifier|*
name|proc_type
parameter_list|,
name|gint
modifier|*
name|num_args
parameter_list|,
name|gint
modifier|*
name|num_values
parameter_list|,
name|GimpParamDef
modifier|*
modifier|*
name|args
parameter_list|,
name|GimpParamDef
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|success
operator|=
name|_gimp_pdb_proc_info
argument_list|(
name|procedure_name
argument_list|,
name|blurb
argument_list|,
name|help
argument_list|,
name|author
argument_list|,
name|copyright
argument_list|,
name|date
argument_list|,
name|proc_type
argument_list|,
name|num_args
argument_list|,
name|num_values
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
operator|*
name|args
operator|=
name|g_new
argument_list|(
name|GimpParamDef
argument_list|,
operator|*
name|num_args
argument_list|)
expr_stmt|;
operator|*
name|return_vals
operator|=
name|g_new
argument_list|(
name|GimpParamDef
argument_list|,
operator|*
name|num_values
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_args
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|gimp_pdb_proc_arg
argument_list|(
name|procedure_name
argument_list|,
name|i
argument_list|,
operator|&
operator|(
operator|*
name|args
operator|)
index|[
name|i
index|]
operator|.
name|type
argument_list|,
operator|&
operator|(
operator|*
name|args
operator|)
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
operator|(
operator|*
name|args
operator|)
index|[
name|i
index|]
operator|.
name|description
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
operator|*
name|return_vals
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_values
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|gimp_pdb_proc_val
argument_list|(
name|procedure_name
argument_list|,
name|i
argument_list|,
operator|&
operator|(
operator|*
name|return_vals
operator|)
index|[
name|i
index|]
operator|.
name|type
argument_list|,
operator|&
operator|(
operator|*
name|return_vals
operator|)
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
operator|(
operator|*
name|return_vals
operator|)
index|[
name|i
index|]
operator|.
name|description
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
operator|*
name|return_vals
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_proc_arg:  * @procedure_name: The procedure name.  * @arg_num: The argument number.  * @arg_type: (out): The type of argument.  * @arg_name: (out) (transfer full): The name of the argument.  * @arg_desc: (out) (transfer full): A description of the argument.  *  * Queries the procedural database for information on the specified  * procedure's argument.  *  * This procedure returns information on the specified procedure's  * argument. The argument type, name, and a description are retrieved.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_pdb_proc_arg (const gchar * procedure_name,gint arg_num,GimpPDBArgType * arg_type,gchar ** arg_name,gchar ** arg_desc)
name|gimp_pdb_proc_arg
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
name|gint
name|arg_num
parameter_list|,
name|GimpPDBArgType
modifier|*
name|arg_type
parameter_list|,
name|gchar
modifier|*
modifier|*
name|arg_name
parameter_list|,
name|gchar
modifier|*
modifier|*
name|arg_desc
parameter_list|)
block|{
return|return
name|_gimp_pdb_proc_arg
argument_list|(
name|procedure_name
argument_list|,
name|arg_num
argument_list|,
name|arg_type
argument_list|,
name|arg_name
argument_list|,
name|arg_desc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * gimp_pdb_proc_val:  * @procedure_name: The procedure name.  * @val_num: The return value number.  * @val_type: (out): The type of return value.  * @val_name: (out) (transfer full): The name of the return value.  * @val_desc: (out) (transfer full): A description of the return value.  *  * Queries the procedural database for information on the specified  * procedure's return value.  *  * This procedure returns information on the specified procedure's  * return value. The return value type, name, and a description are  * retrieved.  *  * Returns: TRUE on success.  **/
end_comment

begin_function
name|gboolean
DECL|function|gimp_pdb_proc_val (const gchar * procedure_name,gint val_num,GimpPDBArgType * val_type,gchar ** val_name,gchar ** val_desc)
name|gimp_pdb_proc_val
parameter_list|(
specifier|const
name|gchar
modifier|*
name|procedure_name
parameter_list|,
name|gint
name|val_num
parameter_list|,
name|GimpPDBArgType
modifier|*
name|val_type
parameter_list|,
name|gchar
modifier|*
modifier|*
name|val_name
parameter_list|,
name|gchar
modifier|*
modifier|*
name|val_desc
parameter_list|)
block|{
return|return
name|_gimp_pdb_proc_val
argument_list|(
name|procedure_name
argument_list|,
name|val_num
argument_list|,
name|val_type
argument_list|,
name|val_name
argument_list|,
name|val_desc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  private functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gimp_loop (GimpRunProc run_proc)
name|gimp_loop
parameter_list|(
name|GimpRunProc
name|run_proc
parameter_list|)
block|{
name|GimpWireMessage
name|msg
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|gimp_wire_read_msg
argument_list|(
name|_gimp_readchannel
argument_list|,
operator|&
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|msg
operator|.
name|type
condition|)
block|{
case|case
name|GP_QUIT
case|:
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
case|case
name|GP_CONFIG
case|:
name|_gimp_config
argument_list|(
name|msg
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TILE_REQ
case|:
case|case
name|GP_TILE_ACK
case|:
case|case
name|GP_TILE_DATA
case|:
name|g_warning
argument_list|(
literal|"unexpected tile message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RUN
case|:
name|gimp_proc_run
argument_list|(
name|msg
operator|.
name|data
argument_list|,
name|run_proc
argument_list|)
expr_stmt|;
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
case|case
name|GP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc return message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RUN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc run message received (should not happen"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc return message received (should not happen"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_INSTALL
case|:
name|g_warning
argument_list|(
literal|"unexpected proc install message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_HAS_INIT
case|:
name|g_warning
argument_list|(
literal|"unexpected has init message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_process_message (GimpWireMessage * msg)
name|gimp_process_message
parameter_list|(
name|GimpWireMessage
modifier|*
name|msg
parameter_list|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|GP_QUIT
case|:
name|gimp_quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|GP_CONFIG
case|:
name|_gimp_config
argument_list|(
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TILE_REQ
case|:
case|case
name|GP_TILE_ACK
case|:
case|case
name|GP_TILE_DATA
case|:
name|g_warning
argument_list|(
literal|"unexpected tile message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RUN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc run message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc return message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RUN
case|:
name|gimp_temp_proc_run
argument_list|(
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc return message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_INSTALL
case|:
name|g_warning
argument_list|(
literal|"unexpected proc install message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_HAS_INIT
case|:
name|g_warning
argument_list|(
literal|"unexpected has init message received (should not happen)"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_single_message (void)
name|gimp_single_message
parameter_list|(
name|void
parameter_list|)
block|{
name|GimpWireMessage
name|msg
decl_stmt|;
comment|/* Run a temp function */
if|if
condition|(
operator|!
name|gimp_wire_read_msg
argument_list|(
name|_gimp_readchannel
argument_list|,
operator|&
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|gimp_process_message
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|gimp_wire_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_extension_read (GIOChannel * channel,GIOCondition condition,gpointer data)
name|gimp_extension_read
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|GIOCondition
name|condition
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gimp_single_message
argument_list|()
expr_stmt|;
return|return
name|G_SOURCE_CONTINUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_proc_run (GPProcRun * proc_run,GimpRunProc run_proc)
name|gimp_proc_run
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|)
block|{
name|GPProcReturn
name|proc_return
decl_stmt|;
name|gimp_proc_run_internal
argument_list|(
name|proc_run
argument_list|,
name|run_proc
argument_list|,
operator|&
name|proc_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_proc_return_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_return
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_temp_proc_run (GPProcRun * proc_run)
name|gimp_temp_proc_run
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|)
block|{
name|GPProcReturn
name|proc_return
decl_stmt|;
name|GimpRunProc
name|run_proc
init|=
name|g_hash_table_lookup
argument_list|(
name|gimp_temp_proc_ht
argument_list|,
name|proc_run
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|run_proc
condition|)
block|{
ifdef|#
directive|ifdef
name|GDK_WINDOWING_QUARTZ
if|if
condition|(
name|proc_run
operator|->
name|params
operator|&&
name|proc_run
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
index|[
name|NSApp
name|activateIgnoringOtherApps
operator|:
name|YES
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|gimp_proc_run_internal
argument_list|(
name|proc_run
argument_list|,
name|run_proc
argument_list|,
operator|&
name|proc_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_temp_proc_return_write
argument_list|(
name|_gimp_writechannel
argument_list|,
operator|&
name|proc_return
argument_list|,
name|NULL
argument_list|)
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gimp_proc_run_internal (GPProcRun * proc_run,GimpRunProc run_proc,GPProcReturn * proc_return)
name|gimp_proc_run_internal
parameter_list|(
name|GPProcRun
modifier|*
name|proc_run
parameter_list|,
name|GimpRunProc
name|run_proc
parameter_list|,
name|GPProcReturn
modifier|*
name|proc_return
parameter_list|)
block|{
name|GimpValueArray
modifier|*
name|arguments
decl_stmt|;
name|GimpValueArray
modifier|*
name|return_values
init|=
name|NULL
decl_stmt|;
name|GimpParam
modifier|*
name|params
decl_stmt|;
name|GimpParam
modifier|*
name|return_vals
decl_stmt|;
name|gint
name|n_params
decl_stmt|;
name|gint
name|n_return_vals
decl_stmt|;
name|arguments
operator|=
name|_gimp_gp_params_to_value_array
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|proc_run
operator|->
name|params
argument_list|,
name|proc_run
operator|->
name|nparams
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|n_params
operator|=
name|gimp_value_array_length
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|params
operator|=
name|_gimp_value_array_to_params
argument_list|(
name|arguments
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|run_proc
argument_list|(
name|proc_run
operator|->
name|name
argument_list|,
name|n_params
argument_list|,
name|params
argument_list|,
operator|&
name|n_return_vals
argument_list|,
operator|&
name|return_vals
argument_list|)
expr_stmt|;
name|return_values
operator|=
name|_gimp_params_to_value_array
argument_list|(
name|return_vals
argument_list|,
name|n_return_vals
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|gimp_value_array_unref
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|proc_return
operator|->
name|name
operator|=
name|proc_run
operator|->
name|name
expr_stmt|;
name|proc_return
operator|->
name|nparams
operator|=
name|gimp_value_array_length
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
name|proc_return
operator|->
name|params
operator|=
name|_gimp_value_array_to_gp_params
argument_list|(
name|return_values
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_value_array_unref
argument_list|(
name|return_values
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_plugin_io_error_handler (GIOChannel * channel,GIOCondition cond,gpointer data)
name|gimp_plugin_io_error_handler
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|GIOCondition
name|cond
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|g_printerr
argument_list|(
literal|"%s: fatal error: GIMP crashed\n"
argument_list|,
name|gimp_get_progname
argument_list|()
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
comment|/* never reached */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_write (GIOChannel * channel,const guint8 * buf,gulong count,gpointer user_data)
name|gimp_write
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
specifier|const
name|guint8
modifier|*
name|buf
parameter_list|,
name|gulong
name|count
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|gulong
name|bytes
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|write_buffer_index
operator|+
name|count
operator|)
operator|>=
name|WRITE_BUFFER_SIZE
condition|)
block|{
name|bytes
operator|=
name|WRITE_BUFFER_SIZE
operator|-
name|write_buffer_index
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|write_buffer
index|[
name|write_buffer_index
index|]
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|write_buffer_index
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_wire_flush
argument_list|(
name|channel
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|bytes
operator|=
name|count
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|write_buffer
index|[
name|write_buffer_index
index|]
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|write_buffer_index
operator|+=
name|bytes
expr_stmt|;
block|}
name|buf
operator|+=
name|bytes
expr_stmt|;
name|count
operator|-=
name|bytes
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|gimp_flush (GIOChannel * channel,gpointer user_data)
name|gimp_flush
parameter_list|(
name|GIOChannel
modifier|*
name|channel
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|GIOStatus
name|status
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|gsize
name|count
decl_stmt|;
name|gsize
name|bytes
decl_stmt|;
if|if
condition|(
name|write_buffer_index
operator|>
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|!=
name|write_buffer_index
condition|)
block|{
do|do
block|{
name|bytes
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|g_io_channel_write_chars
argument_list|(
name|channel
argument_list|,
operator|&
name|write_buffer
index|[
name|count
index|]
argument_list|,
operator|(
name|write_buffer_index
operator|-
name|count
operator|)
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|status
operator|==
name|G_IO_STATUS_AGAIN
condition|)
do|;
if|if
condition|(
name|status
operator|!=
name|G_IO_STATUS_NORMAL
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
name|g_warning
argument_list|(
literal|"%s: gimp_flush(): error: %s"
argument_list|,
name|g_get_prgname
argument_list|()
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_error_free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"%s: gimp_flush(): error"
argument_list|,
name|g_get_prgname
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|count
operator|+=
name|bytes
expr_stmt|;
block|}
name|write_buffer_index
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

