begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"regex2.h"
end_include

begin_include
include|#
directive|include
file|"cclass.h"
end_include

begin_include
include|#
directive|include
file|"cname.h"
end_include

begin_comment
comment|/*  * parse structure, passed up and down to avoid global variables and  * other clumsinesses  */
end_comment

begin_struct
DECL|struct|parse
struct|struct
name|parse
block|{
DECL|member|next
name|char
modifier|*
name|next
decl_stmt|;
comment|/* next character in RE */
DECL|member|end
name|char
modifier|*
name|end
decl_stmt|;
comment|/* end of string (-> NUL normally) */
DECL|member|error
name|int
name|error
decl_stmt|;
comment|/* has an error been seen? */
DECL|member|strip
name|sop
modifier|*
name|strip
decl_stmt|;
comment|/* malloced strip */
DECL|member|ssize
name|sopno
name|ssize
decl_stmt|;
comment|/* malloced strip size (allocated) */
DECL|member|slen
name|sopno
name|slen
decl_stmt|;
comment|/* malloced strip length (used) */
DECL|member|ncsalloc
name|int
name|ncsalloc
decl_stmt|;
comment|/* number of csets allocated */
DECL|member|g
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
DECL|macro|NPAREN
define|#
directive|define
name|NPAREN
value|10
comment|/* we need to remember () 1-9 for back refs */
DECL|member|pbegin
name|sopno
name|pbegin
index|[
name|NPAREN
index|]
decl_stmt|;
comment|/* -> ( ([0] unused) */
DECL|member|pend
name|sopno
name|pend
index|[
name|NPAREN
index|]
decl_stmt|;
comment|/* -> ) ([0] unused) */
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"regcomp.ih"
end_include

begin_decl_stmt
DECL|variable|nuls
specifier|static
name|char
name|nuls
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|nuls
comment|/* place to point scanner in event of error */
end_comment

begin_comment
comment|/*  * macros for use with parse structure  * BEWARE:  these know that the parse structure is named `p' !!!  */
end_comment

begin_define
DECL|macro|PEEK ()
define|#
directive|define
name|PEEK
parameter_list|()
value|(*p->next)
end_define

begin_define
DECL|macro|PEEK2 ()
define|#
directive|define
name|PEEK2
parameter_list|()
value|(*(p->next+1))
end_define

begin_define
DECL|macro|MORE ()
define|#
directive|define
name|MORE
parameter_list|()
value|(p->next< p->end)
end_define

begin_define
DECL|macro|MORE2 ()
define|#
directive|define
name|MORE2
parameter_list|()
value|(p->next+1< p->end)
end_define

begin_define
DECL|macro|SEE (c)
define|#
directive|define
name|SEE
parameter_list|(
name|c
parameter_list|)
value|(MORE()&& PEEK() == (c))
end_define

begin_define
DECL|macro|SEETWO (a,b)
define|#
directive|define
name|SEETWO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(MORE()&& MORE2()&& PEEK() == (a)&& PEEK2() == (b))
end_define

begin_define
DECL|macro|EAT (c)
define|#
directive|define
name|EAT
parameter_list|(
name|c
parameter_list|)
value|((SEE(c)) ? (NEXT1(), 1) : 0)
end_define

begin_define
DECL|macro|EATTWO (a,b)
define|#
directive|define
name|EATTWO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
end_define

begin_define
DECL|macro|NEXT1 ()
define|#
directive|define
name|NEXT1
parameter_list|()
value|(p->next++)
end_define

begin_define
DECL|macro|NEXT2 ()
define|#
directive|define
name|NEXT2
parameter_list|()
value|(p->next += 2)
end_define

begin_define
DECL|macro|NEXTn (n)
define|#
directive|define
name|NEXTn
parameter_list|(
name|n
parameter_list|)
value|(p->next += (n))
end_define

begin_define
DECL|macro|GETNEXT ()
define|#
directive|define
name|GETNEXT
parameter_list|()
value|(*p->next++)
end_define

begin_define
DECL|macro|SETERROR (e)
define|#
directive|define
name|SETERROR
parameter_list|(
name|e
parameter_list|)
value|seterr(p, (e))
end_define

begin_define
DECL|macro|REQUIRE (co,e)
define|#
directive|define
name|REQUIRE
parameter_list|(
name|co
parameter_list|,
name|e
parameter_list|)
value|((void)((co) || SETERROR(e)))
end_define

begin_define
DECL|macro|MUSTSEE (c,e)
define|#
directive|define
name|MUSTSEE
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(MORE()&& PEEK() == (c), e))
end_define

begin_define
DECL|macro|MUSTEAT (c,e)
define|#
directive|define
name|MUSTEAT
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(MORE()&& GETNEXT() == (c), e))
end_define

begin_define
DECL|macro|MUSTNOTSEE (c,e)
define|#
directive|define
name|MUSTNOTSEE
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(!MORE() || PEEK() != (c), e))
end_define

begin_define
DECL|macro|EMIT (op,sopnd)
define|#
directive|define
name|EMIT
parameter_list|(
name|op
parameter_list|,
name|sopnd
parameter_list|)
value|doemit(p, (sop)(op), (size_t)(sopnd))
end_define

begin_define
DECL|macro|INSERT (op,pos)
define|#
directive|define
name|INSERT
parameter_list|(
name|op
parameter_list|,
name|pos
parameter_list|)
value|doinsert(p, (sop)(op), HERE()-(pos)+1, pos)
end_define

begin_define
DECL|macro|AHEAD (pos)
define|#
directive|define
name|AHEAD
parameter_list|(
name|pos
parameter_list|)
value|dofwd(p, pos, HERE()-(pos))
end_define

begin_define
DECL|macro|ASTERN (sop,pos)
define|#
directive|define
name|ASTERN
parameter_list|(
name|sop
parameter_list|,
name|pos
parameter_list|)
value|EMIT(sop, HERE()-pos)
end_define

begin_define
DECL|macro|HERE ()
define|#
directive|define
name|HERE
parameter_list|()
value|(p->slen)
end_define

begin_define
DECL|macro|THERE ()
define|#
directive|define
name|THERE
parameter_list|()
value|(p->slen - 1)
end_define

begin_define
DECL|macro|THERETHERE ()
define|#
directive|define
name|THERETHERE
parameter_list|()
value|(p->slen - 2)
end_define

begin_define
DECL|macro|DROP (n)
define|#
directive|define
name|DROP
parameter_list|(
name|n
parameter_list|)
value|(p->slen -= (n))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_decl_stmt
DECL|variable|never
specifier|static
name|int
name|never
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|never
comment|/* for use in asserts; shuts lint up */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|never
define|#
directive|define
name|never
value|0
end_define

begin_comment
DECL|macro|never
comment|/* some<assert.h>s have bugs too */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  - regcomp - interface for parser and compilation  = API_EXPORT(int) regcomp(regex_t *, const char *, int);  = #define     REG_BASIC 0000  = #define     REG_EXTENDED   0001  = #define     REG_ICASE 0002  = #define     REG_NOSUB 0004  = #define     REG_NEWLINE    0010  = #define     REG_NOSPEC     0020  = #define     REG_PEND  0040  = #define     REG_DUMP  0200  */
end_comment

begin_macro
name|API_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_comment
comment|/* 0 success, otherwise REG_something */
end_comment

begin_macro
name|regcomp
argument_list|(
argument|preg
argument_list|,
argument|pattern
argument_list|,
argument|cflags
argument_list|)
end_macro

begin_decl_stmt
name|regex_t
modifier|*
name|preg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pattern
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cflags
name|int
name|cflags
decl_stmt|;
end_decl_stmt

begin_block
block|{
DECL|variable|pa
name|struct
name|parse
name|pa
decl_stmt|;
DECL|variable|g
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
DECL|variable|p
specifier|register
name|struct
name|parse
modifier|*
name|p
init|=
operator|&
name|pa
decl_stmt|;
DECL|variable|i
specifier|register
name|int
name|i
decl_stmt|;
DECL|variable|len
specifier|register
name|size_t
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|REDEBUG
DECL|macro|GOODFLAGS (f)
define|#
directive|define
name|GOODFLAGS
parameter_list|(
name|f
parameter_list|)
value|(f)
else|#
directive|else
DECL|macro|GOODFLAGS (f)
define|#
directive|define
name|GOODFLAGS
parameter_list|(
name|f
parameter_list|)
value|((f)&~REG_DUMP)
endif|#
directive|endif
name|cflags
operator|=
name|GOODFLAGS
argument_list|(
name|cflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|&&
operator|(
name|cflags
operator|&
name|REG_NOSPEC
operator|)
condition|)
return|return
operator|(
name|REG_INVARG
operator|)
return|;
if|if
condition|(
name|cflags
operator|&
name|REG_PEND
condition|)
block|{
if|if
condition|(
name|preg
operator|->
name|re_endp
operator|<
name|pattern
condition|)
return|return
operator|(
name|REG_INVARG
operator|)
return|;
name|len
operator|=
name|preg
operator|->
name|re_endp
operator|-
name|pattern
expr_stmt|;
block|}
else|else
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
expr_stmt|;
comment|/* do the mallocs early so failure handling is easy */
name|g
operator|=
operator|(
expr|struct
name|re_guts
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_guts
argument_list|)
operator|+
operator|(
name|NC
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cat_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
name|p
operator|->
name|ssize
operator|=
name|len
operator|/
operator|(
name|size_t
operator|)
literal|2
operator|*
operator|(
name|size_t
operator|)
literal|3
operator|+
operator|(
name|size_t
operator|)
literal|1
expr_stmt|;
comment|/* ugh */
name|p
operator|->
name|strip
operator|=
operator|(
name|sop
operator|*
operator|)
name|malloc
argument_list|(
name|p
operator|->
name|ssize
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|slen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|strip
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|g
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
block|}
comment|/* set things up */
name|p
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|pattern
expr_stmt|;
comment|/* convenience; we do not modify it */
name|p
operator|->
name|end
operator|=
name|p
operator|->
name|next
operator|+
name|len
expr_stmt|;
name|p
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ncsalloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPAREN
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|g
operator|->
name|csetsize
operator|=
name|NC
expr_stmt|;
name|g
operator|->
name|sets
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|setbits
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|ncsets
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|cflags
operator|=
name|cflags
expr_stmt|;
name|g
operator|->
name|iflags
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|nbol
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|neol
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|must
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|nsub
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|ncategories
operator|=
literal|1
expr_stmt|;
comment|/* category 0 is "everything else" */
name|g
operator|->
name|categories
operator|=
operator|&
name|g
operator|->
name|catspace
index|[
operator|-
operator|(
name|CHAR_MIN
operator|)
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|g
operator|->
name|catspace
argument_list|,
literal|0
argument_list|,
name|NC
operator|*
sizeof|sizeof
argument_list|(
name|cat_t
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|backrefs
operator|=
literal|0
expr_stmt|;
comment|/* do it */
name|EMIT
argument_list|(
name|OEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|firststate
operator|=
name|THERE
argument_list|()
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|REG_EXTENDED
condition|)
name|p_ere
argument_list|(
name|p
argument_list|,
name|OUT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|&
name|REG_NOSPEC
condition|)
name|p_str
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|p_bre
argument_list|(
name|p
argument_list|,
name|OUT
argument_list|,
name|OUT
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|laststate
operator|=
name|THERE
argument_list|()
expr_stmt|;
comment|/* tidy up loose ends and fill things in */
name|categorize
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|stripsnug
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|findmust
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|nplus
operator|=
name|pluscount
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|magic
operator|=
name|MAGIC2
expr_stmt|;
name|preg
operator|->
name|re_nsub
operator|=
name|g
operator|->
name|nsub
expr_stmt|;
name|preg
operator|->
name|re_g
operator|=
name|g
expr_stmt|;
name|preg
operator|->
name|re_magic
operator|=
name|MAGIC1
expr_stmt|;
ifndef|#
directive|ifndef
name|REDEBUG
comment|/* not debugging, so can't rely on the assert() in regexec() */
if|if
condition|(
name|g
operator|->
name|iflags
operator|&
name|BAD
condition|)
name|SETERROR
argument_list|(
name|REG_ASSERT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* win or lose, we're done */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* lose */
name|regfree
argument_list|(
name|preg
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  - p_ere - ERE parser top level, concatenation and alternation  == static void p_ere(register struct parse *p, int stop);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_ere (p,stop)
name|p_ere
parameter_list|(
name|p
parameter_list|,
name|stop
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|stop
decl_stmt|;
comment|/* character this ERE should end at */
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|sopno
name|prevback
init|=
literal|0
decl_stmt|;
specifier|register
name|sopno
name|prevfwd
init|=
literal|0
decl_stmt|;
specifier|register
name|sopno
name|conc
decl_stmt|;
specifier|register
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* is this the first alternative? */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* do a bunch of concatenated expressions */
name|conc
operator|=
name|HERE
argument_list|()
expr_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|(
name|c
operator|=
name|PEEK
argument_list|()
operator|)
operator|!=
literal|'|'
operator|&&
name|c
operator|!=
name|stop
condition|)
name|p_ere_exp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|HERE
argument_list|()
operator|!=
name|conc
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
comment|/* require nonempty */
if|if
condition|(
operator|!
name|EAT
argument_list|(
literal|'|'
argument_list|)
condition|)
break|break;
comment|/* NOTE BREAK OUT */
if|if
condition|(
name|first
condition|)
block|{
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|conc
argument_list|)
expr_stmt|;
comment|/* offset is wrong */
name|prevfwd
operator|=
name|conc
expr_stmt|;
name|prevback
operator|=
name|conc
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|prevback
argument_list|)
expr_stmt|;
name|prevback
operator|=
name|THERE
argument_list|()
expr_stmt|;
name|AHEAD
argument_list|(
name|prevfwd
argument_list|)
expr_stmt|;
comment|/* fix previous offset */
name|prevfwd
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset is very wrong */
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|/* tail-end fixups */
name|AHEAD
argument_list|(
name|prevfwd
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|prevback
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|MORE
argument_list|()
operator|||
name|SEE
argument_list|(
name|stop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op  == static void p_ere_exp(register struct parse *p);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_ere_exp (p)
name|p_ere_exp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|sopno
name|pos
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|count2
decl_stmt|;
specifier|register
name|sopno
name|subno
decl_stmt|;
name|int
name|wascaret
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|MORE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* caller should have ensured this */
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
name|pos
operator|=
name|HERE
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nsub
operator|++
expr_stmt|;
name|subno
operator|=
name|p
operator|->
name|g
operator|->
name|nsub
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
name|p
operator|->
name|pbegin
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OLPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SEE
argument_list|(
literal|')'
argument_list|)
condition|)
name|p_ere
argument_list|(
name|p
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT
argument_list|(
name|ORPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
name|MUSTEAT
argument_list|(
literal|')'
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|POSIX_MISTAKE
case|case
literal|')'
case|:
comment|/* happens only if no current unmatched ( */
comment|/*            * You may ask, why the ifndef?  Because I didn't notice            * this until slightly too late for 1003.2, and none of the            * other 1003.2 regular-expression reviewers noticed it at            * all.  So an unmatched ) is legal POSIX, at least until            * we can get it fixed.            */
name|SETERROR
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'^'
case|:
name|EMIT
argument_list|(
name|OBOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEBOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nbol
operator|++
expr_stmt|;
name|wascaret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|EMIT
argument_list|(
name|OEOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEEOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|neol
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|SETERROR
argument_list|(
name|REG_EMPTY
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|nonnewline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|EMIT
argument_list|(
name|OANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
name|ordinary
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* okay as ordinary except if digit follows */
name|REQUIRE
argument_list|(
operator|!
name|MORE
argument_list|()
operator|||
operator|!
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ordinary
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|MORE
argument_list|()
condition|)
return|return;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
comment|/* we call { a repetition if followed by a digit */
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|&&
name|MORE2
argument_list|()
operator|&&
name|isdigit
argument_list|(
name|PEEK2
argument_list|()
argument_list|)
operator|)
operator|)
condition|)
return|return;
comment|/* no repetition, we're done */
name|NEXT1
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|wascaret
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* implemented as +? */
comment|/* this case does not require the (y|) trick, noKLUDGE */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* offset slightly wrong */
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* this one's right */
name|AHEAD
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|/* fix the OCH_ */
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset very wrong... */
name|AHEAD
argument_list|(
name|THERE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* ...so fix it */
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|THERETHERE
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|count
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|','
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
condition|)
block|{
name|count2
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|count
operator|<=
name|count2
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single number with comma */
name|count2
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* just a single number */
name|count2
operator|=
name|count
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EAT
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
comment|/* error heuristics */
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|PEEK
argument_list|()
operator|!=
literal|'}'
condition|)
name|NEXT1
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACE
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|MORE
argument_list|()
condition|)
return|return;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|&&
name|MORE2
argument_list|()
operator|&&
name|isdigit
argument_list|(
name|PEEK2
argument_list|()
argument_list|)
operator|)
operator|)
condition|)
return|return;
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_str - string (no metacharacters) "parser"  == static void p_str(register struct parse *p);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_str (p)
name|p_str
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
while|while
condition|(
name|MORE
argument_list|()
condition|)
name|ordinary
argument_list|(
name|p
argument_list|,
name|GETNEXT
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_bre - BRE parser top level, anchoring and concatenation  == static void p_bre(register struct parse *p, register int end1, \  ==  register int end2);  * Giving end1 as OUT essentially eliminates the end1/end2 check.  *  * This implementation is a bit of a kludge, in that a trailing $ is first  * taken as an ordinary character and then revised to be an anchor.  The  * only undesirable side effect is that '$' gets included as a character  * category in such cases.  This is fairly harmless; not worth fixing.  * The amount of lookahead needed to avoid this kludge is excessive.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_bre (p,end1,end2)
name|p_bre
parameter_list|(
name|p
parameter_list|,
name|end1
parameter_list|,
name|end2
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|end1
decl_stmt|;
comment|/* first terminating character */
specifier|register
name|int
name|end2
decl_stmt|;
comment|/* second terminating character */
block|{
specifier|register
name|sopno
name|start
init|=
name|HERE
argument_list|()
decl_stmt|;
specifier|register
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* first subexpression? */
specifier|register
name|int
name|wasdollar
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'^'
argument_list|)
condition|)
block|{
name|EMIT
argument_list|(
name|OBOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEBOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nbol
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
name|end1
argument_list|,
name|end2
argument_list|)
condition|)
block|{
name|wasdollar
operator|=
name|p_simp_re
argument_list|(
name|p
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wasdollar
condition|)
block|{
comment|/* oops, that was a trailing anchor */
name|DROP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OEOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEEOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|neol
operator|++
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|HERE
argument_list|()
operator|!=
name|start
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
comment|/* require nonempty */
block|}
end_function

begin_comment
comment|/*  - p_simp_re - parse a simple RE, an atom possibly followed by a repetition  == static int p_simp_re(register struct parse *p, int starordinary);  */
end_comment

begin_function
specifier|static
name|int
comment|/* was the simple RE an unbackslashed $? */
DECL|function|p_simp_re (p,starordinary)
name|p_simp_re
parameter_list|(
name|p
parameter_list|,
name|starordinary
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|starordinary
decl_stmt|;
comment|/* is a leading * an ordinary character? */
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|count2
decl_stmt|;
specifier|register
name|sopno
name|pos
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|sopno
name|subno
decl_stmt|;
DECL|macro|BACKSL
define|#
directive|define
name|BACKSL
value|(1<<CHAR_BIT)
name|pos
operator|=
name|HERE
argument_list|()
expr_stmt|;
comment|/* repetion op, if any, covers from here */
name|assert
argument_list|(
name|MORE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* caller should have ensured this */
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|c
operator|=
name|BACKSL
operator||
operator|(
name|unsigned
name|char
operator|)
name|GETNEXT
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|nonnewline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|EMIT
argument_list|(
name|OANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'{'
case|:
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'('
case|:
name|p
operator|->
name|g
operator|->
name|nsub
operator|++
expr_stmt|;
name|subno
operator|=
name|p
operator|->
name|g
operator|->
name|nsub
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
name|p
operator|->
name|pbegin
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OLPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
comment|/* the MORE here is an error heuristic */
if|if
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'\\'
argument_list|,
literal|')'
argument_list|)
condition|)
name|p_bre
argument_list|(
name|p
argument_list|,
literal|'\\'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT
argument_list|(
name|ORPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|')'
argument_list|)
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|')'
case|:
comment|/* should not get here -- must be user */
case|case
name|BACKSL
operator||
literal|'}'
case|:
name|SETERROR
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'1'
case|:
case|case
name|BACKSL
operator||
literal|'2'
case|:
case|case
name|BACKSL
operator||
literal|'3'
case|:
case|case
name|BACKSL
operator||
literal|'4'
case|:
case|case
name|BACKSL
operator||
literal|'5'
case|:
case|case
name|BACKSL
operator||
literal|'6'
case|:
case|case
name|BACKSL
operator||
literal|'7'
case|:
case|case
name|BACKSL
operator||
literal|'8'
case|:
case|case
name|BACKSL
operator||
literal|'9'
case|:
name|i
operator|=
operator|(
name|c
operator|&
operator|~
name|BACKSL
operator|)
operator|-
literal|'0'
expr_stmt|;
name|assert
argument_list|(
name|i
operator|<
name|NPAREN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|i
operator|<=
name|p
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OBACK_
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|pbegin
index|[
name|i
index|]
index|]
argument_list|)
operator|==
name|OLPAREN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|pend
index|[
name|i
index|]
index|]
argument_list|)
operator|==
name|ORPAREN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dupl
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
name|p
operator|->
name|pend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|O_BACK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|SETERROR
argument_list|(
name|REG_ESUBREG
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|backrefs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|REQUIRE
argument_list|(
name|starordinary
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ordinary
argument_list|(
name|p
argument_list|,
name|c
operator|&
operator|~
name|BACKSL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EAT
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
comment|/* implemented as +? */
comment|/* this case does not require the (y|) trick, noKLUDGE */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|'{'
argument_list|)
condition|)
block|{
name|count
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|','
argument_list|)
condition|)
block|{
if|if
condition|(
name|MORE
argument_list|()
operator|&&
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
condition|)
block|{
name|count2
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|count
operator|<=
name|count2
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single number with comma */
name|count2
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* just a single number */
name|count2
operator|=
name|count
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|'}'
argument_list|)
condition|)
block|{
comment|/* error heuristics */
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'\\'
argument_list|,
literal|'}'
argument_list|)
condition|)
name|NEXT1
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACE
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|'$'
condition|)
comment|/* $ (but not \$) ends it */
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_count - parse a repetition count  == static int p_count(register struct parse *p);  */
end_comment

begin_function
specifier|static
name|int
comment|/* the value */
DECL|function|p_count (p)
name|p_count
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
operator|&&
name|count
operator|<=
name|DUPMAX
condition|)
block|{
name|count
operator|=
name|count
operator|*
literal|10
operator|+
operator|(
name|GETNEXT
argument_list|()
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ndigits
operator|++
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|ndigits
operator|>
literal|0
operator|&&
name|count
operator|<=
name|DUPMAX
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_bracket - parse a bracketed character list  == static void p_bracket(register struct parse *p);  *  * Note a significant property of this code:  if the allocset() did SETERROR,  * no set operations are done.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_bracket (p)
name|p_bracket
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|cset
modifier|*
name|cs
init|=
name|allocset
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|register
name|int
name|invert
init|=
literal|0
decl_stmt|;
comment|/* Dept of Truly Sickening Special-Case Kludges */
if|if
condition|(
name|p
operator|->
name|next
operator|+
literal|5
operator|<
name|p
operator|->
name|end
operator|&&
name|strncmp
argument_list|(
name|p
operator|->
name|next
argument_list|,
literal|"[:<:]]"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EMIT
argument_list|(
name|OBOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NEXTn
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|next
operator|+
literal|5
operator|<
name|p
operator|->
name|end
operator|&&
name|strncmp
argument_list|(
name|p
operator|->
name|next
argument_list|,
literal|"[:>:]]"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EMIT
argument_list|(
name|OEOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NEXTn
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EAT
argument_list|(
literal|'^'
argument_list|)
condition|)
name|invert
operator|++
expr_stmt|;
comment|/* make note to invert set at end */
if|if
condition|(
name|EAT
argument_list|(
literal|']'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|PEEK
argument_list|()
operator|!=
literal|']'
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'-'
argument_list|,
literal|']'
argument_list|)
condition|)
name|p_b_term
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|MUSTEAT
argument_list|(
literal|']'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* don't mess things up further */
return|return;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_ICASE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ci
decl_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|->
name|g
operator|->
name|csetsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|ci
operator|=
name|othercase
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|!=
name|i
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cs
operator|->
name|multis
operator|!=
name|NULL
condition|)
name|mccase
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invert
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|->
name|g
operator|->
name|csetsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
name|CHsub
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|CHadd
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|CHsub
argument_list|(
name|cs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|!=
name|NULL
condition|)
name|mcinvert
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|cs
operator|->
name|multis
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
if|if
condition|(
name|nch
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* optimize singleton sets */
name|ordinary
argument_list|(
name|p
argument_list|,
name|firstch
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|freeset
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
name|EMIT
argument_list|(
name|OANYOF
argument_list|,
name|freezeset
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_term - parse one term of a bracketed character list  == static void p_b_term(register struct parse *p, register cset *cs);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_b_term (p,cs)
name|p_b_term
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
name|start
decl_stmt|,
name|finish
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* classify what we've got */
switch|switch
condition|(
operator|(
name|MORE
argument_list|()
operator|)
condition|?
name|PEEK
argument_list|()
else|:
literal|'\0'
condition|)
block|{
case|case
literal|'['
case|:
name|c
operator|=
operator|(
name|MORE2
argument_list|()
operator|)
condition|?
name|PEEK2
argument_list|()
else|:
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|SETERROR
argument_list|(
name|REG_ERANGE
argument_list|)
expr_stmt|;
return|return;
comment|/* NOTE RETURN */
break|break;
default|default:
name|c
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
comment|/* character class */
name|NEXT2
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|']'
argument_list|,
name|REG_ECTYPE
argument_list|)
expr_stmt|;
name|p_b_cclass
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|':'
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECTYPE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* equivalence class */
name|NEXT2
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|']'
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
name|p_b_eclass
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'='
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* symbol, ordinary character, or range */
comment|/* xxx revision needed for multichar stuff */
name|start
operator|=
name|p_b_symbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEE
argument_list|(
literal|'-'
argument_list|)
operator|&&
name|MORE2
argument_list|()
operator|&&
name|PEEK2
argument_list|()
operator|!=
literal|']'
condition|)
block|{
comment|/* range */
name|NEXT1
argument_list|()
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|finish
operator|=
literal|'-'
expr_stmt|;
else|else
name|finish
operator|=
name|p_b_symbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|finish
operator|=
name|start
expr_stmt|;
comment|/* xxx what about signed chars here... */
name|REQUIRE
argument_list|(
name|start
operator|<=
name|finish
argument_list|,
name|REG_ERANGE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|finish
condition|;
name|i
operator|++
control|)
name|CHadd
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  - p_b_cclass - parse a character-class name and deal with it  == static void p_b_cclass(register struct parse *p, register cset *cs);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_b_cclass (p,cs)
name|p_b_cclass
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
init|=
name|p
operator|->
name|next
decl_stmt|;
specifier|register
name|struct
name|cclass
modifier|*
name|cp
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|u
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|isalpha
argument_list|(
name|PEEK
argument_list|()
argument_list|)
condition|)
name|NEXT1
argument_list|()
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|next
operator|-
name|sp
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cclasses
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|cp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* oops, didn't find it */
name|SETERROR
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
return|return;
block|}
name|u
operator|=
name|cp
operator|->
name|chars
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|u
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|cp
operator|->
name|multis
init|;
operator|*
name|u
operator|!=
literal|'\0'
condition|;
name|u
operator|+=
name|strlen
argument_list|(
name|u
argument_list|)
operator|+
literal|1
control|)
name|MCadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_eclass - parse an equivalence-class name and deal with it  == static void p_b_eclass(register struct parse *p, register cset *cs);  *  * This implementation is incomplete. xxx  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_b_eclass (p,cs)
name|p_b_eclass
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|c
operator|=
name|p_b_coll_elem
argument_list|(
name|p
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|CHadd
argument_list|(
name|cs
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_symbol - parse a character or [..]ed multicharacter collating symbol  == static char p_b_symbol(register struct parse *p);  */
end_comment

begin_function
specifier|static
name|char
comment|/* value of symbol */
DECL|function|p_b_symbol (p)
name|p_b_symbol
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
name|value
decl_stmt|;
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EATTWO
argument_list|(
literal|'['
argument_list|,
literal|'.'
argument_list|)
condition|)
return|return
operator|(
name|GETNEXT
argument_list|()
operator|)
return|;
comment|/* collating symbol */
name|value
operator|=
name|p_b_coll_elem
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'.'
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_b_coll_elem - parse a collating-element name and look it up  == static char p_b_coll_elem(register struct parse *p, int endc);  */
end_comment

begin_function
specifier|static
name|char
comment|/* value of collating element */
DECL|function|p_b_coll_elem (p,endc)
name|p_b_coll_elem
parameter_list|(
name|p
parameter_list|,
name|endc
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|endc
decl_stmt|;
comment|/* name ended by endc,']' */
block|{
specifier|register
name|char
modifier|*
name|sp
init|=
name|p
operator|->
name|next
decl_stmt|;
specifier|register
name|struct
name|cname
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
name|endc
argument_list|,
literal|']'
argument_list|)
condition|)
name|NEXT1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|MORE
argument_list|()
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|p
operator|->
name|next
operator|-
name|sp
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cnames
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|cp
operator|->
name|code
operator|)
return|;
comment|/* known name */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
operator|(
operator|*
name|sp
operator|)
return|;
comment|/* single character */
name|SETERROR
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* neither */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - othercase - return the case counterpart of an alphabetic  == static char othercase(int ch);  */
end_comment

begin_function
specifier|static
name|char
comment|/* if no counterpart, return ch */
DECL|function|othercase (ch)
name|othercase
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|assert
argument_list|(
name|isalpha
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|tolower
argument_list|(
name|ch
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|toupper
argument_list|(
name|ch
argument_list|)
operator|)
return|;
else|else
comment|/* peculiar, but could happen */
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - bothcases - emit a dualcase version of a two-case character  == static void bothcases(register struct parse *p, int ch);  *  * Boy, is this implementation ever a kludge...  */
end_comment

begin_function
specifier|static
name|void
DECL|function|bothcases (p,ch)
name|bothcases
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|oldnext
init|=
name|p
operator|->
name|next
decl_stmt|;
specifier|register
name|char
modifier|*
name|oldend
init|=
name|p
operator|->
name|end
decl_stmt|;
name|char
name|bracket
index|[
literal|3
index|]
decl_stmt|;
name|assert
argument_list|(
name|othercase
argument_list|(
name|ch
argument_list|)
operator|!=
name|ch
argument_list|)
expr_stmt|;
comment|/* p_bracket() would recurse */
name|p
operator|->
name|next
operator|=
name|bracket
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|bracket
operator|+
literal|2
expr_stmt|;
name|bracket
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|bracket
index|[
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|bracket
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|next
operator|==
name|bracket
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|oldnext
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|oldend
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - ordinary - emit an ordinary character  == static void ordinary(register struct parse *p, register int ch);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|ordinary (p,ch)
name|ordinary
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
block|{
specifier|register
name|cat_t
modifier|*
name|cap
init|=
name|p
operator|->
name|g
operator|->
name|categories
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_ICASE
operator|)
operator|&&
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|&&
name|othercase
argument_list|(
name|ch
argument_list|)
operator|!=
name|ch
condition|)
name|bothcases
argument_list|(
name|p
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
name|EMIT
argument_list|(
name|OCHAR
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
index|[
name|ch
index|]
operator|==
literal|0
condition|)
name|cap
index|[
name|ch
index|]
operator|=
name|p
operator|->
name|g
operator|->
name|ncategories
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - nonnewline - emit REG_NEWLINE version of OANY  == static void nonnewline(register struct parse *p);  *  * Boy, is this implementation ever a kludge...  */
end_comment

begin_function
specifier|static
name|void
DECL|function|nonnewline (p)
name|nonnewline
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|oldnext
init|=
name|p
operator|->
name|next
decl_stmt|;
specifier|register
name|char
modifier|*
name|oldend
init|=
name|p
operator|->
name|end
decl_stmt|;
name|char
name|bracket
index|[
literal|4
index|]
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|bracket
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|bracket
operator|+
literal|3
expr_stmt|;
name|bracket
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|bracket
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bracket
index|[
literal|2
index|]
operator|=
literal|']'
expr_stmt|;
name|bracket
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|next
operator|==
name|bracket
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|oldnext
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|oldend
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - repeat - generate code for a bounded repetition, recursively if needed  == static void repeat(register struct parse *p, sopno start, int from, int to);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|repeat (p,start,from,to)
name|repeat
parameter_list|(
name|p
parameter_list|,
name|start
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sopno
name|start
decl_stmt|;
comment|/* operand from here to end of strip */
name|int
name|from
decl_stmt|;
comment|/* repeated from this number */
name|int
name|to
decl_stmt|;
comment|/* to this number of times (maybe INFINITY) */
block|{
specifier|register
name|sopno
name|finish
init|=
name|HERE
argument_list|()
decl_stmt|;
DECL|macro|N
define|#
directive|define
name|N
value|2
DECL|macro|INF
define|#
directive|define
name|INF
value|3
DECL|macro|REP (f,t)
define|#
directive|define
name|REP
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|((f)*8 + (t))
DECL|macro|MAP (n)
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|(((n)<= 1) ? (n) : ((n) == INFINITY) ? INF : N)
specifier|register
name|sopno
name|copy
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* head off possible runaway recursion */
return|return;
name|assert
argument_list|(
name|from
operator|<=
name|to
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REP
argument_list|(
name|MAP
argument_list|(
name|from
argument_list|)
argument_list|,
name|MAP
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
case|:
comment|/* must be user doing this */
name|DROP
argument_list|(
name|finish
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* drop the operand */
break|break;
case|case
name|REP
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
case|:
comment|/* as x{1,1}? */
case|case
name|REP
argument_list|(
literal|0
argument_list|,
name|N
argument_list|)
case|:
comment|/* as x{1,n}? */
case|case
name|REP
argument_list|(
literal|0
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as x{1,}? */
comment|/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* offset is wrong... */
name|repeat
argument_list|(
name|p
argument_list|,
name|start
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|AHEAD
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* ... fix it */
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHEAD
argument_list|(
name|THERE
argument_list|()
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|THERETHERE
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
case|:
comment|/* trivial case */
comment|/* done */
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
name|N
argument_list|)
case|:
comment|/* as x?x{1,n-1} */
comment|/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|AHEAD
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset very wrong... */
name|AHEAD
argument_list|(
name|THERE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* ...so fix it */
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|THERETHERE
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
operator|+
literal|1
argument_list|,
name|finish
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|copy
operator|==
name|finish
operator|+
literal|4
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
literal|1
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as x+ */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
name|N
argument_list|,
name|N
argument_list|)
case|:
comment|/* as xx{m-1,n-1} */
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
name|from
operator|-
literal|1
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
name|N
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as xx{n-1,INF} */
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
name|from
operator|-
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* "can't happen" */
name|SETERROR
argument_list|(
name|REG_ASSERT
argument_list|)
expr_stmt|;
comment|/* just in case */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  - seterr - set an error condition  == static int seterr(register struct parse *p, int e);  */
end_comment

begin_function
specifier|static
name|int
comment|/* useless but makes type checking happy */
DECL|function|seterr (p,e)
name|seterr
parameter_list|(
name|p
parameter_list|,
name|e
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|e
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|error
operator|==
literal|0
condition|)
comment|/* keep earliest error condition */
name|p
operator|->
name|error
operator|=
name|e
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nuls
expr_stmt|;
comment|/* try to bring things to a halt */
name|p
operator|->
name|end
operator|=
name|nuls
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make the return value well-defined */
block|}
end_function

begin_comment
comment|/*  - allocset - allocate a set of characters for []  == static cset *allocset(register struct parse *p);  */
end_comment

begin_function
specifier|static
name|cset
modifier|*
DECL|function|allocset (p)
name|allocset
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|no
init|=
name|p
operator|->
name|g
operator|->
name|ncsets
operator|++
decl_stmt|;
specifier|register
name|size_t
name|nc
decl_stmt|;
specifier|register
name|size_t
name|nbytes
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|no
operator|>=
name|p
operator|->
name|ncsalloc
condition|)
block|{
comment|/* need another column of space */
name|p
operator|->
name|ncsalloc
operator|+=
name|CHAR_BIT
expr_stmt|;
name|nc
operator|=
name|p
operator|->
name|ncsalloc
expr_stmt|;
name|assert
argument_list|(
name|nc
operator|%
name|CHAR_BIT
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|nc
operator|/
name|CHAR_BIT
operator|*
name|css
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|sets
operator|==
name|NULL
condition|)
name|p
operator|->
name|g
operator|->
name|sets
operator|=
operator|(
name|cset
operator|*
operator|)
name|malloc
argument_list|(
name|nc
operator|*
sizeof|sizeof
argument_list|(
name|cset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|g
operator|->
name|sets
operator|=
operator|(
name|cset
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|g
operator|->
name|sets
argument_list|,
name|nc
operator|*
sizeof|sizeof
argument_list|(
name|cset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|setbits
operator|==
name|NULL
condition|)
name|p
operator|->
name|g
operator|->
name|setbits
operator|=
operator|(
name|uch
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|->
name|g
operator|->
name|setbits
operator|=
operator|(
name|uch
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|g
operator|->
name|setbits
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* xxx this isn't right if setbits is now NULL */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|no
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|i
index|]
operator|.
name|ptr
operator|=
name|p
operator|->
name|g
operator|->
name|setbits
operator|+
name|css
operator|*
operator|(
name|i
operator|/
name|CHAR_BIT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|sets
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|g
operator|->
name|setbits
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|g
operator|->
name|setbits
operator|+
operator|(
name|nbytes
operator|-
name|css
operator|)
argument_list|,
literal|0
argument_list|,
name|css
argument_list|)
expr_stmt|;
else|else
block|{
name|no
operator|=
literal|0
expr_stmt|;
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
comment|/* caller's responsibility not to do set ops */
block|}
block|}
name|assert
argument_list|(
name|p
operator|->
name|g
operator|->
name|sets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
name|cs
operator|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|no
index|]
expr_stmt|;
name|cs
operator|->
name|ptr
operator|=
name|p
operator|->
name|g
operator|->
name|setbits
operator|+
name|css
operator|*
operator|(
operator|(
name|no
operator|)
operator|/
name|CHAR_BIT
operator|)
expr_stmt|;
name|cs
operator|->
name|mask
operator|=
literal|1
operator|<<
operator|(
operator|(
name|no
operator|)
operator|%
name|CHAR_BIT
operator|)
expr_stmt|;
name|cs
operator|->
name|hash
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|smultis
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|multis
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|cs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - freeset - free a now-unused set  == static void freeset(register struct parse *p, register cset *cs);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|freeset (p,cs)
name|freeset
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|cset
modifier|*
name|top
init|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|p
operator|->
name|g
operator|->
name|ncsets
index|]
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|css
condition|;
name|i
operator|++
control|)
name|CHsub
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|top
operator|-
literal|1
condition|)
comment|/* recover only the easy case */
name|p
operator|->
name|g
operator|->
name|ncsets
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - freezeset - final processing on a set of characters  == static int freezeset(register struct parse *p, register cset *cs);  *  * The main task here is merging identical sets.  This is usually a waste  * of time (although the hash code minimizes the overhead), but can win  * big if REG_ICASE is being used.  REG_ICASE, by the way, is why the hash  * is done using addition rather than xor -- all ASCII [aA] sets xor to  * the same value!  */
end_comment

begin_function
specifier|static
name|int
comment|/* set number */
DECL|function|freezeset (p,cs)
name|freezeset
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|uch
name|h
init|=
name|cs
operator|->
name|hash
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|cset
modifier|*
name|top
init|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|p
operator|->
name|g
operator|->
name|ncsets
index|]
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs2
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
comment|/* look for an earlier one which is the same */
for|for
control|(
name|cs2
operator|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
literal|0
index|]
init|;
name|cs2
operator|<
name|top
condition|;
name|cs2
operator|++
control|)
if|if
condition|(
name|cs2
operator|->
name|hash
operator|==
name|h
operator|&&
name|cs2
operator|!=
name|cs
condition|)
block|{
comment|/* maybe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|css
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|!
name|CHIN
argument_list|(
name|cs2
argument_list|,
name|i
argument_list|)
operator|!=
operator|!
operator|!
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
break|break;
comment|/* no */
if|if
condition|(
name|i
operator|==
name|css
condition|)
break|break;
comment|/* yes */
block|}
if|if
condition|(
name|cs2
operator|<
name|top
condition|)
block|{
comment|/* found one */
name|freeset
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|cs
operator|=
name|cs2
expr_stmt|;
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|cs
operator|-
name|p
operator|->
name|g
operator|->
name|sets
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - firstch - return first character in a set (which must have at least one)  == static int firstch(register struct parse *p, register cset *cs);  */
end_comment

begin_function
specifier|static
name|int
comment|/* character; there is no "none" value */
DECL|function|firstch (p,cs)
name|firstch
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|css
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
operator|(
name|char
operator|)
name|i
operator|)
return|;
name|assert
argument_list|(
name|never
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* arbitrary */
block|}
end_function

begin_comment
comment|/*  - nch - number of characters in a set  == static int nch(register struct parse *p, register cset *cs);  */
end_comment

begin_function
specifier|static
name|int
DECL|function|nch (p,cs)
name|nch
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|css
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - mcadd - add a collating element to a cset  == static void mcadd(register struct parse *p, register cset *cs, \  ==  register char *cp);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|mcadd (p,cs,cp)
name|mcadd
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|size_t
name|oldend
init|=
name|cs
operator|->
name|smultis
decl_stmt|;
name|cs
operator|->
name|smultis
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|==
name|NULL
condition|)
name|cs
operator|->
name|multis
operator|=
name|malloc
argument_list|(
name|cs
operator|->
name|smultis
argument_list|)
expr_stmt|;
else|else
name|cs
operator|->
name|multis
operator|=
name|realloc
argument_list|(
name|cs
operator|->
name|multis
argument_list|,
name|cs
operator|->
name|smultis
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cs
operator|->
name|multis
operator|+
name|oldend
operator|-
literal|1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cs
operator|->
name|multis
index|[
name|cs
operator|->
name|smultis
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - mcinvert - invert the list of collating elements in a cset  == static void mcinvert(register struct parse *p, register cset *cs);  *  * This would have to know the set of possibilities.  Implementation  * is deferred.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|mcinvert (p,cs)
name|mcinvert
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
name|assert
argument_list|(
name|cs
operator|->
name|multis
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
block|}
end_function

begin_comment
comment|/*  - mccase - add case counterparts of the list of collating elements in a cset  == static void mccase(register struct parse *p, register cset *cs);  *  * This would have to know the set of possibilities.  Implementation  * is deferred.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|mccase (p,cs)
name|mccase
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
name|assert
argument_list|(
name|cs
operator|->
name|multis
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
block|}
end_function

begin_comment
comment|/*  - isinsets - is this character in any sets?  == static int isinsets(register struct re_guts *g, int c);  */
end_comment

begin_function
specifier|static
name|int
comment|/* predicate */
DECL|function|isinsets (g,c)
name|isinsets
parameter_list|(
name|g
parameter_list|,
name|c
parameter_list|)
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|uch
modifier|*
name|col
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ncols
init|=
operator|(
name|g
operator|->
name|ncsets
operator|+
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|/
name|CHAR_BIT
decl_stmt|;
specifier|register
name|unsigned
name|uc
init|=
operator|(
name|unsigned
name|char
operator|)
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|col
operator|=
name|g
operator|->
name|setbits
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
operator|,
name|col
operator|+=
name|g
operator|->
name|csetsize
control|)
if|if
condition|(
name|col
index|[
name|uc
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - samesets - are these two characters in exactly the same sets?  == static int samesets(register struct re_guts *g, int c1, int c2);  */
end_comment

begin_function
specifier|static
name|int
comment|/* predicate */
DECL|function|samesets (g,c1,c2)
name|samesets
parameter_list|(
name|g
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
name|int
name|c1
decl_stmt|;
name|int
name|c2
decl_stmt|;
block|{
specifier|register
name|uch
modifier|*
name|col
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ncols
init|=
operator|(
name|g
operator|->
name|ncsets
operator|+
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|/
name|CHAR_BIT
decl_stmt|;
specifier|register
name|unsigned
name|uc1
init|=
operator|(
name|unsigned
name|char
operator|)
name|c1
decl_stmt|;
specifier|register
name|unsigned
name|uc2
init|=
operator|(
name|unsigned
name|char
operator|)
name|c2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|col
operator|=
name|g
operator|->
name|setbits
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
operator|,
name|col
operator|+=
name|g
operator|->
name|csetsize
control|)
if|if
condition|(
name|col
index|[
name|uc1
index|]
operator|!=
name|col
index|[
name|uc2
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - categorize - sort out character categories  == static void categorize(struct parse *p, register struct re_guts *g);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|categorize (p,g)
name|categorize
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
specifier|register
name|cat_t
modifier|*
name|cats
init|=
name|g
operator|->
name|categories
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|c2
decl_stmt|;
specifier|register
name|cat_t
name|cat
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
name|CHAR_MIN
init|;
name|c
operator|<=
name|CHAR_MAX
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|cats
index|[
name|c
index|]
operator|==
literal|0
operator|&&
name|isinsets
argument_list|(
name|g
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|cat
operator|=
name|g
operator|->
name|ncategories
operator|++
expr_stmt|;
name|cats
index|[
name|c
index|]
operator|=
name|cat
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c
operator|+
literal|1
init|;
name|c2
operator|<=
name|CHAR_MAX
condition|;
name|c2
operator|++
control|)
if|if
condition|(
name|cats
index|[
name|c2
index|]
operator|==
literal|0
operator|&&
name|samesets
argument_list|(
name|g
argument_list|,
name|c
argument_list|,
name|c2
argument_list|)
condition|)
name|cats
index|[
name|c2
index|]
operator|=
name|cat
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - dupl - emit a duplicate of a bunch of sops  == static sopno dupl(register struct parse *p, sopno start, sopno finish);  */
end_comment

begin_function
specifier|static
name|sopno
comment|/* start of duplicate */
DECL|function|dupl (p,start,finish)
name|dupl
parameter_list|(
name|p
parameter_list|,
name|start
parameter_list|,
name|finish
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sopno
name|start
decl_stmt|;
comment|/* from here */
name|sopno
name|finish
decl_stmt|;
comment|/* to this less one */
block|{
specifier|register
name|sopno
name|ret
init|=
name|HERE
argument_list|()
decl_stmt|;
specifier|register
name|sopno
name|len
init|=
name|finish
operator|-
name|start
decl_stmt|;
name|assert
argument_list|(
name|finish
operator|>=
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|enlarge
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ssize
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* this many unexpected additions */
name|assert
argument_list|(
name|p
operator|->
name|ssize
operator|>=
name|p
operator|->
name|slen
operator|+
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|strip
operator|+
name|p
operator|->
name|slen
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|strip
operator|+
name|start
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|len
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|slen
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - doemit - emit a strip operator  == static void doemit(register struct parse *p, sop op, size_t opnd);  *  * It might seem better to implement this as a macro with a function as  * hard-case backup, but it's just too big and messy unless there are  * some changes to the data structures.  Maybe later.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|doemit (p,op,opnd)
name|doemit
parameter_list|(
name|p
parameter_list|,
name|op
parameter_list|,
name|opnd
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sop
name|op
decl_stmt|;
name|size_t
name|opnd
decl_stmt|;
block|{
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* deal with oversize operands ("can't happen", more or less) */
name|assert
argument_list|(
name|opnd
operator|<
literal|1
operator|<<
name|OPSHIFT
argument_list|)
expr_stmt|;
comment|/* deal with undersized strip */
if|if
condition|(
name|p
operator|->
name|slen
operator|>=
name|p
operator|->
name|ssize
condition|)
name|enlarge
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|ssize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* +50% */
name|assert
argument_list|(
name|p
operator|->
name|slen
operator|<
name|p
operator|->
name|ssize
argument_list|)
expr_stmt|;
comment|/* finally, it's all reduced to the easy case */
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|slen
operator|++
index|]
operator|=
name|SOP
argument_list|(
name|op
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - doinsert - insert a sop into the strip  == static void doinsert(register struct parse *p, sop op, size_t opnd, sopno pos);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|doinsert (p,op,opnd,pos)
name|doinsert
parameter_list|(
name|p
parameter_list|,
name|op
parameter_list|,
name|opnd
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sop
name|op
decl_stmt|;
name|size_t
name|opnd
decl_stmt|;
name|sopno
name|pos
decl_stmt|;
block|{
specifier|register
name|sopno
name|sn
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|sn
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|op
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
comment|/* do checks, ensure space */
name|assert
argument_list|(
name|HERE
argument_list|()
operator|==
name|sn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|strip
index|[
name|sn
index|]
expr_stmt|;
comment|/* adjust paren pointers */
name|assert
argument_list|(
name|pos
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NPAREN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|>=
name|pos
condition|)
block|{
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|>=
name|pos
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|strip
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|strip
index|[
name|pos
index|]
argument_list|,
operator|(
name|HERE
argument_list|()
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|strip
index|[
name|pos
index|]
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - dofwd - complete a forward reference  == static void dofwd(register struct parse *p, sopno pos, sop value);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|dofwd (p,pos,value)
name|dofwd
parameter_list|(
name|p
parameter_list|,
name|pos
parameter_list|,
name|value
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|sopno
name|pos
decl_stmt|;
name|sop
name|value
decl_stmt|;
block|{
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|value
operator|<
literal|1
operator|<<
name|OPSHIFT
argument_list|)
expr_stmt|;
name|p
operator|->
name|strip
index|[
name|pos
index|]
operator|=
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|pos
index|]
argument_list|)
operator||
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - enlarge - enlarge the strip  == static void enlarge(register struct parse *p, sopno size);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|enlarge (p,size)
name|enlarge
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|sopno
name|size
decl_stmt|;
block|{
specifier|register
name|sop
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|ssize
operator|>=
name|size
condition|)
return|return;
name|sp
operator|=
operator|(
name|sop
operator|*
operator|)
name|realloc
argument_list|(
name|p
operator|->
name|strip
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|strip
operator|=
name|sp
expr_stmt|;
name|p
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - stripsnug - compact the strip  == static void stripsnug(register struct parse *p, register struct re_guts *g);  */
end_comment

begin_function
specifier|static
name|void
DECL|function|stripsnug (p,g)
name|stripsnug
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
name|g
operator|->
name|nstates
operator|=
name|p
operator|->
name|slen
expr_stmt|;
name|g
operator|->
name|strip
operator|=
operator|(
name|sop
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|strip
argument_list|,
name|p
operator|->
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|strip
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
name|g
operator|->
name|strip
operator|=
name|p
operator|->
name|strip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - findmust - fill in must and mlen with longest mandatory literal string  == static void findmust(register struct parse *p, register struct re_guts *g);  *  * This algorithm could do fancy things like analyzing the operands of |  * for common subsequences.  Someday.  This code is simple and finds most  * of the interesting cases.  *  * Note that must and mlen got initialized during setup.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|findmust (p,g)
name|findmust
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
specifier|register
name|sop
modifier|*
name|scan
decl_stmt|;
name|sop
modifier|*
name|start
init|=
name|NULL
decl_stmt|;
specifier|register
name|sop
modifier|*
name|newstart
init|=
name|NULL
decl_stmt|;
specifier|register
name|sopno
name|newlen
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|sopno
name|i
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* find the longest OCHAR sequence in strip */
name|newlen
operator|=
literal|0
expr_stmt|;
name|scan
operator|=
name|g
operator|->
name|strip
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OCHAR
case|:
comment|/* sequence member */
if|if
condition|(
name|newlen
operator|==
literal|0
condition|)
comment|/* new sequence */
name|newstart
operator|=
name|scan
operator|-
literal|1
expr_stmt|;
name|newlen
operator|++
expr_stmt|;
break|break;
case|case
name|OPLUS_
case|:
comment|/* things that don't break one */
case|case
name|OLPAREN
case|:
case|case
name|ORPAREN
case|:
break|break;
case|case
name|OQUEST_
case|:
comment|/* things that must be skipped */
case|case
name|OCH_
case|:
name|scan
operator|--
expr_stmt|;
do|do
block|{
name|scan
operator|+=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|scan
expr_stmt|;
comment|/* assert() interferes w debug printouts */
if|if
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OOR2
condition|)
block|{
name|g
operator|->
name|iflags
operator||=
name|BAD
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
condition|)
do|;
comment|/* fallthrough */
default|default:
comment|/* things that break a sequence */
if|if
condition|(
name|newlen
operator|>
name|g
operator|->
name|mlen
condition|)
block|{
comment|/* ends one */
name|start
operator|=
name|newstart
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
name|newlen
expr_stmt|;
block|}
name|newlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OEND
condition|)
do|;
if|if
condition|(
name|g
operator|->
name|mlen
operator|==
literal|0
condition|)
comment|/* there isn't one */
return|return;
comment|/* turn it into a character string */
name|g
operator|->
name|must
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|g
operator|->
name|mlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|must
operator|==
name|NULL
condition|)
block|{
comment|/* argh; just forget it */
name|g
operator|->
name|mlen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|g
operator|->
name|must
expr_stmt|;
name|scan
operator|=
name|start
expr_stmt|;
for|for
control|(
name|i
operator|=
name|g
operator|->
name|mlen
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
name|OP
argument_list|(
name|s
operator|=
operator|*
name|scan
operator|++
argument_list|)
operator|!=
name|OCHAR
condition|)
continue|continue;
name|assert
argument_list|(
name|cp
operator|<
name|g
operator|->
name|must
operator|+
name|g
operator|->
name|mlen
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|cp
operator|==
name|g
operator|->
name|must
operator|+
name|g
operator|->
name|mlen
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* just on general principles */
block|}
end_function

begin_comment
comment|/*  - pluscount - count + nesting  == static sopno pluscount(register struct parse *p, register struct re_guts *g);  */
end_comment

begin_function
specifier|static
name|sopno
comment|/* nesting depth */
DECL|function|pluscount (p,g)
name|pluscount
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
specifier|register
name|sop
modifier|*
name|scan
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|sopno
name|plusnest
init|=
literal|0
decl_stmt|;
specifier|register
name|sopno
name|maxnest
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* there may not be an OEND */
name|scan
operator|=
name|g
operator|->
name|strip
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OPLUS_
case|:
name|plusnest
operator|++
expr_stmt|;
break|break;
case|case
name|O_PLUS
case|:
if|if
condition|(
name|plusnest
operator|>
name|maxnest
condition|)
name|maxnest
operator|=
name|plusnest
expr_stmt|;
name|plusnest
operator|--
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OEND
condition|)
do|;
if|if
condition|(
name|plusnest
operator|!=
literal|0
condition|)
name|g
operator|->
name|iflags
operator||=
name|BAD
expr_stmt|;
return|return
operator|(
name|maxnest
operator|)
return|;
block|}
end_function

end_unit

