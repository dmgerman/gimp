begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The matching engine and friends.  This file is #included by regexec.c  * after suitable #defines of a variety of macros used herein, so that  * different state representations can be used without duplicating masses  * of code.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SNAMES
end_ifdef

begin_define
DECL|macro|matcher
define|#
directive|define
name|matcher
value|smatcher
end_define

begin_define
DECL|macro|fast
define|#
directive|define
name|fast
value|sfast
end_define

begin_define
DECL|macro|slow
define|#
directive|define
name|slow
value|sslow
end_define

begin_define
DECL|macro|dissect
define|#
directive|define
name|dissect
value|sdissect
end_define

begin_define
DECL|macro|backref
define|#
directive|define
name|backref
value|sbackref
end_define

begin_define
DECL|macro|step
define|#
directive|define
name|step
value|sstep
end_define

begin_define
DECL|macro|print
define|#
directive|define
name|print
value|sprint
end_define

begin_define
DECL|macro|at
define|#
directive|define
name|at
value|sat
end_define

begin_define
DECL|macro|match
define|#
directive|define
name|match
value|smat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LNAMES
end_ifdef

begin_define
DECL|macro|matcher
define|#
directive|define
name|matcher
value|lmatcher
end_define

begin_define
DECL|macro|fast
define|#
directive|define
name|fast
value|lfast
end_define

begin_define
DECL|macro|slow
define|#
directive|define
name|slow
value|lslow
end_define

begin_define
DECL|macro|dissect
define|#
directive|define
name|dissect
value|ldissect
end_define

begin_define
DECL|macro|backref
define|#
directive|define
name|backref
value|lbackref
end_define

begin_define
DECL|macro|step
define|#
directive|define
name|step
value|lstep
end_define

begin_define
DECL|macro|print
define|#
directive|define
name|print
value|lprint
end_define

begin_define
DECL|macro|at
define|#
directive|define
name|at
value|lat
end_define

begin_define
DECL|macro|match
define|#
directive|define
name|match
value|lmat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* another structure passed up and down to avoid zillions of parameters */
end_comment

begin_struct
DECL|struct|match
struct|struct
name|match
block|{
DECL|member|g
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
DECL|member|eflags
name|int
name|eflags
decl_stmt|;
DECL|member|pmatch
name|regmatch_t
modifier|*
name|pmatch
decl_stmt|;
comment|/* [nsub+1] (0 element unused) */
DECL|member|offp
name|char
modifier|*
name|offp
decl_stmt|;
comment|/* offsets work from here */
DECL|member|beginp
name|char
modifier|*
name|beginp
decl_stmt|;
comment|/* start of string -- virtual NUL precedes */
DECL|member|endp
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* end of string -- virtual NUL here */
DECL|member|coldp
name|char
modifier|*
name|coldp
decl_stmt|;
comment|/* can be no match starting before here */
DECL|member|lastpos
name|char
modifier|*
modifier|*
name|lastpos
decl_stmt|;
comment|/* [nplus+1] */
name|STATEVARS
expr_stmt|;
DECL|member|st
name|states
name|st
decl_stmt|;
comment|/* current states */
DECL|member|fresh
name|states
name|fresh
decl_stmt|;
comment|/* states for a fresh start */
DECL|member|tmp
name|states
name|tmp
decl_stmt|;
comment|/* temporary */
DECL|member|empty
name|states
name|empty
decl_stmt|;
comment|/* empty set of states */
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"engine.ih"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|REDEBUG
end_ifdef

begin_define
DECL|macro|SP (t,s,c)
define|#
directive|define
name|SP
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
value|print(m, t, s, c, stdout)
end_define

begin_define
DECL|macro|AT (t,p1,p2,s1,s2)
define|#
directive|define
name|AT
parameter_list|(
name|t
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
value|at(m, t, p1, p2, s1, s2)
end_define

begin_define
DECL|macro|NOTE (str)
define|#
directive|define
name|NOTE
parameter_list|(
name|str
parameter_list|)
value|{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|SP (t,s,c)
define|#
directive|define
name|SP
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
end_define

begin_comment
DECL|macro|SP (t,s,c)
comment|/* nothing */
end_comment

begin_define
DECL|macro|AT (t,p1,p2,s1,s2)
define|#
directive|define
name|AT
parameter_list|(
name|t
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
end_define

begin_comment
DECL|macro|AT (t,p1,p2,s1,s2)
comment|/* nothing */
end_comment

begin_define
DECL|macro|NOTE (s)
define|#
directive|define
name|NOTE
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
DECL|macro|NOTE (s)
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  - matcher - the actual matching engine  == static int matcher(register struct re_guts *g, char *string, \  ==	size_t nmatch, regmatch_t pmatch[], int eflags);  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 success, REG_NOMATCH failure */
DECL|function|matcher (g,string,nmatch,pmatch,eflags)
name|matcher
parameter_list|(
name|g
parameter_list|,
name|string
parameter_list|,
name|nmatch
parameter_list|,
name|pmatch
parameter_list|,
name|eflags
parameter_list|)
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|regmatch_t
name|pmatch
index|[]
decl_stmt|;
name|int
name|eflags
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|endp
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|match
name|mv
decl_stmt|;
specifier|register
name|struct
name|match
modifier|*
name|m
init|=
operator|&
name|mv
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
specifier|const
name|sopno
name|gf
init|=
name|g
operator|->
name|firststate
operator|+
literal|1
decl_stmt|;
comment|/* +1 for OEND */
specifier|register
specifier|const
name|sopno
name|gl
init|=
name|g
operator|->
name|laststate
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|stop
decl_stmt|;
comment|/* simplify the situation where possible */
if|if
condition|(
name|g
operator|->
name|cflags
operator|&
name|REG_NOSUB
condition|)
name|nmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|REG_STARTEND
condition|)
block|{
name|start
operator|=
name|string
operator|+
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
name|stop
operator|=
name|string
operator|+
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|string
expr_stmt|;
name|stop
operator|=
name|start
operator|+
name|strlen
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop
operator|<
name|start
condition|)
return|return
operator|(
name|REG_INVARG
operator|)
return|;
comment|/* prescreening; this does wonders for this rather slow code */
if|if
condition|(
name|g
operator|->
name|must
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|start
init|;
name|dp
operator|<
name|stop
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|*
name|dp
operator|==
name|g
operator|->
name|must
index|[
literal|0
index|]
operator|&&
name|stop
operator|-
name|dp
operator|>=
name|g
operator|->
name|mlen
operator|&&
name|memcmp
argument_list|(
name|dp
argument_list|,
name|g
operator|->
name|must
argument_list|,
operator|(
name|size_t
operator|)
name|g
operator|->
name|mlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dp
operator|==
name|stop
condition|)
comment|/* we didn't find g->must */
return|return
operator|(
name|REG_NOMATCH
operator|)
return|;
block|}
comment|/* match struct setup */
name|m
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|m
operator|->
name|eflags
operator|=
name|eflags
expr_stmt|;
name|m
operator|->
name|pmatch
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|lastpos
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|offp
operator|=
name|string
expr_stmt|;
name|m
operator|->
name|beginp
operator|=
name|start
expr_stmt|;
name|m
operator|->
name|endp
operator|=
name|stop
expr_stmt|;
name|STATESETUP
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|SETUP
argument_list|(
name|m
operator|->
name|st
argument_list|)
expr_stmt|;
name|SETUP
argument_list|(
name|m
operator|->
name|fresh
argument_list|)
expr_stmt|;
name|SETUP
argument_list|(
name|m
operator|->
name|tmp
argument_list|)
expr_stmt|;
name|SETUP
argument_list|(
name|m
operator|->
name|empty
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|m
operator|->
name|empty
argument_list|)
expr_stmt|;
comment|/* this loop does only one repetition except for backrefs */
for|for
control|(
init|;
condition|;
control|)
block|{
name|endp
operator|=
name|fast
argument_list|(
name|m
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|gf
argument_list|,
name|gl
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|NULL
condition|)
block|{
comment|/* a miss */
name|STATETEARDOWN
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_NOMATCH
operator|)
return|;
block|}
if|if
condition|(
name|nmatch
operator|==
literal|0
operator|&&
operator|!
name|g
operator|->
name|backrefs
condition|)
break|break;
comment|/* no further info needed */
comment|/* where? */
name|assert
argument_list|(
name|m
operator|->
name|coldp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|NOTE
argument_list|(
literal|"finding start"
argument_list|)
expr_stmt|;
name|endp
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|coldp
argument_list|,
name|stop
argument_list|,
name|gf
argument_list|,
name|gl
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
break|break;
name|assert
argument_list|(
name|m
operator|->
name|coldp
operator|<
name|m
operator|->
name|endp
argument_list|)
expr_stmt|;
name|m
operator|->
name|coldp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nmatch
operator|==
literal|1
operator|&&
operator|!
name|g
operator|->
name|backrefs
condition|)
break|break;
comment|/* no further info needed */
comment|/* oh my, he wants the subexpressions... */
if|if
condition|(
name|m
operator|->
name|pmatch
operator|==
name|NULL
condition|)
name|m
operator|->
name|pmatch
operator|=
operator|(
name|regmatch_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|m
operator|->
name|g
operator|->
name|nsub
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pmatch
operator|==
name|NULL
condition|)
block|{
name|STATETEARDOWN
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
condition|;
name|i
operator|++
control|)
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|=
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|g
operator|->
name|backrefs
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_BACKR
operator|)
condition|)
block|{
name|NOTE
argument_list|(
literal|"dissecting"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dissect
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|coldp
argument_list|,
name|endp
argument_list|,
name|gf
argument_list|,
name|gl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|g
operator|->
name|nplus
operator|>
literal|0
operator|&&
name|m
operator|->
name|lastpos
operator|==
name|NULL
condition|)
name|m
operator|->
name|lastpos
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|g
operator|->
name|nplus
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|nplus
operator|>
literal|0
operator|&&
name|m
operator|->
name|lastpos
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|m
operator|->
name|pmatch
argument_list|)
expr_stmt|;
name|STATETEARDOWN
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
block|}
name|NOTE
argument_list|(
literal|"backref dissect"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|coldp
argument_list|,
name|endp
argument_list|,
name|gf
argument_list|,
name|gl
argument_list|,
operator|(
name|sopno
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
break|break;
comment|/* uh-oh... we couldn't find a subexpression-level match */
name|assert
argument_list|(
name|g
operator|->
name|backrefs
argument_list|)
expr_stmt|;
comment|/* must be back references doing it */
name|assert
argument_list|(
name|g
operator|->
name|nplus
operator|==
literal|0
operator|||
name|m
operator|->
name|lastpos
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|||
name|endp
operator|<=
name|m
operator|->
name|coldp
condition|)
break|break;
comment|/* defeat */
name|NOTE
argument_list|(
literal|"backoff"
argument_list|)
expr_stmt|;
name|endp
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|coldp
argument_list|,
name|endp
operator|-
literal|1
argument_list|,
name|gf
argument_list|,
name|gl
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|NULL
condition|)
break|break;
comment|/* defeat */
comment|/* try it on a shorter possibility */
ifndef|#
directive|ifndef
name|NDEBUG
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|NOTE
argument_list|(
literal|"backoff dissect"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|coldp
argument_list|,
name|endp
argument_list|,
name|gf
argument_list|,
name|gl
argument_list|,
operator|(
name|sopno
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|dp
operator|==
name|NULL
operator|||
name|dp
operator|==
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
comment|/* found a shorter one */
break|break;
comment|/* despite initial appearances, there is no match here */
name|NOTE
argument_list|(
literal|"false alarm"
argument_list|)
expr_stmt|;
name|start
operator|=
name|m
operator|->
name|coldp
operator|+
literal|1
expr_stmt|;
comment|/* recycle starting later */
name|assert
argument_list|(
name|start
operator|<=
name|stop
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the details if requested */
if|if
condition|(
name|nmatch
operator|>
literal|0
condition|)
block|{
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
name|m
operator|->
name|coldp
operator|-
name|m
operator|->
name|offp
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|endp
operator|-
name|m
operator|->
name|offp
expr_stmt|;
block|}
if|if
condition|(
name|nmatch
operator|>
literal|1
condition|)
block|{
name|assert
argument_list|(
name|m
operator|->
name|pmatch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nmatch
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
condition|)
name|pmatch
index|[
name|i
index|]
operator|=
name|m
operator|->
name|pmatch
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|=
operator|-
literal|1
expr_stmt|;
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|pmatch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|pmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|lastpos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|lastpos
argument_list|)
expr_stmt|;
name|STATETEARDOWN
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - dissect - figure out what matched what, no back references  == static char *dissect(register struct match *m, char *start, \  ==	char *stop, sopno startst, sopno stopst);  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* == stop (success) always */
DECL|function|dissect (m,start,stop,startst,stopst)
name|dissect
parameter_list|(
name|m
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|startst
parameter_list|,
name|stopst
parameter_list|)
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|stop
decl_stmt|;
name|sopno
name|startst
decl_stmt|;
name|sopno
name|stopst
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|sopno
name|ss
decl_stmt|;
comment|/* start sop of current subRE */
specifier|register
name|sopno
name|es
decl_stmt|;
comment|/* end sop of current subRE */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* start of string matched by it */
specifier|register
name|char
modifier|*
name|stp
decl_stmt|;
comment|/* string matched by it cannot pass here */
specifier|register
name|char
modifier|*
name|rest
decl_stmt|;
comment|/* start of rest of string */
specifier|register
name|char
modifier|*
name|tail
decl_stmt|;
comment|/* string unmatched by rest of RE */
specifier|register
name|sopno
name|ssub
decl_stmt|;
comment|/* start sop of subsubRE */
specifier|register
name|sopno
name|esub
decl_stmt|;
comment|/* end sop of subsubRE */
specifier|register
name|char
modifier|*
name|ssp
decl_stmt|;
comment|/* start of string matched by subsubRE */
specifier|register
name|char
modifier|*
name|sep
decl_stmt|;
comment|/* end of string matched by subsubRE */
specifier|register
name|char
modifier|*
name|oldssp
decl_stmt|;
comment|/* previous ssp */
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|AT
argument_list|(
literal|"diss"
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
name|sp
operator|=
name|start
expr_stmt|;
for|for
control|(
name|ss
operator|=
name|startst
init|;
name|ss
operator|<
name|stopst
condition|;
name|ss
operator|=
name|es
control|)
block|{
comment|/* identify end of subRE */
name|es
operator|=
name|ss
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|es
index|]
argument_list|)
condition|)
block|{
case|case
name|OPLUS_
case|:
case|case
name|OQUEST_
case|:
name|es
operator|+=
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|es
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCH_
case|:
while|while
condition|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|es
index|]
argument_list|)
operator|!=
name|O_CH
condition|)
name|es
operator|+=
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|es
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|es
operator|++
expr_stmt|;
comment|/* figure out what it matched */
switch|switch
condition|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
argument_list|)
condition|)
block|{
case|case
name|OEND
case|:
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCHAR
case|:
name|sp
operator|++
expr_stmt|;
break|break;
case|case
name|OBOL
case|:
case|case
name|OEOL
case|:
case|case
name|OBOW
case|:
case|case
name|OEOW
case|:
break|break;
case|case
name|OANY
case|:
case|case
name|OANYOF
case|:
name|sp
operator|++
expr_stmt|;
break|break;
case|case
name|OBACK_
case|:
case|case
name|O_BACK
case|:
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
break|break;
comment|/* cases where length of match is hard to find */
case|case
name|OQUEST_
case|:
name|stp
operator|=
name|stop
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* how long could this one be? */
name|rest
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stp
argument_list|,
name|ss
argument_list|,
name|es
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* it did match */
comment|/* could the rest match the rest? */
name|tail
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|rest
argument_list|,
name|stop
argument_list|,
name|es
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|stop
condition|)
break|break;
comment|/* yes! */
comment|/* no -- try a shorter match for this one */
name|stp
operator|=
name|rest
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|stp
operator|>=
name|sp
argument_list|)
expr_stmt|;
comment|/* it did work */
block|}
name|ssub
operator|=
name|ss
operator|+
literal|1
expr_stmt|;
name|esub
operator|=
name|es
operator|-
literal|1
expr_stmt|;
comment|/* did innards match? */
if|if
condition|(
name|slow
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|rest
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|=
name|dissect
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|rest
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dp
operator|==
name|rest
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* no */
name|assert
argument_list|(
name|sp
operator|==
name|rest
argument_list|)
expr_stmt|;
name|sp
operator|=
name|rest
expr_stmt|;
break|break;
case|case
name|OPLUS_
case|:
name|stp
operator|=
name|stop
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* how long could this one be? */
name|rest
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stp
argument_list|,
name|ss
argument_list|,
name|es
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* it did match */
comment|/* could the rest match the rest? */
name|tail
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|rest
argument_list|,
name|stop
argument_list|,
name|es
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|stop
condition|)
break|break;
comment|/* yes! */
comment|/* no -- try a shorter match for this one */
name|stp
operator|=
name|rest
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|stp
operator|>=
name|sp
argument_list|)
expr_stmt|;
comment|/* it did work */
block|}
name|ssub
operator|=
name|ss
operator|+
literal|1
expr_stmt|;
name|esub
operator|=
name|es
operator|-
literal|1
expr_stmt|;
name|ssp
operator|=
name|sp
expr_stmt|;
name|oldssp
operator|=
name|ssp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* find last match of innards */
name|sep
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|ssp
argument_list|,
name|rest
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
name|NULL
operator|||
name|sep
operator|==
name|ssp
condition|)
break|break;
comment|/* failed or matched null */
name|oldssp
operator|=
name|ssp
expr_stmt|;
comment|/* on to next try */
name|ssp
operator|=
name|sep
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|==
name|NULL
condition|)
block|{
comment|/* last successful match */
name|sep
operator|=
name|ssp
expr_stmt|;
name|ssp
operator|=
name|oldssp
expr_stmt|;
block|}
name|assert
argument_list|(
name|sep
operator|==
name|rest
argument_list|)
expr_stmt|;
comment|/* must exhaust substring */
name|assert
argument_list|(
name|slow
argument_list|(
name|m
argument_list|,
name|ssp
argument_list|,
name|sep
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
operator|==
name|rest
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dissect
argument_list|(
name|m
argument_list|,
name|ssp
argument_list|,
name|sep
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dp
operator|==
name|sep
argument_list|)
expr_stmt|;
name|sp
operator|=
name|rest
expr_stmt|;
break|break;
case|case
name|OCH_
case|:
name|stp
operator|=
name|stop
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* how long could this one be? */
name|rest
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stp
argument_list|,
name|ss
argument_list|,
name|es
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* it did match */
comment|/* could the rest match the rest? */
name|tail
operator|=
name|slow
argument_list|(
name|m
argument_list|,
name|rest
argument_list|,
name|stop
argument_list|,
name|es
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|stop
condition|)
break|break;
comment|/* yes! */
comment|/* no -- try a shorter match for this one */
name|stp
operator|=
name|rest
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|stp
operator|>=
name|sp
argument_list|)
expr_stmt|;
comment|/* it did work */
block|}
name|ssub
operator|=
name|ss
operator|+
literal|1
expr_stmt|;
name|esub
operator|=
name|ss
operator|+
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* find first matching branch */
if|if
condition|(
name|slow
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|rest
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
operator|==
name|rest
condition|)
break|break;
comment|/* it matched all of it */
comment|/* that one missed, try next one */
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR1
argument_list|)
expr_stmt|;
name|esub
operator|++
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR2
argument_list|)
expr_stmt|;
name|ssub
operator|=
name|esub
operator|+
literal|1
expr_stmt|;
name|esub
operator|+=
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR2
condition|)
name|esub
operator|--
expr_stmt|;
else|else
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|O_CH
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
name|dissect
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|rest
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dp
operator|==
name|rest
argument_list|)
expr_stmt|;
name|sp
operator|=
name|rest
expr_stmt|;
break|break;
case|case
name|O_PLUS
case|:
case|case
name|O_QUEST
case|:
case|case
name|OOR1
case|:
case|case
name|OOR2
case|:
case|case
name|O_CH
case|:
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLPAREN
case|:
name|i
operator|=
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|=
name|sp
operator|-
name|m
operator|->
name|offp
expr_stmt|;
break|break;
case|case
name|ORPAREN
case|:
name|i
operator|=
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|=
name|sp
operator|-
name|m
operator|->
name|offp
expr_stmt|;
break|break;
default|default:
comment|/* uh oh */
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|assert
argument_list|(
name|sp
operator|==
name|stop
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - backref - figure out what matched what, figuring in back references  == static char *backref(register struct match *m, char *start, \  ==	char *stop, sopno startst, sopno stopst, sopno lev);  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* == stop (success) or NULL (failure) */
DECL|function|backref (m,start,stop,startst,stopst,lev)
name|backref
parameter_list|(
name|m
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|startst
parameter_list|,
name|stopst
parameter_list|,
name|lev
parameter_list|)
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|stop
decl_stmt|;
name|sopno
name|startst
decl_stmt|;
name|sopno
name|stopst
decl_stmt|;
name|sopno
name|lev
decl_stmt|;
comment|/* PLUS nesting level */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|sopno
name|ss
decl_stmt|;
comment|/* start sop of current subRE */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* start of string matched by it */
specifier|register
name|sopno
name|ssub
decl_stmt|;
comment|/* start sop of subsubRE */
specifier|register
name|sopno
name|esub
decl_stmt|;
comment|/* end sop of subsubRE */
specifier|register
name|char
modifier|*
name|ssp
decl_stmt|;
comment|/* start of string matched by subsubRE */
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
specifier|register
name|int
name|hard
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|regoff_t
name|offsave
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
name|AT
argument_list|(
literal|"back"
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
name|sp
operator|=
name|start
expr_stmt|;
comment|/* get as far as we can with easy stuff */
name|hard
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ss
operator|=
name|startst
init|;
operator|!
name|hard
operator|&&
name|ss
operator|<
name|stopst
condition|;
name|ss
operator|++
control|)
switch|switch
condition|(
name|OP
argument_list|(
name|s
operator|=
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
argument_list|)
condition|)
block|{
case|case
name|OCHAR
case|:
if|if
condition|(
name|sp
operator|==
name|stop
operator|||
operator|*
name|sp
operator|++
operator|!=
operator|(
name|char
operator|)
name|OPND
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|OANY
case|:
if|if
condition|(
name|sp
operator|==
name|stop
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
name|OANYOF
case|:
name|cs
operator|=
operator|&
name|m
operator|->
name|g
operator|->
name|sets
index|[
name|OPND
argument_list|(
name|s
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|stop
operator|||
operator|!
name|CHIN
argument_list|(
name|cs
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|OBOL
case|:
if|if
condition|(
operator|(
name|sp
operator|==
name|m
operator|->
name|beginp
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTBOL
operator|)
operator|)
operator|||
operator|(
name|sp
operator|<
name|m
operator|->
name|endp
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
literal|'\n'
operator|&&
operator|(
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|)
condition|)
block|{
comment|/* yes */
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|OEOL
case|:
if|if
condition|(
operator|(
name|sp
operator|==
name|m
operator|->
name|endp
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTEOL
operator|)
operator|)
operator|||
operator|(
name|sp
operator|<
name|m
operator|->
name|endp
operator|&&
operator|*
name|sp
operator|==
literal|'\n'
operator|&&
operator|(
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|)
condition|)
block|{
comment|/* yes */
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|OBOW
case|:
if|if
condition|(
operator|(
operator|(
name|sp
operator|==
name|m
operator|->
name|beginp
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTBOL
operator|)
operator|)
operator|||
operator|(
name|sp
operator|<
name|m
operator|->
name|endp
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
literal|'\n'
operator|&&
operator|(
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|)
operator|||
operator|(
name|sp
operator|>
name|m
operator|->
name|beginp
operator|&&
operator|!
name|ISWORD
argument_list|(
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|sp
operator|<
name|m
operator|->
name|endp
operator|&&
name|ISWORD
argument_list|(
operator|*
name|sp
argument_list|)
operator|)
condition|)
block|{
comment|/* yes */
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|OEOW
case|:
if|if
condition|(
operator|(
operator|(
name|sp
operator|==
name|m
operator|->
name|endp
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTEOL
operator|)
operator|)
operator|||
operator|(
name|sp
operator|<
name|m
operator|->
name|endp
operator|&&
operator|*
name|sp
operator|==
literal|'\n'
operator|&&
operator|(
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|)
operator|||
operator|(
name|sp
operator|<
name|m
operator|->
name|endp
operator|&&
operator|!
name|ISWORD
argument_list|(
operator|*
name|sp
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|sp
operator|>
name|m
operator|->
name|beginp
operator|&&
name|ISWORD
argument_list|(
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
comment|/* yes */
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|O_QUEST
case|:
break|break;
case|case
name|OOR1
case|:
comment|/* matches null but needs to skip */
name|ss
operator|++
expr_stmt|;
name|s
operator|=
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
expr_stmt|;
do|do
block|{
name|assert
argument_list|(
name|OP
argument_list|(
name|s
argument_list|)
operator|==
name|OOR2
argument_list|)
expr_stmt|;
name|ss
operator|+=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
operator|=
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
argument_list|)
operator|!=
name|O_CH
condition|)
do|;
comment|/* note that the ss++ gets us past the O_CH */
break|break;
default|default:
comment|/* have to make a choice */
name|hard
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|hard
condition|)
block|{
comment|/* that was it! */
if|if
condition|(
name|sp
operator|!=
name|stop
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
name|ss
operator|--
expr_stmt|;
comment|/* adjust for the for's final increment */
comment|/* the hard stuff */
name|AT
argument_list|(
literal|"hard"
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OBACK_
case|:
comment|/* the vilest depths */
name|i
operator|=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|-
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
expr_stmt|;
name|assert
argument_list|(
name|stop
operator|-
name|m
operator|->
name|beginp
operator|>=
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|>
name|stop
operator|-
name|len
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* not enough left to match */
name|ssp
operator|=
name|m
operator|->
name|offp
operator|+
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|sp
argument_list|,
name|ssp
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|ss
index|]
operator|!=
name|SOP
argument_list|(
name|O_BACK
argument_list|,
name|i
argument_list|)
condition|)
name|ss
operator|++
expr_stmt|;
return|return
operator|(
name|backref
argument_list|(
name|m
argument_list|,
name|sp
operator|+
name|len
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
argument_list|)
operator|)
return|;
break|break;
case|case
name|OQUEST_
case|:
comment|/* to null or not */
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dp
operator|)
return|;
comment|/* not */
return|return
operator|(
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
name|OPND
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
argument_list|)
operator|)
return|;
break|break;
case|case
name|OPLUS_
case|:
name|assert
argument_list|(
name|m
operator|->
name|lastpos
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lev
operator|+
literal|1
operator|<=
name|m
operator|->
name|g
operator|->
name|nplus
argument_list|)
expr_stmt|;
name|m
operator|->
name|lastpos
index|[
name|lev
operator|+
literal|1
index|]
operator|=
name|sp
expr_stmt|;
return|return
operator|(
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
operator|+
literal|1
argument_list|)
operator|)
return|;
break|break;
case|case
name|O_PLUS
case|:
if|if
condition|(
name|sp
operator|==
name|m
operator|->
name|lastpos
index|[
name|lev
index|]
condition|)
comment|/* last pass matched null */
return|return
operator|(
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
operator|-
literal|1
argument_list|)
operator|)
return|;
comment|/* try another pass */
name|m
operator|->
name|lastpos
index|[
name|lev
index|]
operator|=
name|sp
expr_stmt|;
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|-
name|OPND
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
operator|-
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|dp
operator|)
return|;
break|break;
case|case
name|OCH_
case|:
comment|/* find the right one, if any */
name|ssub
operator|=
name|ss
operator|+
literal|1
expr_stmt|;
name|esub
operator|=
name|ss
operator|+
name|OPND
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* find first matching branch */
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ssub
argument_list|,
name|esub
argument_list|,
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dp
operator|)
return|;
comment|/* that one missed, try next one */
if|if
condition|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|O_CH
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* there is none */
name|esub
operator|++
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR2
argument_list|)
expr_stmt|;
name|ssub
operator|=
name|esub
operator|+
literal|1
expr_stmt|;
name|esub
operator|+=
name|OPND
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|OOR2
condition|)
name|esub
operator|--
expr_stmt|;
else|else
name|assert
argument_list|(
name|OP
argument_list|(
name|m
operator|->
name|g
operator|->
name|strip
index|[
name|esub
index|]
argument_list|)
operator|==
name|O_CH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OLPAREN
case|:
comment|/* must undo assignment if rest fails */
name|i
operator|=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|offsave
operator|=
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
expr_stmt|;
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|=
name|sp
operator|-
name|m
operator|->
name|offp
expr_stmt|;
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dp
operator|)
return|;
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
operator|=
name|offsave
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|ORPAREN
case|:
comment|/* must undo assignment if rest fails */
name|i
operator|=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<=
name|m
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|offsave
operator|=
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
expr_stmt|;
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|=
name|sp
operator|-
name|m
operator|->
name|offp
expr_stmt|;
name|dp
operator|=
name|backref
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|stop
argument_list|,
name|ss
operator|+
literal|1
argument_list|,
name|stopst
argument_list|,
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dp
operator|)
return|;
name|m
operator|->
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
operator|=
name|offsave
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
default|default:
comment|/* uh oh */
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* "can't happen" */
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - fast - step through the string at top speed  == static char *fast(register struct match *m, char *start, \  ==	char *stop, sopno startst, sopno stopst);  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* where tentative match ended, or NULL */
DECL|function|fast (m,start,stop,startst,stopst)
name|fast
parameter_list|(
name|m
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|startst
parameter_list|,
name|stopst
parameter_list|)
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|stop
decl_stmt|;
name|sopno
name|startst
decl_stmt|;
name|sopno
name|stopst
decl_stmt|;
block|{
specifier|register
name|states
name|st
init|=
name|m
operator|->
name|st
decl_stmt|;
specifier|register
name|states
name|fresh
init|=
name|m
operator|->
name|fresh
decl_stmt|;
specifier|register
name|states
name|tmp
init|=
name|m
operator|->
name|tmp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|(
name|start
operator|==
name|m
operator|->
name|beginp
operator|)
condition|?
name|OUT
else|:
operator|*
operator|(
name|start
operator|-
literal|1
operator|)
decl_stmt|;
specifier|register
name|int
name|lastc
decl_stmt|;
comment|/* previous c */
specifier|register
name|int
name|flagch
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|coldp
decl_stmt|;
comment|/* last p after which no match was underway */
name|CLEAR
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|SET1
argument_list|(
name|st
argument_list|,
name|startst
argument_list|)
expr_stmt|;
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|NOTHING
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|fresh
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"start"
argument_list|,
name|st
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|coldp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* next character */
name|lastc
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|(
name|p
operator|==
name|m
operator|->
name|endp
operator|)
condition|?
name|OUT
else|:
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|st
argument_list|,
name|fresh
argument_list|)
condition|)
name|coldp
operator|=
name|p
expr_stmt|;
comment|/* is there an EOL and/or BOL between lastc and c? */
name|flagch
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|lastc
operator|==
literal|'\n'
operator|&&
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|||
operator|(
name|lastc
operator|==
name|OUT
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTBOL
operator|)
operator|)
condition|)
block|{
name|flagch
operator|=
name|BOL
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|g
operator|->
name|nbol
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|||
operator|(
name|c
operator|==
name|OUT
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTEOL
operator|)
operator|)
condition|)
block|{
name|flagch
operator|=
operator|(
name|flagch
operator|==
name|BOL
operator|)
condition|?
name|BOLEOL
else|:
name|EOL
expr_stmt|;
name|i
operator|+=
name|m
operator|->
name|g
operator|->
name|neol
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|flagch
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"boleol"
argument_list|,
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* how about a word boundary? */
if|if
condition|(
operator|(
name|flagch
operator|==
name|BOL
operator|||
operator|(
name|lastc
operator|!=
name|OUT
operator|&&
operator|!
name|ISWORD
argument_list|(
name|lastc
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|c
operator|!=
name|OUT
operator|&&
name|ISWORD
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|flagch
operator|=
name|BOW
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lastc
operator|!=
name|OUT
operator|&&
name|ISWORD
argument_list|(
name|lastc
argument_list|)
operator|)
operator|&&
operator|(
name|flagch
operator|==
name|EOL
operator|||
operator|(
name|c
operator|!=
name|OUT
operator|&&
operator|!
name|ISWORD
argument_list|(
name|c
argument_list|)
operator|)
operator|)
condition|)
block|{
name|flagch
operator|=
name|EOW
expr_stmt|;
block|}
if|if
condition|(
name|flagch
operator|==
name|BOW
operator|||
name|flagch
operator|==
name|EOW
condition|)
block|{
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|flagch
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"boweow"
argument_list|,
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* are we done? */
if|if
condition|(
name|ISSET
argument_list|(
name|st
argument_list|,
name|stopst
argument_list|)
operator|||
name|p
operator|==
name|stop
condition|)
break|break;
comment|/* NOTE BREAK OUT */
comment|/* no, we must deal with this character */
name|ASSIGN
argument_list|(
name|tmp
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|st
argument_list|,
name|fresh
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|c
operator|!=
name|OUT
argument_list|)
expr_stmt|;
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|tmp
argument_list|,
name|c
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"aft"
argument_list|,
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|EQ
argument_list|(
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|NOTHING
argument_list|,
name|st
argument_list|)
argument_list|,
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|coldp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|->
name|coldp
operator|=
name|coldp
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|st
argument_list|,
name|stopst
argument_list|)
condition|)
return|return
operator|(
name|p
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - slow - step through the string more deliberately  == static char *slow(register struct match *m, char *start, \  ==	char *stop, sopno startst, sopno stopst);  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* where it ended */
DECL|function|slow (m,start,stop,startst,stopst)
name|slow
parameter_list|(
name|m
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|startst
parameter_list|,
name|stopst
parameter_list|)
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|stop
decl_stmt|;
name|sopno
name|startst
decl_stmt|;
name|sopno
name|stopst
decl_stmt|;
block|{
specifier|register
name|states
name|st
init|=
name|m
operator|->
name|st
decl_stmt|;
specifier|register
name|states
name|empty
init|=
name|m
operator|->
name|empty
decl_stmt|;
specifier|register
name|states
name|tmp
init|=
name|m
operator|->
name|tmp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|(
name|start
operator|==
name|m
operator|->
name|beginp
operator|)
condition|?
name|OUT
else|:
operator|*
operator|(
name|start
operator|-
literal|1
operator|)
decl_stmt|;
specifier|register
name|int
name|lastc
decl_stmt|;
comment|/* previous c */
specifier|register
name|int
name|flagch
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|matchp
decl_stmt|;
comment|/* last p at which a match ended */
name|AT
argument_list|(
literal|"slow"
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|SET1
argument_list|(
name|st
argument_list|,
name|startst
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"sstart"
argument_list|,
name|st
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|NOTHING
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|matchp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* next character */
name|lastc
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|(
name|p
operator|==
name|m
operator|->
name|endp
operator|)
condition|?
name|OUT
else|:
operator|*
name|p
expr_stmt|;
comment|/* is there an EOL and/or BOL between lastc and c? */
name|flagch
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|lastc
operator|==
literal|'\n'
operator|&&
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|||
operator|(
name|lastc
operator|==
name|OUT
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTBOL
operator|)
operator|)
condition|)
block|{
name|flagch
operator|=
name|BOL
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|g
operator|->
name|nbol
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|m
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
operator|)
operator|||
operator|(
name|c
operator|==
name|OUT
operator|&&
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_NOTEOL
operator|)
operator|)
condition|)
block|{
name|flagch
operator|=
operator|(
name|flagch
operator|==
name|BOL
operator|)
condition|?
name|BOLEOL
else|:
name|EOL
expr_stmt|;
name|i
operator|+=
name|m
operator|->
name|g
operator|->
name|neol
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|flagch
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"sboleol"
argument_list|,
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* how about a word boundary? */
if|if
condition|(
operator|(
name|flagch
operator|==
name|BOL
operator|||
operator|(
name|lastc
operator|!=
name|OUT
operator|&&
operator|!
name|ISWORD
argument_list|(
name|lastc
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|c
operator|!=
name|OUT
operator|&&
name|ISWORD
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|flagch
operator|=
name|BOW
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lastc
operator|!=
name|OUT
operator|&&
name|ISWORD
argument_list|(
name|lastc
argument_list|)
operator|)
operator|&&
operator|(
name|flagch
operator|==
name|EOL
operator|||
operator|(
name|c
operator|!=
name|OUT
operator|&&
operator|!
name|ISWORD
argument_list|(
name|c
argument_list|)
operator|)
operator|)
condition|)
block|{
name|flagch
operator|=
name|EOW
expr_stmt|;
block|}
if|if
condition|(
name|flagch
operator|==
name|BOW
operator|||
name|flagch
operator|==
name|EOW
condition|)
block|{
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|flagch
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"sboweow"
argument_list|,
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* are we done? */
if|if
condition|(
name|ISSET
argument_list|(
name|st
argument_list|,
name|stopst
argument_list|)
condition|)
name|matchp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|st
argument_list|,
name|empty
argument_list|)
operator|||
name|p
operator|==
name|stop
condition|)
break|break;
comment|/* NOTE BREAK OUT */
comment|/* no, we must deal with this character */
name|ASSIGN
argument_list|(
name|tmp
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|ASSIGN
argument_list|(
name|st
argument_list|,
name|empty
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|c
operator|!=
name|OUT
argument_list|)
expr_stmt|;
name|st
operator|=
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|tmp
argument_list|,
name|c
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|SP
argument_list|(
literal|"saft"
argument_list|,
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|EQ
argument_list|(
name|step
argument_list|(
name|m
operator|->
name|g
argument_list|,
name|startst
argument_list|,
name|stopst
argument_list|,
name|st
argument_list|,
name|NOTHING
argument_list|,
name|st
argument_list|)
argument_list|,
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|matchp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - step - map set of states reachable before char to set reachable after  == static states step(register struct re_guts *g, sopno start, sopno stop, \  ==	register states bef, int ch, register states aft);  == #define	BOL	(OUT+1)  == #define	EOL	(BOL+1)  == #define	BOLEOL	(BOL+2)  == #define	NOTHING	(BOL+3)  == #define	BOW	(BOL+4)  == #define	EOW	(BOL+5)  == #define	CODEMAX	(BOL+5)		// highest code used  == #define	NONCHAR(c)	((c)> CHAR_MAX)  == #define	NNONCHAR	(CODEMAX-CHAR_MAX)  */
end_comment

begin_function
specifier|static
name|states
DECL|function|step (g,start,stop,bef,ch,aft)
name|step
parameter_list|(
name|g
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|bef
parameter_list|,
name|ch
parameter_list|,
name|aft
parameter_list|)
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
name|sopno
name|start
decl_stmt|;
comment|/* start state within strip */
name|sopno
name|stop
decl_stmt|;
comment|/* state after stop state within strip */
specifier|register
name|states
name|bef
decl_stmt|;
comment|/* states reachable before */
name|int
name|ch
decl_stmt|;
comment|/* character or NONCHAR code */
specifier|register
name|states
name|aft
decl_stmt|;
comment|/* states already known reachable after */
block|{
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|sopno
name|pc
decl_stmt|;
specifier|register
name|onestate
name|here
decl_stmt|;
comment|/* note, macros know this name */
specifier|register
name|sopno
name|look
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|pc
operator|=
name|start
operator|,
name|INIT
argument_list|(
name|here
argument_list|,
name|pc
argument_list|)
init|;
name|pc
operator|!=
name|stop
condition|;
name|pc
operator|++
operator|,
name|INC
argument_list|(
name|here
argument_list|)
control|)
block|{
name|s
operator|=
name|g
operator|->
name|strip
index|[
name|pc
index|]
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OEND
case|:
name|assert
argument_list|(
name|pc
operator|==
name|stop
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCHAR
case|:
comment|/* only characters can match */
name|assert
argument_list|(
operator|!
name|NONCHAR
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|!=
operator|(
name|char
operator|)
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|(
name|char
operator|)
name|OPND
argument_list|(
name|s
argument_list|)
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBOL
case|:
if|if
condition|(
name|ch
operator|==
name|BOL
operator|||
name|ch
operator|==
name|BOLEOL
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OEOL
case|:
if|if
condition|(
name|ch
operator|==
name|EOL
operator|||
name|ch
operator|==
name|BOLEOL
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBOW
case|:
if|if
condition|(
name|ch
operator|==
name|BOW
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OEOW
case|:
if|if
condition|(
name|ch
operator|==
name|EOW
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OANY
case|:
if|if
condition|(
operator|!
name|NONCHAR
argument_list|(
name|ch
argument_list|)
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OANYOF
case|:
name|cs
operator|=
operator|&
name|g
operator|->
name|sets
index|[
name|OPND
argument_list|(
name|s
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|NONCHAR
argument_list|(
name|ch
argument_list|)
operator|&&
name|CHIN
argument_list|(
name|cs
argument_list|,
name|ch
argument_list|)
condition|)
name|FWD
argument_list|(
name|aft
argument_list|,
name|bef
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBACK_
case|:
comment|/* ignored here */
case|case
name|O_BACK
case|:
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPLUS_
case|:
comment|/* forward, this is just an empty */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_PLUS
case|:
comment|/* both forward and back */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|ISSETBACK
argument_list|(
name|aft
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|ISSETBACK
argument_list|(
name|aft
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
comment|/* oho, must reconsider loop body */
name|pc
operator|-=
name|OPND
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|INIT
argument_list|(
name|here
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OQUEST_
case|:
comment|/* two branches, both forward */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_QUEST
case|:
comment|/* just an empty */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLPAREN
case|:
comment|/* not significant here */
case|case
name|ORPAREN
case|:
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCH_
case|:
comment|/* mark the first two branches */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|g
operator|->
name|strip
index|[
name|pc
operator|+
name|OPND
argument_list|(
name|s
argument_list|)
index|]
argument_list|)
operator|==
name|OOR2
argument_list|)
expr_stmt|;
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OOR1
case|:
comment|/* done a branch, find the O_CH */
if|if
condition|(
name|ISSTATEIN
argument_list|(
name|aft
argument_list|,
name|here
argument_list|)
condition|)
block|{
for|for
control|(
name|look
operator|=
literal|1
init|;
name|OP
argument_list|(
name|s
operator|=
name|g
operator|->
name|strip
index|[
name|pc
operator|+
name|look
index|]
argument_list|)
operator|!=
name|O_CH
condition|;
name|look
operator|+=
name|OPND
argument_list|(
name|s
argument_list|)
control|)
name|assert
argument_list|(
name|OP
argument_list|(
name|s
argument_list|)
operator|==
name|OOR2
argument_list|)
expr_stmt|;
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
name|look
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OOR2
case|:
comment|/* propagate OCH_'s marking */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|g
operator|->
name|strip
index|[
name|pc
operator|+
name|OPND
argument_list|(
name|s
argument_list|)
index|]
argument_list|)
operator|!=
name|O_CH
condition|)
block|{
name|assert
argument_list|(
name|OP
argument_list|(
name|g
operator|->
name|strip
index|[
name|pc
operator|+
name|OPND
argument_list|(
name|s
argument_list|)
index|]
argument_list|)
operator|==
name|OOR2
argument_list|)
expr_stmt|;
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_CH
case|:
comment|/* just empty */
name|FWD
argument_list|(
name|aft
argument_list|,
name|aft
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ooooops... */
name|assert
argument_list|(
name|nope
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|aft
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REDEBUG
end_ifdef

begin_comment
comment|/*  - print - print a set of states  == #ifdef REDEBUG  == static void print(struct match *m, char *caption, states st, \  ==	int ch, FILE *d);  == #endif  */
end_comment

begin_function
specifier|static
name|void
DECL|function|print (m,caption,st,ch,d)
name|print
parameter_list|(
name|m
parameter_list|,
name|caption
parameter_list|,
name|st
parameter_list|,
name|ch
parameter_list|,
name|d
parameter_list|)
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|caption
decl_stmt|;
name|states
name|st
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|struct
name|re_guts
modifier|*
name|g
init|=
name|m
operator|->
name|g
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_TRACE
operator|)
condition|)
return|return;
name|fprintf
argument_list|(
name|d
argument_list|,
literal|"%s"
argument_list|,
name|caption
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|d
argument_list|,
literal|" %s"
argument_list|,
name|pchar
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nstates
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISSET
argument_list|(
name|st
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|d
argument_list|,
literal|"%s%d"
argument_list|,
operator|(
name|first
operator|)
condition|?
literal|"\t"
else|:
literal|", "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - at - print current situation  == #ifdef REDEBUG  == static void at(struct match *m, char *title, char *start, char *stop, \  ==						sopno startst, sopno stopst);  == #endif  */
end_comment

begin_function
specifier|static
name|void
DECL|function|at (m,title,start,stop,startst,stopst)
name|at
parameter_list|(
name|m
parameter_list|,
name|title
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|startst
parameter_list|,
name|stopst
parameter_list|)
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|stop
decl_stmt|;
name|sopno
name|startst
decl_stmt|;
name|sopno
name|stopst
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|eflags
operator|&
name|REG_TRACE
operator|)
condition|)
return|return;
name|printf
argument_list|(
literal|"%s %s-"
argument_list|,
name|title
argument_list|,
name|pchar
argument_list|(
operator|*
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|pchar
argument_list|(
operator|*
name|stop
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld-%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|startst
argument_list|,
operator|(
name|long
operator|)
name|stopst
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PCHARDONE
end_ifndef

begin_define
DECL|macro|PCHARDONE
define|#
directive|define
name|PCHARDONE
end_define

begin_comment
DECL|macro|PCHARDONE
comment|/* never again */
end_comment

begin_comment
comment|/*  - pchar - make a character printable  == #ifdef REDEBUG  == static char *pchar(int ch);  == #endif  *  * Is this identical to regchar() over in debug.c?  Well, yes.  But a  * duplicate here avoids having a debugging-capable regexec.o tied to  * a matching debug.o, and this is convenient.  It all disappears in  * the non-debug compilation anyway, so it doesn't matter much.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* -> representation */
DECL|function|pchar (ch)
name|pchar
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
specifier|static
name|char
name|pbuf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|' '
condition|)
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%c"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"\\%o"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|pbuf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|matcher
end_undef

begin_undef
undef|#
directive|undef
name|fast
end_undef

begin_undef
undef|#
directive|undef
name|slow
end_undef

begin_undef
undef|#
directive|undef
name|dissect
end_undef

begin_undef
undef|#
directive|undef
name|backref
end_undef

begin_undef
undef|#
directive|undef
name|step
end_undef

begin_undef
undef|#
directive|undef
name|print
end_undef

begin_undef
undef|#
directive|undef
name|at
end_undef

begin_undef
undef|#
directive|undef
name|match
end_undef

end_unit

