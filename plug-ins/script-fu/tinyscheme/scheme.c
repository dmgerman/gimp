begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* T I N Y S C H E M E    1 . 3 8  *   Dimitrios Souflis (dsouflis@acm.org)  *   Based on MiniScheme (original credits follow)  * (MINISCM)               coded by Atsushi Moriwaki (11/5/1989)  * (MINISCM)           E-MAIL :  moriwaki@kurims.kurims.kyoto-u.ac.jp  * (MINISCM) This version has been modified by R.C. Secrist.  * (MINISCM)  * (MINISCM) Mini-Scheme is now maintained by Akira KIDA.  * (MINISCM)  * (MINISCM) This is a revised and modified version by Akira KIDA.  * (MINISCM)   current version is 0.85k4 (15 May 1994)  *  */
end_comment

begin_comment
comment|/* ******** READ THE FOLLOWING BEFORE MODIFYING THIS FILE! ******** */
end_comment

begin_comment
comment|/* This copy of TinyScheme has been modified to support UTF-8 coded */
end_comment

begin_comment
comment|/* character strings. As a result, the length of a string in bytes  */
end_comment

begin_comment
comment|/* may not be the same as the length of a string in characters. You */
end_comment

begin_comment
comment|/* must keep this in mind at all times while making any changes to  */
end_comment

begin_comment
comment|/* the routines in this file, or when adding new features.          */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* UTF-8 modifications made by Kevin Cozens (kcozens@interlog.com)  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
DECL|macro|_SCHEME_SOURCE
define|#
directive|define
name|_SCHEME_SOURCE
end_define

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
DECL|macro|access (f,a)
define|#
directive|define
name|access
parameter_list|(
name|f
parameter_list|,
name|a
parameter_list|)
value|_access(f,a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_DL
end_if

begin_include
include|#
directive|include
file|"dynload.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_MATH
end_if

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|"scheme-private.h"
end_include

begin_if
if|#
directive|if
operator|!
name|STANDALONE
end_if

begin_decl_stmt
DECL|variable|ts_output_handler
specifier|static
name|ts_output_func
name|ts_output_handler
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ts_output_data
specifier|static
name|gpointer
name|ts_output_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|ts_register_output_func (ts_output_func func,gpointer user_data)
name|ts_register_output_func
parameter_list|(
name|ts_output_func
name|func
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|ts_output_handler
operator|=
name|func
expr_stmt|;
name|ts_output_data
operator|=
name|user_data
expr_stmt|;
block|}
end_function

begin_comment
comment|/* len is length of 'string' in bytes or -1 for null terminated strings */
end_comment

begin_function
name|void
DECL|function|ts_output_string (TsOutputType type,const char * string,int len)
name|ts_output_string
parameter_list|(
name|TsOutputType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts_output_handler
operator|&&
name|len
operator|>
literal|0
condition|)
call|(
modifier|*
name|ts_output_handler
call|)
argument_list|(
name|type
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
name|ts_output_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used for documentation purposes, to signal functions in 'interface' */
end_comment

begin_define
DECL|macro|INTERFACE
define|#
directive|define
name|INTERFACE
end_define

begin_define
DECL|macro|TOK_EOF
define|#
directive|define
name|TOK_EOF
value|(-1)
end_define

begin_define
DECL|macro|TOK_LPAREN
define|#
directive|define
name|TOK_LPAREN
value|0
end_define

begin_define
DECL|macro|TOK_RPAREN
define|#
directive|define
name|TOK_RPAREN
value|1
end_define

begin_define
DECL|macro|TOK_DOT
define|#
directive|define
name|TOK_DOT
value|2
end_define

begin_define
DECL|macro|TOK_ATOM
define|#
directive|define
name|TOK_ATOM
value|3
end_define

begin_define
DECL|macro|TOK_QUOTE
define|#
directive|define
name|TOK_QUOTE
value|4
end_define

begin_define
DECL|macro|TOK_COMMENT
define|#
directive|define
name|TOK_COMMENT
value|5
end_define

begin_define
DECL|macro|TOK_DQUOTE
define|#
directive|define
name|TOK_DQUOTE
value|6
end_define

begin_define
DECL|macro|TOK_BQUOTE
define|#
directive|define
name|TOK_BQUOTE
value|7
end_define

begin_define
DECL|macro|TOK_COMMA
define|#
directive|define
name|TOK_COMMA
value|8
end_define

begin_define
DECL|macro|TOK_ATMARK
define|#
directive|define
name|TOK_ATMARK
value|9
end_define

begin_define
DECL|macro|TOK_SHARP
define|#
directive|define
name|TOK_SHARP
value|10
end_define

begin_define
DECL|macro|TOK_SHARP_CONST
define|#
directive|define
name|TOK_SHARP_CONST
value|11
end_define

begin_define
DECL|macro|TOK_VEC
define|#
directive|define
name|TOK_VEC
value|12
end_define

begin_define
DECL|macro|BACKQUOTE
define|#
directive|define
name|BACKQUOTE
value|'`'
end_define

begin_comment
comment|/*  *  Basic memory allocation units  */
end_comment

begin_define
DECL|macro|banner
define|#
directive|define
name|banner
value|"TinyScheme 1.38 (with UTF-8 support)"
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_define
DECL|macro|stricmp
define|#
directive|define
name|stricmp
value|utf8_stricmp
end_define

begin_function
DECL|function|utf8_stricmp (const char * s1,const char * s2)
specifier|static
name|int
name|utf8_stricmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|char
modifier|*
name|s1a
decl_stmt|,
modifier|*
name|s2a
decl_stmt|;
name|int
name|result
decl_stmt|;
name|s1a
operator|=
name|g_utf8_casefold
argument_list|(
name|s1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s2a
operator|=
name|g_utf8_casefold
argument_list|(
name|s2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|g_utf8_collate
argument_list|(
name|s1a
argument_list|,
name|s2a
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|s1a
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|s2a
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
DECL|macro|min (a,b)
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<= (b) ? (a) : (b))
end_define

begin_if
if|#
directive|if
name|USE_STRLWR
end_if

begin_comment
comment|/* #error FIXME: Can't just use g_utf8_strdown since it allocates a new string #define strlwr(s)  g_utf8_strdown(s, -1) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|strlwr (s)
define|#
directive|define
name|strlwr
parameter_list|(
name|s
parameter_list|)
value|s
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|prompt
end_ifndef

begin_define
DECL|macro|prompt
define|#
directive|define
name|prompt
value|"ts> "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|InitFile
end_ifndef

begin_define
DECL|macro|InitFile
define|#
directive|define
name|InitFile
value|"init.scm"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_CELLSEGS
end_ifndef

begin_define
DECL|macro|FIRST_CELLSEGS
define|#
directive|define
name|FIRST_CELLSEGS
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
DECL|enum|scheme_types
enum|enum
name|scheme_types
block|{
DECL|enumerator|T_STRING
name|T_STRING
init|=
literal|1
block|,
DECL|enumerator|T_NUMBER
name|T_NUMBER
init|=
literal|2
block|,
DECL|enumerator|T_SYMBOL
name|T_SYMBOL
init|=
literal|3
block|,
DECL|enumerator|T_PROC
name|T_PROC
init|=
literal|4
block|,
DECL|enumerator|T_PAIR
name|T_PAIR
init|=
literal|5
block|,
DECL|enumerator|T_CLOSURE
name|T_CLOSURE
init|=
literal|6
block|,
DECL|enumerator|T_CONTINUATION
name|T_CONTINUATION
init|=
literal|7
block|,
DECL|enumerator|T_FOREIGN
name|T_FOREIGN
init|=
literal|8
block|,
DECL|enumerator|T_CHARACTER
name|T_CHARACTER
init|=
literal|9
block|,
DECL|enumerator|T_PORT
name|T_PORT
init|=
literal|10
block|,
DECL|enumerator|T_VECTOR
name|T_VECTOR
init|=
literal|11
block|,
DECL|enumerator|T_MACRO
name|T_MACRO
init|=
literal|12
block|,
DECL|enumerator|T_PROMISE
name|T_PROMISE
init|=
literal|13
block|,
DECL|enumerator|T_ENVIRONMENT
name|T_ENVIRONMENT
init|=
literal|14
block|,
DECL|enumerator|T_LAST_SYSTEM_TYPE
name|T_LAST_SYSTEM_TYPE
init|=
literal|14
block|}
enum|;
end_enum

begin_comment
comment|/* ADJ is enough slack to align cells in a TYPE_BITS-bit boundary */
end_comment

begin_define
DECL|macro|ADJ
define|#
directive|define
name|ADJ
value|32
end_define

begin_define
DECL|macro|TYPE_BITS
define|#
directive|define
name|TYPE_BITS
value|5
end_define

begin_define
DECL|macro|T_MASKTYPE
define|#
directive|define
name|T_MASKTYPE
value|31
end_define

begin_comment
DECL|macro|T_MASKTYPE
comment|/* 0000000000011111 */
end_comment

begin_define
DECL|macro|T_SYNTAX
define|#
directive|define
name|T_SYNTAX
value|4096
end_define

begin_comment
DECL|macro|T_SYNTAX
comment|/* 0001000000000000 */
end_comment

begin_define
DECL|macro|T_IMMUTABLE
define|#
directive|define
name|T_IMMUTABLE
value|8192
end_define

begin_comment
DECL|macro|T_IMMUTABLE
comment|/* 0010000000000000 */
end_comment

begin_define
DECL|macro|T_ATOM
define|#
directive|define
name|T_ATOM
value|16384
end_define

begin_comment
DECL|macro|T_ATOM
comment|/* 0100000000000000 */
end_comment

begin_comment
DECL|macro|T_ATOM
comment|/* only for gc */
end_comment

begin_define
DECL|macro|CLRATOM
define|#
directive|define
name|CLRATOM
value|49151
end_define

begin_comment
DECL|macro|CLRATOM
comment|/* 1011111111111111 */
end_comment

begin_comment
DECL|macro|CLRATOM
comment|/* only for gc */
end_comment

begin_define
DECL|macro|MARK
define|#
directive|define
name|MARK
value|32768
end_define

begin_comment
DECL|macro|MARK
comment|/* 1000000000000000 */
end_comment

begin_define
DECL|macro|UNMARK
define|#
directive|define
name|UNMARK
value|32767
end_define

begin_comment
DECL|macro|UNMARK
comment|/* 0111111111111111 */
end_comment

begin_function_decl
specifier|static
name|num
name|num_add
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|num
name|num_mul
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|num
name|num_div
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|num
name|num_intdiv
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|num
name|num_sub
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|num
name|num_rem
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|num
name|num_mod
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|num_eq
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|num_gt
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|num_ge
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|num_lt
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|num_le
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|USE_MATH
end_if

begin_function_decl
specifier|static
name|double
name|round_per_R5RS
parameter_list|(
name|double
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|is_zero_double
parameter_list|(
name|double
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|function|num_is_integer (pointer p)
specifier|static
name|INLINE
name|int
name|num_is_integer
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
operator|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|is_fixnum
operator|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|num_zero
specifier|static
name|num
name|num_zero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_one
specifier|static
name|num
name|num_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* macros for cell operations */
end_comment

begin_define
DECL|macro|typeflag (p)
define|#
directive|define
name|typeflag
parameter_list|(
name|p
parameter_list|)
value|((p)->_flag)
end_define

begin_define
DECL|macro|type (p)
define|#
directive|define
name|type
parameter_list|(
name|p
parameter_list|)
value|(typeflag(p)&T_MASKTYPE)
end_define

begin_function
DECL|function|is_string (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_string
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_STRING
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|strvalue (p)
define|#
directive|define
name|strvalue
parameter_list|(
name|p
parameter_list|)
value|((p)->_object._string._svalue)
end_define

begin_define
DECL|macro|strlength (p)
define|#
directive|define
name|strlength
parameter_list|(
name|p
parameter_list|)
value|((p)->_object._string._length)
end_define

begin_function_decl
name|INTERFACE
specifier|static
name|int
name|is_list
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|function|is_vector (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_vector
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_VECTOR
operator|)
return|;
block|}
end_function

begin_function_decl
name|INTERFACE
specifier|static
name|void
name|fill_vector
parameter_list|(
name|pointer
name|vec
parameter_list|,
name|pointer
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|INTERFACE
specifier|static
name|pointer
name|vector_elem
parameter_list|(
name|pointer
name|vec
parameter_list|,
name|int
name|ielem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|INTERFACE
specifier|static
name|pointer
name|set_vector_elem
parameter_list|(
name|pointer
name|vec
parameter_list|,
name|int
name|ielem
parameter_list|,
name|pointer
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|function|is_number (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_number
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_NUMBER
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_integer (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_integer
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|is_number
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
operator|(
name|p
operator|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|is_fixnum
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_real (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_real
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|is_number
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|p
operator|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|is_fixnum
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_character (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_character
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_CHARACTER
operator|)
return|;
block|}
end_function

begin_function
DECL|function|string_length (pointer p)
name|INTERFACE
name|INLINE
name|int
name|string_length
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|strlength
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|string_value (pointer p)
name|INTERFACE
name|INLINE
name|char
modifier|*
name|string_value
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|strvalue
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|nvalue (pointer p)
name|INLINE
name|num
name|nvalue
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
operator|)
operator|->
name|_object
operator|.
name|_number
operator|)
return|;
block|}
end_function

begin_function
DECL|function|ivalue (pointer p)
name|INTERFACE
name|long
name|ivalue
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|num_is_integer
argument_list|(
name|p
argument_list|)
condition|?
operator|(
name|p
operator|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|value
operator|.
name|ivalue
else|:
call|(
name|long
call|)
argument_list|(
name|p
argument_list|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|value
operator|.
name|rvalue
operator|)
return|;
block|}
end_function

begin_function
DECL|function|rvalue (pointer p)
name|INTERFACE
name|double
name|rvalue
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
operator|!
name|num_is_integer
argument_list|(
name|p
argument_list|)
condition|?
operator|(
name|p
operator|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|value
operator|.
name|rvalue
else|:
call|(
name|double
call|)
argument_list|(
name|p
argument_list|)
operator|->
name|_object
operator|.
name|_number
operator|.
name|value
operator|.
name|ivalue
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|ivalue_unchecked (p)
define|#
directive|define
name|ivalue_unchecked
parameter_list|(
name|p
parameter_list|)
value|((p)->_object._number.value.ivalue)
end_define

begin_define
DECL|macro|rvalue_unchecked (p)
define|#
directive|define
name|rvalue_unchecked
parameter_list|(
name|p
parameter_list|)
value|((p)->_object._number.value.rvalue)
end_define

begin_define
DECL|macro|set_num_integer (p)
define|#
directive|define
name|set_num_integer
parameter_list|(
name|p
parameter_list|)
value|(p)->_object._number.is_fixnum=1;
end_define

begin_define
DECL|macro|set_num_real (p)
define|#
directive|define
name|set_num_real
parameter_list|(
name|p
parameter_list|)
value|(p)->_object._number.is_fixnum=0;
end_define

begin_function
DECL|function|charvalue (pointer p)
name|INTERFACE
name|gunichar
name|charvalue
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|gunichar
operator|)
name|ivalue_unchecked
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|is_port (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_port
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_PORT
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|is_inport (p)
define|#
directive|define
name|is_inport
parameter_list|(
name|p
parameter_list|)
value|(type(p)==T_PORT&& p->_object._port->kind&port_input)
end_define

begin_define
DECL|macro|is_outport (p)
define|#
directive|define
name|is_outport
parameter_list|(
name|p
parameter_list|)
value|(type(p)==T_PORT&& p->_object._port->kind&port_output)
end_define

begin_function
DECL|function|is_pair (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_pair
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_PAIR
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|car (p)
define|#
directive|define
name|car
parameter_list|(
name|p
parameter_list|)
value|((p)->_object._cons._car)
end_define

begin_define
DECL|macro|cdr (p)
define|#
directive|define
name|cdr
parameter_list|(
name|p
parameter_list|)
value|((p)->_object._cons._cdr)
end_define

begin_function
DECL|function|pair_car (pointer p)
name|INTERFACE
name|pointer
name|pair_car
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|car
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|pair_cdr (pointer p)
name|INTERFACE
name|pointer
name|pair_cdr
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|cdr
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|set_car (pointer p,pointer q)
name|INTERFACE
name|pointer
name|set_car
parameter_list|(
name|pointer
name|p
parameter_list|,
name|pointer
name|q
parameter_list|)
block|{
return|return
name|car
argument_list|(
name|p
argument_list|)
operator|=
name|q
return|;
block|}
end_function

begin_function
DECL|function|set_cdr (pointer p,pointer q)
name|INTERFACE
name|pointer
name|set_cdr
parameter_list|(
name|pointer
name|p
parameter_list|,
name|pointer
name|q
parameter_list|)
block|{
return|return
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|q
return|;
block|}
end_function

begin_function
DECL|function|is_symbol (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_symbol
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_SYMBOL
operator|)
return|;
block|}
end_function

begin_function
DECL|function|symname (pointer p)
name|INTERFACE
name|INLINE
name|char
modifier|*
name|symname
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|strvalue
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_PLIST
end_if

begin_function
DECL|function|hasprop (pointer p)
name|SCHEME_EXPORT
name|INLINE
name|int
name|hasprop
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|typeflag
argument_list|(
name|p
argument_list|)
operator|&
name|T_SYMBOL
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|symprop (p)
define|#
directive|define
name|symprop
parameter_list|(
name|p
parameter_list|)
value|cdr(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
DECL|function|is_syntax (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_syntax
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|typeflag
argument_list|(
name|p
argument_list|)
operator|&
name|T_SYNTAX
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_proc (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_proc
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_PROC
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_foreign (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_foreign
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_FOREIGN
operator|)
return|;
block|}
end_function

begin_function
DECL|function|syntaxname (pointer p)
name|INTERFACE
name|INLINE
name|char
modifier|*
name|syntaxname
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|strvalue
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_define
DECL|macro|procnum (p)
define|#
directive|define
name|procnum
parameter_list|(
name|p
parameter_list|)
value|ivalue(p)
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|procname
parameter_list|(
name|pointer
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|function|is_closure (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_closure
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_CLOSURE
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_macro (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_macro
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_MACRO
operator|)
return|;
block|}
end_function

begin_function
DECL|function|closure_code (pointer p)
name|INTERFACE
name|INLINE
name|pointer
name|closure_code
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|car
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|closure_env (pointer p)
name|INTERFACE
name|INLINE
name|pointer
name|closure_env
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|cdr
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|is_continuation (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_continuation
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_CONTINUATION
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|cont_dump (p)
define|#
directive|define
name|cont_dump
parameter_list|(
name|p
parameter_list|)
value|cdr(p)
end_define

begin_comment
comment|/* To do: promise should be forced ONCE only */
end_comment

begin_function
DECL|function|is_promise (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_promise
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_PROMISE
operator|)
return|;
block|}
end_function

begin_function
DECL|function|is_environment (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_environment
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|T_ENVIRONMENT
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|setenvironment (p)
define|#
directive|define
name|setenvironment
parameter_list|(
name|p
parameter_list|)
value|typeflag(p) = T_ENVIRONMENT
end_define

begin_define
DECL|macro|is_atom (p)
define|#
directive|define
name|is_atom
parameter_list|(
name|p
parameter_list|)
value|(typeflag(p)&T_ATOM)
end_define

begin_define
DECL|macro|setatom (p)
define|#
directive|define
name|setatom
parameter_list|(
name|p
parameter_list|)
value|typeflag(p) |= T_ATOM
end_define

begin_define
DECL|macro|clratom (p)
define|#
directive|define
name|clratom
parameter_list|(
name|p
parameter_list|)
value|typeflag(p)&= CLRATOM
end_define

begin_define
DECL|macro|is_mark (p)
define|#
directive|define
name|is_mark
parameter_list|(
name|p
parameter_list|)
value|(typeflag(p)&MARK)
end_define

begin_define
DECL|macro|setmark (p)
define|#
directive|define
name|setmark
parameter_list|(
name|p
parameter_list|)
value|typeflag(p) |= MARK
end_define

begin_define
DECL|macro|clrmark (p)
define|#
directive|define
name|clrmark
parameter_list|(
name|p
parameter_list|)
value|typeflag(p)&= UNMARK
end_define

begin_function
DECL|function|is_immutable (pointer p)
name|INTERFACE
name|INLINE
name|int
name|is_immutable
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
operator|(
name|typeflag
argument_list|(
name|p
argument_list|)
operator|&
name|T_IMMUTABLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*#define setimmutable(p)  typeflag(p) |= T_IMMUTABLE*/
end_comment

begin_function
DECL|function|setimmutable (pointer p)
name|INTERFACE
name|INLINE
name|void
name|setimmutable
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
name|typeflag
argument_list|(
name|p
argument_list|)
operator||=
name|T_IMMUTABLE
expr_stmt|;
block|}
end_function

begin_define
DECL|macro|caar (p)
define|#
directive|define
name|caar
parameter_list|(
name|p
parameter_list|)
value|car(car(p))
end_define

begin_define
DECL|macro|cadr (p)
define|#
directive|define
name|cadr
parameter_list|(
name|p
parameter_list|)
value|car(cdr(p))
end_define

begin_define
DECL|macro|cdar (p)
define|#
directive|define
name|cdar
parameter_list|(
name|p
parameter_list|)
value|cdr(car(p))
end_define

begin_define
DECL|macro|cddr (p)
define|#
directive|define
name|cddr
parameter_list|(
name|p
parameter_list|)
value|cdr(cdr(p))
end_define

begin_define
DECL|macro|cadar (p)
define|#
directive|define
name|cadar
parameter_list|(
name|p
parameter_list|)
value|car(cdr(car(p)))
end_define

begin_define
DECL|macro|caddr (p)
define|#
directive|define
name|caddr
parameter_list|(
name|p
parameter_list|)
value|car(cdr(cdr(p)))
end_define

begin_define
DECL|macro|cdaar (p)
define|#
directive|define
name|cdaar
parameter_list|(
name|p
parameter_list|)
value|cdr(car(car(p)))
end_define

begin_define
DECL|macro|cadaar (p)
define|#
directive|define
name|cadaar
parameter_list|(
name|p
parameter_list|)
value|car(cdr(car(car(p))))
end_define

begin_define
DECL|macro|cadddr (p)
define|#
directive|define
name|cadddr
parameter_list|(
name|p
parameter_list|)
value|car(cdr(cdr(cdr(p))))
end_define

begin_define
DECL|macro|cddddr (p)
define|#
directive|define
name|cddddr
parameter_list|(
name|p
parameter_list|)
value|cdr(cdr(cdr(cdr(p))))
end_define

begin_if
if|#
directive|if
name|USE_CHAR_CLASSIFIERS
end_if

begin_function
DECL|function|Cisalpha (gunichar c)
specifier|static
name|INLINE
name|int
name|Cisalpha
parameter_list|(
name|gunichar
name|c
parameter_list|)
block|{
return|return
name|g_unichar_isalpha
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|Cisdigit (gunichar c)
specifier|static
name|INLINE
name|int
name|Cisdigit
parameter_list|(
name|gunichar
name|c
parameter_list|)
block|{
return|return
name|g_unichar_isdigit
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|Cisspace (gunichar c)
specifier|static
name|INLINE
name|int
name|Cisspace
parameter_list|(
name|gunichar
name|c
parameter_list|)
block|{
return|return
name|g_unichar_isspace
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|Cisupper (gunichar c)
specifier|static
name|INLINE
name|int
name|Cisupper
parameter_list|(
name|gunichar
name|c
parameter_list|)
block|{
return|return
name|g_unichar_isupper
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|Cislower (gunichar c)
specifier|static
name|INLINE
name|int
name|Cislower
parameter_list|(
name|gunichar
name|c
parameter_list|)
block|{
return|return
name|g_unichar_islower
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_ASCII_NAMES
end_if

begin_decl_stmt
DECL|variable|charnames
specifier|static
specifier|const
name|char
modifier|*
name|charnames
index|[
literal|32
index|]
init|=
block|{
literal|"nul"
block|,
literal|"soh"
block|,
literal|"stx"
block|,
literal|"etx"
block|,
literal|"eot"
block|,
literal|"enq"
block|,
literal|"ack"
block|,
literal|"bel"
block|,
literal|"bs"
block|,
literal|"ht"
block|,
literal|"lf"
block|,
literal|"vt"
block|,
literal|"ff"
block|,
literal|"cr"
block|,
literal|"so"
block|,
literal|"si"
block|,
literal|"dle"
block|,
literal|"dc1"
block|,
literal|"dc2"
block|,
literal|"dc3"
block|,
literal|"dc4"
block|,
literal|"nak"
block|,
literal|"syn"
block|,
literal|"etb"
block|,
literal|"can"
block|,
literal|"em"
block|,
literal|"sub"
block|,
literal|"esc"
block|,
literal|"fs"
block|,
literal|"gs"
block|,
literal|"rs"
block|,
literal|"us"
block|}
decl_stmt|;
end_decl_stmt

begin_function
DECL|function|is_ascii_name (const char * name,int * pc)
specifier|static
name|int
name|is_ascii_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|pc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|charnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pc
operator|=
name|i
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"del"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pc
operator|=
literal|127
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes expected AFTER lead byte of UTF-8 character. */
end_comment

begin_decl_stmt
DECL|variable|utf8_length
specifier|static
specifier|const
name|char
name|utf8_length
index|[
literal|64
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0xc0-0xcf */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0xd0-0xdf */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 0xe0-0xef */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|0
comment|/* 0xf0-0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|file_push
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_pop
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_interactive
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|int
name|is_one_of
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|gunichar
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_cellseg
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|binary_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|pointer
name|get_cell
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|_get_cell
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|reserve_cells
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|get_consecutive_cells
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|find_consecutive_cells
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finalize_cell
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_consecutive_cells
parameter_list|(
name|pointer
name|x
parameter_list|,
name|int
name|needed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|find_slot_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|env
parameter_list|,
name|pointer
name|sym
parameter_list|,
name|int
name|all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_number
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|num
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|store_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|gunichar
name|fill
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_vector
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_atom
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_sharp_const
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_port
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|port
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|port_from_filename
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|int
name|prop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|port_from_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
name|prop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|port_from_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|past_the_end
parameter_list|,
name|int
name|prop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|port
modifier|*
name|port_rep_from_filename
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|int
name|prop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|port
modifier|*
name|port_rep_from_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
name|prop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|port
modifier|*
name|port_rep_from_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|past_the_end
parameter_list|,
name|int
name|prop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|port_close
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|p
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark
parameter_list|(
name|pointer
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gunichar
name|inchar
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|backchar
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|gunichar
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|readstr_upto
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|delim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|readstrexp
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|void
name|skipspace
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|token
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printslashstring
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atom2str
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|l
parameter_list|,
name|int
name|f
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printatom
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|l
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_proc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_closure
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|c
parameter_list|,
name|pointer
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|mk_continuation
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|reverse
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|reverse_in_place
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|term
parameter_list|,
name|pointer
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|append
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|list_length
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eqv
parameter_list|(
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|void
name|dump_stack_mark
parameter_list|(
name|scheme
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_0
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_1
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_2
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_3
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_4
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_5
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pointer
name|opexe_6
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Eval_Cycle
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_syntax
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|syntaxnum
parameter_list|(
name|pointer
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_proc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|scheme
modifier|*
name|scheme_init_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
DECL|macro|num_ivalue (n)
define|#
directive|define
name|num_ivalue
parameter_list|(
name|n
parameter_list|)
value|(n.is_fixnum?(n).value.ivalue:(long)(n).value.rvalue)
end_define

begin_define
DECL|macro|num_rvalue (n)
define|#
directive|define
name|num_rvalue
parameter_list|(
name|n
parameter_list|)
value|(!n.is_fixnum?(n).value.rvalue:(double)(n).value.ivalue)
end_define

begin_function
DECL|function|num_add (num a,num b)
specifier|static
name|num
name|num_add
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|is_fixnum
condition|)
block|{
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|+
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|value
operator|.
name|rvalue
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|+
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_mul (num a,num b)
specifier|static
name|num
name|num_mul
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|is_fixnum
condition|)
block|{
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|*
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|value
operator|.
name|rvalue
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|*
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_div (num a,num b)
specifier|static
name|num
name|num_div
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
operator|&&
name|a
operator|.
name|value
operator|.
name|ivalue
operator|%
name|b
operator|.
name|value
operator|.
name|ivalue
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|is_fixnum
condition|)
block|{
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|/
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|value
operator|.
name|rvalue
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|/
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_intdiv (num a,num b)
specifier|static
name|num
name|num_intdiv
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|is_fixnum
condition|)
block|{
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|/
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|value
operator|.
name|rvalue
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|/
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_sub (num a,num b)
specifier|static
name|num
name|num_sub
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|is_fixnum
condition|)
block|{
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|-
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|value
operator|.
name|rvalue
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|-
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_rem (num a,num b)
specifier|static
name|num
name|num_rem
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|long
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|res
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
expr_stmt|;
name|e1
operator|=
name|num_ivalue
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|e2
operator|=
name|num_ivalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|e1
operator|%
name|e2
expr_stmt|;
comment|/* modulo should have same sign as second operand */
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|res
operator|-=
name|labs
argument_list|(
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
name|res
operator|+=
name|labs
argument_list|(
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|res
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_mod (num a,num b)
specifier|static
name|num
name|num_mod
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|num
name|ret
decl_stmt|;
name|long
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|res
decl_stmt|;
name|ret
operator|.
name|is_fixnum
operator|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
expr_stmt|;
name|e1
operator|=
name|num_ivalue
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|e2
operator|=
name|num_ivalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|e1
operator|%
name|e2
expr_stmt|;
if|if
condition|(
name|res
operator|*
name|e2
operator|<
literal|0
condition|)
block|{
comment|/* modulo should have same sign as second operand */
name|e2
operator|=
name|labs
argument_list|(
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
name|res
operator|-=
name|e2
expr_stmt|;
block|}
else|else
block|{
name|res
operator|+=
name|e2
expr_stmt|;
block|}
block|}
name|ret
operator|.
name|value
operator|.
name|ivalue
operator|=
name|res
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_eq (num a,num b)
specifier|static
name|int
name|num_eq
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|is_fixnum
init|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
decl_stmt|;
if|if
condition|(
name|is_fixnum
condition|)
block|{
name|ret
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|==
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|==
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_gt (num a,num b)
specifier|static
name|int
name|num_gt
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|is_fixnum
init|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
decl_stmt|;
if|if
condition|(
name|is_fixnum
condition|)
block|{
name|ret
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|>
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|>
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_ge (num a,num b)
specifier|static
name|int
name|num_ge
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
return|return
operator|!
name|num_lt
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|num_lt (num a,num b)
specifier|static
name|int
name|num_lt
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|is_fixnum
init|=
name|a
operator|.
name|is_fixnum
operator|&&
name|b
operator|.
name|is_fixnum
decl_stmt|;
if|if
condition|(
name|is_fixnum
condition|)
block|{
name|ret
operator|=
name|a
operator|.
name|value
operator|.
name|ivalue
operator|<
name|b
operator|.
name|value
operator|.
name|ivalue
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|num_rvalue
argument_list|(
name|a
argument_list|)
operator|<
name|num_rvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|function|num_le (num a,num b)
specifier|static
name|int
name|num_le
parameter_list|(
name|num
name|a
parameter_list|,
name|num
name|b
parameter_list|)
block|{
return|return
operator|!
name|num_gt
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_MATH
end_if

begin_comment
comment|/* Round to nearest. Round to even if midway */
end_comment

begin_function
DECL|function|round_per_R5RS (double x)
specifier|static
name|double
name|round_per_R5RS
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|double
name|fl
init|=
name|floor
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|double
name|ce
init|=
name|ceil
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|double
name|dfl
init|=
name|x
operator|-
name|fl
decl_stmt|;
name|double
name|dce
init|=
name|ce
operator|-
name|x
decl_stmt|;
if|if
condition|(
name|dfl
operator|>
name|dce
condition|)
block|{
return|return
name|ce
return|;
block|}
elseif|else
if|if
condition|(
name|dfl
operator|<
name|dce
condition|)
block|{
return|return
name|fl
return|;
block|}
else|else
block|{
if|if
condition|(
name|fmod
argument_list|(
name|fl
argument_list|,
literal|2.0
argument_list|)
operator|==
literal|0.0
condition|)
block|{
comment|/* I imagine this holds */
return|return
name|fl
return|;
block|}
else|else
block|{
return|return
name|ce
return|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
DECL|function|is_zero_double (double x)
specifier|static
name|int
name|is_zero_double
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
name|x
operator|<
name|DBL_MIN
operator|&&
name|x
operator|>
operator|-
name|DBL_MIN
return|;
block|}
end_function

begin_function
DECL|function|binary_decode (const char * s)
specifier|static
name|long
name|binary_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|long
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'1'
operator|||
operator|*
name|s
operator|==
literal|'0'
operator|)
condition|)
block|{
name|x
operator|<<=
literal|1
expr_stmt|;
name|x
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* allocate new cell segment */
end_comment

begin_function
DECL|function|alloc_cellseg (scheme * sc,int n)
specifier|static
name|int
name|alloc_cellseg
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|pointer
name|newp
decl_stmt|;
name|pointer
name|last
decl_stmt|;
name|pointer
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|adj
init|=
name|ADJ
decl_stmt|;
if|if
condition|(
name|adj
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cell
argument_list|)
condition|)
block|{
name|adj
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cell
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|last_cell_seg
operator|>=
name|CELL_NSEGMENT
operator|-
literal|1
condition|)
return|return
name|k
return|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
name|CELL_SEGSIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cell
argument_list|)
operator|+
name|adj
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
name|k
return|;
name|i
operator|=
operator|++
name|sc
operator|->
name|last_cell_seg
expr_stmt|;
name|sc
operator|->
name|alloc_seg
index|[
name|i
index|]
operator|=
name|cp
expr_stmt|;
comment|/* adjust in TYPE_BITS-bit boundary */
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|cp
operator|)
operator|%
name|adj
operator|!=
literal|0
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|adj
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|)
name|cp
operator|/
name|adj
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* insert new segment in address order */
name|newp
operator|=
operator|(
name|pointer
operator|)
name|cp
expr_stmt|;
name|sc
operator|->
name|cell_seg
index|[
name|i
index|]
operator|=
name|newp
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|sc
operator|->
name|cell_seg
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|sc
operator|->
name|cell_seg
index|[
name|i
index|]
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|cell_seg
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|cell_seg
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|cell_seg
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|cell_seg
index|[
operator|--
name|i
index|]
operator|=
name|p
expr_stmt|;
block|}
name|sc
operator|->
name|fcells
operator|+=
name|CELL_SEGSIZE
expr_stmt|;
name|last
operator|=
name|newp
operator|+
name|CELL_SEGSIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|newp
init|;
name|p
operator|<=
name|last
condition|;
name|p
operator|++
control|)
block|{
name|typeflag
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|car
argument_list|(
name|p
argument_list|)
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
comment|/* insert new cells in address order on free list */
if|if
condition|(
name|sc
operator|->
name|free_cell
operator|==
name|sc
operator|->
name|NIL
operator|||
name|p
operator|<
name|sc
operator|->
name|free_cell
condition|)
block|{
name|cdr
argument_list|(
name|last
argument_list|)
operator|=
name|sc
operator|->
name|free_cell
expr_stmt|;
name|sc
operator|->
name|free_cell
operator|=
name|newp
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|sc
operator|->
name|free_cell
expr_stmt|;
while|while
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
operator|&&
name|newp
operator|>
name|cdr
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cdr
argument_list|(
name|last
argument_list|)
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|newp
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
DECL|function|get_cell_x (scheme * sc,pointer a,pointer b)
specifier|static
name|INLINE
name|pointer
name|get_cell_x
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|free_cell
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|pointer
name|x
init|=
name|sc
operator|->
name|free_cell
decl_stmt|;
name|sc
operator|->
name|free_cell
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|fcells
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
return|return
name|_get_cell
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* get new cell.  parameter a, b is marked by gc. */
end_comment

begin_function
DECL|function|_get_cell (scheme * sc,pointer a,pointer b)
specifier|static
name|pointer
name|_get_cell
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
return|return
name|sc
operator|->
name|sink
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|free_cell
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
specifier|const
name|int
name|min_to_be_recovered
init|=
name|sc
operator|->
name|last_cell_seg
operator|*
literal|8
decl_stmt|;
name|gc
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fcells
operator|<
name|min_to_be_recovered
operator|||
name|sc
operator|->
name|free_cell
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
comment|/* if only a few recovered, get more to avoid fruitless gc's */
if|if
condition|(
operator|!
name|alloc_cellseg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|&&
name|sc
operator|->
name|free_cell
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
name|sc
operator|->
name|sink
return|;
block|}
block|}
block|}
name|x
operator|=
name|sc
operator|->
name|free_cell
expr_stmt|;
name|sc
operator|->
name|free_cell
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|fcells
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* make sure that there is a given number of cells free */
end_comment

begin_function
DECL|function|reserve_cells (scheme * sc,int n)
specifier|static
name|pointer
name|reserve_cells
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
comment|/* Are there enough cells available? */
if|if
condition|(
name|sc
operator|->
name|fcells
operator|<
name|n
condition|)
block|{
comment|/* If not, try gc'ing some */
name|gc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fcells
operator|<
name|n
condition|)
block|{
comment|/* If there still aren't, try getting more heap */
if|if
condition|(
operator|!
name|alloc_cellseg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
name|sc
operator|->
name|NIL
return|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|fcells
operator|<
name|n
condition|)
block|{
comment|/* If all fail, report failure */
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
name|sc
operator|->
name|NIL
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|->
name|T
operator|)
return|;
block|}
end_function

begin_function
DECL|function|get_consecutive_cells (scheme * sc,int n)
specifier|static
name|pointer
name|get_consecutive_cells
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
return|return
name|sc
operator|->
name|sink
return|;
block|}
comment|/* Are there any cells available? */
name|x
operator|=
name|find_consecutive_cells
argument_list|(
name|sc
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
name|x
return|;
block|}
comment|/* If not, try gc'ing some */
name|gc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|x
operator|=
name|find_consecutive_cells
argument_list|(
name|sc
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
name|x
return|;
block|}
comment|/* If there still aren't, try getting more heap */
if|if
condition|(
operator|!
name|alloc_cellseg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
name|sc
operator|->
name|sink
return|;
block|}
name|x
operator|=
name|find_consecutive_cells
argument_list|(
name|sc
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
name|x
return|;
block|}
comment|/* If all fail, report failure */
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
name|sc
operator|->
name|sink
return|;
block|}
end_function

begin_function
DECL|function|count_consecutive_cells (pointer x,int needed)
specifier|static
name|int
name|count_consecutive_cells
parameter_list|(
name|pointer
name|x
parameter_list|,
name|int
name|needed
parameter_list|)
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cdr
argument_list|(
name|x
argument_list|)
operator|==
name|x
operator|+
literal|1
condition|)
block|{
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|needed
condition|)
return|return
name|n
return|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
DECL|function|find_consecutive_cells (scheme * sc,int n)
specifier|static
name|pointer
name|find_consecutive_cells
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|pointer
modifier|*
name|pp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|pp
operator|=
operator|&
name|sc
operator|->
name|free_cell
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|cnt
operator|=
name|count_consecutive_cells
argument_list|(
operator|*
name|pp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
name|n
condition|)
block|{
name|pointer
name|x
init|=
operator|*
name|pp
decl_stmt|;
operator|*
name|pp
operator|=
name|cdr
argument_list|(
operator|*
name|pp
operator|+
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fcells
operator|-=
name|n
expr_stmt|;
return|return
name|x
return|;
block|}
name|pp
operator|=
operator|&
name|cdr
argument_list|(
operator|*
name|pp
operator|+
name|cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_comment
comment|/* To retain recent allocs before interpreter knows about them -    Tehom */
end_comment

begin_function
DECL|function|push_recent_alloc (scheme * sc,pointer recent,pointer extra)
specifier|static
name|void
name|push_recent_alloc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|recent
parameter_list|,
name|pointer
name|extra
parameter_list|)
block|{
name|pointer
name|holder
init|=
name|get_cell_x
argument_list|(
name|sc
argument_list|,
name|recent
argument_list|,
name|extra
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|holder
argument_list|)
operator|=
name|T_PAIR
operator||
name|T_IMMUTABLE
expr_stmt|;
name|car
argument_list|(
name|holder
argument_list|)
operator|=
name|recent
expr_stmt|;
name|cdr
argument_list|(
name|holder
argument_list|)
operator|=
name|car
argument_list|(
name|sc
operator|->
name|sink
argument_list|)
expr_stmt|;
name|car
argument_list|(
name|sc
operator|->
name|sink
argument_list|)
operator|=
name|holder
expr_stmt|;
block|}
end_function

begin_function
DECL|function|get_cell (scheme * sc,pointer a,pointer b)
specifier|static
name|pointer
name|get_cell
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
name|pointer
name|cell
init|=
name|get_cell_x
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
comment|/* For right now, include "a" and "b" in "cell" so that gc doesn't      think they are garbage. */
comment|/* Tentatively record it as a pair so gc understands it. */
name|typeflag
argument_list|(
name|cell
argument_list|)
operator|=
name|T_PAIR
expr_stmt|;
name|car
argument_list|(
name|cell
argument_list|)
operator|=
name|a
expr_stmt|;
name|cdr
argument_list|(
name|cell
argument_list|)
operator|=
name|b
expr_stmt|;
name|push_recent_alloc
argument_list|(
name|sc
argument_list|,
name|cell
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
return|return
name|cell
return|;
block|}
end_function

begin_function
DECL|function|get_vector_object (scheme * sc,int len,pointer init)
specifier|static
name|pointer
name|get_vector_object
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|pointer
name|init
parameter_list|)
block|{
name|pointer
name|cells
init|=
name|get_consecutive_cells
argument_list|(
name|sc
argument_list|,
name|len
operator|/
literal|2
operator|+
name|len
operator|%
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
return|return
name|sc
operator|->
name|sink
return|;
block|}
comment|/* Record it as a vector so that gc understands it. */
name|typeflag
argument_list|(
name|cells
argument_list|)
operator|=
operator|(
name|T_VECTOR
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|ivalue_unchecked
argument_list|(
name|cells
argument_list|)
operator|=
name|len
expr_stmt|;
name|set_num_integer
argument_list|(
name|cells
argument_list|)
expr_stmt|;
name|fill_vector
argument_list|(
name|cells
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|push_recent_alloc
argument_list|(
name|sc
argument_list|,
name|cells
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
return|return
name|cells
return|;
block|}
end_function

begin_function
DECL|function|ok_to_freely_gc (scheme * sc)
specifier|static
name|INLINE
name|void
name|ok_to_freely_gc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|car
argument_list|(
name|sc
operator|->
name|sink
argument_list|)
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|TSGRIND
end_if

begin_function
DECL|function|check_cell_alloced (pointer p,int expect_alloced)
specifier|static
name|void
name|check_cell_alloced
parameter_list|(
name|pointer
name|p
parameter_list|,
name|int
name|expect_alloced
parameter_list|)
block|{
comment|/* Can't use putstr(sc,str) because callers have no access to      sc.  */
if|if
condition|(
name|typeflag
argument_list|(
name|p
argument_list|)
operator|&
operator|!
name|expect_alloced
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cell is already allocated!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|typeflag
argument_list|(
name|p
argument_list|)
operator|)
operator|&
name|expect_alloced
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cell is not allocated!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|check_range_alloced (pointer p,int n,int expect_alloced)
specifier|static
name|void
name|check_range_alloced
parameter_list|(
name|pointer
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|expect_alloced
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|check_cell_alloced
argument_list|(
name|p
operator|+
name|i
argument_list|,
name|expect_alloced
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Medium level cell allocation */
end_comment

begin_comment
comment|/* get new cons cell */
end_comment

begin_function
DECL|function|_cons (scheme * sc,pointer a,pointer b,int immutable)
name|pointer
name|_cons
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|,
name|int
name|immutable
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_PAIR
expr_stmt|;
if|if
condition|(
name|immutable
condition|)
block|{
name|setimmutable
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|car
argument_list|(
name|x
argument_list|)
operator|=
name|a
expr_stmt|;
name|cdr
argument_list|(
name|x
argument_list|)
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ========== oblist implementation  ========== */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_OBJECT_LIST
end_ifndef

begin_function_decl
specifier|static
name|int
name|hash_fn
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int
name|table_size
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|function|oblist_initial_value (scheme * sc)
specifier|static
name|pointer
name|oblist_initial_value
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|mk_vector
argument_list|(
name|sc
argument_list|,
literal|461
argument_list|)
return|;
comment|/* probably should be bigger */
block|}
end_function

begin_comment
comment|/* returns the new symbol */
end_comment

begin_function
DECL|function|oblist_add_by_name (scheme * sc,const char * name)
specifier|static
name|pointer
name|oblist_add_by_name
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|int
name|location
decl_stmt|;
name|x
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|mk_string
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_SYMBOL
expr_stmt|;
name|setimmutable
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|location
operator|=
name|hash_fn
argument_list|(
name|name
argument_list|,
name|ivalue_unchecked
argument_list|(
name|sc
operator|->
name|oblist
argument_list|)
argument_list|)
expr_stmt|;
name|set_vector_elem
argument_list|(
name|sc
operator|->
name|oblist
argument_list|,
name|location
argument_list|,
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|vector_elem
argument_list|(
name|sc
operator|->
name|oblist
argument_list|,
name|location
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
DECL|function|oblist_find_by_name (scheme * sc,const char * name)
specifier|static
name|INLINE
name|pointer
name|oblist_find_by_name
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|location
decl_stmt|;
name|pointer
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|location
operator|=
name|hash_fn
argument_list|(
name|name
argument_list|,
name|ivalue_unchecked
argument_list|(
name|sc
operator|->
name|oblist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|vector_elem
argument_list|(
name|sc
operator|->
name|oblist
argument_list|,
name|location
argument_list|)
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|s
operator|=
name|symname
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* case-insensitive, per R5RS section 2. */
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|car
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_function
DECL|function|oblist_all_symbols (scheme * sc)
specifier|static
name|pointer
name|oblist_all_symbols
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pointer
name|x
decl_stmt|;
name|pointer
name|ob_list
init|=
name|sc
operator|->
name|NIL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivalue_unchecked
argument_list|(
name|sc
operator|->
name|oblist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
name|vector_elem
argument_list|(
name|sc
operator|->
name|oblist
argument_list|,
name|i
argument_list|)
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|ob_list
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|ob_list
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ob_list
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
DECL|function|oblist_initial_value (scheme * sc)
specifier|static
name|pointer
name|oblist_initial_value
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_function
DECL|function|oblist_find_by_name (scheme * sc,const char * name)
specifier|static
name|INLINE
name|pointer
name|oblist_find_by_name
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|oblist
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|s
operator|=
name|symname
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* case-insensitive, per R5RS section 2. */
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|car
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_comment
comment|/* returns the new symbol */
end_comment

begin_function
DECL|function|oblist_add_by_name (scheme * sc,const char * name)
specifier|static
name|pointer
name|oblist_add_by_name
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|x
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|mk_string
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_SYMBOL
expr_stmt|;
name|setimmutable
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|oblist
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|oblist
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
DECL|function|oblist_all_symbols (scheme * sc)
specifier|static
name|pointer
name|oblist_all_symbols
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|sc
operator|->
name|oblist
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
DECL|function|mk_port (scheme * sc,port * p)
specifier|static
name|pointer
name|mk_port
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|port
modifier|*
name|p
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_PORT
operator||
name|T_ATOM
expr_stmt|;
name|x
operator|->
name|_object
operator|.
name|_port
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mk_foreign_func (scheme * sc,foreign_func f)
name|pointer
name|mk_foreign_func
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|foreign_func
name|f
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|T_FOREIGN
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|x
operator|->
name|_object
operator|.
name|_ff
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mk_character (scheme * sc,gunichar c)
name|INTERFACE
name|pointer
name|mk_character
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|gunichar
name|c
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|T_CHARACTER
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|ivalue_unchecked
argument_list|(
name|x
argument_list|)
operator|=
name|c
expr_stmt|;
name|set_num_integer
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get number atom (integer) */
end_comment

begin_function
DECL|function|mk_integer (scheme * sc,long num)
name|INTERFACE
name|pointer
name|mk_integer
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|long
name|num
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|T_NUMBER
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|ivalue_unchecked
argument_list|(
name|x
argument_list|)
operator|=
name|num
expr_stmt|;
name|set_num_integer
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mk_real (scheme * sc,double n)
name|INTERFACE
name|pointer
name|mk_real
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|double
name|n
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|T_NUMBER
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|rvalue_unchecked
argument_list|(
name|x
argument_list|)
operator|=
name|n
expr_stmt|;
name|set_num_real
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mk_number (scheme * sc,num n)
specifier|static
name|pointer
name|mk_number
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|num
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|.
name|is_fixnum
condition|)
block|{
return|return
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|n
operator|.
name|value
operator|.
name|ivalue
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mk_real
argument_list|(
name|sc
argument_list|,
name|n
operator|.
name|value
operator|.
name|rvalue
argument_list|)
return|;
block|}
block|}
end_function

begin_function
DECL|function|foreign_error (scheme * sc,const char * s,pointer a)
name|pointer
name|foreign_error
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
name|sc
operator|->
name|foreign_error
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_string
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_comment
comment|/* char_cnt is length of string in chars. */
end_comment

begin_comment
comment|/* str points to a NUL terminated string. */
end_comment

begin_comment
comment|/* Only uses fill_char if str is NULL.    */
end_comment

begin_function
DECL|function|store_string (scheme * sc,int char_cnt,const char * str,gunichar fill)
specifier|static
name|char
modifier|*
name|store_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|char_cnt
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|gunichar
name|fill
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gchar
name|utf8
index|[
literal|7
index|]
decl_stmt|;
name|gchar
modifier|*
name|q
decl_stmt|;
name|gchar
modifier|*
name|q2
decl_stmt|;
if|if
condition|(
name|str
operator|!=
literal|0
condition|)
block|{
name|q2
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|char_cnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|g_utf8_validate
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
operator|&
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|<=
name|q2
condition|)
name|len
operator|=
name|q
operator|-
name|str
expr_stmt|;
else|else
name|len
operator|=
name|q2
operator|-
name|str
expr_stmt|;
name|q
operator|=
operator|(
name|gchar
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|g_unichar_to_utf8
argument_list|(
name|fill
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|gchar
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
name|char_cnt
operator|*
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
name|sc
operator|->
name|strbuff
return|;
block|}
if|if
condition|(
name|str
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|q
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|q2
operator|=
name|q
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|char_cnt
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|q2
argument_list|,
name|utf8
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q2
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|q2
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get new string */
end_comment

begin_function
DECL|function|mk_string (scheme * sc,const char * str)
name|INTERFACE
name|pointer
name|mk_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|mk_counted_string
argument_list|(
name|sc
argument_list|,
name|str
argument_list|,
name|g_utf8_strlen
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* len is the length of str in characters */
end_comment

begin_function
DECL|function|mk_counted_string (scheme * sc,const char * str,int len)
name|INTERFACE
name|pointer
name|mk_counted_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|T_STRING
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|strvalue
argument_list|(
name|x
argument_list|)
operator|=
name|store_string
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strlength
argument_list|(
name|x
argument_list|)
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mk_empty_string (scheme * sc,int len,gunichar fill)
name|INTERFACE
name|pointer
name|mk_empty_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|gunichar
name|fill
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|T_STRING
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|strvalue
argument_list|(
name|x
argument_list|)
operator|=
name|store_string
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|fill
argument_list|)
expr_stmt|;
name|strlength
argument_list|(
name|x
argument_list|)
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mk_vector (scheme * sc,int len)
name|INTERFACE
specifier|static
name|pointer
name|mk_vector
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|get_vector_object
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|fill_vector (pointer vec,pointer obj)
name|INTERFACE
specifier|static
name|void
name|fill_vector
parameter_list|(
name|pointer
name|vec
parameter_list|,
name|pointer
name|obj
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num
init|=
name|ivalue
argument_list|(
name|vec
argument_list|)
operator|/
literal|2
operator|+
name|ivalue
argument_list|(
name|vec
argument_list|)
operator|%
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|typeflag
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|i
argument_list|)
operator|=
name|T_PAIR
expr_stmt|;
name|setimmutable
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|car
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|i
argument_list|)
operator|=
name|obj
expr_stmt|;
name|cdr
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|i
argument_list|)
operator|=
name|obj
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|vector_elem (pointer vec,int ielem)
name|INTERFACE
specifier|static
name|pointer
name|vector_elem
parameter_list|(
name|pointer
name|vec
parameter_list|,
name|int
name|ielem
parameter_list|)
block|{
name|int
name|n
init|=
name|ielem
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|ielem
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
return|return
name|car
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|n
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|cdr
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|n
argument_list|)
return|;
block|}
block|}
end_function

begin_function
DECL|function|set_vector_elem (pointer vec,int ielem,pointer a)
name|INTERFACE
specifier|static
name|pointer
name|set_vector_elem
parameter_list|(
name|pointer
name|vec
parameter_list|,
name|int
name|ielem
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
name|int
name|n
init|=
name|ielem
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|ielem
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
return|return
name|car
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|n
argument_list|)
operator|=
name|a
return|;
block|}
else|else
block|{
return|return
name|cdr
argument_list|(
name|vec
operator|+
literal|1
operator|+
name|n
argument_list|)
operator|=
name|a
return|;
block|}
block|}
end_function

begin_comment
comment|/* get new symbol */
end_comment

begin_function
DECL|function|mk_symbol (scheme * sc,const char * name)
name|INTERFACE
name|pointer
name|mk_symbol
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
comment|/* first check oblist */
name|x
operator|=
name|oblist_find_by_name
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
block|{
name|x
operator|=
name|oblist_add_by_name
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
end_function

begin_function
DECL|function|gensym (scheme * sc)
name|INTERFACE
name|pointer
name|gensym
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|char
name|name
index|[
literal|40
index|]
decl_stmt|;
for|for
control|(
init|;
name|sc
operator|->
name|gensym_cnt
operator|<
name|LONG_MAX
condition|;
name|sc
operator|->
name|gensym_cnt
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
literal|40
argument_list|,
literal|"gensym-%ld"
argument_list|,
name|sc
operator|->
name|gensym_cnt
argument_list|)
expr_stmt|;
comment|/* first check oblist */
name|x
operator|=
name|oblist_find_by_name
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|x
operator|=
name|oblist_add_by_name
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_comment
comment|/* make symbol or number atom from string */
end_comment

begin_function
DECL|function|mk_atom (scheme * sc,char * q)
specifier|static
name|pointer
name|mk_atom
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|q
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|has_dec_point
init|=
literal|0
decl_stmt|;
name|int
name|has_fp_exp
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|USE_COLON_HOOK
if|if
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|q
argument_list|,
literal|"::"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|COLON_HOOK
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|QUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_atom
argument_list|(
name|sc
argument_list|,
name|p
operator|+
literal|2
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|strlwr
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
name|p
operator|=
name|q
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|has_dec_point
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|strlwr
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|has_dec_point
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|strlwr
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|strlwr
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
return|;
block|}
for|for
control|(
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|0
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|has_dec_point
condition|)
block|{
name|has_dec_point
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|has_fp_exp
condition|)
block|{
name|has_dec_point
operator|=
literal|1
expr_stmt|;
comment|/* decimal point illegal                                                 from now on */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|||
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
block|}
return|return
operator|(
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|strlwr
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|has_dec_point
condition|)
block|{
return|return
name|mk_real
argument_list|(
name|sc
argument_list|,
name|g_ascii_strtod
argument_list|(
name|q
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|(
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|atol
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* make constant */
end_comment

begin_function
DECL|function|mk_sharp_const (scheme * sc,char * name)
specifier|static
name|pointer
name|mk_sharp_const
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|long
name|x
decl_stmt|;
name|char
name|tmp
index|[
name|STRBUFFSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"t"
argument_list|)
condition|)
return|return
operator|(
name|sc
operator|->
name|T
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"f"
argument_list|)
condition|)
return|return
operator|(
name|sc
operator|->
name|F
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'o'
condition|)
block|{
comment|/* #o (octal) */
name|snprintf
argument_list|(
name|tmp
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"0%s"
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|tmp
argument_list|,
literal|"%lo"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'d'
condition|)
block|{
comment|/* #d (decimal) */
name|sscanf
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'x'
condition|)
block|{
comment|/* #x (hex) */
name|snprintf
argument_list|(
name|tmp
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"0x%s"
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|tmp
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'b'
condition|)
block|{
comment|/* #b (binary) */
name|x
operator|=
name|binary_decode
argument_list|(
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\\'
condition|)
block|{
comment|/* #\w (character) */
name|gunichar
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stricmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"newline"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"return"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"tab"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
literal|'\t'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'x'
operator|&&
name|name
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|c1
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|name
operator|+
literal|2
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|c1
argument_list|)
operator|==
literal|1
operator|&&
name|c1
operator|<
name|UCHAR_MAX
condition|)
block|{
name|c
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
if|#
directive|if
name|USE_ASCII_NAMES
block|}
elseif|else
if|if
condition|(
name|is_ascii_name
argument_list|(
name|name
operator|+
literal|1
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
comment|/* nothing */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|name
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
return|return
name|mk_character
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
return|;
block|}
else|else
return|return
operator|(
name|sc
operator|->
name|NIL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ========== garbage collector ========== */
end_comment

begin_comment
comment|/*--  *  We use algorithm E (Knuth, The Art of Computer Programming Vol.1,  *  sec. 2.3.5), the Schorr-Deutsch-Waite link-inversion algorithm,  *  for marking.  */
end_comment

begin_function
DECL|function|mark (pointer a)
specifier|static
name|void
name|mark
parameter_list|(
name|pointer
name|a
parameter_list|)
block|{
name|pointer
name|t
decl_stmt|,
name|q
decl_stmt|,
name|p
decl_stmt|;
name|t
operator|=
operator|(
name|pointer
operator|)
literal|0
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|E2
label|:
name|setmark
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_vector
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num
init|=
name|ivalue_unchecked
argument_list|(
name|p
argument_list|)
operator|/
literal|2
operator|+
name|ivalue_unchecked
argument_list|(
name|p
argument_list|)
operator|%
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Vector cells will be treated like ordinary cells */
name|mark
argument_list|(
name|p
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_atom
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|E6
goto|;
comment|/* E4: down car */
name|q
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|!
name|is_mark
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|setatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* a note that we have moved car */
name|car
argument_list|(
name|p
argument_list|)
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
goto|goto
name|E2
goto|;
block|}
name|E5
label|:
name|q
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* down cdr */
if|if
condition|(
name|q
operator|&&
operator|!
name|is_mark
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
goto|goto
name|E2
goto|;
block|}
name|E6
label|:
comment|/* up.  Undo the link switching from steps E4 and E5. */
if|if
condition|(
operator|!
name|t
condition|)
return|return;
name|q
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|is_atom
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|clratom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|t
operator|=
name|car
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|car
argument_list|(
name|q
argument_list|)
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
goto|goto
name|E5
goto|;
block|}
else|else
block|{
name|t
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cdr
argument_list|(
name|q
argument_list|)
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
goto|goto
name|E6
goto|;
block|}
block|}
end_function

begin_comment
comment|/* garbage collection. parameter a, b is marked. */
end_comment

begin_function
DECL|function|gc (scheme * sc,pointer a,pointer b)
specifier|static
name|void
name|gc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
name|pointer
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gc_verbose
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"gc..."
argument_list|)
expr_stmt|;
block|}
comment|/* mark system globals */
name|mark
argument_list|(
name|sc
operator|->
name|oblist
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|global_env
argument_list|)
expr_stmt|;
comment|/* mark current registers */
name|mark
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|dump_stack_mark
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|inport
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|save_inport
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|outport
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|sc
operator|->
name|loadport
argument_list|)
expr_stmt|;
comment|/* Mark recent objects the interpreter doesn't know about yet. */
name|mark
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|sink
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark variables a, b */
name|mark
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* garbage collect */
name|clrmark
argument_list|(
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fcells
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|free_cell
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
comment|/* free-list is kept sorted by address so as to maintain consecutive      ranges, if possible, for use with vectors. Here we scan the cells      (which are also kept sorted by address) downwards to build the      free-list in sorted order.   */
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|last_cell_seg
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|p
operator|=
name|sc
operator|->
name|cell_seg
index|[
name|i
index|]
operator|+
name|CELL_SEGSIZE
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|sc
operator|->
name|cell_seg
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|is_mark
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|clrmark
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reclaim cell */
if|if
condition|(
name|typeflag
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|finalize_cell
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|car
argument_list|(
name|p
argument_list|)
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
operator|++
name|sc
operator|->
name|fcells
expr_stmt|;
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|sc
operator|->
name|free_cell
expr_stmt|;
name|sc
operator|->
name|free_cell
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|gc_verbose
condition|)
block|{
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
literal|80
argument_list|,
literal|"done: %ld cells were recovered.\n"
argument_list|,
name|sc
operator|->
name|fcells
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|finalize_cell (scheme * sc,pointer a)
specifier|static
name|void
name|finalize_cell
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
if|if
condition|(
name|is_string
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|sc
operator|->
name|free
argument_list|(
name|strvalue
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_port
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|_object
operator|.
name|_port
operator|->
name|kind
operator|&
name|port_file
operator|&&
name|a
operator|->
name|_object
operator|.
name|_port
operator|->
name|rep
operator|.
name|stdio
operator|.
name|closeit
condition|)
block|{
name|port_close
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|port_input
operator||
name|port_output
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|free
argument_list|(
name|a
operator|->
name|_object
operator|.
name|_port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========== Routines for Reading ========== */
end_comment

begin_function
DECL|function|file_push (scheme * sc,const char * fname)
specifier|static
name|int
name|file_push
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|fin
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|file_i
operator|==
name|MAXFIL
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|fin
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|file_i
operator|++
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|.
name|kind
operator|=
name|port_file
operator||
name|port_input
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|.
name|rep
operator|.
name|stdio
operator|.
name|file
operator|=
name|fin
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|.
name|rep
operator|.
name|stdio
operator|.
name|closeit
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|nesting_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|loadport
operator|->
name|_object
operator|.
name|_port
operator|=
name|sc
operator|->
name|load_stack
operator|+
name|sc
operator|->
name|file_i
expr_stmt|;
block|}
return|return
name|fin
operator|!=
literal|0
return|;
block|}
end_function

begin_function
DECL|function|file_pop (scheme * sc)
specifier|static
name|void
name|file_pop
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|nesting
operator|=
name|sc
operator|->
name|nesting_stack
index|[
name|sc
operator|->
name|file_i
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|file_i
operator|!=
literal|0
condition|)
block|{
name|port_close
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|loadport
argument_list|,
name|port_input
argument_list|)
expr_stmt|;
name|sc
operator|->
name|file_i
operator|--
expr_stmt|;
name|sc
operator|->
name|loadport
operator|->
name|_object
operator|.
name|_port
operator|=
name|sc
operator|->
name|load_stack
operator|+
name|sc
operator|->
name|file_i
expr_stmt|;
if|if
condition|(
name|file_interactive
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|file_interactive (scheme * sc)
specifier|static
name|int
name|file_interactive
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|sc
operator|->
name|file_i
operator|==
literal|0
operator|&&
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|rep
operator|.
name|stdio
operator|.
name|file
operator|==
name|stdin
operator|&&
name|sc
operator|->
name|inport
operator|->
name|_object
operator|.
name|_port
operator|->
name|kind
operator|&
name|port_file
return|;
block|}
end_function

begin_function
DECL|function|port_rep_from_filename (scheme * sc,const char * fn,int prop)
specifier|static
name|port
modifier|*
name|port_rep_from_filename
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|int
name|prop
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|rw
decl_stmt|;
name|port
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|prop
operator|==
operator|(
name|port_input
operator||
name|port_output
operator|)
condition|)
block|{
name|rw
operator|=
literal|"a+b"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|port_output
condition|)
block|{
name|rw
operator|=
literal|"wb"
expr_stmt|;
block|}
else|else
block|{
name|rw
operator|=
literal|"rb"
expr_stmt|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
name|rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|pt
operator|=
name|port_rep_from_file
argument_list|(
name|sc
argument_list|,
name|f
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|closeit
operator|=
literal|1
expr_stmt|;
return|return
name|pt
return|;
block|}
end_function

begin_function
DECL|function|port_from_filename (scheme * sc,const char * fn,int prop)
specifier|static
name|pointer
name|port_from_filename
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|int
name|prop
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|port_rep_from_filename
argument_list|(
name|sc
argument_list|,
name|fn
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
literal|0
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
return|return
name|mk_port
argument_list|(
name|sc
argument_list|,
name|pt
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|port_rep_from_file (scheme * sc,FILE * f,int prop)
specifier|static
name|port
modifier|*
name|port_rep_from_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|prop
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
operator|(
name|port
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|pt
operator|->
name|kind
operator|=
name|port_file
operator||
name|prop
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
operator|=
name|f
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|closeit
operator|=
literal|0
expr_stmt|;
return|return
name|pt
return|;
block|}
end_function

begin_function
DECL|function|port_from_file (scheme * sc,FILE * f,int prop)
specifier|static
name|pointer
name|port_from_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|prop
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|port_rep_from_file
argument_list|(
name|sc
argument_list|,
name|f
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
literal|0
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
return|return
name|mk_port
argument_list|(
name|sc
argument_list|,
name|pt
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|port_rep_from_string (scheme * sc,char * start,char * past_the_end,int prop)
specifier|static
name|port
modifier|*
name|port_rep_from_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|past_the_end
parameter_list|,
name|int
name|prop
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
operator|(
name|port
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|pt
operator|->
name|kind
operator|=
name|port_string
operator||
name|prop
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|=
name|start
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|=
name|past_the_end
expr_stmt|;
return|return
name|pt
return|;
block|}
end_function

begin_function
DECL|function|port_from_string (scheme * sc,char * start,char * past_the_end,int prop)
specifier|static
name|pointer
name|port_from_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|past_the_end
parameter_list|,
name|int
name|prop
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|port_rep_from_string
argument_list|(
name|sc
argument_list|,
name|start
argument_list|,
name|past_the_end
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
literal|0
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
return|return
name|mk_port
argument_list|(
name|sc
argument_list|,
name|pt
argument_list|)
return|;
block|}
end_function

begin_define
DECL|macro|BLOCK_SIZE
define|#
directive|define
name|BLOCK_SIZE
value|256
end_define

begin_function
DECL|function|port_rep_from_scratch (scheme * sc)
specifier|static
name|port
modifier|*
name|port_rep_from_scratch
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|pt
operator|=
operator|(
name|port
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|start
operator|=
name|sc
operator|->
name|malloc
argument_list|(
name|BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|start
argument_list|,
literal|' '
argument_list|,
name|BLOCK_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|start
index|[
name|BLOCK_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pt
operator|->
name|kind
operator|=
name|port_string
operator||
name|port_output
operator||
name|port_srfi6
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|=
name|start
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|=
name|start
operator|+
name|BLOCK_SIZE
operator|-
literal|1
expr_stmt|;
return|return
name|pt
return|;
block|}
end_function

begin_function
DECL|function|port_from_scratch (scheme * sc)
specifier|static
name|pointer
name|port_from_scratch
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|port_rep_from_scratch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
literal|0
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
return|return
name|mk_port
argument_list|(
name|sc
argument_list|,
name|pt
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|port_close (scheme * sc,pointer p,int flag)
specifier|static
name|void
name|port_close
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|p
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|port
modifier|*
name|pt
init|=
name|p
operator|->
name|_object
operator|.
name|_port
decl_stmt|;
name|pt
operator|->
name|kind
operator|&=
operator|~
name|flag
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|->
name|kind
operator|&
operator|(
name|port_input
operator||
name|port_output
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|kind
operator|&
name|port_file
condition|)
block|{
name|fclose
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
name|pt
operator|->
name|kind
operator|=
name|port_free
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|basic_inchar (port * pt)
specifier|static
name|gunichar
name|basic_inchar
parameter_list|(
name|port
modifier|*
name|pt
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|kind
operator|&
name|port_file
condition|)
block|{
name|unsigned
name|char
name|utf8
index|[
literal|7
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|utf8
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|utf8
index|[
literal|0
index|]
operator|<=
literal|0x7f
condition|)
block|{
return|return
operator|(
name|gunichar
operator|)
name|utf8
index|[
literal|0
index|]
return|;
block|}
comment|/* Check for valid lead byte per RFC-3629 */
if|if
condition|(
name|utf8
index|[
literal|0
index|]
operator|>=
literal|0xc2
operator|&&
name|utf8
index|[
literal|0
index|]
operator|<=
literal|0xf4
condition|)
block|{
name|len
operator|=
name|utf8_length
index|[
name|utf8
index|[
literal|0
index|]
operator|&
literal|0x3F
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|utf8
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|utf8
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>
name|len
condition|)
block|{
return|return
name|g_utf8_get_char
argument_list|(
operator|(
name|char
operator|*
operator|)
name|utf8
argument_list|)
return|;
block|}
comment|/* we did not get enough continuation characters. */
name|utf8
index|[
literal|0
index|]
operator|=
name|utf8
index|[
name|i
index|]
expr_stmt|;
comment|/* ignore and restart */
block|}
else|else
block|{
comment|/* Everything else is invalid and will be ignored */
name|c
operator|=
name|fgetc
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|utf8
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|==
literal|0
operator|||
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|==
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
condition|)
block|{
return|return
name|EOF
return|;
block|}
else|else
block|{
name|gunichar
name|c
decl_stmt|;
name|len
operator|=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|-
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
expr_stmt|;
name|c
operator|=
name|g_utf8_get_char_validated
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|=
name|g_utf8_find_next_char
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
argument_list|,
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|==
name|NULL
condition|)
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* get new character from input file */
end_comment

begin_function
DECL|function|inchar (scheme * sc)
specifier|static
name|gunichar
name|inchar
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|gunichar
name|c
decl_stmt|;
name|port
modifier|*
name|pt
decl_stmt|;
name|again
label|:
name|pt
operator|=
name|sc
operator|->
name|inport
operator|->
name|_object
operator|.
name|_port
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|kind
operator|&
name|port_file
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bc_flag
condition|)
name|c
operator|=
name|sc
operator|->
name|backchar
index|[
operator|--
name|sc
operator|->
name|bc_flag
index|]
expr_stmt|;
else|else
name|c
operator|=
name|basic_inchar
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|=
name|basic_inchar
argument_list|(
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|sc
operator|->
name|inport
operator|==
name|sc
operator|->
name|loadport
operator|&&
name|sc
operator|->
name|file_i
operator|!=
literal|0
condition|)
block|{
name|file_pop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nesting
operator|!=
literal|0
condition|)
block|{
return|return
name|EOF
return|;
block|}
else|else
block|{
return|return
literal|'\n'
return|;
block|}
goto|goto
name|again
goto|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* back character to input buffer */
end_comment

begin_function
DECL|function|backchar (scheme * sc,gunichar c)
specifier|static
name|void
name|backchar
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|gunichar
name|c
parameter_list|)
block|{
name|port
modifier|*
name|pt
decl_stmt|;
name|gint
name|charlen
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
name|charlen
operator|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pt
operator|=
name|sc
operator|->
name|inport
operator|->
name|_object
operator|.
name|_port
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|kind
operator|&
name|port_file
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bc_flag
operator|<
literal|2
condition|)
name|sc
operator|->
name|backchar
index|[
name|sc
operator|->
name|bc_flag
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|!=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|start
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|-
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|start
operator|>=
name|charlen
condition|)
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|-=
name|charlen
expr_stmt|;
else|else
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|start
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|realloc_port_string (scheme * sc,port * p)
specifier|static
name|int
name|realloc_port_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|port
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|start
init|=
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|start
decl_stmt|;
name|size_t
name|new_size
init|=
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|-
name|start
operator|+
literal|1
operator|+
name|BLOCK_SIZE
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|sc
operator|->
name|malloc
argument_list|(
name|new_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|memset
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|,
name|new_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|str
index|[
name|new_size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|start
operator|=
name|str
expr_stmt|;
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|=
name|str
operator|+
name|new_size
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|-=
name|start
operator|-
name|str
expr_stmt|;
name|sc
operator|->
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* len is number of UTF-8 characters in string pointed to by chars */
end_comment

begin_function
DECL|function|putchars (scheme * sc,const char * chars,int char_cnt)
specifier|static
name|void
name|putchars
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|char_cnt
parameter_list|)
block|{
name|int
name|free_bytes
decl_stmt|;
comment|/* Space remaining in buffer (in bytes) */
name|int
name|l
decl_stmt|;
name|port
modifier|*
name|pt
init|=
name|sc
operator|->
name|outport
operator|->
name|_object
operator|.
name|_port
decl_stmt|;
if|if
condition|(
name|char_cnt
operator|<=
literal|0
condition|)
return|return;
comment|/* Get length of 'chars' in bytes */
name|char_cnt
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|chars
argument_list|,
operator|(
name|long
operator|)
name|char_cnt
argument_list|)
operator|-
name|chars
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|kind
operator|&
name|port_file
condition|)
block|{
if|#
directive|if
name|STANDALONE
name|fwrite
argument_list|(
name|chars
argument_list|,
literal|1
argument_list|,
name|char_cnt
argument_list|,
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If output is still directed to stdout (the default) it should be    */
comment|/* safe to redirect it to the registered output routine. */
if|if
condition|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
operator|==
name|stdout
condition|)
name|ts_output_string
argument_list|(
name|TS_OUTPUT_NORMAL
argument_list|,
name|chars
argument_list|,
name|char_cnt
argument_list|)
expr_stmt|;
else|else
block|{
name|fwrite
argument_list|(
name|chars
argument_list|,
literal|1
argument_list|,
name|char_cnt
argument_list|,
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|!=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
condition|)
block|{
name|free_bytes
operator|=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|-
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|char_cnt
argument_list|,
name|free_bytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
argument_list|,
name|chars
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|+=
name|l
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pt
operator|->
name|kind
operator|&
name|port_srfi6
operator|&&
name|realloc_port_string
argument_list|(
name|sc
argument_list|,
name|pt
argument_list|)
condition|)
block|{
name|free_bytes
operator|=
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|-
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|char_cnt
argument_list|,
name|free_bytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
argument_list|,
name|chars
argument_list|,
name|char_cnt
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|+=
name|l
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|putcharacter (scheme * sc,gunichar c)
name|INTERFACE
name|void
name|putcharacter
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|gunichar
name|c
parameter_list|)
block|{
name|char
name|utf8
index|[
literal|7
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|putchars
argument_list|(
name|sc
argument_list|,
name|utf8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|putstr (scheme * sc,const char * s)
name|INTERFACE
name|void
name|putstr
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|putchars
argument_list|(
name|sc
argument_list|,
name|s
argument_list|,
name|g_utf8_strlen
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read characters up to delimiter, but cater to character constants */
end_comment

begin_function
DECL|function|readstr_upto (scheme * sc,char * delim)
specifier|static
name|char
modifier|*
name|readstr_upto
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|sc
operator|->
name|strbuff
decl_stmt|;
name|gunichar
name|c
init|=
literal|0
decl_stmt|;
name|gunichar
name|c_prev
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
do|do
block|{
name|c_prev
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|len
operator|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|&&
operator|!
name|is_one_of
argument_list|(
name|delim
argument_list|,
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|p
operator|==
name|sc
operator|->
name|strbuff
operator|+
literal|2
operator|&&
name|c_prev
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* put back the delimiter */
name|p
index|[
operator|-
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|strbuff
return|;
block|}
end_function

begin_comment
comment|/* read string expression "xxx...xxx" */
end_comment

begin_function
DECL|function|readstrexp (scheme * sc)
specifier|static
name|pointer
name|readstrexp
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|sc
operator|->
name|strbuff
decl_stmt|;
name|gunichar
name|c
decl_stmt|;
name|int
name|c1
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
DECL|enum|__anon28dc31d10103
DECL|enumerator|st_ok
DECL|enumerator|st_bsl
DECL|enumerator|st_x1
DECL|enumerator|st_x2
DECL|enumerator|st_oct1
DECL|enumerator|st_oct2
enum|enum
block|{
name|st_ok
block|,
name|st_bsl
block|,
name|st_x1
block|,
name|st_x2
block|,
name|st_oct1
block|,
name|st_oct2
block|}
name|state
init|=
name|st_ok
enum|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|p
operator|-
name|sc
operator|->
name|strbuff
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return
name|sc
operator|->
name|F
return|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|st_ok
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|state
operator|=
name|st_bsl
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|mk_counted_string
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|,
name|p
operator|-
name|sc
operator|->
name|strbuff
argument_list|)
return|;
default|default:
name|len
operator|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|st_bsl
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|state
operator|=
name|st_oct1
expr_stmt|;
name|c1
operator|=
name|g_unichar_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|state
operator|=
name|st_x1
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|p
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
break|break;
default|default:
name|len
operator|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|st_x1
case|:
case|case
name|st_x2
case|:
if|if
condition|(
operator|!
name|g_unichar_isxdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|sc
operator|->
name|F
return|;
name|c1
operator|=
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|g_unichar_xdigit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|st_x1
condition|)
name|state
operator|=
name|st_x2
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|c1
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
block|}
break|break;
case|case
name|st_oct1
case|:
comment|/* State when handling second octal digit */
case|case
name|st_oct2
case|:
comment|/* State when handling third octal digit */
if|if
condition|(
operator|!
name|g_unichar_isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|g_unichar_digit_value
argument_list|(
name|c
argument_list|)
operator|>
literal|7
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c1
expr_stmt|;
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
block|}
else|else
block|{
comment|/* Is value of three character octal too big for a byte? */
if|if
condition|(
name|state
operator|==
name|st_oct2
operator|&&
name|c1
operator|>=
literal|32
condition|)
return|return
name|sc
operator|->
name|F
return|;
name|c1
operator|=
operator|(
name|c1
operator|<<
literal|3
operator|)
operator|+
name|g_unichar_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|st_oct1
condition|)
name|state
operator|=
name|st_oct2
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|c1
expr_stmt|;
name|state
operator|=
name|st_ok
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* check c is in chars */
end_comment

begin_function
DECL|function|is_one_of (char * s,gunichar c)
specifier|static
name|INLINE
name|int
name|is_one_of
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|gunichar
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|g_utf8_strchr
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* skip white characters */
end_comment

begin_function
DECL|function|skipspace (scheme * sc)
specifier|static
name|INLINE
name|void
name|skipspace
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|gunichar
name|c
decl_stmt|;
while|while
condition|(
name|g_unichar_isspace
argument_list|(
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get token */
end_comment

begin_function
DECL|function|token (scheme * sc)
specifier|static
name|int
name|token
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|gunichar
name|c
decl_stmt|;
name|skipspace
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
condition|)
block|{
case|case
name|EOF
case|:
return|return
operator|(
name|TOK_EOF
operator|)
return|;
case|case
literal|'('
case|:
return|return
operator|(
name|TOK_LPAREN
operator|)
return|;
case|case
literal|')'
case|:
return|return
operator|(
name|TOK_RPAREN
operator|)
return|;
case|case
literal|'.'
case|:
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_one_of
argument_list|(
literal|" \n\t"
argument_list|,
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|TOK_DOT
operator|)
return|;
block|}
else|else
block|{
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|backchar
argument_list|(
name|sc
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
return|return
name|TOK_ATOM
return|;
block|}
case|case
literal|'\''
case|:
return|return
operator|(
name|TOK_QUOTE
operator|)
return|;
case|case
literal|';'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
return|return
operator|(
name|token
argument_list|(
name|sc
argument_list|)
operator|)
return|;
case|case
literal|'"'
case|:
return|return
operator|(
name|TOK_DQUOTE
operator|)
return|;
case|case
literal|'_'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|'"'
condition|)
return|return
operator|(
name|TOK_DQUOTE
operator|)
return|;
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ATOM
operator|)
return|;
case|case
name|BACKQUOTE
case|:
return|return
operator|(
name|TOK_BQUOTE
operator|)
return|;
case|case
literal|','
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|'@'
condition|)
return|return
operator|(
name|TOK_ATMARK
operator|)
return|;
else|else
block|{
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_COMMA
operator|)
return|;
block|}
case|case
literal|'#'
case|:
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
return|return
operator|(
name|TOK_VEC
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
return|return
operator|(
name|token
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_one_of
argument_list|(
literal|" tfodxb\\"
argument_list|,
name|c
argument_list|)
condition|)
block|{
return|return
name|TOK_SHARP_CONST
return|;
block|}
else|else
block|{
return|return
operator|(
name|TOK_SHARP
operator|)
return|;
block|}
block|}
default|default:
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ATOM
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ========== Routines for Printing ========== */
end_comment

begin_define
DECL|macro|ok_abbrev (x)
define|#
directive|define
name|ok_abbrev
parameter_list|(
name|x
parameter_list|)
value|(is_pair(x)&& cdr(x) == sc->NIL)
end_define

begin_function
DECL|function|printslashstring (scheme * sc,char * p,int len)
specifier|static
name|void
name|printslashstring
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gunichar
name|c
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|g_utf8_get_char
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Is a check for a value of 0xff still valid in UTF8?? ~~~~~ */
if|if
condition|(
name|c
operator|==
literal|0xff
operator|||
name|c
operator|==
literal|'"'
operator|||
name|c
operator|<
literal|' '
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
comment|/* This still needs work ~~~~~ */
name|int
name|d
init|=
name|c
operator|/
literal|16
decl_stmt|;
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|10
condition|)
block|{
name|putcharacter
argument_list|(
name|sc
argument_list|,
name|d
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putcharacter
argument_list|(
name|sc
argument_list|,
name|d
operator|-
literal|10
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|c
operator|%
literal|16
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|10
condition|)
block|{
name|putcharacter
argument_list|(
name|sc
argument_list|,
name|d
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putcharacter
argument_list|(
name|sc
argument_list|,
name|d
operator|-
literal|10
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|putcharacter
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|g_utf8_next_char
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|putcharacter
argument_list|(
name|sc
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print atoms */
end_comment

begin_function
DECL|function|printatom (scheme * sc,pointer l,int f)
specifier|static
name|void
name|printatom
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|l
parameter_list|,
name|int
name|f
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|atom2str
argument_list|(
name|sc
argument_list|,
name|l
argument_list|,
name|f
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|putchars
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Uses internal buffer unless string pointer is already available */
end_comment

begin_function
DECL|function|atom2str (scheme * sc,pointer l,int f,char ** pp,int * plen)
specifier|static
name|void
name|atom2str
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|l
parameter_list|,
name|int
name|f
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
modifier|*
name|plen
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|p
operator|=
literal|"()"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
name|sc
operator|->
name|T
condition|)
block|{
name|p
operator|=
literal|"#t"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
name|sc
operator|->
name|F
condition|)
block|{
name|p
operator|=
literal|"#f"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
name|sc
operator|->
name|EOF_OBJ
condition|)
block|{
name|p
operator|=
literal|"#<EOF>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_port
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|strbuff
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#<PORT>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_number
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|strbuff
expr_stmt|;
if|if
condition|(
name|num_is_integer
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%ld"
argument_list|,
name|ivalue_unchecked
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%.10g"
argument_list|,
name|rvalue_unchecked
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_string
argument_list|(
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|p
operator|=
name|strvalue
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Hack, uses the fact that printing is needed */
operator|*
name|pp
operator|=
name|sc
operator|->
name|strbuff
expr_stmt|;
operator|*
name|plen
operator|=
literal|0
expr_stmt|;
name|printslashstring
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|l
argument_list|)
argument_list|,
name|g_utf8_strlen
argument_list|(
name|strvalue
argument_list|(
name|l
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|is_character
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|gunichar
name|c
init|=
name|charvalue
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|p
operator|=
name|sc
operator|->
name|strbuff
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|int
name|len
init|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|p
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\space"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\newline"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\return"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\tab"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|USE_ASCII_NAMES
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\del"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\%s"
argument_list|,
name|charnames
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#\\x%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|is_symbol
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
name|symname
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_proc
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|strbuff
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#<%s PROCEDURE %ld>"
argument_list|,
name|procname
argument_list|(
name|l
argument_list|)
argument_list|,
name|procnum
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_macro
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
literal|"#<MACRO>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_closure
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
literal|"#<CLOSURE>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_promise
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
literal|"#<PROMISE>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_foreign
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|strbuff
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"#<FOREIGN PROCEDURE %ld>"
argument_list|,
name|procnum
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_continuation
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|p
operator|=
literal|"#<CONTINUATION>"
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
literal|"#<ERROR>"
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
operator|*
name|plen
operator|=
name|g_utf8_strlen
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========== Routines for Evaluation Cycle ========== */
end_comment

begin_comment
comment|/* make closure. c is code. e is environment */
end_comment

begin_function
DECL|function|mk_closure (scheme * sc,pointer c,pointer e)
specifier|static
name|pointer
name|mk_closure
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|c
parameter_list|,
name|pointer
name|e
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|c
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_CLOSURE
expr_stmt|;
name|car
argument_list|(
name|x
argument_list|)
operator|=
name|c
expr_stmt|;
name|cdr
argument_list|(
name|x
argument_list|)
operator|=
name|e
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* make continuation. */
end_comment

begin_function
DECL|function|mk_continuation (scheme * sc,pointer d)
specifier|static
name|pointer
name|mk_continuation
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|d
parameter_list|)
block|{
name|pointer
name|x
init|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_CONTINUATION
expr_stmt|;
name|cont_dump
argument_list|(
name|x
argument_list|)
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|list_star (scheme * sc,pointer d)
specifier|static
name|pointer
name|list_star
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|d
parameter_list|)
block|{
name|pointer
name|p
decl_stmt|,
name|q
decl_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|d
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
name|car
argument_list|(
name|d
argument_list|)
return|;
block|}
name|p
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|d
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|d
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|p
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|p
operator|=
name|cdr
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/* reverse list -- produce new list */
end_comment

begin_function
DECL|function|reverse (scheme * sc,pointer a)
specifier|static
name|pointer
name|reverse
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
comment|/* a must be checked by gc */
name|pointer
name|p
init|=
name|sc
operator|->
name|NIL
decl_stmt|;
for|for
control|(
init|;
name|is_pair
argument_list|(
name|a
argument_list|)
condition|;
name|a
operator|=
name|cdr
argument_list|(
name|a
argument_list|)
control|)
block|{
name|p
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|a
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* reverse list --- in-place */
end_comment

begin_function
DECL|function|reverse_in_place (scheme * sc,pointer term,pointer list)
specifier|static
name|pointer
name|reverse_in_place
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|term
parameter_list|,
name|pointer
name|list
parameter_list|)
block|{
name|pointer
name|p
init|=
name|list
decl_stmt|,
name|result
init|=
name|term
decl_stmt|,
name|q
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|q
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cdr
argument_list|(
name|p
argument_list|)
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* append list -- produce new list */
end_comment

begin_function
DECL|function|append (scheme * sc,pointer a,pointer b)
specifier|static
name|pointer
name|append
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
name|pointer
name|p
init|=
name|b
decl_stmt|,
name|q
decl_stmt|;
if|if
condition|(
name|a
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|a
operator|=
name|reverse
argument_list|(
name|sc
argument_list|,
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|a
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|q
operator|=
name|cdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|cdr
argument_list|(
name|a
argument_list|)
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|q
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* equivalence of atoms */
end_comment

begin_function
DECL|function|eqv (pointer a,pointer b)
name|int
name|eqv
parameter_list|(
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
if|if
condition|(
name|is_string
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_string
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|(
name|strvalue
argument_list|(
name|a
argument_list|)
operator|==
name|strvalue
argument_list|(
name|b
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_number
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_number
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|num_is_integer
argument_list|(
name|a
argument_list|)
operator|==
name|num_is_integer
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|num_eq
argument_list|(
name|nvalue
argument_list|(
name|a
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_character
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_character
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|charvalue
argument_list|(
name|a
argument_list|)
operator|==
name|charvalue
argument_list|(
name|b
argument_list|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_port
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_port
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|a
operator|==
name|b
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_proc
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_proc
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|procnum
argument_list|(
name|a
argument_list|)
operator|==
name|procnum
argument_list|(
name|b
argument_list|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* true or false value macro */
end_comment

begin_comment
comment|/* () is #t in R5RS */
end_comment

begin_define
DECL|macro|is_true (p)
define|#
directive|define
name|is_true
parameter_list|(
name|p
parameter_list|)
value|((p) != sc->F)
end_define

begin_define
DECL|macro|is_false (p)
define|#
directive|define
name|is_false
parameter_list|(
name|p
parameter_list|)
value|((p) == sc->F)
end_define

begin_comment
comment|/* ========== Environment implementation  ========== */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_ALIST_ENV
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|USE_OBJECT_LIST
argument_list|)
end_if

begin_function
DECL|function|hash_fn (const char * key,int table_size)
specifier|static
name|int
name|hash_fn
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int
name|table_size
parameter_list|)
block|{
name|unsigned
name|int
name|hashed
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|bits_per_int
init|=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|*
literal|8
decl_stmt|;
for|for
control|(
name|c
operator|=
name|key
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
comment|/* letters have about 5 bits in them */
name|hashed
operator|=
operator|(
name|hashed
operator|<<
literal|5
operator|)
operator||
operator|(
name|hashed
operator|>>
operator|(
name|bits_per_int
operator|-
literal|5
operator|)
operator|)
expr_stmt|;
name|hashed
operator|^=
operator|*
name|c
expr_stmt|;
block|}
return|return
name|hashed
operator|%
name|table_size
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_ALIST_ENV
end_ifndef

begin_comment
comment|/*  * In this implementation, each frame of the environment may be  * a hash table: a vector of alists hashed by variable name.  * In practice, we use a vector only for the initial frame;  * subsequent frames are too small and transient for the lookup  * speed to out-weigh the cost of making a new vector.  */
end_comment

begin_function
DECL|function|new_frame_in_env (scheme * sc,pointer old_env)
specifier|static
name|void
name|new_frame_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|old_env
parameter_list|)
block|{
name|pointer
name|new_frame
decl_stmt|;
comment|/* The interaction-environment has about 300 variables in it. */
if|if
condition|(
name|old_env
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|new_frame
operator|=
name|mk_vector
argument_list|(
name|sc
argument_list|,
literal|461
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_frame
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
name|sc
operator|->
name|envir
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|new_frame
argument_list|,
name|old_env
argument_list|)
expr_stmt|;
name|setenvironment
argument_list|(
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|new_slot_spec_in_env (scheme * sc,pointer env,pointer variable,pointer value)
specifier|static
name|INLINE
name|void
name|new_slot_spec_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|env
parameter_list|,
name|pointer
name|variable
parameter_list|,
name|pointer
name|value
parameter_list|)
block|{
name|pointer
name|slot
init|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|variable
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_vector
argument_list|(
name|car
argument_list|(
name|env
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|location
init|=
name|hash_fn
argument_list|(
name|symname
argument_list|(
name|variable
argument_list|)
argument_list|,
name|ivalue_unchecked
argument_list|(
name|car
argument_list|(
name|env
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|set_vector_elem
argument_list|(
name|car
argument_list|(
name|env
argument_list|)
argument_list|,
name|location
argument_list|,
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|slot
argument_list|,
name|vector_elem
argument_list|(
name|car
argument_list|(
name|env
argument_list|)
argument_list|,
name|location
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|car
argument_list|(
name|env
argument_list|)
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|slot
argument_list|,
name|car
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|find_slot_in_env (scheme * sc,pointer env,pointer hdl,int all)
specifier|static
name|pointer
name|find_slot_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|env
parameter_list|,
name|pointer
name|hdl
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|location
decl_stmt|;
for|for
control|(
name|x
operator|=
name|env
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|is_vector
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|location
operator|=
name|hash_fn
argument_list|(
name|symname
argument_list|(
name|hdl
argument_list|)
argument_list|,
name|ivalue_unchecked
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|vector_elem
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|car
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
if|if
condition|(
name|caar
argument_list|(
name|y
argument_list|)
operator|==
name|hdl
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|all
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
block|}
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
name|car
argument_list|(
name|y
argument_list|)
return|;
block|}
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_ALIST_ENV */
end_comment

begin_function
DECL|function|new_frame_in_env (scheme * sc,pointer old_env)
specifier|static
name|INLINE
name|void
name|new_frame_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|old_env
parameter_list|)
block|{
name|sc
operator|->
name|envir
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|old_env
argument_list|)
expr_stmt|;
name|setenvironment
argument_list|(
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|new_slot_spec_in_env (scheme * sc,pointer env,pointer variable,pointer value)
specifier|static
name|INLINE
name|void
name|new_slot_spec_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|env
parameter_list|,
name|pointer
name|variable
parameter_list|,
name|pointer
name|value
parameter_list|)
block|{
name|car
argument_list|(
name|env
argument_list|)
operator|=
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|variable
argument_list|,
name|value
argument_list|)
argument_list|,
name|car
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|find_slot_in_env (scheme * sc,pointer env,pointer hdl,int all)
specifier|static
name|pointer
name|find_slot_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|env
parameter_list|,
name|pointer
name|hdl
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|x
operator|=
name|env
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
for|for
control|(
name|y
operator|=
name|car
argument_list|(
name|x
argument_list|)
init|;
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
if|if
condition|(
name|caar
argument_list|(
name|y
argument_list|)
operator|==
name|hdl
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|all
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
block|}
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
return|return
name|car
argument_list|(
name|y
argument_list|)
return|;
block|}
return|return
name|sc
operator|->
name|NIL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ALIST_ENV else */
end_comment

begin_function
DECL|function|new_slot_in_env (scheme * sc,pointer variable,pointer value)
specifier|static
name|INLINE
name|void
name|new_slot_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|variable
parameter_list|,
name|pointer
name|value
parameter_list|)
block|{
name|new_slot_spec_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|variable
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|set_slot_in_env (scheme * sc,pointer slot,pointer value)
specifier|static
name|INLINE
name|void
name|set_slot_in_env
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|slot
parameter_list|,
name|pointer
name|value
parameter_list|)
block|{
name|cdr
argument_list|(
name|slot
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
DECL|function|slot_value_in_env (pointer slot)
specifier|static
name|INLINE
name|pointer
name|slot_value_in_env
parameter_list|(
name|pointer
name|slot
parameter_list|)
block|{
return|return
name|cdr
argument_list|(
name|slot
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ========== Evaluation Cycle ========== */
end_comment

begin_function
DECL|function|_Error_1 (scheme * sc,const char * s,pointer a)
specifier|static
name|pointer
name|_Error_1
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
if|#
directive|if
name|USE_ERROR_HOOK
name|pointer
name|x
decl_stmt|;
name|pointer
name|hdl
init|=
name|sc
operator|->
name|ERROR_HOOK
decl_stmt|;
name|x
operator|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|hdl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|QUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
operator|(
name|a
operator|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_string
argument_list|(
name|sc
argument_list|,
operator|(
name|s
operator|)
argument_list|)
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|setimmutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|slot_value_in_env
argument_list|(
name|x
argument_list|)
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|op
operator|=
operator|(
name|int
operator|)
name|OP_EVAL
expr_stmt|;
return|return
name|sc
operator|->
name|T
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
operator|(
name|a
operator|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_string
argument_list|(
name|sc
argument_list|,
operator|(
name|s
operator|)
argument_list|)
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|setimmutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|op
operator|=
operator|(
name|int
operator|)
name|OP_ERR0
expr_stmt|;
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_define
DECL|macro|Error_1 (sc,s,a)
define|#
directive|define
name|Error_1
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|,
name|a
parameter_list|)
value|return _Error_1(sc,s,a)
end_define

begin_define
DECL|macro|Error_0 (sc,s)
define|#
directive|define
name|Error_0
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|)
value|return _Error_1(sc,s,0)
end_define

begin_comment
comment|/* Too small to turn into function */
end_comment

begin_define
DECL|macro|BEGIN
define|#
directive|define
name|BEGIN
value|do {
end_define

begin_define
DECL|macro|END
define|#
directive|define
name|END
value|} while (0)
end_define

begin_define
DECL|macro|s_goto (sc,a)
define|#
directive|define
name|s_goto
parameter_list|(
name|sc
parameter_list|,
name|a
parameter_list|)
value|BEGIN                                  \     sc->op = (int)(a);                                      \     return sc->T; END
end_define

begin_define
DECL|macro|s_return (sc,a)
define|#
directive|define
name|s_return
parameter_list|(
name|sc
parameter_list|,
name|a
parameter_list|)
value|return _s_return(sc,a)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|USE_SCHEME_STACK
end_ifndef

begin_comment
comment|/* this structure holds all the interpreter's registers */
end_comment

begin_struct
DECL|struct|dump_stack_frame
struct|struct
name|dump_stack_frame
block|{
DECL|member|op
name|enum
name|scheme_opcodes
name|op
decl_stmt|;
DECL|member|args
name|pointer
name|args
decl_stmt|;
DECL|member|envir
name|pointer
name|envir
decl_stmt|;
DECL|member|code
name|pointer
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_define
DECL|macro|STACK_GROWTH
define|#
directive|define
name|STACK_GROWTH
value|3
end_define

begin_function
DECL|function|s_save (scheme * sc,enum scheme_opcodes op,pointer args,pointer code)
specifier|static
name|void
name|s_save
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|,
name|pointer
name|args
parameter_list|,
name|pointer
name|code
parameter_list|)
block|{
name|int
name|nframes
init|=
operator|(
name|int
operator|)
name|sc
operator|->
name|dump
decl_stmt|;
name|struct
name|dump_stack_frame
modifier|*
name|next_frame
decl_stmt|;
comment|/* enough room for the next frame? */
if|if
condition|(
name|nframes
operator|>=
name|sc
operator|->
name|dump_size
condition|)
block|{
name|sc
operator|->
name|dump_size
operator|+=
name|STACK_GROWTH
expr_stmt|;
comment|/* alas there is no sc->realloc */
name|sc
operator|->
name|dump_base
operator|=
name|realloc
argument_list|(
name|sc
operator|->
name|dump_base
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dump_stack_frame
argument_list|)
operator|*
name|sc
operator|->
name|dump_size
argument_list|)
expr_stmt|;
block|}
name|next_frame
operator|=
operator|(
expr|struct
name|dump_stack_frame
operator|*
operator|)
name|sc
operator|->
name|dump_base
operator|+
name|nframes
expr_stmt|;
name|next_frame
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|next_frame
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|next_frame
operator|->
name|envir
operator|=
name|sc
operator|->
name|envir
expr_stmt|;
name|next_frame
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|sc
operator|->
name|dump
operator|=
call|(
name|pointer
call|)
argument_list|(
name|nframes
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|_s_return (scheme * sc,pointer a)
specifier|static
name|pointer
name|_s_return
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
name|int
name|nframes
init|=
operator|(
name|int
operator|)
name|sc
operator|->
name|dump
decl_stmt|;
name|struct
name|dump_stack_frame
modifier|*
name|frame
decl_stmt|;
name|sc
operator|->
name|value
operator|=
operator|(
name|a
operator|)
expr_stmt|;
if|if
condition|(
name|nframes
operator|<=
literal|0
condition|)
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
name|nframes
operator|--
expr_stmt|;
name|frame
operator|=
operator|(
expr|struct
name|dump_stack_frame
operator|*
operator|)
name|sc
operator|->
name|dump_base
operator|+
name|nframes
expr_stmt|;
name|sc
operator|->
name|op
operator|=
name|frame
operator|->
name|op
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|frame
operator|->
name|args
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|frame
operator|->
name|envir
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|frame
operator|->
name|code
expr_stmt|;
name|sc
operator|->
name|dump
operator|=
operator|(
name|pointer
operator|)
name|nframes
expr_stmt|;
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|dump_stack_reset (scheme * sc)
specifier|static
name|INLINE
name|void
name|dump_stack_reset
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
comment|/* in this implementation, sc->dump is the number of frames on the stack */
name|sc
operator|->
name|dump
operator|=
operator|(
name|pointer
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dump_stack_initialize (scheme * sc)
specifier|static
name|INLINE
name|void
name|dump_stack_initialize
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|dump_size
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dump_base
operator|=
name|NULL
expr_stmt|;
name|dump_stack_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dump_stack_free (scheme * sc)
specifier|static
name|void
name|dump_stack_free
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|dump_base
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dump_base
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|dump
operator|=
operator|(
name|pointer
operator|)
literal|0
expr_stmt|;
name|sc
operator|->
name|dump_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dump_stack_mark (scheme * sc)
specifier|static
name|INLINE
name|void
name|dump_stack_mark
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|nframes
init|=
operator|(
name|int
operator|)
name|sc
operator|->
name|dump
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dump_stack_frame
modifier|*
name|frame
decl_stmt|;
name|frame
operator|=
operator|(
expr|struct
name|dump_stack_frame
operator|*
operator|)
name|sc
operator|->
name|dump_base
operator|+
name|i
expr_stmt|;
name|mark
argument_list|(
name|frame
operator|->
name|args
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|frame
operator|->
name|envir
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|frame
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
DECL|function|dump_stack_reset (scheme * sc)
specifier|static
name|INLINE
name|void
name|dump_stack_reset
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|dump
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dump_stack_initialize (scheme * sc)
specifier|static
name|INLINE
name|void
name|dump_stack_initialize
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|dump_stack_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dump_stack_free (scheme * sc)
specifier|static
name|void
name|dump_stack_free
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|dump
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
end_function

begin_function
DECL|function|_s_return (scheme * sc,pointer a)
specifier|static
name|pointer
name|_s_return
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
name|sc
operator|->
name|value
operator|=
operator|(
name|a
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dump
operator|==
name|sc
operator|->
name|NIL
condition|)
return|return
name|sc
operator|->
name|NIL
return|;
name|sc
operator|->
name|op
operator|=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|dump
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|caddr
argument_list|(
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadddr
argument_list|(
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dump
operator|=
name|cddddr
argument_list|(
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|s_save (scheme * sc,enum scheme_opcodes op,pointer args,pointer code)
specifier|static
name|void
name|s_save
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|,
name|pointer
name|args
parameter_list|,
name|pointer
name|code
parameter_list|)
block|{
name|sc
operator|->
name|dump
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
operator|(
name|code
operator|)
argument_list|,
name|sc
operator|->
name|dump
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dump
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
operator|(
name|args
operator|)
argument_list|,
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dump
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
call|(
name|long
call|)
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dump_stack_mark (scheme * sc)
specifier|static
name|INLINE
name|void
name|dump_stack_mark
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|mark
argument_list|(
name|sc
operator|->
name|dump
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|s_retbool (tf)
define|#
directive|define
name|s_retbool
parameter_list|(
name|tf
parameter_list|)
value|s_return(sc,(tf) ? sc->T : sc->F)
end_define

begin_function
DECL|function|opexe_0 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_0
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_LOAD
case|:
comment|/* load */
if|if
condition|(
name|file_interactive
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|sc
operator|->
name|outport
operator|->
name|_object
operator|.
name|_port
operator|->
name|rep
operator|.
name|stdio
operator|.
name|file
argument_list|,
literal|"Loading %s\n"
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file_push
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"unable to open"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_retbool
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_T0LVL
case|:
comment|/* top level */
if|if
condition|(
name|file_interactive
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|nesting
operator|=
literal|0
expr_stmt|;
name|dump_stack_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|sc
operator|->
name|global_env
expr_stmt|;
name|sc
operator|->
name|save_inport
operator|=
name|sc
operator|->
name|inport
expr_stmt|;
name|sc
operator|->
name|inport
operator|=
name|sc
operator|->
name|loadport
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_T0LVL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_VALUEPRINT
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_T1LVL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_interactive
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
block|}
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_READ_INTERNAL
argument_list|)
expr_stmt|;
case|case
name|OP_T1LVL
case|:
comment|/* top level */
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|value
expr_stmt|;
name|sc
operator|->
name|inport
operator|=
name|sc
operator|->
name|save_inport
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_READ_INTERNAL
case|:
comment|/* internal read */
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tok
operator|==
name|TOK_EOF
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|inport
operator|==
name|sc
operator|->
name|loadport
condition|)
block|{
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_QUIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|EOF_OBJ
argument_list|)
expr_stmt|;
block|}
block|}
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
case|case
name|OP_GENSYM
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|gensym
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_VALUEPRINT
case|:
comment|/* print evaluation result */
comment|/* OP_VALUEPRINT is always pushed, because when changing from              non-interactive to interactive mode, it needs to be              already on the stack */
if|if
condition|(
name|sc
operator|->
name|tracing
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"\nGives: "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_interactive
argument_list|(
name|sc
argument_list|)
operator|||
name|sc
operator|->
name|print_output
condition|)
block|{
name|sc
operator|->
name|print_flag
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|value
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_EVAL
case|:
comment|/* main part of evaluation */
if|#
directive|if
name|USE_TRACING
if|if
condition|(
name|sc
operator|->
name|tracing
condition|)
block|{
comment|/*s_save(sc,OP_VALUEPRINT,sc->NIL,sc->NIL);*/
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_REAL_EVAL
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|code
expr_stmt|;
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"\nEval: "
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
comment|/* fall through */
case|case
name|OP_REAL_EVAL
case|:
endif|#
directive|endif
if|if
condition|(
name|is_symbol
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* symbol */
name|x
operator|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|sc
operator|->
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|slot_value_in_env
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"eval: unbound variable:"
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_syntax
argument_list|(
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
comment|/* SYNTAX */
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|syntaxnum
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* first, eval top element and eval arguments */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_E0ARGS
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
comment|/* If no macros => s_save(sc,OP_E1ARGS, sc->NIL, cdr(sc->code));*/
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_E0ARGS
case|:
comment|/* eval arguments */
if|if
condition|(
name|is_macro
argument_list|(
name|sc
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* macro expansion */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_DOMACRO
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|value
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_APPLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_E1ARGS
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_E1ARGS
case|:
comment|/* eval arguments */
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* continue */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_E1ARGS
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* end */
name|sc
operator|->
name|args
operator|=
name|reverse_in_place
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_APPLY
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|USE_TRACING
case|case
name|OP_TRACING
case|:
block|{
name|int
name|tr
init|=
name|sc
operator|->
name|tracing
decl_stmt|;
name|sc
operator|->
name|tracing
operator|=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|tr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
case|case
name|OP_APPLY
case|:
comment|/* apply 'code' to 'args' */
if|#
directive|if
name|USE_TRACING
if|if
condition|(
name|sc
operator|->
name|tracing
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_REAL_APPLY
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|print_flag
operator|=
literal|1
expr_stmt|;
comment|/*         sc->args=cons(sc,sc->code,sc->args);*/
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"\nApply to: "
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
comment|/* fall through */
case|case
name|OP_REAL_APPLY
case|:
endif|#
directive|endif
if|if
condition|(
name|is_proc
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
name|s_goto
argument_list|(
name|sc
argument_list|,
name|procnum
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PROCEDURE */
block|}
elseif|else
if|if
condition|(
name|is_foreign
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
name|sc
operator|->
name|foreign_error
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|x
operator|=
name|sc
operator|->
name|code
operator|->
name|_object
operator|.
name|_ff
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|foreign_error
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|sc
operator|->
name|foreign_error
expr_stmt|;
name|sc
operator|->
name|foreign_error
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|Error_1
argument_list|(
name|sc
argument_list|,
name|string_value
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_closure
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|||
name|is_macro
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|||
name|is_promise
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* CLOSURE */
comment|/* Should not accept promise */
comment|/* make environment */
name|new_frame_in_env
argument_list|(
name|sc
argument_list|,
name|closure_env
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|car
argument_list|(
name|closure_code
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
operator|,
name|y
operator|=
name|sc
operator|->
name|args
init|;
name|is_pair
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
operator|,
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
if|if
condition|(
name|y
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"not enough arguments"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|car
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
comment|/*--                      * if (y != sc->NIL) {                      *   Error_0(sc,"too many arguments");                      * }                      */
block|}
elseif|else
if|if
condition|(
name|is_symbol
argument_list|(
name|x
argument_list|)
condition|)
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"syntax error in closure: not a symbol:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|closure_code
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_continuation
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* CONTINUATION */
name|sc
operator|->
name|dump
operator|=
name|cont_dump
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
operator|!=
name|sc
operator|->
name|NIL
condition|?
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
else|:
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"illegal function"
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_DOMACRO
case|:
comment|/* do macro */
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|value
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_LAMBDA
case|:
comment|/* lambda */
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_closure
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_MKCLOSURE
case|:
comment|/* make-closure */
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|car
argument_list|(
name|x
argument_list|)
operator|==
name|sc
operator|->
name|LAMBDA
condition|)
block|{
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|y
operator|=
name|sc
operator|->
name|envir
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_closure
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_QUOTE
case|:
comment|/* quote */
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_DEF0
case|:
comment|/* define */
if|if
condition|(
name|is_immutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"define: unable to alter immutable"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|caar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|LAMBDA
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|cdar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_symbol
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"variable is not a symbol"
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_DEF1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_DEF1
case|:
comment|/* define */
name|x
operator|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|sc
operator|->
name|code
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|set_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
case|case
name|OP_DEFP
case|:
comment|/* defined? */
name|x
operator|=
name|sc
operator|->
name|envir
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|x
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|s_retbool
argument_list|(
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
case|case
name|OP_SET0
case|:
comment|/* set! */
if|if
condition|(
name|is_immutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"set!: unable to alter immutable variable"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_SET1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_SET1
case|:
comment|/* set! */
name|y
operator|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|sc
operator|->
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|set_slot_in_env
argument_list|(
name|sc
argument_list|,
name|y
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"set!: unbound variable:"
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_BEGIN
case|:
comment|/* begin */
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_IF0
case|:
comment|/* if */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_IF1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_IF1
case|:
comment|/* if */
if|if
condition|(
name|is_true
argument_list|(
name|sc
operator|->
name|value
argument_list|)
condition|)
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|code
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
comment|/* (if #f 1) ==> () because                                * car(sc->NIL) = sc->NIL */
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_LET0
case|:
comment|/* let */
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|value
operator|=
name|sc
operator|->
name|code
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|is_symbol
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|?
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
else|:
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_LET1
argument_list|)
expr_stmt|;
case|case
name|OP_LET1
case|:
comment|/* let (calculate parameters) */
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* continue */
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
operator|||
operator|!
name|is_pair
argument_list|(
name|cdar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"Bad syntax of binding spec in let :"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_LET1
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* end */
name|sc
operator|->
name|args
operator|=
name|reverse_in_place
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_LET2
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_LET2
case|:
comment|/* let */
name|new_frame_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|is_symbol
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|?
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
else|:
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|,
name|y
operator|=
name|sc
operator|->
name|args
init|;
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
operator|,
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|caar
argument_list|(
name|x
argument_list|)
argument_list|,
name|car
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_symbol
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
comment|/* named let */
for|for
control|(
name|x
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|,
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|x
argument_list|)
condition|)
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"Bad syntax of binding in let :"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_list
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"Bad syntax of binding in let :"
argument_list|,
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|caar
argument_list|(
name|x
argument_list|)
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|mk_closure
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|reverse_in_place
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|cddr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cddr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
block|}
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
case|case
name|OP_LET0AST
case|:
comment|/* let* */
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|new_frame_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
operator|||
operator|!
name|is_pair
argument_list|(
name|caar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
operator|||
operator|!
name|is_pair
argument_list|(
name|cdaar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"Bad syntax of binding spec in let* :"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_LET1AST
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadaar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_LET1AST
case|:
comment|/* let* (make new frame) */
name|new_frame_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_LET2AST
argument_list|)
expr_stmt|;
case|case
name|OP_LET2AST
case|:
comment|/* let* (calculate parameters) */
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|caar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* continue */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_LET2AST
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* end */
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|args
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
block|}
default|default:
name|snprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|opexe_1 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_1
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_LET0REC
case|:
comment|/* letrec */
name|new_frame_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|value
operator|=
name|sc
operator|->
name|code
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_LET1REC
argument_list|)
expr_stmt|;
case|case
name|OP_LET1REC
case|:
comment|/* letrec (calculate parameters) */
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* continue */
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
operator|||
operator|!
name|is_pair
argument_list|(
name|cdar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"Bad syntax of binding spec in letrec :"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_LET1REC
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* end */
name|sc
operator|->
name|args
operator|=
name|reverse_in_place
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_LET2REC
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_LET2REC
case|:
comment|/* letrec */
for|for
control|(
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|,
name|y
operator|=
name|sc
operator|->
name|args
init|;
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
operator|,
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|caar
argument_list|(
name|x
argument_list|)
argument_list|,
name|car
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
case|case
name|OP_COND0
case|:
comment|/* cond */
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"syntax error in cond"
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_COND1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|caar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_COND1
case|:
comment|/* cond */
if|if
condition|(
name|is_true
argument_list|(
name|sc
operator|->
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|code
operator|=
name|cdar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|==
name|sc
operator|->
name|FEED_TO
condition|)
block|{
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"syntax error in cond"
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|QUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|code
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
operator|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_COND1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|caar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|OP_DELAY
case|:
comment|/* delay */
name|x
operator|=
name|mk_closure
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_PROMISE
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|OP_AND0
case|:
comment|/* and */
if|if
condition|(
name|sc
operator|->
name|code
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_AND1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_AND1
case|:
comment|/* and */
if|if
condition|(
name|is_false
argument_list|(
name|sc
operator|->
name|value
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|code
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_AND1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_OR0
case|:
comment|/* or */
if|if
condition|(
name|sc
operator|->
name|code
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_OR1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_OR1
case|:
comment|/* or */
if|if
condition|(
name|is_true
argument_list|(
name|sc
operator|->
name|value
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|code
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_OR1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_C0STREAM
case|:
comment|/* cons-stream */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_C1STREAM
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_C1STREAM
case|:
comment|/* cons-stream */
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|value
expr_stmt|;
comment|/* save sc->value to register sc->args for gc */
name|x
operator|=
name|mk_closure
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator|=
name|T_PROMISE
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_MACRO0
case|:
comment|/* macro */
if|if
condition|(
name|is_pair
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|caar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|LAMBDA
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|cdar
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_symbol
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"variable is not a symbol"
argument_list|)
expr_stmt|;
block|}
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_MACRO1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_MACRO1
case|:
comment|/* macro */
name|typeflag
argument_list|(
name|sc
operator|->
name|value
argument_list|)
operator|=
name|T_MACRO
expr_stmt|;
name|x
operator|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|sc
operator|->
name|code
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|set_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
case|case
name|OP_CASE0
case|:
comment|/* case */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_CASE1
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_CASE1
case|:
comment|/* case */
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|code
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|y
operator|=
name|caar
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
for|for
control|(
init|;
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
if|if
condition|(
name|eqv
argument_list|(
name|car
argument_list|(
name|y
argument_list|)
argument_list|,
name|sc
operator|->
name|value
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
if|if
condition|(
name|is_pair
argument_list|(
name|caar
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|code
operator|=
name|cdar
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* else */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_CASE2
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|cdar
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|caar
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_CASE2
case|:
comment|/* case */
if|if
condition|(
name|is_true
argument_list|(
name|sc
operator|->
name|value
argument_list|)
condition|)
block|{
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_BEGIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_PAPPLY
case|:
comment|/* apply */
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|list_star
argument_list|(
name|sc
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
comment|/*sc->args = cadr(sc->args);*/
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_APPLY
argument_list|)
expr_stmt|;
case|case
name|OP_PEVAL
case|:
comment|/* eval */
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|sc
operator|->
name|envir
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
case|case
name|OP_CONTINUATION
case|:
comment|/* call-with-current-continuation */
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_continuation
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dump
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_APPLY
argument_list|)
expr_stmt|;
default|default:
name|snprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|opexe_2 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_2
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|num
name|v
decl_stmt|;
if|#
directive|if
name|USE_MATH
name|double
name|dd
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
if|#
directive|if
name|USE_MATH
case|case
name|OP_INEX2EX
case|:
comment|/* inexact->exact */
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_is_integer
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modf
argument_list|(
name|rvalue_unchecked
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|ivalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"inexact->exact: not integral:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_EXP
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|exp
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_LOG
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|log
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_SIN
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|sin
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_COS
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|cos
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_TAN
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|tan
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_ASIN
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|asin
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_ACOS
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|acos
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_ATAN
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|atan
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pointer
name|y
init|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
decl_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|atan2
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|,
name|rvalue
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_SQRT
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|sqrt
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_EXPT
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"expt: needs two arguments"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pointer
name|y
init|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
decl_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|pow
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|,
name|rvalue
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_FLOOR
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|floor
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CEILING
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|ceil
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_TRUNCATE
case|:
block|{
name|double
name|rvalue_of_x
decl_stmt|;
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|rvalue_of_x
operator|=
name|rvalue
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvalue_of_x
operator|>
literal|0
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|floor
argument_list|(
name|rvalue_of_x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|ceil
argument_list|(
name|rvalue_of_x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|OP_ROUND
case|:
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_real
argument_list|(
name|sc
argument_list|,
name|round_per_R5RS
argument_list|(
name|rvalue
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|OP_ADD
case|:
comment|/* + */
name|v
operator|=
name|num_zero
expr_stmt|;
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|args
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|v
operator|=
name|num_add
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_MUL
case|:
comment|/* * */
name|v
operator|=
name|num_one
expr_stmt|;
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|args
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|v
operator|=
name|num_mul
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_SUB
case|:
comment|/* - */
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|x
operator|=
name|sc
operator|->
name|args
expr_stmt|;
name|v
operator|=
name|num_zero
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|v
operator|=
name|num_sub
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_DIV
case|:
comment|/* / */
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|x
operator|=
name|sc
operator|->
name|args
expr_stmt|;
name|v
operator|=
name|num_one
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_zero_double
argument_list|(
name|rvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|v
operator|=
name|num_div
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"/: division by zero"
argument_list|)
expr_stmt|;
block|}
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_INTDIV
case|:
comment|/* quotient */
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|x
operator|=
name|sc
operator|->
name|args
expr_stmt|;
name|v
operator|=
name|num_one
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|ivalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|v
operator|=
name|num_intdiv
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"quotient: division by zero"
argument_list|)
expr_stmt|;
block|}
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_REM
case|:
comment|/* remainder */
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|v
operator|=
name|num_rem
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"remainder: division by zero"
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_MOD
case|:
comment|/* modulo */
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|v
operator|=
name|num_mod
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"modulo: division by zero"
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_number
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CAR
case|:
comment|/* car */
name|s_return
argument_list|(
name|sc
argument_list|,
name|caar
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CDR
case|:
comment|/* cdr */
name|s_return
argument_list|(
name|sc
argument_list|,
name|cdar
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CONS
case|:
comment|/* cons */
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
case|case
name|OP_SETCAR
case|:
comment|/* set-car! */
if|if
condition|(
operator|!
name|is_immutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|caar
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"set-car!: unable to alter immutable pair"
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_SETCDR
case|:
comment|/* set-cdr! */
if|if
condition|(
operator|!
name|is_immutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|cdar
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"set-cdr!: unable to alter immutable pair"
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_CHAR2INT
case|:
block|{
comment|/* char->integer */
name|gunichar
name|c
decl_stmt|;
name|c
operator|=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_INT2CHAR
case|:
block|{
comment|/* integer->char */
name|gunichar
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|gunichar
operator|)
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_character
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_CHARUPCASE
case|:
block|{
name|gunichar
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|gunichar
operator|)
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|g_unichar_toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_character
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_CHARDNCASE
case|:
block|{
name|gunichar
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|gunichar
operator|)
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|g_unichar_tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_character
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_STR2SYM
case|:
comment|/* string->symbol */
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_STR2ATOM
case|:
comment|/* string->atom */
block|{
name|char
modifier|*
name|s
init|=
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_sharp_const
argument_list|(
name|sc
argument_list|,
name|s
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_atom
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|OP_SYM2STR
case|:
comment|/* symbol->string */
name|x
operator|=
name|mk_string
argument_list|(
name|sc
argument_list|,
name|symname
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setimmutable
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|OP_ATOM2STR
case|:
comment|/* atom->string */
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|x
argument_list|)
operator|||
name|is_character
argument_list|(
name|x
argument_list|)
operator|||
name|is_string
argument_list|(
name|x
argument_list|)
operator|||
name|is_symbol
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|atom2str
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_counted_string
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"atom->string: not an atom:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_MKSTRING
case|:
block|{
comment|/* make-string */
name|gunichar
name|fill
init|=
literal|' '
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|fill
operator|=
name|charvalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_empty_string
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
name|fill
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_STRLEN
case|:
comment|/* string-length */
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|g_utf8_strlen
argument_list|(
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_STRREF
case|:
block|{
comment|/* string-ref */
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|index
decl_stmt|;
name|str
operator|=
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|g_utf8_strlen
argument_list|(
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"string-ref: out of bounds:"
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|index
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_character
argument_list|(
name|sc
argument_list|,
name|g_utf8_get_char
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_STRSET
case|:
block|{
comment|/* string-set! */
name|pointer
name|a
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|index
decl_stmt|;
name|gunichar
name|c
decl_stmt|;
name|char
name|utf8
index|[
literal|7
index|]
decl_stmt|;
name|int
name|utf8_len
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|p1_len
decl_stmt|;
name|int
name|p2_len
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
name|a
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_immutable
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"string-set!: unable to alter immutable string:"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|strvalue
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|index
operator|=
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|g_utf8_strlen
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"string-set!: out of bounds:"
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|charvalue
argument_list|(
name|caddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|utf8_len
operator|=
name|g_unichar_to_utf8
argument_list|(
name|c
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|p1
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|index
argument_list|)
expr_stmt|;
name|p2
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p1_len
operator|=
name|p1
operator|-
name|str
expr_stmt|;
name|p2_len
operator|=
name|strlen
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|p1_len
operator|+
name|utf8_len
operator|+
name|p2_len
expr_stmt|;
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|malloc
argument_list|(
name|newlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstr
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"string-set!: No memory to alter string:"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1_len
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|,
name|p1_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newstr
operator|+
name|p1_len
argument_list|,
name|utf8
argument_list|,
name|utf8_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2_len
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|newstr
operator|+
name|p1_len
operator|+
name|utf8_len
argument_list|,
name|p2
argument_list|,
name|p2_len
argument_list|)
expr_stmt|;
name|newstr
index|[
name|newlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|strvalue
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|strvalue
argument_list|(
name|a
argument_list|)
operator|=
name|newstr
expr_stmt|;
name|strlength
argument_list|(
name|a
argument_list|)
operator|=
name|newlen
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_STRAPPEND
case|:
block|{
comment|/* string-append */
comment|/* in 1.29 string-append was in Scheme in init.scm but was too slow */
name|int
name|len
init|=
literal|0
decl_stmt|;
name|pointer
name|newstr
decl_stmt|;
name|pointer
name|car_x
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
comment|/* compute needed length for new string */
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|args
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|len
operator|+=
name|strlength
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newstr
operator|=
name|mk_empty_string
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* store the contents of the argument strings into the new string */
name|pos
operator|=
name|strvalue
argument_list|(
name|newstr
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|args
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
name|car_x
operator|=
name|car
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pos
argument_list|,
name|strvalue
argument_list|(
name|car_x
argument_list|)
argument_list|,
name|strlength
argument_list|(
name|car_x
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|strlength
argument_list|(
name|car_x
argument_list|)
expr_stmt|;
block|}
operator|*
name|pos
operator|=
literal|'\0'
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_SUBSTR
case|:
block|{
comment|/* substring */
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|index0
decl_stmt|;
name|int
name|index1
decl_stmt|;
name|int
name|len
decl_stmt|;
name|pointer
name|x
decl_stmt|;
name|str
operator|=
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|index0
operator|=
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index0
operator|>
name|g_utf8_strlen
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"substring: start out of bounds:"
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|index1
operator|=
name|ivalue
argument_list|(
name|caddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index1
operator|>
name|g_utf8_strlen
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|)
operator|||
name|index1
operator|<
name|index0
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"substring: end out of bounds:"
argument_list|,
name|caddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|index1
operator|=
name|g_utf8_strlen
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|beg
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|index0
argument_list|)
expr_stmt|;
name|end
operator|=
name|g_utf8_offset_to_pointer
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|index1
argument_list|)
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
name|x
operator|=
name|mk_empty_string
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|strvalue
argument_list|(
name|x
argument_list|)
argument_list|,
name|beg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strvalue
argument_list|(
name|x
argument_list|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_VECTOR
case|:
block|{
comment|/* vector */
name|int
name|i
decl_stmt|;
name|pointer
name|vec
decl_stmt|;
name|int
name|len
init|=
name|list_length
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"vector: not a proper list:"
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|vec
operator|=
name|mk_vector
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sink
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|sc
operator|->
name|args
operator|,
name|i
operator|=
literal|0
init|;
name|is_pair
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|set_vector_elem
argument_list|(
name|vec
argument_list|,
name|i
argument_list|,
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_MKVECTOR
case|:
block|{
comment|/* make-vector */
name|pointer
name|fill
init|=
name|sc
operator|->
name|NIL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|pointer
name|vec
decl_stmt|;
name|len
operator|=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|fill
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|vec
operator|=
name|mk_vector
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sink
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fill
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|fill_vector
argument_list|(
name|vec
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_VECLEN
case|:
comment|/* vector-length */
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_VECREF
case|:
block|{
comment|/* vector-ref */
name|int
name|index
decl_stmt|;
name|index
operator|=
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"vector-ref: out of bounds:"
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|vector_elem
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_VECSET
case|:
block|{
comment|/* vector-set! */
name|int
name|index
decl_stmt|;
if|if
condition|(
name|is_immutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"vector-set!: unable to alter immutable vector:"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|ivalue
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"vector-set!: out of bounds:"
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_vector_elem
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|index
argument_list|,
name|caddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
default|default:
name|snprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|is_list (scheme * sc,pointer a)
specifier|static
name|int
name|is_list
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
name|pointer
name|slow
decl_stmt|,
name|fast
decl_stmt|;
name|slow
operator|=
name|fast
operator|=
name|a
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fast
operator|==
name|sc
operator|->
name|NIL
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|fast
argument_list|)
condition|)
return|return
literal|0
return|;
name|fast
operator|=
name|cdr
argument_list|(
name|fast
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast
operator|==
name|sc
operator|->
name|NIL
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|fast
argument_list|)
condition|)
return|return
literal|0
return|;
name|fast
operator|=
name|cdr
argument_list|(
name|fast
argument_list|)
expr_stmt|;
name|slow
operator|=
name|cdr
argument_list|(
name|slow
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast
operator|==
name|slow
condition|)
block|{
comment|/* the fast pointer has looped back around and caught up                with the slow pointer, hence the structure is circular,                not of finite length, and therefore not a list */
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|list_length (scheme * sc,pointer a)
name|int
name|list_length
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|pointer
name|slow
decl_stmt|,
name|fast
decl_stmt|;
name|slow
operator|=
name|fast
operator|=
name|a
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fast
operator|==
name|sc
operator|->
name|NIL
condition|)
return|return
name|i
return|;
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|fast
argument_list|)
condition|)
return|return
name|i
return|;
name|fast
operator|=
name|cdr
argument_list|(
name|fast
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|fast
operator|==
name|sc
operator|->
name|NIL
condition|)
return|return
name|i
return|;
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|fast
argument_list|)
condition|)
return|return
name|i
return|;
operator|++
name|i
expr_stmt|;
name|fast
operator|=
name|cdr
argument_list|(
name|fast
argument_list|)
expr_stmt|;
name|slow
operator|=
name|cdr
argument_list|(
name|slow
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast
operator|==
name|slow
condition|)
block|{
comment|/* the fast pointer has looped back around and caught up                with the slow pointer, hence the structure is circular,                not of finite length, and therefore not a list */
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|opexe_3 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_3
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|num
name|v
decl_stmt|;
name|int
function_decl|(
modifier|*
name|comp_func
function_decl|)
parameter_list|(
name|num
parameter_list|,
name|num
parameter_list|)
init|=
literal|0
function_decl|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_NOT
case|:
comment|/* not */
name|s_retbool
argument_list|(
name|is_false
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_BOOLP
case|:
comment|/* boolean? */
name|s_retbool
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|F
operator|||
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_EOFOBJP
case|:
comment|/* boolean? */
name|s_retbool
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|EOF_OBJ
argument_list|)
expr_stmt|;
case|case
name|OP_NULLP
case|:
comment|/* null? */
name|s_retbool
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
case|case
name|OP_NUMEQ
case|:
comment|/* = */
case|case
name|OP_LESS
case|:
comment|/*< */
case|case
name|OP_GRE
case|:
comment|/*> */
case|case
name|OP_LEQ
case|:
comment|/*<= */
case|case
name|OP_GEQ
case|:
comment|/*>= */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_NUMEQ
case|:
name|comp_func
operator|=
name|num_eq
expr_stmt|;
break|break;
case|case
name|OP_LESS
case|:
name|comp_func
operator|=
name|num_lt
expr_stmt|;
break|break;
case|case
name|OP_GRE
case|:
name|comp_func
operator|=
name|num_gt
expr_stmt|;
break|break;
case|case
name|OP_LEQ
case|:
name|comp_func
operator|=
name|num_le
expr_stmt|;
break|break;
case|case
name|OP_GEQ
case|:
name|comp_func
operator|=
name|num_ge
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* Quiet the compiler */
block|}
name|x
operator|=
name|sc
operator|->
name|args
expr_stmt|;
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|comp_func
argument_list|(
name|v
argument_list|,
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|s_retbool
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|nvalue
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_retbool
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|OP_SYMBOLP
case|:
comment|/* symbol? */
name|s_retbool
argument_list|(
name|is_symbol
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_NUMBERP
case|:
comment|/* number? */
name|s_retbool
argument_list|(
name|is_number
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_STRINGP
case|:
comment|/* string? */
name|s_retbool
argument_list|(
name|is_string
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_INTEGERP
case|:
comment|/* integer? */
name|s_retbool
argument_list|(
name|is_number
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|&&
name|is_integer
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_REALP
case|:
comment|/* real? */
name|s_retbool
argument_list|(
name|is_number
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All numbers are real */
case|case
name|OP_CHARP
case|:
comment|/* char? */
name|s_retbool
argument_list|(
name|is_character
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_CHAR_CLASSIFIERS
case|case
name|OP_CHARAP
case|:
comment|/* char-alphabetic? */
name|s_retbool
argument_list|(
name|Cisalpha
argument_list|(
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CHARNP
case|:
comment|/* char-numeric? */
name|s_retbool
argument_list|(
name|Cisdigit
argument_list|(
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CHARWP
case|:
comment|/* char-whitespace? */
name|s_retbool
argument_list|(
name|Cisspace
argument_list|(
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CHARUP
case|:
comment|/* char-upper-case? */
name|s_retbool
argument_list|(
name|Cisupper
argument_list|(
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CHARLP
case|:
comment|/* char-lower-case? */
name|s_retbool
argument_list|(
name|Cislower
argument_list|(
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|OP_PORTP
case|:
comment|/* port? */
name|s_retbool
argument_list|(
name|is_port
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_INPORTP
case|:
comment|/* input-port? */
name|s_retbool
argument_list|(
name|is_inport
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_OUTPORTP
case|:
comment|/* output-port? */
name|s_retbool
argument_list|(
name|is_outport
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_PROCP
case|:
comment|/* procedure? */
comment|/*--               * continuation should be procedure by the example               * (call-with-current-continuation procedure?) ==> #t                  * in R^3 report sec. 6.9               */
name|s_retbool
argument_list|(
name|is_proc
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|||
name|is_closure
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|||
name|is_continuation
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|||
name|is_foreign
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_PAIRP
case|:
comment|/* pair? */
name|s_retbool
argument_list|(
name|is_pair
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_LISTP
case|:
comment|/* list? */
name|s_retbool
argument_list|(
name|is_list
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_ENVP
case|:
comment|/* environment? */
name|s_retbool
argument_list|(
name|is_environment
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_VECTORP
case|:
comment|/* vector? */
name|s_retbool
argument_list|(
name|is_vector
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_EQ
case|:
comment|/* eq? */
name|s_retbool
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_EQV
case|:
comment|/* eqv? */
name|s_retbool
argument_list|(
name|eqv
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|snprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|opexe_4 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_4
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_FORCE
case|:
comment|/* force */
name|sc
operator|->
name|code
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_promise
argument_list|(
name|sc
operator|->
name|code
argument_list|)
condition|)
block|{
comment|/* Should change type to closure here */
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_SAVE_FORCED
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_APPLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_SAVE_FORCED
case|:
comment|/* Save forced value replacing promise */
name|memcpy
argument_list|(
name|sc
operator|->
name|code
argument_list|,
name|sc
operator|->
name|value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cell
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
case|case
name|OP_WRITE
case|:
comment|/* write */
case|case
name|OP_DISPLAY
case|:
comment|/* display */
case|case
name|OP_WRITE_CHAR
case|:
comment|/* write-char */
if|if
condition|(
name|is_pair
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|outport
condition|)
block|{
name|x
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|outport
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_SET_OUTPORT
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|outport
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|args
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_WRITE
condition|)
block|{
name|sc
operator|->
name|print_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|print_flag
operator|=
literal|0
expr_stmt|;
block|}
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
case|case
name|OP_NEWLINE
case|:
comment|/* newline */
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|outport
condition|)
block|{
name|x
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|outport
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_SET_OUTPORT
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|outport
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
block|}
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_ERR0
case|:
comment|/* error */
name|sc
operator|->
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_string
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_string
argument_list|(
name|sc
argument_list|,
literal|" -- "
argument_list|)
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|setimmutable
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"Error: "
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_ERR1
argument_list|)
expr_stmt|;
case|case
name|OP_ERR1
case|:
comment|/* error */
name|putstr
argument_list|(
name|sc
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|args
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_ERR1
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|print_flag
operator|=
literal|1
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|interactive_repl
condition|)
block|{
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_T0LVL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|sc
operator|->
name|NIL
return|;
block|}
block|}
case|case
name|OP_REVERSE
case|:
comment|/* reverse */
name|s_return
argument_list|(
name|sc
argument_list|,
name|reverse
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_LIST_STAR
case|:
comment|/* list* */
name|s_return
argument_list|(
name|sc
argument_list|,
name|list_star
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_APPEND
case|:
comment|/* append */
if|if
condition|(
name|sc
operator|->
name|args
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
init|;
name|y
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
name|x
operator|=
name|append
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|car
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_PLIST
case|case
name|OP_PUT
case|:
comment|/* put */
if|if
condition|(
operator|!
name|hasprop
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|||
operator|!
name|hasprop
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"illegal use of put"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|symprop
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|,
name|y
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|caar
argument_list|(
name|x
argument_list|)
operator|==
name|y
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
name|cdar
argument_list|(
name|x
argument_list|)
operator|=
name|caddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
else|else
name|symprop
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|y
argument_list|,
name|caddr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
name|symprop
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_GET
case|:
comment|/* get */
if|if
condition|(
operator|!
name|hasprop
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|||
operator|!
name|hasprop
argument_list|(
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"illegal use of get"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|symprop
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|,
name|y
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
init|;
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|;
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|caar
argument_list|(
name|x
argument_list|)
operator|==
name|y
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|cdar
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_PLIST */
case|case
name|OP_QUIT
case|:
comment|/* quit */
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|sc
operator|->
name|retcode
operator|=
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sc
operator|->
name|NIL
operator|)
return|;
case|case
name|OP_GC
case|:
comment|/* gc */
name|gc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_GCVERB
case|:
comment|/* gc-verbose */
block|{
name|int
name|was
init|=
name|sc
operator|->
name|gc_verbose
decl_stmt|;
name|sc
operator|->
name|gc_verbose
operator|=
operator|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|F
operator|)
expr_stmt|;
name|s_retbool
argument_list|(
name|was
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_NEWSEGMENT
case|:
comment|/* new-segment */
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|||
operator|!
name|is_number
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"new-segment: argument must be a number"
argument_list|)
expr_stmt|;
block|}
name|alloc_cellseg
argument_list|(
name|sc
argument_list|,
operator|(
name|int
operator|)
name|ivalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_OBLIST
case|:
comment|/* oblist */
name|s_return
argument_list|(
name|sc
argument_list|,
name|oblist_all_symbols
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_CURR_INPORT
case|:
comment|/* current-input-port */
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|inport
argument_list|)
expr_stmt|;
case|case
name|OP_CURR_OUTPORT
case|:
comment|/* current-output-port */
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|outport
argument_list|)
expr_stmt|;
case|case
name|OP_OPEN_INFILE
case|:
comment|/* open-input-file */
case|case
name|OP_OPEN_OUTFILE
case|:
comment|/* open-output-file */
case|case
name|OP_OPEN_INOUTFILE
case|:
comment|/* open-input-output-file */
block|{
name|int
name|prop
init|=
literal|0
decl_stmt|;
name|pointer
name|p
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_OPEN_INFILE
case|:
name|prop
operator|=
name|port_input
expr_stmt|;
break|break;
case|case
name|OP_OPEN_OUTFILE
case|:
name|prop
operator|=
name|port_output
expr_stmt|;
break|break;
case|case
name|OP_OPEN_INOUTFILE
case|:
name|prop
operator|=
name|port_input
operator||
name|port_output
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* Quiet the compiler */
block|}
name|p
operator|=
name|port_from_filename
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|USE_STRING_PORTS
case|case
name|OP_OPEN_INSTRING
case|:
comment|/* open-input-string */
case|case
name|OP_OPEN_INOUTSTRING
case|:
comment|/* open-input-output-string */
block|{
name|int
name|prop
init|=
literal|0
decl_stmt|;
name|pointer
name|p
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_OPEN_INSTRING
case|:
name|prop
operator|=
name|port_input
expr_stmt|;
break|break;
case|case
name|OP_OPEN_INOUTSTRING
case|:
name|prop
operator|=
name|port_input
operator||
name|port_output
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* Quiet the compiler */
block|}
name|p
operator|=
name|port_from_string
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|+
name|strlength
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_OPEN_OUTSTRING
case|:
comment|/* open-output-string */
block|{
name|pointer
name|p
decl_stmt|;
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|p
operator|=
name|port_from_scratch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|port_from_string
argument_list|(
name|sc
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
name|strvalue
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|+
name|strlength
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|,
name|port_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_GET_OUTSTRING
case|:
comment|/* get-output-string */
block|{
name|port
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|->
name|_object
operator|.
name|_port
operator|)
operator|->
name|kind
operator|&
name|port_string
condition|)
block|{
name|off_t
name|size
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size
operator|=
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|curr
operator|-
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|str
operator|=
name|sc
operator|->
name|malloc
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|pointer
name|s
decl_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|p
operator|->
name|rep
operator|.
name|string
operator|.
name|start
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|mk_string
argument_list|(
name|sc
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
case|case
name|OP_CLOSE_INPORT
case|:
comment|/* close-input-port */
name|port_close
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|port_input
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_CLOSE_OUTPORT
case|:
comment|/* close-output-port */
name|port_close
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|port_output
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
case|case
name|OP_INT_ENV
case|:
comment|/* interaction-environment */
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|global_env
argument_list|)
expr_stmt|;
case|case
name|OP_CURR_ENV
case|:
comment|/* current-environment */
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|)
expr_stmt|;
default|default:
name|sprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|opexe_5 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_5
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|nesting
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|sc
operator|->
name|nesting
decl_stmt|;
name|sc
operator|->
name|nesting
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"unmatched parentheses:"
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* ========== reading part ========== */
case|case
name|OP_READ
case|:
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_READ_INTERNAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_inport
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"read: not an input port:"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|inport
condition|)
block|{
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_READ_INTERNAL
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|sc
operator|->
name|inport
expr_stmt|;
name|sc
operator|->
name|inport
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|x
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_SET_INPORT
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_READ_INTERNAL
argument_list|)
expr_stmt|;
case|case
name|OP_READ_CHAR
case|:
comment|/* read-char */
case|case
name|OP_PEEK_CHAR
case|:
comment|/* peek-char */
block|{
name|gunichar
name|c
decl_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|!=
name|sc
operator|->
name|inport
condition|)
block|{
name|x
operator|=
name|sc
operator|->
name|inport
expr_stmt|;
name|x
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_SET_INPORT
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|inport
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|inchar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|EOF_OBJ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|op
operator|==
name|OP_PEEK_CHAR
condition|)
block|{
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_character
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_CHAR_READY
case|:
comment|/* char-ready? */
block|{
name|pointer
name|p
init|=
name|sc
operator|->
name|inport
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|p
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|p
operator|->
name|_object
operator|.
name|_port
operator|->
name|kind
operator|&
name|port_string
expr_stmt|;
name|s_retbool
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_SET_INPORT
case|:
comment|/* set-input-port */
name|sc
operator|->
name|inport
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
case|case
name|OP_SET_OUTPORT
case|:
comment|/* set-output-port */
name|sc
operator|->
name|outport
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|)
expr_stmt|;
case|case
name|OP_RDSEXPR
case|:
switch|switch
condition|(
name|sc
operator|->
name|tok
condition|)
block|{
case|case
name|TOK_EOF
case|:
if|if
condition|(
name|sc
operator|->
name|inport
operator|==
name|sc
operator|->
name|loadport
condition|)
block|{
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_QUIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|EOF_OBJ
argument_list|)
expr_stmt|;
block|}
comment|/*  * Commented out because we now skip comments in the scanner  *           case TOK_COMMENT: {                gunichar c;                while ((c=inchar(sc)) != '\n'&& c!=EOF)                     ;                sc->tok = token(sc);                s_goto(sc,OP_RDSEXPR);           } */
case|case
name|TOK_VEC
case|:
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDVEC
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|TOK_LPAREN
case|:
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tok
operator|==
name|TOK_RPAREN
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tok
operator|==
name|TOK_DOT
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"syntax error: illegal dot expression"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|nesting_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|++
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDLIST
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
block|}
case|case
name|TOK_QUOTE
case|:
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDQUOTE
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
case|case
name|TOK_BQUOTE
case|:
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tok
operator|==
name|TOK_VEC
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDQQUOTEVEC
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tok
operator|=
name|TOK_LPAREN
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDQQUOTE
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
block|}
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
case|case
name|TOK_COMMA
case|:
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDUNQUOTE
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
case|case
name|TOK_ATMARK
case|:
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDUQTSP
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
case|case
name|TOK_ATOM
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_atom
argument_list|(
name|sc
argument_list|,
name|readstr_upto
argument_list|(
name|sc
argument_list|,
literal|"();\t\n\r "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|TOK_DQUOTE
case|:
name|x
operator|=
name|readstrexp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|sc
operator|->
name|F
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"Error reading string"
argument_list|)
expr_stmt|;
block|}
name|setimmutable
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|TOK_SHARP
case|:
block|{
name|pointer
name|f
init|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|envir
argument_list|,
name|sc
operator|->
name|SHARP_HOOK
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"undefined sharp expression"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|code
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|slot_value_in_env
argument_list|(
name|f
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|TOK_SHARP_CONST
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|mk_sharp_const
argument_list|(
name|sc
argument_list|,
name|readstr_upto
argument_list|(
name|sc
argument_list|,
literal|"();\t\n\r "
argument_list|)
argument_list|)
operator|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"undefined sharp expression"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
default|default:
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"syntax error: illegal token"
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tok
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RDLIST
case|:
block|{
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We now skip comments in the scanner           while (sc->tok == TOK_COMMENT) {                gunichar c;                while ((c=inchar(sc)) != '\n'&& c!=EOF)                     ;                sc->tok = token(sc);           } */
if|if
condition|(
name|sc
operator|->
name|tok
operator|==
name|TOK_RPAREN
condition|)
block|{
name|gunichar
name|c
init|=
name|inchar
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|backchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nesting_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|--
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|reverse_in_place
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tok
operator|==
name|TOK_DOT
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDDOT
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tok
operator|=
name|token
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_RDLIST
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_RDSEXPR
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|OP_RDDOT
case|:
if|if
condition|(
name|token
argument_list|(
name|sc
argument_list|)
operator|!=
name|TOK_RPAREN
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"syntax error: illegal dot expression"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|nesting_stack
index|[
name|sc
operator|->
name|file_i
index|]
operator|--
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|reverse_in_place
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_RDQUOTE
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|QUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_RDQQUOTE
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|QQUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_RDQQUOTEVEC
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"apply"
argument_list|)
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"vector"
argument_list|)
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|QQUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_RDUNQUOTE
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|UNQUOTE
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_RDUQTSP
case|:
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|UNQUOTESP
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|value
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_RDVEC
case|:
comment|/*sc->code=cons(sc,mk_proc(sc,OP_VECTOR),sc->value);           s_goto(sc,OP_EVAL); Cannot be quoted*/
comment|/*x=cons(sc,mk_proc(sc,OP_VECTOR),sc->value);          s_return(sc,x); Cannot be part of pairs*/
comment|/*sc->code=mk_proc(sc,OP_VECTOR);        sc->args=sc->value;        s_goto(sc,OP_APPLY);*/
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|value
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_VECTOR
argument_list|)
expr_stmt|;
comment|/* ========== printing part ========== */
case|case
name|OP_P0LIST
case|:
if|if
condition|(
name|is_vector
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"#("
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_PVECFROM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_environment
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"#<ENVIRONMENT>"
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|printatom
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|print_flag
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|QUOTE
operator|&&
name|ok_abbrev
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|QQUOTE
operator|&&
name|ok_abbrev
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|UNQUOTE
operator|&&
name|ok_abbrev
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
operator|==
name|sc
operator|->
name|UNQUOTESP
operator|&&
name|ok_abbrev
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|",@"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_P1LIST
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_P1LIST
case|:
if|if
condition|(
name|is_pair
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_P1LIST
argument_list|,
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|sc
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_vector
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_P1LIST
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|sc
argument_list|,
literal|" . "
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|args
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|" . "
argument_list|)
expr_stmt|;
name|printatom
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|print_flag
argument_list|)
expr_stmt|;
block|}
name|putstr
argument_list|(
name|sc
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_PVECFROM
case|:
block|{
name|int
name|i
init|=
name|ivalue_unchecked
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|pointer
name|vec
init|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|ivalue_unchecked
argument_list|(
name|vec
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|len
condition|)
block|{
name|putstr
argument_list|(
name|sc
argument_list|,
literal|" )"
argument_list|)
expr_stmt|;
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pointer
name|elem
init|=
name|vector_elem
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|ivalue_unchecked
argument_list|(
name|cdr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_PVECFROM
argument_list|,
name|sc
operator|->
name|args
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|elem
expr_stmt|;
name|putstr
argument_list|(
name|sc
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|s_goto
argument_list|(
name|sc
argument_list|,
name|OP_P0LIST
argument_list|)
expr_stmt|;
block|}
block|}
default|default:
name|snprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
block|}
end_function

begin_function
DECL|function|opexe_6 (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|opexe_6
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
name|long
name|v
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_LIST_LENGTH
case|:
comment|/* length */
comment|/* a.k */
name|v
operator|=
name|list_length
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
literal|0
condition|)
block|{
name|Error_1
argument_list|(
name|sc
argument_list|,
literal|"length: not a list:"
argument_list|,
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_return
argument_list|(
name|sc
argument_list|,
name|mk_integer
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_ASSQ
case|:
comment|/* assq */
comment|/* a.k */
name|x
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|cadr
argument_list|(
name|sc
operator|->
name|args
argument_list|)
init|;
name|is_pair
argument_list|(
name|y
argument_list|)
condition|;
name|y
operator|=
name|cdr
argument_list|(
name|y
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_pair
argument_list|(
name|car
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|Error_0
argument_list|(
name|sc
argument_list|,
literal|"unable to handle non pair element"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|caar
argument_list|(
name|y
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|is_pair
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|car
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_GET_CLOSURE
case|:
comment|/* get-closure-code */
comment|/* a.k */
name|sc
operator|->
name|args
operator|=
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|args
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_closure
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|LAMBDA
argument_list|,
name|closure_code
argument_list|(
name|sc
operator|->
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_macro
argument_list|(
name|sc
operator|->
name|args
argument_list|)
condition|)
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|LAMBDA
argument_list|,
name|closure_code
argument_list|(
name|sc
operator|->
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_return
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|F
argument_list|)
expr_stmt|;
block|}
case|case
name|OP_CLOSUREP
case|:
comment|/* closure? */
comment|/*            * Note, macro object is also a closure.            * Therefore, (closure?<#MACRO>) ==> #t            */
name|s_retbool
argument_list|(
name|is_closure
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OP_MACROP
case|:
comment|/* macro? */
name|s_retbool
argument_list|(
name|is_macro
argument_list|(
name|car
argument_list|(
name|sc
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|snprintf
argument_list|(
name|sc
operator|->
name|strbuff
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%d: illegal operator"
argument_list|,
name|sc
operator|->
name|op
argument_list|)
expr_stmt|;
name|Error_0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|strbuff
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|T
return|;
comment|/* NOTREACHED */
block|}
end_function

begin_typedef
DECL|typedef|dispatch_func
typedef|typedef
name|pointer
function_decl|(
modifier|*
name|dispatch_func
function_decl|)
parameter_list|(
name|scheme
modifier|*
parameter_list|,
name|enum
name|scheme_opcodes
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|test_predicate
typedef|typedef
name|int
function_decl|(
modifier|*
name|test_predicate
function_decl|)
parameter_list|(
name|pointer
parameter_list|)
function_decl|;
end_typedef

begin_function
DECL|function|is_any (pointer p)
specifier|static
name|int
name|is_any
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
DECL|function|is_nonneg (pointer p)
specifier|static
name|int
name|is_nonneg
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
return|return
name|is_integer
argument_list|(
name|p
argument_list|)
operator|&&
name|ivalue
argument_list|(
name|p
argument_list|)
operator|>=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Correspond carefully with following defines! */
end_comment

begin_struct
DECL|struct|__anon28dc31d10208
specifier|static
struct|struct
block|{
DECL|member|fct
name|test_predicate
name|fct
decl_stmt|;
DECL|member|kind
specifier|const
name|char
modifier|*
name|kind
decl_stmt|;
DECL|variable|tests
block|}
name|tests
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused */
block|{
name|is_any
block|,
literal|0
block|}
block|,
block|{
name|is_string
block|,
literal|"string"
block|}
block|,
block|{
name|is_symbol
block|,
literal|"symbol"
block|}
block|,
block|{
name|is_port
block|,
literal|"port"
block|}
block|,
block|{
literal|0
block|,
literal|"input port"
block|}
block|,
block|{
literal|0
block|,
literal|"output_port"
block|}
block|,
block|{
name|is_environment
block|,
literal|"environment"
block|}
block|,
block|{
name|is_pair
block|,
literal|"pair"
block|}
block|,
block|{
literal|0
block|,
literal|"pair or '()"
block|}
block|,
block|{
name|is_character
block|,
literal|"character"
block|}
block|,
block|{
name|is_vector
block|,
literal|"vector"
block|}
block|,
block|{
name|is_number
block|,
literal|"number"
block|}
block|,
block|{
name|is_integer
block|,
literal|"integer"
block|}
block|,
block|{
name|is_nonneg
block|,
literal|"non-negative integer"
block|}
block|}
struct|;
end_struct

begin_define
DECL|macro|TST_NONE
define|#
directive|define
name|TST_NONE
value|0
end_define

begin_define
DECL|macro|TST_ANY
define|#
directive|define
name|TST_ANY
value|"\001"
end_define

begin_define
DECL|macro|TST_STRING
define|#
directive|define
name|TST_STRING
value|"\002"
end_define

begin_define
DECL|macro|TST_SYMBOL
define|#
directive|define
name|TST_SYMBOL
value|"\003"
end_define

begin_define
DECL|macro|TST_PORT
define|#
directive|define
name|TST_PORT
value|"\004"
end_define

begin_define
DECL|macro|TST_INPORT
define|#
directive|define
name|TST_INPORT
value|"\005"
end_define

begin_define
DECL|macro|TST_OUTPORT
define|#
directive|define
name|TST_OUTPORT
value|"\006"
end_define

begin_define
DECL|macro|TST_ENVIRONMENT
define|#
directive|define
name|TST_ENVIRONMENT
value|"\007"
end_define

begin_define
DECL|macro|TST_PAIR
define|#
directive|define
name|TST_PAIR
value|"\010"
end_define

begin_define
DECL|macro|TST_LIST
define|#
directive|define
name|TST_LIST
value|"\011"
end_define

begin_define
DECL|macro|TST_CHAR
define|#
directive|define
name|TST_CHAR
value|"\012"
end_define

begin_define
DECL|macro|TST_VECTOR
define|#
directive|define
name|TST_VECTOR
value|"\013"
end_define

begin_define
DECL|macro|TST_NUMBER
define|#
directive|define
name|TST_NUMBER
value|"\014"
end_define

begin_define
DECL|macro|TST_INTEGER
define|#
directive|define
name|TST_INTEGER
value|"\015"
end_define

begin_define
DECL|macro|TST_NATURAL
define|#
directive|define
name|TST_NATURAL
value|"\016"
end_define

begin_typedef
DECL|struct|__anon28dc31d10308
typedef|typedef
struct|struct
block|{
DECL|member|func
name|dispatch_func
name|func
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|min_arity
name|int
name|min_arity
decl_stmt|;
DECL|member|max_arity
name|int
name|max_arity
decl_stmt|;
DECL|member|arg_tests_encoding
name|char
modifier|*
name|arg_tests_encoding
decl_stmt|;
DECL|typedef|op_code_info
block|}
name|op_code_info
typedef|;
end_typedef

begin_define
DECL|macro|INF_ARG
define|#
directive|define
name|INF_ARG
value|0xffff
end_define

begin_decl_stmt
DECL|variable|dispatch_table
specifier|static
name|op_code_info
name|dispatch_table
index|[]
init|=
block|{
DECL|macro|_OP_DEF (A,B,C,D,E,OP)
define|#
directive|define
name|_OP_DEF
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|,
name|D
parameter_list|,
name|E
parameter_list|,
name|OP
parameter_list|)
value|{A,B,C,D,E},
include|#
directive|include
file|"opdefines.h"
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
DECL|function|procname (pointer x)
specifier|static
specifier|const
name|char
modifier|*
name|procname
parameter_list|(
name|pointer
name|x
parameter_list|)
block|{
name|int
name|n
init|=
name|procnum
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|dispatch_table
index|[
name|n
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
name|name
operator|=
literal|"ILLEGAL!"
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* kernel of this interpreter */
end_comment

begin_function
DECL|function|Eval_Cycle (scheme * sc,enum scheme_opcodes op)
specifier|static
name|void
name|Eval_Cycle
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|old_op
decl_stmt|;
name|sc
operator|->
name|op
operator|=
name|op
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|op_code_info
modifier|*
name|pcd
init|=
name|dispatch_table
operator|+
name|sc
operator|->
name|op
decl_stmt|;
if|if
condition|(
name|pcd
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
comment|/* if built-in function, check arguments */
name|char
name|msg
index|[
name|STRBUFFSIZE
index|]
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|int
name|n
init|=
name|list_length
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|args
argument_list|)
decl_stmt|;
comment|/* Check number of arguments */
if|if
condition|(
name|n
operator|<
name|pcd
operator|->
name|min_arity
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%s: needs%s %d argument(s)"
argument_list|,
name|pcd
operator|->
name|name
argument_list|,
name|pcd
operator|->
name|min_arity
operator|==
name|pcd
operator|->
name|max_arity
condition|?
literal|""
else|:
literal|" at least"
argument_list|,
name|pcd
operator|->
name|min_arity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|&&
name|n
operator|>
name|pcd
operator|->
name|max_arity
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%s: needs%s %d argument(s)"
argument_list|,
name|pcd
operator|->
name|name
argument_list|,
name|pcd
operator|->
name|min_arity
operator|==
name|pcd
operator|->
name|max_arity
condition|?
literal|""
else|:
literal|" at most"
argument_list|,
name|pcd
operator|->
name|max_arity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|pcd
operator|->
name|arg_tests_encoding
operator|!=
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
init|=
name|pcd
operator|->
name|arg_tests_encoding
decl_stmt|;
name|pointer
name|arglist
init|=
name|sc
operator|->
name|args
decl_stmt|;
do|do
block|{
name|pointer
name|arg
init|=
name|car
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|j
operator|=
operator|(
name|int
operator|)
name|t
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|TST_INPORT
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|is_inport
argument_list|(
name|arg
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|TST_OUTPORT
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|is_outport
argument_list|(
name|arg
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|TST_LIST
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|arg
operator|!=
name|sc
operator|->
name|NIL
operator|&&
operator|!
name|is_pair
argument_list|(
name|arg
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tests
index|[
name|j
index|]
operator|.
name|fct
argument_list|(
name|arg
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* last test is replicated as necessary */
name|t
operator|++
expr_stmt|;
block|}
name|arglist
operator|=
name|cdr
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|n
condition|)
do|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
name|STRBUFFSIZE
argument_list|,
literal|"%s: argument %d must be: %s"
argument_list|,
name|pcd
operator|->
name|name
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|tests
index|[
name|j
index|]
operator|.
name|kind
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|_Error_1
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
return|return;
block|}
name|pcd
operator|=
name|dispatch_table
operator|+
name|sc
operator|->
name|op
expr_stmt|;
block|}
block|}
name|ok_to_freely_gc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|old_op
operator|=
name|sc
operator|->
name|op
expr_stmt|;
if|if
condition|(
name|pcd
operator|->
name|func
argument_list|(
name|sc
argument_list|,
operator|(
expr|enum
name|scheme_opcodes
operator|)
name|sc
operator|->
name|op
argument_list|)
operator|==
name|sc
operator|->
name|NIL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|no_memory
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No memory!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========== Initialization of internal keywords ========== */
end_comment

begin_function
DECL|function|assign_syntax (scheme * sc,char * name)
specifier|static
name|void
name|assign_syntax
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|x
operator|=
name|oblist_add_by_name
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|x
argument_list|)
operator||=
name|T_SYNTAX
expr_stmt|;
block|}
end_function

begin_function
DECL|function|assign_proc (scheme * sc,enum scheme_opcodes op,char * name)
specifier|static
name|void
name|assign_proc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|y
operator|=
name|mk_proc
argument_list|(
name|sc
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|mk_proc (scheme * sc,enum scheme_opcodes op)
specifier|static
name|pointer
name|mk_proc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|enum
name|scheme_opcodes
name|op
parameter_list|)
block|{
name|pointer
name|y
decl_stmt|;
name|y
operator|=
name|get_cell
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|y
argument_list|)
operator|=
operator|(
name|T_PROC
operator||
name|T_ATOM
operator|)
expr_stmt|;
name|ivalue_unchecked
argument_list|(
name|y
argument_list|)
operator|=
operator|(
name|long
operator|)
name|op
expr_stmt|;
name|set_num_integer
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* Hard-coded for the given keywords. Remember to rewrite if more are added! */
end_comment

begin_function
DECL|function|syntaxnum (pointer p)
specifier|static
name|int
name|syntaxnum
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|strvalue
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|strlength
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'i'
condition|)
return|return
name|OP_IF0
return|;
comment|/* if */
else|else
return|return
name|OP_OR0
return|;
comment|/* or */
case|case
literal|3
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
return|return
name|OP_AND0
return|;
comment|/* and */
else|else
return|return
name|OP_LET0
return|;
comment|/* let */
case|case
literal|4
case|:
switch|switch
condition|(
name|s
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'e'
case|:
return|return
name|OP_CASE0
return|;
comment|/* case */
case|case
literal|'d'
case|:
return|return
name|OP_COND0
return|;
comment|/* cond */
case|case
literal|'*'
case|:
return|return
name|OP_LET0AST
return|;
comment|/* let* */
default|default:
return|return
name|OP_SET0
return|;
comment|/* set! */
block|}
case|case
literal|5
case|:
switch|switch
condition|(
name|s
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'g'
case|:
return|return
name|OP_BEGIN
return|;
comment|/* begin */
case|case
literal|'l'
case|:
return|return
name|OP_DELAY
return|;
comment|/* delay */
case|case
literal|'c'
case|:
return|return
name|OP_MACRO0
return|;
comment|/* macro */
default|default:
return|return
name|OP_QUOTE
return|;
comment|/* quote */
block|}
case|case
literal|6
case|:
switch|switch
condition|(
name|s
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'m'
case|:
return|return
name|OP_LAMBDA
return|;
comment|/* lambda */
case|case
literal|'f'
case|:
return|return
name|OP_DEF0
return|;
comment|/* define */
default|default:
return|return
name|OP_LET0REC
return|;
comment|/* letrec */
block|}
default|default:
return|return
name|OP_C0STREAM
return|;
comment|/* cons-stream */
block|}
block|}
end_function

begin_comment
comment|/* initialization of TinyScheme */
end_comment

begin_if
if|#
directive|if
name|USE_INTERFACE
end_if

begin_function
DECL|function|s_cons (scheme * sc,pointer a,pointer b)
name|INTERFACE
specifier|static
name|pointer
name|s_cons
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
return|return
name|cons
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|s_immutable_cons (scheme * sc,pointer a,pointer b)
name|INTERFACE
specifier|static
name|pointer
name|s_immutable_cons
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|a
parameter_list|,
name|pointer
name|b
parameter_list|)
block|{
return|return
name|immutable_cons
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|vtbl
specifier|static
name|struct
name|scheme_interface
name|vtbl
init|=
block|{
name|scheme_define
block|,
name|s_cons
block|,
name|s_immutable_cons
block|,
name|reserve_cells
block|,
name|mk_integer
block|,
name|mk_real
block|,
name|mk_symbol
block|,
name|gensym
block|,
name|mk_string
block|,
name|mk_counted_string
block|,
name|mk_character
block|,
name|mk_vector
block|,
name|mk_foreign_func
block|,
name|mk_closure
block|,
name|putstr
block|,
name|putcharacter
block|,
name|is_string
block|,
name|string_length
block|,
name|string_value
block|,
name|is_number
block|,
name|nvalue
block|,
name|ivalue
block|,
name|rvalue
block|,
name|is_integer
block|,
name|is_real
block|,
name|is_character
block|,
name|charvalue
block|,
name|is_list
block|,
name|is_vector
block|,
name|list_length
block|,
name|ivalue
block|,
name|fill_vector
block|,
name|vector_elem
block|,
name|set_vector_elem
block|,
name|is_port
block|,
name|is_pair
block|,
name|pair_car
block|,
name|pair_cdr
block|,
name|set_car
block|,
name|set_cdr
block|,
name|is_symbol
block|,
name|symname
block|,
name|is_syntax
block|,
name|is_proc
block|,
name|is_foreign
block|,
name|syntaxname
block|,
name|is_closure
block|,
name|is_macro
block|,
name|closure_code
block|,
name|closure_env
block|,
name|is_continuation
block|,
name|is_promise
block|,
name|is_environment
block|,
name|is_immutable
block|,
name|setimmutable
block|,
name|scheme_load_file
block|,
name|scheme_load_string
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
DECL|function|scheme_init_new (void)
name|scheme
modifier|*
name|scheme_init_new
parameter_list|(
name|void
parameter_list|)
block|{
name|scheme
modifier|*
name|sc
init|=
operator|(
name|scheme
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scheme
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scheme_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|sc
return|;
block|}
block|}
end_function

begin_function
DECL|function|scheme_init_new_custom_alloc (func_alloc malloc,func_dealloc free)
name|scheme
modifier|*
name|scheme_init_new_custom_alloc
parameter_list|(
name|func_alloc
name|malloc
parameter_list|,
name|func_dealloc
name|free
parameter_list|)
block|{
name|scheme
modifier|*
name|sc
init|=
operator|(
name|scheme
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scheme
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scheme_init_custom_alloc
argument_list|(
name|sc
argument_list|,
name|malloc
argument_list|,
name|free
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|sc
return|;
block|}
block|}
end_function

begin_function
DECL|function|scheme_init (scheme * sc)
name|int
name|scheme_init
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|scheme_init_custom_alloc
argument_list|(
name|sc
argument_list|,
name|malloc
argument_list|,
name|free
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|scheme_init_custom_alloc (scheme * sc,func_alloc malloc,func_dealloc free)
name|int
name|scheme_init_custom_alloc
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|func_alloc
name|malloc
parameter_list|,
name|func_dealloc
name|free
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
sizeof|sizeof
argument_list|(
name|dispatch_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dispatch_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|pointer
name|x
decl_stmt|;
name|num_zero
operator|.
name|is_fixnum
operator|=
literal|1
expr_stmt|;
name|num_zero
operator|.
name|value
operator|.
name|ivalue
operator|=
literal|0
expr_stmt|;
name|num_one
operator|.
name|is_fixnum
operator|=
literal|1
expr_stmt|;
name|num_one
operator|.
name|value
operator|.
name|ivalue
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|USE_INTERFACE
name|sc
operator|->
name|vptr
operator|=
operator|&
name|vtbl
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|gensym_cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|malloc
operator|=
name|malloc
expr_stmt|;
name|sc
operator|->
name|free
operator|=
name|free
expr_stmt|;
name|sc
operator|->
name|last_cell_seg
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sink
operator|=
operator|&
name|sc
operator|->
name|_sink
expr_stmt|;
name|sc
operator|->
name|NIL
operator|=
operator|&
name|sc
operator|->
name|_NIL
expr_stmt|;
name|sc
operator|->
name|T
operator|=
operator|&
name|sc
operator|->
name|_HASHT
expr_stmt|;
name|sc
operator|->
name|F
operator|=
operator|&
name|sc
operator|->
name|_HASHF
expr_stmt|;
name|sc
operator|->
name|EOF_OBJ
operator|=
operator|&
name|sc
operator|->
name|_EOF_OBJ
expr_stmt|;
name|sc
operator|->
name|free_cell
operator|=
operator|&
name|sc
operator|->
name|_NIL
expr_stmt|;
name|sc
operator|->
name|fcells
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|no_memory
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|inport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|outport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|save_inport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|loadport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|nesting
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|interactive_repl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|print_output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alloc_cellseg
argument_list|(
name|sc
argument_list|,
name|FIRST_CELLSEGS
argument_list|)
operator|!=
name|FIRST_CELLSEGS
condition|)
block|{
name|sc
operator|->
name|no_memory
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|gc_verbose
operator|=
literal|0
expr_stmt|;
name|dump_stack_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|tracing
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bc_flag
operator|=
literal|0
expr_stmt|;
comment|/* init sc->NIL */
name|typeflag
argument_list|(
name|sc
operator|->
name|NIL
argument_list|)
operator|=
operator|(
name|T_ATOM
operator||
name|MARK
operator|)
expr_stmt|;
name|car
argument_list|(
name|sc
operator|->
name|NIL
argument_list|)
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|NIL
argument_list|)
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
comment|/* init T */
name|typeflag
argument_list|(
name|sc
operator|->
name|T
argument_list|)
operator|=
operator|(
name|T_ATOM
operator||
name|MARK
operator|)
expr_stmt|;
name|car
argument_list|(
name|sc
operator|->
name|T
argument_list|)
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|T
argument_list|)
operator|=
name|sc
operator|->
name|T
expr_stmt|;
comment|/* init F */
name|typeflag
argument_list|(
name|sc
operator|->
name|F
argument_list|)
operator|=
operator|(
name|T_ATOM
operator||
name|MARK
operator|)
expr_stmt|;
name|car
argument_list|(
name|sc
operator|->
name|F
argument_list|)
operator|=
name|cdr
argument_list|(
name|sc
operator|->
name|F
argument_list|)
operator|=
name|sc
operator|->
name|F
expr_stmt|;
comment|/* init sink */
name|typeflag
argument_list|(
name|sc
operator|->
name|sink
argument_list|)
operator|=
operator|(
name|T_PAIR
operator||
name|MARK
operator|)
expr_stmt|;
name|car
argument_list|(
name|sc
operator|->
name|sink
argument_list|)
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|oblist
operator|=
name|oblist_initial_value
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init global_env */
name|new_frame_in_env
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|global_env
operator|=
name|sc
operator|->
name|envir
expr_stmt|;
comment|/* init else */
name|x
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"else"
argument_list|)
expr_stmt|;
name|new_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|sc
operator|->
name|T
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"lambda"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"quote"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"define"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"if"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"set!"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"let"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"let*"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"letrec"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"cond"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"delay"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"and"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"cons-stream"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"macro"
argument_list|)
expr_stmt|;
name|assign_syntax
argument_list|(
name|sc
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dispatch_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
literal|0
condition|)
block|{
name|assign_proc
argument_list|(
name|sc
argument_list|,
operator|(
expr|enum
name|scheme_opcodes
operator|)
name|i
argument_list|,
name|dispatch_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* initialization of global pointers to special symbols */
name|sc
operator|->
name|LAMBDA
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"lambda"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|QUOTE
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"quote"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|QQUOTE
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"quasiquote"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|UNQUOTE
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"unquote"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|UNQUOTESP
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"unquote-splicing"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|FEED_TO
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"=>"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|COLON_HOOK
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"*colon-hook*"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ERROR_HOOK
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"*error-hook*"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|SHARP_HOOK
operator|=
name|mk_symbol
argument_list|(
name|sc
argument_list|,
literal|"*sharp-hook*"
argument_list|)
expr_stmt|;
return|return
operator|!
name|sc
operator|->
name|no_memory
return|;
block|}
end_function

begin_function
DECL|function|scheme_set_input_port_file (scheme * sc,FILE * fin)
name|SCHEME_EXPORT
name|void
name|scheme_set_input_port_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
name|fin
parameter_list|)
block|{
name|sc
operator|->
name|inport
operator|=
name|port_from_file
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|port_input
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|scheme_set_input_port_string (scheme * sc,char * start,char * past_the_end)
name|void
name|scheme_set_input_port_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|past_the_end
parameter_list|)
block|{
name|sc
operator|->
name|inport
operator|=
name|port_from_string
argument_list|(
name|sc
argument_list|,
name|start
argument_list|,
name|past_the_end
argument_list|,
name|port_input
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|scheme_set_output_port_file (scheme * sc,FILE * fout)
name|SCHEME_EXPORT
name|void
name|scheme_set_output_port_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
name|fout
parameter_list|)
block|{
name|sc
operator|->
name|outport
operator|=
name|port_from_file
argument_list|(
name|sc
argument_list|,
name|fout
argument_list|,
name|port_output
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|scheme_set_output_port_string (scheme * sc,char * start,char * past_the_end)
name|void
name|scheme_set_output_port_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|past_the_end
parameter_list|)
block|{
name|sc
operator|->
name|outport
operator|=
name|port_from_string
argument_list|(
name|sc
argument_list|,
name|start
argument_list|,
name|past_the_end
argument_list|,
name|port_output
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|scheme_set_external_data (scheme * sc,void * p)
name|void
name|scheme_set_external_data
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|sc
operator|->
name|ext_data
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
DECL|function|scheme_deinit (scheme * sc)
name|void
name|scheme_deinit
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|oblist
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|global_env
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|dump_stack_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|value
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
if|if
condition|(
name|is_port
argument_list|(
name|sc
operator|->
name|inport
argument_list|)
condition|)
block|{
name|typeflag
argument_list|(
name|sc
operator|->
name|inport
argument_list|)
operator|=
name|T_ATOM
expr_stmt|;
block|}
name|sc
operator|->
name|inport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|outport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
if|if
condition|(
name|is_port
argument_list|(
name|sc
operator|->
name|save_inport
argument_list|)
condition|)
block|{
name|typeflag
argument_list|(
name|sc
operator|->
name|save_inport
argument_list|)
operator|=
name|T_ATOM
expr_stmt|;
block|}
name|sc
operator|->
name|save_inport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
if|if
condition|(
name|is_port
argument_list|(
name|sc
operator|->
name|loadport
argument_list|)
condition|)
block|{
name|typeflag
argument_list|(
name|sc
operator|->
name|loadport
argument_list|)
operator|=
name|T_ATOM
expr_stmt|;
block|}
name|sc
operator|->
name|loadport
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|gc_verbose
operator|=
literal|0
expr_stmt|;
name|gc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|last_cell_seg
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|free
argument_list|(
name|sc
operator|->
name|alloc_seg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|scheme_load_file (scheme * sc,FILE * fin)
name|void
name|scheme_load_file
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|FILE
modifier|*
name|fin
parameter_list|)
block|{
name|dump_stack_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|sc
operator|->
name|global_env
expr_stmt|;
name|sc
operator|->
name|file_i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|kind
operator|=
name|port_input
operator||
name|port_file
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|rep
operator|.
name|stdio
operator|.
name|file
operator|=
name|fin
expr_stmt|;
name|sc
operator|->
name|loadport
operator|=
name|mk_port
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|load_stack
argument_list|)
expr_stmt|;
name|sc
operator|->
name|retcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|stdin
condition|)
block|{
name|sc
operator|->
name|interactive_repl
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|inport
operator|=
name|sc
operator|->
name|loadport
expr_stmt|;
name|Eval_Cycle
argument_list|(
name|sc
argument_list|,
name|OP_T0LVL
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|sc
operator|->
name|loadport
argument_list|)
operator|=
name|T_ATOM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|retcode
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|retcode
operator|=
name|sc
operator|->
name|nesting
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|scheme_load_string (scheme * sc,const char * cmd)
name|void
name|scheme_load_string
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|dump_stack_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|sc
operator|->
name|global_env
expr_stmt|;
name|sc
operator|->
name|file_i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|kind
operator|=
name|port_input
operator||
name|port_string
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|rep
operator|.
name|string
operator|.
name|start
operator|=
operator|(
name|char
operator|*
operator|)
name|cmd
expr_stmt|;
comment|/* This func respects const */
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|rep
operator|.
name|string
operator|.
name|past_the_end
operator|=
operator|(
name|char
operator|*
operator|)
name|cmd
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|load_stack
index|[
literal|0
index|]
operator|.
name|rep
operator|.
name|string
operator|.
name|curr
operator|=
operator|(
name|char
operator|*
operator|)
name|cmd
expr_stmt|;
name|sc
operator|->
name|loadport
operator|=
name|mk_port
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|load_stack
argument_list|)
expr_stmt|;
name|sc
operator|->
name|retcode
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|interactive_repl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|inport
operator|=
name|sc
operator|->
name|loadport
expr_stmt|;
name|Eval_Cycle
argument_list|(
name|sc
argument_list|,
name|OP_T0LVL
argument_list|)
expr_stmt|;
name|typeflag
argument_list|(
name|sc
operator|->
name|loadport
argument_list|)
operator|=
name|T_ATOM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|retcode
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|retcode
operator|=
name|sc
operator|->
name|nesting
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|scheme_define (scheme * sc,pointer envir,pointer symbol,pointer value)
name|void
name|scheme_define
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|envir
parameter_list|,
name|pointer
name|symbol
parameter_list|,
name|pointer
name|value
parameter_list|)
block|{
name|pointer
name|x
decl_stmt|;
name|x
operator|=
name|find_slot_in_env
argument_list|(
name|sc
argument_list|,
name|envir
argument_list|,
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|sc
operator|->
name|NIL
condition|)
block|{
name|set_slot_in_env
argument_list|(
name|sc
argument_list|,
name|x
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_slot_spec_in_env
argument_list|(
name|sc
argument_list|,
name|envir
argument_list|,
name|symbol
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|STANDALONE
end_if

begin_function
DECL|function|scheme_apply0 (scheme * sc,const char * procname)
name|pointer
name|scheme_apply0
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|procname
parameter_list|)
block|{
return|return
name|scheme_eval
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|(
name|sc
argument_list|,
name|mk_symbol
argument_list|(
name|sc
argument_list|,
name|procname
argument_list|)
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* "func" and "args" are assumed to be already eval'ed. */
end_comment

begin_function
DECL|function|scheme_call (scheme * sc,pointer func,pointer args)
name|pointer
name|scheme_call
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|func
parameter_list|,
name|pointer
name|args
parameter_list|)
block|{
name|int
name|old_repl
init|=
name|sc
operator|->
name|interactive_repl
decl_stmt|;
name|sc
operator|->
name|interactive_repl
operator|=
literal|0
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_QUIT
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|envir
operator|=
name|sc
operator|->
name|global_env
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|func
expr_stmt|;
name|sc
operator|->
name|retcode
operator|=
literal|0
expr_stmt|;
name|Eval_Cycle
argument_list|(
name|sc
argument_list|,
name|OP_APPLY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|interactive_repl
operator|=
name|old_repl
expr_stmt|;
return|return
name|sc
operator|->
name|value
return|;
block|}
end_function

begin_function
DECL|function|scheme_eval (scheme * sc,pointer obj)
name|pointer
name|scheme_eval
parameter_list|(
name|scheme
modifier|*
name|sc
parameter_list|,
name|pointer
name|obj
parameter_list|)
block|{
name|int
name|old_repl
init|=
name|sc
operator|->
name|interactive_repl
decl_stmt|;
name|sc
operator|->
name|interactive_repl
operator|=
literal|0
expr_stmt|;
name|s_save
argument_list|(
name|sc
argument_list|,
name|OP_QUIT
argument_list|,
name|sc
operator|->
name|NIL
argument_list|,
name|sc
operator|->
name|NIL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|args
operator|=
name|sc
operator|->
name|NIL
expr_stmt|;
name|sc
operator|->
name|code
operator|=
name|obj
expr_stmt|;
name|sc
operator|->
name|retcode
operator|=
literal|0
expr_stmt|;
name|Eval_Cycle
argument_list|(
name|sc
argument_list|,
name|OP_EVAL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|interactive_repl
operator|=
name|old_repl
expr_stmt|;
return|return
name|sc
operator|->
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========== Main ========== */
end_comment

begin_if
if|#
directive|if
name|STANDALONE
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OSX
argument_list|)
end_if

begin_function
DECL|function|main (int argc,char ** argv)
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
extern|extern MacTS_main(int argc
operator|,
extern|char **argv
block|)
function|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argc
init|=
name|ccommand
argument_list|(
operator|&
name|argv
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MacTS_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_macro
unit|} int
DECL|function|MacTS_main (int argc,char ** argv)
name|MacTS_main
argument_list|(
argument|int argc
argument_list|,
argument|char **argv
argument_list|)
end_macro

begin_block
DECL|function|MacTS_main (int argc,char ** argv)
block|{
else|#
directive|else
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
endif|#
directive|endif
name|scheme
name|sc
decl_stmt|;
name|FILE
modifier|*
name|fin
decl_stmt|;
name|char
modifier|*
name|file_name
init|=
name|InitFile
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|int
name|isfile
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
name|banner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: tinyscheme -?\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"or:    tinyscheme [<file1><file2> ...]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"followed by\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          -1<file> [<arg1><arg2> ...]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          -c<Scheme commands> [<arg1><arg2> ...]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"assuming that the executable is named tinyscheme.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use - as filename for stdin.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|scheme_init
argument_list|(
operator|&
name|sc
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not initialize!\n"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|scheme_set_input_port_file
argument_list|(
operator|&
name|sc
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|scheme_set_output_port_file
argument_list|(
operator|&
name|sc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_DL
name|scheme_define
argument_list|(
operator|&
name|sc
argument_list|,
name|sc
operator|.
name|global_env
argument_list|,
name|mk_symbol
argument_list|(
operator|&
name|sc
argument_list|,
literal|"load-extension"
argument_list|)
argument_list|,
name|mk_foreign_func
argument_list|(
operator|&
name|sc
argument_list|,
name|scm_load_ext
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file_name
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|getenv
argument_list|(
literal|"TINYSCHEMEINIT"
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|file_name
operator|=
name|p
expr_stmt|;
block|}
block|}
do|do
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fin
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"-1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"-c"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pointer
name|args
init|=
name|sc
operator|.
name|NIL
decl_stmt|;
name|isfile
operator|=
name|file_name
index|[
literal|1
index|]
operator|==
literal|'1'
expr_stmt|;
name|file_name
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fin
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isfile
condition|)
block|{
name|fin
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
name|pointer
name|value
init|=
name|mk_string
argument_list|(
operator|&
name|sc
argument_list|,
operator|*
name|argv
argument_list|)
decl_stmt|;
name|args
operator|=
name|cons
argument_list|(
operator|&
name|sc
argument_list|,
name|value
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|reverse_in_place
argument_list|(
operator|&
name|sc
argument_list|,
name|sc
operator|.
name|NIL
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|scheme_define
argument_list|(
operator|&
name|sc
argument_list|,
name|sc
operator|.
name|global_env
argument_list|,
name|mk_symbol
argument_list|(
operator|&
name|sc
argument_list|,
literal|"*args*"
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fin
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isfile
operator|&&
name|fin
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open file %s\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isfile
condition|)
block|{
name|scheme_load_file
argument_list|(
operator|&
name|sc
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scheme_load_string
argument_list|(
operator|&
name|sc
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isfile
operator|||
name|fin
operator|!=
name|stdin
condition|)
block|{
if|if
condition|(
name|sc
operator|.
name|retcode
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Errors encountered reading %s\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isfile
condition|)
block|{
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|file_name
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|file_name
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|scheme_load_file
argument_list|(
operator|&
name|sc
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
name|retcode
operator|=
name|sc
operator|.
name|retcode
expr_stmt|;
name|scheme_deinit
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

