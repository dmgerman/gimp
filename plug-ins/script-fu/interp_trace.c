begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    COPYRIGHT (c) 1992-1994 BY  *    MITECH CORPORATION, ACTON, MASSACHUSETTS.  *    See the source file SLIB.C for more information.   (trace procedure1 procedure2 ...)  (untrace procedure1 procedure2 ...)   Currently only user-defined procedures can be traced.  Fancy printing features such as indentation based on  recursion level will also have to wait for a future version.    */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"siod.h"
end_include

begin_include
include|#
directive|include
file|"siodp.h"
end_include

begin_function
specifier|static
name|void
DECL|function|init_trace_version (void)
name|init_trace_version
parameter_list|(
name|void
parameter_list|)
block|{
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*trace-version*"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"$Id$"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|tc_closure_traced
specifier|static
name|long
name|tc_closure_traced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_traced
specifier|static
name|LISP
name|sym_traced
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_quote
specifier|static
name|LISP
name|sym_quote
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_begin
specifier|static
name|LISP
name|sym_begin
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|LISP
name|ltrace_fcn_name
parameter_list|(
name|LISP
name|body
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LISP
name|ltrace_1
parameter_list|(
name|LISP
name|fcn_name
parameter_list|,
name|LISP
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LISP
name|ltrace
parameter_list|(
name|LISP
name|fcn_names
parameter_list|,
name|LISP
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LISP
name|luntrace_1
parameter_list|(
name|LISP
name|fcn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LISP
name|luntrace
parameter_list|(
name|LISP
name|fcns
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_gc_scan
parameter_list|(
name|LISP
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LISP
name|ct_gc_mark
parameter_list|(
name|LISP
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ct_prin1
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LISP
name|ct_eval
parameter_list|(
name|LISP
name|ct
parameter_list|,
name|LISP
modifier|*
name|px
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|LISP
DECL|function|ltrace_fcn_name (LISP body)
name|ltrace_fcn_name
parameter_list|(
name|LISP
name|body
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|;
if|if NCONSP
condition|(
name|body
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if NEQ
condition|(
name|CAR
argument_list|(
name|body
argument_list|)
operator|,
name|sym_begin
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|tmp
operator|=
name|CDR
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if NCONSP
condition|(
name|tmp
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|tmp
operator|=
name|CAR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if NCONSP
condition|(
name|tmp
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if NEQ
condition|(
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|,
name|sym_quote
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|tmp
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if NCONSP
condition|(
name|tmp
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ltrace_1 (LISP fcn_name,LISP env)
name|ltrace_1
parameter_list|(
name|LISP
name|fcn_name
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|fcn
decl_stmt|,
name|code
decl_stmt|;
name|fcn
operator|=
name|leval
argument_list|(
name|fcn_name
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|fcn
argument_list|)
operator|==
name|tc_closure
condition|)
block|{
name|code
operator|=
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
expr_stmt|;
if|if NULLP
condition|(
name|ltrace_fcn_name
argument_list|(
name|cdr
argument_list|(
name|code
argument_list|)
argument_list|)
condition|)
name|setcdr
argument_list|(
name|code
argument_list|,
name|cons
argument_list|(
name|sym_begin
argument_list|,
name|cons
argument_list|(
name|cons
argument_list|(
name|sym_quote
argument_list|,
name|cons
argument_list|(
name|fcn_name
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|,
name|cons
argument_list|(
name|cdr
argument_list|(
name|code
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fcn
operator|->
name|type
operator|=
name|tc_closure_traced
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE
argument_list|(
name|fcn
argument_list|)
operator|==
name|tc_closure_traced
condition|)
empty_stmt|;
else|else
name|err
argument_list|(
literal|"not a closure, cannot trace"
argument_list|,
name|fcn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ltrace (LISP fcn_names,LISP env)
name|ltrace
parameter_list|(
name|LISP
name|fcn_names
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|fcn_names
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|ltrace_1
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|luntrace_1 (LISP fcn)
name|luntrace_1
parameter_list|(
name|LISP
name|fcn
parameter_list|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|fcn
argument_list|)
operator|==
name|tc_closure
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE
argument_list|(
name|fcn
argument_list|)
operator|==
name|tc_closure_traced
condition|)
name|fcn
operator|->
name|type
operator|=
name|tc_closure
expr_stmt|;
else|else
name|err
argument_list|(
literal|"not a closure, cannot untrace"
argument_list|,
name|fcn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|luntrace (LISP fcns)
name|luntrace
parameter_list|(
name|LISP
name|fcns
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|fcns
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|luntrace_1
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ct_gc_scan (LISP ptr)
name|ct_gc_scan
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|CAR
argument_list|(
name|ptr
argument_list|)
operator|=
name|gc_relocate
argument_list|(
name|CAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|gc_relocate
argument_list|(
name|CDR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|LISP
DECL|function|ct_gc_mark (LISP ptr)
name|ct_gc_mark
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|gc_mark
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|ct_prin1 (LISP ptr,struct gen_printio * f)
name|ct_prin1
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|)
block|{
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"#<CLOSURE(TRACED) "
argument_list|)
expr_stmt|;
name|lprin1g
argument_list|(
name|car
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|lprin1g
argument_list|(
name|cdr
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|ct_eval (LISP ct,LISP * px,LISP * penv)
name|ct_eval
parameter_list|(
name|LISP
name|ct
parameter_list|,
name|LISP
modifier|*
name|px
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|fcn_name
decl_stmt|,
name|args
decl_stmt|,
name|env
decl_stmt|,
name|result
decl_stmt|,
name|l
decl_stmt|;
name|fcn_name
operator|=
name|ltrace_fcn_name
argument_list|(
name|cdr
argument_list|(
name|ct
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|leval_args
argument_list|(
name|CDR
argument_list|(
operator|*
name|px
argument_list|)
argument_list|,
operator|*
name|penv
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|stdout
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
name|lprin1f
argument_list|(
name|fcn_name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|args
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
block|{
name|fput_st
argument_list|(
name|stdout
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|lprin1f
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fput_st
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|env
operator|=
name|extend_env
argument_list|(
name|args
argument_list|,
name|car
argument_list|(
name|ct
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|ct
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|)
expr_stmt|;
name|result
operator|=
name|leval
argument_list|(
name|cdr
argument_list|(
name|ct
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|stdout
argument_list|,
literal|"<-"
argument_list|)
expr_stmt|;
name|lprin1f
argument_list|(
name|fcn_name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|stdout
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|lprin1f
argument_list|(
name|result
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|init_trace (void)
name|init_trace
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
name|tc_closure_traced
operator|=
name|allocate_user_tc
argument_list|()
expr_stmt|;
name|set_gc_hooks
argument_list|(
name|tc_closure_traced
argument_list|,
name|NULL
argument_list|,
name|ct_gc_mark
argument_list|,
name|ct_gc_scan
argument_list|,
name|NULL
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_traced
argument_list|,
literal|"*traced*"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym_traced
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_begin
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_quote
argument_list|,
literal|"quote"
argument_list|)
expr_stmt|;
name|set_print_hooks
argument_list|(
name|tc_closure_traced
argument_list|,
name|ct_prin1
argument_list|)
expr_stmt|;
name|set_eval_hooks
argument_list|(
name|tc_closure_traced
argument_list|,
name|ct_eval
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"trace"
argument_list|,
name|ltrace
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"untrace"
argument_list|,
name|luntrace
argument_list|)
expr_stmt|;
name|init_trace_version
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

