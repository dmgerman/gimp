begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"siod.h"
end_include

begin_comment
comment|/* OSF/1 doc says that POSIX and XPG4 include regcomp in libc.    So we might as well set ourselves up to take advantage of it.    This functionality is also available in hpux, and is also provided    by the FSF's librx package, so if you can use that if your    operating system vendor doesn't supply it.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|init_regex_version (void)
name|init_regex_version
parameter_list|(
name|void
parameter_list|)
block|{
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*regex-version*"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"$Id$"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|tc_regex
name|long
name|tc_regex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
DECL|struct|tc_regex
struct|struct
name|tc_regex
block|{
DECL|member|compflag
name|int
name|compflag
decl_stmt|;
DECL|member|nmatch
name|size_t
name|nmatch
decl_stmt|;
DECL|member|r
name|regex_t
modifier|*
name|r
decl_stmt|;
DECL|member|m
name|regmatch_t
modifier|*
name|m
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|tc_regex
modifier|*
DECL|function|get_tc_regex (LISP ptr)
name|get_tc_regex
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
if|if NTYPEP
condition|(
name|ptr
operator|,
name|tc_regex
condition|)
name|err
argument_list|(
literal|"not a regular expression"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|tc_regex
operator|*
operator|)
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|regcomp_l (LISP pattern,LISP flags)
name|regcomp_l
parameter_list|(
name|LISP
name|pattern
parameter_list|,
name|LISP
name|flags
parameter_list|)
block|{
name|long
name|iflag
decl_stmt|,
name|iflags
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
name|errbuff
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LISP
name|result
decl_stmt|;
name|struct
name|tc_regex
modifier|*
name|h
decl_stmt|;
name|iflags
operator|=
name|NNULLP
argument_list|(
name|flags
argument_list|)
condition|?
name|get_c_long
argument_list|(
name|flags
argument_list|)
else|:
literal|0
expr_stmt|;
name|str
operator|=
name|get_c_string
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|iflag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|tc_regex
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tc_regex
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|compflag
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|nmatch
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|r
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|tc_regex
expr_stmt|;
name|result
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|r
operator|=
operator|(
name|regex_t
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|regcomp
argument_list|(
name|h
operator|->
name|r
argument_list|,
name|str
argument_list|,
name|iflags
argument_list|)
operator|)
condition|)
block|{
name|regerror
argument_list|(
name|error
argument_list|,
name|h
operator|->
name|r
argument_list|,
name|errbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuff
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
argument_list|(
name|errbuff
argument_list|,
name|pattern
argument_list|)
operator|)
return|;
block|}
name|h
operator|->
name|compflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|iflags
operator|&
name|REG_NOSUB
condition|)
block|{
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|h
operator|->
name|nmatch
operator|=
name|h
operator|->
name|r
operator|->
name|re_nsub
operator|+
literal|1
expr_stmt|;
name|h
operator|->
name|m
operator|=
operator|(
name|regmatch_t
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|h
operator|->
name|nmatch
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|regerror_l (LISP code,LISP ptr)
name|regerror_l
parameter_list|(
name|LISP
name|code
parameter_list|,
name|LISP
name|ptr
parameter_list|)
block|{
name|char
name|errbuff
index|[
literal|1024
index|]
decl_stmt|;
name|regerror
argument_list|(
name|get_c_long
argument_list|(
name|code
argument_list|)
argument_list|,
name|get_tc_regex
argument_list|(
name|ptr
argument_list|)
operator|->
name|r
argument_list|,
name|errbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuff
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|strlen
argument_list|(
name|errbuff
argument_list|)
argument_list|,
name|errbuff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|regexec_l (LISP ptr,LISP str,LISP eflags)
name|regexec_l
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|LISP
name|str
parameter_list|,
name|LISP
name|eflags
parameter_list|)
block|{
name|size_t
name|j
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LISP
name|result
decl_stmt|;
name|struct
name|tc_regex
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|get_tc_regex
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|regexec
argument_list|(
name|h
operator|->
name|r
argument_list|,
name|get_c_string
argument_list|(
name|str
argument_list|)
argument_list|,
name|h
operator|->
name|nmatch
argument_list|,
name|h
operator|->
name|m
argument_list|,
name|NNULLP
argument_list|(
name|eflags
argument_list|)
condition|?
name|get_c_long
argument_list|(
name|eflags
argument_list|)
else|:
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|flocons
argument_list|(
name|error
argument_list|)
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|result
operator|=
name|NIL
init|;
name|j
operator|<
name|h
operator|->
name|nmatch
condition|;
operator|++
name|j
control|)
name|result
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
name|flocons
argument_list|(
name|h
operator|->
name|m
index|[
name|j
index|]
operator|.
name|rm_so
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|h
operator|->
name|m
index|[
name|j
index|]
operator|.
name|rm_eo
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreverse
argument_list|(
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|regex_gc_free (LISP ptr)
name|regex_gc_free
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|struct
name|tc_regex
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
operator|(
expr|struct
name|tc_regex
operator|*
operator|)
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|compflag
operator|)
operator|&&
name|h
operator|->
name|r
condition|)
name|regfree
argument_list|(
name|h
operator|->
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|r
condition|)
block|{
name|free
argument_list|(
name|h
operator|->
name|r
argument_list|)
expr_stmt|;
name|h
operator|->
name|r
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|m
condition|)
block|{
name|free
argument_list|(
name|h
operator|->
name|m
argument_list|)
expr_stmt|;
name|h
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|regex_prin1 (LISP ptr,struct gen_printio * f)
name|regex_prin1
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|regex_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|get_tc_regex
argument_list|(
name|ptr
argument_list|)
operator|->
name|r
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"#<REGEX %p nsub=%d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|re_nsub
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_regex (void)
name|init_regex
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
name|tc_regex
operator|=
name|allocate_user_tc
argument_list|()
expr_stmt|;
name|set_gc_hooks
argument_list|(
name|tc_regex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|regex_gc_free
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|set_print_hooks
argument_list|(
name|tc_regex
argument_list|,
name|regex_prin1
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"regcomp"
argument_list|,
name|regcomp_l
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"regerror"
argument_list|,
name|regerror_l
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"regexec"
argument_list|,
name|regexec_l
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_EXTENDED"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_EXTENDED
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ICASE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ICASE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_NOSUB"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_NOSUB
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_NEWLINE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_NEWLINE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_NOTBOL"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_NOTBOL
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_NOTEOL"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_NOTEOL
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_NOMATCH"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_NOMATCH
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_BADPAT"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_BADPAT
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ECOLLATE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ECOLLATE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ECTYPE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ECTYPE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_EESCAPE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_EESCAPE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ESUBREG"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ESUBREG
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_EBRACK"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_EBRACK
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_EPAREN"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_EPAREN
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_EBRACE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_EBRACE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_BADBR"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_BADBR
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ERANGE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ERANGE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ESPACE"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ESPACE
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_BADRPT"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_BADRPT
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_ECHAR
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"REG_ECHAR"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|REG_ECHAR
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_regex_version
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

