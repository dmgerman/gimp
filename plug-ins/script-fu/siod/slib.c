begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Scheme In One Defun, but in C this time.   *                      COPYRIGHT (c) 1988-1994 BY                          *  *        PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS.       *  *                         ALL RIGHTS RESERVED                              *   Permission to use, copy, modify, distribute and sell this software  and its documentation for any purpose and without fee is hereby  granted, provided that the above copyright notice appear in all copies  and that both that copyright notice and this permission notice appear  in supporting documentation, and that the name of Paradigm Associates  Inc not be used in advertising or publicity pertaining to distribution  of the software without specific, written prior permission.   PARADIGM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL  PARADIGM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR  ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  SOFTWARE.   */
end_comment

begin_comment
comment|/*     gjc@world.std.com     Paradigm Associates Inc          Phone: 617-492-6079    29 Putnam Ave, Suite 6    Cambridge, MA 02138      Release 1.0: 24-APR-88    Release 1.1: 25-APR-88, added: macros, predicates, load. With additions by    Barak.Pearlmutter@DOGHEN.BOLTZ.CS.CMU.EDU: Full flonum recognizer,    cleaned up uses of NULL/0. Now distributed with siod.scm.    Release 1.2: 28-APR-88, name changes as requested by JAR@AI.AI.MIT.EDU,    plus some bug fixes.    Release 1.3: 1-MAY-88, changed env to use frames instead of alist.    define now works properly. vms specific function edit.    Release 1.4 20-NOV-89. Minor Cleanup and remodularization.    Now in 3 files, siod.h, slib.c, siod.c. Makes it easier to write your    own main loops. Some short-int changes for lightspeed C included.    Release 1.5 29-NOV-89. Added startup flag -g, select stop and copy    or mark-and-sweep garbage collection, which assumes that the stack/register    marking code is correct for your architecture.    Release 2.0 1-DEC-89. Added repl_hooks, Catch, Throw. This is significantly    different enough (from 1.3) now that I'm calling it a major release.    Release 2.1 4-DEC-89. Small reader features, dot, backquote, comma.    Release 2.2 5-DEC-89. gc,read,print,eval, hooks for user defined datatypes.    Release 2.3 6-DEC-89. save_forms, obarray intern mechanism. comment char.    Release 2.3a......... minor speed-ups. i/o interrupt considerations.    Release 2.4 27-APR-90 gen_readr, for read-from-string.    Release 2.5 18-SEP-90 arrays added to SIOD.C by popular demand. inums.    Release 2.6 11-MAR-92 function prototypes, some remodularization.    Release 2.7 20-MAR-92 hash tables, fasload. Stack check.    Release 2.8  3-APR-92 Bug fixes, \n syntax in string reading.    Release 2.9 28-AUG-92 gc sweep bug fix. fseek, ftell, etc. Change to    envlookup to allow (a . rest) suggested by bowles@is.s.u-tokyo.ac.jp.    Release 2.9a 10-AUG-93. Minor changes for Windows NT.    Release 3.0  1-MAY-94. Release it, include changes/cleanup recommended by    andreasg@nynexst.com for the OS2 C++ compiler. Compilation and running    tested using DEC C, VAX C. WINDOWS NT. GNU C on SPARC. Storage    management improvements, more string functions. SQL support.    Release 3.1? -JUN-95 verbose flag, other integration improvements for htqs.c    hpux by denson@sdd.hp.com, solaris by pgw9@columbia.edu.    Release 3.2X MAR-96. dynamic linking, subr closures, other improvements.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TIMES_H
end_if

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_define
DECL|macro|STRICT
define|#
directive|define
name|STRICT
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"siod.h"
end_include

begin_include
include|#
directive|include
file|"siodp.h"
end_include

begin_define
DECL|macro|MAX_ERROR
define|#
directive|define
name|MAX_ERROR
value|1024
end_define

begin_decl_stmt
DECL|variable|siod_err_msg
name|char
name|siod_err_msg
index|[
name|MAX_ERROR
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|init_slib_version (void)
name|init_slib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*slib-version*"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"$Id$"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|siod_version (void)
name|siod_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"3.2x 12-MAR-96"
operator|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|nheaps
name|long
name|nheaps
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|heaps
name|LISP
modifier|*
name|heaps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|heap
DECL|variable|heap_end
DECL|variable|heap_org
name|LISP
name|heap
decl_stmt|,
name|heap_end
decl_stmt|,
name|heap_org
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|heap_size
name|long
name|heap_size
init|=
literal|5000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|old_heap_used
name|long
name|old_heap_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gc_status_flag
name|long
name|gc_status_flag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|init_file
name|char
modifier|*
name|init_file
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|tkbuffer
name|char
modifier|*
name|tkbuffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gc_kind_copying
name|long
name|gc_kind_copying
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gc_cells_allocated
name|long
name|gc_cells_allocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gc_time_taken
name|double
name|gc_time_taken
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|stack_start_ptr
name|LISP
modifier|*
name|stack_start_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|freelist
name|LISP
name|freelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|errjmp
name|jmp_buf
name|errjmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|errjmp_ok
name|long
name|errjmp_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|nointerrupt
name|long
name|nointerrupt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|interrupt_differed
name|long
name|interrupt_differed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|oblistvar
name|LISP
name|oblistvar
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_t
name|LISP
name|sym_t
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|eof_val
name|LISP
name|eof_val
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_errobj
name|LISP
name|sym_errobj
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_catchall
name|LISP
name|sym_catchall
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_progn
name|LISP
name|sym_progn
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_lambda
name|LISP
name|sym_lambda
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_quote
name|LISP
name|sym_quote
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_dot
name|LISP
name|sym_dot
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_after_gc
name|LISP
name|sym_after_gc
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_eval_history_ptr
name|LISP
name|sym_eval_history_ptr
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|unbound_marker
name|LISP
name|unbound_marker
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|obarray
name|LISP
modifier|*
name|obarray
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|repl_return_val
name|LISP
name|repl_return_val
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|obarray_dim
name|long
name|obarray_dim
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|catch_framep
name|struct
name|catch_frame
modifier|*
name|catch_framep
init|=
operator|(
expr|struct
name|catch_frame
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
DECL|variable|repl_puts
name|void
function_decl|(
modifier|*
name|repl_puts
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|repl_read
name|LISP
function_decl|(
modifier|*
name|repl_read
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|repl_eval
name|LISP
function_decl|(
modifier|*
name|repl_eval
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|repl_print
name|void
function_decl|(
modifier|*
name|repl_print
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|inums
name|LISP
modifier|*
name|inums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|inums_dim
name|long
name|inums_dim
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|user_types
name|struct
name|user_type_hooks
modifier|*
name|user_types
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|user_tc_next
name|long
name|user_tc_next
init|=
name|tc_user_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|protected_registers
name|struct
name|gc_protected
modifier|*
name|protected_registers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|save_regs_gc_mark
name|jmp_buf
name|save_regs_gc_mark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gc_rt
name|double
name|gc_rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gc_cells_collected
name|long
name|gc_cells_collected
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|user_ch_readm
name|char
modifier|*
name|user_ch_readm
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|user_te_readm
name|char
modifier|*
name|user_te_readm
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function_decl
DECL|variable|user_readm
name|LISP
function_decl|(
modifier|*
name|user_readm
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|gen_readio
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|user_readt
name|LISP
function_decl|(
modifier|*
name|user_readt
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|fatal_exit_hook
name|void
function_decl|(
modifier|*
name|fatal_exit_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|THINK_C
end_ifdef

begin_decl_stmt
DECL|variable|ipoll_counter
name|int
name|ipoll_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
DECL|variable|stack_limit_ptr
name|char
modifier|*
name|stack_limit_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|stack_size
name|long
name|stack_size
init|=
ifdef|#
directive|ifdef
name|THINK_C
literal|10000
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|50000
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
DECL|variable|siod_verbose_level
name|long
name|siod_verbose_level
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SIOD_LIB_DEFAULT
end_ifndef

begin_define
DECL|macro|SIOD_LIB_DEFAULT
define|#
directive|define
name|SIOD_LIB_DEFAULT
value|"/usr/local/lib/siod"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Added by Spencer Kimball for script-fu shit 6/3/97 */
end_comment

begin_decl_stmt
DECL|variable|siod_output
name|FILE
modifier|*
name|siod_output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|siod_lib
name|char
modifier|*
name|siod_lib
init|=
name|SIOD_LIB_DEFAULT
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|process_cla (int argc,char ** argv,int warnflag)
name|process_cla
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|warnflag
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|int
name|siod_lib_set
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|vms
argument_list|)
if|if
condition|(
operator|!
name|siod_lib_set
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"SIOD_LIB"
argument_list|)
condition|)
block|{
name|siod_lib
operator|=
name|getenv
argument_list|(
literal|"SIOD_LIB"
argument_list|)
expr_stmt|;
name|siod_lib_set
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|argc
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|k
index|]
argument_list|)
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|argv
index|[
name|k
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|warnflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad arg: %s\n"
argument_list|,
name|argv
index|[
name|k
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|argv
index|[
name|k
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'l'
case|:
name|siod_lib
operator|=
operator|&
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|heap_size
operator|=
name|atol
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|nheaps
operator|=
name|atol
argument_list|(
operator|&
name|ptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|obarray_dim
operator|=
name|atol
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|init_file
operator|=
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|inums_dim
operator|=
name|atol
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|gc_kind_copying
operator|=
name|atol
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|stack_size
operator|=
name|atol
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|siod_verbose_level
operator|=
name|atol
argument_list|(
operator|&
operator|(
name|argv
index|[
name|k
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|warnflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad arg: %s\n"
argument_list|,
name|argv
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|print_welcome (void)
name|print_welcome
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"Welcome to SIOD, Scheme In One Defun, Version %s\n"
argument_list|,
name|siod_version
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"(C) Copyright 1988-1994 Paradigm Associates Inc. Help: (help)\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|siod_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|print_hs_1 (void)
name|print_hs_1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"%ld heaps. size = %ld cells, %ld bytes. %ld inums. GC is %s\n"
argument_list|,
name|nheaps
argument_list|,
name|heap_size
argument_list|,
name|heap_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
argument_list|,
name|inums_dim
argument_list|,
operator|(
name|gc_kind_copying
operator|==
literal|1
operator|)
condition|?
literal|"stop and copy"
else|:
literal|"mark and sweep"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|siod_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|print_hs_2 (void)
name|print_hs_2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|gc_kind_copying
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"heaps[0] at %p, heaps[1] at %p\n"
argument_list|,
name|heaps
index|[
literal|0
index|]
argument_list|,
name|heaps
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"heaps[0] at %p\n"
argument_list|,
name|heaps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|siod_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|long
DECL|function|no_interrupt (long n)
name|no_interrupt
parameter_list|(
name|long
name|n
parameter_list|)
block|{
name|long
name|x
decl_stmt|;
name|x
operator|=
name|nointerrupt
expr_stmt|;
name|nointerrupt
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|nointerrupt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|interrupt_differed
operator|==
literal|1
operator|)
condition|)
block|{
name|interrupt_differed
operator|=
literal|0
expr_stmt|;
name|err_ctrl_c
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|handle_sigfpe (int sig SIG_restargs)
name|handle_sigfpe
parameter_list|(
name|int
name|sig
name|SIG_restargs
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|handle_sigfpe
argument_list|)
expr_stmt|;
name|my_err
argument_list|(
literal|"floating point exception"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|handle_sigint (int sig SIG_restargs)
name|handle_sigint
parameter_list|(
name|int
name|sig
name|SIG_restargs
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_sigint
argument_list|)
expr_stmt|;
if|if
condition|(
name|nointerrupt
operator|==
literal|1
condition|)
name|interrupt_differed
operator|=
literal|1
expr_stmt|;
else|else
name|err_ctrl_c
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|err_ctrl_c (void)
name|err_ctrl_c
parameter_list|(
name|void
parameter_list|)
block|{
name|my_err
argument_list|(
literal|"control-c interrupt"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|get_eof_val (void)
name|get_eof_val
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|eof_val
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|repl_driver (long want_sigint,long want_init,struct repl_hooks * h)
name|repl_driver
parameter_list|(
name|long
name|want_sigint
parameter_list|,
name|long
name|want_init
parameter_list|,
name|struct
name|repl_hooks
modifier|*
name|h
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|struct
name|repl_hooks
name|hd
decl_stmt|;
name|LISP
name|stack_start
decl_stmt|;
name|stack_start_ptr
operator|=
operator|&
name|stack_start
expr_stmt|;
name|stack_limit_ptr
operator|=
name|STACK_LIMIT
argument_list|(
name|stack_start_ptr
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
name|k
operator|=
name|setjmp
argument_list|(
name|errjmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|2
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|want_sigint
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_sigint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|handle_sigfpe
argument_list|)
expr_stmt|;
name|catch_framep
operator|=
operator|(
expr|struct
name|catch_frame
operator|*
operator|)
name|NULL
expr_stmt|;
name|errjmp_ok
operator|=
literal|1
expr_stmt|;
name|interrupt_differed
operator|=
literal|0
expr_stmt|;
name|nointerrupt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|want_init
operator|&&
name|init_file
operator|&&
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
name|vload
argument_list|(
name|init_file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|hd
operator|.
name|repl_puts
operator|=
name|repl_puts
expr_stmt|;
name|hd
operator|.
name|repl_read
operator|=
name|repl_read
expr_stmt|;
name|hd
operator|.
name|repl_eval
operator|=
name|repl_eval
expr_stmt|;
name|hd
operator|.
name|repl_print
operator|=
name|repl_print
expr_stmt|;
return|return
operator|(
name|repl
argument_list|(
operator|&
name|hd
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|repl
argument_list|(
name|h
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ignore_puts (char * st)
name|ignore_puts
parameter_list|(
name|char
modifier|*
name|st
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
DECL|function|noprompt_puts (char * st)
name|noprompt_puts
parameter_list|(
name|char
modifier|*
name|st
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|st
argument_list|,
literal|"> "
argument_list|)
operator|!=
literal|0
condition|)
name|put_st
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|repl_c_string_arg
specifier|static
name|char
modifier|*
name|repl_c_string_arg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|repl_c_string_flag
specifier|static
name|long
name|repl_c_string_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|LISP
DECL|function|repl_c_string_read (void)
name|repl_c_string_read
parameter_list|(
name|void
parameter_list|)
block|{
name|LISP
name|s
decl_stmt|;
if|if
condition|(
name|repl_c_string_arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|get_eof_val
argument_list|()
operator|)
return|;
name|s
operator|=
name|strcons
argument_list|(
name|strlen
argument_list|(
name|repl_c_string_arg
argument_list|)
argument_list|,
name|repl_c_string_arg
argument_list|)
expr_stmt|;
name|repl_c_string_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|read_from_string
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ignore_print (LISP x)
name|ignore_print
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|repl_c_string_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|not_ignore_print (LISP x)
name|not_ignore_print
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|repl_c_string_flag
operator|=
literal|1
expr_stmt|;
name|lprint
argument_list|(
name|x
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
DECL|function|repl_c_string (char * str,long want_sigint,long want_init,long want_print)
name|repl_c_string
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|long
name|want_sigint
parameter_list|,
name|long
name|want_init
parameter_list|,
name|long
name|want_print
parameter_list|)
block|{
name|struct
name|repl_hooks
name|h
decl_stmt|;
name|long
name|retval
decl_stmt|;
if|if
condition|(
name|want_print
condition|)
name|h
operator|.
name|repl_puts
operator|=
name|noprompt_puts
expr_stmt|;
else|else
name|h
operator|.
name|repl_puts
operator|=
name|ignore_puts
expr_stmt|;
name|h
operator|.
name|repl_read
operator|=
name|repl_c_string_read
expr_stmt|;
name|h
operator|.
name|repl_eval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|want_print
condition|)
name|h
operator|.
name|repl_print
operator|=
name|not_ignore_print
expr_stmt|;
else|else
name|h
operator|.
name|repl_print
operator|=
name|ignore_print
expr_stmt|;
name|repl_c_string_arg
operator|=
name|str
expr_stmt|;
name|repl_c_string_flag
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|repl_driver
argument_list|(
name|want_sigint
argument_list|,
name|want_init
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
elseif|else
if|if
condition|(
name|repl_c_string_flag
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|double
DECL|function|myruntime (void)
name|myruntime
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|HAVE_SYS_TIMES_H
name|double
name|total
decl_stmt|;
name|struct
name|tms
name|b
decl_stmt|;
name|times
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|total
operator|=
name|b
operator|.
name|tms_utime
expr_stmt|;
name|total
operator|+=
name|b
operator|.
name|tms_stime
expr_stmt|;
return|return
operator|(
name|total
operator|/
literal|60.0
operator|)
return|;
elif|#
directive|elif
name|G_OS_WIN32
name|FILETIME
name|creation
decl_stmt|,
name|exit
decl_stmt|,
name|kernel
decl_stmt|,
name|user
decl_stmt|;
name|GetProcessTimes
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|creation
argument_list|,
operator|&
name|exit
argument_list|,
operator|&
name|kernel
argument_list|,
operator|&
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
name|kernel
operator|.
name|dwLowDateTime
operator|*
literal|1e7
operator|+
name|user
operator|.
name|dwLowDateTime
operator|*
literal|1e7
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/timers.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TIMEOFDAY
end_ifndef

begin_define
DECL|macro|TIMEOFDAY
define|#
directive|define
name|TIMEOFDAY
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
DECL|function|myrealtime (void)
name|myrealtime
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|.
name|tv_sec
operator|+
operator|(
operator|(
operator|(
name|double
operator|)
name|x
operator|.
name|tv_nsec
operator|)
operator|*
literal|1.0e-9
operator|)
operator|)
return|;
else|else
return|return
operator|(
literal|0.0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_include
include|#
directive|include
file|<starlet.h>
end_include

begin_function
name|double
DECL|function|myrealtime (void)
name|myrealtime
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|x
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|double
name|c
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
name|sys$gettim
argument_list|(
operator|&
name|x
argument_list|)
operator|==
name|SS$_NORMAL
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0.0
condition|)
name|c
operator|=
name|pow
argument_list|(
operator|(
name|double
operator|)
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|31
argument_list|)
operator|*
literal|100.0e-9
expr_stmt|;
return|return
operator|(
name|x
index|[
literal|0
index|]
operator|*
literal|100.0e-9
operator|+
name|x
index|[
literal|1
index|]
operator|*
name|c
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0.0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_function
name|double
DECL|function|myrealtime (void)
name|myrealtime
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|x
decl_stmt|;
name|time
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|double
operator|)
name|x
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
DECL|function|set_repl_hooks (void (* puts_f)(char *),LISP (* read_f)(void),LISP (* eval_f)(LISP),void (* print_f)(LISP))
name|set_repl_hooks
parameter_list|(
name|void
function_decl|(
modifier|*
name|puts_f
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|read_f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|eval_f
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|print_f
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|)
block|{
name|repl_puts
operator|=
name|puts_f
expr_stmt|;
name|repl_read
operator|=
name|read_f
expr_stmt|;
name|repl_eval
operator|=
name|eval_f
expr_stmt|;
name|repl_print
operator|=
name|print_f
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gput_st (struct gen_printio * f,char * st)
name|gput_st
parameter_list|(
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|st
parameter_list|)
block|{
name|PUTS_FCN
argument_list|(
name|st
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|fput_st (FILE * f,char * st)
name|fput_st
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|st
parameter_list|)
block|{
name|long
name|flag
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|siod_output
argument_list|)
expr_stmt|;
block|}
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|fputs_fcn (char * st,void * cb)
name|fputs_fcn
parameter_list|(
name|char
modifier|*
name|st
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|fput_st
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|cb
argument_list|,
name|st
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|put_st (char * st)
name|put_st
parameter_list|(
name|char
modifier|*
name|st
parameter_list|)
block|{
name|fput_st
argument_list|(
name|siod_output
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|siod_output
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|grepl_puts (char * st,void (* repl_puts)(char *))
name|grepl_puts
parameter_list|(
name|char
modifier|*
name|st
parameter_list|,
name|void
function_decl|(
modifier|*
name|repl_puts
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|repl_puts
operator|==
name|NULL
condition|)
name|put_st
argument_list|(
name|st
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|repl_puts
call|)
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
DECL|function|repl (struct repl_hooks * h)
name|repl
parameter_list|(
name|struct
name|repl_hooks
modifier|*
name|h
parameter_list|)
block|{
name|LISP
name|x
decl_stmt|,
name|cw
init|=
literal|0
decl_stmt|;
name|double
name|rt
decl_stmt|,
name|ct
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|gc_kind_copying
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|gc_status_flag
operator|)
operator|||
name|heap
operator|>=
name|heap_end
operator|)
condition|)
block|{
name|rt
operator|=
name|myruntime
argument_list|()
expr_stmt|;
name|gc_stop_and_copy
argument_list|()
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"GC took %g seconds, %ld compressed to %d, %d free\n"
argument_list|,
name|myruntime
argument_list|()
operator|-
name|rt
argument_list|,
name|old_heap_used
argument_list|,
name|heap
operator|-
name|heap_org
argument_list|,
name|heap_end
operator|-
name|heap
argument_list|)
expr_stmt|;
name|grepl_puts
argument_list|(
name|tkbuffer
argument_list|,
name|h
operator|->
name|repl_puts
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|2
condition|)
name|grepl_puts
argument_list|(
literal|"> "
argument_list|,
name|h
operator|->
name|repl_puts
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|repl_read
operator|==
name|NULL
condition|)
name|x
operator|=
name|lread
argument_list|(
name|NIL
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
call|(
modifier|*
name|h
operator|->
name|repl_read
call|)
argument_list|()
expr_stmt|;
if|if EQ
condition|(
name|x
operator|,
name|eof_val
condition|)
break|break;
name|rt
operator|=
name|myruntime
argument_list|()
expr_stmt|;
name|ct
operator|=
name|myrealtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|gc_kind_copying
operator|==
literal|1
condition|)
name|cw
operator|=
name|heap
expr_stmt|;
else|else
block|{
name|gc_cells_allocated
operator|=
literal|0
expr_stmt|;
name|gc_time_taken
operator|=
literal|0.0
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|repl_eval
operator|==
name|NULL
condition|)
name|repl_return_val
operator|=
name|x
operator|=
name|leval
argument_list|(
name|x
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
else|else
name|repl_return_val
operator|=
name|x
operator|=
call|(
modifier|*
name|h
operator|->
name|repl_eval
call|)
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|gc_kind_copying
operator|==
literal|1
condition|)
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"Evaluation took %g seconds %d cons work, %g real.\n"
argument_list|,
name|myruntime
argument_list|()
operator|-
name|rt
argument_list|,
name|heap
operator|-
name|cw
argument_list|,
name|myrealtime
argument_list|()
operator|-
name|ct
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"Evaluation took %g seconds (%g in gc) %ld cons work, %g real.\n"
argument_list|,
name|myruntime
argument_list|()
operator|-
name|rt
argument_list|,
name|gc_time_taken
argument_list|,
name|gc_cells_allocated
argument_list|,
name|myrealtime
argument_list|()
operator|-
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
name|grepl_puts
argument_list|(
name|tkbuffer
argument_list|,
name|h
operator|->
name|repl_puts
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|repl_print
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|2
condition|)
name|lprint
argument_list|(
name|x
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|h
operator|->
name|repl_print
call|)
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|set_fatal_exit_hook (void (* fcn)(void))
name|set_fatal_exit_hook
parameter_list|(
name|void
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|fatal_exit_hook
operator|=
name|fcn
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|inside_err
specifier|static
name|long
name|inside_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|LISP
DECL|function|my_err (char * message,LISP x)
name|my_err
parameter_list|(
name|char
modifier|*
name|message
parameter_list|,
name|LISP
name|x
parameter_list|)
block|{
name|struct
name|catch_frame
modifier|*
name|l
decl_stmt|;
name|long
name|was_inside
init|=
name|inside_err
decl_stmt|;
name|LISP
name|retval
decl_stmt|,
name|nx
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eobj
decl_stmt|;
name|nointerrupt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|message
operator|)
operator|&&
name|CONSP
argument_list|(
name|x
argument_list|)
operator|&&
name|TYPEP
argument_list|(
name|CAR
argument_list|(
name|x
argument_list|)
argument_list|,
name|tc_string
argument_list|)
condition|)
block|{
name|msg
operator|=
name|get_c_string
argument_list|(
name|CAR
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|nx
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|retval
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|message
expr_stmt|;
name|nx
operator|=
name|x
expr_stmt|;
name|retval
operator|=
name|NIL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eobj
operator|=
name|try_get_c_string
argument_list|(
name|nx
argument_list|)
operator|)
operator|&&
operator|!
name|memchr
argument_list|(
name|eobj
argument_list|,
literal|0
argument_list|,
literal|30
argument_list|)
condition|)
name|eobj
operator|=
name|NULL
expr_stmt|;
if|if NULLP
condition|(
name|nx
condition|)
name|sprintf
argument_list|(
name|siod_err_msg
argument_list|,
literal|"ERROR: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eobj
condition|)
name|sprintf
argument_list|(
name|siod_err_msg
argument_list|,
literal|"ERROR: %s (errobj %s)\n"
argument_list|,
name|msg
argument_list|,
name|eobj
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|siod_err_msg
argument_list|,
literal|"ERROR: %s (see errobj)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|siod_verbose_level
operator|>=
literal|1
operator|)
operator|&&
name|msg
condition|)
block|{
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"%s\n"
argument_list|,
name|siod_err_msg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|siod_output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errjmp_ok
operator|==
literal|1
condition|)
block|{
name|inside_err
operator|=
literal|1
expr_stmt|;
name|setvar
argument_list|(
name|sym_errobj
argument_list|,
name|nx
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|catch_framep
init|;
name|l
condition|;
name|l
operator|=
operator|(
operator|*
name|l
operator|)
operator|.
name|next
control|)
if|if
condition|(
name|EQ
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|.
name|tag
argument_list|,
name|sym_errobj
argument_list|)
operator|||
name|EQ
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|.
name|tag
argument_list|,
name|sym_catchall
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|msg
condition|)
name|msg
operator|=
literal|"quit"
expr_stmt|;
operator|(
operator|*
name|l
operator|)
operator|.
name|retval
operator|=
operator|(
name|NNULLP
argument_list|(
name|retval
argument_list|)
condition|?
name|retval
else|:
operator|(
name|was_inside
operator|)
condition|?
name|NIL
else|:
name|cons
argument_list|(
name|strcons
argument_list|(
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|,
name|msg
argument_list|)
argument_list|,
name|nx
argument_list|)
operator|)
expr_stmt|;
name|nointerrupt
operator|=
literal|0
expr_stmt|;
name|inside_err
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|.
name|cframe
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|inside_err
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|errjmp
argument_list|,
operator|(
name|msg
operator|)
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FATAL ERROR DURING STARTUP OR CRITICAL CODE SECTION\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fatal_exit_hook
condition|)
call|(
modifier|*
name|fatal_exit_hook
call|)
argument_list|()
expr_stmt|;
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|errswitch (void)
name|errswitch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|my_err
argument_list|(
literal|"BUG. Reached impossible case"
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|err_stack (char * ptr)
name|err_stack
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
comment|/* The user could be given an option to continue here */
block|{
name|my_err
argument_list|(
literal|"the currently assigned stack limit has been exceded"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|stack_limit (LISP amount,LISP silent)
name|stack_limit
parameter_list|(
name|LISP
name|amount
parameter_list|,
name|LISP
name|silent
parameter_list|)
block|{
if|if NNULLP
condition|(
name|amount
condition|)
block|{
name|stack_size
operator|=
name|get_c_long
argument_list|(
name|amount
argument_list|)
expr_stmt|;
name|stack_limit_ptr
operator|=
name|STACK_LIMIT
argument_list|(
name|stack_start_ptr
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
block|}
if|if NULLP
condition|(
name|silent
condition|)
block|{
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"Stack_size = %ld bytes, [%p,%p]\n"
argument_list|,
name|stack_size
argument_list|,
name|stack_start_ptr
argument_list|,
name|stack_limit_ptr
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|tkbuffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
else|else
return|return
operator|(
name|flocons
argument_list|(
name|stack_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|try_get_c_string (LISP x)
name|try_get_c_string
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if TYPEP
condition|(
name|x
operator|,
name|tc_symbol
condition|)
return|return
operator|(
name|PNAME
argument_list|(
name|x
argument_list|)
operator|)
return|;
elseif|else
if|if TYPEP
condition|(
name|x
operator|,
name|tc_string
condition|)
return|return
operator|(
name|x
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|get_c_string (LISP x)
name|get_c_string
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if TYPEP
condition|(
name|x
operator|,
name|tc_symbol
condition|)
return|return
operator|(
name|PNAME
argument_list|(
name|x
argument_list|)
operator|)
return|;
elseif|else
if|if TYPEP
condition|(
name|x
operator|,
name|tc_string
condition|)
return|return
operator|(
name|x
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|)
return|;
else|else
name|my_err
argument_list|(
literal|"not a symbol or string"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|get_c_string_dim (LISP x,long * len)
name|get_c_string_dim
parameter_list|(
name|LISP
name|x
parameter_list|,
name|long
modifier|*
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|tc_symbol
case|:
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|PNAME
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PNAME
argument_list|(
name|x
argument_list|)
operator|)
return|;
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
operator|*
name|len
operator|=
name|x
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
expr_stmt|;
return|return
operator|(
name|x
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|)
return|;
case|case
name|tc_long_array
case|:
operator|*
name|len
operator|=
name|x
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|x
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
operator|)
return|;
default|default:
name|my_err
argument_list|(
literal|"not a symbol or string"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lerr (LISP message,LISP x)
name|lerr
parameter_list|(
name|LISP
name|message
parameter_list|,
name|LISP
name|x
parameter_list|)
block|{
if|if
condition|(
name|CONSP
argument_list|(
name|message
argument_list|)
operator|&&
name|TYPEP
argument_list|(
name|CAR
argument_list|(
name|message
argument_list|)
argument_list|,
name|tc_string
argument_list|)
condition|)
name|my_err
argument_list|(
name|NULL
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|my_err
argument_list|(
name|get_c_string
argument_list|(
name|message
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gc_fatal_error (void)
name|gc_fatal_error
parameter_list|(
name|void
parameter_list|)
block|{
name|my_err
argument_list|(
literal|"ran out of storage"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|newcell (long type)
name|newcell
parameter_list|(
name|long
name|type
parameter_list|)
block|{
name|LISP
name|z
decl_stmt|;
name|NEWCELL
argument_list|(
name|z
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cons (LISP x,LISP y)
name|cons
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
name|LISP
name|z
decl_stmt|;
name|NEWCELL
argument_list|(
name|z
argument_list|,
name|tc_cons
argument_list|)
expr_stmt|;
name|CAR
argument_list|(
name|z
argument_list|)
operator|=
name|x
expr_stmt|;
name|CDR
argument_list|(
name|z
argument_list|)
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|consp (LISP x)
name|consp
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if CONSP
condition|(
name|x
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|car (LISP x)
name|car
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
switch|switch TYPE
condition|(
name|x
condition|)
block|{
case|case
name|tc_nil
case|:
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_cons
case|:
return|return
operator|(
name|CAR
argument_list|(
name|x
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|my_err
argument_list|(
literal|"wta to car"
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|cdr (LISP x)
name|cdr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
switch|switch TYPE
condition|(
name|x
condition|)
block|{
case|case
name|tc_nil
case|:
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_cons
case|:
return|return
operator|(
name|CDR
argument_list|(
name|x
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|my_err
argument_list|(
literal|"wta to cdr"
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|setcar (LISP cell,LISP value)
name|setcar
parameter_list|(
name|LISP
name|cell
parameter_list|,
name|LISP
name|value
parameter_list|)
block|{
if|if NCONSP
condition|(
name|cell
condition|)
name|my_err
argument_list|(
literal|"wta to setcar"
argument_list|,
name|cell
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAR
argument_list|(
name|cell
argument_list|)
operator|=
name|value
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|setcdr (LISP cell,LISP value)
name|setcdr
parameter_list|(
name|LISP
name|cell
parameter_list|,
name|LISP
name|value
parameter_list|)
block|{
if|if NCONSP
condition|(
name|cell
condition|)
name|my_err
argument_list|(
literal|"wta to setcdr"
argument_list|,
name|cell
argument_list|)
expr_stmt|;
return|return
operator|(
name|CDR
argument_list|(
name|cell
argument_list|)
operator|=
name|value
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|flocons (double x)
name|flocons
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|LISP
name|z
decl_stmt|;
name|long
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|inums_dim
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|x
operator|-
operator|(
name|n
operator|=
operator|(
name|long
operator|)
name|x
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|n
operator|<
name|inums_dim
operator|)
condition|)
return|return
operator|(
name|inums
index|[
name|n
index|]
operator|)
return|;
name|NEWCELL
argument_list|(
name|z
argument_list|,
name|tc_flonum
argument_list|)
expr_stmt|;
name|FLONM
argument_list|(
name|z
argument_list|)
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|numberp (LISP x)
name|numberp
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if FLONUMP
condition|(
name|x
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|plus (LISP x,LISP y)
name|plus
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NULLP
condition|(
name|y
condition|)
return|return
operator|(
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|flocons
argument_list|(
literal|0
argument_list|)
else|:
name|x
operator|)
return|;
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to plus"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to plus"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|+
name|FLONM
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ltimes (LISP x,LISP y)
name|ltimes
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NULLP
condition|(
name|y
condition|)
return|return
operator|(
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|flocons
argument_list|(
literal|1
argument_list|)
else|:
name|x
operator|)
return|;
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to times"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to times"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|*
name|FLONM
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|difference (LISP x,LISP y)
name|difference
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to difference"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|y
condition|)
return|return
operator|(
name|flocons
argument_list|(
operator|-
name|FLONM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
else|else
block|{
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to difference"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|-
name|FLONM
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|Quotient (LISP x,LISP y)
name|Quotient
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to quotient"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|y
condition|)
return|return
operator|(
name|flocons
argument_list|(
literal|1
operator|/
name|FLONM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
else|else
block|{
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to quotient"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|/
name|FLONM
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lllabs (LISP x)
name|lllabs
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|double
name|v
decl_stmt|;
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta to abs"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|v
operator|=
name|FLONM
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
literal|0
condition|)
return|return
operator|(
name|flocons
argument_list|(
operator|-
name|v
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lsqrt (LISP x)
name|lsqrt
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta to sqrt"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|sqrt
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|greaterp (LISP x,LISP y)
name|greaterp
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to greaterp"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to greaterp"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|>
name|FLONM
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lessp (LISP x,LISP y)
name|lessp
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to lessp"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to lessp"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|<
name|FLONM
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|greaterEp (LISP x,LISP y)
name|greaterEp
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to greaterp"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to greaterp"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|>=
name|FLONM
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lessEp (LISP x,LISP y)
name|lessEp
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to lessp"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to lessp"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|<=
name|FLONM
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lmax (LISP x,LISP y)
name|lmax
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NULLP
condition|(
name|y
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to max"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to max"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|>
name|FLONM
argument_list|(
name|y
argument_list|)
operator|)
condition|?
name|x
else|:
name|y
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lmin (LISP x,LISP y)
name|lmin
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NULLP
condition|(
name|y
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if NFLONUMP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"wta(1st) to min"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|my_err
argument_list|(
literal|"wta(2nd) to min"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|<
name|FLONM
argument_list|(
name|y
argument_list|)
operator|)
condition|?
name|x
else|:
name|y
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|eq (LISP x,LISP y)
name|eq
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if EQ
condition|(
name|x
operator|,
name|y
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|eql (LISP x,LISP y)
name|eql
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if EQ
condition|(
name|x
operator|,
name|y
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
elseif|else
if|if NFLONUMP
condition|(
name|x
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
elseif|else
if|if NFLONUMP
condition|(
name|y
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
elseif|else
if|if
condition|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|==
name|FLONM
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|symcons (char * pname,LISP vcell)
name|symcons
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|,
name|LISP
name|vcell
parameter_list|)
block|{
name|LISP
name|z
decl_stmt|;
name|NEWCELL
argument_list|(
name|z
argument_list|,
name|tc_symbol
argument_list|)
expr_stmt|;
name|PNAME
argument_list|(
name|z
argument_list|)
operator|=
name|pname
expr_stmt|;
name|VCELL
argument_list|(
name|z
argument_list|)
operator|=
name|vcell
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|symbolp (LISP x)
name|symbolp
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if SYMBOLP
condition|(
name|x
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|err_ubv (LISP v)
name|err_ubv
parameter_list|(
name|LISP
name|v
parameter_list|)
block|{
return|return
operator|(
name|my_err
argument_list|(
literal|"unbound variable"
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|symbol_boundp (LISP x,LISP env)
name|symbol_boundp
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|;
if|if NSYMBOLP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"not a symbol"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|envlookup
argument_list|(
name|x
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|tmp
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
if|if EQ
condition|(
name|VCELL
argument_list|(
name|x
argument_list|)
operator|,
name|unbound_marker
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
else|else
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|symbol_value (LISP x,LISP env)
name|symbol_value
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|;
if|if NSYMBOLP
condition|(
name|x
condition|)
name|my_err
argument_list|(
literal|"not a symbol"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|envlookup
argument_list|(
name|x
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|tmp
condition|)
return|return
operator|(
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|)
return|;
name|tmp
operator|=
name|VCELL
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|tmp
operator|,
name|unbound_marker
condition|)
name|err_ubv
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|must_malloc (unsigned long size)
name|must_malloc
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size
operator|)
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|my_err
argument_list|(
literal|"failed to allocate storage from system"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|gen_intern (char * name,long copyp)
name|gen_intern
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|long
name|copyp
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|sym
decl_stmt|,
name|sl
decl_stmt|;
name|char
modifier|*
name|cname
decl_stmt|;
name|long
name|hash
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|,
name|flag
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obarray_dim
operator|>
literal|1
condition|)
block|{
name|hash
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|obarray_dim
expr_stmt|;
name|cname
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cname
operator|++
operator|)
condition|)
name|hash
operator|=
operator|(
operator|(
name|hash
operator|*
literal|17
operator|)
operator|^
name|c
operator|)
operator|%
name|n
expr_stmt|;
name|sl
operator|=
name|obarray
index|[
name|hash
index|]
expr_stmt|;
block|}
else|else
name|sl
operator|=
name|oblistvar
expr_stmt|;
for|for
control|(
name|l
operator|=
name|sl
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|PNAME
argument_list|(
name|CAR
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAR
argument_list|(
name|l
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|copyp
operator|==
literal|1
condition|)
block|{
name|cname
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|cname
operator|=
name|name
expr_stmt|;
name|sym
operator|=
name|symcons
argument_list|(
name|cname
argument_list|,
name|unbound_marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|obarray_dim
operator|>
literal|1
condition|)
name|obarray
index|[
name|hash
index|]
operator|=
name|cons
argument_list|(
name|sym
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|oblistvar
operator|=
name|cons
argument_list|(
name|sym
argument_list|,
name|oblistvar
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cintern (char * name)
name|cintern
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|gen_intern
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|rintern (char * name)
name|rintern
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|gen_intern
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|intern (LISP name)
name|intern
parameter_list|(
name|LISP
name|name
parameter_list|)
block|{
return|return
operator|(
name|rintern
argument_list|(
name|get_c_string
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|subrcons (long type,char * name,SUBR_FUNC f)
name|subrcons
parameter_list|(
name|long
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|SUBR_FUNC
name|f
parameter_list|)
block|{
name|LISP
name|z
decl_stmt|;
name|NEWCELL
argument_list|(
name|z
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
operator|*
name|z
operator|)
operator|.
name|storage_as
operator|.
name|subr
operator|.
name|name
operator|=
name|name
expr_stmt|;
operator|(
operator|*
name|z
operator|)
operator|.
name|storage_as
operator|.
name|subr0
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|closure (LISP env,LISP code)
name|closure
parameter_list|(
name|LISP
name|env
parameter_list|,
name|LISP
name|code
parameter_list|)
block|{
name|LISP
name|z
decl_stmt|;
name|NEWCELL
argument_list|(
name|z
argument_list|,
name|tc_closure
argument_list|)
expr_stmt|;
operator|(
operator|*
name|z
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|env
operator|=
name|env
expr_stmt|;
operator|(
operator|*
name|z
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
operator|=
name|code
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gc_protect (LISP * location)
name|gc_protect
parameter_list|(
name|LISP
modifier|*
name|location
parameter_list|)
block|{
name|gc_protect_n
argument_list|(
name|location
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_protect_n (LISP * location,long n)
name|gc_protect_n
parameter_list|(
name|LISP
modifier|*
name|location
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|struct
name|gc_protected
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
expr|struct
name|gc_protected
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gc_protected
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|reg
operator|)
operator|.
name|location
operator|=
name|location
expr_stmt|;
operator|(
operator|*
name|reg
operator|)
operator|.
name|length
operator|=
name|n
expr_stmt|;
operator|(
operator|*
name|reg
operator|)
operator|.
name|next
operator|=
name|protected_registers
expr_stmt|;
name|protected_registers
operator|=
name|reg
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_protect_sym (LISP * location,char * st)
name|gc_protect_sym
parameter_list|(
name|LISP
modifier|*
name|location
parameter_list|,
name|char
modifier|*
name|st
parameter_list|)
block|{
operator|*
name|location
operator|=
name|cintern
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|gc_protect
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_unprotect (LISP * location)
name|gc_unprotect
parameter_list|(
name|LISP
modifier|*
name|location
parameter_list|)
block|{
name|struct
name|gc_protected
modifier|*
name|reg
decl_stmt|;
name|struct
name|gc_protected
modifier|*
name|prev_reg
decl_stmt|;
name|prev_reg
operator|=
name|NULL
expr_stmt|;
name|reg
operator|=
name|protected_registers
expr_stmt|;
while|while
condition|(
name|reg
condition|)
block|{
if|if
condition|(
name|location
operator|==
name|reg
operator|->
name|location
condition|)
block|{
if|if
condition|(
name|prev_reg
condition|)
name|prev_reg
operator|->
name|next
operator|=
name|reg
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|protected_registers
condition|)
name|protected_registers
operator|=
name|protected_registers
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev_reg
operator|=
name|reg
expr_stmt|;
name|reg
operator|=
name|reg
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|scan_registers (void)
name|scan_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gc_protected
modifier|*
name|reg
decl_stmt|;
name|LISP
modifier|*
name|location
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|protected_registers
init|;
name|reg
condition|;
name|reg
operator|=
operator|(
operator|*
name|reg
operator|)
operator|.
name|next
control|)
block|{
name|location
operator|=
operator|(
operator|*
name|reg
operator|)
operator|.
name|location
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|reg
operator|)
operator|.
name|length
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|location
index|[
name|j
index|]
operator|=
name|gc_relocate
argument_list|(
name|location
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|init_storage (void)
name|init_storage
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
name|LISP
name|stack_start
decl_stmt|;
if|if
condition|(
name|stack_start_ptr
operator|==
name|NULL
condition|)
name|stack_start_ptr
operator|=
operator|&
name|stack_start
expr_stmt|;
name|init_storage_1
argument_list|()
expr_stmt|;
name|init_storage_a
argument_list|()
expr_stmt|;
name|set_gc_hooks
argument_list|(
name|tc_c_file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file_gc_free
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|set_print_hooks
argument_list|(
name|tc_c_file
argument_list|,
name|file_prin1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_storage_1 (void)
name|init_storage_1
parameter_list|(
name|void
parameter_list|)
block|{
name|LISP
name|ptr
decl_stmt|;
name|long
name|j
decl_stmt|;
name|tkbuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|TKBUFFERN
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|gc_kind_copying
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nheaps
operator|!=
literal|2
operator|)
operator|)
operator|||
operator|(
name|nheaps
operator|<
literal|1
operator|)
condition|)
name|my_err
argument_list|(
literal|"invalid number of heaps"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|heaps
operator|=
operator|(
name|LISP
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LISP
argument_list|)
operator|*
name|nheaps
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nheaps
condition|;
operator|++
name|j
control|)
name|heaps
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|heaps
index|[
literal|0
index|]
operator|=
operator|(
name|LISP
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
operator|*
name|heap_size
argument_list|)
expr_stmt|;
name|heap
operator|=
name|heaps
index|[
literal|0
index|]
expr_stmt|;
name|heap_org
operator|=
name|heap
expr_stmt|;
name|heap_end
operator|=
name|heap
operator|+
name|heap_size
expr_stmt|;
if|if
condition|(
name|gc_kind_copying
operator|==
literal|1
condition|)
name|heaps
index|[
literal|1
index|]
operator|=
operator|(
name|LISP
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
operator|*
name|heap_size
argument_list|)
expr_stmt|;
else|else
name|freelist
operator|=
name|NIL
expr_stmt|;
name|gc_protect
argument_list|(
operator|&
name|oblistvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|obarray_dim
operator|>
literal|1
condition|)
block|{
name|obarray
operator|=
operator|(
name|LISP
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LISP
argument_list|)
operator|*
name|obarray_dim
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|obarray_dim
condition|;
operator|++
name|j
control|)
name|obarray
index|[
name|j
index|]
operator|=
name|NIL
expr_stmt|;
name|gc_protect_n
argument_list|(
name|obarray
argument_list|,
name|obarray_dim
argument_list|)
expr_stmt|;
block|}
name|unbound_marker
operator|=
name|cons
argument_list|(
name|cintern
argument_list|(
literal|"**unbound-marker**"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|gc_protect
argument_list|(
operator|&
name|unbound_marker
argument_list|)
expr_stmt|;
name|eof_val
operator|=
name|cons
argument_list|(
name|cintern
argument_list|(
literal|"eof"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|gc_protect
argument_list|(
operator|&
name|eof_val
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_t
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym_t
argument_list|,
name|sym_t
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"nil"
argument_list|)
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"let"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"let-internal-macro"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"let*"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"let*-macro"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"letrec"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"letrec-macro"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_errobj
argument_list|,
literal|"errobj"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym_errobj
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_catchall
argument_list|,
literal|"all"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_progn
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_lambda
argument_list|,
literal|"lambda"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_quote
argument_list|,
literal|"quote"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_dot
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_after_gc
argument_list|,
literal|"*after-gc*"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym_after_gc
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_eval_history_ptr
argument_list|,
literal|"*eval-history-ptr*"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym_eval_history_ptr
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inums_dim
operator|>
literal|0
condition|)
block|{
name|inums
operator|=
operator|(
name|LISP
operator|*
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LISP
argument_list|)
operator|*
name|inums_dim
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|inums_dim
condition|;
operator|++
name|j
control|)
block|{
name|NEWCELL
argument_list|(
name|ptr
argument_list|,
name|tc_flonum
argument_list|)
expr_stmt|;
name|FLONM
argument_list|(
name|ptr
argument_list|)
operator|=
name|j
expr_stmt|;
name|inums
index|[
name|j
index|]
operator|=
name|ptr
expr_stmt|;
block|}
name|gc_protect_n
argument_list|(
name|inums
argument_list|,
name|inums_dim
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|init_subr (char * name,long type,SUBR_FUNC fcn)
name|init_subr
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|long
name|type
parameter_list|,
name|SUBR_FUNC
name|fcn
parameter_list|)
block|{
name|setvar
argument_list|(
name|cintern
argument_list|(
name|name
argument_list|)
argument_list|,
name|subrcons
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|fcn
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_0 (char * name,LISP (* fcn)(void))
name|init_subr_0
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_0
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_1 (char * name,LISP (* fcn)(LISP))
name|init_subr_1
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_1
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_2 (char * name,LISP (* fcn)(LISP,LISP))
name|init_subr_2
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_2
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_2n (char * name,LISP (* fcn)(LISP,LISP))
name|init_subr_2n
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_2n
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_3 (char * name,LISP (* fcn)(LISP,LISP,LISP))
name|init_subr_3
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
parameter_list|,
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_3
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_4 (char * name,LISP (* fcn)(LISP,LISP,LISP,LISP))
name|init_subr_4
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
parameter_list|,
name|LISP
parameter_list|,
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_4
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_subr_5 (char * name,LISP (* fcn)(LISP,LISP,LISP,LISP,LISP))
name|init_subr_5
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
parameter_list|,
name|LISP
parameter_list|,
name|LISP
parameter_list|,
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_subr_5
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_lsubr (char * name,LISP (* fcn)(LISP))
name|init_lsubr
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_lsubr
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_fsubr (char * name,LISP (* fcn)(LISP,LISP))
name|init_fsubr
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_fsubr
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_msubr (char * name,LISP (* fcn)(LISP *,LISP *))
name|init_msubr
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
modifier|*
parameter_list|,
name|LISP
modifier|*
parameter_list|)
parameter_list|)
block|{
name|init_subr
argument_list|(
name|name
argument_list|,
name|tc_msubr
argument_list|,
operator|(
name|SUBR_FUNC
operator|)
name|fcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|assq (LISP x,LISP alist)
name|assq
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|alist
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|alist
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSP
argument_list|(
name|tmp
argument_list|)
operator|&&
name|EQ
argument_list|(
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|my_err
argument_list|(
literal|"improper list to assq"
argument_list|,
name|alist
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|user_type_hooks
modifier|*
DECL|function|get_user_type_hooks (long type)
name|get_user_type_hooks
parameter_list|(
name|long
name|type
parameter_list|)
block|{
name|long
name|n
decl_stmt|;
if|if
condition|(
name|user_types
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|user_type_hooks
argument_list|)
operator|*
name|tc_table_dim
expr_stmt|;
name|user_types
operator|=
operator|(
expr|struct
name|user_type_hooks
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|user_types
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|type
operator|<
name|tc_table_dim
operator|)
condition|)
return|return
operator|(
operator|&
name|user_types
index|[
name|type
index|]
operator|)
return|;
else|else
name|my_err
argument_list|(
literal|"type number out of range"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|allocate_user_tc (void)
name|allocate_user_tc
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|x
init|=
name|user_tc_next
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|tc_user_max
condition|)
name|my_err
argument_list|(
literal|"ran out of user type codes"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
operator|++
name|user_tc_next
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|set_gc_hooks (long type,LISP (* rel)(LISP),LISP (* mark)(LISP),void (* scan)(LISP),void (* free)(LISP),long * kind)
name|set_gc_hooks
parameter_list|(
name|long
name|type
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|rel
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|mark
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|scan
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|free
function_decl|)
parameter_list|(
name|LISP
parameter_list|)
parameter_list|,
name|long
modifier|*
name|kind
parameter_list|)
block|{
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|gc_relocate
operator|=
name|rel
expr_stmt|;
name|p
operator|->
name|gc_scan
operator|=
name|scan
expr_stmt|;
name|p
operator|->
name|gc_mark
operator|=
name|mark
expr_stmt|;
name|p
operator|->
name|gc_free
operator|=
name|free
expr_stmt|;
operator|*
name|kind
operator|=
name|gc_kind_copying
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|gc_relocate (LISP x)
name|gc_relocate
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|LISP
name|nw
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
if|if EQ
condition|(
name|x
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|x
operator|)
operator|.
name|gc_mark
operator|==
literal|1
condition|)
return|return
operator|(
name|CAR
argument_list|(
name|x
argument_list|)
operator|)
return|;
switch|switch TYPE
condition|(
name|x
condition|)
block|{
case|case
name|tc_flonum
case|:
case|case
name|tc_cons
case|:
case|case
name|tc_symbol
case|:
case|case
name|tc_closure
case|:
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
if|if
condition|(
operator|(
name|nw
operator|=
name|heap
operator|)
operator|>=
name|heap_end
condition|)
name|gc_fatal_error
argument_list|()
expr_stmt|;
name|heap
operator|=
name|nw
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|nw
argument_list|,
name|x
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|gc_relocate
condition|)
name|nw
operator|=
call|(
modifier|*
name|p
operator|->
name|gc_relocate
call|)
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|nw
operator|=
name|heap
operator|)
operator|>=
name|heap_end
condition|)
name|gc_fatal_error
argument_list|()
expr_stmt|;
name|heap
operator|=
name|nw
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|nw
argument_list|,
name|x
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|x
operator|)
operator|.
name|gc_mark
operator|=
literal|1
expr_stmt|;
name|CAR
argument_list|(
name|x
argument_list|)
operator|=
name|nw
expr_stmt|;
return|return
operator|(
name|nw
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|get_newspace (void)
name|get_newspace
parameter_list|(
name|void
parameter_list|)
block|{
name|LISP
name|newspace
decl_stmt|;
if|if
condition|(
name|heap_org
operator|==
name|heaps
index|[
literal|0
index|]
condition|)
name|newspace
operator|=
name|heaps
index|[
literal|1
index|]
expr_stmt|;
else|else
name|newspace
operator|=
name|heaps
index|[
literal|0
index|]
expr_stmt|;
name|heap
operator|=
name|newspace
expr_stmt|;
name|heap_org
operator|=
name|heap
expr_stmt|;
name|heap_end
operator|=
name|heap
operator|+
name|heap_size
expr_stmt|;
return|return
operator|(
name|newspace
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|scan_newspace (LISP newspace)
name|scan_newspace
parameter_list|(
name|LISP
name|newspace
parameter_list|)
block|{
name|LISP
name|ptr
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|newspace
init|;
name|ptr
operator|<
name|heap
condition|;
operator|++
name|ptr
control|)
block|{
switch|switch TYPE
condition|(
name|ptr
condition|)
block|{
case|case
name|tc_cons
case|:
case|case
name|tc_closure
case|:
name|CAR
argument_list|(
name|ptr
argument_list|)
operator|=
name|gc_relocate
argument_list|(
name|CAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|gc_relocate
argument_list|(
name|CDR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_symbol
case|:
name|VCELL
argument_list|(
name|ptr
argument_list|)
operator|=
name|gc_relocate
argument_list|(
name|VCELL
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_flonum
case|:
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
break|break;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|gc_scan
condition|)
call|(
modifier|*
name|p
operator|->
name|gc_scan
call|)
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|free_oldspace (LISP space,LISP end)
name|free_oldspace
parameter_list|(
name|LISP
name|space
parameter_list|,
name|LISP
name|end
parameter_list|)
block|{
name|LISP
name|ptr
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|space
init|;
name|ptr
operator|<
name|end
condition|;
operator|++
name|ptr
control|)
if|if
condition|(
name|ptr
operator|->
name|gc_mark
operator|==
literal|0
condition|)
switch|switch TYPE
condition|(
name|ptr
condition|)
block|{
case|case
name|tc_cons
case|:
case|case
name|tc_closure
case|:
case|case
name|tc_symbol
case|:
case|case
name|tc_flonum
case|:
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
break|break;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|gc_free
condition|)
call|(
modifier|*
name|p
operator|->
name|gc_free
call|)
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gc_stop_and_copy (void)
name|gc_stop_and_copy
parameter_list|(
name|void
parameter_list|)
block|{
name|LISP
name|newspace
decl_stmt|,
name|oldspace
decl_stmt|,
name|end
decl_stmt|;
name|long
name|flag
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errjmp_ok
operator|=
literal|0
expr_stmt|;
name|oldspace
operator|=
name|heap_org
expr_stmt|;
name|end
operator|=
name|heap
expr_stmt|;
name|old_heap_used
operator|=
name|end
operator|-
name|oldspace
expr_stmt|;
name|newspace
operator|=
name|get_newspace
argument_list|()
expr_stmt|;
name|scan_registers
argument_list|()
expr_stmt|;
name|scan_newspace
argument_list|(
name|newspace
argument_list|)
expr_stmt|;
name|free_oldspace
argument_list|(
name|oldspace
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|errjmp_ok
operator|=
literal|1
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|allocate_aheap (void)
name|allocate_aheap
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|flag
decl_stmt|;
name|LISP
name|ptr
decl_stmt|,
name|end
decl_stmt|,
name|next
decl_stmt|;
name|gc_kind_check
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nheaps
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|!
name|heaps
index|[
name|j
index|]
condition|)
block|{
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gc_status_flag
operator|&&
operator|(
name|siod_verbose_level
operator|>=
literal|4
operator|)
condition|)
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"[allocating heap %ld]\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|heaps
index|[
name|j
index|]
operator|=
operator|(
name|LISP
operator|)
name|must_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
operator|*
name|heap_size
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|heaps
index|[
name|j
index|]
expr_stmt|;
name|end
operator|=
name|heaps
index|[
name|j
index|]
operator|+
name|heap_size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|(
operator|*
name|ptr
operator|)
operator|.
name|type
operator|=
name|tc_free_cell
expr_stmt|;
name|next
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|next
operator|<
name|end
condition|)
block|{
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|next
expr_stmt|;
name|ptr
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|freelist
expr_stmt|;
break|break;
block|}
block|}
name|freelist
operator|=
name|heaps
index|[
name|j
index|]
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|gc_for_newcell (void)
name|gc_for_newcell
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|flag
decl_stmt|,
name|n
decl_stmt|;
name|LISP
name|l
decl_stmt|;
if|if
condition|(
name|heap
operator|<
name|heap_end
condition|)
block|{
name|freelist
operator|=
name|heap
expr_stmt|;
name|CDR
argument_list|(
name|freelist
argument_list|)
operator|=
name|NIL
expr_stmt|;
operator|++
name|heap
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errjmp_ok
operator|==
literal|0
condition|)
name|gc_fatal_error
argument_list|()
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errjmp_ok
operator|=
literal|0
expr_stmt|;
name|gc_mark_and_sweep
argument_list|()
expr_stmt|;
name|errjmp_ok
operator|=
literal|1
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|l
operator|=
name|freelist
init|;
operator|(
name|n
operator|<
literal|100
operator|)
operator|&&
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
operator|++
name|n
control|)
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if NULLP
condition|(
name|allocate_aheap
argument_list|()
condition|)
name|gc_fatal_error
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|n
operator|==
literal|100
operator|)
operator|&&
name|NNULLP
argument_list|(
name|sym_after_gc
argument_list|)
condition|)
name|leval
argument_list|(
name|leval
argument_list|(
name|sym_after_gc
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
else|else
name|allocate_aheap
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_mark_and_sweep (void)
name|gc_mark_and_sweep
parameter_list|(
name|void
parameter_list|)
block|{
name|LISP
name|stack_end
decl_stmt|;
name|gc_ms_stats_start
argument_list|()
expr_stmt|;
while|while
condition|(
name|heap
operator|<
name|heap_end
condition|)
block|{
name|heap
operator|->
name|type
operator|=
name|tc_free_cell
expr_stmt|;
name|heap
operator|->
name|gc_mark
operator|=
literal|0
expr_stmt|;
operator|++
name|heap
expr_stmt|;
block|}
name|setjmp
argument_list|(
name|save_regs_gc_mark
argument_list|)
expr_stmt|;
name|mark_locations
argument_list|(
operator|(
name|LISP
operator|*
operator|)
name|save_regs_gc_mark
argument_list|,
operator|(
name|LISP
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|save_regs_gc_mark
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|save_regs_gc_mark
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mark_protected_registers
argument_list|()
expr_stmt|;
name|mark_locations
argument_list|(
operator|(
name|LISP
operator|*
operator|)
name|stack_start_ptr
argument_list|,
operator|(
name|LISP
operator|*
operator|)
operator|&
name|stack_end
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THINK_C
name|mark_locations
argument_list|(
operator|(
name|LISP
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|stack_start_ptr
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|LISP
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|stack_end
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gc_sweep
argument_list|()
expr_stmt|;
name|gc_ms_stats_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_ms_stats_start (void)
name|gc_ms_stats_start
parameter_list|(
name|void
parameter_list|)
block|{
name|gc_rt
operator|=
name|myruntime
argument_list|()
expr_stmt|;
name|gc_cells_collected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gc_status_flag
operator|&&
operator|(
name|siod_verbose_level
operator|>=
literal|4
operator|)
condition|)
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"[starting GC]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_ms_stats_end (void)
name|gc_ms_stats_end
parameter_list|(
name|void
parameter_list|)
block|{
name|gc_rt
operator|=
name|myruntime
argument_list|()
operator|-
name|gc_rt
expr_stmt|;
name|gc_time_taken
operator|=
name|gc_time_taken
operator|+
name|gc_rt
expr_stmt|;
if|if
condition|(
name|gc_status_flag
operator|&&
operator|(
name|siod_verbose_level
operator|>=
literal|4
operator|)
condition|)
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"[GC took %g cpu seconds, %ld cells collected]\n"
argument_list|,
name|gc_rt
argument_list|,
name|gc_cells_collected
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_mark (LISP ptr)
name|gc_mark
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|gc_mark_loop
label|:
if|if NULLP
condition|(
name|ptr
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|.
name|gc_mark
condition|)
return|return;
operator|(
operator|*
name|ptr
operator|)
operator|.
name|gc_mark
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|.
name|type
condition|)
block|{
case|case
name|tc_flonum
case|:
break|break;
case|case
name|tc_cons
case|:
name|gc_mark
argument_list|(
name|CAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|CDR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
goto|goto
name|gc_mark_loop
goto|;
case|case
name|tc_symbol
case|:
name|ptr
operator|=
name|VCELL
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
goto|goto
name|gc_mark_loop
goto|;
case|case
name|tc_closure
case|:
name|gc_mark
argument_list|(
operator|(
operator|*
name|ptr
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|*
name|ptr
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|env
expr_stmt|;
goto|goto
name|gc_mark_loop
goto|;
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
break|break;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|gc_mark
condition|)
name|ptr
operator|=
call|(
modifier|*
name|p
operator|->
name|gc_mark
call|)
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|mark_protected_registers (void)
name|mark_protected_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gc_protected
modifier|*
name|reg
decl_stmt|;
name|LISP
modifier|*
name|location
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|protected_registers
init|;
name|reg
condition|;
name|reg
operator|=
operator|(
operator|*
name|reg
operator|)
operator|.
name|next
control|)
block|{
name|location
operator|=
operator|(
operator|*
name|reg
operator|)
operator|.
name|location
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|reg
operator|)
operator|.
name|length
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|gc_mark
argument_list|(
name|location
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|mark_locations (LISP * start,LISP * end)
name|mark_locations
parameter_list|(
name|LISP
modifier|*
name|start
parameter_list|,
name|LISP
modifier|*
name|end
parameter_list|)
block|{
name|LISP
modifier|*
name|tmp
decl_stmt|;
name|long
name|n
decl_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
name|tmp
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|tmp
expr_stmt|;
block|}
name|n
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|mark_locations_array
argument_list|(
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
DECL|function|looks_pointerp (LISP p)
name|looks_pointerp
parameter_list|(
name|LISP
name|p
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
name|LISP
name|h
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nheaps
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|(
name|h
operator|=
name|heaps
index|[
name|j
index|]
operator|)
operator|&&
operator|(
name|p
operator|>=
name|h
operator|)
operator|&&
operator|(
name|p
operator|<
operator|(
name|h
operator|+
name|heap_size
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|)
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
name|NTYPEP
argument_list|(
name|p
argument_list|,
name|tc_free_cell
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|mark_locations_array (LISP * x,long n)
name|mark_locations_array
parameter_list|(
name|LISP
modifier|*
name|x
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|LISP
name|p
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
block|{
name|p
operator|=
name|x
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|looks_pointerp
argument_list|(
name|p
argument_list|)
condition|)
name|gc_mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|gc_sweep (void)
name|gc_sweep
parameter_list|(
name|void
parameter_list|)
block|{
name|LISP
name|ptr
decl_stmt|,
name|end
decl_stmt|,
name|nfreelist
decl_stmt|,
name|org
decl_stmt|;
name|long
name|n
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|end
operator|=
name|heap_end
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|nfreelist
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nheaps
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|heaps
index|[
name|k
index|]
condition|)
block|{
name|org
operator|=
name|heaps
index|[
name|k
index|]
expr_stmt|;
name|end
operator|=
name|org
operator|+
name|heap_size
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|org
init|;
name|ptr
operator|<
name|end
condition|;
operator|++
name|ptr
control|)
if|if
condition|(
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|.
name|gc_mark
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|.
name|type
condition|)
block|{
case|case
name|tc_free_cell
case|:
case|case
name|tc_cons
case|:
case|case
name|tc_closure
case|:
case|case
name|tc_symbol
case|:
case|case
name|tc_flonum
case|:
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
break|break;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|gc_free
condition|)
call|(
modifier|*
name|p
operator|->
name|gc_free
call|)
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|.
name|type
operator|=
name|tc_free_cell
expr_stmt|;
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|nfreelist
expr_stmt|;
name|nfreelist
operator|=
name|ptr
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|ptr
operator|)
operator|.
name|gc_mark
operator|=
literal|0
expr_stmt|;
block|}
name|gc_cells_collected
operator|=
name|n
expr_stmt|;
name|freelist
operator|=
name|nfreelist
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|gc_kind_check (void)
name|gc_kind_check
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|gc_kind_copying
operator|==
literal|1
condition|)
name|my_err
argument_list|(
literal|"cannot perform operation with stop-and-copy GC mode. Use -g0\n"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|user_gc (LISP args)
name|user_gc
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
name|long
name|old_status_flag
decl_stmt|,
name|flag
decl_stmt|;
name|gc_kind_check
argument_list|()
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errjmp_ok
operator|=
literal|0
expr_stmt|;
name|old_status_flag
operator|=
name|gc_status_flag
expr_stmt|;
if|if NNULLP
condition|(
name|args
condition|)
block|{
if|if NULLP
condition|(
name|car
argument_list|(
name|args
argument_list|)
condition|)
name|gc_status_flag
operator|=
literal|0
expr_stmt|;
else|else
name|gc_status_flag
operator|=
literal|1
expr_stmt|;
block|}
name|gc_mark_and_sweep
argument_list|()
expr_stmt|;
name|gc_status_flag
operator|=
name|old_status_flag
expr_stmt|;
name|errjmp_ok
operator|=
literal|1
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|nactive_heaps (void)
name|nactive_heaps
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
operator|(
name|m
operator|<
name|nheaps
operator|)
operator|&&
name|heaps
index|[
name|m
index|]
condition|;
operator|++
name|m
control|)
empty_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|freelist_length (void)
name|freelist_length
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|n
decl_stmt|;
name|LISP
name|l
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|l
operator|=
name|freelist
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
operator|++
name|n
control|)
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|n
operator|+=
operator|(
name|heap_end
operator|-
name|heap
operator|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|gc_status (LISP args)
name|gc_status
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
name|long
name|n
decl_stmt|,
name|m
decl_stmt|;
if|if NNULLP
condition|(
name|args
condition|)
block|{
if|if NULLP
condition|(
name|car
argument_list|(
name|args
argument_list|)
condition|)
name|gc_status_flag
operator|=
literal|0
expr_stmt|;
else|else
name|gc_status_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gc_kind_copying
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|gc_status_flag
condition|)
name|put_st
argument_list|(
literal|"garbage collection is on\n"
argument_list|)
expr_stmt|;
else|else
name|put_st
argument_list|(
literal|"garbage collection is off\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%d allocated %d free\n"
argument_list|,
name|heap
operator|-
name|heap_org
argument_list|,
name|heap_end
operator|-
name|heap
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|tkbuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gc_status_flag
condition|)
name|put_st
argument_list|(
literal|"garbage collection verbose\n"
argument_list|)
expr_stmt|;
else|else
name|put_st
argument_list|(
literal|"garbage collection silent\n"
argument_list|)
expr_stmt|;
block|{
name|m
operator|=
name|nactive_heaps
argument_list|()
expr_stmt|;
name|n
operator|=
name|freelist_length
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%ld/%ld heaps, %ld allocated %ld free\n"
argument_list|,
name|m
argument_list|,
name|nheaps
argument_list|,
name|m
operator|*
name|heap_size
operator|-
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|tkbuffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|gc_info (LISP arg)
name|gc_info
parameter_list|(
name|LISP
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|get_c_long
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
operator|(
name|gc_kind_copying
operator|==
literal|1
operator|)
condition|?
name|sym_t
else|:
name|NIL
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|flocons
argument_list|(
name|nactive_heaps
argument_list|()
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|flocons
argument_list|(
name|nheaps
argument_list|)
operator|)
return|;
case|case
literal|3
case|:
return|return
operator|(
name|flocons
argument_list|(
name|heap_size
argument_list|)
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|flocons
argument_list|(
operator|(
name|gc_kind_copying
operator|==
literal|1
operator|)
condition|?
call|(
name|long
call|)
argument_list|(
name|heap_end
operator|-
name|heap
argument_list|)
else|:
name|freelist_length
argument_list|()
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|NIL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|leval_args (LISP l,LISP env)
name|leval_args
parameter_list|(
name|LISP
name|l
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|result
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|tmp
decl_stmt|;
if|if NULLP
condition|(
name|l
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if NCONSP
condition|(
name|l
condition|)
name|my_err
argument_list|(
literal|"bad syntax argument list"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|result
operator|=
name|cons
argument_list|(
name|leval
argument_list|(
name|CAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
for|for
control|(
name|v1
operator|=
name|result
operator|,
name|v2
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
init|;
name|CONSP
argument_list|(
name|v2
argument_list|)
condition|;
name|v1
operator|=
name|tmp
operator|,
name|v2
operator|=
name|CDR
argument_list|(
name|v2
argument_list|)
control|)
block|{
name|tmp
operator|=
name|cons
argument_list|(
name|leval
argument_list|(
name|CAR
argument_list|(
name|v2
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|CDR
argument_list|(
name|v1
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
if|if NNULLP
condition|(
name|v2
condition|)
name|my_err
argument_list|(
literal|"bad syntax argument list"
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|extend_env (LISP actuals,LISP formals,LISP env)
name|extend_env
parameter_list|(
name|LISP
name|actuals
parameter_list|,
name|LISP
name|formals
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
if|if SYMBOLP
condition|(
name|formals
condition|)
return|return
operator|(
name|cons
argument_list|(
name|cons
argument_list|(
name|cons
argument_list|(
name|formals
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|cons
argument_list|(
name|actuals
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
operator|)
return|;
return|return
operator|(
name|cons
argument_list|(
name|cons
argument_list|(
name|formals
argument_list|,
name|actuals
argument_list|)
argument_list|,
name|env
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|ENVLOOKUP_TRICK
define|#
directive|define
name|ENVLOOKUP_TRICK
value|1
end_define

begin_function
name|LISP
DECL|function|envlookup (LISP var,LISP env)
name|envlookup
parameter_list|(
name|LISP
name|var
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|frame
decl_stmt|,
name|al
decl_stmt|,
name|fl
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|frame
operator|=
name|env
init|;
name|CONSP
argument_list|(
name|frame
argument_list|)
condition|;
name|frame
operator|=
name|CDR
argument_list|(
name|frame
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if NCONSP
condition|(
name|tmp
condition|)
name|my_err
argument_list|(
literal|"damaged frame"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|fl
operator|=
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|,
name|al
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
init|;
name|CONSP
argument_list|(
name|fl
argument_list|)
condition|;
name|fl
operator|=
name|CDR
argument_list|(
name|fl
argument_list|)
operator|,
name|al
operator|=
name|CDR
argument_list|(
name|al
argument_list|)
control|)
block|{
if|if NCONSP
condition|(
name|al
condition|)
name|my_err
argument_list|(
literal|"too few arguments"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|CAR
argument_list|(
name|fl
argument_list|)
operator|,
name|var
condition|)
return|return
operator|(
name|al
operator|)
return|;
block|}
comment|/* suggested by a user. It works for reference (although conses)          but doesn't allow for set! to work properly... */
if|#
directive|if
operator|(
name|ENVLOOKUP_TRICK
operator|)
if|if
condition|(
name|SYMBOLP
argument_list|(
name|fl
argument_list|)
operator|&&
name|EQ
argument_list|(
name|fl
argument_list|,
name|var
argument_list|)
condition|)
return|return
operator|(
name|cons
argument_list|(
name|al
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
if|if NNULLP
condition|(
name|frame
condition|)
name|my_err
argument_list|(
literal|"damaged env"
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|set_eval_hooks (long type,LISP (* fcn)(LISP,LISP *,LISP *))
name|set_eval_hooks
parameter_list|(
name|long
name|type
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|LISP
modifier|*
parameter_list|,
name|LISP
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|leval
operator|=
name|fcn
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|err_closure_code (LISP tmp)
name|err_closure_code
parameter_list|(
name|LISP
name|tmp
parameter_list|)
block|{
return|return
operator|(
name|my_err
argument_list|(
literal|"closure code type not valid"
argument_list|,
name|tmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval (LISP x,LISP env)
name|leval
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|,
name|arg1
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|loop
label|:
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|VCELL
argument_list|(
name|sym_eval_history_ptr
argument_list|)
expr_stmt|;
if|if TYPEP
condition|(
name|tmp
operator|,
name|tc_cons
condition|)
block|{
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|=
name|x
expr_stmt|;
name|VCELL
argument_list|(
name|sym_eval_history_ptr
argument_list|)
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
switch|switch TYPE
condition|(
name|x
condition|)
block|{
case|case
name|tc_symbol
case|:
name|tmp
operator|=
name|envlookup
argument_list|(
name|x
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|tmp
condition|)
return|return
operator|(
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|)
return|;
name|tmp
operator|=
name|VCELL
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|tmp
operator|,
name|unbound_marker
condition|)
name|err_ubv
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
case|case
name|tc_cons
case|:
name|tmp
operator|=
name|CAR
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch TYPE
condition|(
name|tmp
condition|)
block|{
case|case
name|tc_symbol
case|:
name|tmp
operator|=
name|envlookup
argument_list|(
name|tmp
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|tmp
condition|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|VCELL
argument_list|(
name|CAR
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|tmp
operator|,
name|unbound_marker
condition|)
name|err_ubv
argument_list|(
name|CAR
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_cons
case|:
name|tmp
operator|=
name|leval
argument_list|(
name|tmp
argument_list|,
name|env
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch TYPE
condition|(
name|tmp
condition|)
block|{
case|case
name|tc_subr_0
case|:
return|return
operator|(
name|SUBR0
argument_list|(
name|tmp
argument_list|)
argument_list|()
operator|)
return|;
case|case
name|tc_subr_1
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|leval
argument_list|(
name|car
argument_list|(
name|CDR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR2
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2n
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|SUBR2
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|cdr
argument_list|(
name|x
argument_list|)
init|;
name|CONSP
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
control|)
name|arg1
operator|=
name|SUBR2
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|arg1
argument_list|,
name|leval
argument_list|(
name|CAR
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|arg1
operator|)
return|;
case|case
name|tc_subr_3
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR3
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_4
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR4
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_5
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR5
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_lsubr
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|leval_args
argument_list|(
name|CDR
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_fsubr
case|:
return|return
operator|(
name|SUBR2
argument_list|(
name|tmp
argument_list|)
argument_list|(
name|CDR
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
operator|)
return|;
case|case
name|tc_msubr
case|:
if|if NULLP
condition|(
name|SUBRM
argument_list|(
name|tmp
argument_list|)
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|env
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
goto|goto
name|loop
goto|;
case|case
name|tc_closure
case|:
switch|switch TYPE
condition|(
operator|(
operator|*
name|tmp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
condition|)
block|{
case|case
name|tc_cons
case|:
name|env
operator|=
name|extend_env
argument_list|(
name|leval_args
argument_list|(
name|CDR
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|CAR
argument_list|(
operator|(
operator|*
name|tmp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
operator|(
operator|*
name|tmp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|CDR
argument_list|(
operator|(
operator|*
name|tmp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|tc_subr_1
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR2
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|arg1
argument_list|)
operator|)
return|;
case|case
name|tc_subr_3
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR3
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_4
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR4
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_5
case|:
name|x
operator|=
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|x
operator|=
name|NULLP
argument_list|(
name|x
argument_list|)
condition|?
name|NIL
else|:
name|CDR
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUBR5
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|arg1
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_lsubr
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|cons
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|leval_args
argument_list|(
name|CDR
argument_list|(
name|x
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
default|default:
name|err_closure_code
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tc_symbol
case|:
name|x
operator|=
name|cons
argument_list|(
name|tmp
argument_list|,
name|cons
argument_list|(
name|cons
argument_list|(
name|sym_quote
argument_list|,
name|cons
argument_list|(
name|x
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|leval
argument_list|(
name|x
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|leval
condition|)
block|{
if|if NULLP
condition|(
call|(
modifier|*
name|p
operator|->
name|leval
call|)
argument_list|(
name|tmp
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|env
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|else
goto|goto
name|loop
goto|;
block|}
name|my_err
argument_list|(
literal|"bad function"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
default|default:
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lapply (LISP fcn,LISP args)
name|lapply
parameter_list|(
name|LISP
name|fcn
parameter_list|,
name|LISP
name|args
parameter_list|)
block|{
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|LISP
name|acc
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|fcn
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
switch|switch TYPE
condition|(
name|fcn
condition|)
block|{
case|case
name|tc_subr_0
case|:
return|return
operator|(
name|SUBR0
argument_list|(
name|fcn
argument_list|)
argument_list|()
operator|)
return|;
case|case
name|tc_subr_1
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2
case|:
return|return
operator|(
name|SUBR2
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2n
case|:
name|acc
operator|=
name|SUBR2
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
init|;
name|CONSP
argument_list|(
name|args
argument_list|)
condition|;
name|args
operator|=
name|CDR
argument_list|(
name|args
argument_list|)
control|)
name|acc
operator|=
name|SUBR2
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|acc
argument_list|,
name|CAR
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|acc
operator|)
return|;
case|case
name|tc_subr_3
case|:
return|return
operator|(
name|SUBR3
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_4
case|:
return|return
operator|(
name|SUBR4
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_5
case|:
return|return
operator|(
name|SUBR5
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_lsubr
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|args
argument_list|)
operator|)
return|;
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
case|case
name|tc_symbol
case|:
name|my_err
argument_list|(
literal|"cannot be applied"
argument_list|,
name|fcn
argument_list|)
expr_stmt|;
case|case
name|tc_closure
case|:
switch|switch TYPE
condition|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
condition|)
block|{
case|case
name|tc_cons
case|:
return|return
operator|(
name|leval
argument_list|(
name|cdr
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|extend_env
argument_list|(
name|args
argument_list|,
name|car
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_1
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2
case|:
return|return
operator|(
name|SUBR2
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|car
argument_list|(
name|args
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_3
case|:
return|return
operator|(
name|SUBR3
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_4
case|:
return|return
operator|(
name|SUBR4
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_subr_5
case|:
return|return
operator|(
name|SUBR5
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tc_lsubr
case|:
return|return
operator|(
name|SUBR1
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|cons
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|args
argument_list|)
argument_list|)
operator|)
return|;
default|default:
name|err_closure_code
argument_list|(
name|fcn
argument_list|)
expr_stmt|;
block|}
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|fcn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|leval
condition|)
return|return
name|my_err
argument_list|(
literal|"have eval, dont know apply"
argument_list|,
name|fcn
argument_list|)
return|;
else|else
return|return
name|my_err
argument_list|(
literal|"cannot be applied"
argument_list|,
name|fcn
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|setvar (LISP var,LISP val,LISP env)
name|setvar
parameter_list|(
name|LISP
name|var
parameter_list|,
name|LISP
name|val
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|;
if|if NSYMBOLP
condition|(
name|var
condition|)
name|my_err
argument_list|(
literal|"wta(non-symbol) to setvar"
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|envlookup
argument_list|(
name|var
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|tmp
condition|)
return|return
operator|(
name|VCELL
argument_list|(
name|var
argument_list|)
operator|=
name|val
operator|)
return|;
return|return
operator|(
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|=
name|val
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_setq (LISP args,LISP env)
name|leval_setq
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
return|return
operator|(
name|setvar
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|env
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|syntax_define (LISP args)
name|syntax_define
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
if|if SYMBOLP
condition|(
name|car
argument_list|(
name|args
argument_list|)
condition|)
return|return
operator|(
name|args
operator|)
return|;
return|return
operator|(
name|syntax_define
argument_list|(
name|cons
argument_list|(
name|car
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|cons
argument_list|(
name|cons
argument_list|(
name|sym_lambda
argument_list|,
name|cons
argument_list|(
name|cdr
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_define (LISP args,LISP env)
name|leval_define
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|,
name|var
decl_stmt|,
name|val
decl_stmt|;
name|tmp
operator|=
name|syntax_define
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|var
operator|=
name|car
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if NSYMBOLP
condition|(
name|var
condition|)
name|my_err
argument_list|(
literal|"wta(non-symbol) to define"
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|val
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|envlookup
argument_list|(
name|var
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|tmp
condition|)
return|return
operator|(
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|=
name|val
operator|)
return|;
if|if NULLP
condition|(
name|env
condition|)
return|return
operator|(
name|VCELL
argument_list|(
name|var
argument_list|)
operator|=
name|val
operator|)
return|;
name|tmp
operator|=
name|car
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setcar
argument_list|(
name|tmp
argument_list|,
name|cons
argument_list|(
name|var
argument_list|,
name|car
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setcdr
argument_list|(
name|tmp
argument_list|,
name|cons
argument_list|(
name|val
argument_list|,
name|cdr
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_if (LISP * pform,LISP * penv)
name|leval_if
parameter_list|(
name|LISP
modifier|*
name|pform
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|args
decl_stmt|,
name|env
decl_stmt|;
name|args
operator|=
name|cdr
argument_list|(
operator|*
name|pform
argument_list|)
expr_stmt|;
name|env
operator|=
operator|*
name|penv
expr_stmt|;
if|if NNULLP
condition|(
name|leval
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|env
argument_list|)
condition|)
operator|*
name|pform
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|pform
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_lambda (LISP args,LISP env)
name|leval_lambda
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|body
decl_stmt|;
if|if NULLP
condition|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
name|body
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|body
operator|=
name|cons
argument_list|(
name|sym_progn
argument_list|,
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|closure
argument_list|(
name|env
argument_list|,
name|cons
argument_list|(
name|arglchk
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_progn (LISP * pform,LISP * penv)
name|leval_progn
parameter_list|(
name|LISP
modifier|*
name|pform
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|env
decl_stmt|,
name|l
decl_stmt|,
name|next
decl_stmt|;
name|env
operator|=
operator|*
name|penv
expr_stmt|;
name|l
operator|=
name|cdr
argument_list|(
operator|*
name|pform
argument_list|)
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|NNULLP
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|pform
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_or (LISP * pform,LISP * penv)
name|leval_or
parameter_list|(
name|LISP
modifier|*
name|pform
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|env
decl_stmt|,
name|l
decl_stmt|,
name|next
decl_stmt|,
name|val
decl_stmt|;
name|env
operator|=
operator|*
name|penv
expr_stmt|;
name|l
operator|=
name|cdr
argument_list|(
operator|*
name|pform
argument_list|)
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|NNULLP
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|val
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|val
condition|)
block|{
operator|*
name|pform
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|l
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|pform
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_and (LISP * pform,LISP * penv)
name|leval_and
parameter_list|(
name|LISP
modifier|*
name|pform
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|env
decl_stmt|,
name|l
decl_stmt|,
name|next
decl_stmt|;
name|env
operator|=
operator|*
name|penv
expr_stmt|;
name|l
operator|=
name|cdr
argument_list|(
operator|*
name|pform
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|l
condition|)
block|{
operator|*
name|pform
operator|=
name|sym_t
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|next
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|NNULLP
argument_list|(
name|next
argument_list|)
condition|)
block|{
if|if NULLP
condition|(
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
condition|)
block|{
operator|*
name|pform
operator|=
name|NIL
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|l
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|pform
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_catch_1 (LISP forms,LISP env)
name|leval_catch_1
parameter_list|(
name|LISP
name|forms
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|val
init|=
name|NIL
decl_stmt|;
for|for
control|(
name|l
operator|=
name|forms
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|val
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|catch_framep
operator|=
name|catch_framep
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_catch (LISP args,LISP env)
name|leval_catch
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|struct
name|catch_frame
name|frame
decl_stmt|;
name|int
name|k
decl_stmt|;
name|frame
operator|.
name|tag
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|frame
operator|.
name|next
operator|=
name|catch_framep
expr_stmt|;
name|k
operator|=
name|setjmp
argument_list|(
name|frame
operator|.
name|cframe
argument_list|)
expr_stmt|;
name|catch_framep
operator|=
operator|&
name|frame
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|2
condition|)
block|{
name|catch_framep
operator|=
name|frame
operator|.
name|next
expr_stmt|;
return|return
operator|(
name|frame
operator|.
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|leval_catch_1
argument_list|(
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|,
name|env
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lthrow (LISP tag,LISP value)
name|lthrow
parameter_list|(
name|LISP
name|tag
parameter_list|,
name|LISP
name|value
parameter_list|)
block|{
name|struct
name|catch_frame
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|catch_framep
init|;
name|l
condition|;
name|l
operator|=
operator|(
operator|*
name|l
operator|)
operator|.
name|next
control|)
if|if
condition|(
name|EQ
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|.
name|tag
argument_list|,
name|tag
argument_list|)
operator|||
name|EQ
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|.
name|tag
argument_list|,
name|sym_catchall
argument_list|)
condition|)
block|{
operator|(
operator|*
name|l
operator|)
operator|.
name|retval
operator|=
name|value
expr_stmt|;
name|longjmp
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|.
name|cframe
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|my_err
argument_list|(
literal|"no *catch found with this tag"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_let (LISP * pform,LISP * penv)
name|leval_let
parameter_list|(
name|LISP
modifier|*
name|pform
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|env
decl_stmt|,
name|l
decl_stmt|;
name|l
operator|=
name|cdr
argument_list|(
operator|*
name|pform
argument_list|)
expr_stmt|;
name|env
operator|=
operator|*
name|penv
expr_stmt|;
operator|*
name|penv
operator|=
name|extend_env
argument_list|(
name|leval_args
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|,
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
operator|*
name|pform
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|letstar_macro (LISP form)
name|letstar_macro
parameter_list|(
name|LISP
name|form
parameter_list|)
block|{
name|LISP
name|bindings
init|=
name|cadr
argument_list|(
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
name|NNULLP
argument_list|(
name|bindings
argument_list|)
operator|&&
name|NNULLP
argument_list|(
name|cdr
argument_list|(
name|bindings
argument_list|)
argument_list|)
condition|)
name|setcdr
argument_list|(
name|form
argument_list|,
name|cons
argument_list|(
name|cons
argument_list|(
name|car
argument_list|(
name|bindings
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|cons
argument_list|(
name|cons
argument_list|(
name|cintern
argument_list|(
literal|"let*"
argument_list|)
argument_list|,
name|cons
argument_list|(
name|cdr
argument_list|(
name|bindings
argument_list|)
argument_list|,
name|cddr
argument_list|(
name|form
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setcar
argument_list|(
name|form
argument_list|,
name|cintern
argument_list|(
literal|"let"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|form
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|letrec_macro (LISP form)
name|letrec_macro
parameter_list|(
name|LISP
name|form
parameter_list|)
block|{
name|LISP
name|letb
decl_stmt|,
name|setb
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|letb
operator|=
name|NIL
operator|,
name|setb
operator|=
name|cddr
argument_list|(
name|form
argument_list|)
operator|,
name|l
operator|=
name|cadr
argument_list|(
name|form
argument_list|)
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
block|{
name|letb
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
name|caar
argument_list|(
name|l
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|letb
argument_list|)
expr_stmt|;
name|setb
operator|=
name|cons
argument_list|(
name|listn
argument_list|(
literal|3
argument_list|,
name|cintern
argument_list|(
literal|"set!"
argument_list|)
argument_list|,
name|caar
argument_list|(
name|l
argument_list|)
argument_list|,
name|cadar
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|setb
argument_list|)
expr_stmt|;
block|}
name|setcdr
argument_list|(
name|form
argument_list|,
name|cons
argument_list|(
name|letb
argument_list|,
name|setb
argument_list|)
argument_list|)
expr_stmt|;
name|setcar
argument_list|(
name|form
argument_list|,
name|cintern
argument_list|(
literal|"let"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|form
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|reverse (LISP l)
name|reverse
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
name|LISP
name|n
decl_stmt|,
name|p
decl_stmt|;
name|n
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|l
init|;
name|NNULLP
argument_list|(
name|p
argument_list|)
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
name|n
operator|=
name|cons
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|let_macro (LISP form)
name|let_macro
parameter_list|(
name|LISP
name|form
parameter_list|)
block|{
name|LISP
name|p
decl_stmt|,
name|fl
decl_stmt|,
name|al
decl_stmt|,
name|tmp
decl_stmt|;
name|fl
operator|=
name|NIL
expr_stmt|;
name|al
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|form
argument_list|)
argument_list|)
init|;
name|NNULLP
argument_list|(
name|p
argument_list|)
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tmp
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if SYMBOLP
condition|(
name|tmp
condition|)
block|{
name|fl
operator|=
name|cons
argument_list|(
name|tmp
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|al
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fl
operator|=
name|cons
argument_list|(
name|car
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|al
operator|=
name|cons
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|cdr
argument_list|(
name|cdr
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|cons
argument_list|(
name|sym_progn
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setcdr
argument_list|(
name|form
argument_list|,
name|cons
argument_list|(
name|reverse
argument_list|(
name|fl
argument_list|)
argument_list|,
name|cons
argument_list|(
name|reverse
argument_list|(
name|al
argument_list|)
argument_list|,
name|cons
argument_list|(
name|p
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setcar
argument_list|(
name|form
argument_list|,
name|cintern
argument_list|(
literal|"let-internal"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|form
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_quote (LISP args,LISP env)
name|leval_quote
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_tenv (LISP args,LISP env)
name|leval_tenv
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
return|return
operator|(
name|env
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_while (LISP args,LISP env)
name|leval_while
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
while|while NNULLP
condition|(
name|leval
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|env
argument_list|)
condition|)
for|for
control|(
name|l
operator|=
name|cdr
argument_list|(
name|args
argument_list|)
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|symbolconc (LISP args)
name|symbolconc
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
name|long
name|size
decl_stmt|;
name|LISP
name|l
decl_stmt|,
name|s
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|tkbuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|args
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
block|{
name|s
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if NSYMBOLP
condition|(
name|s
condition|)
name|my_err
argument_list|(
literal|"wta(non-symbol) to symbolconc"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|size
operator|=
name|size
operator|+
name|strlen
argument_list|(
name|PNAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|TKBUFFERN
condition|)
name|my_err
argument_list|(
literal|"symbolconc buffer overflow"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tkbuffer
argument_list|,
name|PNAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rintern
argument_list|(
name|tkbuffer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|set_print_hooks (long type,void (* fcn)(LISP,struct gen_printio *))
name|set_print_hooks
parameter_list|(
name|long
name|type
parameter_list|,
name|void
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
name|LISP
parameter_list|,
name|struct
name|gen_printio
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|prin1
operator|=
name|fcn
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|subr_kind_str (long n)
name|subr_kind_str
parameter_list|(
name|long
name|n
parameter_list|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|tc_subr_0
case|:
return|return
operator|(
literal|"subr_0"
operator|)
return|;
case|case
name|tc_subr_1
case|:
return|return
operator|(
literal|"subr_1"
operator|)
return|;
case|case
name|tc_subr_2
case|:
return|return
operator|(
literal|"subr_2"
operator|)
return|;
case|case
name|tc_subr_2n
case|:
return|return
operator|(
literal|"subr_2n"
operator|)
return|;
case|case
name|tc_subr_3
case|:
return|return
operator|(
literal|"subr_3"
operator|)
return|;
case|case
name|tc_subr_4
case|:
return|return
operator|(
literal|"subr_4"
operator|)
return|;
case|case
name|tc_subr_5
case|:
return|return
operator|(
literal|"subr_5"
operator|)
return|;
case|case
name|tc_lsubr
case|:
return|return
operator|(
literal|"lsubr"
operator|)
return|;
case|case
name|tc_fsubr
case|:
return|return
operator|(
literal|"fsubr"
operator|)
return|;
case|case
name|tc_msubr
case|:
return|return
operator|(
literal|"msubr"
operator|)
return|;
default|default:
return|return
operator|(
literal|"???"
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lprin1g (LISP exp,struct gen_printio * f)
name|lprin1g
parameter_list|(
name|LISP
name|exp
parameter_list|,
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|)
block|{
name|LISP
name|tmp
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
switch|switch TYPE
condition|(
name|exp
condition|)
block|{
case|case
name|tc_nil
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_cons
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|lprin1g
argument_list|(
name|car
argument_list|(
name|exp
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|cdr
argument_list|(
name|exp
argument_list|)
init|;
name|CONSP
argument_list|(
name|tmp
argument_list|)
condition|;
name|tmp
operator|=
name|cdr
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|lprin1g
argument_list|(
name|car
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if NNULLP
condition|(
name|tmp
condition|)
block|{
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" . "
argument_list|)
expr_stmt|;
name|lprin1g
argument_list|(
name|tmp
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_flonum
case|:
name|n
operator|=
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|n
operator|)
operator|==
name|FLONM
argument_list|(
name|exp
argument_list|)
condition|)
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%ld"
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%g"
argument_list|,
name|FLONM
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_symbol
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
name|PNAME
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"#<%s "
argument_list|,
name|subr_kind_str
argument_list|(
name|TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
operator|(
operator|*
name|exp
operator|)
operator|.
name|storage_as
operator|.
name|subr
operator|.
name|name
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_closure
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"#<CLOSURE "
argument_list|)
expr_stmt|;
if|if CONSP
condition|(
operator|(
operator|*
name|exp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
condition|)
block|{
name|lprin1g
argument_list|(
name|car
argument_list|(
operator|(
operator|*
name|exp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|lprin1g
argument_list|(
name|cdr
argument_list|(
operator|(
operator|*
name|exp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|lprin1g
argument_list|(
operator|(
operator|*
name|exp
operator|)
operator|.
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|prin1
condition|)
call|(
modifier|*
name|p
operator|->
name|prin1
call|)
argument_list|(
name|exp
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"#<UNKNOWN %d %p>"
argument_list|,
name|TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lprint (LISP exp,LISP lf)
name|lprint
parameter_list|(
name|LISP
name|exp
parameter_list|,
name|LISP
name|lf
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|get_c_file
argument_list|(
name|lf
argument_list|,
name|siod_output
argument_list|)
decl_stmt|;
name|lprin1f
argument_list|(
name|exp
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>
literal|0
condition|)
name|fput_st
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lprin1 (LISP exp,LISP lf)
name|lprin1
parameter_list|(
name|LISP
name|exp
parameter_list|,
name|LISP
name|lf
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|get_c_file
argument_list|(
name|lf
argument_list|,
name|siod_output
argument_list|)
decl_stmt|;
name|lprin1f
argument_list|(
name|exp
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lprin1f (LISP exp,FILE * f)
name|lprin1f
parameter_list|(
name|LISP
name|exp
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|gen_printio
name|s
decl_stmt|;
name|s
operator|.
name|putc_fcn
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|puts_fcn
operator|=
name|fputs_fcn
expr_stmt|;
name|s
operator|.
name|cb_argument
operator|=
name|f
expr_stmt|;
name|lprin1g
argument_list|(
name|exp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lread (LISP f)
name|lread
parameter_list|(
name|LISP
name|f
parameter_list|)
block|{
return|return
operator|(
name|lreadf
argument_list|(
name|get_c_file
argument_list|(
name|f
argument_list|,
name|stdin
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|f_getc (FILE * f)
name|f_getc
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|long
name|iflag
decl_stmt|,
name|dflag
decl_stmt|;
name|int
name|c
decl_stmt|;
name|iflag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dflag
operator|=
name|interrupt_differed
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|(
name|dflag
operator|==
literal|0
operator|)
operator|&
name|interrupt_differed
operator|&
operator|(
name|f
operator|==
name|stdin
operator|)
condition|)
while|while
condition|(
operator|(
name|c
operator|!=
literal|0
operator|)
operator|&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|f_ungetc (int c,FILE * f)
name|f_ungetc
parameter_list|(
name|int
name|c
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|flush_ws (struct gen_readio * f,char * eoferr)
name|flush_ws
parameter_list|(
name|struct
name|gen_readio
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|eoferr
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|commentp
decl_stmt|;
name|commentp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|eoferr
condition|)
name|my_err
argument_list|(
name|eoferr
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|commentp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|commentp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
name|commentp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lreadf (FILE * f)
name|lreadf
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|gen_readio
name|s
decl_stmt|;
name|s
operator|.
name|getc_fcn
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|f_getc
expr_stmt|;
name|s
operator|.
name|ungetc_fcn
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|f_ungetc
expr_stmt|;
name|s
operator|.
name|cb_argument
operator|=
operator|(
name|char
operator|*
operator|)
name|f
expr_stmt|;
return|return
operator|(
name|readtl
argument_list|(
operator|&
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|readtl (struct gen_readio * f)
name|readtl
parameter_list|(
name|struct
name|gen_readio
modifier|*
name|f
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|flush_ws
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|eof_val
operator|)
return|;
name|UNGETC_FCN
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|lreadr
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|set_read_hooks (char * all_set,char * end_set,LISP (* fcn1)(int,struct gen_readio *),LISP (* fcn2)(char *,long,int *))
name|set_read_hooks
parameter_list|(
name|char
modifier|*
name|all_set
parameter_list|,
name|char
modifier|*
name|end_set
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn1
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|gen_readio
modifier|*
parameter_list|)
parameter_list|,
name|LISP
function_decl|(
modifier|*
name|fcn2
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
modifier|*
parameter_list|)
parameter_list|)
block|{
name|user_ch_readm
operator|=
name|all_set
expr_stmt|;
name|user_te_readm
operator|=
name|end_set
expr_stmt|;
name|user_readm
operator|=
name|fcn1
expr_stmt|;
name|user_readt
operator|=
name|fcn2
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|lreadr (struct gen_readio * f)
name|lreadr
parameter_list|(
name|struct
name|gen_readio
modifier|*
name|f
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|buffer
init|=
name|tkbuffer
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|c
operator|=
name|flush_ws
argument_list|(
name|f
argument_list|,
literal|"end of file inside read"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
return|return
operator|(
name|lreadparen
argument_list|(
name|f
argument_list|)
operator|)
return|;
case|case
literal|')'
case|:
name|my_err
argument_list|(
literal|"unexpected close paren"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
return|return
operator|(
name|cons
argument_list|(
name|sym_quote
argument_list|,
name|cons
argument_list|(
name|lreadr
argument_list|(
name|f
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'`'
case|:
return|return
operator|(
name|cons
argument_list|(
name|cintern
argument_list|(
literal|"+internal-backquote"
argument_list|)
argument_list|,
name|lreadr
argument_list|(
name|f
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|','
case|:
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'@'
case|:
name|p
operator|=
literal|"+internal-comma-atsign"
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|p
operator|=
literal|"+internal-comma-dot"
expr_stmt|;
break|break;
default|default:
name|p
operator|=
literal|"+internal-comma"
expr_stmt|;
name|UNGETC_FCN
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cons
argument_list|(
name|cintern
argument_list|(
name|p
argument_list|)
argument_list|,
name|lreadr
argument_list|(
name|f
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'"'
case|:
return|return
operator|(
name|lreadstring
argument_list|(
name|f
argument_list|)
operator|)
return|;
case|case
literal|'#'
case|:
return|return
operator|(
name|lreadsharp
argument_list|(
name|f
argument_list|)
operator|)
return|;
default|default:
if|if
condition|(
operator|(
name|user_readm
operator|!=
name|NULL
operator|)
operator|&&
name|strchr
argument_list|(
name|user_ch_readm
argument_list|,
name|c
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|user_readm
call|)
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|TKBUFFERN
condition|;
operator|++
name|j
control|)
block|{
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|lreadtk
argument_list|(
name|buffer
argument_list|,
name|j
argument_list|)
operator|)
return|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|lreadtk
argument_list|(
name|buffer
argument_list|,
name|j
argument_list|)
operator|)
return|;
if|if
condition|(
name|strchr
argument_list|(
literal|"()'`,;\""
argument_list|,
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|user_te_readm
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|UNGETC_FCN
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|lreadtk
argument_list|(
name|buffer
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|my_err
argument_list|(
literal|"token larger than TKBUFFERN"
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lreadparen (struct gen_readio * f)
name|lreadparen
parameter_list|(
name|struct
name|gen_readio
modifier|*
name|f
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|LISP
name|tmp
decl_stmt|;
name|c
operator|=
name|flush_ws
argument_list|(
name|f
argument_list|,
literal|"end of file inside list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|UNGETC_FCN
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lreadr
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|tmp
operator|,
name|sym_dot
condition|)
block|{
name|tmp
operator|=
name|lreadr
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|flush_ws
argument_list|(
name|f
argument_list|,
literal|"end of file inside list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|my_err
argument_list|(
literal|"missing close paren"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
return|return
operator|(
name|cons
argument_list|(
name|tmp
argument_list|,
name|lreadparen
argument_list|(
name|f
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lreadtk (char * buffer,long j)
name|lreadtk
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|j
parameter_list|)
block|{
name|int
name|flag
decl_stmt|;
name|LISP
name|tmp
decl_stmt|;
name|int
name|adigit
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|p
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|user_readt
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
call|(
modifier|*
name|user_readt
call|)
argument_list|(
name|p
argument_list|,
name|j
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
name|adigit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
name|adigit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
name|adigit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|adigit
condition|)
goto|goto
name|a_symbol
goto|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'e'
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|a_symbol
goto|;
else|else
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
goto|goto
name|a_symbol
goto|;
return|return
operator|(
name|flocons
argument_list|(
name|atof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
return|;
name|a_symbol
label|:
return|return
operator|(
name|rintern
argument_list|(
name|buffer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|copy_list (LISP x)
name|copy_list
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if NULLP
condition|(
name|x
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|STACK_CHECK
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|cons
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|,
name|copy_list
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|apropos (LISP matchl)
name|apropos
parameter_list|(
name|LISP
name|matchl
parameter_list|)
block|{
name|LISP
name|result
init|=
name|NIL
decl_stmt|,
name|l
decl_stmt|,
name|ml
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
for|for
control|(
name|l
operator|=
name|oblistvar
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|pname
operator|=
name|get_c_string
argument_list|(
name|CAR
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|=
name|matchl
expr_stmt|;
while|while
condition|(
name|CONSP
argument_list|(
name|ml
argument_list|)
operator|&&
name|strstr
argument_list|(
name|pname
argument_list|,
name|get_c_string
argument_list|(
name|CAR
argument_list|(
name|ml
argument_list|)
argument_list|)
argument_list|)
condition|)
name|ml
operator|=
name|CDR
argument_list|(
name|ml
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|ml
condition|)
name|result
operator|=
name|cons
argument_list|(
name|CAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|fopen_cg (FILE * (* fcn)(const char *,const char *),char * name,char * how)
name|fopen_cg
parameter_list|(
name|FILE
modifier|*
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|how
parameter_list|)
block|{
name|LISP
name|sym
decl_stmt|;
name|long
name|flag
decl_stmt|;
name|char
name|errmsg
index|[
literal|80
index|]
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|newcell
argument_list|(
name|tc_c_file
argument_list|)
expr_stmt|;
name|sym
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
name|sym
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sym
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
operator|=
call|(
modifier|*
name|fcn
call|)
argument_list|(
name|name
argument_list|,
name|how
argument_list|)
operator|)
condition|)
block|{
name|SAFE_STRCPY
argument_list|(
name|errmsg
argument_list|,
literal|"could not open "
argument_list|)
expr_stmt|;
name|SAFE_STRCAT
argument_list|(
name|errmsg
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|my_err
argument_list|(
name|errmsg
argument_list|,
name|llast_c_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sym
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|fopen_c (char * name,char * how)
name|fopen_c
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|how
parameter_list|)
block|{
return|return
operator|(
name|fopen_cg
argument_list|(
name|fopen
argument_list|,
name|name
argument_list|,
name|how
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|fopen_l (LISP name,LISP how)
name|fopen_l
parameter_list|(
name|LISP
name|name
parameter_list|,
name|LISP
name|how
parameter_list|)
block|{
return|return
operator|(
name|fopen_c
argument_list|(
name|get_c_string
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULLP
argument_list|(
name|how
argument_list|)
condition|?
literal|"r"
else|:
name|get_c_string
argument_list|(
name|how
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|delq (LISP elem,LISP l)
name|delq
parameter_list|(
name|LISP
name|elem
parameter_list|,
name|LISP
name|l
parameter_list|)
block|{
if|if NULLP
condition|(
name|l
condition|)
return|return
operator|(
name|l
operator|)
return|;
name|STACK_CHECK
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|elem
operator|,
name|car
argument_list|(
name|l
argument_list|)
condition|)
return|return
operator|(
name|delq
argument_list|(
name|elem
argument_list|,
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
operator|)
return|;
name|setcdr
argument_list|(
name|l
argument_list|,
name|delq
argument_list|(
name|elem
argument_list|,
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|fclose_l (LISP p)
name|fclose_l
parameter_list|(
name|LISP
name|p
parameter_list|)
block|{
name|long
name|flag
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if NTYPEP
condition|(
name|p
operator|,
name|tc_c_file
condition|)
name|my_err
argument_list|(
literal|"not a file"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|file_gc_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|vload (char * fname,long cflag,long rflag)
name|vload
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|long
name|cflag
parameter_list|,
name|long
name|rflag
parameter_list|)
block|{
name|LISP
name|form
decl_stmt|,
name|result
decl_stmt|,
name|tail
decl_stmt|,
name|lf
decl_stmt|,
name|reader
init|=
name|NIL
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|c
decl_stmt|,
name|j
decl_stmt|;
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|key
init|=
literal|"parser:"
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|ftype
init|=
literal|".scm"
decl_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|int
name|iflag
decl_stmt|;
name|iflag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fname
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|(
name|strlen
argument_list|(
name|siod_lib
argument_list|)
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|1
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|siod_lib
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|buffer
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fname
operator|=
name|buffer
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
block|{
name|put_st
argument_list|(
literal|"loading "
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|lf
operator|=
name|fopen_c
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|f
operator|=
name|lf
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
expr_stmt|;
name|result
operator|=
name|NIL
expr_stmt|;
name|tail
operator|=
name|NIL
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|==
literal|'#'
operator|)
operator|||
operator|(
name|c
operator|==
literal|';'
operator|)
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
if|if
condition|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|buffer
index|[
name|j
index|]
operator|=
name|c
expr_stmt|;
name|buffer
index|[
operator|++
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|start
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
name|key
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|end
operator|=
operator|&
name|start
index|[
name|strlen
argument_list|(
name|key
argument_list|)
index|]
init|;
operator|*
name|end
operator|&&
name|isalnum
argument_list|(
operator|*
name|end
argument_list|)
condition|;
operator|++
name|end
control|)
empty_stmt|;
name|j
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|g_memmove
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|buffer
index|[
name|strlen
argument_list|(
name|key
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|buffer
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
name|require
argument_list|(
name|strcons
argument_list|(
operator|-
literal|1
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|reader
operator|=
name|rintern
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|reader
operator|=
name|funcall1
argument_list|(
name|leval
argument_list|(
name|reader
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|5
condition|)
block|{
name|put_st
argument_list|(
literal|"parser:"
argument_list|)
expr_stmt|;
name|lprin1
argument_list|(
name|reader
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|form
operator|=
name|NULLP
argument_list|(
name|reader
argument_list|)
condition|?
name|lread
argument_list|(
name|lf
argument_list|)
else|:
name|funcall1
argument_list|(
name|reader
argument_list|,
name|lf
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|form
operator|,
name|eof_val
condition|)
break|break;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|5
condition|)
name|lprint
argument_list|(
name|form
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
block|{
name|form
operator|=
name|cons
argument_list|(
name|form
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|result
condition|)
name|result
operator|=
name|tail
operator|=
name|form
expr_stmt|;
else|else
name|tail
operator|=
name|setcdr
argument_list|(
name|tail
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
else|else
name|leval
argument_list|(
name|form
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
name|fclose_l
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
name|put_st
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|load (LISP fname,LISP cflag,LISP rflag)
name|load
parameter_list|(
name|LISP
name|fname
parameter_list|,
name|LISP
name|cflag
parameter_list|,
name|LISP
name|rflag
parameter_list|)
block|{
return|return
operator|(
name|vload
argument_list|(
name|get_c_string
argument_list|(
name|fname
argument_list|)
argument_list|,
name|NULLP
argument_list|(
name|cflag
argument_list|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|NULLP
argument_list|(
name|rflag
argument_list|)
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|require (LISP fname)
name|require
parameter_list|(
name|LISP
name|fname
parameter_list|)
block|{
name|LISP
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|string_append
argument_list|(
name|cons
argument_list|(
name|cintern
argument_list|(
literal|"*"
argument_list|)
argument_list|,
name|cons
argument_list|(
name|fname
argument_list|,
name|cons
argument_list|(
name|cintern
argument_list|(
literal|"-loaded*"
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULLP
argument_list|(
name|symbol_boundp
argument_list|(
name|sym
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|||
name|NULLP
argument_list|(
name|symbol_value
argument_list|(
name|sym
argument_list|,
name|NIL
argument_list|)
argument_list|)
condition|)
block|{
name|load
argument_list|(
name|fname
argument_list|,
name|NIL
argument_list|,
name|sym_t
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym
argument_list|,
name|sym_t
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|save_forms (LISP fname,LISP forms,LISP how)
name|save_forms
parameter_list|(
name|LISP
name|fname
parameter_list|,
name|LISP
name|forms
parameter_list|,
name|LISP
name|how
parameter_list|)
block|{
name|char
modifier|*
name|cname
decl_stmt|,
modifier|*
name|chow
init|=
name|NULL
decl_stmt|;
name|LISP
name|l
decl_stmt|,
name|lf
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|cname
operator|=
name|get_c_string
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|how
operator|,
name|NIL
condition|)
name|chow
operator|=
literal|"w"
expr_stmt|;
elseif|else
if|if EQ
condition|(
name|how
operator|,
name|cintern
argument_list|(
literal|"a"
argument_list|)
condition|)
name|chow
operator|=
literal|"a"
expr_stmt|;
else|else
name|my_err
argument_list|(
literal|"bad argument to save-forms"
argument_list|,
name|how
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
block|{
name|put_st
argument_list|(
operator|(
operator|*
name|chow
operator|==
literal|'a'
operator|)
condition|?
literal|"appending"
else|:
literal|"saving"
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
literal|" forms to "
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|lf
operator|=
name|fopen_c
argument_list|(
name|cname
argument_list|,
name|chow
argument_list|)
expr_stmt|;
name|f
operator|=
name|lf
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
expr_stmt|;
for|for
control|(
name|l
operator|=
name|forms
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
block|{
name|lprin1f
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fclose_l
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
name|put_st
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|quit (void)
name|quit
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|my_err
argument_list|(
name|NULL
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|nullp (LISP x)
name|nullp
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if EQ
condition|(
name|x
operator|,
name|NIL
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|arglchk (LISP x)
name|arglchk
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|#
directive|if
operator|(
operator|!
name|ENVLOOKUP_TRICK
operator|)
name|LISP
name|l
decl_stmt|;
if|if SYMBOLP
condition|(
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
for|for
control|(
name|l
operator|=
name|x
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
empty_stmt|;
if|if NNULLP
condition|(
name|l
condition|)
name|my_err
argument_list|(
literal|"improper formal argument list"
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|file_gc_free (LISP ptr)
name|file_gc_free
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
condition|)
block|{
name|fclose
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
condition|)
block|{
name|free
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|file_prin1 (LISP ptr,struct gen_printio * f)
name|file_prin1
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|name
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"#<FILE "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|" %p"
argument_list|,
name|ptr
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|FILE
modifier|*
DECL|function|get_c_file (LISP p,FILE * deflt)
name|get_c_file
parameter_list|(
name|LISP
name|p
parameter_list|,
name|FILE
modifier|*
name|deflt
parameter_list|)
block|{
if|if
condition|(
name|NULLP
argument_list|(
name|p
argument_list|)
operator|&&
name|deflt
condition|)
return|return
operator|(
name|deflt
operator|)
return|;
if|if NTYPEP
condition|(
name|p
operator|,
name|tc_c_file
condition|)
name|my_err
argument_list|(
literal|"not a file"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
condition|)
name|my_err
argument_list|(
literal|"file is closed"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|storage_as
operator|.
name|c_file
operator|.
name|f
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lgetc (LISP p)
name|lgetc
parameter_list|(
name|LISP
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|f_getc
argument_list|(
name|get_c_file
argument_list|(
name|p
argument_list|,
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|i
operator|==
name|EOF
operator|)
condition|?
name|NIL
else|:
name|flocons
argument_list|(
operator|(
name|double
operator|)
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lungetc (LISP ii,LISP p)
name|lungetc
parameter_list|(
name|LISP
name|ii
parameter_list|,
name|LISP
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if NNULLP
condition|(
name|ii
condition|)
block|{
name|i
operator|=
name|get_c_long
argument_list|(
name|ii
argument_list|)
expr_stmt|;
name|f_ungetc
argument_list|(
name|i
argument_list|,
name|get_c_file
argument_list|(
name|p
argument_list|,
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lputc (LISP c,LISP p)
name|lputc
parameter_list|(
name|LISP
name|c
parameter_list|,
name|LISP
name|p
parameter_list|)
block|{
name|long
name|flag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|p
argument_list|,
name|siod_output
argument_list|)
expr_stmt|;
if|if FLONUMP
condition|(
name|c
condition|)
name|i
operator|=
operator|(
name|int
operator|)
name|FLONM
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
operator|*
name|get_c_string
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lputs (LISP str,LISP p)
name|lputs
parameter_list|(
name|LISP
name|str
parameter_list|,
name|LISP
name|p
parameter_list|)
block|{
name|fput_st
argument_list|(
name|get_c_file
argument_list|(
name|p
argument_list|,
name|siod_output
argument_list|)
argument_list|,
name|get_c_string
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lftell (LISP file)
name|lftell
parameter_list|(
name|LISP
name|file
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
operator|(
name|double
operator|)
name|ftell
argument_list|(
name|get_c_file
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lfseek (LISP file,LISP offset,LISP direction)
name|lfseek
parameter_list|(
name|LISP
name|file
parameter_list|,
name|LISP
name|offset
parameter_list|,
name|LISP
name|direction
parameter_list|)
block|{
return|return
operator|(
operator|(
name|fseek
argument_list|(
name|get_c_file
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|get_c_long
argument_list|(
name|offset
argument_list|)
argument_list|,
name|get_c_long
argument_list|(
name|direction
argument_list|)
argument_list|)
operator|)
condition|?
name|NIL
else|:
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|parse_number (LISP x)
name|parse_number
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|get_c_string
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|atof
argument_list|(
name|c
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|init_subrs (void)
name|init_subrs
parameter_list|(
name|void
parameter_list|)
block|{
name|init_subrs_1
argument_list|()
expr_stmt|;
name|init_subrs_a
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|closure_code (LISP exp)
name|closure_code
parameter_list|(
name|LISP
name|exp
parameter_list|)
block|{
return|return
operator|(
name|exp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|closure_env (LISP exp)
name|closure_env
parameter_list|(
name|LISP
name|exp
parameter_list|)
block|{
return|return
operator|(
name|exp
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lwhile (LISP form,LISP env)
name|lwhile
parameter_list|(
name|LISP
name|form
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
while|while
condition|(
name|NNULLP
argument_list|(
name|leval
argument_list|(
name|car
argument_list|(
name|form
argument_list|)
argument_list|,
name|env
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|l
operator|=
name|cdr
argument_list|(
name|form
argument_list|)
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|nreverse (LISP x)
name|nreverse
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|LISP
name|newp
decl_stmt|,
name|oldp
decl_stmt|,
name|nextp
decl_stmt|;
name|newp
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|oldp
operator|=
name|x
init|;
name|CONSP
argument_list|(
name|oldp
argument_list|)
condition|;
name|oldp
operator|=
name|nextp
control|)
block|{
name|nextp
operator|=
name|CDR
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
name|CDR
argument_list|(
name|oldp
argument_list|)
operator|=
name|newp
expr_stmt|;
name|newp
operator|=
name|oldp
expr_stmt|;
block|}
return|return
operator|(
name|newp
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|siod_verbose (LISP arg)
name|siod_verbose
parameter_list|(
name|LISP
name|arg
parameter_list|)
block|{
if|if NNULLP
condition|(
name|arg
condition|)
name|siod_verbose_level
operator|=
name|get_c_long
argument_list|(
name|car
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|siod_verbose_level
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|siod_verbose_check (int level)
name|siod_verbose_check
parameter_list|(
name|int
name|level
parameter_list|)
block|{
return|return
operator|(
operator|(
name|siod_verbose_level
operator|>=
name|level
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lruntime (void)
name|lruntime
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cons
argument_list|(
name|flocons
argument_list|(
name|myruntime
argument_list|()
argument_list|)
argument_list|,
name|cons
argument_list|(
name|flocons
argument_list|(
name|gc_time_taken
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lrealtime (void)
name|lrealtime
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|myrealtime
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|caar (LISP x)
name|caar
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cadr (LISP x)
name|cadr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cdar (LISP x)
name|cdar
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cddr (LISP x)
name|cddr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lrand (LISP m)
name|lrand
parameter_list|(
name|LISP
name|m
parameter_list|)
block|{
name|long
name|res
decl_stmt|;
name|res
operator|=
name|rand
argument_list|()
expr_stmt|;
if|if NULLP
condition|(
name|m
condition|)
return|return
operator|(
name|flocons
argument_list|(
name|res
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|flocons
argument_list|(
name|res
operator|%
name|get_c_long
argument_list|(
name|m
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lsrand (LISP s)
name|lsrand
parameter_list|(
name|LISP
name|s
parameter_list|)
block|{
name|srand
argument_list|(
name|get_c_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|a_true_value (void)
name|a_true_value
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|poparg (LISP * ptr,LISP defaultv)
name|poparg
parameter_list|(
name|LISP
modifier|*
name|ptr
parameter_list|,
name|LISP
name|defaultv
parameter_list|)
block|{
name|LISP
name|value
decl_stmt|;
if|if NULLP
condition|(
operator|*
name|ptr
condition|)
return|return
operator|(
name|defaultv
operator|)
return|;
name|value
operator|=
name|car
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|cdr
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|last_c_errmsg (int num)
name|last_c_errmsg
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|xerrno
init|=
operator|(
name|num
operator|<
literal|0
operator|)
condition|?
name|errno
else|:
name|num
decl_stmt|;
specifier|static
name|char
name|serrmsg
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
name|g_strerror
argument_list|(
name|xerrno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
name|sprintf
argument_list|(
name|serrmsg
argument_list|,
literal|"errno %d"
argument_list|,
name|xerrno
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|serrmsg
expr_stmt|;
block|}
return|return
operator|(
name|errmsg
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|llast_c_errmsg (int num)
name|llast_c_errmsg
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|xerrno
init|=
operator|(
name|num
operator|<
literal|0
operator|)
condition|?
name|errno
else|:
name|num
decl_stmt|;
name|char
modifier|*
name|errmsg
init|=
name|g_strerror
argument_list|(
name|xerrno
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|errmsg
condition|)
return|return
operator|(
name|flocons
argument_list|(
name|xerrno
argument_list|)
operator|)
return|;
return|return
operator|(
name|cintern
argument_list|(
name|errmsg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lllast_c_errmsg (void)
name|lllast_c_errmsg
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|llast_c_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|help (void)
name|help
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"HELP for SIOD, Version %s\n"
argument_list|,
name|siod_version
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"For the latest Script-Fu tips, tutorials,& info:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|siod_output
argument_list|,
literal|"\thttp://www.gimp.org/scripts.html\n\n"
argument_list|)
expr_stmt|;
return|return
name|NIL
return|;
block|}
end_function

begin_function
name|size_t
DECL|function|safe_strlen (const char * s,size_t size)
name|safe_strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|(
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
operator|)
condition|)
return|return
operator|(
name|end
operator|-
name|s
operator|)
return|;
else|else
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|safe_strcpy (char * s1,size_t size1,const char * s2)
name|safe_strcpy
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|size_t
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|size_t
name|len2
decl_stmt|;
if|if
condition|(
name|size1
operator|==
literal|0
condition|)
return|return
operator|(
name|s1
operator|)
return|;
name|len2
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
operator|<
name|size1
condition|)
block|{
if|if
condition|(
name|len2
condition|)
name|memcpy
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|s1
index|[
name|len2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|s1
index|[
name|size1
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|s1
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|safe_strcat (char * s1,size_t size1,const char * s2)
name|safe_strcat
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|size_t
name|size1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|size_t
name|len1
decl_stmt|;
name|len1
operator|=
name|safe_strlen
argument_list|(
name|s1
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|safe_strcpy
argument_list|(
operator|&
name|s1
index|[
name|len1
index|]
argument_list|,
name|size1
operator|-
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
name|s1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|LISP
DECL|function|parser_read (LISP ignore)
name|parser_read
parameter_list|(
name|LISP
name|ignore
parameter_list|)
block|{
return|return
operator|(
name|leval
argument_list|(
name|cintern
argument_list|(
literal|"read"
argument_list|)
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|init_subrs_1 (void)
name|init_subrs_1
parameter_list|(
name|void
parameter_list|)
block|{
name|init_subr_2
argument_list|(
literal|"cons"
argument_list|,
name|cons
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"car"
argument_list|,
name|car
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cdr"
argument_list|,
name|cdr
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"set-car!"
argument_list|,
name|setcar
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"set-cdr!"
argument_list|,
name|setcdr
argument_list|)
expr_stmt|;
name|init_subr_2n
argument_list|(
literal|"+"
argument_list|,
name|plus
argument_list|)
expr_stmt|;
name|init_subr_2n
argument_list|(
literal|"-"
argument_list|,
name|difference
argument_list|)
expr_stmt|;
name|init_subr_2n
argument_list|(
literal|"*"
argument_list|,
name|ltimes
argument_list|)
expr_stmt|;
name|init_subr_2n
argument_list|(
literal|"/"
argument_list|,
name|Quotient
argument_list|)
expr_stmt|;
name|init_subr_2n
argument_list|(
literal|"min"
argument_list|,
name|lmin
argument_list|)
expr_stmt|;
name|init_subr_2n
argument_list|(
literal|"max"
argument_list|,
name|lmax
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"abs"
argument_list|,
name|lllabs
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"sqrt"
argument_list|,
name|lsqrt
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|">"
argument_list|,
name|greaterp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"<"
argument_list|,
name|lessp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|">="
argument_list|,
name|greaterEp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"<="
argument_list|,
name|lessEp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"eq?"
argument_list|,
name|eq
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"eqv?"
argument_list|,
name|eql
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"="
argument_list|,
name|eql
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"assq"
argument_list|,
name|assq
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"delq"
argument_list|,
name|delq
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"read"
argument_list|,
name|lread
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"parser_read"
argument_list|,
name|parser_read
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*parser_read.scm-loaded*"
argument_list|)
argument_list|,
name|sym_t
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"eof-val"
argument_list|,
name|get_eof_val
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"print"
argument_list|,
name|lprint
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"prin1"
argument_list|,
name|lprin1
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"eval"
argument_list|,
name|leval
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"apply"
argument_list|,
name|lapply
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"define"
argument_list|,
name|leval_define
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"lambda"
argument_list|,
name|leval_lambda
argument_list|)
expr_stmt|;
name|init_msubr
argument_list|(
literal|"if"
argument_list|,
name|leval_if
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"while"
argument_list|,
name|leval_while
argument_list|)
expr_stmt|;
name|init_msubr
argument_list|(
literal|"begin"
argument_list|,
name|leval_progn
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"set!"
argument_list|,
name|leval_setq
argument_list|)
expr_stmt|;
name|init_msubr
argument_list|(
literal|"or"
argument_list|,
name|leval_or
argument_list|)
expr_stmt|;
name|init_msubr
argument_list|(
literal|"and"
argument_list|,
name|leval_and
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"*catch"
argument_list|,
name|leval_catch
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"*throw"
argument_list|,
name|lthrow
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"quote"
argument_list|,
name|leval_quote
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"apropos"
argument_list|,
name|apropos
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"verbose"
argument_list|,
name|siod_verbose
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"copy-list"
argument_list|,
name|copy_list
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"gc-status"
argument_list|,
name|gc_status
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"gc"
argument_list|,
name|user_gc
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"load"
argument_list|,
name|load
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"require"
argument_list|,
name|require
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"pair?"
argument_list|,
name|consp
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"symbol?"
argument_list|,
name|symbolp
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"number?"
argument_list|,
name|numberp
argument_list|)
expr_stmt|;
name|init_msubr
argument_list|(
literal|"let-internal"
argument_list|,
name|leval_let
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"let-internal-macro"
argument_list|,
name|let_macro
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"let*-macro"
argument_list|,
name|letstar_macro
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"letrec-macro"
argument_list|,
name|letrec_macro
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"symbol-bound?"
argument_list|,
name|symbol_boundp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"symbol-value"
argument_list|,
name|symbol_value
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"set-symbol-value!"
argument_list|,
name|setvar
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"the-environment"
argument_list|,
name|leval_tenv
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"error"
argument_list|,
name|lerr
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"quit"
argument_list|,
name|quit
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"not"
argument_list|,
name|nullp
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"null?"
argument_list|,
name|nullp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"env-lookup"
argument_list|,
name|envlookup
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"reverse"
argument_list|,
name|reverse
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"symbolconc"
argument_list|,
name|symbolconc
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"save-forms"
argument_list|,
name|save_forms
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"fopen"
argument_list|,
name|fopen_l
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"fclose"
argument_list|,
name|fclose_l
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"getc"
argument_list|,
name|lgetc
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"ungetc"
argument_list|,
name|lungetc
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"putc"
argument_list|,
name|lputc
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"puts"
argument_list|,
name|lputs
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"ftell"
argument_list|,
name|lftell
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"fseek"
argument_list|,
name|lfseek
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"parse-number"
argument_list|,
name|parse_number
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"%%stack-limit"
argument_list|,
name|stack_limit
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"intern"
argument_list|,
name|intern
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"%%closure"
argument_list|,
name|closure
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"%%closure-code"
argument_list|,
name|closure_code
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"%%closure-env"
argument_list|,
name|closure_env
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"while"
argument_list|,
name|lwhile
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"nreverse"
argument_list|,
name|nreverse
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"allocate-heap"
argument_list|,
name|allocate_aheap
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"gc-info"
argument_list|,
name|gc_info
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"runtime"
argument_list|,
name|lruntime
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"realtime"
argument_list|,
name|lrealtime
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"caar"
argument_list|,
name|caar
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cadr"
argument_list|,
name|cadr
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cdar"
argument_list|,
name|cdar
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cddr"
argument_list|,
name|cddr
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"rand"
argument_list|,
name|lrand
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"srand"
argument_list|,
name|lsrand
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"last-c-error"
argument_list|,
name|lllast_c_errmsg
argument_list|)
expr_stmt|;
name|init_subr_0
argument_list|(
literal|"help"
argument_list|,
name|help
argument_list|)
expr_stmt|;
name|init_slib_version
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* err0,pr,prp are convenient to call from the C-language debugger */
end_comment

begin_function
name|void
DECL|function|err0 (void)
name|err0
parameter_list|(
name|void
parameter_list|)
block|{
name|my_err
argument_list|(
literal|"0"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|pr (LISP p)
name|pr
parameter_list|(
name|LISP
name|p
parameter_list|)
block|{
if|if
condition|(
name|looks_pointerp
argument_list|(
name|p
argument_list|)
condition|)
name|lprint
argument_list|(
name|p
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
else|else
name|put_st
argument_list|(
literal|"invalid\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|prp (LISP * p)
name|prp
parameter_list|(
name|LISP
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|pr
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

