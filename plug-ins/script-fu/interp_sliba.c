begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                   COPYRIGHT (c) 1988-1994 BY                             *  *        PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS.       *  *        See the source file SLIB.C for more information.                  *   Array-hacking code moved to another source file.   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"siod.h"
end_include

begin_include
include|#
directive|include
file|"siodp.h"
end_include

begin_function
specifier|static
name|void
DECL|function|init_sliba_version (void)
name|init_sliba_version
parameter_list|(
name|void
parameter_list|)
block|{
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*sliba-version*"
argument_list|)
argument_list|,
name|cintern
argument_list|(
literal|"$Id$"
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|sym_plists
specifier|static
name|LISP
name|sym_plists
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bashnum
specifier|static
name|LISP
name|bashnum
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_e
specifier|static
name|LISP
name|sym_e
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sym_f
specifier|static
name|LISP
name|sym_f
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|init_storage_a1 (long type)
name|init_storage_a1
parameter_list|(
name|long
name|type
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|set_gc_hooks
argument_list|(
name|type
argument_list|,
name|array_gc_relocate
argument_list|,
name|array_gc_mark
argument_list|,
name|array_gc_scan
argument_list|,
name|array_gc_free
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|set_print_hooks
argument_list|(
name|type
argument_list|,
name|array_prin1
argument_list|)
expr_stmt|;
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|fast_print
operator|=
name|array_fast_print
expr_stmt|;
name|p
operator|->
name|fast_read
operator|=
name|array_fast_read
expr_stmt|;
name|p
operator|->
name|equal
operator|=
name|array_equal
expr_stmt|;
name|p
operator|->
name|c_sxhash
operator|=
name|array_sxhash
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|init_storage_a (void)
name|init_storage_a
parameter_list|(
name|void
parameter_list|)
block|{
name|gc_protect
argument_list|(
operator|&
name|bashnum
argument_list|)
expr_stmt|;
name|bashnum
operator|=
name|newcell
argument_list|(
name|tc_flonum
argument_list|)
expr_stmt|;
name|init_storage_a1
argument_list|(
name|tc_string
argument_list|)
expr_stmt|;
name|init_storage_a1
argument_list|(
name|tc_double_array
argument_list|)
expr_stmt|;
name|init_storage_a1
argument_list|(
name|tc_long_array
argument_list|)
expr_stmt|;
name|init_storage_a1
argument_list|(
name|tc_lisp_array
argument_list|)
expr_stmt|;
name|init_storage_a1
argument_list|(
name|tc_byte_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|array_gc_relocate (LISP ptr)
name|array_gc_relocate
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|LISP
name|nw
decl_stmt|;
if|if
condition|(
operator|(
name|nw
operator|=
name|heap
operator|)
operator|>=
name|heap_end
condition|)
name|gc_fatal_error
argument_list|()
expr_stmt|;
name|heap
operator|=
name|nw
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|nw
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nw
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|array_gc_scan (LISP ptr)
name|array_gc_scan
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
if|if TYPEP
condition|(
name|ptr
operator|,
name|tc_lisp_array
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|;
operator|++
name|j
control|)
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
operator|=
name|gc_relocate
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|array_gc_mark (LISP ptr)
name|array_gc_mark
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
name|long
name|j
decl_stmt|;
if|if TYPEP
condition|(
name|ptr
operator|,
name|tc_lisp_array
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|;
operator|++
name|j
control|)
name|gc_mark
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|array_gc_free (LISP ptr)
name|array_gc_free
parameter_list|(
name|LISP
name|ptr
parameter_list|)
block|{
switch|switch
condition|(
name|ptr
operator|->
name|type
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
name|free
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_double_array
case|:
name|free
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_long_array
case|:
name|free
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_lisp_array
case|:
name|free
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|array_prin1 (LISP ptr,struct gen_printio * f)
name|array_prin1
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|struct
name|gen_printio
modifier|*
name|f
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|type
condition|)
block|{
case|case
name|tc_string
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcspn
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
literal|"\"\\\n\r\t"
argument_list|)
operator|==
name|strlen
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
condition|)
name|gput_st
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|char
name|cbuff
index|[
literal|3
index|]
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
switch|switch
condition|(
name|c
operator|=
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
name|cbuff
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuff
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|cbuff
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|cbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cbuff
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|cbuff
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|cbuff
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_double_array
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"#("
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
condition|;
operator|++
name|j
control|)
block|{
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%g"
argument_list|,
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
condition|)
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_long_array
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"#("
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
condition|;
operator|++
name|j
control|)
block|{
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%ld"
argument_list|,
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
condition|)
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
case|case
name|tc_byte_array
case|:
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"#%ld\""
argument_list|,
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
condition|;
operator|++
name|j
control|)
block|{
name|sprintf
argument_list|(
name|tkbuffer
argument_list|,
literal|"%02x"
argument_list|,
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|j
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|gput_st
argument_list|(
name|f
argument_list|,
name|tkbuffer
argument_list|)
expr_stmt|;
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_lisp_array
case|:
name|gput_st
argument_list|(
name|f
argument_list|,
literal|"#("
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|;
operator|++
name|j
control|)
block|{
name|lprin1g
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|<
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|)
name|gput_st
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|gput_st
argument_list|(
name|f
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|strcons (long length,char * data)
name|strcons
parameter_list|(
name|long
name|length
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
name|long
name|flag
decl_stmt|;
name|LISP
name|s
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|tc_string
expr_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
name|length
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
name|must_malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|memcpy
argument_list|(
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|rfs_getc (unsigned char ** p)
name|rfs_getc
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|*
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
operator|*
name|p
operator|=
operator|*
name|p
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|rfs_ungetc (unsigned char c,unsigned char ** p)
name|rfs_ungetc
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
operator|*
name|p
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|read_from_string (LISP x)
name|read_from_string
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|gen_readio
name|s
decl_stmt|;
name|p
operator|=
name|get_c_string
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|s
operator|.
name|getc_fcn
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rfs_getc
expr_stmt|;
name|s
operator|.
name|ungetc_fcn
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|rfs_ungetc
expr_stmt|;
name|s
operator|.
name|cb_argument
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|p
expr_stmt|;
return|return
operator|(
name|readtl
argument_list|(
operator|&
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|pts_puts (char * from,void * cb)
name|pts_puts
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|LISP
name|into
decl_stmt|;
name|size_t
name|fromlen
decl_stmt|,
name|intolen
decl_stmt|,
name|intosize
decl_stmt|,
name|fitsize
decl_stmt|;
name|into
operator|=
operator|(
name|LISP
operator|)
name|cb
expr_stmt|;
name|fromlen
operator|=
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|intolen
operator|=
name|strlen
argument_list|(
name|into
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
expr_stmt|;
name|intosize
operator|=
name|into
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|-
name|intolen
expr_stmt|;
name|fitsize
operator|=
operator|(
name|fromlen
operator|<
name|intosize
operator|)
condition|?
name|fromlen
else|:
name|intosize
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|into
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|intolen
index|]
argument_list|,
name|from
argument_list|,
name|fitsize
argument_list|)
expr_stmt|;
name|into
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|intolen
operator|+
name|fitsize
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fitsize
operator|<
name|fromlen
condition|)
name|err
argument_list|(
literal|"print to string overflow"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|err_wta_str (LISP exp)
name|err_wta_str
parameter_list|(
name|LISP
name|exp
parameter_list|)
block|{
return|return
operator|(
name|err
argument_list|(
literal|"not a string"
argument_list|,
name|exp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|print_to_string (LISP exp,LISP str,LISP nostart)
name|print_to_string
parameter_list|(
name|LISP
name|exp
parameter_list|,
name|LISP
name|str
parameter_list|,
name|LISP
name|nostart
parameter_list|)
block|{
name|struct
name|gen_printio
name|s
decl_stmt|;
if|if NTYPEP
condition|(
name|str
operator|,
name|tc_string
condition|)
name|err_wta_str
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|s
operator|.
name|putc_fcn
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|puts_fcn
operator|=
name|pts_puts
expr_stmt|;
name|s
operator|.
name|cb_argument
operator|=
name|str
expr_stmt|;
if|if NULLP
condition|(
name|nostart
condition|)
name|str
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lprin1g
argument_list|(
name|exp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|aref1 (LISP a,LISP i)
name|aref1
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|i
parameter_list|)
block|{
name|long
name|k
decl_stmt|;
if|if NFLONUMP
condition|(
name|i
condition|)
name|err
argument_list|(
literal|"bad index to aref"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|"negative index to aref"
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch TYPE
condition|(
name|a
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
condition|)
name|err
argument_list|(
literal|"index too large"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
operator|(
name|double
operator|)
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|k
index|]
argument_list|)
operator|)
return|;
case|case
name|tc_double_array
case|:
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
condition|)
name|err
argument_list|(
literal|"index too large"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|k
index|]
argument_list|)
operator|)
return|;
case|case
name|tc_long_array
case|:
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
condition|)
name|err
argument_list|(
literal|"index too large"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
index|[
name|k
index|]
argument_list|)
operator|)
return|;
case|case
name|tc_lisp_array
case|:
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|)
name|err
argument_list|(
literal|"index too large"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|k
index|]
operator|)
return|;
default|default:
return|return
operator|(
name|err
argument_list|(
literal|"invalid argument to aref"
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|err1_aset1 (LISP i)
name|err1_aset1
parameter_list|(
name|LISP
name|i
parameter_list|)
block|{
name|err
argument_list|(
literal|"index to aset too large"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|err2_aset1 (LISP v)
name|err2_aset1
parameter_list|(
name|LISP
name|v
parameter_list|)
block|{
name|err
argument_list|(
literal|"bad value to store in array"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|aset1 (LISP a,LISP i,LISP v)
name|aset1
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|i
parameter_list|,
name|LISP
name|v
parameter_list|)
block|{
name|long
name|k
decl_stmt|;
if|if NFLONUMP
condition|(
name|i
condition|)
name|err
argument_list|(
literal|"bad index to aset"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|"negative index to aset"
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch TYPE
condition|(
name|a
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
if|if NFLONUMP
condition|(
name|v
condition|)
name|err2_aset1
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
condition|)
name|err1_aset1
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|k
index|]
operator|=
operator|(
name|char
operator|)
name|FLONM
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
case|case
name|tc_double_array
case|:
if|if NFLONUMP
condition|(
name|v
condition|)
name|err2_aset1
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
condition|)
name|err1_aset1
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|k
index|]
operator|=
name|FLONM
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
case|case
name|tc_long_array
case|:
if|if NFLONUMP
condition|(
name|v
condition|)
name|err2_aset1
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
condition|)
name|err1_aset1
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
index|[
name|k
index|]
operator|=
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
case|case
name|tc_lisp_array
case|:
if|if
condition|(
name|k
operator|>=
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|)
name|err1_aset1
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|k
index|]
operator|=
name|v
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
default|default:
return|return
operator|(
name|err
argument_list|(
literal|"invalid argument to aset"
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|arcons (long typecode,long n,long initp)
name|arcons
parameter_list|(
name|long
name|typecode
parameter_list|,
name|long
name|n
parameter_list|,
name|long
name|initp
parameter_list|)
block|{
name|LISP
name|a
decl_stmt|;
name|long
name|flag
decl_stmt|,
name|j
decl_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|a
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|typecode
condition|)
block|{
case|case
name|tc_double_array
case|:
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
operator|=
operator|(
name|double
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initp
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
break|break;
case|case
name|tc_long_array
case|:
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
operator|=
operator|(
name|long
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initp
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|tc_string
case|:
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|initp
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|' '
expr_stmt|;
case|case
name|tc_byte_array
case|:
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|initp
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|tc_lisp_array
case|:
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
operator|=
operator|(
name|LISP
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|LISP
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
operator|=
name|NIL
expr_stmt|;
break|break;
default|default:
name|errswitch
argument_list|()
expr_stmt|;
block|}
name|a
operator|->
name|type
operator|=
name|typecode
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|mallocl (void * place,long size)
name|mallocl
parameter_list|(
name|void
modifier|*
name|place
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|long
name|n
decl_stmt|,
name|r
decl_stmt|;
name|LISP
name|retval
decl_stmt|;
name|n
operator|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|r
operator|=
name|size
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
operator|++
name|n
expr_stmt|;
name|retval
operator|=
name|arcons
argument_list|(
name|tc_long_array
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|*
operator|)
name|place
operator|=
name|retval
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cons_array (LISP dim,LISP kind)
name|cons_array
parameter_list|(
name|LISP
name|dim
parameter_list|,
name|LISP
name|kind
parameter_list|)
block|{
name|LISP
name|a
decl_stmt|;
name|long
name|flag
decl_stmt|,
name|n
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|NFLONUMP
argument_list|(
name|dim
argument_list|)
operator|||
operator|(
name|FLONM
argument_list|(
name|dim
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|err
argument_list|(
literal|"bad dimension to cons-array"
argument_list|,
name|dim
argument_list|)
operator|)
return|;
else|else
name|n
operator|=
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|dim
argument_list|)
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|a
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|cintern
argument_list|(
literal|"double"
argument_list|)
operator|,
name|kind
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|tc_double_array
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
operator|=
operator|(
name|double
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if EQ
condition|(
name|cintern
argument_list|(
literal|"long"
argument_list|)
operator|,
name|kind
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|tc_long_array
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
operator|=
operator|(
name|long
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if EQ
condition|(
name|cintern
argument_list|(
literal|"string"
argument_list|)
operator|,
name|kind
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|tc_string
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if EQ
condition|(
name|cintern
argument_list|(
literal|"byte"
argument_list|)
operator|,
name|kind
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|tc_byte_array
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|cintern
argument_list|(
literal|"lisp"
argument_list|)
argument_list|,
name|kind
argument_list|)
operator|||
name|NULLP
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|tc_lisp_array
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
operator|=
name|n
expr_stmt|;
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
operator|=
operator|(
name|LISP
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|LISP
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
operator|=
name|NIL
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"bad type of array"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_append (LISP args)
name|string_append
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
name|long
name|size
decl_stmt|;
name|LISP
name|l
decl_stmt|,
name|s
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|args
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|size
operator|+=
name|strlen
argument_list|(
name|get_c_string
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|strcons
argument_list|(
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|=
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|args
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|strcat
argument_list|(
name|data
argument_list|,
name|get_c_string
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|bytes_append (LISP args)
name|bytes_append
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
name|long
name|size
decl_stmt|,
name|n
decl_stmt|,
name|j
decl_stmt|;
name|LISP
name|l
decl_stmt|,
name|s
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|args
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
block|{
name|get_c_string_dim
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|size
operator|+=
name|n
expr_stmt|;
block|}
name|s
operator|=
name|arcons
argument_list|(
name|tc_byte_array
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|=
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|args
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
block|{
name|ptr
operator|=
name|get_c_string_dim
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
index|[
name|j
index|]
argument_list|,
name|ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|j
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|substring (LISP str,LISP start,LISP end)
name|substring
parameter_list|(
name|LISP
name|str
parameter_list|,
name|LISP
name|start
parameter_list|,
name|LISP
name|end
parameter_list|)
block|{
name|long
name|s
decl_stmt|,
name|e
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|get_c_string_dim
argument_list|(
name|str
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|s
operator|=
name|get_c_long
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|end
condition|)
name|e
operator|=
name|n
expr_stmt|;
else|else
name|e
operator|=
name|get_c_long
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|<
literal|0
operator|)
operator|||
operator|(
name|s
operator|>
name|e
operator|)
condition|)
name|err
argument_list|(
literal|"bad start index"
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|<
literal|0
operator|)
operator|||
operator|(
name|e
operator|>
name|n
operator|)
condition|)
name|err
argument_list|(
literal|"bad end index"
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|e
operator|-
name|s
argument_list|,
operator|&
name|data
index|[
name|s
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_search (LISP token,LISP str)
name|string_search
parameter_list|(
name|LISP
name|token
parameter_list|,
name|LISP
name|str
parameter_list|)
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|s1
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|s2
operator|=
name|get_c_string
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
return|return
operator|(
name|flocons
argument_list|(
name|ptr
operator|-
name|s1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_define
DECL|macro|IS_TRIM_SPACE (_x)
define|#
directive|define
name|IS_TRIM_SPACE
parameter_list|(
name|_x
parameter_list|)
value|(strchr(" \t\r\n",(_x)))
end_define

begin_function
name|LISP
DECL|function|string_trim (LISP str)
name|string_trim
parameter_list|(
name|LISP
name|str
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/*, *sp = " \t\r\n";*/
name|start
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|&&
name|IS_TRIM_SPACE
argument_list|(
operator|*
name|start
argument_list|)
condition|)
operator|++
name|start
expr_stmt|;
name|end
operator|=
operator|&
name|start
index|[
name|strlen
argument_list|(
name|start
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|end
operator|>
name|start
operator|)
operator|&&
name|IS_TRIM_SPACE
argument_list|(
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|--
name|end
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|end
operator|-
name|start
argument_list|,
name|start
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_trim_left (LISP str)
name|string_trim_left
parameter_list|(
name|LISP
name|str
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|start
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|&&
name|IS_TRIM_SPACE
argument_list|(
operator|*
name|start
argument_list|)
condition|)
operator|++
name|start
expr_stmt|;
name|end
operator|=
operator|&
name|start
index|[
name|strlen
argument_list|(
name|start
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|end
operator|-
name|start
argument_list|,
name|start
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_trim_right (LISP str)
name|string_trim_right
parameter_list|(
name|LISP
name|str
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|start
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
name|start
index|[
name|strlen
argument_list|(
name|start
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|end
operator|>
name|start
operator|)
operator|&&
name|IS_TRIM_SPACE
argument_list|(
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|--
name|end
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|end
operator|-
name|start
argument_list|,
name|start
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_upcase (LISP str)
name|string_upcase
parameter_list|(
name|LISP
name|str
parameter_list|)
block|{
name|LISP
name|result
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
name|s1
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|result
operator|=
name|strcons
argument_list|(
name|n
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|get_c_string
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|s2
index|[
name|j
index|]
operator|=
name|toupper
argument_list|(
name|s2
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_downcase (LISP str)
name|string_downcase
parameter_list|(
name|LISP
name|str
parameter_list|)
block|{
name|LISP
name|result
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
name|s1
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|result
operator|=
name|strcons
argument_list|(
name|n
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|get_c_string
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|s2
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|s2
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lreadstring (struct gen_readio * f)
name|lreadstring
parameter_list|(
name|struct
name|gen_readio
modifier|*
name|f
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|tkbuffer
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"eof after \\"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|c
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|c
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"eof after \\0"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|8
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
name|UNGETC_FCN
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|>=
name|TKBUFFERN
condition|)
name|err
argument_list|(
literal|"read string overflow"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|j
argument_list|,
name|tkbuffer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lreadsharp (struct gen_readio * f)
name|lreadsharp
parameter_list|(
name|struct
name|gen_readio
modifier|*
name|f
parameter_list|)
block|{
name|LISP
name|obj
decl_stmt|,
name|l
decl_stmt|,
name|result
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|GETC_FCN
argument_list|(
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
name|UNGETC_FCN
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|obj
operator|=
name|lreadr
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|n
operator|=
name|nlength
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|result
operator|=
name|arcons
argument_list|(
name|tc_lisp_array
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|obj
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
operator|,
operator|++
name|j
control|)
name|result
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
case|case
literal|'.'
case|:
name|obj
operator|=
name|lreadr
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|leval
argument_list|(
name|obj
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
name|NIL
operator|)
return|;
case|case
literal|'t'
case|:
return|return
operator|(
name|flocons
argument_list|(
literal|1
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|err
argument_list|(
literal|"readsharp syntax not handled"
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_define
DECL|macro|HASH_COMBINE (_h1,_h2,_mod)
define|#
directive|define
name|HASH_COMBINE
parameter_list|(
name|_h1
parameter_list|,
name|_h2
parameter_list|,
name|_mod
parameter_list|)
value|((((_h1) * 17 + 1) ^ (_h2)) % (_mod))
end_define

begin_function
name|long
DECL|function|c_sxhash (LISP obj,long n)
name|c_sxhash
parameter_list|(
name|LISP
name|obj
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|long
name|hash
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|LISP
name|tmp
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|obj
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
switch|switch TYPE
condition|(
name|obj
condition|)
block|{
case|case
name|tc_nil
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|tc_cons
case|:
name|hash
operator|=
name|c_sxhash
argument_list|(
name|CAR
argument_list|(
name|obj
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|CDR
argument_list|(
name|obj
argument_list|)
init|;
name|CONSP
argument_list|(
name|tmp
argument_list|)
condition|;
name|tmp
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
name|c_sxhash
argument_list|(
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
name|c_sxhash
argument_list|(
name|tmp
argument_list|,
name|n
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
case|case
name|tc_symbol
case|:
for|for
control|(
name|hash
operator|=
literal|0
operator|,
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|PNAME
argument_list|(
name|obj
argument_list|)
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
operator|*
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
case|case
name|tc_subr_0
case|:
case|case
name|tc_subr_1
case|:
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_3
case|:
case|case
name|tc_subr_4
case|:
case|case
name|tc_subr_5
case|:
case|case
name|tc_lsubr
case|:
case|case
name|tc_fsubr
case|:
case|case
name|tc_msubr
case|:
for|for
control|(
name|hash
operator|=
literal|0
operator|,
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|obj
operator|->
name|storage_as
operator|.
name|subr
operator|.
name|name
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
operator|*
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
case|case
name|tc_flonum
case|:
return|return
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|FLONM
argument_list|(
name|obj
argument_list|)
operator|)
operator|%
name|n
operator|)
return|;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_sxhash
condition|)
return|return
operator|(
call|(
modifier|*
name|p
operator|->
name|c_sxhash
call|)
argument_list|(
name|obj
argument_list|,
name|n
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|sxhash (LISP obj,LISP n)
name|sxhash
parameter_list|(
name|LISP
name|obj
parameter_list|,
name|LISP
name|n
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|c_sxhash
argument_list|(
name|obj
argument_list|,
name|FLONUMP
argument_list|(
name|n
argument_list|)
condition|?
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|n
argument_list|)
else|:
literal|10000
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|equal (LISP a,LISP b)
name|equal
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|long
name|atype
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|loop
label|:
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
if|if EQ
condition|(
name|a
operator|,
name|b
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
name|atype
operator|=
name|TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|atype
operator|!=
name|TYPE
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
switch|switch
condition|(
name|atype
condition|)
block|{
case|case
name|tc_cons
case|:
if|if NULLP
condition|(
name|equal
argument_list|(
name|car
argument_list|(
name|a
argument_list|)
argument_list|,
name|car
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|a
operator|=
name|cdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|cdr
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|tc_flonum
case|:
return|return
operator|(
operator|(
name|FLONM
argument_list|(
name|a
argument_list|)
operator|==
name|FLONM
argument_list|(
name|b
argument_list|)
operator|)
condition|?
name|sym_t
else|:
name|NIL
operator|)
return|;
case|case
name|tc_symbol
case|:
return|return
operator|(
name|NIL
operator|)
return|;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|equal
condition|)
return|return
operator|(
call|(
modifier|*
name|p
operator|->
name|equal
call|)
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|array_equal (LISP a,LISP b)
name|array_equal
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|len
decl_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|b
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|b
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_long_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|b
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
argument_list|,
name|b
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_double_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|b
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|j
index|]
operator|!=
name|b
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
index|[
name|j
index|]
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|sym_t
operator|)
return|;
case|case
name|tc_lisp_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|b
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
if|if NULLP
condition|(
name|equal
argument_list|(
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|,
name|b
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|sym_t
operator|)
return|;
default|default:
return|return
operator|(
name|errswitch
argument_list|()
operator|)
return|;
block|}
block|}
end_function

begin_function
name|long
DECL|function|array_sxhash (LISP a,long n)
name|array_sxhash
parameter_list|(
name|LISP
name|a
parameter_list|,
name|long
name|n
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|len
decl_stmt|,
name|hash
decl_stmt|;
name|unsigned
name|char
modifier|*
name|char_data
decl_stmt|;
name|unsigned
name|long
modifier|*
name|long_data
decl_stmt|;
name|double
modifier|*
name|double_data
decl_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
operator|,
name|char_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|a
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
operator|,
operator|++
name|char_data
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
operator|*
name|char_data
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
case|case
name|tc_long_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
operator|,
name|long_data
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|a
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
operator|,
operator|++
name|long_data
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
operator|*
name|long_data
operator|%
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
case|case
name|tc_double_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
operator|,
name|double_data
operator|=
name|a
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
operator|,
operator|++
name|double_data
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|*
name|double_data
operator|%
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
case|case
name|tc_lisp_array
case|:
name|len
operator|=
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
name|hash
operator|=
name|HASH_COMBINE
argument_list|(
name|hash
argument_list|,
name|c_sxhash
argument_list|(
name|a
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|,
name|n
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
default|default:
name|errswitch
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|long
DECL|function|href_index (LISP table,LISP key)
name|href_index
parameter_list|(
name|LISP
name|table
parameter_list|,
name|LISP
name|key
parameter_list|)
block|{
name|long
name|index
decl_stmt|;
if|if NTYPEP
condition|(
name|table
operator|,
name|tc_lisp_array
condition|)
name|err
argument_list|(
literal|"not a hash table"
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|index
operator|=
name|c_sxhash
argument_list|(
name|key
argument_list|,
name|table
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|table
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
operator|)
condition|)
block|{
name|err
argument_list|(
literal|"sxhash inconsistency"
argument_list|,
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|href (LISP table,LISP key)
name|href
parameter_list|(
name|LISP
name|table
parameter_list|,
name|LISP
name|key
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|assoc
argument_list|(
name|key
argument_list|,
name|table
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|href_index
argument_list|(
name|table
argument_list|,
name|key
argument_list|)
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|hset (LISP table,LISP key,LISP value)
name|hset
parameter_list|(
name|LISP
name|table
parameter_list|,
name|LISP
name|key
parameter_list|,
name|LISP
name|value
parameter_list|)
block|{
name|long
name|index
decl_stmt|;
name|LISP
name|cell
decl_stmt|,
name|l
decl_stmt|;
name|index
operator|=
name|href_index
argument_list|(
name|table
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|l
operator|=
name|table
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|index
index|]
expr_stmt|;
if|if NNULLP
condition|(
name|cell
operator|=
name|assoc
argument_list|(
name|key
argument_list|,
name|l
argument_list|)
condition|)
return|return
operator|(
name|setcdr
argument_list|(
name|cell
argument_list|,
name|value
argument_list|)
operator|)
return|;
name|cell
operator|=
name|cons
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|table
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|index
index|]
operator|=
name|cons
argument_list|(
name|cell
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|assoc (LISP x,LISP alist)
name|assoc
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|alist
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|alist
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSP
argument_list|(
name|tmp
argument_list|)
operator|&&
name|equal
argument_list|(
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|err
argument_list|(
literal|"improper list to assoc"
argument_list|,
name|alist
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|assv (LISP x,LISP alist)
name|assv
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|alist
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|alist
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSP
argument_list|(
name|tmp
argument_list|)
operator|&&
name|NNULLP
argument_list|(
name|eql
argument_list|(
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|err
argument_list|(
literal|"improper list to assv"
argument_list|,
name|alist
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|put_long (long i,FILE * f)
name|put_long
parameter_list|(
name|long
name|i
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|fwrite
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
DECL|function|get_long (FILE * f)
name|get_long
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
name|fread
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|fast_print_table (LISP obj,LISP table)
name|fast_print_table
parameter_list|(
name|LISP
name|obj
parameter_list|,
name|LISP
name|table
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|LISP
name|ht
decl_stmt|,
name|index
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|car
argument_list|(
name|table
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|ht
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|table
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|index
operator|=
name|href
argument_list|(
name|ht
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
name|FO_fetch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|get_c_long
argument_list|(
name|index
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if NULLP
condition|(
name|index
operator|=
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|table
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hset
argument_list|(
name|ht
argument_list|,
name|obj
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|FLONM
argument_list|(
name|bashnum
argument_list|)
operator|=
literal|1.0
expr_stmt|;
name|setcar
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|table
argument_list|)
argument_list|)
argument_list|,
name|plus
argument_list|(
name|index
argument_list|,
name|bashnum
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|FO_store
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|get_c_long
argument_list|(
name|index
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|fast_print (LISP obj,LISP table)
name|fast_print
parameter_list|(
name|LISP
name|obj
parameter_list|,
name|LISP
name|table
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|len
decl_stmt|;
name|LISP
name|tmp
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|obj
argument_list|)
expr_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|car
argument_list|(
name|table
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|obj
argument_list|)
condition|)
block|{
case|case
name|tc_nil
case|:
name|putc
argument_list|(
name|tc_nil
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_cons
case|:
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|tmp
operator|=
name|obj
init|;
name|CONSP
argument_list|(
name|tmp
argument_list|)
condition|;
name|tmp
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|putc
argument_list|(
name|tc_cons
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fast_print
argument_list|(
name|car
argument_list|(
name|obj
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|fast_print
argument_list|(
name|cdr
argument_list|(
name|obj
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if NULLP
condition|(
name|tmp
condition|)
block|{
name|putc
argument_list|(
name|FO_list
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|obj
init|;
name|CONSP
argument_list|(
name|tmp
argument_list|)
condition|;
name|tmp
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
control|)
name|fast_print
argument_list|(
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
name|FO_listd
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|obj
init|;
name|CONSP
argument_list|(
name|tmp
argument_list|)
condition|;
name|tmp
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
control|)
name|fast_print
argument_list|(
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|fast_print
argument_list|(
name|tmp
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_flonum
case|:
name|putc
argument_list|(
name|tc_flonum
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|obj
operator|->
name|storage_as
operator|.
name|flonum
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
operator|->
name|storage_as
operator|.
name|flonum
operator|.
name|data
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_symbol
case|:
if|if
condition|(
name|fast_print_table
argument_list|(
name|obj
argument_list|,
name|table
argument_list|)
condition|)
block|{
name|putc
argument_list|(
name|tc_symbol
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|PNAME
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TKBUFFERN
condition|)
name|err
argument_list|(
literal|"symbol name too long"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|PNAME
argument_list|(
name|obj
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NIL
operator|)
return|;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fast_print
condition|)
return|return
operator|(
call|(
modifier|*
name|p
operator|->
name|fast_print
call|)
argument_list|(
name|obj
argument_list|,
name|table
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|err
argument_list|(
literal|"cannot fast-print"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|fast_read (LISP table)
name|fast_read
parameter_list|(
name|LISP
name|table
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|LISP
name|tmp
decl_stmt|,
name|l
decl_stmt|;
name|struct
name|user_type_hooks
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|len
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|car
argument_list|(
name|table
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|table
operator|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FO_comment
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
return|return
operator|(
name|table
operator|)
return|;
case|case
literal|'\n'
case|:
return|return
operator|(
name|fast_read
argument_list|(
name|table
argument_list|)
operator|)
return|;
block|}
case|case
name|FO_fetch
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|FLONM
argument_list|(
name|bashnum
argument_list|)
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|href
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|table
argument_list|)
argument_list|)
argument_list|,
name|bashnum
argument_list|)
operator|)
return|;
case|case
name|FO_store
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|fast_read
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|hset
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|table
argument_list|)
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|len
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
case|case
name|tc_nil
case|:
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_cons
case|:
name|tmp
operator|=
name|fast_read
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|cons
argument_list|(
name|tmp
argument_list|,
name|fast_read
argument_list|(
name|table
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|FO_list
case|:
case|case
name|FO_listd
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|FLONM
argument_list|(
name|bashnum
argument_list|)
operator|=
name|len
expr_stmt|;
name|l
operator|=
name|make_list
argument_list|(
name|bashnum
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|l
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|=
name|fast_read
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|CDR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|CAR
argument_list|(
name|tmp
argument_list|)
operator|=
name|fast_read
argument_list|(
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|FO_listd
condition|)
name|CDR
argument_list|(
name|tmp
argument_list|)
operator|=
name|fast_read
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
case|case
name|tc_flonum
case|:
name|tmp
operator|=
name|newcell
argument_list|(
name|tc_flonum
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|tmp
operator|->
name|storage_as
operator|.
name|flonum
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
operator|->
name|storage_as
operator|.
name|flonum
operator|.
name|data
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
case|case
name|tc_symbol
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TKBUFFERN
condition|)
name|err
argument_list|(
literal|"symbol name too long"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|tkbuffer
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|tkbuffer
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rintern
argument_list|(
name|tkbuffer
argument_list|)
operator|)
return|;
default|default:
name|p
operator|=
name|get_user_type_hooks
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fast_read
condition|)
return|return
call|(
modifier|*
name|p
operator|->
name|fast_read
call|)
argument_list|(
name|c
argument_list|,
name|table
argument_list|)
return|;
else|else
return|return
operator|(
name|err
argument_list|(
literal|"unknown fast-read opcode"
argument_list|,
name|flocons
argument_list|(
name|c
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|array_fast_print (LISP ptr,LISP table)
name|array_fast_print
parameter_list|(
name|LISP
name|ptr
parameter_list|,
name|LISP
name|table
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|len
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|car
argument_list|(
name|table
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|type
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
name|putc
argument_list|(
name|ptr
operator|->
name|type
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|len
operator|=
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_double_array
case|:
name|putc
argument_list|(
name|tc_double_array
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|len
operator|=
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_long_array
case|:
name|putc
argument_list|(
name|tc_long_array
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|len
operator|=
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
case|case
name|tc_lisp_array
case|:
name|putc
argument_list|(
name|tc_lisp_array
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|len
operator|=
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
expr_stmt|;
name|put_long
argument_list|(
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
name|fast_print
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|,
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
default|default:
return|return
operator|(
name|errswitch
argument_list|()
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|array_fast_read (int code,LISP table)
name|array_fast_read
parameter_list|(
name|int
name|code
parameter_list|,
name|LISP
name|table
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|len
decl_stmt|,
name|iflag
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|LISP
name|ptr
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|car
argument_list|(
name|table
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|tc_string
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strcons
argument_list|(
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
case|case
name|tc_byte_array
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|iflag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|newcell
argument_list|(
name|tc_byte_array
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|len
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
case|case
name|tc_double_array
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|iflag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|newcell
argument_list|(
name|tc_double_array
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
operator|=
name|len
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
operator|=
operator|(
name|double
operator|*
operator|)
name|must_malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
case|case
name|tc_long_array
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|iflag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|newcell
argument_list|(
name|tc_long_array
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
operator|=
name|len
expr_stmt|;
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
operator|=
operator|(
name|long
operator|*
operator|)
name|must_malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|ptr
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
case|case
name|tc_lisp_array
case|:
name|len
operator|=
name|get_long
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|FLONM
argument_list|(
name|bashnum
argument_list|)
operator|=
name|len
expr_stmt|;
name|ptr
operator|=
name|cons_array
argument_list|(
name|bashnum
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
name|ptr
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
operator|=
name|fast_read
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
default|default:
return|return
operator|(
name|errswitch
argument_list|()
operator|)
return|;
block|}
block|}
end_function

begin_function
name|long
DECL|function|get_c_long (LISP x)
name|get_c_long
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|err
argument_list|(
literal|"not a number"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|FLONM
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|double
DECL|function|get_c_double (LISP x)
name|get_c_double
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|err
argument_list|(
literal|"not a number"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|FLONM
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|make_list (LISP x,LISP v)
name|make_list
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|v
parameter_list|)
block|{
name|long
name|n
decl_stmt|;
name|LISP
name|l
decl_stmt|;
name|n
operator|=
name|get_c_long
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|l
operator|=
name|NIL
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|cons
argument_list|(
name|v
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lfread (LISP size,LISP file)
name|lfread
parameter_list|(
name|LISP
name|size
parameter_list|,
name|LISP
name|file
parameter_list|)
block|{
name|long
name|flag
decl_stmt|,
name|n
decl_stmt|,
name|ret
decl_stmt|,
name|m
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|LISP
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|file
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|size
argument_list|)
condition|)
block|{
case|case
name|tc_string
case|:
case|case
name|tc_byte_array
case|:
name|s
operator|=
name|size
expr_stmt|;
name|buffer
operator|=
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|n
operator|=
name|get_c_long
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|must_malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|n
condition|)
block|{
name|s
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|tc_string
expr_stmt|;
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|strcons
argument_list|(
name|ret
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|,
name|buffer
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
operator|(
name|double
operator|)
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lfwrite (LISP string,LISP file)
name|lfwrite
parameter_list|(
name|LISP
name|string
parameter_list|,
name|LISP
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|flag
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|long
name|dim
decl_stmt|,
name|len
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|file
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|data
operator|=
name|get_c_string_dim
argument_list|(
name|CONSP
argument_list|(
name|string
argument_list|)
condition|?
name|car
argument_list|(
name|string
argument_list|)
else|:
name|string
argument_list|,
operator|&
name|dim
argument_list|)
expr_stmt|;
name|len
operator|=
name|CONSP
argument_list|(
name|string
argument_list|)
condition|?
name|get_c_long
argument_list|(
name|cadr
argument_list|(
name|string
argument_list|)
argument_list|)
else|:
name|dim
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|len
operator|>
name|dim
condition|)
name|err
argument_list|(
literal|"write length too long"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lfflush (LISP file)
name|lfflush
parameter_list|(
name|LISP
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|flag
decl_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|file
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|flag
operator|=
name|no_interrupt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|no_interrupt
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_length (LISP string)
name|string_length
parameter_list|(
name|LISP
name|string
parameter_list|)
block|{
if|if NTYPEP
condition|(
name|string
operator|,
name|tc_string
condition|)
name|err_wta_str
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|strlen
argument_list|(
name|string
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_dim (LISP string)
name|string_dim
parameter_list|(
name|LISP
name|string
parameter_list|)
block|{
if|if NTYPEP
condition|(
name|string
operator|,
name|tc_string
condition|)
name|err_wta_str
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
operator|(
name|double
operator|)
name|string
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|nlength (LISP obj)
name|nlength
parameter_list|(
name|LISP
name|obj
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
name|long
name|n
decl_stmt|;
switch|switch TYPE
condition|(
name|obj
condition|)
block|{
case|case
name|tc_string
case|:
return|return
operator|(
name|strlen
argument_list|(
name|obj
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
argument_list|)
operator|)
return|;
case|case
name|tc_byte_array
case|:
return|return
operator|(
name|obj
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
operator|)
return|;
case|case
name|tc_double_array
case|:
return|return
operator|(
name|obj
operator|->
name|storage_as
operator|.
name|double_array
operator|.
name|dim
operator|)
return|;
case|case
name|tc_long_array
case|:
return|return
operator|(
name|obj
operator|->
name|storage_as
operator|.
name|long_array
operator|.
name|dim
operator|)
return|;
case|case
name|tc_lisp_array
case|:
return|return
operator|(
name|obj
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
operator|)
return|;
case|case
name|tc_nil
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|tc_cons
case|:
for|for
control|(
name|l
operator|=
name|obj
operator|,
name|n
operator|=
literal|0
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
operator|,
operator|++
name|n
control|)
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
if|if NNULLP
condition|(
name|l
condition|)
name|err
argument_list|(
literal|"improper list to length"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
default|default:
name|err
argument_list|(
literal|"wta to length"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|llength (LISP obj)
name|llength
parameter_list|(
name|LISP
name|obj
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|nlength
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|number2string (LISP x,LISP b,LISP w,LISP p)
name|number2string
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|b
parameter_list|,
name|LISP
name|w
parameter_list|,
name|LISP
name|p
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|double
name|y
decl_stmt|;
name|long
name|base
decl_stmt|,
name|width
decl_stmt|,
name|prec
decl_stmt|;
if|if NFLONUMP
condition|(
name|x
condition|)
name|err
argument_list|(
literal|"wta"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|FLONM
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|width
operator|=
name|NNULLP
argument_list|(
name|w
argument_list|)
condition|?
name|get_c_long
argument_list|(
name|w
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|100
condition|)
name|err
argument_list|(
literal|"width too long"
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|prec
operator|=
name|NNULLP
argument_list|(
name|p
argument_list|)
condition|?
name|get_c_long
argument_list|(
name|p
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prec
operator|>
literal|100
condition|)
name|err
argument_list|(
literal|"precision too large"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULLP
argument_list|(
name|b
argument_list|)
operator|||
name|EQ
argument_list|(
name|sym_e
argument_list|,
name|b
argument_list|)
operator|||
name|EQ
argument_list|(
name|sym_f
argument_list|,
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|prec
operator|>=
literal|0
operator|)
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|NULLP
argument_list|(
name|b
argument_list|)
condition|?
literal|"% *.*g"
else|:
name|EQ
argument_list|(
name|sym_e
argument_list|,
name|b
argument_list|)
condition|?
literal|"% *.*e"
else|:
literal|"% *.*f"
argument_list|,
name|width
argument_list|,
name|prec
argument_list|,
name|y
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|NULLP
argument_list|(
name|b
argument_list|)
condition|?
literal|"% *g"
else|:
name|EQ
argument_list|(
name|sym_e
argument_list|,
name|b
argument_list|)
condition|?
literal|"% *e"
else|:
literal|"% *f"
argument_list|,
name|width
argument_list|,
name|y
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|NULLP
argument_list|(
name|b
argument_list|)
condition|?
literal|"%.*g"
else|:
name|EQ
argument_list|(
name|sym_e
argument_list|,
name|b
argument_list|)
condition|?
literal|"%.*e"
else|:
literal|"%.*f"
argument_list|,
name|prec
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|NULLP
argument_list|(
name|b
argument_list|)
condition|?
literal|"%g"
else|:
name|EQ
argument_list|(
name|sym_e
argument_list|,
name|b
argument_list|)
condition|?
literal|"%e"
else|:
literal|"%f"
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|base
operator|=
name|get_c_long
argument_list|(
name|b
argument_list|)
operator|)
operator|==
literal|10
operator|)
operator|||
operator|(
name|base
operator|==
literal|8
operator|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|width
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
operator|(
name|base
operator|==
literal|10
operator|)
condition|?
literal|"%0*ld"
else|:
operator|(
name|base
operator|==
literal|8
operator|)
condition|?
literal|"%0*lo"
else|:
literal|"%0*lX"
argument_list|,
name|width
argument_list|,
operator|(
name|long
operator|)
name|y
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
operator|(
name|base
operator|==
literal|10
operator|)
condition|?
literal|"%ld"
else|:
operator|(
name|base
operator|==
literal|8
operator|)
condition|?
literal|"%lo"
else|:
literal|"%lX"
argument_list|,
operator|(
name|long
operator|)
name|y
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"number base not handled"
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcons
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string2number (LISP x,LISP b)
name|string2number
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|long
name|base
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
name|double
name|result
init|=
literal|0.0
decl_stmt|;
name|str
operator|=
name|get_c_string
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|b
condition|)
name|result
operator|=
name|atof
argument_list|(
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|base
operator|=
name|get_c_long
argument_list|(
name|b
argument_list|)
operator|)
operator|==
literal|10
condition|)
block|{
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|double
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|8
condition|)
block|{
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%lo"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|double
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|double
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|base
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|base
operator|<=
literal|16
operator|)
condition|)
block|{
for|for
control|(
name|result
operator|=
literal|0.0
init|;
operator|*
name|str
condition|;
operator|++
name|str
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|result
operator|=
name|result
operator|*
name|base
operator|+
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|result
operator|=
name|result
operator|*
name|base
operator|+
name|toupper
argument_list|(
operator|*
name|str
argument_list|)
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"number base not handled"
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrcmp (LISP s1,LISP s2)
name|lstrcmp
parameter_list|(
name|LISP
name|s1
parameter_list|,
name|LISP
name|s2
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|strcmp
argument_list|(
name|get_c_string
argument_list|(
name|s1
argument_list|)
argument_list|,
name|get_c_string
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|chk_string (LISP s,char ** data,long * dim)
name|chk_string
parameter_list|(
name|LISP
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|long
modifier|*
name|dim
parameter_list|)
block|{
if|if TYPEP
condition|(
name|s
operator|,
name|tc_string
condition|)
block|{
operator|*
name|data
operator|=
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
expr_stmt|;
operator|*
name|dim
operator|=
name|s
operator|->
name|storage_as
operator|.
name|string
operator|.
name|dim
expr_stmt|;
block|}
else|else
name|err_wta_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrcpy (LISP dest,LISP src)
name|lstrcpy
parameter_list|(
name|LISP
name|dest
parameter_list|,
name|LISP
name|src
parameter_list|)
block|{
name|long
name|ddim
decl_stmt|,
name|slen
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|chk_string
argument_list|(
name|dest
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|ddim
argument_list|)
expr_stmt|;
name|s
operator|=
name|get_c_string
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|>
name|ddim
condition|)
name|err
argument_list|(
literal|"string too long"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|d
index|[
name|slen
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrcat (LISP dest,LISP src)
name|lstrcat
parameter_list|(
name|LISP
name|dest
parameter_list|,
name|LISP
name|src
parameter_list|)
block|{
name|long
name|ddim
decl_stmt|,
name|dlen
decl_stmt|,
name|slen
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|chk_string
argument_list|(
name|dest
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|ddim
argument_list|)
expr_stmt|;
name|s
operator|=
name|get_c_string
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slen
operator|+
name|dlen
operator|)
operator|>
name|ddim
condition|)
name|err
argument_list|(
literal|"string too long"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|d
index|[
name|dlen
index|]
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|d
index|[
name|dlen
operator|+
name|slen
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrbreakup (LISP str,LISP lmarker)
name|lstrbreakup
parameter_list|(
name|LISP
name|str
parameter_list|,
name|LISP
name|lmarker
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|marker
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|LISP
name|result
init|=
name|NIL
decl_stmt|;
name|start
operator|=
name|get_c_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|marker
operator|=
name|get_c_string
argument_list|(
name|lmarker
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|marker
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|start
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|end
operator|=
name|strstr
argument_list|(
name|start
argument_list|,
name|marker
argument_list|)
operator|)
condition|)
name|end
operator|=
operator|&
name|start
index|[
name|strlen
argument_list|(
name|start
argument_list|)
index|]
expr_stmt|;
name|result
operator|=
name|cons
argument_list|(
name|strcons
argument_list|(
name|end
operator|-
name|start
argument_list|,
name|start
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
operator|*
name|end
operator|)
condition|?
name|end
operator|+
name|k
else|:
name|end
expr_stmt|;
block|}
return|return
operator|(
name|nreverse
argument_list|(
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrunbreakup (LISP elems,LISP lmarker)
name|lstrunbreakup
parameter_list|(
name|LISP
name|elems
parameter_list|,
name|LISP
name|lmarker
parameter_list|)
block|{
name|LISP
name|result
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|elems
operator|,
name|result
operator|=
name|NIL
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
if|if EQ
condition|(
name|l
operator|,
name|elems
condition|)
name|result
operator|=
name|cons
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|cons
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|cons
argument_list|(
name|lmarker
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|string_append
argument_list|(
name|nreverse
argument_list|(
name|result
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|stringp (LISP x)
name|stringp
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|TYPEP
argument_list|(
name|x
argument_list|,
name|tc_string
argument_list|)
condition|?
name|sym_t
else|:
name|NIL
operator|)
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|base64_encode_table
specifier|static
name|char
modifier|*
name|base64_encode_table
init|=
literal|"\ ABCDEFGHIJKLMNOPQRSTUVWXYZ\ abcdefghijklmnopqrstuvwxyz\ 0123456789+/="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|base64_decode_table
specifier|static
name|char
modifier|*
name|base64_decode_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|init_base64_table (void)
name|init_base64_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|base64_decode_table
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|base64_decode_table
argument_list|,
operator|-
literal|1
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|65
condition|;
operator|++
name|j
control|)
name|base64_decode_table
index|[
operator|(
name|unsigned
name|char
operator|)
name|base64_encode_table
index|[
name|j
index|]
index|]
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_define
DECL|macro|BITMSK (N)
define|#
directive|define
name|BITMSK
parameter_list|(
name|N
parameter_list|)
value|((1<< (N)) - 1)
end_define

begin_define
DECL|macro|ITEM1 (X)
define|#
directive|define
name|ITEM1
parameter_list|(
name|X
parameter_list|)
value|(X>> 2)& BITMSK(6)
end_define

begin_define
DECL|macro|ITEM2 (X,Y)
define|#
directive|define
name|ITEM2
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X& BITMSK(2))<< 4) | ((Y>> 4)& BITMSK(4))
end_define

begin_define
DECL|macro|ITEM3 (X,Y)
define|#
directive|define
name|ITEM3
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X& BITMSK(4))<< 2) | ((Y>> 6)& BITMSK(2))
end_define

begin_define
DECL|macro|ITEM4 (X)
define|#
directive|define
name|ITEM4
parameter_list|(
name|X
parameter_list|)
value|X& BITMSK(6)
end_define

begin_function
name|LISP
DECL|function|base64encode (LISP in)
name|base64encode
parameter_list|(
name|LISP
name|in
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
init|=
name|base64_encode_table
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|LISP
name|out
decl_stmt|;
name|long
name|j
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|chunks
decl_stmt|,
name|leftover
decl_stmt|;
name|s
operator|=
name|get_c_string_dim
argument_list|(
name|in
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|chunks
operator|=
name|n
operator|/
literal|3
expr_stmt|;
name|leftover
operator|=
name|n
operator|%
literal|3
expr_stmt|;
name|m
operator|=
operator|(
name|chunks
operator|+
operator|(
operator|(
name|leftover
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
literal|4
expr_stmt|;
name|out
operator|=
name|strcons
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|get_c_string
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
init|;
name|j
operator|<
name|chunks
condition|;
operator|++
name|j
operator|,
name|p1
operator|+=
literal|3
control|)
block|{
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM1
argument_list|(
name|p1
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM2
argument_list|(
name|p1
index|[
literal|0
index|]
argument_list|,
name|p1
index|[
literal|1
index|]
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM3
argument_list|(
name|p1
index|[
literal|1
index|]
argument_list|,
name|p1
index|[
literal|2
index|]
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM4
argument_list|(
name|p1
index|[
literal|2
index|]
argument_list|)
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|leftover
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM1
argument_list|(
name|p1
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM2
argument_list|(
name|p1
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|base64_encode_table
index|[
literal|64
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|base64_encode_table
index|[
literal|64
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM1
argument_list|(
name|p1
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM2
argument_list|(
name|p1
index|[
literal|0
index|]
argument_list|,
name|p1
index|[
literal|1
index|]
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|t
index|[
name|ITEM3
argument_list|(
name|p1
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|base64_encode_table
index|[
literal|64
index|]
expr_stmt|;
break|break;
default|default:
name|errswitch
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|base64decode (LISP in)
name|base64decode
parameter_list|(
name|LISP
name|in
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
init|=
name|base64_decode_table
decl_stmt|;
name|LISP
name|out
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|long
name|j
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|chunks
decl_stmt|,
name|leftover
decl_stmt|,
name|item1
decl_stmt|,
name|item2
decl_stmt|,
name|item3
decl_stmt|,
name|item4
decl_stmt|;
name|s
operator|=
name|get_c_string
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|strcons
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|%
literal|4
condition|)
name|err
argument_list|(
literal|"illegal base64 data length"
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|n
operator|-
literal|1
index|]
operator|==
name|base64_encode_table
index|[
literal|64
index|]
condition|)
block|{
if|if
condition|(
name|s
index|[
name|n
operator|-
literal|2
index|]
operator|==
name|base64_encode_table
index|[
literal|64
index|]
condition|)
name|leftover
operator|=
literal|1
expr_stmt|;
else|else
name|leftover
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|leftover
operator|=
literal|0
expr_stmt|;
name|chunks
operator|=
operator|(
name|n
operator|/
literal|4
operator|)
operator|-
operator|(
operator|(
name|leftover
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|m
operator|=
operator|(
name|chunks
operator|*
literal|3
operator|)
operator|+
name|leftover
expr_stmt|;
name|out
operator|=
name|strcons
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|get_c_string
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
init|;
name|j
operator|<
name|chunks
condition|;
operator|++
name|j
operator|,
name|p1
operator|+=
literal|4
control|)
block|{
if|if
condition|(
operator|(
name|item1
operator|=
name|t
index|[
name|p1
index|[
literal|0
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
name|item2
operator|=
name|t
index|[
name|p1
index|[
literal|1
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
name|item3
operator|=
name|t
index|[
name|p1
index|[
literal|2
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
name|item4
operator|=
name|t
index|[
name|p1
index|[
literal|3
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
operator|*
name|p2
operator|++
operator|=
operator|(
name|item1
operator|<<
literal|2
operator|)
operator||
operator|(
name|item2
operator|>>
literal|4
operator|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
operator|(
name|item2
operator|<<
literal|4
operator|)
operator||
operator|(
name|item3
operator|>>
literal|2
operator|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
operator|(
name|item3
operator|<<
literal|6
operator|)
operator||
name|item4
expr_stmt|;
block|}
switch|switch
condition|(
name|leftover
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|item1
operator|=
name|t
index|[
name|p1
index|[
literal|0
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
name|item2
operator|=
name|t
index|[
name|p1
index|[
literal|1
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
operator|*
name|p2
operator|++
operator|=
operator|(
name|item1
operator|<<
literal|2
operator|)
operator||
operator|(
name|item2
operator|>>
literal|4
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|item1
operator|=
name|t
index|[
name|p1
index|[
literal|0
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
name|item2
operator|=
name|t
index|[
name|p1
index|[
literal|1
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|(
name|item3
operator|=
name|t
index|[
name|p1
index|[
literal|2
index|]
index|]
operator|)
operator|&
operator|~
name|BITMSK
argument_list|(
literal|6
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
operator|*
name|p2
operator|++
operator|=
operator|(
name|item1
operator|<<
literal|2
operator|)
operator||
operator|(
name|item2
operator|>>
literal|4
operator|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
operator|(
name|item2
operator|<<
literal|4
operator|)
operator||
operator|(
name|item3
operator|>>
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|errswitch
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|memq (LISP x,LISP il)
name|memq
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|il
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|il
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|x
operator|,
name|tmp
condition|)
return|return
operator|(
name|l
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|err
argument_list|(
literal|"improper list to memq"
argument_list|,
name|il
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|member (LISP x,LISP il)
name|member
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|il
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|il
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|equal
argument_list|(
name|x
argument_list|,
name|tmp
argument_list|)
condition|)
return|return
operator|(
name|l
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|err
argument_list|(
literal|"improper list to member"
argument_list|,
name|il
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|memv (LISP x,LISP il)
name|memv
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|il
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|il
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|eql
argument_list|(
name|x
argument_list|,
name|tmp
argument_list|)
condition|)
return|return
operator|(
name|l
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|err
argument_list|(
literal|"improper list to memv"
argument_list|,
name|il
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|nth (LISP x,LISP li)
name|nth
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|li
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
init|=
name|get_c_long
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|li
init|;
operator|(
name|j
operator|<
name|n
operator|)
operator|&&
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
operator|++
name|j
control|)
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if CONSP
condition|(
name|l
condition|)
return|return
operator|(
name|CAR
argument_list|(
name|l
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|err
argument_list|(
literal|"bad arg to nth"
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* these lxxx_default functions are convenient for manipulating    command-line argument lists */
end_comment

begin_function
name|LISP
DECL|function|lref_default (LISP li,LISP x,LISP fcn)
name|lref_default
parameter_list|(
name|LISP
name|li
parameter_list|,
name|LISP
name|x
parameter_list|,
name|LISP
name|fcn
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
name|long
name|j
decl_stmt|,
name|n
init|=
name|get_c_long
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|li
init|;
operator|(
name|j
operator|<
name|n
operator|)
operator|&&
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
operator|++
name|j
control|)
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if CONSP
condition|(
name|l
condition|)
return|return
operator|(
name|CAR
argument_list|(
name|l
argument_list|)
operator|)
return|;
elseif|else
if|if NNULLP
condition|(
name|fcn
condition|)
return|return
operator|(
name|lapply
argument_list|(
name|fcn
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|larg_default (LISP li,LISP x,LISP dval)
name|larg_default
parameter_list|(
name|LISP
name|li
parameter_list|,
name|LISP
name|x
parameter_list|,
name|LISP
name|dval
parameter_list|)
block|{
name|LISP
name|l
init|=
name|li
decl_stmt|,
name|elem
decl_stmt|;
name|long
name|j
init|=
literal|0
decl_stmt|,
name|n
init|=
name|get_c_long
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while NNULLP
condition|(
name|l
condition|)
block|{
name|elem
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPEP
argument_list|(
name|elem
argument_list|,
name|tc_string
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"-:"
argument_list|,
operator|*
name|get_c_string
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
name|n
condition|)
return|return
operator|(
name|elem
operator|)
return|;
else|else
block|{
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dval
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lkey_default (LISP li,LISP key,LISP dval)
name|lkey_default
parameter_list|(
name|LISP
name|li
parameter_list|,
name|LISP
name|key
parameter_list|,
name|LISP
name|dval
parameter_list|)
block|{
name|LISP
name|l
init|=
name|li
decl_stmt|,
name|elem
decl_stmt|;
name|char
modifier|*
name|ckey
decl_stmt|,
modifier|*
name|celem
decl_stmt|;
name|long
name|n
decl_stmt|;
name|ckey
operator|=
name|get_c_string
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|ckey
argument_list|)
expr_stmt|;
while|while NNULLP
condition|(
name|l
condition|)
block|{
name|elem
operator|=
name|car
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPEP
argument_list|(
name|elem
argument_list|,
name|tc_string
argument_list|)
operator|&&
operator|(
operator|*
operator|(
name|celem
operator|=
name|get_c_string
argument_list|(
name|elem
argument_list|)
operator|)
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
operator|&
name|celem
index|[
literal|1
index|]
argument_list|,
name|ckey
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|celem
index|[
name|n
operator|+
literal|1
index|]
operator|==
literal|'='
operator|)
condition|)
return|return
operator|(
name|strcons
argument_list|(
name|strlen
argument_list|(
operator|&
name|celem
index|[
name|n
operator|+
literal|2
index|]
argument_list|)
argument_list|,
operator|&
name|celem
index|[
name|n
operator|+
literal|2
index|]
argument_list|)
operator|)
return|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dval
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|llist (LISP l)
name|llist
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|writes1 (FILE * f,LISP l)
name|writes1
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|LISP
name|l
parameter_list|)
block|{
name|LISP
name|v
decl_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
for|for
control|(
name|v
operator|=
name|l
init|;
name|CONSP
argument_list|(
name|v
argument_list|)
condition|;
name|v
operator|=
name|CDR
argument_list|(
name|v
argument_list|)
control|)
name|writes1
argument_list|(
name|f
argument_list|,
name|CAR
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
switch|switch TYPE
condition|(
name|v
condition|)
block|{
case|case
name|tc_nil
case|:
break|break;
case|case
name|tc_symbol
case|:
case|case
name|tc_string
case|:
name|fput_st
argument_list|(
name|f
argument_list|,
name|get_c_string
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lprin1f
argument_list|(
name|v
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|writes (LISP args)
name|writes
parameter_list|(
name|LISP
name|args
parameter_list|)
block|{
return|return
operator|(
name|writes1
argument_list|(
name|get_c_file
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|stdout
argument_list|)
argument_list|,
name|cdr
argument_list|(
name|args
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|last (LISP l)
name|last
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
name|LISP
name|v1
decl_stmt|,
name|v2
decl_stmt|;
name|v1
operator|=
name|l
expr_stmt|;
name|v2
operator|=
name|CONSP
argument_list|(
name|v1
argument_list|)
condition|?
name|CDR
argument_list|(
name|v1
argument_list|)
else|:
name|err
argument_list|(
literal|"bad arg to last"
argument_list|,
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|CONSP
argument_list|(
name|v2
argument_list|)
condition|)
block|{
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
name|v1
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|CDR
argument_list|(
name|v2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|v1
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|butlast (LISP l)
name|butlast
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
name|STACK_CHECK
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|l
condition|)
name|err
argument_list|(
literal|"list is empty"
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if CONSP
condition|(
name|l
condition|)
block|{
if|if NULLP
condition|(
name|CDR
argument_list|(
name|l
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
else|else
return|return
operator|(
name|cons
argument_list|(
name|CAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|butlast
argument_list|(
name|CDR
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|err
argument_list|(
literal|"not a list"
argument_list|,
name|l
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|nconc (LISP a,LISP b)
name|nconc
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
if|if NULLP
condition|(
name|a
condition|)
return|return
operator|(
name|b
operator|)
return|;
name|setcdr
argument_list|(
name|last
argument_list|(
name|a
argument_list|)
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|funcall1 (LISP fcn,LISP a1)
name|funcall1
parameter_list|(
name|LISP
name|fcn
parameter_list|,
name|LISP
name|a1
parameter_list|)
block|{
switch|switch TYPE
condition|(
name|fcn
condition|)
block|{
case|case
name|tc_subr_1
case|:
name|STACK_CHECK
argument_list|(
operator|&
name|fcn
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
return|return
operator|(
name|SUBR1
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|a1
argument_list|)
operator|)
return|;
case|case
name|tc_closure
case|:
if|if TYPEP
condition|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
operator|,
name|tc_subr_2
condition|)
block|{
name|STACK_CHECK
argument_list|(
operator|&
name|fcn
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
return|return
operator|(
name|SUBR2
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|code
argument_list|)
argument_list|(
name|fcn
operator|->
name|storage_as
operator|.
name|closure
operator|.
name|env
argument_list|,
name|a1
argument_list|)
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|lapply
argument_list|(
name|fcn
argument_list|,
name|cons
argument_list|(
name|a1
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|funcall2 (LISP fcn,LISP a1,LISP a2)
name|funcall2
parameter_list|(
name|LISP
name|fcn
parameter_list|,
name|LISP
name|a1
parameter_list|,
name|LISP
name|a2
parameter_list|)
block|{
switch|switch TYPE
condition|(
name|fcn
condition|)
block|{
case|case
name|tc_subr_2
case|:
case|case
name|tc_subr_2n
case|:
name|STACK_CHECK
argument_list|(
operator|&
name|fcn
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
return|return
operator|(
name|SUBR2
argument_list|(
name|fcn
argument_list|)
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|lapply
argument_list|(
name|fcn
argument_list|,
name|cons
argument_list|(
name|a1
argument_list|,
name|cons
argument_list|(
name|a2
argument_list|,
name|NIL
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lqsort (LISP l,LISP f,LISP g)
name|lqsort
parameter_list|(
name|LISP
name|l
parameter_list|,
name|LISP
name|f
parameter_list|,
name|LISP
name|g
parameter_list|)
comment|/* this is a stupid recursive qsort */
block|{
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|LISP
name|v
decl_stmt|,
name|mark
decl_stmt|,
name|less
decl_stmt|,
name|notless
decl_stmt|;
for|for
control|(
name|v
operator|=
name|l
operator|,
name|n
operator|=
literal|0
init|;
name|CONSP
argument_list|(
name|v
argument_list|)
condition|;
name|v
operator|=
name|CDR
argument_list|(
name|v
argument_list|)
operator|,
operator|++
name|n
control|)
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
if|if NNULLP
condition|(
name|v
condition|)
name|err
argument_list|(
literal|"bad list to qsort"
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|j
operator|=
name|rand
argument_list|()
operator|%
name|n
expr_stmt|;
for|for
control|(
name|v
operator|=
name|l
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|j
condition|;
operator|++
name|n
control|)
name|v
operator|=
name|CDR
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|mark
operator|=
name|CAR
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|less
operator|=
name|NIL
operator|,
name|notless
operator|=
name|NIL
operator|,
name|v
operator|=
name|l
operator|,
name|n
operator|=
literal|0
init|;
name|NNULLP
argument_list|(
name|v
argument_list|)
condition|;
name|v
operator|=
name|CDR
argument_list|(
name|v
argument_list|)
operator|,
operator|++
name|n
control|)
if|if
condition|(
name|j
operator|!=
name|n
condition|)
block|{
if|if NNULLP
condition|(
name|funcall2
argument_list|(
name|f
argument_list|,
name|NULLP
argument_list|(
name|g
argument_list|)
condition|?
name|CAR
argument_list|(
name|v
argument_list|)
else|:
name|funcall1
argument_list|(
name|g
argument_list|,
name|CAR
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|,
name|NULLP
argument_list|(
name|g
argument_list|)
condition|?
name|mark
else|:
name|funcall1
argument_list|(
name|g
argument_list|,
name|mark
argument_list|)
argument_list|)
condition|)
name|less
operator|=
name|cons
argument_list|(
name|CAR
argument_list|(
name|v
argument_list|)
argument_list|,
name|less
argument_list|)
expr_stmt|;
else|else
name|notless
operator|=
name|cons
argument_list|(
name|CAR
argument_list|(
name|v
argument_list|)
argument_list|,
name|notless
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nconc
argument_list|(
name|lqsort
argument_list|(
name|less
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
argument_list|,
name|cons
argument_list|(
name|mark
argument_list|,
name|lqsort
argument_list|(
name|notless
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|string_lessp (LISP s1,LISP s2)
name|string_lessp
parameter_list|(
name|LISP
name|s1
parameter_list|,
name|LISP
name|s2
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|get_c_string
argument_list|(
name|s1
argument_list|)
argument_list|,
name|get_c_string
argument_list|(
name|s2
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|sym_t
operator|)
return|;
else|else
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|benchmark_funcall1 (LISP ln,LISP f,LISP a1)
name|benchmark_funcall1
parameter_list|(
name|LISP
name|ln
parameter_list|,
name|LISP
name|f
parameter_list|,
name|LISP
name|a1
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
name|LISP
name|value
init|=
name|NIL
decl_stmt|;
name|n
operator|=
name|get_c_long
argument_list|(
name|ln
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|value
operator|=
name|funcall1
argument_list|(
name|f
argument_list|,
name|a1
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|benchmark_funcall2 (LISP l)
name|benchmark_funcall2
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
name|LISP
name|ln
init|=
name|car
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|LISP
name|f
init|=
name|car
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
name|LISP
name|a1
init|=
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|LISP
name|a2
init|=
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|LISP
name|value
init|=
name|NULL
decl_stmt|;
name|n
operator|=
name|get_c_long
argument_list|(
name|ln
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|value
operator|=
name|funcall2
argument_list|(
name|f
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|benchmark_eval (LISP ln,LISP exp,LISP env)
name|benchmark_eval
parameter_list|(
name|LISP
name|ln
parameter_list|,
name|LISP
name|exp
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|long
name|j
decl_stmt|,
name|n
decl_stmt|;
name|LISP
name|value
init|=
name|NIL
decl_stmt|;
name|n
operator|=
name|get_c_long
argument_list|(
name|ln
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|value
operator|=
name|leval
argument_list|(
name|exp
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|mapcar1 (LISP fcn,LISP in)
name|mapcar1
parameter_list|(
name|LISP
name|fcn
parameter_list|,
name|LISP
name|in
parameter_list|)
block|{
name|LISP
name|res
decl_stmt|,
name|ptr
decl_stmt|,
name|l
decl_stmt|;
if|if NULLP
condition|(
name|in
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|res
operator|=
name|ptr
operator|=
name|cons
argument_list|(
name|funcall1
argument_list|(
name|fcn
argument_list|,
name|car
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cdr
argument_list|(
name|in
argument_list|)
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
name|ptr
operator|=
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|cons
argument_list|(
name|funcall1
argument_list|(
name|fcn
argument_list|,
name|CAR
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|CDR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|mapcar2 (LISP fcn,LISP in1,LISP in2)
name|mapcar2
parameter_list|(
name|LISP
name|fcn
parameter_list|,
name|LISP
name|in1
parameter_list|,
name|LISP
name|in2
parameter_list|)
block|{
name|LISP
name|res
decl_stmt|,
name|ptr
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|;
if|if
condition|(
name|NULLP
argument_list|(
name|in1
argument_list|)
operator|||
name|NULLP
argument_list|(
name|in2
argument_list|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|res
operator|=
name|ptr
operator|=
name|cons
argument_list|(
name|funcall2
argument_list|(
name|fcn
argument_list|,
name|car
argument_list|(
name|in1
argument_list|)
argument_list|,
name|car
argument_list|(
name|in2
argument_list|)
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
for|for
control|(
name|l1
operator|=
name|cdr
argument_list|(
name|in1
argument_list|)
operator|,
name|l2
operator|=
name|cdr
argument_list|(
name|in2
argument_list|)
init|;
name|CONSP
argument_list|(
name|l1
argument_list|)
operator|&&
name|CONSP
argument_list|(
name|l2
argument_list|)
condition|;
name|l1
operator|=
name|CDR
argument_list|(
name|l1
argument_list|)
operator|,
name|l2
operator|=
name|CDR
argument_list|(
name|l2
argument_list|)
control|)
name|ptr
operator|=
name|CDR
argument_list|(
name|ptr
argument_list|)
operator|=
name|cons
argument_list|(
name|funcall2
argument_list|(
name|fcn
argument_list|,
name|CAR
argument_list|(
name|l1
argument_list|)
argument_list|,
name|CAR
argument_list|(
name|l2
argument_list|)
argument_list|)
argument_list|,
name|CDR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|mapcar (LISP l)
name|mapcar
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
name|LISP
name|fcn
init|=
name|car
argument_list|(
name|l
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|get_c_long
argument_list|(
name|llength
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
return|return
operator|(
name|mapcar1
argument_list|(
name|fcn
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|3
case|:
return|return
operator|(
name|mapcar2
argument_list|(
name|fcn
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|,
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|err
argument_list|(
literal|"mapcar case not handled"
argument_list|,
name|l
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|lfmod (LISP x,LISP y)
name|lfmod
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|err
argument_list|(
literal|"wta(1st) to fmod"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|err
argument_list|(
literal|"wta(2nd) to fmod"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|fmod
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
argument_list|,
name|FLONM
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lsubset (LISP fcn,LISP l)
name|lsubset
parameter_list|(
name|LISP
name|fcn
parameter_list|,
name|LISP
name|l
parameter_list|)
block|{
name|LISP
name|result
init|=
name|NIL
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|l
init|;
name|CONSP
argument_list|(
name|v
argument_list|)
condition|;
name|v
operator|=
name|CDR
argument_list|(
name|v
argument_list|)
control|)
if|if NNULLP
condition|(
name|funcall1
argument_list|(
name|fcn
argument_list|,
name|CAR
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|cons
argument_list|(
name|CAR
argument_list|(
name|v
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreverse
argument_list|(
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ass (LISP x,LISP alist,LISP fcn)
name|ass
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|alist
parameter_list|,
name|LISP
name|fcn
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|l
operator|=
name|alist
init|;
name|CONSP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|CDR
argument_list|(
name|l
argument_list|)
control|)
block|{
name|tmp
operator|=
name|CAR
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSP
argument_list|(
name|tmp
argument_list|)
operator|&&
name|NNULLP
argument_list|(
name|funcall2
argument_list|(
name|fcn
argument_list|,
name|CAR
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
block|}
if|if EQ
condition|(
name|l
operator|,
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
name|err
argument_list|(
literal|"improper list to ass"
argument_list|,
name|alist
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|append2 (LISP l1,LISP l2)
name|append2
parameter_list|(
name|LISP
name|l1
parameter_list|,
name|LISP
name|l2
parameter_list|)
block|{
name|long
name|n
decl_stmt|;
name|LISP
name|result
init|=
name|NIL
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|n
operator|=
name|nlength
argument_list|(
name|l1
argument_list|)
operator|+
name|nlength
argument_list|(
name|l2
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
for|for
control|(
name|p1
operator|=
name|result
operator|,
name|p2
operator|=
name|l1
init|;
name|NNULLP
argument_list|(
name|p2
argument_list|)
condition|;
name|p1
operator|=
name|cdr
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|cdr
argument_list|(
name|p2
argument_list|)
control|)
name|setcar
argument_list|(
name|p1
argument_list|,
name|car
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p2
operator|=
name|l2
init|;
name|NNULLP
argument_list|(
name|p2
argument_list|)
condition|;
name|p1
operator|=
name|cdr
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|cdr
argument_list|(
name|p2
argument_list|)
control|)
name|setcar
argument_list|(
name|p1
argument_list|,
name|car
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|append (LISP l)
name|append
parameter_list|(
name|LISP
name|l
parameter_list|)
block|{
name|STACK_CHECK
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
if|if NULLP
condition|(
name|l
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
elseif|else
if|if NULLP
condition|(
name|cdr
argument_list|(
name|l
argument_list|)
condition|)
return|return
operator|(
name|car
argument_list|(
name|l
argument_list|)
operator|)
return|;
elseif|else
if|if NULLP
condition|(
name|cddr
argument_list|(
name|l
argument_list|)
condition|)
return|return
operator|(
name|append2
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|cadr
argument_list|(
name|l
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|append2
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|append
argument_list|(
name|cdr
argument_list|(
name|l
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|listn (long n,...)
name|listn
parameter_list|(
name|long
name|n
parameter_list|,
modifier|...
parameter_list|)
block|{
name|LISP
name|result
decl_stmt|,
name|ptr
decl_stmt|;
name|long
name|j
decl_stmt|;
name|va_list
name|args
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|result
operator|=
name|NIL
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|result
operator|=
name|cons
argument_list|(
name|NIL
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ptr
operator|=
name|result
init|;
name|j
operator|<
name|n
condition|;
name|ptr
operator|=
name|cdr
argument_list|(
name|ptr
argument_list|)
operator|,
operator|++
name|j
control|)
name|setcar
argument_list|(
name|ptr
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|LISP
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|fast_load (LISP lfname,LISP noeval)
name|fast_load
parameter_list|(
name|LISP
name|lfname
parameter_list|,
name|LISP
name|noeval
parameter_list|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|LISP
name|stream
decl_stmt|;
name|LISP
name|result
init|=
name|NIL
decl_stmt|,
name|form
decl_stmt|;
name|fname
operator|=
name|get_c_string
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
block|{
name|put_st
argument_list|(
literal|"fast loading "
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|listn
argument_list|(
literal|3
argument_list|,
name|fopen_c
argument_list|(
name|fname
argument_list|,
literal|"rb"
argument_list|)
argument_list|,
name|cons_array
argument_list|(
name|flocons
argument_list|(
literal|100
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|flocons
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|NEQ
argument_list|(
name|stream
argument_list|,
name|form
operator|=
name|fast_read
argument_list|(
name|stream
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|5
condition|)
name|lprint
argument_list|(
name|form
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|noeval
condition|)
name|leval
argument_list|(
name|form
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|cons
argument_list|(
name|form
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|fclose_l
argument_list|(
name|car
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
name|put_st
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreverse
argument_list|(
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|shexstr (char * outstr,void * buff,size_t len)
name|shexstr
parameter_list|(
name|char
modifier|*
name|outstr
parameter_list|,
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|data
init|=
name|buff
decl_stmt|;
name|size_t
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
name|sprintf
argument_list|(
operator|&
name|outstr
index|[
name|j
operator|*
literal|2
index|]
argument_list|,
literal|"%02X"
argument_list|,
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LISP
DECL|function|fast_save (LISP fname,LISP forms,LISP nohash,LISP comment)
name|fast_save
parameter_list|(
name|LISP
name|fname
parameter_list|,
name|LISP
name|forms
parameter_list|,
name|LISP
name|nohash
parameter_list|,
name|LISP
name|comment
parameter_list|)
block|{
name|char
modifier|*
name|cname
decl_stmt|,
name|msgbuff
index|[
literal|100
index|]
decl_stmt|,
name|databuff
index|[
literal|50
index|]
decl_stmt|;
name|LISP
name|stream
decl_stmt|,
name|l
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|l_one
init|=
literal|1
decl_stmt|;
name|double
name|d_one
init|=
literal|1.0
decl_stmt|;
name|cname
operator|=
name|get_c_string
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
block|{
name|put_st
argument_list|(
literal|"fast saving forms to "
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|put_st
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|listn
argument_list|(
literal|3
argument_list|,
name|fopen_c
argument_list|(
name|cname
argument_list|,
literal|"wb"
argument_list|)
argument_list|,
name|NNULLP
argument_list|(
name|nohash
argument_list|)
condition|?
name|NIL
else|:
name|cons_array
argument_list|(
name|flocons
argument_list|(
literal|100
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|flocons
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|get_c_file
argument_list|(
name|car
argument_list|(
name|stream
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|comment
condition|)
name|fput_st
argument_list|(
name|f
argument_list|,
name|get_c_string
argument_list|(
name|comment
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuff
argument_list|,
literal|"# Siod Binary Object Save File\n"
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|f
argument_list|,
name|msgbuff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuff
argument_list|,
literal|"# sizeof(long) = %d\n# sizeof(double) = %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|f
argument_list|,
name|msgbuff
argument_list|)
expr_stmt|;
name|shexstr
argument_list|(
name|databuff
argument_list|,
operator|&
name|l_one
argument_list|,
sizeof|sizeof
argument_list|(
name|l_one
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuff
argument_list|,
literal|"# 1 = %s\n"
argument_list|,
name|databuff
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|f
argument_list|,
name|msgbuff
argument_list|)
expr_stmt|;
name|shexstr
argument_list|(
name|databuff
argument_list|,
operator|&
name|d_one
argument_list|,
sizeof|sizeof
argument_list|(
name|d_one
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuff
argument_list|,
literal|"# 1.0 = %s\n"
argument_list|,
name|databuff
argument_list|)
expr_stmt|;
name|fput_st
argument_list|(
name|f
argument_list|,
name|msgbuff
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|forms
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|fast_print
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fclose_l
argument_list|(
name|car
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|siod_verbose_level
operator|>=
literal|3
condition|)
name|put_st
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|swrite1 (LISP stream,LISP data)
name|swrite1
parameter_list|(
name|LISP
name|stream
parameter_list|,
name|LISP
name|data
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|get_c_file
argument_list|(
name|stream
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
switch|switch TYPE
condition|(
name|data
condition|)
block|{
case|case
name|tc_symbol
case|:
case|case
name|tc_string
case|:
name|fput_st
argument_list|(
name|f
argument_list|,
name|get_c_string
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lprin1f
argument_list|(
name|data
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|swrite (LISP stream,LISP table,LISP data)
name|swrite
parameter_list|(
name|LISP
name|stream
parameter_list|,
name|LISP
name|table
parameter_list|,
name|LISP
name|data
parameter_list|)
block|{
name|LISP
name|value
decl_stmt|,
name|key
decl_stmt|;
name|long
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|data
argument_list|)
condition|)
block|{
case|case
name|tc_symbol
case|:
name|value
operator|=
name|href
argument_list|(
name|table
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if CONSP
condition|(
name|value
condition|)
block|{
name|swrite1
argument_list|(
name|stream
argument_list|,
name|CAR
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|CDR
argument_list|(
name|value
argument_list|)
condition|)
name|hset
argument_list|(
name|table
argument_list|,
name|data
argument_list|,
name|CDR
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|swrite1
argument_list|(
name|stream
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_lisp_array
case|:
name|n
operator|=
name|data
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|dim
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|err
argument_list|(
literal|"no object repeat count"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|key
operator|=
name|data
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if NULLP
condition|(
name|value
operator|=
name|href
argument_list|(
name|table
argument_list|,
name|key
argument_list|)
condition|)
name|value
operator|=
name|key
expr_stmt|;
elseif|else
if|if CONSP
condition|(
name|value
condition|)
block|{
if|if NNULLP
condition|(
name|CDR
argument_list|(
name|value
argument_list|)
condition|)
name|hset
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
name|CDR
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|CAR
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|get_c_long
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|m
condition|;
operator|++
name|k
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|swrite
argument_list|(
name|stream
argument_list|,
name|table
argument_list|,
name|data
operator|->
name|storage_as
operator|.
name|lisp_array
operator|.
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_cons
case|:
comment|/* this should be handled similar to the array case */
default|default:
name|swrite1
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lpow (LISP x,LISP y)
name|lpow
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
if|if NFLONUMP
condition|(
name|x
condition|)
name|err
argument_list|(
literal|"wta(1st) to pow"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if NFLONUMP
condition|(
name|y
condition|)
name|err
argument_list|(
literal|"wta(2nd) to pow"
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|pow
argument_list|(
name|FLONM
argument_list|(
name|x
argument_list|)
argument_list|,
name|FLONM
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lexp (LISP x)
name|lexp
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|exp
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|llog (LISP x)
name|llog
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|log
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lsin (LISP x)
name|lsin
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|sin
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lcos (LISP x)
name|lcos
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|cos
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ltan (LISP x)
name|ltan
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|tan
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lasin (LISP x)
name|lasin
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|asin
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lacos (LISP x)
name|lacos
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|acos
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|latan (LISP x)
name|latan
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|atan
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|latan2 (LISP x,LISP y)
name|latan2
parameter_list|(
name|LISP
name|x
parameter_list|,
name|LISP
name|y
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|atan2
argument_list|(
name|get_c_double
argument_list|(
name|x
argument_list|)
argument_list|,
name|get_c_double
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|hexstr (LISP a)
name|hexstr
parameter_list|(
name|LISP
name|a
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|LISP
name|result
decl_stmt|;
name|long
name|j
decl_stmt|,
name|dim
decl_stmt|;
name|in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|get_c_string_dim
argument_list|(
name|a
argument_list|,
operator|&
name|dim
argument_list|)
expr_stmt|;
name|result
operator|=
name|strcons
argument_list|(
name|dim
operator|*
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|out
operator|=
name|get_c_string
argument_list|(
name|result
argument_list|)
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dim
condition|;
operator|++
name|j
operator|,
name|out
operator|+=
literal|2
control|)
name|sprintf
argument_list|(
name|out
argument_list|,
literal|"%02x"
argument_list|,
name|in
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|xdigitvalue (int c)
name|xdigitvalue
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|toupper
argument_list|(
name|c
argument_list|)
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|hexstr2bytes (LISP a)
name|hexstr2bytes
parameter_list|(
name|LISP
name|a
parameter_list|)
block|{
name|char
modifier|*
name|in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out
decl_stmt|;
name|LISP
name|result
decl_stmt|;
name|long
name|j
decl_stmt|,
name|dim
decl_stmt|;
name|in
operator|=
name|get_c_string
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|dim
operator|=
name|strlen
argument_list|(
name|in
argument_list|)
operator|/
literal|2
expr_stmt|;
name|result
operator|=
name|arcons
argument_list|(
name|tc_byte_array
argument_list|,
name|dim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
operator|->
name|storage_as
operator|.
name|string
operator|.
name|data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dim
condition|;
operator|++
name|j
control|)
name|out
index|[
name|j
index|]
operator|=
name|xdigitvalue
argument_list|(
name|in
index|[
name|j
operator|*
literal|2
index|]
argument_list|)
operator|*
literal|16
operator|+
name|xdigitvalue
argument_list|(
name|in
index|[
name|j
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|getprop (LISP plist,LISP key)
name|getprop
parameter_list|(
name|LISP
name|plist
parameter_list|,
name|LISP
name|key
parameter_list|)
block|{
name|LISP
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|cdr
argument_list|(
name|plist
argument_list|)
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cddr
argument_list|(
name|l
argument_list|)
control|)
if|if EQ
condition|(
name|car
argument_list|(
name|l
argument_list|)
operator|,
name|key
condition|)
return|return
operator|(
name|cadr
argument_list|(
name|l
argument_list|)
operator|)
return|;
else|else
name|INTERRUPT_CHECK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|setprop (LISP plist,LISP key,LISP value)
name|setprop
parameter_list|(
name|LISP
name|plist
parameter_list|,
name|LISP
name|key
parameter_list|,
name|LISP
name|value
parameter_list|)
block|{
name|err
argument_list|(
literal|"not implemented"
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|putprop (LISP plist,LISP value,LISP key)
name|putprop
parameter_list|(
name|LISP
name|plist
parameter_list|,
name|LISP
name|value
parameter_list|,
name|LISP
name|key
parameter_list|)
block|{
return|return
operator|(
name|setprop
argument_list|(
name|plist
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ltypeof (LISP obj)
name|ltypeof
parameter_list|(
name|LISP
name|obj
parameter_list|)
block|{
name|long
name|x
decl_stmt|;
name|x
operator|=
name|TYPE
argument_list|(
name|obj
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|tc_nil
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_nil"
argument_list|)
operator|)
return|;
case|case
name|tc_cons
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_cons"
argument_list|)
operator|)
return|;
case|case
name|tc_flonum
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_flonum"
argument_list|)
operator|)
return|;
case|case
name|tc_symbol
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_symbol"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_0
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_0"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_1
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_1"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_2"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_2n
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_2n"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_3
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_3"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_4
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_4"
argument_list|)
operator|)
return|;
case|case
name|tc_subr_5
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_subr_5"
argument_list|)
operator|)
return|;
case|case
name|tc_lsubr
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_lsubr"
argument_list|)
operator|)
return|;
case|case
name|tc_fsubr
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_fsubr"
argument_list|)
operator|)
return|;
case|case
name|tc_msubr
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_msubr"
argument_list|)
operator|)
return|;
case|case
name|tc_closure
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_closure"
argument_list|)
operator|)
return|;
case|case
name|tc_free_cell
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_free_cell"
argument_list|)
operator|)
return|;
case|case
name|tc_string
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_string"
argument_list|)
operator|)
return|;
case|case
name|tc_byte_array
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_byte_array"
argument_list|)
operator|)
return|;
case|case
name|tc_double_array
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_double_array"
argument_list|)
operator|)
return|;
case|case
name|tc_long_array
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_long_array"
argument_list|)
operator|)
return|;
case|case
name|tc_lisp_array
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_lisp_array"
argument_list|)
operator|)
return|;
case|case
name|tc_c_file
case|:
return|return
operator|(
name|cintern
argument_list|(
literal|"tc_c_file"
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|flocons
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|LISP
DECL|function|caaar (LISP x)
name|caaar
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|car
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|caadr (LISP x)
name|caadr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cadar (LISP x)
name|cadar
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|cdr
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|caddr (LISP x)
name|caddr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|car
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cdaar (LISP x)
name|cdaar
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|car
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cdadr (LISP x)
name|cdadr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|car
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cddar (LISP x)
name|cddar
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|car
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|cdddr (LISP x)
name|cdddr
parameter_list|(
name|LISP
name|x
parameter_list|)
block|{
return|return
operator|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|cdr
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|ash (LISP value,LISP n)
name|ash
parameter_list|(
name|LISP
name|value
parameter_list|,
name|LISP
name|n
parameter_list|)
block|{
name|long
name|m
decl_stmt|,
name|k
decl_stmt|;
name|m
operator|=
name|get_c_long
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|k
operator|=
name|get_c_long
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|m
operator|=
name|m
operator|<<
name|k
expr_stmt|;
else|else
name|m
operator|=
name|m
operator|>>
operator|(
operator|-
name|k
operator|)
expr_stmt|;
return|return
operator|(
name|flocons
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|bitand (LISP a,LISP b)
name|bitand
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|get_c_long
argument_list|(
name|a
argument_list|)
operator|&
name|get_c_long
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|bitor (LISP a,LISP b)
name|bitor
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|get_c_long
argument_list|(
name|a
argument_list|)
operator||
name|get_c_long
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|bitxor (LISP a,LISP b)
name|bitxor
parameter_list|(
name|LISP
name|a
parameter_list|,
name|LISP
name|b
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|get_c_long
argument_list|(
name|a
argument_list|)
operator|^
name|get_c_long
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|bitnot (LISP a)
name|bitnot
parameter_list|(
name|LISP
name|a
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
operator|~
name|get_c_long
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_prog1 (LISP args,LISP env)
name|leval_prog1
parameter_list|(
name|LISP
name|args
parameter_list|,
name|LISP
name|env
parameter_list|)
block|{
name|LISP
name|retval
decl_stmt|,
name|l
decl_stmt|;
name|retval
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|args
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cdr
argument_list|(
name|args
argument_list|)
init|;
name|NNULLP
argument_list|(
name|l
argument_list|)
condition|;
name|l
operator|=
name|cdr
argument_list|(
name|l
argument_list|)
control|)
name|leval
argument_list|(
name|car
argument_list|(
name|l
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|leval_cond (LISP * pform,LISP * penv)
name|leval_cond
parameter_list|(
name|LISP
modifier|*
name|pform
parameter_list|,
name|LISP
modifier|*
name|penv
parameter_list|)
block|{
name|LISP
name|args
decl_stmt|,
name|env
decl_stmt|,
name|clause
decl_stmt|,
name|value
decl_stmt|,
name|next
decl_stmt|;
name|args
operator|=
name|cdr
argument_list|(
operator|*
name|pform
argument_list|)
expr_stmt|;
name|env
operator|=
operator|*
name|penv
expr_stmt|;
if|if NULLP
condition|(
name|args
condition|)
block|{
operator|*
name|pform
operator|=
name|NIL
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|next
operator|=
name|cdr
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while NNULLP
condition|(
name|next
condition|)
block|{
name|clause
operator|=
name|car
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|value
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|clause
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|value
condition|)
block|{
name|clause
operator|=
name|cdr
argument_list|(
name|clause
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|clause
condition|)
block|{
operator|*
name|pform
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
else|else
block|{
name|next
operator|=
name|cdr
argument_list|(
name|clause
argument_list|)
expr_stmt|;
while|while
condition|(
name|NNULLP
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|leval
argument_list|(
name|car
argument_list|(
name|clause
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|clause
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|pform
operator|=
name|car
argument_list|(
name|clause
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
block|}
name|args
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|clause
operator|=
name|car
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|clause
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|next
condition|)
block|{
operator|*
name|pform
operator|=
name|car
argument_list|(
name|clause
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
name|value
operator|=
name|leval
argument_list|(
name|car
argument_list|(
name|clause
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if NULLP
condition|(
name|value
condition|)
block|{
operator|*
name|pform
operator|=
name|NIL
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|clause
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|NNULLP
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|leval
argument_list|(
name|car
argument_list|(
name|clause
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|clause
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|cdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|pform
operator|=
name|car
argument_list|(
name|clause
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_t
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrspn (LISP str1,LISP str2)
name|lstrspn
parameter_list|(
name|LISP
name|str1
parameter_list|,
name|LISP
name|str2
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|strspn
argument_list|(
name|get_c_string
argument_list|(
name|str1
argument_list|)
argument_list|,
name|get_c_string
argument_list|(
name|str2
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|lstrcspn (LISP str1,LISP str2)
name|lstrcspn
parameter_list|(
name|LISP
name|str1
parameter_list|,
name|LISP
name|str2
parameter_list|)
block|{
return|return
operator|(
name|flocons
argument_list|(
name|strcspn
argument_list|(
name|get_c_string
argument_list|(
name|str1
argument_list|)
argument_list|,
name|get_c_string
argument_list|(
name|str2
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|substring_equal (LISP str1,LISP str2,LISP start,LISP end)
name|substring_equal
parameter_list|(
name|LISP
name|str1
parameter_list|,
name|LISP
name|str2
parameter_list|,
name|LISP
name|start
parameter_list|,
name|LISP
name|end
parameter_list|)
block|{
name|char
modifier|*
name|cstr1
decl_stmt|,
modifier|*
name|cstr2
decl_stmt|;
name|long
name|len1
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|,
name|e
decl_stmt|;
name|cstr1
operator|=
name|get_c_string_dim
argument_list|(
name|str1
argument_list|,
operator|&
name|len1
argument_list|)
expr_stmt|;
name|cstr2
operator|=
name|get_c_string_dim
argument_list|(
name|str2
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULLP
argument_list|(
name|start
argument_list|)
condition|?
literal|0
else|:
name|get_c_long
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|e
operator|=
name|NULLP
argument_list|(
name|end
argument_list|)
condition|?
name|n
else|:
name|get_c_long
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|<
literal|0
operator|)
operator|||
operator|(
name|s
operator|>
name|e
operator|)
operator|||
operator|(
name|e
operator|<
literal|0
operator|)
operator|||
operator|(
name|e
operator|>
name|n
operator|)
operator|||
operator|(
operator|(
name|e
operator|-
name|s
operator|)
operator|!=
name|len1
operator|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
return|return
operator|(
operator|(
name|memcmp
argument_list|(
name|cstr1
argument_list|,
operator|&
name|cstr2
index|[
name|s
index|]
argument_list|,
name|e
operator|-
name|s
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|a_true_value
argument_list|()
else|:
name|NIL
operator|)
return|;
block|}
end_function

begin_function
name|LISP
DECL|function|set_eval_history (LISP len,LISP circ)
name|set_eval_history
parameter_list|(
name|LISP
name|len
parameter_list|,
name|LISP
name|circ
parameter_list|)
block|{
name|LISP
name|data
decl_stmt|;
name|data
operator|=
name|NULLP
argument_list|(
name|len
argument_list|)
condition|?
name|len
else|:
name|make_list
argument_list|(
name|len
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if NNULLP
condition|(
name|circ
condition|)
name|data
operator|=
name|nconc
argument_list|(
name|data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*eval-history-ptr*"
argument_list|)
argument_list|,
name|data
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*eval-history*"
argument_list|)
argument_list|,
name|data
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|LISP
DECL|function|parser_fasl (LISP ignore)
name|parser_fasl
parameter_list|(
name|LISP
name|ignore
parameter_list|)
block|{
return|return
operator|(
name|closure
argument_list|(
name|listn
argument_list|(
literal|3
argument_list|,
name|NIL
argument_list|,
name|cons_array
argument_list|(
name|flocons
argument_list|(
literal|100
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|flocons
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|leval
argument_list|(
name|cintern
argument_list|(
literal|"parser_fasl_hook"
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|LISP
DECL|function|parser_fasl_hook (LISP env,LISP f)
name|parser_fasl_hook
parameter_list|(
name|LISP
name|env
parameter_list|,
name|LISP
name|f
parameter_list|)
block|{
name|LISP
name|result
decl_stmt|;
name|setcar
argument_list|(
name|env
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|result
operator|=
name|fast_read
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if EQ
condition|(
name|result
operator|,
name|env
condition|)
return|return
operator|(
name|get_eof_val
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|init_subrs_a (void)
name|init_subrs_a
parameter_list|(
name|void
parameter_list|)
block|{
name|init_subr_2
argument_list|(
literal|"aref"
argument_list|,
name|aref1
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"aset"
argument_list|,
name|aset1
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"string-append"
argument_list|,
name|string_append
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"bytes-append"
argument_list|,
name|bytes_append
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-length"
argument_list|,
name|string_length
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-dimension"
argument_list|,
name|string_dim
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"read-from-string"
argument_list|,
name|read_from_string
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"print-to-string"
argument_list|,
name|print_to_string
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"cons-array"
argument_list|,
name|cons_array
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"sxhash"
argument_list|,
name|sxhash
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"equal?"
argument_list|,
name|equal
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"href"
argument_list|,
name|href
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"hset"
argument_list|,
name|hset
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"assoc"
argument_list|,
name|assoc
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"assv"
argument_list|,
name|assv
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"fast-read"
argument_list|,
name|fast_read
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"fast-print"
argument_list|,
name|fast_print
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"make-list"
argument_list|,
name|make_list
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"fread"
argument_list|,
name|lfread
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"fwrite"
argument_list|,
name|lfwrite
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"fflush"
argument_list|,
name|lfflush
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"length"
argument_list|,
name|llength
argument_list|)
expr_stmt|;
name|init_subr_4
argument_list|(
literal|"number->string"
argument_list|,
name|number2string
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"string->number"
argument_list|,
name|string2number
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"substring"
argument_list|,
name|substring
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"string-search"
argument_list|,
name|string_search
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-trim"
argument_list|,
name|string_trim
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-trim-left"
argument_list|,
name|string_trim_left
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-trim-right"
argument_list|,
name|string_trim_right
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-upcase"
argument_list|,
name|string_upcase
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string-downcase"
argument_list|,
name|string_downcase
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"strcmp"
argument_list|,
name|lstrcmp
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"strcat"
argument_list|,
name|lstrcat
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"strcpy"
argument_list|,
name|lstrcpy
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"strbreakup"
argument_list|,
name|lstrbreakup
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"unbreakupstr"
argument_list|,
name|lstrunbreakup
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"string?"
argument_list|,
name|stringp
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_e
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_f
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
name|gc_protect_sym
argument_list|(
operator|&
name|sym_plists
argument_list|,
literal|"*plists*"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|sym_plists
argument_list|,
name|arcons
argument_list|(
name|tc_lisp_array
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"lref-default"
argument_list|,
name|lref_default
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"larg-default"
argument_list|,
name|larg_default
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"lkey-default"
argument_list|,
name|lkey_default
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"list"
argument_list|,
name|llist
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"writes"
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"qsort"
argument_list|,
name|lqsort
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"string-lessp"
argument_list|,
name|string_lessp
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"mapcar"
argument_list|,
name|mapcar
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"mapcar2"
argument_list|,
name|mapcar2
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"mapcar1"
argument_list|,
name|mapcar1
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"benchmark-funcall1"
argument_list|,
name|benchmark_funcall1
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"benchmark-funcall2"
argument_list|,
name|benchmark_funcall2
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"benchmark-eval"
argument_list|,
name|benchmark_eval
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"fmod"
argument_list|,
name|lfmod
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"subset"
argument_list|,
name|lsubset
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"base64encode"
argument_list|,
name|base64encode
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"base64decode"
argument_list|,
name|base64decode
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"ass"
argument_list|,
name|ass
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"append2"
argument_list|,
name|append2
argument_list|)
expr_stmt|;
name|init_lsubr
argument_list|(
literal|"append"
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|init_subr_4
argument_list|(
literal|"fast-save"
argument_list|,
name|fast_save
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"fast-load"
argument_list|,
name|fast_load
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"swrite"
argument_list|,
name|swrite
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"pow"
argument_list|,
name|lpow
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"exp"
argument_list|,
name|lexp
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"log"
argument_list|,
name|llog
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"sin"
argument_list|,
name|lsin
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cos"
argument_list|,
name|lcos
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"tan"
argument_list|,
name|ltan
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"asin"
argument_list|,
name|lasin
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"acos"
argument_list|,
name|lacos
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"atan"
argument_list|,
name|latan
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"atan2"
argument_list|,
name|latan2
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"typeof"
argument_list|,
name|ltypeof
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"caaar"
argument_list|,
name|caaar
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"caadr"
argument_list|,
name|caadr
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cadar"
argument_list|,
name|cadar
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"caddr"
argument_list|,
name|caddr
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cdaar"
argument_list|,
name|cdaar
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cdadr"
argument_list|,
name|cdadr
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cddar"
argument_list|,
name|cddar
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"cdddr"
argument_list|,
name|cdddr
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*pi*"
argument_list|)
argument_list|,
name|flocons
argument_list|(
name|atan
argument_list|(
literal|1.0
argument_list|)
operator|*
literal|4
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|init_base64_table
argument_list|()
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"array->hexstr"
argument_list|,
name|hexstr
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"hexstr->bytes"
argument_list|,
name|hexstr2bytes
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"ass"
argument_list|,
name|ass
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"bit-and"
argument_list|,
name|bitand
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"bit-or"
argument_list|,
name|bitor
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"bit-xor"
argument_list|,
name|bitxor
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"bit-not"
argument_list|,
name|bitnot
argument_list|)
expr_stmt|;
name|init_msubr
argument_list|(
literal|"cond"
argument_list|,
name|leval_cond
argument_list|)
expr_stmt|;
name|init_fsubr
argument_list|(
literal|"prog1"
argument_list|,
name|leval_prog1
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"strspn"
argument_list|,
name|lstrspn
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"strcspn"
argument_list|,
name|lstrcspn
argument_list|)
expr_stmt|;
name|init_subr_4
argument_list|(
literal|"substring-equal?"
argument_list|,
name|substring_equal
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"butlast"
argument_list|,
name|butlast
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"ash"
argument_list|,
name|ash
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"get"
argument_list|,
name|getprop
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"setprop"
argument_list|,
name|setprop
argument_list|)
expr_stmt|;
name|init_subr_3
argument_list|(
literal|"putprop"
argument_list|,
name|putprop
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"last"
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"memq"
argument_list|,
name|memq
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"memv"
argument_list|,
name|memv
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"member"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"nth"
argument_list|,
name|nth
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"nconc"
argument_list|,
name|nconc
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"set-eval-history"
argument_list|,
name|set_eval_history
argument_list|)
expr_stmt|;
name|init_subr_1
argument_list|(
literal|"parser_fasl"
argument_list|,
name|parser_fasl
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|cintern
argument_list|(
literal|"*parser_fasl.scm-loaded*"
argument_list|)
argument_list|,
name|a_true_value
argument_list|()
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|init_subr_2
argument_list|(
literal|"parser_fasl_hook"
argument_list|,
name|parser_fasl_hook
argument_list|)
expr_stmt|;
name|init_sliba_version
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

