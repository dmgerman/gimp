begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fit.c: turn a bitmap representation of a curve into a list of splines.    Some of the ideas, but not the code, comes from the Phoenix thesis.     See README for the reference.  Copyright (C) 1992 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"spline.h"
end_include

begin_include
include|#
directive|include
file|"vector.h"
end_include

begin_include
include|#
directive|include
file|"curve.h"
end_include

begin_include
include|#
directive|include
file|"fit.h"
end_include

begin_include
include|#
directive|include
file|"pxl-outline.h"
end_include

begin_comment
comment|/* If two endpoints are closer than this, they are made to be equal.    (-align-threshold)  */
end_comment

begin_decl_stmt
DECL|variable|align_threshold
name|real
name|align_threshold
init|=
literal|0.5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the angle defined by a point and its predecessors and successors    is smaller than this, it's a corner, even if it's within    `corner_surround' pixels of a point with a smaller angle.     (-corner-always-threshold)  */
end_comment

begin_decl_stmt
DECL|variable|corner_always_threshold
name|real
name|corner_always_threshold
init|=
literal|60.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of points to consider when determining if a point is a corner    or not.  (-corner-surround)  */
end_comment

begin_decl_stmt
DECL|variable|corner_surround
name|unsigned
name|corner_surround
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a point, its predecessors, and its successors define an angle      smaller than this, it's a corner.  Should be in range 0..180.    (-corner-threshold)  */
end_comment

begin_decl_stmt
DECL|variable|corner_threshold
name|real
name|corner_threshold
init|=
literal|100.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of error at which a fitted spline is unacceptable.  If any    pixel is further away than this from the fitted curve, we try again.    (-error-threshold) */
end_comment

begin_comment
comment|/* real error_threshold = .8; ALT */
end_comment

begin_decl_stmt
DECL|variable|error_threshold
name|real
name|error_threshold
init|=
literal|.4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A second number of adjacent points to consider when filtering.    (-filter-alternative-surround)  */
end_comment

begin_decl_stmt
DECL|variable|filter_alternative_surround
name|unsigned
name|filter_alternative_surround
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the angles between the vectors produced by filter_surround and    filter_alternative_surround points differ by more than this, use    the one from filter_alternative_surround.  (-filter-epsilon)  */
end_comment

begin_decl_stmt
DECL|variable|filter_epsilon
name|real
name|filter_epsilon
init|=
literal|10.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times to smooth original data points.  Increasing this    number dramatically---to 50 or so---can produce vastly better    results.  But if any points that ``should'' be corners aren't found,    the curve goes to hell around that point.  (-filter-iterations)  */
end_comment

begin_comment
comment|/* unsigned filter_iteration_count = 4; ALT */
end_comment

begin_decl_stmt
DECL|variable|filter_iteration_count
name|unsigned
name|filter_iteration_count
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To produce the new point, use the old point plus this times the    neighbors.  (-filter-percent)  */
end_comment

begin_decl_stmt
DECL|variable|filter_percent
name|real
name|filter_percent
init|=
literal|.33
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of adjacent points to consider if `filter_surround' points    defines a straight line.  (-filter-secondary-surround)  */
end_comment

begin_decl_stmt
DECL|variable|filter_secondary_surround
name|unsigned
name|filter_secondary_surround
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of adjacent points to consider when filtering.   (-filter-surround)  */
end_comment

begin_decl_stmt
DECL|variable|filter_surround
name|unsigned
name|filter_surround
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Says whether or not to remove ``knee'' points after finding the outline.     (See the comments at `remove_knee_points'.)  (-remove-knees).  */
end_comment

begin_decl_stmt
DECL|variable|keep_knees
name|boolean
name|keep_knees
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a spline is closer to a straight line than this, it remains a    straight line, even if it would otherwise be changed back to a curve.    This is weighted by the square of the curve length, to make shorter    curves more likely to be reverted.  (-line-reversion-threshold)  */
end_comment

begin_decl_stmt
DECL|variable|line_reversion_threshold
name|real
name|line_reversion_threshold
init|=
literal|.01
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many pixels (on the average) a spline can diverge from the line    determined by its endpoints before it is changed to a straight line.    (-line-threshold) */
end_comment

begin_comment
comment|/* real line_threshold = 1.0; ALT */
end_comment

begin_decl_stmt
DECL|variable|line_threshold
name|real
name|line_threshold
init|=
literal|0.5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reparameterization doesn't improve the fit by this much percent,    stop doing it.  (-reparameterize-improve)  */
end_comment

begin_comment
comment|/* real reparameterize_improvement = .10; ALT */
end_comment

begin_decl_stmt
DECL|variable|reparameterize_improvement
name|real
name|reparameterize_improvement
init|=
literal|.01
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of error at which it is pointless to reparameterize.  This    happens, for example, when we are trying to fit the outline of the    outside of an `O' with a single spline.  The initial fit is not good    enough for the Newton-Raphson iteration to improve it.  It may be    that it would be better to detect the cases where we didn't find any    corners.  (-reparameterize-threshold)  */
end_comment

begin_comment
comment|/* real reparameterize_threshold = 30.0; ALT */
end_comment

begin_decl_stmt
DECL|variable|reparameterize_threshold
name|real
name|reparameterize_threshold
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Percentage of the curve away from the worst point to look for a    better place to subdivide.  (-subdivide-search)  */
end_comment

begin_decl_stmt
DECL|variable|subdivide_search
name|real
name|subdivide_search
init|=
literal|.1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of points to consider when deciding whether a given point is a    better place to subdivide.  (-subdivide-surround)  */
end_comment

begin_decl_stmt
DECL|variable|subdivide_surround
name|unsigned
name|subdivide_surround
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many pixels a point can diverge from a straight line and still be    considered a better place to subdivide.  (-subdivide-threshold) */
end_comment

begin_decl_stmt
DECL|variable|subdivide_threshold
name|real
name|subdivide_threshold
init|=
literal|.03
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of points to look at on either side of a point when computing    the approximation to the tangent at that point.  (-tangent-surround)  */
end_comment

begin_decl_stmt
DECL|variable|tangent_surround
name|unsigned
name|tangent_surround
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need to manipulate lists of array indices.  */
end_comment

begin_typedef
DECL|struct|index_list
typedef|typedef
struct|struct
name|index_list
block|{
DECL|member|data
name|unsigned
modifier|*
name|data
decl_stmt|;
DECL|member|length
name|unsigned
name|length
decl_stmt|;
DECL|typedef|index_list_type
block|}
name|index_list_type
typedef|;
end_typedef

begin_comment
comment|/* The usual accessor macros.  */
end_comment

begin_define
DECL|macro|GET_INDEX (i_l,n)
define|#
directive|define
name|GET_INDEX
parameter_list|(
name|i_l
parameter_list|,
name|n
parameter_list|)
value|((i_l).data[n])
end_define

begin_define
DECL|macro|INDEX_LIST_LENGTH (i_l)
define|#
directive|define
name|INDEX_LIST_LENGTH
parameter_list|(
name|i_l
parameter_list|)
value|((i_l).length)
end_define

begin_define
DECL|macro|GET_LAST_INDEX (i_l)
define|#
directive|define
name|GET_LAST_INDEX
parameter_list|(
name|i_l
parameter_list|)
value|((i_l).data[INDEX_LIST_LENGTH (i_l) - 1])
end_define

begin_function_decl
specifier|static
name|void
name|append_index
parameter_list|(
name|index_list_type
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_index_list
parameter_list|(
name|index_list_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|index_list_type
name|new_index_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_adjacent_corners
parameter_list|(
name|index_list_type
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|align
parameter_list|(
name|spline_list_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_bad_lines
parameter_list|(
name|spline_list_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filter
parameter_list|(
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|real
name|filter_angle
parameter_list|(
name|vector_type
parameter_list|,
name|vector_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_curve_vectors
parameter_list|(
name|unsigned
parameter_list|,
name|curve_type
parameter_list|,
name|unsigned
parameter_list|,
name|vector_type
modifier|*
parameter_list|,
name|vector_type
modifier|*
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|find_subdivision
parameter_list|(
name|curve_type
parameter_list|,
name|unsigned
name|initial
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_vectors
parameter_list|(
name|unsigned
parameter_list|,
name|pixel_outline_type
parameter_list|,
name|vector_type
modifier|*
parameter_list|,
name|vector_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|index_list_type
name|find_corners
parameter_list|(
name|pixel_outline_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|real
name|find_error
parameter_list|(
name|curve_type
parameter_list|,
name|spline_type
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vector_type
name|find_half_tangent
parameter_list|(
name|curve_type
parameter_list|,
name|boolean
name|start
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_tangent
parameter_list|(
name|curve_type
parameter_list|,
name|boolean
parameter_list|,
name|boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|spline_type
name|fit_one_spline
parameter_list|(
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|spline_list_type
modifier|*
name|fit_curve
parameter_list|(
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|spline_list_type
name|fit_curve_list
parameter_list|(
name|curve_list_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|spline_list_type
modifier|*
name|fit_with_least_squares
parameter_list|(
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|spline_list_type
modifier|*
name|fit_with_line
parameter_list|(
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_knee_points
parameter_list|(
name|curve_type
parameter_list|,
name|boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|reparameterize
parameter_list|(
name|curve_type
parameter_list|,
name|spline_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_initial_parameter_values
parameter_list|(
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|spline_linear_enough
parameter_list|(
name|spline_type
modifier|*
parameter_list|,
name|curve_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|curve_list_array_type
name|split_at_corners
parameter_list|(
name|pixel_outline_list_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|test_subdivision_point
parameter_list|(
name|curve_type
parameter_list|,
name|unsigned
parameter_list|,
name|vector_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The top-level call that transforms the list of pixels in the outlines    of the original character to a list of spline lists fitted to those    pixels.  */
end_comment

begin_function
name|spline_list_array_type
DECL|function|fitted_splines (pixel_outline_list_type pixel_outline_list)
name|fitted_splines
parameter_list|(
name|pixel_outline_list_type
name|pixel_outline_list
parameter_list|)
block|{
name|unsigned
name|this_list
decl_stmt|;
name|unsigned
name|total
init|=
literal|0
decl_stmt|;
name|spline_list_array_type
name|char_splines
init|=
name|new_spline_list_array
argument_list|()
decl_stmt|;
name|curve_list_array_type
name|curve_array
init|=
name|split_at_corners
argument_list|(
name|pixel_outline_list
argument_list|)
decl_stmt|;
for|for
control|(
name|this_list
operator|=
literal|0
init|;
name|this_list
operator|<
name|CURVE_LIST_ARRAY_LENGTH
argument_list|(
name|curve_array
argument_list|)
condition|;
name|this_list
operator|++
control|)
block|{
name|spline_list_type
name|curve_list_splines
decl_stmt|;
name|curve_list_type
name|curves
init|=
name|CURVE_LIST_ARRAY_ELT
argument_list|(
name|curve_array
argument_list|,
name|this_list
argument_list|)
decl_stmt|;
name|curve_list_splines
operator|=
name|fit_curve_list
argument_list|(
name|curves
argument_list|)
expr_stmt|;
name|append_spline_list
argument_list|(
operator|&
name|char_splines
argument_list|,
name|curve_list_splines
argument_list|)
expr_stmt|;
comment|/*       REPORT ("* "); */
block|}
name|free_curve_list_array
argument_list|(
operator|&
name|curve_array
argument_list|)
expr_stmt|;
for|for
control|(
name|this_list
operator|=
literal|0
init|;
name|this_list
operator|<
name|SPLINE_LIST_ARRAY_LENGTH
argument_list|(
name|char_splines
argument_list|)
condition|;
name|this_list
operator|++
control|)
name|total
operator|+=
name|SPLINE_LIST_LENGTH
argument_list|(
name|SPLINE_LIST_ARRAY_ELT
argument_list|(
name|char_splines
argument_list|,
name|this_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   REPORT1 ("=%u", total); */
return|return
name|char_splines
return|;
block|}
end_function

begin_comment
comment|/* Set up the internal parameters from the external ones */
end_comment

begin_function
name|void
DECL|function|fit_set_params (SELVALS * selVals)
name|fit_set_params
parameter_list|(
name|SELVALS
modifier|*
name|selVals
parameter_list|)
block|{
name|align_threshold
operator|=
name|selVals
operator|->
name|align_threshold
expr_stmt|;
name|corner_always_threshold
operator|=
name|selVals
operator|->
name|corner_always_threshold
expr_stmt|;
name|corner_surround
operator|=
name|selVals
operator|->
name|corner_surround
expr_stmt|;
name|corner_threshold
operator|=
name|selVals
operator|->
name|corner_threshold
expr_stmt|;
name|error_threshold
operator|=
name|selVals
operator|->
name|error_threshold
expr_stmt|;
name|filter_alternative_surround
operator|=
name|selVals
operator|->
name|filter_alternative_surround
expr_stmt|;
name|filter_epsilon
operator|=
name|selVals
operator|->
name|filter_epsilon
expr_stmt|;
name|filter_iteration_count
operator|=
name|selVals
operator|->
name|filter_iteration_count
expr_stmt|;
name|filter_percent
operator|=
name|selVals
operator|->
name|filter_percent
expr_stmt|;
name|filter_secondary_surround
operator|=
name|selVals
operator|->
name|filter_secondary_surround
expr_stmt|;
name|filter_surround
operator|=
name|selVals
operator|->
name|filter_surround
expr_stmt|;
name|keep_knees
operator|=
name|selVals
operator|->
name|keep_knees
expr_stmt|;
name|line_reversion_threshold
operator|=
name|selVals
operator|->
name|line_reversion_threshold
expr_stmt|;
name|line_threshold
operator|=
name|selVals
operator|->
name|line_threshold
expr_stmt|;
name|reparameterize_improvement
operator|=
name|selVals
operator|->
name|reparameterize_improvement
expr_stmt|;
name|reparameterize_threshold
operator|=
name|selVals
operator|->
name|reparameterize_threshold
expr_stmt|;
name|subdivide_search
operator|=
name|selVals
operator|->
name|subdivide_search
expr_stmt|;
name|subdivide_surround
operator|=
name|selVals
operator|->
name|subdivide_surround
expr_stmt|;
name|subdivide_threshold
operator|=
name|selVals
operator|->
name|subdivide_threshold
expr_stmt|;
name|tangent_surround
operator|=
name|selVals
operator|->
name|tangent_surround
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|fit_set_default_params (SELVALS * selVals)
name|fit_set_default_params
parameter_list|(
name|SELVALS
modifier|*
name|selVals
parameter_list|)
block|{
name|selVals
operator|->
name|align_threshold
operator|=
name|align_threshold
expr_stmt|;
name|selVals
operator|->
name|corner_always_threshold
operator|=
name|corner_always_threshold
expr_stmt|;
name|selVals
operator|->
name|corner_surround
operator|=
name|corner_surround
expr_stmt|;
name|selVals
operator|->
name|corner_threshold
operator|=
name|corner_threshold
expr_stmt|;
name|selVals
operator|->
name|error_threshold
operator|=
name|error_threshold
expr_stmt|;
name|selVals
operator|->
name|filter_alternative_surround
operator|=
name|filter_alternative_surround
expr_stmt|;
name|selVals
operator|->
name|filter_epsilon
operator|=
name|filter_epsilon
expr_stmt|;
name|selVals
operator|->
name|filter_iteration_count
operator|=
name|filter_iteration_count
expr_stmt|;
name|selVals
operator|->
name|filter_percent
operator|=
name|filter_percent
expr_stmt|;
name|selVals
operator|->
name|filter_secondary_surround
operator|=
name|filter_secondary_surround
expr_stmt|;
name|selVals
operator|->
name|filter_surround
operator|=
name|filter_surround
expr_stmt|;
name|selVals
operator|->
name|keep_knees
operator|=
name|keep_knees
expr_stmt|;
name|selVals
operator|->
name|line_reversion_threshold
operator|=
name|line_reversion_threshold
expr_stmt|;
name|selVals
operator|->
name|line_threshold
operator|=
name|line_threshold
expr_stmt|;
name|selVals
operator|->
name|reparameterize_improvement
operator|=
name|reparameterize_improvement
expr_stmt|;
name|selVals
operator|->
name|reparameterize_threshold
operator|=
name|reparameterize_threshold
expr_stmt|;
name|selVals
operator|->
name|subdivide_search
operator|=
name|subdivide_search
expr_stmt|;
name|selVals
operator|->
name|subdivide_surround
operator|=
name|subdivide_surround
expr_stmt|;
name|selVals
operator|->
name|subdivide_threshold
operator|=
name|subdivide_threshold
expr_stmt|;
name|selVals
operator|->
name|tangent_surround
operator|=
name|tangent_surround
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fit the list of curves CURVE_LIST to a list of splines, and return    it.  CURVE_LIST represents a single closed paths, e.g., either the    inside or outside outline of an `o'.  */
end_comment

begin_function
specifier|static
name|spline_list_type
DECL|function|fit_curve_list (curve_list_type curve_list)
name|fit_curve_list
parameter_list|(
name|curve_list_type
name|curve_list
parameter_list|)
block|{
name|curve_type
name|curve
decl_stmt|;
name|unsigned
name|this_curve
decl_stmt|,
name|this_spline
decl_stmt|;
name|unsigned
name|curve_list_length
init|=
name|CURVE_LIST_LENGTH
argument_list|(
name|curve_list
argument_list|)
decl_stmt|;
name|spline_list_type
name|curve_list_splines
init|=
operator|*
name|new_spline_list
argument_list|()
decl_stmt|;
comment|/* Remove the extraneous ``knee'' points before filtering.  Since the      corners have already been found, we don't need to worry about      removing a point that should be a corner.  */
if|if
condition|(
operator|!
name|keep_knees
condition|)
block|{
comment|/*       LOG ("\nRemoving knees:\n"); */
for|for
control|(
name|this_curve
operator|=
literal|0
init|;
name|this_curve
operator|<
name|curve_list_length
condition|;
name|this_curve
operator|++
control|)
block|{
comment|/*           LOG1 ("#%u:", this_curve); */
name|remove_knee_points
argument_list|(
name|CURVE_LIST_ELT
argument_list|(
name|curve_list
argument_list|,
name|this_curve
argument_list|)
argument_list|,
name|CURVE_LIST_CLOCKWISE
argument_list|(
name|curve_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We filter all the curves in CURVE_LIST at once; otherwise, we would      look at an unfiltered curve when computing tangents.  */
comment|/*   LOG ("\nFiltering curves:\n"); */
for|for
control|(
name|this_curve
operator|=
literal|0
init|;
name|this_curve
operator|<
name|curve_list
operator|.
name|length
condition|;
name|this_curve
operator|++
control|)
block|{
comment|/*       LOG1 ("#%u: ", this_curve); */
name|filter
argument_list|(
name|CURVE_LIST_ELT
argument_list|(
name|curve_list
argument_list|,
name|this_curve
argument_list|)
argument_list|)
expr_stmt|;
comment|/*       REPORT ("f"); */
block|}
comment|/* Make the first point in the first curve also be the last point in      the last curve, so the fit to the whole curve list will begin and      end at the same point.  This may cause slight errors in computing      the tangents and t values, but it's worth it for the continuity.      Of course we don't want to do this if the two points are already      the same, as they are if the curve is cyclic.  (We don't append it      earlier, in `split_at_corners', because that confuses the      filtering.)  Finally, we can't append the point if the curve is      exactly three points long, because we aren't adding any more data,      and three points isn't enough to determine a spline.  Therefore,      the fitting will fail.  */
name|curve
operator|=
name|CURVE_LIST_ELT
argument_list|(
name|curve_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURVE_CYCLIC
argument_list|(
name|curve
argument_list|)
operator|&&
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|!=
literal|3
condition|)
name|append_point
argument_list|(
name|curve
argument_list|,
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, fit each curve in the list to a list of splines.  */
for|for
control|(
name|this_curve
operator|=
literal|0
init|;
name|this_curve
operator|<
name|curve_list_length
condition|;
name|this_curve
operator|++
control|)
block|{
name|spline_list_type
modifier|*
name|curve_splines
decl_stmt|;
name|curve_type
name|current_curve
init|=
name|CURVE_LIST_ELT
argument_list|(
name|curve_list
argument_list|,
name|this_curve
argument_list|)
decl_stmt|;
comment|/*       REPORT1 (" %u", this_curve); */
comment|/*       LOG1 ("\nFitting curve #%u:\n", this_curve); */
name|curve_splines
operator|=
name|fit_curve
argument_list|(
name|current_curve
argument_list|)
expr_stmt|;
if|if
condition|(
name|curve_splines
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Could not fit curve #%u"
argument_list|,
name|this_curve
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*           LOG1 ("Fitted splines for curve #%u:\n", this_curve); */
for|for
control|(
name|this_spline
operator|=
literal|0
init|;
name|this_spline
operator|<
name|SPLINE_LIST_LENGTH
argument_list|(
operator|*
name|curve_splines
argument_list|)
condition|;
name|this_spline
operator|++
control|)
block|{
comment|/*               LOG1 ("  %u: ", this_spline); */
comment|/*               if (logging) */
comment|/*                 print_spline (log_ file, */
comment|/*                               SPLINE_LIST_ELT (*curve_splines, this_spline)); */
block|}
comment|/* After fitting, we may need to change some would-be lines              back to curves, because they are in a list with other              curves.  */
name|change_bad_lines
argument_list|(
name|curve_splines
argument_list|)
expr_stmt|;
name|concat_spline_lists
argument_list|(
operator|&
name|curve_list_splines
argument_list|,
operator|*
name|curve_splines
argument_list|)
expr_stmt|;
comment|/*           REPORT1 ("(%u)", SPLINE_LIST_LENGTH (*curve_splines)); */
block|}
block|}
comment|/* We do this for each outline's spline list because when a point      is changed, it needs to be changed in both segments in which it      appears---and the segments might be in different curves.  */
name|align
argument_list|(
operator|&
name|curve_list_splines
argument_list|)
expr_stmt|;
return|return
name|curve_list_splines
return|;
block|}
end_function

begin_comment
comment|/* Transform a set of locations to a list of splines (the fewer the    better).  We are guaranteed that CURVE does not contain any corners.    We return NULL if we cannot fit the points at all.  */
end_comment

begin_function
specifier|static
name|spline_list_type
modifier|*
DECL|function|fit_curve (curve_type curve)
name|fit_curve
parameter_list|(
name|curve_type
name|curve
parameter_list|)
block|{
name|spline_list_type
modifier|*
name|fitted_splines
decl_stmt|;
if|if
condition|(
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Tried to fit curve with less than two points"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Do we have enough points to fit with a spline?  */
name|fitted_splines
operator|=
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|<
literal|4
condition|?
name|fit_with_line
argument_list|(
name|curve
argument_list|)
else|:
name|fit_with_least_squares
argument_list|(
name|curve
argument_list|)
expr_stmt|;
return|return
name|fitted_splines
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* As mentioned above, the first step is to find the corners in    PIXEL_LIST, the list of points.  (Presumably we can't fit a single    spline around a corner.)  The general strategy is to look through all    the points, remembering which we want to consider corners.  Then go    through that list, producing the curve_list.  This is dictated by the    fact that PIXEL_LIST does not necessarily start on a corner---it just    starts at the character's first outline pixel, going left-to-right,    top-to-bottom.  But we want all our splines to start and end on real    corners.     For example, consider the top of a capital `C' (this is in cmss20):                      x                      ***********                   ******************     PIXEL_LIST will start at the pixel below the `x'.  If we considered    this pixel a corner, we would wind up matching a very small segment    from there to the end of the line, probably as a straight line, which    is certainly not what we want.       PIXEL_LIST has one element for each closed outline on the character.    To preserve this information, we return an array of curve_lists, one    element (which in turn consists of several curves, one between each    pair of corners) for each element in PIXEL_LIST.  */
end_comment

begin_function
specifier|static
name|curve_list_array_type
DECL|function|split_at_corners (pixel_outline_list_type pixel_list)
name|split_at_corners
parameter_list|(
name|pixel_outline_list_type
name|pixel_list
parameter_list|)
block|{
name|unsigned
name|this_pixel_o
decl_stmt|;
name|curve_list_array_type
name|curve_array
init|=
name|new_curve_list_array
argument_list|()
decl_stmt|;
comment|/*   LOG ("\nFinding corners:\n"); */
for|for
control|(
name|this_pixel_o
operator|=
literal|0
init|;
name|this_pixel_o
operator|<
name|O_LIST_LENGTH
argument_list|(
name|pixel_list
argument_list|)
condition|;
name|this_pixel_o
operator|++
control|)
block|{
name|curve_type
name|curve
decl_stmt|,
name|first_curve
decl_stmt|;
name|index_list_type
name|corner_list
decl_stmt|;
name|unsigned
name|p
decl_stmt|,
name|this_corner
decl_stmt|;
name|curve_list_type
name|curve_list
init|=
name|new_curve_list
argument_list|()
decl_stmt|;
name|pixel_outline_type
name|pixel_o
init|=
name|O_LIST_OUTLINE
argument_list|(
name|pixel_list
argument_list|,
name|this_pixel_o
argument_list|)
decl_stmt|;
name|CURVE_LIST_CLOCKWISE
argument_list|(
name|curve_list
argument_list|)
operator|=
name|O_CLOCKWISE
argument_list|(
name|pixel_o
argument_list|)
expr_stmt|;
comment|/*       LOG1 ("#%u:", this_pixel_o); */
comment|/* If the outline does not have enough points, we can't do          anything.  The endpoints of the outlines are automatically          corners.  We need at least `corner_surround' more pixels on          either side of a point before it is conceivable that we might          want another corner.  */
if|if
condition|(
name|O_LENGTH
argument_list|(
name|pixel_o
argument_list|)
operator|>
name|corner_surround
operator|*
literal|2
operator|+
literal|2
condition|)
name|corner_list
operator|=
name|find_corners
argument_list|(
name|pixel_o
argument_list|)
expr_stmt|;
else|else
name|corner_list
operator|.
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Remember the first curve so we can make it be the `next' of the          last one.  (And vice versa.)  */
name|first_curve
operator|=
name|new_curve
argument_list|()
expr_stmt|;
name|curve
operator|=
name|first_curve
expr_stmt|;
if|if
condition|(
name|corner_list
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|/* No corners.  Use all of the pixel outline as the curve.  */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|O_LENGTH
argument_list|(
name|pixel_o
argument_list|)
condition|;
name|p
operator|++
control|)
name|append_pixel
argument_list|(
name|curve
argument_list|,
name|O_COORDINATE
argument_list|(
name|pixel_o
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This curve is cyclic.  */
name|CURVE_CYCLIC
argument_list|(
name|curve
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Each curve consists of the points between (inclusive) each pair              of corners.  */
for|for
control|(
name|this_corner
operator|=
literal|0
init|;
name|this_corner
operator|<
name|corner_list
operator|.
name|length
operator|-
literal|1
condition|;
name|this_corner
operator|++
control|)
block|{
name|curve_type
name|previous_curve
init|=
name|curve
decl_stmt|;
name|unsigned
name|corner
init|=
name|GET_INDEX
argument_list|(
name|corner_list
argument_list|,
name|this_corner
argument_list|)
decl_stmt|;
name|unsigned
name|next_corner
init|=
name|GET_INDEX
argument_list|(
name|corner_list
argument_list|,
name|this_corner
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|corner
init|;
name|p
operator|<=
name|next_corner
condition|;
name|p
operator|++
control|)
name|append_pixel
argument_list|(
name|curve
argument_list|,
name|O_COORDINATE
argument_list|(
name|pixel_o
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|append_curve
argument_list|(
operator|&
name|curve_list
argument_list|,
name|curve
argument_list|)
expr_stmt|;
name|curve
operator|=
name|new_curve
argument_list|()
expr_stmt|;
name|NEXT_CURVE
argument_list|(
name|previous_curve
argument_list|)
operator|=
name|curve
expr_stmt|;
name|PREVIOUS_CURVE
argument_list|(
name|curve
argument_list|)
operator|=
name|previous_curve
expr_stmt|;
block|}
comment|/* The last curve is different.  It consists of the points              (inclusive) between the last corner and the end of the list,              and the beginning of the list and the first corner.  */
for|for
control|(
name|p
operator|=
name|GET_LAST_INDEX
argument_list|(
name|corner_list
argument_list|)
init|;
name|p
operator|<
name|O_LENGTH
argument_list|(
name|pixel_o
argument_list|)
condition|;
name|p
operator|++
control|)
name|append_pixel
argument_list|(
name|curve
argument_list|,
name|O_COORDINATE
argument_list|(
name|pixel_o
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<=
name|GET_INDEX
argument_list|(
name|corner_list
argument_list|,
literal|0
argument_list|)
condition|;
name|p
operator|++
control|)
name|append_pixel
argument_list|(
name|curve
argument_list|,
name|O_COORDINATE
argument_list|(
name|pixel_o
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*       LOG1 (" [%u].\n", corner_list.length); */
comment|/* Add `curve' to the end of the list, updating the pointers in          the chain.  */
name|append_curve
argument_list|(
operator|&
name|curve_list
argument_list|,
name|curve
argument_list|)
expr_stmt|;
name|NEXT_CURVE
argument_list|(
name|curve
argument_list|)
operator|=
name|first_curve
expr_stmt|;
name|PREVIOUS_CURVE
argument_list|(
name|first_curve
argument_list|)
operator|=
name|curve
expr_stmt|;
comment|/* And now add the just-completed curve list to the array.  */
name|append_curve_list
argument_list|(
operator|&
name|curve_array
argument_list|,
name|curve_list
argument_list|)
expr_stmt|;
block|}
comment|/* End of considering each pixel outline.  */
return|return
name|curve_array
return|;
block|}
end_function

begin_comment
comment|/* We consider a point to be a corner if (1) the angle defined by the    `corner_surround' points coming into it and going out from it is less    than `corner_threshold' degrees, and no point within    `corner_surround' points has a smaller angle; or (2) the angle is less    than `corner_always_threshold' degrees.     Because of the different cases, it is convenient to have the    following macro to append a corner on to the list we return.  The    character argument C is simply so that the different cases can be    distinguished in the log file.  */
end_comment

begin_define
DECL|macro|APPEND_CORNER (index,angle,c)
define|#
directive|define
name|APPEND_CORNER
parameter_list|(
name|index
parameter_list|,
name|angle
parameter_list|,
name|c
parameter_list|)
define|\
value|do									\     {									\       append_index (&corner_list, index);				\
comment|/*LOG4 (" (%d,%d)%c%.3f",	*/
value|\
comment|/*      O_COORDINATE (pixel_outline, index).x,*/
value|\
comment|/*      O_COORDINATE (pixel_outline, index).y,*/
value|\
comment|/*      c, angle);*/
value|\     }									\   while (0)
end_define

begin_function
specifier|static
name|index_list_type
DECL|function|find_corners (pixel_outline_type pixel_outline)
name|find_corners
parameter_list|(
name|pixel_outline_type
name|pixel_outline
parameter_list|)
block|{
name|unsigned
name|p
decl_stmt|;
name|index_list_type
name|corner_list
init|=
name|new_index_list
argument_list|()
decl_stmt|;
comment|/* Consider each pixel on the outline in turn.  */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|O_LENGTH
argument_list|(
name|pixel_outline
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
name|real
name|corner_angle
decl_stmt|;
name|vector_type
name|in_vector
decl_stmt|,
name|out_vector
decl_stmt|;
comment|/* Check if the angle is small enough.  */
name|find_vectors
argument_list|(
name|p
argument_list|,
name|pixel_outline
argument_list|,
operator|&
name|in_vector
argument_list|,
operator|&
name|out_vector
argument_list|)
expr_stmt|;
name|corner_angle
operator|=
name|Vangle
argument_list|(
name|in_vector
argument_list|,
name|out_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|corner_angle
argument_list|)
operator|<=
name|corner_threshold
condition|)
block|{
comment|/* We want to keep looking, instead of just appending the              first pixel we find with a small enough angle, since there              might be another corner within `corner_surround' pixels, with              a smaller angle.  If that is the case, we want that one.  */
name|real
name|best_corner_angle
init|=
name|corner_angle
decl_stmt|;
name|unsigned
name|best_corner_index
init|=
name|p
decl_stmt|;
name|index_list_type
name|equally_good_list
init|=
name|new_index_list
argument_list|()
decl_stmt|;
comment|/* As we come into the loop, `p' is the index of the point              that has an angle less than `corner_angle'.  We use `i' to              move through the pixels next to that, and `q' for moving              through the adjacent pixels to each `p'.  */
name|unsigned
name|q
init|=
name|p
decl_stmt|;
name|unsigned
name|i
init|=
name|p
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* Perhaps the angle is sufficiently small that we want to                  consider this a corner, even if it's not the best                  (unless we've already wrapped around in the search,                  i.e., `q<i', in which case we have already added the                  corner, and we don't want to add it again).  We want to                  do this check on the first candidate we find, as well                  as the others in the loop, hence this comes before the                  stopping condition.  */
if|if
condition|(
name|corner_angle
operator|<=
name|corner_always_threshold
operator|&&
name|q
operator|>=
name|p
condition|)
name|APPEND_CORNER
argument_list|(
name|q
argument_list|,
name|corner_angle
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
comment|/* Exit the loop if we've looked at `corner_surround'                  pixels past the best one we found, or if we've looked                  at all the pixels.  */
if|if
condition|(
name|i
operator|>=
name|best_corner_index
operator|+
name|corner_surround
operator|||
name|i
operator|>=
name|O_LENGTH
argument_list|(
name|pixel_outline
argument_list|)
condition|)
break|break;
comment|/* Check the angle.  */
name|q
operator|=
name|i
operator|%
name|O_LENGTH
argument_list|(
name|pixel_outline
argument_list|)
expr_stmt|;
name|find_vectors
argument_list|(
name|q
argument_list|,
name|pixel_outline
argument_list|,
operator|&
name|in_vector
argument_list|,
operator|&
name|out_vector
argument_list|)
expr_stmt|;
name|corner_angle
operator|=
name|Vangle
argument_list|(
name|in_vector
argument_list|,
name|out_vector
argument_list|)
expr_stmt|;
comment|/* If we come across a corner that is just as good as the                  best one, we should make it a corner, too.  This                  happens, for example, at the points on the `W' in some                  typefaces, where the ``points'' are flat.  */
if|if
condition|(
name|epsilon_equal
argument_list|(
name|corner_angle
argument_list|,
name|best_corner_angle
argument_list|)
condition|)
name|append_index
argument_list|(
operator|&
name|equally_good_list
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|corner_angle
operator|<
name|best_corner_angle
condition|)
block|{
name|best_corner_angle
operator|=
name|corner_angle
expr_stmt|;
comment|/* We want to check `corner_surround' pixels beyond the                      new best corner.  */
name|i
operator|=
name|best_corner_index
operator|=
name|q
expr_stmt|;
name|free_index_list
argument_list|(
operator|&
name|equally_good_list
argument_list|)
expr_stmt|;
name|equally_good_list
operator|=
name|new_index_list
argument_list|()
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* After we exit the loop, `q' is the index of the last point              we checked.  We have already added the corner if              `best_corner_angle' is less than `corner_always_threshold'.              Again, if we've already wrapped around, we don't want to              add the corner again.  */
if|if
condition|(
name|best_corner_angle
operator|>
name|corner_always_threshold
operator|&&
name|best_corner_index
operator|>=
name|p
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|APPEND_CORNER
argument_list|(
name|best_corner_index
argument_list|,
name|best_corner_angle
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INDEX_LIST_LENGTH
argument_list|(
name|equally_good_list
argument_list|)
condition|;
name|i
operator|++
control|)
name|APPEND_CORNER
argument_list|(
name|GET_INDEX
argument_list|(
name|equally_good_list
argument_list|,
name|i
argument_list|)
argument_list|,
name|best_corner_angle
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|free_index_list
argument_list|(
operator|&
name|equally_good_list
argument_list|)
expr_stmt|;
block|}
comment|/* If we wrapped around in our search, we're done; otherwise,              we don't want the outer loop to look at the pixels that we              already looked at in searching for the best corner.  */
name|p
operator|=
operator|(
name|q
operator|<
name|p
operator|)
condition|?
name|O_LENGTH
argument_list|(
name|pixel_outline
argument_list|)
else|:
name|q
expr_stmt|;
block|}
comment|/* End of searching for the best corner.  */
block|}
comment|/* End of considering each pixel.  */
if|if
condition|(
name|INDEX_LIST_LENGTH
argument_list|(
name|corner_list
argument_list|)
operator|>
literal|0
condition|)
comment|/* We never want two corners next to each other, since the        only way to fit such a ``curve'' would be with a straight        line, which usually interrupts the continuity dreadfully.  */
name|remove_adjacent_corners
argument_list|(
operator|&
name|corner_list
argument_list|,
name|O_LENGTH
argument_list|(
name|pixel_outline
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|corner_list
return|;
block|}
end_function

begin_comment
comment|/* Return the difference vectors coming in and going out of the outline    OUTLINE at the point whose index is TEST_INDEX.  In Phoenix,    Schneider looks at a single point on either side of the point we're    considering.  That works for him because his points are not touching.    But our points *are* touching, and so we have to look at    `corner_surround' points on either side, to get a better picture of    the outline's shape.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_vectors (unsigned test_index,pixel_outline_type outline,vector_type * in,vector_type * out)
name|find_vectors
parameter_list|(
name|unsigned
name|test_index
parameter_list|,
name|pixel_outline_type
name|outline
parameter_list|,
name|vector_type
modifier|*
name|in
parameter_list|,
name|vector_type
modifier|*
name|out
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|n_done
decl_stmt|;
name|coordinate_type
name|candidate
init|=
name|O_COORDINATE
argument_list|(
name|outline
argument_list|,
name|test_index
argument_list|)
decl_stmt|;
operator|*
name|in
operator|=
operator|(
name|vector_type
operator|)
block|{
literal|0.0
block|,
literal|0.0
block|}
expr_stmt|;
operator|*
name|out
operator|=
operator|(
name|vector_type
operator|)
block|{
literal|0.0
block|,
literal|0.0
block|}
expr_stmt|;
comment|/* Add up the differences from p of the `corner_surround' points      before p.  */
for|for
control|(
name|i
operator|=
name|O_PREV
argument_list|(
name|outline
argument_list|,
name|test_index
argument_list|)
operator|,
name|n_done
operator|=
literal|0
init|;
name|n_done
operator|<
name|corner_surround
condition|;
name|i
operator|=
name|O_PREV
argument_list|(
name|outline
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
operator|*
name|in
operator|=
name|Vadd
argument_list|(
operator|*
name|in
argument_list|,
name|IPsubtract
argument_list|(
name|O_COORDINATE
argument_list|(
name|outline
argument_list|,
name|i
argument_list|)
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We don't need this code any more, because now we create the pixel      outline from the corners of the pixels, rather than the edges.  */
comment|/* To see why we need this test, consider the following      case: four pixels stacked vertically with no other adjacent pixels,      i.e.,   *              *x              *              *             *** (etc.) We are considering the pixel marked `x' for cornerhood.      The out vector at this point is going to be the zero vector (if      `corner_surround' is 3), because the first      pixel on the outline is the one above the x, the second pixel x      itself, and the third the one below x.  (Remember that we go      around the edges of the pixels to find the outlines, not the      pixels themselves.)  */
block|if (magnitude (*in) == 0.0)     {       WARNING ("Zero magnitude in");       return corner_threshold + 1.0;     }
endif|#
directive|endif
comment|/* 0 */
comment|/* And the points after p.  */
for|for
control|(
name|i
operator|=
name|O_NEXT
argument_list|(
name|outline
argument_list|,
name|test_index
argument_list|)
operator|,
name|n_done
operator|=
literal|0
init|;
name|n_done
operator|<
name|corner_surround
condition|;
name|i
operator|=
name|O_NEXT
argument_list|(
name|outline
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
operator|*
name|out
operator|=
name|Vadd
argument_list|(
operator|*
name|out
argument_list|,
name|IPsubtract
argument_list|(
name|O_COORDINATE
argument_list|(
name|outline
argument_list|,
name|i
argument_list|)
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* As with the test for the in vector, we don't need this any more.  */
block|if (magnitude (*out) == 0.0)     {       WARNING ("Zero magnitude out");       return corner_threshold + 1.0;     }
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_comment
comment|/* Remove adjacent points from the index list LIST.  We do this by first    sorting the list and then running through it.  Since these lists are    quite short, a straight selection sort (e.g., p.139 of the Art of    Computer Programming, vol.3) is good enough.  LAST_INDEX is the index    of the last pixel on the outline, i.e., the next one is the first    pixel.  We need this for checking the adjacency of the last corner.        We need to do this because the adjacent corners turn into    two-pixel-long curves, which can only be fit by straight lines.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|remove_adjacent_corners (index_list_type * list,unsigned last_index)
name|remove_adjacent_corners
parameter_list|(
name|index_list_type
modifier|*
name|list
parameter_list|,
name|unsigned
name|last_index
parameter_list|)
block|{
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|last
decl_stmt|;
name|index_list_type
name|new
init|=
name|new_index_list
argument_list|()
decl_stmt|;
for|for
control|(
name|j
operator|=
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|list
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|unsigned
name|search
decl_stmt|;
name|unsigned
name|temp
decl_stmt|;
comment|/* Find maximal element below `j'.  */
name|unsigned
name|max_index
init|=
name|j
decl_stmt|;
for|for
control|(
name|search
operator|=
literal|0
init|;
name|search
operator|<
name|j
condition|;
name|search
operator|++
control|)
if|if
condition|(
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|search
argument_list|)
operator|>
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|max_index
argument_list|)
condition|)
name|max_index
operator|=
name|search
expr_stmt|;
if|if
condition|(
name|max_index
operator|!=
name|j
condition|)
block|{
name|temp
operator|=
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|j
argument_list|)
operator|=
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|max_index
argument_list|)
expr_stmt|;
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|max_index
argument_list|)
operator|=
name|temp
expr_stmt|;
name|printf
argument_list|(
literal|"needed exchange"
argument_list|)
expr_stmt|;
comment|/* xx -- really have to sort?  */
block|}
block|}
comment|/* The list is sorted.  Now look for adjacent entries.  Each time      through the loop we insert the current entry and, if appropriate,      the next entry.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|list
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|current
init|=
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|unsigned
name|next
init|=
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
name|j
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* We should never have inserted the same element twice.  */
name|assert
argument_list|(
name|current
operator|!=
name|next
argument_list|)
expr_stmt|;
name|append_index
argument_list|(
operator|&
name|new
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|current
operator|+
literal|1
condition|)
name|j
operator|++
expr_stmt|;
block|}
comment|/* Don't append the last element if it is 1) adjacent to the previous      one; or 2) adjacent to the very first one.  */
name|last
operator|=
name|GET_LAST_INDEX
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_LIST_LENGTH
argument_list|(
name|new
argument_list|)
operator|==
literal|0
operator|||
operator|!
operator|(
name|last
operator|==
name|GET_LAST_INDEX
argument_list|(
name|new
argument_list|)
operator|+
literal|1
operator|||
operator|(
name|last
operator|==
name|last_index
operator|&&
name|GET_INDEX
argument_list|(
operator|*
name|list
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|append_index
argument_list|(
operator|&
name|new
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|free_index_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A ``knee'' is a point which forms a ``right angle'' with its    predecessor and successor.  See the documentation (the `Removing    knees' section) for an example and more details.     The argument CLOCKWISE tells us which direction we're moving.  (We    can't figure that information out from just the single segment with    which we are given to work.)        We should never find two consecutive knees.        Since the first and last points are corners (unless the curve is    cyclic), it doesn't make sense to remove those.  */
end_comment

begin_comment
comment|/* This evaluates to true if the vector V is zero in one direction and    nonzero in the other.  */
end_comment

begin_define
DECL|macro|ONLY_ONE_ZERO (v)
define|#
directive|define
name|ONLY_ONE_ZERO
parameter_list|(
name|v
parameter_list|)
define|\
value|(((v).dx == 0.0&& (v).dy != 0.0) || ((v).dy == 0.0&& (v).dx != 0.0))
end_define

begin_comment
comment|/* There are four possible cases for knees, one for each of the four    corners of a rectangle; and then the cases differ depending on which    direction we are going around the curve.  The tests are listed here    in the order of upper left, upper right, lower right, lower left.    Perhaps there is some simple pattern to the    clockwise/counterclockwise differences, but I don't see one.  */
end_comment

begin_define
DECL|macro|CLOCKWISE_KNEE (prev_delta,next_delta)
define|#
directive|define
name|CLOCKWISE_KNEE
parameter_list|(
name|prev_delta
parameter_list|,
name|next_delta
parameter_list|)
define|\
value|((prev_delta.dx == -1.0&& next_delta.dy == 1.0)			\    || (prev_delta.dy == 1.0&& next_delta.dx == 1.0)			\    || (prev_delta.dx == 1.0&& next_delta.dy == -1.0)			\    || (prev_delta.dy == -1.0&& next_delta.dx == -1.0))
end_define

begin_define
DECL|macro|COUNTERCLOCKWISE_KNEE (prev_delta,next_delta)
define|#
directive|define
name|COUNTERCLOCKWISE_KNEE
parameter_list|(
name|prev_delta
parameter_list|,
name|next_delta
parameter_list|)
define|\
value|((prev_delta.dy == 1.0&& next_delta.dx == -1.0)			\    || (prev_delta.dx == 1.0&& next_delta.dy == 1.0)			\    || (prev_delta.dy == -1.0&& next_delta.dx == 1.0)			\    || (prev_delta.dx == -1.0&& next_delta.dy == -1.0))
end_define

begin_function
specifier|static
name|void
DECL|function|remove_knee_points (curve_type curve,boolean clockwise)
name|remove_knee_points
parameter_list|(
name|curve_type
name|curve
parameter_list|,
name|boolean
name|clockwise
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|offset
init|=
name|CURVE_CYCLIC
argument_list|(
name|curve
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|coordinate_type
name|previous
init|=
name|real_to_int_coord
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|CURVE_PREV
argument_list|(
name|curve
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|curve_type
name|trimmed_curve
init|=
name|copy_most_of_curve
argument_list|(
name|curve
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CURVE_CYCLIC
argument_list|(
name|curve
argument_list|)
condition|)
name|append_pixel
argument_list|(
name|trimmed_curve
argument_list|,
name|real_to_int_coord
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|-
name|offset
condition|;
name|i
operator|++
control|)
block|{
name|coordinate_type
name|current
init|=
name|real_to_int_coord
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|coordinate_type
name|next
init|=
name|real_to_int_coord
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|CURVE_NEXT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|vector_type
name|prev_delta
init|=
name|IPsubtract
argument_list|(
name|previous
argument_list|,
name|current
argument_list|)
decl_stmt|;
name|vector_type
name|next_delta
init|=
name|IPsubtract
argument_list|(
name|next
argument_list|,
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|ONLY_ONE_ZERO
argument_list|(
name|prev_delta
argument_list|)
operator|&&
name|ONLY_ONE_ZERO
argument_list|(
name|next_delta
argument_list|)
operator|&&
operator|(
operator|(
name|clockwise
operator|&&
name|CLOCKWISE_KNEE
argument_list|(
name|prev_delta
argument_list|,
name|next_delta
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|clockwise
operator|&&
name|COUNTERCLOCKWISE_KNEE
argument_list|(
name|prev_delta
argument_list|,
name|next_delta
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* LOG2 (" (%d,%d)", current.x, current.y); */
block|}
else|else
block|{
name|previous
operator|=
name|current
expr_stmt|;
name|append_pixel
argument_list|(
name|trimmed_curve
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|CURVE_CYCLIC
argument_list|(
name|curve
argument_list|)
condition|)
name|append_pixel
argument_list|(
name|trimmed_curve
argument_list|,
name|real_to_int_coord
argument_list|(
name|LAST_CURVE_POINT
argument_list|(
name|curve
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   if (CURVE_LENGTH (trimmed_curve) == CURVE_LENGTH (curve)) */
comment|/*     LOG (" (none)"); */
comment|/*   LOG (".\n"); */
name|free_curve
argument_list|(
name|curve
argument_list|)
expr_stmt|;
operator|*
name|curve
operator|=
operator|*
name|trimmed_curve
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Smooth the curve by adding in neighboring points.  Do this    `filter_iteration_count' times.  But don't change the corners.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Computing the new point based on a single neighboring point and with    constant percentages, as the `SMOOTH' macro did, isn't quite good    enough.  For example, at the top of an `o' the curve might well have    three consecutive horizontal pixels, even though there isn't really a    straight there.  With this code, the middle point would remain    unfiltered.  */
end_comment

begin_define
define|#
directive|define
name|SMOOTH
parameter_list|(
name|axis
parameter_list|)
define|\
value|CURVE_POINT (curve, this_point).axis					\     = ((1.0 - center_percent) / 2)					\        * CURVE_POINT (curve, CURVE_PREV (curve, this_point)).axis   	\       + center_percent * CURVE_POINT (curve, this_point).axis		\       + ((1.0 - center_percent) / 2)					\         * CURVE_POINT (curve, CURVE_NEXT (curve, this_point)).axis
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* We sometimes need to change the information about the filtered point.    This macro assigns to the relevant variables.  */
end_comment

begin_define
DECL|macro|FILTER_ASSIGN (new)
define|#
directive|define
name|FILTER_ASSIGN
parameter_list|(
name|new
parameter_list|)
define|\
value|do									\     {									\       in = in_##new;							\       out = out_##new;							\       count = new##_count;						\       angle = angle_##new;						\     }									\   while (0)
end_define

begin_function
specifier|static
name|void
DECL|function|filter (curve_type curve)
name|filter
parameter_list|(
name|curve_type
name|curve
parameter_list|)
block|{
name|unsigned
name|iteration
decl_stmt|,
name|this_point
decl_stmt|;
name|unsigned
name|offset
init|=
name|CURVE_CYCLIC
argument_list|(
name|curve
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* We must have at least three points---the previous one, the current      one, and the next one.  But if we don't have at least five, we will      probably collapse the curve down onto a single point, which means      we won't be able to fit it with a spline.  */
if|if
condition|(
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|<
literal|5
condition|)
block|{
comment|/*       LOG1 ("Length is %u, not enough to filter.\n", CURVE_LENGTH (curve)); */
return|return;
block|}
for|for
control|(
name|iteration
operator|=
literal|0
init|;
name|iteration
operator|<
name|filter_iteration_count
condition|;
name|iteration
operator|++
control|)
block|{
name|curve_type
name|new_curve
init|=
name|copy_most_of_curve
argument_list|(
name|curve
argument_list|)
decl_stmt|;
comment|/* Keep the first point on the curve.  */
if|if
condition|(
name|offset
condition|)
name|append_point
argument_list|(
name|new_curve
argument_list|,
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|this_point
operator|=
name|offset
init|;
name|this_point
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|-
name|offset
condition|;
name|this_point
operator|++
control|)
block|{
name|real
name|angle
decl_stmt|,
name|angle_alt
decl_stmt|;
name|vector_type
name|in
decl_stmt|,
name|in_alt
decl_stmt|,
name|out
decl_stmt|,
name|out_alt
decl_stmt|,
name|sum
decl_stmt|;
name|unsigned
name|count
decl_stmt|,
name|alt_count
decl_stmt|;
name|real_coordinate_type
name|new_point
decl_stmt|;
comment|/* Find the angle using the usual number of surrounding points              on the curve. */
name|find_curve_vectors
argument_list|(
name|this_point
argument_list|,
name|curve
argument_list|,
name|filter_surround
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|angle
operator|=
name|filter_angle
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Find the angle using the alternative (presumably smaller)              number.  */
name|find_curve_vectors
argument_list|(
name|this_point
argument_list|,
name|curve
argument_list|,
name|filter_alternative_surround
argument_list|,
operator|&
name|in_alt
argument_list|,
operator|&
name|out_alt
argument_list|,
operator|&
name|alt_count
argument_list|)
expr_stmt|;
name|angle_alt
operator|=
name|filter_angle
argument_list|(
name|in_alt
argument_list|,
name|out_alt
argument_list|)
expr_stmt|;
comment|/* If the alternate angle is enough larger than the usual one              and neither of the components of the sum are zero, use it.              (We don't use absolute value here, since if the alternate              angle is smaller, we don't particularly care, since that              means the curve is pretty flat around the current point,              anyway.)  This helps keep small features from disappearing              into the surrounding curve.  */
name|sum
operator|=
name|Vadd
argument_list|(
name|in_alt
argument_list|,
name|out_alt
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle_alt
operator|-
name|angle
operator|>=
name|filter_epsilon
operator|&&
name|sum
operator|.
name|dx
operator|!=
literal|0
operator|&&
name|sum
operator|.
name|dy
operator|!=
literal|0
condition|)
name|FILTER_ASSIGN
argument_list|(
name|alt
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code isn't needed anymore, since we do the filtering in a    somewhat more general way.  */
comment|/* If we're left with an angle of zero, don't stop yet; we              might be at a straight which really isn't one (as in the `o'              discussed above).  */
block|if (epsilon_equal (angle, 0.0))             {               real angle_secondary;               vector_type in_secondary, out_secondary;               unsigned in_secondary_count, out_secondary_count;                find_curve_vectors (this_point, curve, filter_secondary_surround,&in_secondary,&out_secondary,&in_secondary_count,&out_secondary_count);               angle_secondary = filter_angle (in_secondary, out_secondary);               if (!epsilon_equal (angle_secondary, 0.0))                 FILTER_ASSIGN (secondary);             }
endif|#
directive|endif
comment|/* 0 */
comment|/* Start with the old point.  */
name|new_point
operator|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|this_point
argument_list|)
expr_stmt|;
name|sum
operator|=
name|Vadd
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|new_point
operator|.
name|x
operator|+=
name|sum
operator|.
name|dx
operator|*
name|filter_percent
operator|/
name|count
expr_stmt|;
name|new_point
operator|.
name|y
operator|+=
name|sum
operator|.
name|dy
operator|*
name|filter_percent
operator|/
name|count
expr_stmt|;
comment|/* Put the newly computed point into a separate curve, so it              doesn't affect future computation (on this iteration).  */
name|append_point
argument_list|(
name|new_curve
argument_list|,
name|new_point
argument_list|)
expr_stmt|;
block|}
comment|/* Just as with the first point, we have to keep the last point.  */
if|if
condition|(
name|offset
condition|)
name|append_point
argument_list|(
name|new_curve
argument_list|,
name|LAST_CURVE_POINT
argument_list|(
name|curve
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the original curve to the newly filtered one, and go again.  */
name|free_curve
argument_list|(
name|curve
argument_list|)
expr_stmt|;
operator|*
name|curve
operator|=
operator|*
name|new_curve
expr_stmt|;
block|}
comment|/*   log_curve (curve, false); */
comment|/*   display_curve (curve); */
block|}
end_function

begin_comment
comment|/* Return the vectors IN and OUT, computed by looking at SURROUND points    on either side of TEST_INDEX.  Also return the number of points in    the vectors in COUNT (we make sure they are the same).  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_curve_vectors (unsigned test_index,curve_type curve,unsigned surround,vector_type * in,vector_type * out,unsigned * count)
name|find_curve_vectors
parameter_list|(
name|unsigned
name|test_index
parameter_list|,
name|curve_type
name|curve
parameter_list|,
name|unsigned
name|surround
parameter_list|,
name|vector_type
modifier|*
name|in
parameter_list|,
name|vector_type
modifier|*
name|out
parameter_list|,
name|unsigned
modifier|*
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|in_count
decl_stmt|,
name|out_count
decl_stmt|;
name|unsigned
name|n_done
decl_stmt|;
name|real_coordinate_type
name|candidate
init|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|test_index
argument_list|)
decl_stmt|;
comment|/* Add up the differences from p of the `surround' points      before p.  */
operator|*
name|in
operator|=
operator|(
name|vector_type
operator|)
block|{
literal|0.0
block|,
literal|0.0
block|}
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CURVE_PREV
argument_list|(
name|curve
argument_list|,
name|test_index
argument_list|)
operator|,
name|n_done
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
operator|&&
name|n_done
operator|<
name|surround
condition|;
comment|/* Do not wrap around.  */
name|i
operator|=
name|CURVE_PREV
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
operator|*
name|in
operator|=
name|Vadd
argument_list|(
operator|*
name|in
argument_list|,
name|Psubtract
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|in_count
operator|=
name|n_done
expr_stmt|;
comment|/* And the points after p.  Don't use more points after p than we      ended up with before it.  */
operator|*
name|out
operator|=
operator|(
name|vector_type
operator|)
block|{
literal|0.0
block|,
literal|0.0
block|}
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CURVE_NEXT
argument_list|(
name|curve
argument_list|,
name|test_index
argument_list|)
operator|,
name|n_done
operator|=
literal|0
init|;
name|i
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|&&
name|n_done
operator|<
name|surround
operator|&&
name|n_done
operator|<
name|in_count
condition|;
name|i
operator|=
name|CURVE_NEXT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
operator|*
name|out
operator|=
name|Vadd
argument_list|(
operator|*
name|out
argument_list|,
name|Psubtract
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|out_count
operator|=
name|n_done
expr_stmt|;
comment|/* If we used more points before p than after p, we have to go back      and redo it.  (We could just subtract the ones that were missing,      but for this few of points, efficiency doesn't matter.)  */
if|if
condition|(
name|out_count
operator|<
name|in_count
condition|)
block|{
operator|*
name|in
operator|=
operator|(
name|vector_type
operator|)
block|{
literal|0.0
block|,
literal|0.0
block|}
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CURVE_PREV
argument_list|(
name|curve
argument_list|,
name|test_index
argument_list|)
operator|,
name|n_done
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
operator|&&
name|n_done
operator|<
name|out_count
condition|;
name|i
operator|=
name|CURVE_PREV
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
operator|*
name|in
operator|=
name|Vadd
argument_list|(
operator|*
name|in
argument_list|,
name|Psubtract
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|in_count
operator|=
name|n_done
expr_stmt|;
block|}
name|assert
argument_list|(
name|in_count
operator|==
name|out_count
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|in_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the angle between the vectors IN and OUT, and bring it into the    range [0,45].  */
end_comment

begin_function
specifier|static
name|real
DECL|function|filter_angle (vector_type in,vector_type out)
name|filter_angle
parameter_list|(
name|vector_type
name|in
parameter_list|,
name|vector_type
name|out
parameter_list|)
block|{
name|real
name|angle
init|=
name|Vangle
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
decl_stmt|;
comment|/* What we want to do between 90 and 180 is the same as what we      want to do between 0 and 90.  */
name|angle
operator|=
name|fmod
argument_list|(
name|angle
argument_list|,
literal|1990.0
argument_list|)
expr_stmt|;
comment|/* And what we want to do between 45 and 90 is the same as      between 0 and 45, only reversed.  */
if|if
condition|(
name|angle
operator|>
literal|45.0
condition|)
name|angle
operator|=
literal|90.0
operator|-
name|angle
expr_stmt|;
return|return
name|angle
return|;
block|}
end_function

begin_comment
comment|/* This routine returns the curve fitted to a straight line in a very    simple way: make the first and last points on the curve be the    endpoints of the line.  This simplicity is justified because we are    called only on very short curves.  */
end_comment

begin_function
specifier|static
name|spline_list_type
modifier|*
DECL|function|fit_with_line (curve_type curve)
name|fit_with_line
parameter_list|(
name|curve_type
name|curve
parameter_list|)
block|{
name|spline_type
name|line
init|=
name|new_spline
argument_list|()
decl_stmt|;
comment|/*   LOG ("Fitting with straight line:\n"); */
comment|/*   REPORT ("l"); */
name|SPLINE_DEGREE
argument_list|(
name|line
argument_list|)
operator|=
name|LINEAR
expr_stmt|;
name|START_POINT
argument_list|(
name|line
argument_list|)
operator|=
name|CONTROL1
argument_list|(
name|line
argument_list|)
operator|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|END_POINT
argument_list|(
name|line
argument_list|)
operator|=
name|CONTROL2
argument_list|(
name|line
argument_list|)
operator|=
name|LAST_CURVE_POINT
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/* Make sure that this line is never changed to a cubic.  */
name|SPLINE_LINEARITY
argument_list|(
name|line
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/*   if (logging) */
comment|/*     { */
comment|/*       LOG ("  "); */
comment|/*       print_spline (log_file, line); */
comment|/*     } */
return|return
name|init_spline_list
argument_list|(
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The least squares method is well described in Schneider's thesis.    Briefly, we try to fit the entire curve with one spline.  If that fails,    we try reparameterizing, i.e., finding new, and supposedly better,    t values.  If that still fails, we subdivide the curve.  */
end_comment

begin_function
specifier|static
name|spline_list_type
modifier|*
DECL|function|fit_with_least_squares (curve_type curve)
name|fit_with_least_squares
parameter_list|(
name|curve_type
name|curve
parameter_list|)
block|{
name|real
name|error
decl_stmt|,
name|best_error
init|=
name|FLT_MAX
decl_stmt|;
name|spline_type
name|spline
decl_stmt|,
name|best_spline
decl_stmt|;
name|spline_list_type
modifier|*
name|spline_list
decl_stmt|;
name|unsigned
name|worst_point
decl_stmt|;
name|unsigned
name|iteration
init|=
literal|0
decl_stmt|;
name|real
name|previous_error
init|=
name|FLT_MAX
decl_stmt|;
name|real
name|improvement
init|=
name|FLT_MAX
decl_stmt|;
comment|/*   LOG ("\nFitting with least squares:\n"); */
comment|/* Phoenix reduces the number of points with a ``linear spline      technique''.  But for fitting letterforms, that is      inappropriate.  We want all the points we can get.  */
comment|/* It makes no difference whether we first set the `t' values or      find the tangents.  This order makes the documentation a little      more coherent.  */
comment|/*   LOG ("Finding tangents:\n"); */
name|find_tangent
argument_list|(
name|curve
argument_list|,
comment|/* to_start */
name|true
argument_list|,
comment|/* cross_curve */
name|false
argument_list|)
expr_stmt|;
name|find_tangent
argument_list|(
name|curve
argument_list|,
comment|/* to_start */
name|false
argument_list|,
comment|/* cross_curve */
name|false
argument_list|)
expr_stmt|;
name|set_initial_parameter_values
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/* Now we loop, reparameterizing and/or subdividing, until CURVE has      been fit.  */
while|while
condition|(
name|true
condition|)
block|{
comment|/*       LOG ("  fitted to spline:\n"); */
name|spline
operator|=
name|fit_one_spline
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/*       if (logging) */
comment|/*         { */
comment|/*           LOG ("    "); */
comment|/*           print_spline (log_file, spline); */
comment|/*         } */
name|error
operator|=
name|find_error
argument_list|(
name|curve
argument_list|,
name|spline
argument_list|,
operator|&
name|worst_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
name|previous_error
condition|)
block|{
comment|/* 	  LOG ("Reparameterization made it worse.\n"); */
comment|/* Just fall through; we will subdivide.  */
block|}
else|else
block|{
name|best_error
operator|=
name|error
expr_stmt|;
name|best_spline
operator|=
name|spline
expr_stmt|;
block|}
name|improvement
operator|=
literal|1.0
operator|-
name|error
operator|/
name|previous_error
expr_stmt|;
comment|/* Don't exit, even if the error is less than `error_threshold',          since we might be able to improve the fit with further          reparameterization.  If the reparameterization made it worse,          we will exit here, since `improvement' will be negative.  */
if|if
condition|(
name|improvement
operator|<
name|reparameterize_improvement
operator|||
name|error
operator|>
name|reparameterize_threshold
condition|)
break|break;
name|iteration
operator|++
expr_stmt|;
comment|/*       LOG3 ("Reparameterization #%u (error was %.3f, a %u%% improvement):\n", */
comment|/*             iteration, error, ((unsigned) (improvement * 100.0))); */
comment|/* The reparameterization might fail, if the initial fit was          better than `reparameterize_threshold', yet worse than the          Newton-Raphson algorithm could handle.  */
if|if
condition|(
operator|!
name|reparameterize
argument_list|(
name|curve
argument_list|,
name|spline
argument_list|)
condition|)
break|break;
name|previous_error
operator|=
name|error
expr_stmt|;
block|}
comment|/* Go back to the best fit.  */
name|spline
operator|=
name|best_spline
expr_stmt|;
name|error
operator|=
name|best_error
expr_stmt|;
if|if
condition|(
name|error
operator|<
name|error_threshold
condition|)
block|{
comment|/* The points were fitted with a (possibly reparameterized)          spline.  We end up here whenever a fit is accepted.  We have          one more job: see if the ``curve'' that was fit should really          be a straight line. */
if|if
condition|(
name|spline_linear_enough
argument_list|(
operator|&
name|spline
argument_list|,
name|curve
argument_list|)
condition|)
block|{
name|SPLINE_DEGREE
argument_list|(
name|spline
argument_list|)
operator|=
name|LINEAR
expr_stmt|;
comment|/*           LOG ("Changed to line.\n"); */
block|}
name|spline_list
operator|=
name|init_spline_list
argument_list|(
name|spline
argument_list|)
expr_stmt|;
comment|/*       LOG1 ("Accepted error of %.3f.\n", error); */
block|}
else|else
block|{
comment|/* We couldn't fit the curve acceptably, so subdivide.  */
name|unsigned
name|subdivision_index
decl_stmt|;
name|spline_list_type
modifier|*
name|left_spline_list
decl_stmt|;
name|spline_list_type
modifier|*
name|right_spline_list
decl_stmt|;
name|curve_type
name|left_curve
init|=
name|new_curve
argument_list|()
decl_stmt|;
name|curve_type
name|right_curve
init|=
name|new_curve
argument_list|()
decl_stmt|;
comment|/* Keep the linked list of curves intact.  */
name|NEXT_CURVE
argument_list|(
name|right_curve
argument_list|)
operator|=
name|NEXT_CURVE
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|PREVIOUS_CURVE
argument_list|(
name|right_curve
argument_list|)
operator|=
name|left_curve
expr_stmt|;
name|NEXT_CURVE
argument_list|(
name|left_curve
argument_list|)
operator|=
name|right_curve
expr_stmt|;
name|PREVIOUS_CURVE
argument_list|(
name|left_curve
argument_list|)
operator|=
name|curve
expr_stmt|;
name|NEXT_CURVE
argument_list|(
name|curve
argument_list|)
operator|=
name|left_curve
expr_stmt|;
comment|/*       REPORT ("s"); */
comment|/*       LOG1 ("\nSubdividing (error %.3f):\n", error); */
comment|/*       LOG3 ("  Original point: (%.3f,%.3f), #%u.\n", */
comment|/*             CURVE_POINT (curve, worst_point).x, */
comment|/*             CURVE_POINT (curve, worst_point).y, worst_point); */
name|subdivision_index
operator|=
name|find_subdivision
argument_list|(
name|curve
argument_list|,
name|worst_point
argument_list|)
expr_stmt|;
comment|/*       LOG3 ("  Final point: (%.3f,%.3f), #%u.\n", */
comment|/*             CURVE_POINT (curve, subdivision_index).x, */
comment|/*             CURVE_POINT (curve, subdivision_index).y, subdivision_index); */
comment|/*       display_subdivision (CURVE_POINT (curve, subdivision_index)); */
comment|/* The last point of the left-hand curve will also be the first          point of the right-hand curve.  */
name|CURVE_LENGTH
argument_list|(
name|left_curve
argument_list|)
operator|=
name|subdivision_index
operator|+
literal|1
expr_stmt|;
name|CURVE_LENGTH
argument_list|(
name|right_curve
argument_list|)
operator|=
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|-
name|subdivision_index
expr_stmt|;
name|left_curve
operator|->
name|point_list
operator|=
name|curve
operator|->
name|point_list
expr_stmt|;
name|right_curve
operator|->
name|point_list
operator|=
name|curve
operator|->
name|point_list
operator|+
name|subdivision_index
expr_stmt|;
comment|/* We want to use the tangents of the curve which we are          subdividing for the start tangent for left_curve and the          end tangent for right_curve.  */
name|CURVE_START_TANGENT
argument_list|(
name|left_curve
argument_list|)
operator|=
name|CURVE_START_TANGENT
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|CURVE_END_TANGENT
argument_list|(
name|right_curve
argument_list|)
operator|=
name|CURVE_END_TANGENT
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/* We have to set up the two curves before finding the tangent at          the subdivision point.  The tangent at that point must be the          same for both curves, or noticeable bumps will occur in the          character.  But we want to use information on both sides of the          point to compute the tangent, hence cross_curve = true.  */
name|find_tangent
argument_list|(
name|left_curve
argument_list|,
comment|/* to_start_point: */
name|false
argument_list|,
comment|/* cross_curve: */
name|true
argument_list|)
expr_stmt|;
name|CURVE_START_TANGENT
argument_list|(
name|right_curve
argument_list|)
operator|=
name|CURVE_END_TANGENT
argument_list|(
name|left_curve
argument_list|)
expr_stmt|;
comment|/* Now that we've set up the curves, we can fit them.  */
name|left_spline_list
operator|=
name|fit_curve
argument_list|(
name|left_curve
argument_list|)
expr_stmt|;
name|right_spline_list
operator|=
name|fit_curve
argument_list|(
name|right_curve
argument_list|)
expr_stmt|;
comment|/* Neither of the subdivided curves could be fit, so fail.  */
if|if
condition|(
name|left_spline_list
operator|==
name|NULL
operator|&&
name|right_spline_list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Put the two together (or whichever of them exist).  */
name|spline_list
operator|=
name|new_spline_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|left_spline_list
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"could not fit left spline list"
argument_list|)
expr_stmt|;
comment|/*           LOG1 ("Could not fit spline to left curve (%x).\n", */
comment|/*                 (unsigned) left_curve); */
block|}
else|else
name|concat_spline_lists
argument_list|(
name|spline_list
argument_list|,
operator|*
name|left_spline_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|right_spline_list
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"could not fit right spline list"
argument_list|)
expr_stmt|;
comment|/*           LOG1 ("Could not fit spline to right curve (%x).\n", */
comment|/*                 (unsigned) right_curve); */
block|}
else|else
name|concat_spline_lists
argument_list|(
name|spline_list
argument_list|,
operator|*
name|right_spline_list
argument_list|)
expr_stmt|;
block|}
return|return
name|spline_list
return|;
block|}
end_function

begin_comment
comment|/* Our job here is to find alpha1 (and alpha2), where t1_hat (t2_hat) is    the tangent to CURVE at the starting (ending) point, such that:     control1 = alpha1*t1_hat + starting point    control2 = alpha2*t2_hat + ending_point     and the resulting spline (starting_point .. control1 and control2 ..    ending_point) minimizes the least-square error from CURVE.        See pp.57--59 of the Phoenix thesis.        The B?(t) here corresponds to B_i^3(U_i) there.    The Bernshte\u in polynomials of degree n are defined by    B_i^n(t) = { n \choose i } t^i (1-t)^{n-i}, i = 0..n  */
end_comment

begin_define
DECL|macro|B0 (t)
define|#
directive|define
name|B0
parameter_list|(
name|t
parameter_list|)
value|CUBE (1 - (t))
end_define

begin_define
DECL|macro|B1 (t)
define|#
directive|define
name|B1
parameter_list|(
name|t
parameter_list|)
value|(3.0 * (t) * SQUARE (1 - (t)))
end_define

begin_define
DECL|macro|B2 (t)
define|#
directive|define
name|B2
parameter_list|(
name|t
parameter_list|)
value|(3.0 * SQUARE (t) * (1 - (t)))
end_define

begin_define
DECL|macro|B3 (t)
define|#
directive|define
name|B3
parameter_list|(
name|t
parameter_list|)
value|CUBE (t)
end_define

begin_define
DECL|macro|U (i)
define|#
directive|define
name|U
parameter_list|(
name|i
parameter_list|)
value|CURVE_T (curve, i)
end_define

begin_function
specifier|static
name|spline_type
DECL|function|fit_one_spline (curve_type curve)
name|fit_one_spline
parameter_list|(
name|curve_type
name|curve
parameter_list|)
block|{
comment|/* Since our arrays are zero-based, the `C0' and `C1' here correspond      to `C1' and `C2' in the paper.  */
name|real
name|X_C1_det
decl_stmt|,
name|C0_X_det
decl_stmt|,
name|C0_C1_det
decl_stmt|;
name|real
name|alpha1
decl_stmt|,
name|alpha2
decl_stmt|;
name|spline_type
name|spline
decl_stmt|;
name|vector_type
name|start_vector
decl_stmt|,
name|end_vector
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|vector_type
name|A
index|[
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* A dynamically allocated array.  */
name|vector_type
name|t1_hat
init|=
operator|*
name|CURVE_START_TANGENT
argument_list|(
name|curve
argument_list|)
decl_stmt|;
name|vector_type
name|t2_hat
init|=
operator|*
name|CURVE_END_TANGENT
argument_list|(
name|curve
argument_list|)
decl_stmt|;
name|real
name|C
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
literal|0.0
block|,
literal|0.0
block|}
block|}
decl_stmt|;
name|real
name|X
index|[
literal|2
index|]
init|=
block|{
literal|0.0
block|,
literal|0.0
block|}
decl_stmt|;
name|START_POINT
argument_list|(
name|spline
argument_list|)
operator|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|END_POINT
argument_list|(
name|spline
argument_list|)
operator|=
name|LAST_CURVE_POINT
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|start_vector
operator|=
name|make_vector
argument_list|(
name|START_POINT
argument_list|(
name|spline
argument_list|)
argument_list|)
expr_stmt|;
name|end_vector
operator|=
name|make_vector
argument_list|(
name|END_POINT
argument_list|(
name|spline
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|A
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|Vmult_scalar
argument_list|(
name|t1_hat
argument_list|,
name|B1
argument_list|(
name|U
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|A
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|Vmult_scalar
argument_list|(
name|t2_hat
argument_list|,
name|B2
argument_list|(
name|U
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|vector_type
name|temp
decl_stmt|,
name|temp0
decl_stmt|,
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|;
name|vector_type
modifier|*
name|Ai
init|=
name|A
index|[
name|i
index|]
decl_stmt|;
name|C
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+=
name|Vdot
argument_list|(
name|Ai
index|[
literal|0
index|]
argument_list|,
name|Ai
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|C
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+=
name|Vdot
argument_list|(
name|Ai
index|[
literal|0
index|]
argument_list|,
name|Ai
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* C[1][0] = C[0][1] (this is assigned outside the loop)  */
name|C
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+=
name|Vdot
argument_list|(
name|Ai
index|[
literal|1
index|]
argument_list|,
name|Ai
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Now the right-hand side of the equation in the paper.  */
name|temp0
operator|=
name|Vmult_scalar
argument_list|(
name|start_vector
argument_list|,
name|B0
argument_list|(
name|U
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|Vmult_scalar
argument_list|(
name|start_vector
argument_list|,
name|B1
argument_list|(
name|U
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|Vmult_scalar
argument_list|(
name|end_vector
argument_list|,
name|B2
argument_list|(
name|U
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp3
operator|=
name|Vmult_scalar
argument_list|(
name|end_vector
argument_list|,
name|B3
argument_list|(
name|U
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|make_vector
argument_list|(
name|Vsubtract_point
argument_list|(
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
argument_list|,
name|Vadd
argument_list|(
name|temp0
argument_list|,
name|Vadd
argument_list|(
name|temp1
argument_list|,
name|Vadd
argument_list|(
name|temp2
argument_list|,
name|temp3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|X
index|[
literal|0
index|]
operator|+=
name|Vdot
argument_list|(
name|temp
argument_list|,
name|Ai
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|X
index|[
literal|1
index|]
operator|+=
name|Vdot
argument_list|(
name|temp
argument_list|,
name|Ai
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|C
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|C
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|X_C1_det
operator|=
name|X
index|[
literal|0
index|]
operator|*
name|C
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|X
index|[
literal|1
index|]
operator|*
name|C
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|C0_X_det
operator|=
name|C
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|X
index|[
literal|1
index|]
operator|-
name|C
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|X
index|[
literal|0
index|]
expr_stmt|;
name|C0_C1_det
operator|=
name|C
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|C
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|C
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|C
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|C0_C1_det
operator|==
literal|0.0
condition|)
name|FATAL
argument_list|(
literal|"zero determinant of C0*C1"
argument_list|)
expr_stmt|;
name|alpha1
operator|=
name|X_C1_det
operator|/
name|C0_C1_det
expr_stmt|;
name|alpha2
operator|=
name|C0_X_det
operator|/
name|C0_C1_det
expr_stmt|;
name|CONTROL1
argument_list|(
name|spline
argument_list|)
operator|=
name|Vadd_point
argument_list|(
name|START_POINT
argument_list|(
name|spline
argument_list|)
argument_list|,
name|Vmult_scalar
argument_list|(
name|t1_hat
argument_list|,
name|alpha1
argument_list|)
argument_list|)
expr_stmt|;
name|CONTROL2
argument_list|(
name|spline
argument_list|)
operator|=
name|Vadd_point
argument_list|(
name|END_POINT
argument_list|(
name|spline
argument_list|)
argument_list|,
name|Vmult_scalar
argument_list|(
name|t2_hat
argument_list|,
name|alpha2
argument_list|)
argument_list|)
expr_stmt|;
name|SPLINE_DEGREE
argument_list|(
name|spline
argument_list|)
operator|=
name|CUBIC
expr_stmt|;
return|return
name|spline
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find closer-to-optimal t values for the given x,y's and control    points, using Newton-Raphson iteration.  A good description of this    is in Plass& Stone.  This routine performs one step in the    iteration, not the whole thing.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|reparameterize (curve_type curve,spline_type S)
name|reparameterize
parameter_list|(
name|curve_type
name|curve
parameter_list|,
name|spline_type
name|S
parameter_list|)
block|{
name|unsigned
name|p
decl_stmt|,
name|i
decl_stmt|;
name|spline_type
name|S1
decl_stmt|,
name|S2
decl_stmt|;
comment|/* S' and S''.  */
comment|/*   REPORT ("r"); */
comment|/* Find the first and second derivatives of S.  To make      `evaluate_spline' work, we fill the beginning points (i.e., the first      two for a linear spline and the first three for a quadratic one),      even though this is at odds with the rest of the program.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|S1
operator|.
name|v
index|[
name|i
index|]
operator|.
name|x
operator|=
literal|3.0
operator|*
operator|(
name|S
operator|.
name|v
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
operator|-
name|S
operator|.
name|v
index|[
name|i
index|]
operator|.
name|x
operator|)
expr_stmt|;
name|S1
operator|.
name|v
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|3.0
operator|*
operator|(
name|S
operator|.
name|v
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
operator|-
name|S
operator|.
name|v
index|[
name|i
index|]
operator|.
name|y
operator|)
expr_stmt|;
block|}
name|S1
operator|.
name|v
index|[
name|i
index|]
operator|.
name|x
operator|=
name|S1
operator|.
name|v
index|[
name|i
index|]
operator|.
name|y
operator|=
operator|-
literal|1.0
expr_stmt|;
comment|/* These will never be accessed.  */
name|SPLINE_DEGREE
argument_list|(
name|S1
argument_list|)
operator|=
name|QUADRATIC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|S2
operator|.
name|v
index|[
name|i
index|]
operator|.
name|x
operator|=
literal|2.0
operator|*
operator|(
name|S1
operator|.
name|v
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
operator|-
name|S1
operator|.
name|v
index|[
name|i
index|]
operator|.
name|x
operator|)
expr_stmt|;
name|S2
operator|.
name|v
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|2.0
operator|*
operator|(
name|S1
operator|.
name|v
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
operator|-
name|S1
operator|.
name|v
index|[
name|i
index|]
operator|.
name|y
operator|)
expr_stmt|;
block|}
name|S2
operator|.
name|v
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|S2
operator|.
name|v
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|S2
operator|.
name|v
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|S2
operator|.
name|v
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|-
literal|1.0
expr_stmt|;
name|SPLINE_DEGREE
argument_list|(
name|S2
argument_list|)
operator|=
name|LINEAR
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
name|real
name|new_distance
decl_stmt|,
name|old_distance
decl_stmt|;
name|real_coordinate_type
name|new_point
decl_stmt|;
name|real_coordinate_type
name|point
init|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|real
name|t
init|=
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
decl_stmt|;
comment|/* Find the points at this t on S, S', and S''.  */
name|real_coordinate_type
name|S_t
init|=
name|evaluate_spline
argument_list|(
name|S
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|real_coordinate_type
name|S1_t
init|=
name|evaluate_spline
argument_list|(
name|S1
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|real_coordinate_type
name|S2_t
init|=
name|evaluate_spline
argument_list|(
name|S2
argument_list|,
name|t
argument_list|)
decl_stmt|;
comment|/* The differences in x and y (Q1(t) on p.62 of Schneider's thesis).  */
name|real_coordinate_type
name|d
init|=
block|{
name|S_t
operator|.
name|x
operator|-
name|point
operator|.
name|x
block|,
name|S_t
operator|.
name|y
operator|-
name|point
operator|.
name|y
block|}
decl_stmt|;
comment|/* The step size, f(t)/f'(t).  */
name|real
name|numerator
init|=
name|d
operator|.
name|x
operator|*
name|S1_t
operator|.
name|x
operator|+
name|d
operator|.
name|y
operator|*
name|S1_t
operator|.
name|y
decl_stmt|;
name|real
name|denominator
init|=
operator|(
name|SQUARE
argument_list|(
name|S1_t
operator|.
name|x
argument_list|)
operator|+
name|d
operator|.
name|x
operator|*
name|S2_t
operator|.
name|x
operator|+
name|SQUARE
argument_list|(
name|S1_t
operator|.
name|y
argument_list|)
operator|+
name|d
operator|.
name|y
operator|*
name|S2_t
operator|.
name|y
operator|)
decl_stmt|;
comment|/* We compute the distances only to be able to check that we          really are moving closer.  I don't know how this condition can          be reliably checked for in advance, but I know what it means in          practice: the original fit was not good enough for the          Newton-Raphson iteration to converge.  Therefore, we need to          abort the reparameterization, and subdivide.  */
name|old_distance
operator|=
name|distance
argument_list|(
name|S_t
argument_list|,
name|point
argument_list|)
expr_stmt|;
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
operator|-=
name|numerator
operator|/
name|denominator
expr_stmt|;
name|new_point
operator|=
name|evaluate_spline
argument_list|(
name|S
argument_list|,
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|new_distance
operator|=
name|distance
argument_list|(
name|new_point
argument_list|,
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_distance
operator|>
name|old_distance
condition|)
block|{
comment|/* 	  REPORT ("!"); */
comment|/* 	  LOG3 ("  Stopped reparameterizing; %.3f> %.3f at point %u.\n", */
comment|/* 		new_distance, old_distance, p); */
return|return
name|false
return|;
block|}
comment|/* The t value might be negative or> 1, if the choice of control          points wasn't so great.  We have no difficulty in evaluating          a spline at a t outside the range zero to one, though, so it          doesn't matter.  (Although it is a little unconventional.)  */
block|}
comment|/*   LOG ("  reparameterized curve:\n   "); */
comment|/*   log_curve (curve, true); */
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine finds the best place to subdivide the curve CURVE,    somewhere near to the point whose index is INITIAL.  Originally,    curves were always subdivided at the point of worst error, which is    intuitively appealing, but doesn't always give the best results.  For    example, at the end of a serif that tapers into the stem, the best    subdivision point is at the point where they join, even if the worst    point is a little ways into the serif.        We return the index of the point at which to subdivide.  */
end_comment

begin_function
specifier|static
name|unsigned
DECL|function|find_subdivision (curve_type curve,unsigned initial)
name|find_subdivision
parameter_list|(
name|curve_type
name|curve
parameter_list|,
name|unsigned
name|initial
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n_done
decl_stmt|;
name|int
name|best_point
init|=
operator|-
literal|1
decl_stmt|;
name|vector_type
name|best
init|=
block|{
name|FLT_MAX
block|,
name|FLT_MAX
block|}
decl_stmt|;
name|unsigned
name|search
init|=
name|subdivide_search
operator|*
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
decl_stmt|;
comment|/*   LOG1 ("  Number of points to search: %u.\n", search); */
comment|/* We don't want to find the first (or last) point in the curve.  */
for|for
control|(
name|i
operator|=
name|initial
operator|,
name|n_done
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
name|n_done
operator|<
name|search
condition|;
name|i
operator|=
name|CURVE_PREV
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
block|{
if|if
condition|(
name|test_subdivision_point
argument_list|(
name|curve
argument_list|,
name|i
argument_list|,
operator|&
name|best
argument_list|)
condition|)
block|{
name|best_point
operator|=
name|i
expr_stmt|;
comment|/*           LOG3 ("    Better point: (%.3f,%.3f), #%u.\n", */
comment|/*                CURVE_POINT (curve, i).x, CURVE_POINT (curve, i).y, i); */
block|}
block|}
comment|/* If we found a good one, let's take it.  */
if|if
condition|(
name|best_point
operator|!=
operator|-
literal|1
condition|)
return|return
name|best_point
return|;
for|for
control|(
name|i
operator|=
name|CURVE_NEXT
argument_list|(
name|curve
argument_list|,
name|initial
argument_list|)
operator|,
name|n_done
operator|=
literal|0
init|;
name|i
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|-
literal|1
operator|&&
name|n_done
operator|<
name|search
condition|;
name|i
operator|=
name|CURVE_NEXT
argument_list|(
name|curve
argument_list|,
name|i
argument_list|)
operator|,
name|n_done
operator|++
control|)
block|{
if|if
condition|(
name|test_subdivision_point
argument_list|(
name|curve
argument_list|,
name|i
argument_list|,
operator|&
name|best
argument_list|)
condition|)
block|{
name|best_point
operator|=
name|i
expr_stmt|;
comment|/*           LOG3 ("    Better point at (%.3f,%.3f), #%u.\n", */
comment|/*                CURVE_POINT (curve, i).x, CURVE_POINT (curve, i).y, i); */
block|}
block|}
comment|/* If we didn't find any better point, return the original.  */
return|return
name|best_point
operator|==
operator|-
literal|1
condition|?
name|initial
else|:
name|best_point
return|;
block|}
end_function

begin_comment
comment|/* Here are some macros that decide whether or not we're at a    ``join point'', as described above.  */
end_comment

begin_define
DECL|macro|ONLY_ONE_LESS (v)
define|#
directive|define
name|ONLY_ONE_LESS
parameter_list|(
name|v
parameter_list|)
define|\
value|(((v).dx< subdivide_threshold&& (v).dy> subdivide_threshold)	\    || ((v).dy< subdivide_threshold&& (v).dx> subdivide_threshold))
end_define

begin_define
DECL|macro|BOTH_GREATER (v)
define|#
directive|define
name|BOTH_GREATER
parameter_list|(
name|v
parameter_list|)
define|\
value|((v).dx> subdivide_threshold&& (v).dy> subdivide_threshold)
end_define

begin_comment
comment|/* We assume that the vectors V1 and V2 are nonnegative.  */
end_comment

begin_define
DECL|macro|JOIN (v1,v2)
define|#
directive|define
name|JOIN
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
define|\
value|((ONLY_ONE_LESS (v1)&& BOTH_GREATER (v2))				\      || (ONLY_ONE_LESS (v2)&& BOTH_GREATER (v1)))
end_define

begin_comment
comment|/* If the component D of the vector V is smaller than the best so far,    update the best point.  */
end_comment

begin_define
DECL|macro|UPDATE_BEST (v,d)
define|#
directive|define
name|UPDATE_BEST
parameter_list|(
name|v
parameter_list|,
name|d
parameter_list|)
define|\
value|do									\     {									\       if ((v).d< subdivide_threshold&& (v).d< best->d)		\         best->d = (v).d;						\     }									\   while (0)
end_define

begin_comment
comment|/* If the point INDEX in the curve CURVE is the best subdivision point    we've found so far, update the vector BEST.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|test_subdivision_point (curve_type curve,unsigned index,vector_type * best)
name|test_subdivision_point
parameter_list|(
name|curve_type
name|curve
parameter_list|,
name|unsigned
name|index
parameter_list|,
name|vector_type
modifier|*
name|best
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
name|vector_type
name|in
decl_stmt|,
name|out
decl_stmt|;
name|boolean
name|join
init|=
name|false
decl_stmt|;
name|find_curve_vectors
argument_list|(
name|index
argument_list|,
name|curve
argument_list|,
name|subdivide_surround
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* We don't want to subdivide at points which are very close to the      endpoints, so if the vectors aren't computed from as many points as      we asked for, don't bother checking this point.  */
if|if
condition|(
name|count
operator|==
name|subdivide_surround
condition|)
block|{
name|in
operator|=
name|Vabs
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|out
operator|=
name|Vabs
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|join
operator|=
name|JOIN
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|join
condition|)
block|{
name|UPDATE_BEST
argument_list|(
name|in
argument_list|,
name|dx
argument_list|)
expr_stmt|;
name|UPDATE_BEST
argument_list|(
name|in
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|UPDATE_BEST
argument_list|(
name|out
argument_list|,
name|dx
argument_list|)
expr_stmt|;
name|UPDATE_BEST
argument_list|(
name|out
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|join
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find reasonable values for t for each point on CURVE.  The method is    called chord-length parameterization, which is described in Plass&    Stone.  The basic idea is just to use the distance from one point to    the next as the t value, normalized to produce values that increase    from zero for the first point to one for the last point.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|set_initial_parameter_values (curve_type curve)
name|set_initial_parameter_values
parameter_list|(
name|curve_type
name|curve
parameter_list|)
block|{
name|unsigned
name|p
decl_stmt|;
comment|/*   LOG ("\nAssigning initial t values:\n  "); */
name|CURVE_T
argument_list|(
name|curve
argument_list|,
literal|0
argument_list|)
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
name|real_coordinate_type
name|point
init|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
decl_stmt|,
name|previous_p
init|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|p
operator|-
literal|1
argument_list|)
decl_stmt|;
name|real
name|d
init|=
name|distance
argument_list|(
name|point
argument_list|,
name|previous_p
argument_list|)
decl_stmt|;
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
operator|=
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
operator|-
literal|1
argument_list|)
operator|+
name|d
expr_stmt|;
block|}
name|assert
argument_list|(
name|LAST_CURVE_T
argument_list|(
name|curve
argument_list|)
operator|!=
literal|0.0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|p
operator|++
control|)
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
operator|=
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|p
argument_list|)
operator|/
name|LAST_CURVE_T
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/*   log_entire_curve (curve); */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find an approximation to the tangent to an endpoint of CURVE (to the    first point if TO_START_POINT is true, else the last).  If    CROSS_CURVE is true, consider points on the adjacent curve to CURVE.     It is important to compute an accurate approximation, because the    control points that we eventually decide upon to fit the curve will    be placed on the half-lines defined by the tangents and    endpoints...and we never recompute the tangent after this.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_tangent (curve_type curve,boolean to_start_point,boolean cross_curve)
name|find_tangent
parameter_list|(
name|curve_type
name|curve
parameter_list|,
name|boolean
name|to_start_point
parameter_list|,
name|boolean
name|cross_curve
parameter_list|)
block|{
name|vector_type
name|tangent
decl_stmt|;
name|vector_type
modifier|*
modifier|*
name|curve_tangent
init|=
name|to_start_point
condition|?
operator|&
operator|(
name|CURVE_START_TANGENT
argument_list|(
name|curve
argument_list|)
operator|)
else|:
operator|&
operator|(
name|CURVE_END_TANGENT
argument_list|(
name|curve
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|n_points
init|=
literal|0
decl_stmt|;
comment|/*   LOG1 ("  tangent to %s: ", to_start_point ? "start" : "end"); */
if|if
condition|(
operator|*
name|curve_tangent
operator|==
name|NULL
condition|)
block|{
operator|*
name|curve_tangent
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vector_type
argument_list|)
argument_list|)
expr_stmt|;
name|tangent
operator|=
name|find_half_tangent
argument_list|(
name|curve
argument_list|,
name|to_start_point
argument_list|,
operator|&
name|n_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|cross_curve
condition|)
block|{
name|curve_type
name|adjacent_curve
init|=
name|to_start_point
condition|?
name|PREVIOUS_CURVE
argument_list|(
name|curve
argument_list|)
else|:
name|NEXT_CURVE
argument_list|(
name|curve
argument_list|)
decl_stmt|;
name|vector_type
name|tangent2
init|=
name|find_half_tangent
argument_list|(
name|adjacent_curve
argument_list|,
operator|!
name|to_start_point
argument_list|,
operator|&
name|n_points
argument_list|)
decl_stmt|;
comment|/*           LOG2 ("(adjacent curve half tangent (%.3f,%.3f)) ", */
comment|/*                 tangent2.dx, tangent2.dy); */
name|tangent
operator|=
name|Vadd
argument_list|(
name|tangent
argument_list|,
name|tangent2
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|n_points
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|*
name|curve_tangent
operator|=
name|Vmult_scalar
argument_list|(
name|tangent
argument_list|,
literal|1.0
operator|/
name|n_points
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*       LOG ("(already computed) "); */
block|}
comment|/*   LOG2 ("(%.3f,%.3f).\n", (*curve_tangent)->dx, (*curve_tangent)->dy); */
block|}
end_function

begin_comment
comment|/* Find the change in y and change in x for `tangent_surround' (a global)    points along CURVE.  Increment N_POINTS by the number of points we    actually look at.  */
end_comment

begin_function
specifier|static
name|vector_type
DECL|function|find_half_tangent (curve_type c,boolean to_start_point,unsigned * n_points)
name|find_half_tangent
parameter_list|(
name|curve_type
name|c
parameter_list|,
name|boolean
name|to_start_point
parameter_list|,
name|unsigned
modifier|*
name|n_points
parameter_list|)
block|{
name|unsigned
name|p
decl_stmt|;
name|int
name|factor
init|=
name|to_start_point
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|unsigned
name|tangent_index
init|=
name|to_start_point
condition|?
literal|0
else|:
name|c
operator|->
name|length
operator|-
literal|1
decl_stmt|;
name|real_coordinate_type
name|tangent_point
init|=
name|CURVE_POINT
argument_list|(
name|c
argument_list|,
name|tangent_index
argument_list|)
decl_stmt|;
name|vector_type
name|tangent
init|=
block|{
literal|0.0
block|,
literal|0.0
block|}
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|tangent_surround
condition|;
name|p
operator|++
control|)
block|{
name|int
name|this_index
init|=
name|p
operator|*
name|factor
operator|+
name|tangent_index
decl_stmt|;
name|real_coordinate_type
name|this_point
decl_stmt|;
if|if
condition|(
name|this_index
operator|<
literal|0
operator|||
name|this_index
operator|>=
name|c
operator|->
name|length
condition|)
break|break;
name|this_point
operator|=
name|CURVE_POINT
argument_list|(
name|c
argument_list|,
name|p
operator|*
name|factor
operator|+
name|tangent_index
argument_list|)
expr_stmt|;
comment|/* Perhaps we should weight the tangent from `this_point' by some          factor dependent on the distance from the tangent point.  */
name|tangent
operator|=
name|Vadd
argument_list|(
name|tangent
argument_list|,
name|Vmult_scalar
argument_list|(
name|Psubtract
argument_list|(
name|this_point
argument_list|,
name|tangent_point
argument_list|)
argument_list|,
name|factor
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|n_points
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|tangent
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When this routine is called, we have computed a spline representation    for the digitized curve.  The question is, how good is it?  If the    fit is very good indeed, we might have an error of zero on each    point, and then WORST_POINT becomes irrelevant.  But normally, we    return the error at the worst point, and the index of that point in    WORST_POINT.  The error computation itself is the Euclidean distance    from the original curve CURVE to the fitted spline SPLINE.  */
end_comment

begin_function
specifier|static
name|real
DECL|function|find_error (curve_type curve,spline_type spline,unsigned * worst_point)
name|find_error
parameter_list|(
name|curve_type
name|curve
parameter_list|,
name|spline_type
name|spline
parameter_list|,
name|unsigned
modifier|*
name|worst_point
parameter_list|)
block|{
name|unsigned
name|this_point
decl_stmt|;
name|real
name|total_error
init|=
literal|0.0
decl_stmt|;
name|real
name|worst_error
init|=
name|FLT_MIN
decl_stmt|;
operator|*
name|worst_point
operator|=
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* A sentinel value.  */
for|for
control|(
name|this_point
operator|=
literal|0
init|;
name|this_point
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|this_point
operator|++
control|)
block|{
name|real_coordinate_type
name|curve_point
init|=
name|CURVE_POINT
argument_list|(
name|curve
argument_list|,
name|this_point
argument_list|)
decl_stmt|;
name|real
name|t
init|=
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|this_point
argument_list|)
decl_stmt|;
name|real_coordinate_type
name|spline_point
init|=
name|evaluate_spline
argument_list|(
name|spline
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|real
name|this_error
init|=
name|distance
argument_list|(
name|curve_point
argument_list|,
name|spline_point
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_error
operator|>
name|worst_error
condition|)
block|{
operator|*
name|worst_point
operator|=
name|this_point
expr_stmt|;
name|worst_error
operator|=
name|this_error
expr_stmt|;
block|}
name|total_error
operator|+=
name|this_error
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|worst_point
operator|==
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* Didn't have any ``worst point''; the error should be zero.  */
if|if
condition|(
name|epsilon_equal
argument_list|(
name|total_error
argument_list|,
literal|0.0
argument_list|)
condition|)
block|{
comment|/* 	  LOG ("  Every point fit perfectly.\n"); */
block|}
else|else
name|printf
argument_list|(
literal|"No worst point found; something is wrong"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*       LOG4 ("  Worst error (at (%.3f,%.3f), point #%u) was %.3f.\n", */
comment|/*             CURVE_POINT (curve, *worst_point).x, */
comment|/*             CURVE_POINT (curve, *worst_point).y, *worst_point, worst_error); */
comment|/*       LOG1 ("  Total error was %.3f.\n", total_error); */
comment|/*       LOG2 ("  Average error (over %u points) was %.3f.\n", */
comment|/*             CURVE_LENGTH (curve), total_error / CURVE_LENGTH (curve)); */
block|}
return|return
name|worst_error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Supposing that we have accepted the error, another question arises:    would we be better off just using a straight line?  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|spline_linear_enough (spline_type * spline,curve_type curve)
name|spline_linear_enough
parameter_list|(
name|spline_type
modifier|*
name|spline
parameter_list|,
name|curve_type
name|curve
parameter_list|)
block|{
name|real
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|slope
decl_stmt|;
name|unsigned
name|this_point
decl_stmt|;
name|real
name|distance
init|=
literal|0.0
decl_stmt|;
comment|/*   LOG ("Checking linearity:\n"); */
comment|/* For a line described by Ax + By + C = 0, the distance d from a      point (x0,y0) to that line is:       d = | Ax0 + By0 + C | / sqrt (A^2 + B^2).       We can find A, B, and C from the starting and ending points,      unless the line defined by those two points is vertical.  */
if|if
condition|(
name|epsilon_equal
argument_list|(
name|START_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|x
argument_list|,
name|END_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|x
argument_list|)
condition|)
block|{
name|A
operator|=
literal|1
expr_stmt|;
name|B
operator|=
literal|0
expr_stmt|;
name|C
operator|=
operator|-
name|START_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|x
expr_stmt|;
block|}
else|else
block|{
comment|/* Plug the spline's starting and ending points into the two-point 	 equation for a line, that is,  	 (y - y1) = ((y2 - y1)/(x2 - x1)) * (x - x1)  	 to get the values for A, B, and C.  */
name|slope
operator|=
operator|(
operator|(
name|END_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|y
operator|-
name|START_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|y
operator|)
operator|/
operator|(
name|END_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|x
operator|-
name|START_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|x
operator|)
operator|)
expr_stmt|;
name|A
operator|=
operator|-
name|slope
expr_stmt|;
name|B
operator|=
literal|1
expr_stmt|;
name|C
operator|=
name|slope
operator|*
name|START_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|x
operator|-
name|START_POINT
argument_list|(
operator|*
name|spline
argument_list|)
operator|.
name|y
expr_stmt|;
block|}
comment|/*   LOG3 ("  Line is %.3fx + %.3fy + %.3f = 0.\n", A, B, C); */
for|for
control|(
name|this_point
operator|=
literal|0
init|;
name|this_point
operator|<
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
condition|;
name|this_point
operator|++
control|)
block|{
name|real
name|t
init|=
name|CURVE_T
argument_list|(
name|curve
argument_list|,
name|this_point
argument_list|)
decl_stmt|;
name|real_coordinate_type
name|spline_point
init|=
name|evaluate_spline
argument_list|(
operator|*
name|spline
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|distance
operator|+=
name|fabs
argument_list|(
name|A
operator|*
name|spline_point
operator|.
name|x
operator|+
name|B
operator|*
name|spline_point
operator|.
name|y
operator|+
name|C
argument_list|)
operator|/
name|sqrt
argument_list|(
name|A
operator|*
name|A
operator|+
name|B
operator|*
name|B
argument_list|)
expr_stmt|;
block|}
comment|/*   LOG1 ("  Total distance is %.3f, ", distance); */
name|distance
operator|/=
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/*   LOG1 ("which is %.3f normalized.\n", distance); */
comment|/* We want reversion of short curves to splines to be more likely than      reversion of long curves, hence the second division by the curve      length, for use in `change_bad_lines'.  */
name|SPLINE_LINEARITY
argument_list|(
operator|*
name|spline
argument_list|)
operator|=
name|distance
operator|/
name|CURVE_LENGTH
argument_list|(
name|curve
argument_list|)
expr_stmt|;
comment|/*   LOG1 ("  Final linearity: %.3f.\n", SPLINE_LINEARITY (*spline)); */
return|return
name|distance
operator|<
name|line_threshold
return|;
block|}
end_function

begin_comment
comment|/* Unfortunately, we cannot tell in isolation whether a given spline    should be changed to a line or not.  That can only be known after the    entire curve has been fit to a list of splines.  (The curve is the    pixel outline between two corners.)  After subdividing the curve, a    line may very well fit a portion of the curve just as well as the    spline---but unless a spline is truly close to being a line, it    should not be combined with other lines.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|change_bad_lines (spline_list_type * spline_list)
name|change_bad_lines
parameter_list|(
name|spline_list_type
modifier|*
name|spline_list
parameter_list|)
block|{
name|unsigned
name|this_spline
decl_stmt|;
name|boolean
name|found_cubic
init|=
name|false
decl_stmt|;
name|unsigned
name|length
init|=
name|SPLINE_LIST_LENGTH
argument_list|(
operator|*
name|spline_list
argument_list|)
decl_stmt|;
comment|/*   LOG1 ("\nChecking for bad lines (length %u):\n", length); */
comment|/* First see if there are any splines in the fitted shape.  */
for|for
control|(
name|this_spline
operator|=
literal|0
init|;
name|this_spline
operator|<
name|length
condition|;
name|this_spline
operator|++
control|)
block|{
if|if
condition|(
name|SPLINE_DEGREE
argument_list|(
name|SPLINE_LIST_ELT
argument_list|(
operator|*
name|spline_list
argument_list|,
name|this_spline
argument_list|)
argument_list|)
operator|==
name|CUBIC
condition|)
block|{
name|found_cubic
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* If so, change lines back to splines (we haven't done anything to      their control points, so we only have to change the degree) unless      the spline is close enough to being a line.  */
if|if
condition|(
name|found_cubic
condition|)
for|for
control|(
name|this_spline
operator|=
literal|0
init|;
name|this_spline
operator|<
name|length
condition|;
name|this_spline
operator|++
control|)
block|{
name|spline_type
name|s
init|=
name|SPLINE_LIST_ELT
argument_list|(
operator|*
name|spline_list
argument_list|,
name|this_spline
argument_list|)
decl_stmt|;
if|if
condition|(
name|SPLINE_DEGREE
argument_list|(
name|s
argument_list|)
operator|==
name|LINEAR
condition|)
block|{
comment|/*             LOG1 ("  #%u: ", this_spline); */
if|if
condition|(
name|SPLINE_LINEARITY
argument_list|(
name|s
argument_list|)
operator|>
name|line_reversion_threshold
condition|)
block|{
comment|/*                 LOG ("reverted, "); */
name|SPLINE_DEGREE
argument_list|(
name|SPLINE_LIST_ELT
argument_list|(
operator|*
name|spline_list
argument_list|,
name|this_spline
argument_list|)
argument_list|)
operator|=
name|CUBIC
expr_stmt|;
block|}
comment|/*             LOG1 ("linearity %.3f.\n", SPLINE_LINEARITY (s)); */
block|}
block|}
else|else
block|{
comment|/* 	LOG ("  No lines.\n"); */
block|}
block|}
end_function

begin_comment
comment|/* When we have finished fitting an entire pixel outline to a spline    list L, we go through L to ensure that any endpoints that are ``close    enough'' (i.e., within `align_threshold') to being the same really    are the same.  */
end_comment

begin_comment
comment|/* This macro adjusts the AXIS axis on the starting and ending points on    a particular spline if necessary.  */
end_comment

begin_define
DECL|macro|TRY_AXIS (axis)
define|#
directive|define
name|TRY_AXIS
parameter_list|(
name|axis
parameter_list|)
define|\
value|do									\     {									\       real delta = fabs (end.axis - start.axis);			\ 									\       if (!epsilon_equal (delta, 0.0)&& delta<= align_threshold)	\         {								\           spline_type *next =&NEXT_SPLINE_LIST_ELT (*l, this_spline);	\           spline_type *prev =&PREV_SPLINE_LIST_ELT (*l, this_spline);	\ 									\           START_POINT (*s).axis = END_POINT (*s).axis			\             = END_POINT (*prev).axis = START_POINT (*next).axis		\             = (start.axis + end.axis) / 2;				\           spline_change = true;						\         }								\     }									\   while (0)
end_define

begin_function
specifier|static
name|void
DECL|function|align (spline_list_type * l)
name|align
parameter_list|(
name|spline_list_type
modifier|*
name|l
parameter_list|)
block|{
name|boolean
name|change
decl_stmt|;
name|unsigned
name|this_spline
decl_stmt|;
name|unsigned
name|length
init|=
name|SPLINE_LIST_LENGTH
argument_list|(
operator|*
name|l
argument_list|)
decl_stmt|;
comment|/*   LOG1 ("\nAligning spline list (length %u):\n", length); */
do|do
block|{
name|change
operator|=
name|false
expr_stmt|;
comment|/*       LOG ("  "); */
for|for
control|(
name|this_spline
operator|=
literal|0
init|;
name|this_spline
operator|<
name|length
condition|;
name|this_spline
operator|++
control|)
block|{
name|boolean
name|spline_change
init|=
name|false
decl_stmt|;
name|spline_type
modifier|*
name|s
init|=
operator|&
name|SPLINE_LIST_ELT
argument_list|(
operator|*
name|l
argument_list|,
name|this_spline
argument_list|)
decl_stmt|;
name|real_coordinate_type
name|start
init|=
name|START_POINT
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
name|real_coordinate_type
name|end
init|=
name|END_POINT
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
name|TRY_AXIS
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TRY_AXIS
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|spline_change
condition|)
block|{
comment|/*               LOG1 ("%u ", this_spline); */
name|change
operator||=
name|spline_change
expr_stmt|;
block|}
block|}
comment|/*       LOG ("\n"); */
block|}
do|while
condition|(
name|change
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lists of array indices (well, that is what we use it for).  */
end_comment

begin_function
specifier|static
name|index_list_type
DECL|function|new_index_list ()
name|new_index_list
parameter_list|()
block|{
name|index_list_type
name|index_list
decl_stmt|;
name|index_list
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|INDEX_LIST_LENGTH
argument_list|(
name|index_list
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|index_list
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|free_index_list (index_list_type * index_list)
name|free_index_list
parameter_list|(
name|index_list_type
modifier|*
name|index_list
parameter_list|)
block|{
if|if
condition|(
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|index_list
argument_list|)
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|index_list
operator|->
name|data
argument_list|)
expr_stmt|;
name|index_list
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|index_list
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|append_index (index_list_type * list,unsigned new_index)
name|append_index
parameter_list|(
name|index_list_type
modifier|*
name|list
parameter_list|,
name|unsigned
name|new_index
parameter_list|)
block|{
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|list
argument_list|)
operator|++
expr_stmt|;
name|list
operator|->
name|data
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|realloc
argument_list|(
name|list
operator|->
name|data
argument_list|,
operator|(
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|list
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   XRETALLOC (list->data, INDEX_LIST_LENGTH (*list), unsigned); */
name|list
operator|->
name|data
index|[
name|INDEX_LIST_LENGTH
argument_list|(
operator|*
name|list
argument_list|)
operator|-
literal|1
index|]
operator|=
name|new_index
expr_stmt|;
block|}
end_function

end_unit

