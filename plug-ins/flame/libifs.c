begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    flame - cosmic recursive fractal flames    Copyright (C) 1992  Scott Draves<spot@cs.cmu.edu>     This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 3 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strcmp */
end_comment

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libifs.h"
end_include

begin_define
DECL|macro|CHOOSE_XFORM_GRAIN
define|#
directive|define
name|CHOOSE_XFORM_GRAIN
value|100
end_define

begin_function_decl
specifier|static
name|int
name|flam3_random_bit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|flam3_random01
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * run the function system described by CP forward N generations.  * store the n resulting 3 vectors in POINTS.  the initial point is passed  * in POINTS[0].  ignore the first FUSE iterations.  */
end_comment

begin_function
name|void
DECL|function|iterate (control_point * cp,int n,int fuse,point * points)
name|iterate
parameter_list|(
name|control_point
modifier|*
name|cp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|fuse
parameter_list|,
name|point
modifier|*
name|points
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count_large
init|=
literal|0
decl_stmt|,
name|count_nan
init|=
literal|0
decl_stmt|;
name|int
name|xform_distrib
index|[
name|CHOOSE_XFORM_GRAIN
index|]
decl_stmt|;
name|double
name|p
index|[
literal|3
index|]
decl_stmt|,
name|t
decl_stmt|,
name|r
decl_stmt|,
name|dr
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|points
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|points
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|points
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
comment|/*    * first, set up xform, which is an array that converts a uniform random    * variable into one with the distribution dictated by the density    * fields    */
name|dr
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
name|dr
operator|+=
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
expr_stmt|;
name|dr
operator|=
name|dr
operator|/
name|CHOOSE_XFORM_GRAIN
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|cp
operator|->
name|xform
index|[
literal|0
index|]
operator|.
name|density
expr_stmt|;
name|r
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHOOSE_XFORM_GRAIN
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|r
operator|>=
name|t
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|t
operator|+=
name|cp
operator|->
name|xform
index|[
name|j
index|]
operator|.
name|density
expr_stmt|;
block|}
name|xform_distrib
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|r
operator|+=
name|dr
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|-
name|fuse
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* FIXME: the following is supported only by gcc and c99 */
name|int
name|fn
init|=
name|xform_distrib
index|[
name|g_random_int_range
argument_list|(
literal|0
argument_list|,
name|CHOOSE_XFORM_GRAIN
argument_list|)
index|]
decl_stmt|;
name|double
name|tx
decl_stmt|,
name|ty
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>
literal|100.0
operator|||
name|p
index|[
literal|0
index|]
operator|<
operator|-
literal|100.0
operator|||
name|p
index|[
literal|1
index|]
operator|>
literal|100.0
operator|||
name|p
index|[
literal|1
index|]
operator|<
operator|-
literal|100.0
condition|)
name|count_large
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|p
index|[
literal|0
index|]
condition|)
name|count_nan
operator|++
expr_stmt|;
DECL|macro|coef
define|#
directive|define
name|coef
value|cp->xform[fn].c
DECL|macro|vari
define|#
directive|define
name|vari
value|cp->xform[fn].var
comment|/* first compute the color coord */
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|p
index|[
literal|2
index|]
operator|+
name|cp
operator|->
name|xform
index|[
name|fn
index|]
operator|.
name|color
operator|)
operator|/
literal|2.0
expr_stmt|;
comment|/* then apply the affine part of the function */
name|tx
operator|=
name|coef
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|p
index|[
literal|0
index|]
operator|+
name|coef
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|p
index|[
literal|1
index|]
operator|+
name|coef
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ty
operator|=
name|coef
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|p
index|[
literal|0
index|]
operator|+
name|coef
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|p
index|[
literal|1
index|]
operator|+
name|coef
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
comment|/* then add in proportional amounts of each of the variations */
name|v
operator|=
name|vari
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* linear */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|tx
expr_stmt|;
name|ny
operator|=
name|ty
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* sinusoidal */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|sin
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ny
operator|=
name|sin
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* spherical */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|double
name|r2
init|=
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
operator|+
literal|1e-6
decl_stmt|;
name|nx
operator|=
name|tx
operator|/
name|r2
expr_stmt|;
name|ny
operator|=
name|ty
operator|/
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* swirl */
name|double
name|r2
init|=
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
decl_stmt|;
comment|/* /k here is fun */
name|double
name|c1
init|=
name|sin
argument_list|(
name|r2
argument_list|)
decl_stmt|;
name|double
name|c2
init|=
name|cos
argument_list|(
name|r2
argument_list|)
decl_stmt|;
name|double
name|nx
init|=
name|c1
operator|*
name|tx
operator|-
name|c2
operator|*
name|ty
decl_stmt|;
name|double
name|ny
init|=
name|c2
operator|*
name|tx
operator|+
name|c1
operator|*
name|ty
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* horseshoe */
name|double
name|a
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|a
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
comment|/* times k here is fun */
else|else
name|a
operator|=
literal|0.0
expr_stmt|;
name|c1
operator|=
name|sin
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|c2
operator|=
name|cos
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|nx
operator|=
name|c1
operator|*
name|tx
operator|-
name|c2
operator|*
name|ty
expr_stmt|;
name|ny
operator|=
name|c2
operator|*
name|tx
operator|+
name|c1
operator|*
name|ty
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* polar */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|nx
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
operator|/
name|G_PI
expr_stmt|;
else|else
name|nx
operator|=
literal|0.0
expr_stmt|;
name|ny
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
operator|-
literal|1.0
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* bent */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|tx
expr_stmt|;
name|ny
operator|=
name|ty
expr_stmt|;
if|if
condition|(
name|nx
operator|<
literal|0.0
condition|)
name|nx
operator|=
name|nx
operator|*
literal|2.0
expr_stmt|;
if|if
condition|(
name|ny
operator|<
literal|0.0
condition|)
name|ny
operator|=
name|ny
operator|/
literal|2.0
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* folded handkerchief */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|nx
operator|=
name|sin
argument_list|(
name|theta
operator|+
name|r2
argument_list|)
operator|*
name|r2
expr_stmt|;
name|ny
operator|=
name|cos
argument_list|(
name|theta
operator|-
name|r2
argument_list|)
operator|*
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* heart */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|theta
operator|*=
name|r2
expr_stmt|;
name|nx
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
operator|*
name|r2
expr_stmt|;
name|ny
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
operator|*
operator|-
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|9
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* disc */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|nx
operator|=
name|tx
operator|*
name|G_PI
expr_stmt|;
name|ny
operator|=
name|ty
operator|*
name|G_PI
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|nx
operator|*
name|nx
operator|*
name|ny
operator|*
name|ny
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|sin
argument_list|(
name|r2
argument_list|)
operator|*
name|theta
operator|/
name|G_PI
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|cos
argument_list|(
name|r2
argument_list|)
operator|*
name|theta
operator|/
name|G_PI
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|10
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* spiral */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
operator|+
literal|1e-6
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
operator|(
name|cos
argument_list|(
name|theta
argument_list|)
operator|+
name|sin
argument_list|(
name|r2
argument_list|)
operator|)
operator|/
name|r2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
operator|(
name|cos
argument_list|(
name|theta
argument_list|)
operator|+
name|cos
argument_list|(
name|r2
argument_list|)
operator|)
operator|/
name|r2
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|11
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* hyperbolic */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
operator|+
literal|1e-6
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
operator|/
name|r2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
operator|*
name|r2
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|12
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|;
comment|/* diamond */
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
operator|*
name|cos
argument_list|(
name|r2
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
operator|*
name|sin
argument_list|(
name|r2
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|13
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* ex */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|n0
decl_stmt|,
name|n1
decl_stmt|,
name|m0
decl_stmt|,
name|m1
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|n0
operator|=
name|sin
argument_list|(
name|theta
operator|+
name|r2
argument_list|)
expr_stmt|;
name|n1
operator|=
name|cos
argument_list|(
name|theta
operator|-
name|r2
argument_list|)
expr_stmt|;
name|m0
operator|=
name|n0
operator|*
name|n0
operator|*
name|n0
operator|*
name|r2
expr_stmt|;
name|m1
operator|=
name|n1
operator|*
name|n1
operator|*
name|n1
operator|*
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
operator|(
name|m0
operator|+
name|m1
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
operator|(
name|m0
operator|-
name|m1
operator|)
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|14
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
comment|/* julia */
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|flam3_random_bit
argument_list|()
condition|)
name|theta
operator|+=
name|G_PI
expr_stmt|;
name|r2
operator|=
name|pow
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|,
literal|0.25
argument_list|)
expr_stmt|;
name|nx
operator|=
name|r2
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|ny
operator|=
name|r2
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|15
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* waves */
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|dx
operator|=
name|coef
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dy
operator|=
name|coef
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|nx
operator|=
name|tx
operator|+
name|coef
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|sin
argument_list|(
name|ty
operator|/
operator|(
operator|(
name|dx
operator|*
name|dx
operator|)
operator|+
name|EPS
operator|)
argument_list|)
expr_stmt|;
name|ny
operator|=
name|ty
operator|+
name|coef
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|sin
argument_list|(
name|tx
operator|/
operator|(
operator|(
name|dy
operator|*
name|dy
operator|)
operator|+
name|EPS
operator|)
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|16
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* fisheye */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|r2
operator|=
literal|2
operator|*
name|r2
operator|/
operator|(
name|r2
operator|+
literal|1
operator|)
expr_stmt|;
name|nx
operator|=
name|r2
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|ny
operator|=
name|r2
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|17
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* popcorn */
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|dx
operator|=
name|tan
argument_list|(
literal|3
operator|*
name|ty
argument_list|)
expr_stmt|;
name|dy
operator|=
name|tan
argument_list|(
literal|3
operator|*
name|tx
argument_list|)
expr_stmt|;
name|nx
operator|=
name|tx
operator|+
name|coef
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|sin
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|ny
operator|=
name|ty
operator|+
name|coef
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|sin
argument_list|(
name|dy
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|18
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* exponential */
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|dx
operator|=
name|exp
argument_list|(
name|tx
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|dy
operator|=
name|G_PI
operator|*
name|ty
expr_stmt|;
name|nx
operator|=
name|cos
argument_list|(
name|dy
argument_list|)
operator|*
name|dx
expr_stmt|;
name|ny
operator|=
name|sin
argument_list|(
name|dy
argument_list|)
operator|*
name|dx
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|19
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* power */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|tsin
decl_stmt|,
name|tcos
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|tsin
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|tcos
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|r2
operator|=
name|pow
argument_list|(
name|r2
argument_list|,
name|tsin
argument_list|)
expr_stmt|;
name|nx
operator|=
name|r2
operator|*
name|tcos
expr_stmt|;
empty_stmt|;
name|ny
operator|=
name|r2
operator|*
name|tsin
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|20
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* cosine */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|cos
argument_list|(
name|tx
operator|*
name|G_PI
argument_list|)
operator|*
name|cosh
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|ny
operator|=
operator|-
name|sin
argument_list|(
name|tx
operator|*
name|G_PI
argument_list|)
operator|*
name|sinh
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|21
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* rings */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|dx
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0
expr_stmt|;
name|dx
operator|=
name|coef
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dx
operator|=
name|dx
operator|*
name|dx
operator|+
name|EPS
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|r2
operator|=
name|fmod
argument_list|(
name|r2
operator|+
name|dx
argument_list|,
literal|2
operator|*
name|dx
argument_list|)
operator|-
name|dx
operator|+
name|r2
operator|*
operator|(
literal|1
operator|-
name|dx
operator|)
expr_stmt|;
name|nx
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
operator|*
name|r2
expr_stmt|;
name|ny
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
operator|*
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|22
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* fan */
name|double
name|theta
decl_stmt|,
name|r2
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dx2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|theta
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
literal|0.0
expr_stmt|;
name|dx
operator|=
name|coef
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dy
operator|=
name|coef
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|dx
operator|=
name|G_PI
operator|*
operator|(
name|dx
operator|*
name|dx
operator|+
name|EPS
operator|)
expr_stmt|;
name|dx2
operator|=
name|dx
operator|/
literal|2
expr_stmt|;
name|r2
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
expr_stmt|;
name|theta
operator|+=
operator|(
name|fmod
argument_list|(
name|theta
operator|+
name|dy
argument_list|,
name|dx
argument_list|)
operator|>
name|dx2
operator|)
condition|?
operator|-
name|dx2
else|:
name|dx2
expr_stmt|;
name|nx
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
operator|*
name|r2
expr_stmt|;
name|ny
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
operator|*
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|23
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* eyefish */
name|double
name|r2
decl_stmt|;
name|r2
operator|=
literal|2.0
operator|*
name|v
operator|/
operator|(
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
operator|+
literal|1.0
operator|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|r2
operator|*
name|tx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|r2
operator|*
name|ty
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|24
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* bubble */
name|double
name|r2
decl_stmt|;
name|r2
operator|=
name|v
operator|/
operator|(
operator|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
operator|)
operator|/
literal|4
operator|+
literal|1
operator|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|r2
operator|*
name|tx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|r2
operator|*
name|ty
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|25
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* cylinder */
name|double
name|nx
decl_stmt|;
name|nx
operator|=
name|sin
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ty
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|26
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* noise */
name|double
name|rx
decl_stmt|,
name|sinr
decl_stmt|,
name|cosr
decl_stmt|,
name|nois
decl_stmt|;
name|rx
operator|=
name|flam3_random01
argument_list|()
operator|*
literal|2
operator|*
name|G_PI
expr_stmt|;
name|sinr
operator|=
name|sin
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|cosr
operator|=
name|cos
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|nois
operator|=
name|flam3_random01
argument_list|()
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nois
operator|*
name|tx
operator|*
name|cosr
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|nois
operator|*
name|ty
operator|*
name|sinr
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|27
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* blur */
name|double
name|rx
decl_stmt|,
name|sinr
decl_stmt|,
name|cosr
decl_stmt|,
name|nois
decl_stmt|;
name|rx
operator|=
name|flam3_random01
argument_list|()
operator|*
literal|2
operator|*
name|G_PI
expr_stmt|;
name|sinr
operator|=
name|sin
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|cosr
operator|=
name|cos
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|nois
operator|=
name|flam3_random01
argument_list|()
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nois
operator|*
name|cosr
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|nois
operator|*
name|sinr
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|28
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* gaussian */
name|double
name|ang
decl_stmt|,
name|sina
decl_stmt|,
name|cosa
decl_stmt|,
name|r2
decl_stmt|;
name|ang
operator|=
name|flam3_random01
argument_list|()
operator|*
literal|2
operator|*
name|G_PI
expr_stmt|;
name|sina
operator|=
name|sin
argument_list|(
name|ang
argument_list|)
expr_stmt|;
name|cosa
operator|=
name|cos
argument_list|(
name|ang
argument_list|)
expr_stmt|;
name|r2
operator|=
name|v
operator|*
operator|(
name|flam3_random01
argument_list|()
operator|+
name|flam3_random01
argument_list|()
operator|+
name|flam3_random01
argument_list|()
operator|+
name|flam3_random01
argument_list|()
operator|-
literal|2.0
operator|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|r2
operator|*
name|cosa
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|r2
operator|*
name|sina
expr_stmt|;
block|}
comment|/* if fuse over, store it */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|points
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* args must be non-overlapping */
end_comment

begin_function
name|void
DECL|function|mult_matrix (double s1[2][2],double s2[2][2],double d[2][2])
name|mult_matrix
parameter_list|(
name|double
name|s1
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|,
name|double
name|s2
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|,
name|double
name|d
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|)
block|{
name|d
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
DECL|function|det_matrix (double s[2][2])
name|double
name|det_matrix
parameter_list|(
name|double
name|s
index|[
literal|2
index|]
index|[
literal|2
index|]
parameter_list|)
block|{
return|return
name|s
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|s
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s
index|[
literal|1
index|]
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|interpolate_angle (double t,double s,double * v1,double * v2,double * v3,int tie,int cross)
name|interpolate_angle
parameter_list|(
name|double
name|t
parameter_list|,
name|double
name|s
parameter_list|,
name|double
modifier|*
name|v1
parameter_list|,
name|double
modifier|*
name|v2
parameter_list|,
name|double
modifier|*
name|v3
parameter_list|,
name|int
name|tie
parameter_list|,
name|int
name|cross
parameter_list|)
block|{
name|double
name|x
init|=
operator|*
name|v1
decl_stmt|;
name|double
name|y
init|=
operator|*
name|v2
decl_stmt|;
name|double
name|d
decl_stmt|;
specifier|static
name|double
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
comment|/* take the shorter way around the circle... */
if|if
condition|(
name|x
operator|>
name|y
condition|)
block|{
name|d
operator|=
name|x
operator|-
name|y
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|G_PI
operator|+
name|EPS
operator|||
operator|(
name|d
operator|>
name|G_PI
operator|-
name|EPS
operator|&&
name|tie
operator|)
condition|)
name|y
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|y
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|G_PI
operator|+
name|EPS
operator|||
operator|(
name|d
operator|>
name|G_PI
operator|-
name|EPS
operator|&&
name|tie
operator|)
condition|)
name|x
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
comment|/* unless we are supposed to avoid crossing */
if|if
condition|(
name|cross
condition|)
block|{
if|if
condition|(
name|lastx
operator|>
name|x
condition|)
block|{
if|if
condition|(
name|lasty
operator|<
name|y
condition|)
name|y
operator|-=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lasty
operator|>
name|y
condition|)
name|y
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
operator|*
name|v3
operator|=
name|s
operator|*
name|x
operator|+
name|t
operator|*
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|interpolate_complex (double t,double s,double * r1,double * r2,double * r3,int flip,int tie,int cross)
name|interpolate_complex
parameter_list|(
name|double
name|t
parameter_list|,
name|double
name|s
parameter_list|,
name|double
modifier|*
name|r1
parameter_list|,
name|double
modifier|*
name|r2
parameter_list|,
name|double
modifier|*
name|r3
parameter_list|,
name|int
name|flip
parameter_list|,
name|int
name|tie
parameter_list|,
name|int
name|cross
parameter_list|)
block|{
name|double
name|c1
index|[
literal|2
index|]
decl_stmt|,
name|c2
index|[
literal|2
index|]
decl_stmt|,
name|c3
index|[
literal|2
index|]
decl_stmt|;
name|double
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|c1
index|[
literal|0
index|]
operator|=
name|r1
index|[
literal|0
index|]
expr_stmt|;
name|c1
index|[
literal|1
index|]
operator|=
name|r1
index|[
literal|1
index|]
expr_stmt|;
name|c2
index|[
literal|0
index|]
operator|=
name|r2
index|[
literal|0
index|]
expr_stmt|;
name|c2
index|[
literal|1
index|]
operator|=
name|r2
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|flip
condition|)
block|{
name|double
name|t
init|=
name|c1
index|[
literal|0
index|]
decl_stmt|;
name|c1
index|[
literal|0
index|]
operator|=
name|c1
index|[
literal|1
index|]
expr_stmt|;
name|c1
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|c2
index|[
literal|0
index|]
expr_stmt|;
name|c2
index|[
literal|0
index|]
operator|=
name|c2
index|[
literal|1
index|]
expr_stmt|;
name|c2
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
comment|/* convert to log space */
name|a1
operator|=
name|atan2
argument_list|(
name|c1
index|[
literal|1
index|]
argument_list|,
name|c1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|a2
operator|=
name|atan2
argument_list|(
name|c2
index|[
literal|1
index|]
argument_list|,
name|c2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|d1
operator|=
literal|0.5
operator|*
name|log
argument_list|(
name|c1
index|[
literal|0
index|]
operator|*
name|c1
index|[
literal|0
index|]
operator|+
name|c1
index|[
literal|1
index|]
operator|*
name|c1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|d2
operator|=
literal|0.5
operator|*
name|log
argument_list|(
name|c2
index|[
literal|0
index|]
operator|*
name|c2
index|[
literal|0
index|]
operator|+
name|c2
index|[
literal|1
index|]
operator|*
name|c2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* interpolate linearly */
name|interpolate_angle
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
operator|&
name|a1
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|a3
argument_list|,
name|tie
argument_list|,
name|cross
argument_list|)
expr_stmt|;
name|d3
operator|=
name|s
operator|*
name|d1
operator|+
name|t
operator|*
name|d2
expr_stmt|;
comment|/* convert back */
name|d3
operator|=
name|exp
argument_list|(
name|d3
argument_list|)
expr_stmt|;
name|c3
index|[
literal|0
index|]
operator|=
name|cos
argument_list|(
name|a3
argument_list|)
operator|*
name|d3
expr_stmt|;
name|c3
index|[
literal|1
index|]
operator|=
name|sin
argument_list|(
name|a3
argument_list|)
operator|*
name|d3
expr_stmt|;
if|if
condition|(
name|flip
condition|)
block|{
name|r3
index|[
literal|1
index|]
operator|=
name|c3
index|[
literal|0
index|]
expr_stmt|;
name|r3
index|[
literal|0
index|]
operator|=
name|c3
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|r3
index|[
literal|0
index|]
operator|=
name|c3
index|[
literal|0
index|]
expr_stmt|;
name|r3
index|[
literal|1
index|]
operator|=
name|c3
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|interpolate_matrix (double t,double m1[3][2],double m2[3][2],double m3[3][2])
name|interpolate_matrix
parameter_list|(
name|double
name|t
parameter_list|,
name|double
name|m1
index|[
literal|3
index|]
index|[
literal|2
index|]
parameter_list|,
name|double
name|m2
index|[
literal|3
index|]
index|[
literal|2
index|]
parameter_list|,
name|double
name|m3
index|[
literal|3
index|]
index|[
literal|2
index|]
parameter_list|)
block|{
name|double
name|s
init|=
literal|1.0
operator|-
name|t
decl_stmt|;
name|interpolate_complex
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
operator|&
name|m1
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|m2
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|m3
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|interpolate_complex
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
operator|&
name|m1
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|m2
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|m3
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* handle the translation part of the xform linearly */
name|m3
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|s
operator|*
name|m1
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|t
operator|*
name|m2
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m3
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|s
operator|*
name|m1
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
name|t
operator|*
name|m2
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_define
DECL|macro|INTERP (x)
define|#
directive|define
name|INTERP
parameter_list|(
name|x
parameter_list|)
value|result->x = c0 * cps[i1].x + c1 * cps[i2].x
end_define

begin_comment
comment|/*  * create a control point that interpolates between the control points  * passed in CPS.  for now just do linear.  in the future, add control  * point types and other things to the cps.  CPS must be sorted by time.  */
end_comment

begin_function
name|void
DECL|function|interpolate (control_point cps[],int ncps,double time,control_point * result)
name|interpolate
parameter_list|(
name|control_point
name|cps
index|[]
parameter_list|,
name|int
name|ncps
parameter_list|,
name|double
name|time
parameter_list|,
name|control_point
modifier|*
name|result
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|double
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|ncps
operator|==
literal|1
condition|)
block|{
operator|*
name|result
operator|=
name|cps
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cps
index|[
literal|0
index|]
operator|.
name|time
operator|>=
name|time
condition|)
block|{
name|i1
operator|=
literal|0
expr_stmt|;
name|i2
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cps
index|[
name|ncps
operator|-
literal|1
index|]
operator|.
name|time
operator|<=
name|time
condition|)
block|{
name|i1
operator|=
name|ncps
operator|-
literal|2
expr_stmt|;
name|i2
operator|=
name|ncps
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|<
name|time
condition|)
name|i1
operator|++
expr_stmt|;
name|i1
operator|--
expr_stmt|;
name|i2
operator|=
name|i1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|time
operator|-
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|>
operator|-
literal|1e-7
operator|&&
name|time
operator|-
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|<
literal|1e-7
condition|)
block|{
operator|*
name|result
operator|=
name|cps
index|[
name|i1
index|]
expr_stmt|;
return|return;
block|}
block|}
name|c0
operator|=
operator|(
name|cps
index|[
name|i2
index|]
operator|.
name|time
operator|-
name|time
operator|)
operator|/
operator|(
name|cps
index|[
name|i2
index|]
operator|.
name|time
operator|-
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|)
expr_stmt|;
name|c1
operator|=
literal|1.0
operator|-
name|c0
expr_stmt|;
name|result
operator|->
name|time
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|cps
index|[
name|i1
index|]
operator|.
name|cmap_inter
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|double
name|spread
init|=
literal|0.15
decl_stmt|;
name|double
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|c
init|=
literal|2
operator|*
name|G_PI
operator|*
name|i
operator|/
literal|256.0
decl_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|c
operator|*
name|cps
index|[
name|i1
index|]
operator|.
name|cmap_inter
argument_list|)
operator|+
literal|4.0
operator|*
name|c1
operator|-
literal|2.0
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|spread
condition|)
name|c
operator|=
name|spread
expr_stmt|;
if|if
condition|(
name|c
operator|<
operator|-
name|spread
condition|)
name|c
operator|=
operator|-
name|spread
expr_stmt|;
name|d1
operator|=
operator|(
name|c
operator|+
name|spread
operator|)
operator|*
literal|0.5
operator|/
name|spread
expr_stmt|;
name|d0
operator|=
literal|1.0
operator|-
name|d1
expr_stmt|;
name|e0
operator|=
operator|(
name|d0
operator|<
literal|0.5
operator|)
condition|?
operator|(
name|d0
operator|*
literal|2
operator|)
else|:
operator|(
name|d1
operator|*
literal|2
operator|)
expr_stmt|;
name|e1
operator|=
literal|1.0
operator|-
name|e0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|->
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|d0
operator|*
name|cps
index|[
name|i1
index|]
operator|.
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|d1
operator|*
name|cps
index|[
name|i2
index|]
operator|.
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
DECL|macro|bright_peak
define|#
directive|define
name|bright_peak
value|2.0
name|result
operator|->
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|e1
operator|*
name|result
operator|->
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|e0
operator|*
literal|1.0
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|double
name|t
index|[
literal|3
index|]
decl_stmt|,
name|s
index|[
literal|3
index|]
decl_stmt|;
name|rgb2hsv
argument_list|(
name|cps
index|[
name|i1
index|]
operator|.
name|cmap
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rgb2hsv
argument_list|(
name|cps
index|[
name|i2
index|]
operator|.
name|cmap
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|t
index|[
name|j
index|]
operator|=
name|c0
operator|*
name|s
index|[
name|j
index|]
operator|+
name|c1
operator|*
name|t
index|[
name|j
index|]
expr_stmt|;
name|hsv2rgb
argument_list|(
name|t
argument_list|,
name|result
operator|->
name|cmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|->
name|cmap_index
operator|=
operator|-
literal|1
expr_stmt|;
name|INTERP
argument_list|(
name|brightness
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|contrast
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|gamma
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|spatial_oversample
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|center
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|center
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|pixels_per_unit
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|spatial_filter_radius
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|sample_density
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|zoom
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|nbatches
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|white_level
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|INTERP
argument_list|(
name|pulse
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|wiggle
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|double
name|r
decl_stmt|;
name|INTERP
argument_list|(
name|xform
index|[
name|i
index|]
operator|.
name|density
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|>
literal|0
condition|)
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|1.0
expr_stmt|;
name|INTERP
argument_list|(
name|xform
index|[
name|i
index|]
operator|.
name|color
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|INTERP
argument_list|(
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|t
operator|+=
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
name|t
operator|=
literal|1.0
operator|/
name|t
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|*=
name|t
expr_stmt|;
name|interpolate_matrix
argument_list|(
name|c1
argument_list|,
name|cps
index|[
name|i1
index|]
operator|.
name|xform
index|[
name|i
index|]
operator|.
name|c
argument_list|,
name|cps
index|[
name|i2
index|]
operator|.
name|xform
index|[
name|i
index|]
operator|.
name|c
argument_list|,
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|double
name|rh_time
init|=
name|time
operator|*
literal|2
operator|*
name|G_PI
operator|/
operator|(
literal|60.0
operator|*
literal|30.0
operator|)
decl_stmt|;
comment|/* apply pulse factor. */
name|r
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|r
operator|+=
name|result
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|0
index|]
operator|*
name|sin
argument_list|(
name|result
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|1
index|]
operator|*
name|rh_time
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|0
index|]
operator|*=
name|r
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|1
index|]
operator|*=
name|r
expr_stmt|;
block|}
comment|/* apply wiggle factor */
name|r
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|double
name|tt
init|=
name|result
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|1
index|]
operator|*
name|rh_time
decl_stmt|;
name|double
name|m
init|=
name|result
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|0
index|]
decl_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+=
name|m
operator|*
name|cos
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+=
name|m
operator|*
operator|-
name|sin
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+=
name|m
operator|*
name|sin
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+=
name|m
operator|*
name|cos
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* for i */
block|}
end_function

begin_comment
comment|/*  * split a string passed in ss into tokens on whitespace.  * # comments to end of line.  ; terminates the record  */
end_comment

begin_function
name|void
DECL|function|tokenize (char ** ss,char * argv[],int * argc)
name|tokenize
parameter_list|(
name|char
modifier|*
modifier|*
name|ss
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
modifier|*
name|argc
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|ss
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|state
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|';'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|s
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|state
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_ascii_isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
case|case
literal|1
case|:
if|if
condition|(
name|g_ascii_isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
case|case
literal|2
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|state
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|*
name|ss
operator|=
name|s
operator|+
literal|1
expr_stmt|;
operator|*
name|argc
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|compare_xforms (const void * va,const void * vb)
name|compare_xforms
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
name|double
name|aa
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|bb
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|ad
decl_stmt|,
name|bd
decl_stmt|;
specifier|const
name|xform
modifier|*
name|a
init|=
name|va
decl_stmt|;
specifier|const
name|xform
modifier|*
name|b
init|=
name|vb
decl_stmt|;
name|aa
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|aa
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|aa
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|aa
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bb
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|bb
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bb
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|bb
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|ad
operator|=
name|det_matrix
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|bd
operator|=
name|det_matrix
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|<
name|bd
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ad
operator|>
name|bd
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
DECL|macro|MAXARGS
define|#
directive|define
name|MAXARGS
value|1000
end_define

begin_define
DECL|macro|streql (x,y)
define|#
directive|define
name|streql
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(!strcmp(x,y))
end_define

begin_comment
comment|/*  * given a pointer to a string SS, fill fields of a control point CP.  * return a pointer to the first unused char in SS.  totally barfucious,  * must integrate with tcl soon...  */
end_comment

begin_function
name|void
DECL|function|parse_control_point (char ** ss,control_point * cp)
name|parse_control_point
parameter_list|(
name|char
modifier|*
modifier|*
name|ss
parameter_list|,
name|control_point
modifier|*
name|cp
parameter_list|)
block|{
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|set_cm
init|=
literal|0
decl_stmt|,
name|set_image_size
init|=
literal|0
decl_stmt|,
name|set_nbatches
init|=
literal|0
decl_stmt|,
name|set_white_level
init|=
literal|0
decl_stmt|,
name|set_cmap_inter
init|=
literal|0
decl_stmt|;
name|int
name|set_spatial_oversample
init|=
literal|0
decl_stmt|;
name|double
modifier|*
name|slot
init|=
name|NULL
decl_stmt|,
name|xf
decl_stmt|,
name|cm
decl_stmt|,
name|t
decl_stmt|,
name|nbatches
decl_stmt|,
name|white_level
decl_stmt|,
name|spatial_oversample
decl_stmt|,
name|cmap_inter
decl_stmt|;
name|double
name|image_size
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|color
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
literal|60.0
expr_stmt|;
name|cp
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
literal|60.0
expr_stmt|;
block|}
name|tokenize
argument_list|(
name|ss
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streql
argument_list|(
literal|"xform"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|xf
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"time"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|time
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"brightness"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|brightness
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"contrast"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|contrast
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"gamma"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|gamma
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"zoom"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|zoom
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"image_size"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
name|image_size
expr_stmt|;
name|set_image_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"center"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
name|cp
operator|->
name|center
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"pulse"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|(
name|double
operator|*
operator|)
name|cp
operator|->
name|pulse
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"wiggle"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|(
name|double
operator|*
operator|)
name|cp
operator|->
name|wiggle
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"pixels_per_unit"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|pixels_per_unit
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"spatial_filter_radius"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|spatial_filter_radius
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"sample_density"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|sample_density
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"nbatches"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|nbatches
expr_stmt|;
name|set_nbatches
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"white_level"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|white_level
expr_stmt|;
name|set_white_level
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"spatial_oversample"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|spatial_oversample
expr_stmt|;
name|set_spatial_oversample
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"cmap"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|cm
expr_stmt|;
name|set_cm
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"density"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|density
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"color"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|color
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"coefs"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|c
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|density
operator|=
literal|1.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"var"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|var
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"cmap_inter"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|cmap_inter
expr_stmt|;
name|set_cmap_inter
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|slot
operator|++
operator|=
name|g_strtod
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_cm
condition|)
block|{
name|cp
operator|->
name|cmap_index
operator|=
operator|(
name|int
operator|)
name|cm
expr_stmt|;
name|get_cmap
argument_list|(
name|cp
operator|->
name|cmap_index
argument_list|,
name|cp
operator|->
name|cmap
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_image_size
condition|)
block|{
name|cp
operator|->
name|width
operator|=
operator|(
name|int
operator|)
name|image_size
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|height
operator|=
operator|(
name|int
operator|)
name|image_size
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|set_cmap_inter
condition|)
name|cp
operator|->
name|cmap_inter
operator|=
operator|(
name|int
operator|)
name|cmap_inter
expr_stmt|;
if|if
condition|(
name|set_nbatches
condition|)
name|cp
operator|->
name|nbatches
operator|=
operator|(
name|int
operator|)
name|nbatches
expr_stmt|;
if|if
condition|(
name|set_spatial_oversample
condition|)
name|cp
operator|->
name|spatial_oversample
operator|=
operator|(
name|int
operator|)
name|spatial_oversample
expr_stmt|;
if|if
condition|(
name|set_white_level
condition|)
name|cp
operator|->
name|white_level
operator|=
operator|(
name|int
operator|)
name|white_level
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|t
operator|+=
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
name|t
operator|=
literal|1.0
operator|/
name|t
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|*=
name|t
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|->
name|xform
argument_list|,
name|NXFORMS
argument_list|,
sizeof|sizeof
argument_list|(
name|xform
argument_list|)
argument_list|,
name|compare_xforms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|print_control_point (FILE * f,control_point * cp,int quote)
name|print_control_point
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|control_point
modifier|*
name|cp
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|quote
condition|?
literal|"# "
else|:
literal|""
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%stime %g\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cmap_index
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%scmap %d\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|cmap_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%simage_size %d %d center %g %g pixels_per_unit %g\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|width
argument_list|,
name|cp
operator|->
name|height
argument_list|,
name|cp
operator|->
name|center
index|[
literal|0
index|]
argument_list|,
name|cp
operator|->
name|center
index|[
literal|1
index|]
argument_list|,
name|cp
operator|->
name|pixels_per_unit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sspatial_oversample %d spatial_filter_radius %g"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|spatial_oversample
argument_list|,
name|cp
operator|->
name|spatial_filter_radius
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" sample_density %g\n"
argument_list|,
name|cp
operator|->
name|sample_density
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%snbatches %d white_level %d\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|nbatches
argument_list|,
name|cp
operator|->
name|white_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sbrightness %g gamma %g cmap_inter %d\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|brightness
argument_list|,
name|cp
operator|->
name|gamma
argument_list|,
name|cp
operator|->
name|cmap_inter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|>
literal|0.0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sxform %d density %g color %g\n"
argument_list|,
name|q
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|color
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%svar"
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %g"
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n%scoefs"
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %g %g"
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s;\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns a uniform variable from 0 to 1 */
end_comment

begin_function
name|double
DECL|function|random_uniform01 (void)
name|random_uniform01
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|g_random_double
argument_list|()
return|;
block|}
end_function

begin_function
DECL|function|random_uniform11 (void)
name|double
name|random_uniform11
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|g_random_double_range
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* returns a mean 0 variance 1 random variable    see numerical recipies p 217 */
end_comment

begin_function
DECL|function|random_gaussian (void)
name|double
name|random_gaussian
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|iset
init|=
literal|0
decl_stmt|;
specifier|static
name|double
name|gset
decl_stmt|;
name|double
name|fac
decl_stmt|,
name|r
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|iset
operator|==
literal|0
condition|)
block|{
do|do
block|{
name|v1
operator|=
name|random_uniform11
argument_list|()
expr_stmt|;
name|v2
operator|=
name|random_uniform11
argument_list|()
expr_stmt|;
name|r
operator|=
name|v1
operator|*
name|v1
operator|+
name|v2
operator|*
name|v2
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|>=
literal|1.0
operator|||
name|r
operator|==
literal|0.0
condition|)
do|;
name|fac
operator|=
name|sqrt
argument_list|(
operator|-
literal|2.0
operator|*
name|log
argument_list|(
name|r
argument_list|)
operator|/
name|r
argument_list|)
expr_stmt|;
name|gset
operator|=
name|v1
operator|*
name|fac
expr_stmt|;
name|iset
operator|=
literal|1
expr_stmt|;
return|return
name|v2
operator|*
name|fac
return|;
block|}
name|iset
operator|=
literal|0
expr_stmt|;
return|return
name|gset
return|;
block|}
end_function

begin_function
name|void
DECL|function|copy_variation (control_point * cp0,control_point * cp1)
name|copy_variation
parameter_list|(
name|control_point
modifier|*
name|cp0
parameter_list|,
name|control_point
modifier|*
name|cp1
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp0
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|=
name|cp1
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_define
DECL|macro|random_distrib (v)
define|#
directive|define
name|random_distrib
parameter_list|(
name|v
parameter_list|)
value|((v)[g_random_int_range (0, vlen(v))])
end_define

begin_function
name|void
DECL|function|random_control_point (control_point * cp,int ivar)
name|random_control_point
parameter_list|(
name|control_point
modifier|*
name|cp
parameter_list|,
name|int
name|ivar
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nxforms
decl_stmt|,
name|var
decl_stmt|;
specifier|static
name|int
name|xform_distrib
index|[]
init|=
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
specifier|static
name|int
name|var_distrib
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
specifier|static
name|int
name|mixed_var_distrib
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
name|get_cmap
argument_list|(
name|cmap_random
argument_list|,
name|cp
operator|->
name|cmap
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|cp
operator|->
name|time
operator|=
literal|0.0
expr_stmt|;
name|nxforms
operator|=
name|random_distrib
argument_list|(
name|xform_distrib
argument_list|)
expr_stmt|;
name|var
operator|=
operator|(
literal|0
operator|>
name|ivar
operator|)
condition|?
name|random_distrib
argument_list|(
name|var_distrib
argument_list|)
else|:
name|ivar
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nxforms
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|1.0
operator|/
name|nxforms
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|color
operator|=
name|i
operator|==
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|random_uniform11
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|var
operator|>=
literal|0
condition|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|var
index|]
operator|=
literal|1.0
expr_stmt|;
else|else
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|random_distrib
argument_list|(
name|mixed_var_distrib
argument_list|)
index|]
operator|=
literal|1.0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|0.0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find a 2d bounding box that does not enclose eps of the fractal density  * in each compass direction.  works by binary search.  * this is stupid, it shouldjust use the find nth smallest algorithm.  */
end_comment

begin_function
name|void
DECL|function|estimate_bounding_box (control_point * cp,double eps,double * bmin,double * bmax)
name|estimate_bounding_box
parameter_list|(
name|control_point
modifier|*
name|cp
parameter_list|,
name|double
name|eps
parameter_list|,
name|double
modifier|*
name|bmin
parameter_list|,
name|double
modifier|*
name|bmax
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|batch
init|=
operator|(
name|eps
operator|==
literal|0.0
operator|)
condition|?
literal|10000
else|:
literal|10.0
operator|/
name|eps
decl_stmt|;
name|int
name|low_target
init|=
name|batch
operator|*
name|eps
decl_stmt|;
name|int
name|high_target
init|=
name|batch
operator|-
name|low_target
decl_stmt|;
name|point
name|min
decl_stmt|,
name|max
decl_stmt|,
name|delta
decl_stmt|;
name|point
modifier|*
name|points
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|point
argument_list|)
operator|*
name|batch
argument_list|)
decl_stmt|;
name|iterate
argument_list|(
name|cp
argument_list|,
name|batch
argument_list|,
literal|20
argument_list|,
name|points
argument_list|)
expr_stmt|;
name|min
index|[
literal|0
index|]
operator|=
name|min
index|[
literal|1
index|]
operator|=
literal|1e10
expr_stmt|;
name|max
index|[
literal|0
index|]
operator|=
name|max
index|[
literal|1
index|]
operator|=
operator|-
literal|1e10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|batch
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
operator|<
name|min
index|[
literal|0
index|]
condition|)
name|min
index|[
literal|0
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
operator|<
name|min
index|[
literal|1
index|]
condition|)
name|min
index|[
literal|1
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
operator|>
name|max
index|[
literal|0
index|]
condition|)
name|max
index|[
literal|0
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
operator|>
name|max
index|[
literal|1
index|]
condition|)
name|max
index|[
literal|1
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|low_target
operator|==
literal|0
condition|)
block|{
name|bmin
index|[
literal|0
index|]
operator|=
name|min
index|[
literal|0
index|]
expr_stmt|;
name|bmin
index|[
literal|1
index|]
operator|=
name|min
index|[
literal|1
index|]
expr_stmt|;
name|bmax
index|[
literal|0
index|]
operator|=
name|max
index|[
literal|0
index|]
expr_stmt|;
name|bmax
index|[
literal|1
index|]
operator|=
name|max
index|[
literal|1
index|]
expr_stmt|;
return|return;
block|}
name|delta
index|[
literal|0
index|]
operator|=
operator|(
name|max
index|[
literal|0
index|]
operator|-
name|min
index|[
literal|0
index|]
operator|)
operator|*
literal|0.25
expr_stmt|;
name|delta
index|[
literal|1
index|]
operator|=
operator|(
name|max
index|[
literal|1
index|]
operator|-
name|min
index|[
literal|1
index|]
operator|)
operator|*
literal|0.25
expr_stmt|;
name|bmax
index|[
literal|0
index|]
operator|=
name|bmin
index|[
literal|0
index|]
operator|=
name|min
index|[
literal|0
index|]
operator|+
literal|2.0
operator|*
name|delta
index|[
literal|0
index|]
expr_stmt|;
name|bmax
index|[
literal|1
index|]
operator|=
name|bmin
index|[
literal|1
index|]
operator|=
name|min
index|[
literal|1
index|]
operator|+
literal|2.0
operator|*
name|delta
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|,
name|s
decl_stmt|,
name|e
decl_stmt|,
name|w
decl_stmt|;
name|n
operator|=
name|s
operator|=
name|e
operator|=
name|w
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|batch
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|0
index|]
operator|<
name|bmin
index|[
literal|0
index|]
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|0
index|]
operator|>
name|bmax
index|[
literal|0
index|]
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|1
index|]
operator|<
name|bmin
index|[
literal|1
index|]
condition|)
name|w
operator|++
expr_stmt|;
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|1
index|]
operator|>
name|bmax
index|[
literal|1
index|]
condition|)
name|e
operator|++
expr_stmt|;
block|}
name|bmin
index|[
literal|0
index|]
operator|+=
operator|(
name|n
operator|<
name|low_target
operator|)
condition|?
name|delta
index|[
literal|0
index|]
else|:
operator|-
name|delta
index|[
literal|0
index|]
expr_stmt|;
name|bmax
index|[
literal|0
index|]
operator|+=
operator|(
name|s
operator|<
name|high_target
operator|)
condition|?
name|delta
index|[
literal|0
index|]
else|:
operator|-
name|delta
index|[
literal|0
index|]
expr_stmt|;
name|bmin
index|[
literal|1
index|]
operator|+=
operator|(
name|w
operator|<
name|low_target
operator|)
condition|?
name|delta
index|[
literal|1
index|]
else|:
operator|-
name|delta
index|[
literal|1
index|]
expr_stmt|;
name|bmax
index|[
literal|1
index|]
operator|+=
operator|(
name|e
operator|<
name|high_target
operator|)
condition|?
name|delta
index|[
literal|1
index|]
else|:
operator|-
name|delta
index|[
literal|1
index|]
expr_stmt|;
name|delta
index|[
literal|0
index|]
operator|=
name|delta
index|[
literal|0
index|]
operator|/
literal|2.0
expr_stmt|;
name|delta
index|[
literal|1
index|]
operator|=
name|delta
index|[
literal|1
index|]
operator|/
literal|2.0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* this has serious flaws in it */
end_comment

begin_function
name|double
DECL|function|standard_metric (control_point * cp1,control_point * cp2)
name|standard_metric
parameter_list|(
name|control_point
modifier|*
name|cp1
parameter_list|,
name|control_point
modifier|*
name|cp2
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|double
name|t
decl_stmt|;
name|double
name|dist
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|double
name|var_dist
init|=
literal|0.0
decl_stmt|;
name|double
name|coef_dist
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
name|cp1
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|-
name|cp2
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
name|var_dist
operator|+=
name|t
operator|*
name|t
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
name|t
operator|=
name|cp1
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
name|k
index|]
operator|-
name|cp2
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
name|coef_dist
operator|+=
name|t
operator|*
name|t
expr_stmt|;
block|}
comment|/* weight them equally for now. */
name|dist
operator|+=
name|var_dist
operator|+
name|coef_dist
expr_stmt|;
block|}
return|return
name|dist
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|flam3_random_bit (void)
name|flam3_random_bit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|l
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|l
operator|=
name|g_random_int
argument_list|()
expr_stmt|;
name|n
operator|=
literal|20
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|l
operator|>>
literal|1
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
return|return
name|l
operator|&
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|double
DECL|function|flam3_random01 (void)
name|flam3_random01
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|g_random_int
argument_list|()
operator|&
literal|0xfffffff
operator|)
operator|/
operator|(
name|double
operator|)
literal|0xfffffff
return|;
block|}
end_function

end_unit

