begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*     flame - cosmic recursive fractal flames     Copyright (C) 1992  Scott Draves<spot@cs.cmu.edu>      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strcmp */
end_comment

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libifs.h"
end_include

begin_define
DECL|macro|CHOOSE_XFORM_GRAIN
define|#
directive|define
name|CHOOSE_XFORM_GRAIN
value|100
end_define

begin_comment
comment|/*  * run the function system described by CP forward N generations.  * store the n resulting 3 vectors in POINTS.  the initial point is passed  * in POINTS[0].  ignore the first FUSE iterations.  */
end_comment

begin_function
DECL|function|iterate (cp,n,fuse,points)
name|void
name|iterate
parameter_list|(
name|cp
parameter_list|,
name|n
parameter_list|,
name|fuse
parameter_list|,
name|points
parameter_list|)
name|control_point
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|fuse
decl_stmt|;
name|point
modifier|*
name|points
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count_large
init|=
literal|0
decl_stmt|,
name|count_nan
init|=
literal|0
decl_stmt|;
name|int
name|xform_distrib
index|[
name|CHOOSE_XFORM_GRAIN
index|]
decl_stmt|;
name|double
name|p
index|[
literal|3
index|]
decl_stmt|,
name|t
decl_stmt|,
name|r
decl_stmt|,
name|dr
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|points
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|points
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|points
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
comment|/*     * first, set up xform, which is an array that converts a uniform random     * variable into one with the distribution dictated by the density     * fields     */
name|dr
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
name|dr
operator|+=
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
expr_stmt|;
name|dr
operator|=
name|dr
operator|/
name|CHOOSE_XFORM_GRAIN
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|cp
operator|->
name|xform
index|[
literal|0
index|]
operator|.
name|density
expr_stmt|;
name|r
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHOOSE_XFORM_GRAIN
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|r
operator|>=
name|t
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|t
operator|+=
name|cp
operator|->
name|xform
index|[
name|j
index|]
operator|.
name|density
expr_stmt|;
block|}
name|xform_distrib
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|r
operator|+=
name|dr
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|-
name|fuse
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fn
init|=
name|xform_distrib
index|[
name|g_random_int_range
argument_list|(
literal|0
argument_list|,
name|CHOOSE_XFORM_GRAIN
argument_list|)
index|]
decl_stmt|;
name|double
name|tx
decl_stmt|,
name|ty
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>
literal|100.0
operator|||
name|p
index|[
literal|0
index|]
operator|<
operator|-
literal|100.0
operator|||
name|p
index|[
literal|1
index|]
operator|>
literal|100.0
operator|||
name|p
index|[
literal|1
index|]
operator|<
operator|-
literal|100.0
condition|)
name|count_large
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|p
index|[
literal|0
index|]
condition|)
name|count_nan
operator|++
expr_stmt|;
DECL|macro|coef
define|#
directive|define
name|coef
value|cp->xform[fn].c
DECL|macro|vari
define|#
directive|define
name|vari
value|cp->xform[fn].var
comment|/* first compute the color coord */
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|p
index|[
literal|2
index|]
operator|+
name|cp
operator|->
name|xform
index|[
name|fn
index|]
operator|.
name|color
operator|)
operator|/
literal|2.0
expr_stmt|;
comment|/* then apply the affine part of the function */
name|tx
operator|=
name|coef
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|p
index|[
literal|0
index|]
operator|+
name|coef
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|p
index|[
literal|1
index|]
operator|+
name|coef
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ty
operator|=
name|coef
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|p
index|[
literal|0
index|]
operator|+
name|coef
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|p
index|[
literal|1
index|]
operator|+
name|coef
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
comment|/* then add in proportional amounts of each of the variations */
name|v
operator|=
name|vari
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* linear */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|tx
expr_stmt|;
name|ny
operator|=
name|ty
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* sinusoidal */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|sin
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ny
operator|=
name|sin
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* complex */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|double
name|r2
init|=
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
operator|+
literal|1e-6
decl_stmt|;
name|nx
operator|=
name|tx
operator|/
name|r2
expr_stmt|;
name|ny
operator|=
name|ty
operator|/
name|r2
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* swirl */
name|double
name|r2
init|=
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
decl_stmt|;
comment|/* /k here is fun */
name|double
name|c1
init|=
name|sin
argument_list|(
name|r2
argument_list|)
decl_stmt|;
name|double
name|c2
init|=
name|cos
argument_list|(
name|r2
argument_list|)
decl_stmt|;
name|double
name|nx
init|=
name|c1
operator|*
name|tx
operator|-
name|c2
operator|*
name|ty
decl_stmt|;
name|double
name|ny
init|=
name|c2
operator|*
name|tx
operator|+
name|c1
operator|*
name|ty
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* horseshoe */
name|double
name|a
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|a
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
comment|/* times k here is fun */
else|else
name|a
operator|=
literal|0.0
expr_stmt|;
name|c1
operator|=
name|sin
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|c2
operator|=
name|cos
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|nx
operator|=
name|c1
operator|*
name|tx
operator|-
name|c2
operator|*
name|ty
expr_stmt|;
name|ny
operator|=
name|c2
operator|*
name|tx
operator|+
name|c1
operator|*
name|ty
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
if|if
condition|(
name|tx
operator|<
operator|-
name|EPS
operator|||
name|tx
operator|>
name|EPS
operator|||
name|ty
operator|<
operator|-
name|EPS
operator|||
name|ty
operator|>
name|EPS
condition|)
name|nx
operator|=
name|atan2
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
operator|/
name|G_PI
expr_stmt|;
else|else
name|nx
operator|=
literal|0.0
expr_stmt|;
name|ny
operator|=
name|sqrt
argument_list|(
name|tx
operator|*
name|tx
operator|+
name|ty
operator|*
name|ty
argument_list|)
operator|-
literal|1.0
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
name|v
operator|=
name|vari
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0.0
condition|)
block|{
comment|/* bent */
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|nx
operator|=
name|tx
expr_stmt|;
name|ny
operator|=
name|ty
expr_stmt|;
if|if
condition|(
name|nx
operator|<
literal|0.0
condition|)
name|nx
operator|=
name|nx
operator|*
literal|2.0
expr_stmt|;
if|if
condition|(
name|ny
operator|<
literal|0.0
condition|)
name|ny
operator|=
name|ny
operator|/
literal|2.0
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|+=
name|v
operator|*
name|nx
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|+=
name|v
operator|*
name|ny
expr_stmt|;
block|}
comment|/* if fuse over, store it */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|points
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if ((count_large> 10 || count_nan> 10)&& !getenv("PVM_ARCH"))       fprintf(stderr, "large = %d nan = %d\n", count_large, count_nan);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* args must be non-overlapping */
end_comment

begin_function
DECL|function|mult_matrix (s1,s2,d)
name|void
name|mult_matrix
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|d
parameter_list|)
name|double
name|s1
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|s2
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|d
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
block|{
name|d
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|s1
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|s1
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|s2
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
DECL|function|det_matrix (s)
name|double
name|det_matrix
parameter_list|(
name|s
parameter_list|)
name|double
name|s
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
block|{
return|return
name|s
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|s
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|s
index|[
literal|1
index|]
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
DECL|function|flip_matrix (m,h)
name|void
name|flip_matrix
parameter_list|(
name|m
parameter_list|,
name|h
parameter_list|)
name|double
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|int
name|h
decl_stmt|;
block|{
name|double
name|s
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* flip on horizontal axis */
name|s
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* flip on vertical axis */
name|s
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|s
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|transpose_matrix (m)
name|void
name|transpose_matrix
parameter_list|(
name|m
parameter_list|)
name|double
name|m
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
block|{
name|double
name|t
decl_stmt|;
name|t
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
DECL|function|choose_evector (m,r,v)
name|void
name|choose_evector
parameter_list|(
name|m
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
name|double
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|r
decl_stmt|;
name|double
name|v
index|[
literal|2
index|]
decl_stmt|;
block|{
name|double
name|b
init|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
decl_stmt|;
name|double
name|d
init|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
decl_stmt|;
name|double
name|x
init|=
name|r
operator|-
name|d
decl_stmt|;
if|if
condition|(
name|b
operator|>
name|EPS
condition|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|<
operator|-
name|EPS
condition|)
block|{
name|v
index|[
literal|0
index|]
operator|=
operator|-
name|x
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
operator|-
name|b
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX */
name|v
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* diagonalize the linear part of a 3x2 matrix.  the evalues are returned    in r as either reals on the diagonal, or a complex pair.  the evectors    are returned as a change of coords matrix.  does not handle shearing    transforms.    */
end_comment

begin_function
DECL|function|diagonalize_matrix (m,r,v)
name|void
name|diagonalize_matrix
parameter_list|(
name|m
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
name|double
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|r
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|v
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
block|{
name|double
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|double
name|m00
decl_stmt|,
name|m10
decl_stmt|,
name|m01
decl_stmt|,
name|m11
decl_stmt|;
name|m00
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m10
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m01
operator|=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m11
operator|=
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|b
operator|=
operator|-
name|m00
operator|-
name|m11
expr_stmt|;
name|c
operator|=
operator|(
name|m00
operator|*
name|m11
operator|)
operator|-
operator|(
name|m01
operator|*
name|m10
operator|)
expr_stmt|;
name|d
operator|=
name|b
operator|*
name|b
operator|-
literal|4
operator|*
name|c
expr_stmt|;
comment|/* should use better formula, see numerical recipes */
if|if
condition|(
name|d
operator|>
name|EPS
condition|)
block|{
name|double
name|r0
init|=
operator|(
operator|-
name|b
operator|+
name|sqrt
argument_list|(
name|d
argument_list|)
operator|)
operator|/
literal|2.0
decl_stmt|;
name|double
name|r1
init|=
operator|(
operator|-
name|b
operator|-
name|sqrt
argument_list|(
name|d
argument_list|)
operator|)
operator|/
literal|2.0
decl_stmt|;
name|r
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|r0
expr_stmt|;
name|r
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|r1
expr_stmt|;
name|r
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|r
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|choose_evector
argument_list|(
name|m
argument_list|,
name|r0
argument_list|,
name|v
operator|+
literal|0
argument_list|)
expr_stmt|;
name|choose_evector
argument_list|(
name|m
argument_list|,
name|r1
argument_list|,
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|<
operator|-
name|EPS
condition|)
block|{
name|double
name|uu
init|=
operator|-
name|b
operator|/
literal|2.0
decl_stmt|;
name|double
name|vv
init|=
name|sqrt
argument_list|(
operator|-
name|d
argument_list|)
operator|/
literal|2.0
decl_stmt|;
name|double
name|w1r
decl_stmt|,
name|w1i
decl_stmt|,
name|w2r
decl_stmt|,
name|w2i
decl_stmt|;
name|r
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|uu
expr_stmt|;
name|r
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|vv
expr_stmt|;
name|r
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|vv
expr_stmt|;
name|r
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|uu
expr_stmt|;
if|if
condition|(
name|m01
operator|>
name|EPS
condition|)
block|{
name|w1r
operator|=
name|uu
operator|-
name|m11
expr_stmt|;
name|w1i
operator|=
name|vv
expr_stmt|;
name|w2r
operator|=
name|m01
expr_stmt|;
name|w2i
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m01
operator|<
operator|-
name|EPS
condition|)
block|{
name|w1r
operator|=
name|m11
operator|-
name|uu
expr_stmt|;
name|w1i
operator|=
operator|-
name|vv
expr_stmt|;
name|w2r
operator|=
operator|-
name|m01
expr_stmt|;
name|w2i
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX */
name|w1r
operator|=
literal|0.0
expr_stmt|;
name|w1i
operator|=
literal|1.0
expr_stmt|;
name|w2r
operator|=
literal|1.0
expr_stmt|;
name|w2i
operator|=
literal|0.0
expr_stmt|;
block|}
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|w1i
expr_stmt|;
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|w2i
expr_stmt|;
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|w1r
expr_stmt|;
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|w2r
expr_stmt|;
block|}
else|else
block|{
name|double
name|rr
init|=
operator|-
name|b
operator|/
literal|2.0
decl_stmt|;
name|r
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|rr
expr_stmt|;
name|r
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|rr
expr_stmt|;
name|r
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|r
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1.0
expr_stmt|;
block|}
comment|/* order the values so that the evector matrix has is positively       oriented.  this is so that evectors never have to cross when we       interpolate them. it might mean that the values cross zero when they       wouldn't have otherwise (if they had different signs) but this is the       lesser of two evils */
if|if
condition|(
name|det_matrix
argument_list|(
name|v
argument_list|)
operator|<
literal|0.0
condition|)
block|{
name|flip_matrix
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flip_matrix
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flip_matrix
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|undiagonalize_matrix (r,v,m)
name|void
name|undiagonalize_matrix
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|,
name|m
parameter_list|)
name|double
name|r
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|v
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
block|{
name|double
name|v_inv
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|t1
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|t2
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|t
decl_stmt|;
comment|/* the unfortunate truth is that given we are using row vectors       the evectors should be stacked horizontally, but the complex       interpolation functions only work on rows, so we fix things here */
name|transpose_matrix
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|mult_matrix
argument_list|(
name|r
argument_list|,
name|v
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|t
operator|=
literal|1.0
operator|/
name|det_matrix
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v_inv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|t
operator|*
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|v_inv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|t
operator|*
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|v_inv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|t
operator|*
operator|-
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|v_inv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|t
operator|*
operator|-
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|mult_matrix
argument_list|(
name|v_inv
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* the unforunate truth is that i have no idea why this is needed. sigh. */
name|transpose_matrix
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* switch v back to how it was */
name|transpose_matrix
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|t2
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|t2
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|t2
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|t2
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
DECL|function|interpolate_angle (t,s,v1,v2,v3,tie,cross)
name|void
name|interpolate_angle
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|,
name|tie
parameter_list|,
name|cross
parameter_list|)
name|double
name|t
decl_stmt|,
name|s
decl_stmt|;
name|double
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|tie
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|x
init|=
operator|*
name|v1
decl_stmt|;
name|double
name|y
init|=
operator|*
name|v2
decl_stmt|;
name|double
name|d
decl_stmt|;
specifier|static
name|double
name|lastx
decl_stmt|,
name|lasty
decl_stmt|;
comment|/* take the shorter way around the circle... */
if|if
condition|(
name|x
operator|>
name|y
condition|)
block|{
name|d
operator|=
name|x
operator|-
name|y
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|G_PI
operator|+
name|EPS
operator|||
operator|(
name|d
operator|>
name|G_PI
operator|-
name|EPS
operator|&&
name|tie
operator|)
condition|)
name|y
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|y
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|G_PI
operator|+
name|EPS
operator|||
operator|(
name|d
operator|>
name|G_PI
operator|-
name|EPS
operator|&&
name|tie
operator|)
condition|)
name|x
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
comment|/* unless we are supposed to avoid crossing */
if|if
condition|(
name|cross
condition|)
block|{
if|if
condition|(
name|lastx
operator|>
name|x
condition|)
block|{
if|if
condition|(
name|lasty
operator|<
name|y
condition|)
name|y
operator|-=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lasty
operator|>
name|y
condition|)
name|y
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastx
operator|=
name|x
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
operator|*
name|v3
operator|=
name|s
operator|*
name|x
operator|+
name|t
operator|*
name|y
expr_stmt|;
block|}
end_block

begin_decl_stmt
DECL|function|interpolate_complex (t,s,r1,r2,r3,flip,tie,cross)
name|void
name|interpolate_complex
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r3
argument_list|,
name|flip
argument_list|,
name|tie
argument_list|,
name|cross
argument_list|)
name|double
name|t
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|r1
index|[
literal|2
index|]
decl_stmt|,
name|r2
index|[
literal|2
index|]
decl_stmt|,
name|r3
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flip
decl_stmt|,
name|tie
decl_stmt|,
name|cross
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|c1
index|[
literal|2
index|]
decl_stmt|,
name|c2
index|[
literal|2
index|]
decl_stmt|,
name|c3
index|[
literal|2
index|]
decl_stmt|;
name|double
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|c1
index|[
literal|0
index|]
operator|=
name|r1
index|[
literal|0
index|]
expr_stmt|;
name|c1
index|[
literal|1
index|]
operator|=
name|r1
index|[
literal|1
index|]
expr_stmt|;
name|c2
index|[
literal|0
index|]
operator|=
name|r2
index|[
literal|0
index|]
expr_stmt|;
name|c2
index|[
literal|1
index|]
operator|=
name|r2
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|flip
condition|)
block|{
name|double
name|t
init|=
name|c1
index|[
literal|0
index|]
decl_stmt|;
name|c1
index|[
literal|0
index|]
operator|=
name|c1
index|[
literal|1
index|]
expr_stmt|;
name|c1
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|c2
index|[
literal|0
index|]
expr_stmt|;
name|c2
index|[
literal|0
index|]
operator|=
name|c2
index|[
literal|1
index|]
expr_stmt|;
name|c2
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
comment|/* convert to log space */
name|a1
operator|=
name|atan2
argument_list|(
name|c1
index|[
literal|1
index|]
argument_list|,
name|c1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|a2
operator|=
name|atan2
argument_list|(
name|c2
index|[
literal|1
index|]
argument_list|,
name|c2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|d1
operator|=
literal|0.5
operator|*
name|log
argument_list|(
name|c1
index|[
literal|0
index|]
operator|*
name|c1
index|[
literal|0
index|]
operator|+
name|c1
index|[
literal|1
index|]
operator|*
name|c1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|d2
operator|=
literal|0.5
operator|*
name|log
argument_list|(
name|c2
index|[
literal|0
index|]
operator|*
name|c2
index|[
literal|0
index|]
operator|+
name|c2
index|[
literal|1
index|]
operator|*
name|c2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* interpolate linearly */
name|interpolate_angle
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
operator|&
name|a1
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|a3
argument_list|,
name|tie
argument_list|,
name|cross
argument_list|)
expr_stmt|;
name|d3
operator|=
name|s
operator|*
name|d1
operator|+
name|t
operator|*
name|d2
expr_stmt|;
comment|/* convert back */
name|d3
operator|=
name|exp
argument_list|(
name|d3
argument_list|)
expr_stmt|;
name|c3
index|[
literal|0
index|]
operator|=
name|cos
argument_list|(
name|a3
argument_list|)
operator|*
name|d3
expr_stmt|;
name|c3
index|[
literal|1
index|]
operator|=
name|sin
argument_list|(
name|a3
argument_list|)
operator|*
name|d3
expr_stmt|;
if|if
condition|(
name|flip
condition|)
block|{
name|r3
index|[
literal|1
index|]
operator|=
name|c3
index|[
literal|0
index|]
expr_stmt|;
name|r3
index|[
literal|0
index|]
operator|=
name|c3
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|r3
index|[
literal|0
index|]
operator|=
name|c3
index|[
literal|0
index|]
expr_stmt|;
name|r3
index|[
literal|1
index|]
operator|=
name|c3
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
DECL|function|interpolate_matrix (t,m1,m2,m3)
name|void
name|interpolate_matrix
argument_list|(
name|t
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|)
name|double
name|m1
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|m2
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|m3
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|s
init|=
literal|1.0
operator|-
name|t
decl_stmt|;
if|#
directive|if
literal|0
block|double r1[2][2], r2[2][2], r3[2][2];    double v1[2][2], v2[2][2], v3[2][2];    diagonalize_matrix(m1, r1, v1);    diagonalize_matrix(m2, r2, v2);
comment|/* handle the evectors */
block|interpolate_complex(t, s, v1 + 0, v2 + 0, v3 + 0, 0, 0, 0);    interpolate_complex(t, s, v1 + 1, v2 + 1, v3 + 1, 0, 0, 1);
comment|/* handle the evalues */
block|interpolate_complex(t, s, r1 + 0, r2 + 0, r3 + 0, 0, 0, 0);    interpolate_complex(t, s, r1 + 1, r2 + 1, r3 + 1, 1, 1, 0);     undiagonalize_matrix(r3, v3, m3);
endif|#
directive|endif
name|interpolate_complex
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|m1
operator|+
literal|0
argument_list|,
name|m2
operator|+
literal|0
argument_list|,
name|m3
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|interpolate_complex
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|m1
operator|+
literal|1
argument_list|,
name|m2
operator|+
literal|1
argument_list|,
name|m3
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* handle the translation part of the xform linearly */
name|m3
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|s
operator|*
name|m1
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|t
operator|*
name|m2
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m3
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|s
operator|*
name|m1
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
name|t
operator|*
name|m2
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_define
DECL|macro|INTERP (x)
define|#
directive|define
name|INTERP
parameter_list|(
name|x
parameter_list|)
value|result->x = c0 * cps[i1].x + c1 * cps[i2].x
end_define

begin_comment
comment|/*  * create a control point that interpolates between the control points  * passed in CPS.  for now just do linear.  in the future, add control  * point types and other things to the cps.  CPS must be sorted by time.  */
end_comment

begin_function
DECL|function|interpolate (cps,ncps,time,result)
name|void
name|interpolate
parameter_list|(
name|cps
parameter_list|,
name|ncps
parameter_list|,
name|time
parameter_list|,
name|result
parameter_list|)
name|control_point
name|cps
index|[]
decl_stmt|;
name|int
name|ncps
decl_stmt|;
name|double
name|time
decl_stmt|;
name|control_point
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|double
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
literal|1
operator|==
name|ncps
condition|)
block|{
operator|*
name|result
operator|=
name|cps
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cps
index|[
literal|0
index|]
operator|.
name|time
operator|>=
name|time
condition|)
block|{
name|i1
operator|=
literal|0
expr_stmt|;
name|i2
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cps
index|[
name|ncps
operator|-
literal|1
index|]
operator|.
name|time
operator|<=
name|time
condition|)
block|{
name|i1
operator|=
name|ncps
operator|-
literal|2
expr_stmt|;
name|i2
operator|=
name|ncps
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|<
name|time
condition|)
name|i1
operator|++
expr_stmt|;
name|i1
operator|--
expr_stmt|;
name|i2
operator|=
name|i1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|time
operator|-
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|>
operator|-
literal|1e-7
operator|&&
name|time
operator|-
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|<
literal|1e-7
condition|)
block|{
operator|*
name|result
operator|=
name|cps
index|[
name|i1
index|]
expr_stmt|;
return|return;
block|}
block|}
name|c0
operator|=
operator|(
name|cps
index|[
name|i2
index|]
operator|.
name|time
operator|-
name|time
operator|)
operator|/
operator|(
name|cps
index|[
name|i2
index|]
operator|.
name|time
operator|-
name|cps
index|[
name|i1
index|]
operator|.
name|time
operator|)
expr_stmt|;
name|c1
operator|=
literal|1.0
operator|-
name|c0
expr_stmt|;
name|result
operator|->
name|time
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|cps
index|[
name|i1
index|]
operator|.
name|cmap_inter
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|double
name|spread
init|=
literal|0.15
decl_stmt|;
name|double
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|c
init|=
literal|2
operator|*
name|G_PI
operator|*
name|i
operator|/
literal|256.0
decl_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|c
operator|*
name|cps
index|[
name|i1
index|]
operator|.
name|cmap_inter
argument_list|)
operator|+
literal|4.0
operator|*
name|c1
operator|-
literal|2.0
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|spread
condition|)
name|c
operator|=
name|spread
expr_stmt|;
if|if
condition|(
name|c
operator|<
operator|-
name|spread
condition|)
name|c
operator|=
operator|-
name|spread
expr_stmt|;
name|d1
operator|=
operator|(
name|c
operator|+
name|spread
operator|)
operator|*
literal|0.5
operator|/
name|spread
expr_stmt|;
name|d0
operator|=
literal|1.0
operator|-
name|d1
expr_stmt|;
name|e0
operator|=
operator|(
name|d0
operator|<
literal|0.5
operator|)
condition|?
operator|(
name|d0
operator|*
literal|2
operator|)
else|:
operator|(
name|d1
operator|*
literal|2
operator|)
expr_stmt|;
name|e1
operator|=
literal|1.0
operator|-
name|e0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|->
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|d0
operator|*
name|cps
index|[
name|i1
index|]
operator|.
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|d1
operator|*
name|cps
index|[
name|i2
index|]
operator|.
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
DECL|macro|bright_peak
define|#
directive|define
name|bright_peak
value|2.0
if|#
directive|if
literal|0
block|if (d0< 0.5) 	   result->cmap[i][j] *= 1.0 + bright_peak * d0; 	 else 	   result->cmap[i][j] *= 1.0 + bright_peak * d1;
else|#
directive|else
name|result
operator|->
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|e1
operator|*
name|result
operator|->
name|cmap
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|e0
operator|*
literal|1.0
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|double
name|t
index|[
literal|3
index|]
decl_stmt|,
name|s
index|[
literal|3
index|]
decl_stmt|;
name|rgb2hsv
argument_list|(
name|cps
index|[
name|i1
index|]
operator|.
name|cmap
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rgb2hsv
argument_list|(
name|cps
index|[
name|i2
index|]
operator|.
name|cmap
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|t
index|[
name|j
index|]
operator|=
name|c0
operator|*
name|s
index|[
name|j
index|]
operator|+
name|c1
operator|*
name|t
index|[
name|j
index|]
expr_stmt|;
name|hsv2rgb
argument_list|(
name|t
argument_list|,
name|result
operator|->
name|cmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|->
name|cmap_index
operator|=
operator|-
literal|1
expr_stmt|;
name|INTERP
argument_list|(
name|brightness
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|contrast
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|gamma
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|spatial_oversample
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|center
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|center
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|pixels_per_unit
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|spatial_filter_radius
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|sample_density
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|zoom
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|nbatches
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|white_level
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|INTERP
argument_list|(
name|pulse
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|INTERP
argument_list|(
name|wiggle
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|double
name|r
decl_stmt|;
name|INTERP
argument_list|(
name|xform
index|[
name|i
index|]
operator|.
name|density
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|>
literal|0
condition|)
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|1.0
expr_stmt|;
name|INTERP
argument_list|(
name|xform
index|[
name|i
index|]
operator|.
name|color
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|INTERP
argument_list|(
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|t
operator|+=
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
name|t
operator|=
literal|1.0
operator|/
name|t
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|*=
name|t
expr_stmt|;
name|interpolate_matrix
argument_list|(
name|c1
argument_list|,
name|cps
index|[
name|i1
index|]
operator|.
name|xform
index|[
name|i
index|]
operator|.
name|c
argument_list|,
name|cps
index|[
name|i2
index|]
operator|.
name|xform
index|[
name|i
index|]
operator|.
name|c
argument_list|,
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|double
name|rh_time
init|=
name|time
operator|*
literal|2
operator|*
name|G_PI
operator|/
operator|(
literal|60.0
operator|*
literal|30.0
operator|)
decl_stmt|;
comment|/* apply pulse factor. */
name|r
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|r
operator|+=
name|result
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|0
index|]
operator|*
name|sin
argument_list|(
name|result
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|1
index|]
operator|*
name|rh_time
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|0
index|]
operator|*=
name|r
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|1
index|]
operator|*=
name|r
expr_stmt|;
block|}
comment|/* apply wiggle factor */
name|r
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|double
name|tt
init|=
name|result
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|1
index|]
operator|*
name|rh_time
decl_stmt|;
name|double
name|m
init|=
name|result
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|0
index|]
decl_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+=
name|m
operator|*
name|cos
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+=
name|m
operator|*
operator|-
name|sin
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+=
name|m
operator|*
name|sin
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|result
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+=
name|m
operator|*
name|cos
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* for i */
block|}
end_function

begin_comment
comment|/*  * split a string passed in ss into tokens on whitespace.  * # comments to end of line.  ; terminates the record  */
end_comment

begin_function
DECL|function|tokenize (ss,argv,argc)
name|void
name|tokenize
parameter_list|(
name|ss
parameter_list|,
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|ss
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|int
modifier|*
name|argc
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|ss
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|state
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|';'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|s
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
literal|'#'
operator|==
name|c
condition|)
name|state
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|g_ascii_isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
case|case
literal|1
case|:
if|if
condition|(
name|g_ascii_isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
case|case
literal|2
case|:
if|if
condition|(
literal|'\n'
operator|==
name|c
condition|)
name|state
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|*
name|ss
operator|=
name|s
operator|+
literal|1
expr_stmt|;
operator|*
name|argc
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
DECL|function|compare_xforms (a,b)
name|int
name|compare_xforms
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|xform
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|double
name|aa
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|bb
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|ad
decl_stmt|,
name|bd
decl_stmt|;
name|aa
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|aa
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|aa
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|aa
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|a
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bb
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|bb
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bb
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|bb
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|b
operator|->
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|ad
operator|=
name|det_matrix
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|bd
operator|=
name|det_matrix
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|<
name|bd
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ad
operator|>
name|bd
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_define
DECL|macro|MAXARGS
define|#
directive|define
name|MAXARGS
value|1000
end_define

begin_define
DECL|macro|streql (x,y)
define|#
directive|define
name|streql
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(!strcmp(x,y))
end_define

begin_comment
comment|/*  * given a pointer to a string SS, fill fields of a control point CP.  * return a pointer to the first unused char in SS.  totally barfucious,  * must integrate with tcl soon...  */
end_comment

begin_function
DECL|function|parse_control_point (ss,cp)
name|void
name|parse_control_point
parameter_list|(
name|ss
parameter_list|,
name|cp
parameter_list|)
name|char
modifier|*
modifier|*
name|ss
decl_stmt|;
name|control_point
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|set_cm
init|=
literal|0
decl_stmt|,
name|set_image_size
init|=
literal|0
decl_stmt|,
name|set_nbatches
init|=
literal|0
decl_stmt|,
name|set_white_level
init|=
literal|0
decl_stmt|,
name|set_cmap_inter
init|=
literal|0
decl_stmt|;
name|int
name|set_spatial_oversample
init|=
literal|0
decl_stmt|;
name|double
modifier|*
name|slot
init|=
name|NULL
decl_stmt|,
name|xf
decl_stmt|,
name|cm
decl_stmt|,
name|t
decl_stmt|,
name|nbatches
decl_stmt|,
name|white_level
decl_stmt|,
name|spatial_oversample
decl_stmt|,
name|cmap_inter
decl_stmt|;
name|double
name|image_size
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|color
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|pulse
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
literal|60.0
expr_stmt|;
name|cp
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|->
name|wiggle
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
literal|60.0
expr_stmt|;
block|}
name|tokenize
argument_list|(
name|ss
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streql
argument_list|(
literal|"xform"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|xf
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"time"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|time
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"brightness"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|brightness
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"contrast"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|contrast
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"gamma"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|gamma
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"zoom"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|zoom
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"image_size"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
name|image_size
expr_stmt|;
name|set_image_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"center"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
name|cp
operator|->
name|center
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"pulse"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|(
name|double
operator|*
operator|)
name|cp
operator|->
name|pulse
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"wiggle"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|(
name|double
operator|*
operator|)
name|cp
operator|->
name|wiggle
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"pixels_per_unit"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|pixels_per_unit
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"spatial_filter_radius"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|spatial_filter_radius
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"sample_density"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|sample_density
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"nbatches"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|nbatches
expr_stmt|;
name|set_nbatches
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"white_level"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|white_level
expr_stmt|;
name|set_white_level
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"spatial_oversample"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|spatial_oversample
expr_stmt|;
name|set_spatial_oversample
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"cmap"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|cm
expr_stmt|;
name|set_cm
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"density"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|density
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"color"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
operator|&
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|color
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"coefs"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|c
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|density
operator|=
literal|1.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"var"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|slot
operator|=
name|cp
operator|->
name|xform
index|[
operator|(
name|int
operator|)
name|xf
index|]
operator|.
name|var
expr_stmt|;
elseif|else
if|if
condition|(
name|streql
argument_list|(
literal|"cmap_inter"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
operator|&
name|cmap_inter
expr_stmt|;
name|set_cmap_inter
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|slot
operator|++
operator|=
name|atof
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_cm
condition|)
block|{
name|cp
operator|->
name|cmap_index
operator|=
operator|(
name|int
operator|)
name|cm
expr_stmt|;
name|get_cmap
argument_list|(
name|cp
operator|->
name|cmap_index
argument_list|,
name|cp
operator|->
name|cmap
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_image_size
condition|)
block|{
name|cp
operator|->
name|width
operator|=
operator|(
name|int
operator|)
name|image_size
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|height
operator|=
operator|(
name|int
operator|)
name|image_size
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|set_cmap_inter
condition|)
name|cp
operator|->
name|cmap_inter
operator|=
operator|(
name|int
operator|)
name|cmap_inter
expr_stmt|;
if|if
condition|(
name|set_nbatches
condition|)
name|cp
operator|->
name|nbatches
operator|=
operator|(
name|int
operator|)
name|nbatches
expr_stmt|;
if|if
condition|(
name|set_spatial_oversample
condition|)
name|cp
operator|->
name|spatial_oversample
operator|=
operator|(
name|int
operator|)
name|spatial_oversample
expr_stmt|;
if|if
condition|(
name|set_white_level
condition|)
name|cp
operator|->
name|white_level
operator|=
operator|(
name|int
operator|)
name|white_level
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|t
operator|+=
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
name|t
operator|=
literal|1.0
operator|/
name|t
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|*=
name|t
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|->
name|xform
argument_list|,
name|NXFORMS
argument_list|,
sizeof|sizeof
argument_list|(
name|xform
argument_list|)
argument_list|,
name|compare_xforms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|print_control_point (f,cp,quote)
name|void
name|print_control_point
parameter_list|(
name|f
parameter_list|,
name|cp
parameter_list|,
name|quote
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|control_point
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|quote
condition|?
literal|"# "
else|:
literal|""
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%stime %g\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|cp
operator|->
name|cmap_index
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%scmap %d\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|cmap_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%simage_size %d %d center %g %g pixels_per_unit %g\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|width
argument_list|,
name|cp
operator|->
name|height
argument_list|,
name|cp
operator|->
name|center
index|[
literal|0
index|]
argument_list|,
name|cp
operator|->
name|center
index|[
literal|1
index|]
argument_list|,
name|cp
operator|->
name|pixels_per_unit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sspatial_oversample %d spatial_filter_radius %g"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|spatial_oversample
argument_list|,
name|cp
operator|->
name|spatial_filter_radius
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" sample_density %g\n"
argument_list|,
name|cp
operator|->
name|sample_density
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%snbatches %d white_level %d\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|nbatches
argument_list|,
name|cp
operator|->
name|white_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sbrightness %g gamma %g cmap_inter %d\n"
argument_list|,
name|q
argument_list|,
name|cp
operator|->
name|brightness
argument_list|,
name|cp
operator|->
name|gamma
argument_list|,
name|cp
operator|->
name|cmap_inter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|>
literal|0.0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sxform %d density %g color %g\n"
argument_list|,
name|q
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|color
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%svar"
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %g"
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n%scoefs"
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %g %g"
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s;\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns a uniform variable from 0 to 1 */
end_comment

begin_function
DECL|function|random_uniform01 ()
name|double
name|random_uniform01
parameter_list|()
block|{
return|return
name|g_random_double
argument_list|()
return|;
block|}
end_function

begin_function
DECL|function|random_uniform11 ()
name|double
name|random_uniform11
parameter_list|()
block|{
return|return
name|g_random_double_range
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* returns a mean 0 variance 1 random variable    see numerical recipies p 217 */
end_comment

begin_function
DECL|function|random_gaussian ()
name|double
name|random_gaussian
parameter_list|()
block|{
specifier|static
name|int
name|iset
init|=
literal|0
decl_stmt|;
specifier|static
name|double
name|gset
decl_stmt|;
name|double
name|fac
decl_stmt|,
name|r
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|iset
condition|)
block|{
do|do
block|{
name|v1
operator|=
name|random_uniform11
argument_list|()
expr_stmt|;
name|v2
operator|=
name|random_uniform11
argument_list|()
expr_stmt|;
name|r
operator|=
name|v1
operator|*
name|v1
operator|+
name|v2
operator|*
name|v2
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|>=
literal|1.0
operator|||
name|r
operator|==
literal|0.0
condition|)
do|;
name|fac
operator|=
name|sqrt
argument_list|(
operator|-
literal|2.0
operator|*
name|log
argument_list|(
name|r
argument_list|)
operator|/
name|r
argument_list|)
expr_stmt|;
name|gset
operator|=
name|v1
operator|*
name|fac
expr_stmt|;
name|iset
operator|=
literal|1
expr_stmt|;
return|return
name|v2
operator|*
name|fac
return|;
block|}
name|iset
operator|=
literal|0
expr_stmt|;
return|return
name|gset
return|;
block|}
end_function

begin_function
name|void
DECL|function|copy_variation (control_point * cp0,control_point * cp1)
name|copy_variation
parameter_list|(
name|control_point
modifier|*
name|cp0
parameter_list|,
name|control_point
modifier|*
name|cp1
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp0
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|=
name|cp1
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_define
DECL|macro|random_distrib (v)
define|#
directive|define
name|random_distrib
parameter_list|(
name|v
parameter_list|)
value|((v)[g_random_int_range (0, vlen(v))])
end_define

begin_function
DECL|function|random_control_point (cp,ivar)
name|void
name|random_control_point
parameter_list|(
name|cp
parameter_list|,
name|ivar
parameter_list|)
name|control_point
modifier|*
name|cp
decl_stmt|;
name|int
name|ivar
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nxforms
decl_stmt|,
name|var
decl_stmt|;
specifier|static
name|int
name|xform_distrib
index|[]
init|=
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
specifier|static
name|int
name|var_distrib
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
specifier|static
name|int
name|mixed_var_distrib
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
name|get_cmap
argument_list|(
name|cmap_random
argument_list|,
name|cp
operator|->
name|cmap
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|cp
operator|->
name|time
operator|=
literal|0.0
expr_stmt|;
name|nxforms
operator|=
name|random_distrib
argument_list|(
name|xform_distrib
argument_list|)
expr_stmt|;
name|var
operator|=
operator|(
literal|0
operator|>
name|ivar
operator|)
condition|?
name|random_distrib
argument_list|(
name|var_distrib
argument_list|)
else|:
name|ivar
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nxforms
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|1.0
operator|/
name|nxforms
expr_stmt|;
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|color
operator|=
name|i
operator|==
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|random_uniform11
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|var
operator|>=
literal|0
condition|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|var
index|]
operator|=
literal|1.0
expr_stmt|;
else|else
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|random_distrib
argument_list|(
name|mixed_var_distrib
argument_list|)
index|]
operator|=
literal|1.0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|density
operator|=
literal|0.0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find a 2d bounding box that does not enclose eps of the fractal density  * in each compass direction.  works by binary search.  * this is stupid, it shouldjust use the find nth smallest algorithm.  */
end_comment

begin_function
DECL|function|estimate_bounding_box (cp,eps,bmin,bmax)
name|void
name|estimate_bounding_box
parameter_list|(
name|cp
parameter_list|,
name|eps
parameter_list|,
name|bmin
parameter_list|,
name|bmax
parameter_list|)
name|control_point
modifier|*
name|cp
decl_stmt|;
name|double
name|eps
decl_stmt|;
name|double
modifier|*
name|bmin
decl_stmt|;
name|double
modifier|*
name|bmax
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|batch
init|=
operator|(
name|eps
operator|==
literal|0.0
operator|)
condition|?
literal|10000
else|:
literal|10.0
operator|/
name|eps
decl_stmt|;
name|int
name|low_target
init|=
name|batch
operator|*
name|eps
decl_stmt|;
name|int
name|high_target
init|=
name|batch
operator|-
name|low_target
decl_stmt|;
name|point
name|min
decl_stmt|,
name|max
decl_stmt|,
name|delta
decl_stmt|;
name|point
modifier|*
name|points
init|=
operator|(
name|point
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|point
argument_list|)
operator|*
name|batch
argument_list|)
decl_stmt|;
name|iterate
argument_list|(
name|cp
argument_list|,
name|batch
argument_list|,
literal|20
argument_list|,
name|points
argument_list|)
expr_stmt|;
name|min
index|[
literal|0
index|]
operator|=
name|min
index|[
literal|1
index|]
operator|=
literal|1e10
expr_stmt|;
name|max
index|[
literal|0
index|]
operator|=
name|max
index|[
literal|1
index|]
operator|=
operator|-
literal|1e10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|batch
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
operator|<
name|min
index|[
literal|0
index|]
condition|)
name|min
index|[
literal|0
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
operator|<
name|min
index|[
literal|1
index|]
condition|)
name|min
index|[
literal|1
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
operator|>
name|max
index|[
literal|0
index|]
condition|)
name|max
index|[
literal|0
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
operator|>
name|max
index|[
literal|1
index|]
condition|)
name|max
index|[
literal|1
index|]
operator|=
name|points
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|low_target
operator|==
literal|0
condition|)
block|{
name|bmin
index|[
literal|0
index|]
operator|=
name|min
index|[
literal|0
index|]
expr_stmt|;
name|bmin
index|[
literal|1
index|]
operator|=
name|min
index|[
literal|1
index|]
expr_stmt|;
name|bmax
index|[
literal|0
index|]
operator|=
name|max
index|[
literal|0
index|]
expr_stmt|;
name|bmax
index|[
literal|1
index|]
operator|=
name|max
index|[
literal|1
index|]
expr_stmt|;
return|return;
block|}
name|delta
index|[
literal|0
index|]
operator|=
operator|(
name|max
index|[
literal|0
index|]
operator|-
name|min
index|[
literal|0
index|]
operator|)
operator|*
literal|0.25
expr_stmt|;
name|delta
index|[
literal|1
index|]
operator|=
operator|(
name|max
index|[
literal|1
index|]
operator|-
name|min
index|[
literal|1
index|]
operator|)
operator|*
literal|0.25
expr_stmt|;
name|bmax
index|[
literal|0
index|]
operator|=
name|bmin
index|[
literal|0
index|]
operator|=
name|min
index|[
literal|0
index|]
operator|+
literal|2.0
operator|*
name|delta
index|[
literal|0
index|]
expr_stmt|;
name|bmax
index|[
literal|1
index|]
operator|=
name|bmin
index|[
literal|1
index|]
operator|=
name|min
index|[
literal|1
index|]
operator|+
literal|2.0
operator|*
name|delta
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|,
name|s
decl_stmt|,
name|e
decl_stmt|,
name|w
decl_stmt|;
name|n
operator|=
name|s
operator|=
name|e
operator|=
name|w
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|batch
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|0
index|]
operator|<
name|bmin
index|[
literal|0
index|]
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|0
index|]
operator|>
name|bmax
index|[
literal|0
index|]
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|1
index|]
operator|<
name|bmin
index|[
literal|1
index|]
condition|)
name|w
operator|++
expr_stmt|;
if|if
condition|(
name|points
index|[
name|j
index|]
index|[
literal|1
index|]
operator|>
name|bmax
index|[
literal|1
index|]
condition|)
name|e
operator|++
expr_stmt|;
block|}
name|bmin
index|[
literal|0
index|]
operator|+=
operator|(
name|n
operator|<
name|low_target
operator|)
condition|?
name|delta
index|[
literal|0
index|]
else|:
operator|-
name|delta
index|[
literal|0
index|]
expr_stmt|;
name|bmax
index|[
literal|0
index|]
operator|+=
operator|(
name|s
operator|<
name|high_target
operator|)
condition|?
name|delta
index|[
literal|0
index|]
else|:
operator|-
name|delta
index|[
literal|0
index|]
expr_stmt|;
name|bmin
index|[
literal|1
index|]
operator|+=
operator|(
name|w
operator|<
name|low_target
operator|)
condition|?
name|delta
index|[
literal|1
index|]
else|:
operator|-
name|delta
index|[
literal|1
index|]
expr_stmt|;
name|bmax
index|[
literal|1
index|]
operator|+=
operator|(
name|e
operator|<
name|high_target
operator|)
condition|?
name|delta
index|[
literal|1
index|]
else|:
operator|-
name|delta
index|[
literal|1
index|]
expr_stmt|;
name|delta
index|[
literal|0
index|]
operator|=
name|delta
index|[
literal|0
index|]
operator|/
literal|2.0
expr_stmt|;
name|delta
index|[
literal|1
index|]
operator|=
name|delta
index|[
literal|1
index|]
operator|/
literal|2.0
expr_stmt|;
comment|/*       fprintf(stderr, "%g %g %g %g\n", bmin[0], bmin[1], bmax[0], bmax[1]);       */
block|}
comment|/*    fprintf(stderr, "%g %g %g %g\n", min[0], min[1], max[0], max[1]);    */
block|}
end_function

begin_comment
comment|/* use hill climberer to find smooth ordering of control points    this is untested */
end_comment

begin_decl_stmt
DECL|function|sort_control_points (cps,ncps,metric)
name|void
name|sort_control_points
argument_list|(
name|cps
argument_list|,
name|ncps
argument_list|,
name|metric
argument_list|)
name|control_point
modifier|*
name|cps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncps
decl_stmt|;
end_decl_stmt

begin_function_decl
name|double
function_decl|(
modifier|*
name|metric
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|niter
init|=
name|ncps
operator|*
literal|1000
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|;
name|double
name|same
decl_stmt|,
name|swap
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|niter
condition|;
name|i
operator|++
control|)
block|{
comment|/* consider switching points with indexes n and m */
name|n
operator|=
name|g_random_int_range
argument_list|(
literal|0
argument_list|,
name|ncps
argument_list|)
expr_stmt|;
name|m
operator|=
name|g_random_int_range
argument_list|(
literal|0
argument_list|,
name|ncps
argument_list|)
expr_stmt|;
name|same
operator|=
operator|(
name|metric
argument_list|(
name|cps
operator|+
name|n
argument_list|,
name|cps
operator|+
operator|(
name|n
operator|-
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|+
name|metric
argument_list|(
name|cps
operator|+
name|n
argument_list|,
name|cps
operator|+
operator|(
name|n
operator|+
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|+
name|metric
argument_list|(
name|cps
operator|+
name|m
argument_list|,
name|cps
operator|+
operator|(
name|m
operator|-
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|+
name|metric
argument_list|(
name|cps
operator|+
name|m
argument_list|,
name|cps
operator|+
operator|(
name|m
operator|+
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|)
expr_stmt|;
name|swap
operator|=
operator|(
name|metric
argument_list|(
name|cps
operator|+
name|n
argument_list|,
name|cps
operator|+
operator|(
name|m
operator|-
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|+
name|metric
argument_list|(
name|cps
operator|+
name|n
argument_list|,
name|cps
operator|+
operator|(
name|m
operator|+
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|+
name|metric
argument_list|(
name|cps
operator|+
name|m
argument_list|,
name|cps
operator|+
operator|(
name|n
operator|-
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|+
name|metric
argument_list|(
name|cps
operator|+
name|m
argument_list|,
name|cps
operator|+
operator|(
name|n
operator|+
literal|1
operator|)
operator|%
name|ncps
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|swap
operator|<
name|same
condition|)
block|{
name|control_point
name|t
decl_stmt|;
name|t
operator|=
name|cps
index|[
name|n
index|]
expr_stmt|;
name|cps
index|[
name|n
index|]
operator|=
name|cps
index|[
name|m
index|]
expr_stmt|;
name|cps
index|[
name|m
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* this has serious flaws in it */
end_comment

begin_function
DECL|function|standard_metric (cp1,cp2)
name|double
name|standard_metric
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
name|control_point
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|double
name|t
decl_stmt|;
name|double
name|dist
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXFORMS
condition|;
name|i
operator|++
control|)
block|{
name|double
name|var_dist
init|=
literal|0.0
decl_stmt|;
name|double
name|coef_dist
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVARS
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
name|cp1
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
operator|-
name|cp2
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|var
index|[
name|j
index|]
expr_stmt|;
name|var_dist
operator|+=
name|t
operator|*
name|t
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
name|t
operator|=
name|cp1
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
name|k
index|]
operator|-
name|cp2
operator|->
name|xform
index|[
name|i
index|]
operator|.
name|c
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
name|coef_dist
operator|+=
name|t
operator|*
name|t
expr_stmt|;
block|}
comment|/* weight them equally for now. */
name|dist
operator|+=
name|var_dist
operator|+
name|coef_dist
expr_stmt|;
block|}
return|return
name|dist
return|;
block|}
end_block

begin_function
name|void
DECL|function|stat_matrix (f,m)
name|stat_matrix
parameter_list|(
name|f
parameter_list|,
name|m
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|double
name|m
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
block|{
name|double
name|r
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|v
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|double
name|a
decl_stmt|;
name|diagonalize_matrix
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"entries = % 10f % 10f % 10f % 10f\n"
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"evalues  = % 10f % 10f % 10f % 10f\n"
argument_list|,
name|r
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|r
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|r
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|r
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"evectors = % 10f % 10f % 10f % 10f\n"
argument_list|,
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|)
operator|/
name|sqrt
argument_list|(
operator|(
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|*
operator|(
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|v
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"theta = %g det = %g\n"
argument_list|,
name|a
argument_list|,
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
unit|main() {
if|#
directive|if
literal|0
end_if

begin_endif
unit|double m1[3][2] = {-0.633344, -0.269064, 0.0676171, 0.590923, 0, 0};    double m2[3][2] = {-0.844863, 0.0270297, -0.905294, 0.413218, 0, 0};
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|double m1[3][2] = {-0.347001, -0.15219, 0.927161, 0.908305, 0, 0};    double m2[3][2] = {-0.577884, 0.653803, 0.664982, -0.734136, 0, 0};
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|double m1[3][2] = {1, 0, 0, 1, 0, 0};    double m2[3][2] = {0, -1, 1, 0, 0, 0};
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_endif
unit|double m1[3][2] = {1, 0, 0, 1, 0, 0};    double m2[3][2] = {-1, 0, 0, -1, 0, 0};
endif|#
directive|endif
end_endif

begin_comment
unit|double m3[3][2];    double t;    int i = 0;     for (t = 0.0; t<= 1.0; t += 1.0/15.0) {       int x, y;       fprintf(stderr, "%g--\n", t);       interpolate_matrix(t, m1, m2, m3);
comment|/*       stat_matrix(stderr, m3); */
end_comment

begin_endif
unit|x = (i % 4) * 100 + 100;       y = (i / 4) * 100 + 100;       printf("newpath ");       printf("%d %d %d %d %d arc ", x, y, 30, 0, 360);       printf("%d %d moveto ", x, y);       printf("%g %g rlineto ", m3[0][0] * 30, m3[0][1] * 30);       printf("%d %d moveto ", x, y);       printf("%g %g rlineto ", m3[1][0] * 30, m3[1][1] * 30);       printf("stroke \n");       printf("newpath ");       printf("%g %g %d %d %d arc ", x + m3[0][0] * 30, y + m3[0][1] * 30, 3, 0, 360);       printf("stroke \n");       i++;    } }
endif|#
directive|endif
end_endif

end_unit

