begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WinSnap Win32 Window Capture Plug-in  * Copyright (C) 1999 Craig Setera  * Craig Setera<setera@home.com>  * 07/14/1999  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  *  * Based on (at least) the following plug-ins:  * Screenshot  * TWAIN  *  * Any suggestions, bug-reports or patches are welcome.  *  * This plug-in provides Win32 users with screen snapshot ability.  *  */
end_comment

begin_comment
comment|/*  * Revision history  *  *  (07/13/99)  v0.5   First working version (internal)  *  (07/14/99)  v0.55  Switched to g_error, g_message, etc.  *  (07/16/99)  v0.60  Better timing, comment cleanup  *  (07/16/99)  v0.70  Switched name  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|"resource.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*  * Plug-in Definitions  */
end_comment

begin_define
DECL|macro|PLUG_IN_NAME
define|#
directive|define
name|PLUG_IN_NAME
value|"plug_in_winsnap"
end_define

begin_define
DECL|macro|PLUG_IN_PROC
define|#
directive|define
name|PLUG_IN_PROC
value|"plug-in-winsnap"
end_define

begin_define
DECL|macro|PLUG_IN_PRINT_NAME
define|#
directive|define
name|PLUG_IN_PRINT_NAME
value|"WinSnap"
end_define

begin_define
DECL|macro|PLUG_IN_HELP
define|#
directive|define
name|PLUG_IN_HELP
value|"This plug-in will capture an image of a Win32 window or desktop"
end_define

begin_define
DECL|macro|PLUG_IN_AUTHOR
define|#
directive|define
name|PLUG_IN_AUTHOR
value|"Craig Setera (setera@home.com)"
end_define

begin_define
DECL|macro|PLUG_IN_COPYRIGHT
define|#
directive|define
name|PLUG_IN_COPYRIGHT
value|"Craig Setera"
end_define

begin_define
DECL|macro|PLUG_IN_VERSION
define|#
directive|define
name|PLUG_IN_VERSION
value|"v0.70 (07/16/1999)"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"win-snap"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-win-snap"
end_define

begin_comment
comment|/*  * Application definitions  */
end_comment

begin_define
DECL|macro|SELECT_FRAME
define|#
directive|define
name|SELECT_FRAME
value|0
end_define

begin_define
DECL|macro|SELECT_CLIENT
define|#
directive|define
name|SELECT_CLIENT
value|1
end_define

begin_define
DECL|macro|SELECT_WINDOW
define|#
directive|define
name|SELECT_WINDOW
value|2
end_define

begin_define
DECL|macro|SHOW_WINDOW
define|#
directive|define
name|SHOW_WINDOW
value|FALSE
end_define

begin_define
DECL|macro|APP_NAME
define|#
directive|define
name|APP_NAME
value|PLUG_IN_NAME
end_define

begin_define
DECL|macro|WM_DOCAPTURE
define|#
directive|define
name|WM_DOCAPTURE
value|(WM_USER + 100)
end_define

begin_comment
comment|/* File variables */
end_comment

begin_decl_stmt
DECL|variable|captureType
specifier|static
name|int
name|captureType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|buffer
specifier|static
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|capBytes
specifier|static
name|guchar
modifier|*
name|capBytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|mainHwnd
specifier|static
name|HWND
name|mainHwnd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|hInst
specifier|static
name|HINSTANCE
name|hInst
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|selectCursor
specifier|static
name|HCURSOR
name|selectCursor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|iconInfo
specifier|static
name|ICONINFO
name|iconInfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sendBMPToGimp
parameter_list|(
name|HBITMAP
name|hBMP
parameter_list|,
name|HDC
name|hDC
parameter_list|,
name|RECT
name|rect
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOL
name|CALLBACK
name|dialogProc
parameter_list|(
name|HWND
parameter_list|,
name|UINT
parameter_list|,
name|WPARAM
parameter_list|,
name|LPARAM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LRESULT
name|CALLBACK
name|WndProc
parameter_list|(
name|HWND
parameter_list|,
name|UINT
parameter_list|,
name|WPARAM
parameter_list|,
name|LPARAM
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Data structure holding data between runs */
end_comment

begin_typedef
DECL|struct|__anon2ae8507b0108
typedef|typedef
struct|struct
block|{
DECL|member|root
name|gint
name|root
decl_stmt|;
DECL|member|delay
name|guint
name|delay
decl_stmt|;
DECL|member|decor
name|gint
name|decor
decl_stmt|;
DECL|typedef|WinSnapValues
block|}
name|WinSnapValues
typedef|;
end_typedef

begin_comment
comment|/* Default WinSnap values */
end_comment

begin_decl_stmt
DECL|variable|winsnapvals
specifier|static
name|WinSnapValues
name|winsnapvals
init|=
block|{
name|FALSE
block|,
literal|0
block|,
name|TRUE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dialog information */
end_comment

begin_typedef
DECL|struct|__anon2ae8507b0208
typedef|typedef
struct|struct
block|{
ifdef|#
directive|ifdef
name|CAN_SET_DECOR
DECL|member|decor_button
name|GtkWidget
modifier|*
name|decor_button
decl_stmt|;
endif|#
directive|endif
DECL|member|single_button
name|GtkWidget
modifier|*
name|single_button
decl_stmt|;
DECL|member|root_button
name|GtkWidget
modifier|*
name|root_button
decl_stmt|;
DECL|member|delay_spinner
name|GtkWidget
modifier|*
name|delay_spinner
decl_stmt|;
DECL|typedef|WinSnapInterface
block|}
name|WinSnapInterface
typedef|;
end_typedef

begin_comment
comment|/* The dialog data */
end_comment

begin_decl_stmt
DECL|variable|winsnapintf
specifier|static
name|WinSnapInterface
name|winsnapintf
init|=
block|{
ifdef|#
directive|ifdef
name|CAN_SET_DECOR
name|NULL
block|,
endif|#
directive|endif
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This plug-in's functions */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We create a DIB section to hold the grabbed area. The scanlines in  * DIB sections are aligned ona LONG (four byte) boundary. Its pixel  * data is in RGB (BGR actually) format, three bytes per pixel.  *  * GIMP uses no alignment for its pixel regions. The GIMP image we  * create is of type RGB, i.e. three bytes per pixel, too. Thus in  * order to be able to quickly transfer all of the image at a time, we  * must use a DIB section and pixel region the scanline width in  * bytes of which is evenly divisible with both 3 and 4. I.e. it must  * be a multiple of 12 bytes, or in pixels, a multiple of four pixels.  */
end_comment

begin_define
DECL|macro|ROUND4 (width)
define|#
directive|define
name|ROUND4
parameter_list|(
name|width
parameter_list|)
value|(((width-1)/4+1)*4)
end_define

begin_comment
comment|/******************************************************************  * Debug stuff  ******************************************************************/
end_comment

begin_comment
comment|/*  * formatWindowsError  *  * Format the latest Windows error message into  * a readable string.  Store in the provided  * buffer.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|formatWindowsError (char * buffer,int buf_size)
name|formatWindowsError
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|LPVOID
name|lpMsgBuf
decl_stmt|;
comment|/* Format the message */
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
operator||
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
argument_list|,
name|NULL
argument_list|,
name|GetLastError
argument_list|()
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
operator|(
name|LPTSTR
operator|)
operator|&
name|lpMsgBuf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy to the buffer */
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|lpMsgBuf
argument_list|,
name|buf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|LocalFree
argument_list|(
name|lpMsgBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************  * Bitmap capture and handling  ******************************************************************/
end_comment

begin_comment
comment|/*  * primDoWindowCapture  *  * The primitive window capture functionality.  Accepts  * the two device contexts and the rectangle to be  * captured.  */
end_comment

begin_function
specifier|static
name|HBITMAP
DECL|function|primDoWindowCapture (HDC hdcWindow,HDC hdcCompat,RECT rect)
name|primDoWindowCapture
parameter_list|(
name|HDC
name|hdcWindow
parameter_list|,
name|HDC
name|hdcCompat
parameter_list|,
name|RECT
name|rect
parameter_list|)
block|{
name|HBITMAP
name|hbmCopy
decl_stmt|;
name|HGDIOBJ
name|oldObject
decl_stmt|;
name|BITMAPINFO
name|bmi
decl_stmt|;
name|int
name|width
init|=
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
decl_stmt|;
name|int
name|height
init|=
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|)
decl_stmt|;
comment|/* Create the bitmap info header */
name|bmi
operator|.
name|bmiHeader
operator|.
name|biSize
operator|=
sizeof|sizeof
argument_list|(
name|BITMAPINFOHEADER
argument_list|)
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biWidth
operator|=
name|ROUND4
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biHeight
operator|=
operator|-
name|height
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biPlanes
operator|=
literal|1
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biBitCount
operator|=
literal|24
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biCompression
operator|=
name|BI_RGB
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biSizeImage
operator|=
literal|0
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biXPelsPerMeter
operator|=
name|bmi
operator|.
name|bmiHeader
operator|.
name|biYPelsPerMeter
operator|=
literal|0
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biClrUsed
operator|=
literal|0
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biClrImportant
operator|=
literal|0
expr_stmt|;
comment|/* Create the bitmap storage space */
name|hbmCopy
operator|=
name|CreateDIBSection
argument_list|(
name|hdcCompat
argument_list|,
operator|(
name|BITMAPINFO
operator|*
operator|)
operator|&
name|bmi
argument_list|,
name|DIB_RGB_COLORS
argument_list|,
operator|&
name|capBytes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hbmCopy
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error creating DIB section: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Select the bitmap into the compatible DC. */
name|oldObject
operator|=
name|SelectObject
argument_list|(
name|hdcCompat
argument_list|,
name|hbmCopy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldObject
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error selecting object: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Copy the data from the application to the bitmap.  Even if we did    * round up the width, BitBlt only the actual data.    */
if|if
condition|(
operator|!
name|BitBlt
argument_list|(
name|hdcCompat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|hdcWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SRCCOPY
argument_list|)
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error copying bitmap: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Restore the original object */
name|SelectObject
argument_list|(
name|hdcCompat
argument_list|,
name|oldObject
argument_list|)
expr_stmt|;
return|return
name|hbmCopy
return|;
block|}
end_function

begin_comment
comment|/*  * doCapture  *  * Do the capture.  Accepts the window  * handle to be captured or the NULL value  * to specify the root window.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|doCapture (HWND selectedHwnd)
name|doCapture
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|)
block|{
name|HDC
name|hdcSrc
decl_stmt|;
name|HDC
name|hdcCompat
decl_stmt|;
name|HRGN
name|capRegion
decl_stmt|;
name|HWND
name|oldForeground
decl_stmt|;
name|RECT
name|rect
decl_stmt|;
name|HBITMAP
name|hbm
decl_stmt|;
comment|/* Try and get everything out of the way before the    * capture.    */
name|Sleep
argument_list|(
literal|500
operator|+
name|winsnapvals
operator|.
name|delay
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Are we capturing a window or the whole screen */
if|if
condition|(
name|selectedHwnd
condition|)
block|{
comment|/* Set to foreground window */
name|oldForeground
operator|=
name|GetForegroundWindow
argument_list|()
expr_stmt|;
name|SetForegroundWindow
argument_list|(
name|selectedHwnd
argument_list|)
expr_stmt|;
name|BringWindowToTop
argument_list|(
name|selectedHwnd
argument_list|)
expr_stmt|;
name|Sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Build a region for the capture */
name|GetWindowRect
argument_list|(
name|selectedHwnd
argument_list|,
operator|&
name|rect
argument_list|)
expr_stmt|;
name|capRegion
operator|=
name|CreateRectRgn
argument_list|(
name|rect
operator|.
name|left
argument_list|,
name|rect
operator|.
name|top
argument_list|,
name|rect
operator|.
name|right
argument_list|,
name|rect
operator|.
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|capRegion
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error creating region: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Get the device context for the selected      * window.  Create a memory DC to use for the      * Bit copy.      */
name|hdcSrc
operator|=
name|GetDCEx
argument_list|(
name|selectedHwnd
argument_list|,
name|capRegion
argument_list|,
name|DCX_WINDOW
operator||
name|DCX_PARENTCLIP
operator||
name|DCX_INTERSECTRGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the device context for the whole screen */
name|hdcSrc
operator|=
name|CreateDC
argument_list|(
literal|"DISPLAY"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the screen's rectangle */
name|rect
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|GetDeviceCaps
argument_list|(
name|hdcSrc
argument_list|,
name|VERTRES
argument_list|)
expr_stmt|;
name|rect
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|GetDeviceCaps
argument_list|(
name|hdcSrc
argument_list|,
name|HORZRES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hdcSrc
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error getting device context: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hdcCompat
operator|=
name|CreateCompatibleDC
argument_list|(
name|hdcSrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdcCompat
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error getting compat device context: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Do the window capture */
name|hbm
operator|=
name|primDoWindowCapture
argument_list|(
name|hdcSrc
argument_list|,
name|hdcCompat
argument_list|,
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hbm
condition|)
return|return
name|FALSE
return|;
comment|/* Release the device context */
name|ReleaseDC
argument_list|(
name|selectedHwnd
argument_list|,
name|hdcSrc
argument_list|)
expr_stmt|;
comment|/* Replace the previous foreground window */
if|if
condition|(
name|selectedHwnd
operator|&&
name|oldForeground
condition|)
name|SetForegroundWindow
argument_list|(
name|oldForeground
argument_list|)
expr_stmt|;
comment|/* Send the bitmap */
if|if
condition|(
name|hbm
operator|!=
name|NULL
condition|)
block|{
name|sendBMPToGimp
argument_list|(
name|hbm
argument_list|,
name|hdcCompat
argument_list|,
name|rect
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  * Win32 entry point and setup...  ******************************************************************/
end_comment

begin_define
DECL|macro|DINV
define|#
directive|define
name|DINV
value|3
end_define

begin_comment
comment|/*  * highlightWindowFrame  *  * Highlight (or unhighlight) the specified  * window handle's frame.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|highlightWindowFrame (HWND hWnd)
name|highlightWindowFrame
parameter_list|(
name|HWND
name|hWnd
parameter_list|)
block|{
name|HDC
name|hdc
decl_stmt|;
name|RECT
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|IsWindow
argument_list|(
name|hWnd
argument_list|)
condition|)
return|return;
name|hdc
operator|=
name|GetWindowDC
argument_list|(
name|hWnd
argument_list|)
expr_stmt|;
name|GetWindowRect
argument_list|(
name|hWnd
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
name|OffsetRect
argument_list|(
operator|&
name|rc
argument_list|,
operator|-
name|rc
operator|.
name|left
argument_list|,
operator|-
name|rc
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsRectEmpty
argument_list|(
operator|&
name|rc
argument_list|)
condition|)
block|{
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|left
argument_list|,
name|rc
operator|.
name|top
argument_list|,
name|rc
operator|.
name|right
operator|-
name|rc
operator|.
name|left
argument_list|,
name|DINV
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|left
argument_list|,
name|rc
operator|.
name|bottom
operator|-
name|DINV
argument_list|,
name|DINV
argument_list|,
operator|-
operator|(
name|rc
operator|.
name|bottom
operator|-
name|rc
operator|.
name|top
operator|-
literal|2
operator|*
name|DINV
operator|)
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|right
operator|-
name|DINV
argument_list|,
name|rc
operator|.
name|top
operator|+
name|DINV
argument_list|,
name|DINV
argument_list|,
name|rc
operator|.
name|bottom
operator|-
name|rc
operator|.
name|top
operator|-
literal|2
operator|*
name|DINV
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|right
argument_list|,
name|rc
operator|.
name|bottom
operator|-
name|DINV
argument_list|,
operator|-
operator|(
name|rc
operator|.
name|right
operator|-
name|rc
operator|.
name|left
operator|)
argument_list|,
name|DINV
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
block|}
name|ReleaseDC
argument_list|(
name|hWnd
argument_list|,
name|hdc
argument_list|)
expr_stmt|;
name|UpdateWindow
argument_list|(
name|hWnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setCaptureType  *  * Set the capture type.  Should be one of:  * SELECT_FRAME  * SELECT_CLIENT  * SELECT_WINDOW  */
end_comment

begin_function
name|void
DECL|function|setCaptureType (int capType)
name|setCaptureType
parameter_list|(
name|int
name|capType
parameter_list|)
block|{
name|captureType
operator|=
name|capType
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * myWindowFromPoint  *  * Map to the appropriate window from the  * specified point.  The chosen window is  * based on the current capture type.  */
end_comment

begin_function
specifier|static
name|HWND
DECL|function|myWindowFromPoint (POINT pt)
name|myWindowFromPoint
parameter_list|(
name|POINT
name|pt
parameter_list|)
block|{
name|HWND
name|myHwnd
decl_stmt|;
name|HWND
name|nextHwnd
decl_stmt|;
switch|switch
condition|(
name|captureType
condition|)
block|{
case|case
name|SELECT_FRAME
case|:
case|case
name|SELECT_CLIENT
case|:
name|nextHwnd
operator|=
name|WindowFromPoint
argument_list|(
name|pt
argument_list|)
expr_stmt|;
do|do
block|{
name|myHwnd
operator|=
name|nextHwnd
expr_stmt|;
name|nextHwnd
operator|=
name|GetParent
argument_list|(
name|myHwnd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nextHwnd
condition|)
do|;
return|return
name|myHwnd
return|;
break|break;
case|case
name|SELECT_WINDOW
case|:
return|return
name|WindowFromPoint
argument_list|(
name|pt
argument_list|)
return|;
break|break;
block|}
return|return
name|WindowFromPoint
argument_list|(
name|pt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dialogProc  *  * The window procedure for the window  * selection dialog box.  */
end_comment

begin_function
name|BOOL
name|CALLBACK
DECL|function|dialogProc (HWND hwndDlg,UINT msg,WPARAM wParam,LPARAM lParam)
name|dialogProc
parameter_list|(
name|HWND
name|hwndDlg
parameter_list|,
name|UINT
name|msg
parameter_list|,
name|WPARAM
name|wParam
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
specifier|static
name|int
name|mouseCaptured
decl_stmt|;
specifier|static
name|int
name|buttonDown
decl_stmt|;
specifier|static
name|HCURSOR
name|oldCursor
decl_stmt|;
specifier|static
name|RECT
name|bitmapRect
decl_stmt|;
specifier|static
name|HWND
name|highlightedHwnd
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|WM_INITDIALOG
case|:
block|{
name|int
name|nonclientHeight
decl_stmt|;
name|HWND
name|hwndGroup
decl_stmt|;
name|RECT
name|dlgRect
decl_stmt|;
name|RECT
name|clientRect
decl_stmt|;
name|RECT
name|groupRect
decl_stmt|;
name|BITMAP
name|bm
decl_stmt|;
comment|/* Set the mouse capture flag */
name|buttonDown
operator|=
literal|0
expr_stmt|;
name|mouseCaptured
operator|=
literal|0
expr_stmt|;
comment|/* Calculate the bitmap dimensions */
name|GetObject
argument_list|(
name|iconInfo
operator|.
name|hbmMask
argument_list|,
sizeof|sizeof
argument_list|(
name|BITMAP
argument_list|)
argument_list|,
operator|(
name|VOID
operator|*
operator|)
operator|&
name|bm
argument_list|)
expr_stmt|;
comment|/* Calculate the dialog window dimensions */
name|GetWindowRect
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|dlgRect
argument_list|)
expr_stmt|;
comment|/* Calculate the group box dimensions */
name|hwndGroup
operator|=
name|GetDlgItem
argument_list|(
name|hwndDlg
argument_list|,
name|IDC_GROUP
argument_list|)
expr_stmt|;
name|GetWindowRect
argument_list|(
name|hwndGroup
argument_list|,
operator|&
name|groupRect
argument_list|)
expr_stmt|;
name|OffsetRect
argument_list|(
operator|&
name|groupRect
argument_list|,
operator|-
name|dlgRect
operator|.
name|left
argument_list|,
operator|-
name|dlgRect
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* The client's rectangle */
name|GetClientRect
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|clientRect
argument_list|)
expr_stmt|;
comment|/* The non-client height */
name|nonclientHeight
operator|=
operator|(
name|dlgRect
operator|.
name|bottom
operator|-
name|dlgRect
operator|.
name|top
operator|)
operator|-
operator|(
name|clientRect
operator|.
name|bottom
operator|-
name|clientRect
operator|.
name|top
operator|)
expr_stmt|;
comment|/* Calculate the bitmap rectangle */
name|bitmapRect
operator|.
name|top
operator|=
operator|(
operator|(
name|groupRect
operator|.
name|top
operator|+
name|groupRect
operator|.
name|bottom
operator|)
operator|/
literal|2
operator|)
operator|-
operator|(
name|bm
operator|.
name|bmHeight
operator|/
literal|2
operator|)
expr_stmt|;
name|bitmapRect
operator|.
name|top
operator|-=
name|nonclientHeight
expr_stmt|;
name|bitmapRect
operator|.
name|bottom
operator|=
name|bitmapRect
operator|.
name|top
operator|+
name|bm
operator|.
name|bmHeight
expr_stmt|;
name|bitmapRect
operator|.
name|left
operator|=
operator|(
operator|(
name|groupRect
operator|.
name|left
operator|+
name|groupRect
operator|.
name|right
operator|)
operator|/
literal|2
operator|)
operator|-
operator|(
name|bm
operator|.
name|bmWidth
operator|/
literal|2
operator|)
expr_stmt|;
name|bitmapRect
operator|.
name|right
operator|=
name|bitmapRect
operator|.
name|left
operator|+
name|bm
operator|.
name|bmWidth
expr_stmt|;
block|}
break|break;
case|case
name|WM_LBUTTONDOWN
case|:
comment|/* Track the button down state */
name|buttonDown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|WM_LBUTTONUP
case|:
name|buttonDown
operator|=
literal|0
expr_stmt|;
comment|/* If we have mouse captured      * we do this stuff.      */
if|if
condition|(
name|mouseCaptured
condition|)
block|{
name|HWND
name|selectedHwnd
decl_stmt|;
name|POINT
name|cursorPos
decl_stmt|;
comment|/* Release the capture */
name|mouseCaptured
operator|=
literal|0
expr_stmt|;
name|SetCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
name|ReleaseCapture
argument_list|()
expr_stmt|;
comment|/* Remove the highlight */
if|if
condition|(
name|highlightedHwnd
condition|)
name|highlightWindowFrame
argument_list|(
name|highlightedHwnd
argument_list|)
expr_stmt|;
name|RedrawWindow
argument_list|(
name|hwndDlg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RDW_INVALIDATE
argument_list|)
expr_stmt|;
comment|/* Return the selected window */
name|GetCursorPos
argument_list|(
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
name|selectedHwnd
operator|=
name|myWindowFromPoint
argument_list|(
name|cursorPos
argument_list|)
expr_stmt|;
name|EndDialog
argument_list|(
name|hwndDlg
argument_list|,
operator|(
name|int
operator|)
name|selectedHwnd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WM_MOUSEMOVE
case|:
comment|/* If the mouse is captured, show      * the window which is tracking      * under the mouse position.      */
if|if
condition|(
name|mouseCaptured
condition|)
block|{
name|HWND
name|currentHwnd
decl_stmt|;
name|POINT
name|cursorPos
decl_stmt|;
comment|/* Get the window */
name|GetCursorPos
argument_list|(
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
name|currentHwnd
operator|=
name|myWindowFromPoint
argument_list|(
name|cursorPos
argument_list|)
expr_stmt|;
comment|/* Do the highlighting */
if|if
condition|(
name|highlightedHwnd
operator|!=
name|currentHwnd
condition|)
block|{
if|if
condition|(
name|highlightedHwnd
condition|)
name|highlightWindowFrame
argument_list|(
name|highlightedHwnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentHwnd
condition|)
name|highlightWindowFrame
argument_list|(
name|currentHwnd
argument_list|)
expr_stmt|;
name|highlightedHwnd
operator|=
name|currentHwnd
expr_stmt|;
block|}
comment|/* If the mouse has not been captured,        * try to figure out if we should capture        * the mouse.        */
block|}
elseif|else
if|if
condition|(
name|buttonDown
condition|)
block|{
name|POINT
name|cursorPos
decl_stmt|;
comment|/* Get the current client position */
name|GetCursorPos
argument_list|(
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
name|ScreenToClient
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
comment|/* Check if within the rectangle formed        * by the bitmap        */
if|if
condition|(
name|PtInRect
argument_list|(
operator|&
name|bitmapRect
argument_list|,
name|cursorPos
argument_list|)
condition|)
block|{
name|mouseCaptured
operator|=
literal|1
expr_stmt|;
name|oldCursor
operator|=
name|SetCursor
argument_list|(
name|selectCursor
argument_list|)
expr_stmt|;
name|SetCapture
argument_list|(
name|hwndDlg
argument_list|)
expr_stmt|;
name|RedrawWindow
argument_list|(
name|hwndDlg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RDW_INVALIDATE
operator||
name|RDW_ERASE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|WM_PAINT
case|:
block|{
name|HDC
name|hDC
decl_stmt|;
name|PAINTSTRUCT
name|ps
decl_stmt|;
comment|/* If the mouse is not captured draw        * the cursor image        */
if|if
condition|(
operator|!
name|mouseCaptured
condition|)
block|{
name|hDC
operator|=
name|BeginPaint
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|DrawIconEx
argument_list|(
name|hDC
argument_list|,
name|bitmapRect
operator|.
name|left
argument_list|,
name|bitmapRect
operator|.
name|top
argument_list|,
name|selectCursor
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DI_NORMAL
argument_list|)
expr_stmt|;
name|EndPaint
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|WM_COMMAND
case|:
comment|/* Handle the cancel button */
switch|switch
condition|(
name|LOWORD
argument_list|(
name|wParam
argument_list|)
condition|)
block|{
case|case
name|IDCANCEL
case|:
name|EndDialog
argument_list|(
name|hwndDlg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Don't use the normal WinMain from gimp.h */
end_comment

begin_define
DECL|macro|WinMain
define|#
directive|define
name|WinMain
value|WinMain_no_thanks
end_define

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_undef
undef|#
directive|undef
name|WinMain
end_undef

begin_comment
comment|/*  * WinMain  *  * The standard gimp plug-in WinMain won't quite cut it for  * this plug-in.  */
end_comment

begin_function
name|int
name|APIENTRY
name|WinMain
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|,
name|HINSTANCE
name|hPrevInstance
parameter_list|,
name|LPSTR
name|lpCmdLine
parameter_list|,
name|int
name|nCmdShow
parameter_list|)
block|{
comment|/*    * Normally, we would do all of the Windows-ish set up of    * the window classes and stuff here in WinMain.  But,    * the only time we really need the window and message    * queues is during the plug-in run.  So, all of that will    * be done during run().  This avoids all of the Windows    * setup stuff for the query().  Stash the instance handle now    * so it is available from the run() procedure.    */
name|hInst
operator|=
name|hInstance
expr_stmt|;
comment|/*    * Now, call gimp_main... This is what the normal WinMain()    * would do.    */
return|return
name|gimp_main
argument_list|(
operator|&
name|PLUG_IN_INFO
argument_list|,
name|__argc
argument_list|,
name|__argv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * InitApplication  *  * Initialize window data and register the window class  */
end_comment

begin_function
name|BOOL
DECL|function|InitApplication (HINSTANCE hInstance)
name|InitApplication
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|)
block|{
name|WNDCLASS
name|wc
decl_stmt|;
name|BOOL
name|retValue
decl_stmt|;
comment|/* Get some resources */
ifdef|#
directive|ifdef
name|_MSC_VER
comment|/* For some reason this works only with MSVC */
name|selectCursor
operator|=
name|LoadCursor
argument_list|(
name|hInstance
argument_list|,
name|MAKEINTRESOURCE
argument_list|(
name|IDC_SELECT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|selectCursor
operator|=
name|LoadCursor
argument_list|(
name|NULL
argument_list|,
name|IDC_CROSS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GetIconInfo
argument_list|(
name|selectCursor
argument_list|,
operator|&
name|iconInfo
argument_list|)
expr_stmt|;
comment|/*    * Fill in window class structure with parameters to describe    * the main window.    */
name|wc
operator|.
name|style
operator|=
name|CS_HREDRAW
operator||
name|CS_VREDRAW
expr_stmt|;
name|wc
operator|.
name|lpfnWndProc
operator|=
operator|(
name|WNDPROC
operator|)
name|WndProc
expr_stmt|;
name|wc
operator|.
name|cbClsExtra
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|cbWndExtra
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|hInstance
operator|=
name|hInstance
expr_stmt|;
name|wc
operator|.
name|hIcon
operator|=
name|LoadIcon
argument_list|(
name|NULL
argument_list|,
name|IDI_APPLICATION
argument_list|)
expr_stmt|;
name|wc
operator|.
name|hCursor
operator|=
name|LoadCursor
argument_list|(
name|NULL
argument_list|,
name|IDC_ARROW
argument_list|)
expr_stmt|;
name|wc
operator|.
name|hbrBackground
operator|=
call|(
name|HBRUSH
call|)
argument_list|(
name|COLOR_WINDOW
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wc
operator|.
name|lpszClassName
operator|=
name|APP_NAME
expr_stmt|;
name|wc
operator|.
name|lpszMenuName
operator|=
name|NULL
expr_stmt|;
comment|/* Register the window class and stash success/failure code. */
name|retValue
operator|=
name|RegisterClass
argument_list|(
operator|&
name|wc
argument_list|)
expr_stmt|;
comment|/* Log error */
if|if
condition|(
operator|!
name|retValue
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error registering class: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/*  * InitInstance  *  * Create the main window for the application.  */
end_comment

begin_function
name|BOOL
DECL|function|InitInstance (HINSTANCE hInstance,int nCmdShow)
name|InitInstance
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|,
name|int
name|nCmdShow
parameter_list|)
block|{
comment|/* Create our window */
name|mainHwnd
operator|=
name|CreateWindow
argument_list|(
name|APP_NAME
argument_list|,
name|APP_NAME
argument_list|,
name|WS_OVERLAPPEDWINDOW
argument_list|,
name|CW_USEDEFAULT
argument_list|,
literal|0
argument_list|,
name|CW_USEDEFAULT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|hInstance
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mainHwnd
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|ShowWindow
argument_list|(
name|mainHwnd
argument_list|,
name|nCmdShow
argument_list|)
expr_stmt|;
name|UpdateWindow
argument_list|(
name|mainHwnd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * winsnapWinMain  *  * This is the function that represents the code that  * would normally reside in WinMain (see above).  This  * function will get called during run() in order to set  * up the windowing environment necessary for WinSnap to  * operate.  */
end_comment

begin_function
name|int
DECL|function|winsnapWinMain (void)
name|winsnapWinMain
parameter_list|(
name|void
parameter_list|)
block|{
name|MSG
name|msg
decl_stmt|;
comment|/* Perform instance initialization */
if|if
condition|(
operator|!
name|InitApplication
argument_list|(
name|hInst
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Perform application initialization */
if|if
condition|(
operator|!
name|InitInstance
argument_list|(
name|hInst
argument_list|,
name|SHOW_WINDOW
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Main message loop */
while|while
condition|(
name|GetMessage
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TranslateMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|DispatchMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|.
name|wParam
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * WndProc  *  * Process window message for the main window.  */
end_comment

begin_function
name|LRESULT
name|CALLBACK
DECL|function|WndProc (HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam)
name|WndProc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|UINT
name|message
parameter_list|,
name|WPARAM
name|wParam
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
name|HWND
name|selectedHwnd
decl_stmt|;
switch|switch
condition|(
name|message
condition|)
block|{
case|case
name|WM_CREATE
case|:
comment|/* The window is created... Send the capture message */
name|PostMessage
argument_list|(
name|hwnd
argument_list|,
name|WM_DOCAPTURE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WM_DOCAPTURE
case|:
comment|/* Get the selected window handle */
name|selectedHwnd
operator|=
operator|(
name|HWND
operator|)
name|DialogBox
argument_list|(
name|hInst
argument_list|,
name|MAKEINTRESOURCE
argument_list|(
name|IDD_SELECT
argument_list|)
argument_list|,
name|hwnd
argument_list|,
operator|(
name|DLGPROC
operator|)
name|dialogProc
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectedHwnd
condition|)
name|doCapture
argument_list|(
name|selectedHwnd
argument_list|)
expr_stmt|;
name|PostQuitMessage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WM_DESTROY
case|:
name|PostQuitMessage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DefWindowProc
argument_list|(
name|hwnd
argument_list|,
name|message
argument_list|,
name|wParam
argument_list|,
name|lParam
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * doRootWindowCapture  *  * Capture the root window  */
end_comment

begin_function
specifier|static
name|void
DECL|function|doRootWindowCapture (void)
name|doRootWindowCapture
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do the window capture */
name|doCapture
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * doNonRootWindowCapture  *  * Capture a selected window.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|doWindowCapture (void)
name|doWindowCapture
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Start up a standard Win32    * message handling loop for    * selection of the window    * to be captured    */
name|winsnapWinMain
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************  * Snapshot configuration dialog  ******************************************************************/
end_comment

begin_comment
comment|/*  * snap_toggle_update  *  * The radio buttons have been updated.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|snap_toggle_update (GtkWidget * widget,gpointer radio_button)
name|snap_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|radio_button
parameter_list|)
block|{
name|gint
modifier|*
name|toggle_val
init|=
operator|(
name|gint
operator|*
operator|)
name|radio_button
decl_stmt|;
if|if
condition|(
name|gtk_toggle_button_get_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
argument_list|)
condition|)
operator|*
name|toggle_val
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|toggle_val
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_SET_DECOR
if|if
condition|(
name|widget
operator|==
name|winsnapintf
operator|.
name|single_button
condition|)
name|gtk_widget_set_sensitive
argument_list|(
name|winsnapintf
operator|.
name|decor_button
argument_list|,
operator|*
name|toggle_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CAN_SET_DECOR */
block|}
end_function

begin_comment
comment|/*  * snap_dialog  *  * Bring up the GTK dialog for setting snapshot  * parameters.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|snap_dialog (void)
name|snap_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkObject
modifier|*
name|adj
decl_stmt|;
name|GSList
modifier|*
name|radio_group
init|=
name|NULL
decl_stmt|;
name|gint
name|radio_pressed
index|[
literal|2
index|]
decl_stmt|;
name|gint
name|decorations
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
comment|/* Set defaults */
name|radio_pressed
index|[
literal|0
index|]
operator|=
operator|(
name|winsnapvals
operator|.
name|root
operator|==
name|FALSE
operator|)
expr_stmt|;
name|radio_pressed
index|[
literal|1
index|]
operator|=
operator|(
name|winsnapvals
operator|.
name|root
operator|==
name|TRUE
operator|)
expr_stmt|;
name|decorations
operator|=
name|winsnapvals
operator|.
name|decor
expr_stmt|;
comment|/* Init GTK  */
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Main Dialog */
name|dialog
operator|=
name|gimp_dialog_new
argument_list|(
name|PLUG_IN_PRINT_NAME
argument_list|,
name|PLUG_IN_ROLE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|PLUG_IN_PROC
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|_
argument_list|(
literal|"Grab"
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|winsnapintf
operator|.
name|single_button
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|radio_group
argument_list|,
name|_
argument_list|(
literal|"Grab a single window"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|winsnapintf
operator|.
name|single_button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|winsnapintf
operator|.
name|single_button
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|snap_toggle_update
argument_list|)
argument_list|,
operator|&
name|radio_pressed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|winsnapintf
operator|.
name|single_button
argument_list|)
argument_list|,
name|radio_pressed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|winsnapintf
operator|.
name|single_button
argument_list|)
expr_stmt|;
name|radio_group
operator|=
name|gtk_radio_button_get_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|winsnapintf
operator|.
name|single_button
argument_list|)
argument_list|)
expr_stmt|;
name|winsnapintf
operator|.
name|root_button
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|radio_group
argument_list|,
name|_
argument_list|(
literal|"Grab the whole screen"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|winsnapintf
operator|.
name|root_button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|winsnapintf
operator|.
name|root_button
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|snap_toggle_update
argument_list|)
argument_list|,
operator|&
name|radio_pressed
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|winsnapintf
operator|.
name|root_button
argument_list|)
argument_list|,
name|radio_pressed
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|winsnapintf
operator|.
name|root_button
argument_list|)
expr_stmt|;
name|radio_group
operator|=
name|gtk_radio_button_get_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|winsnapintf
operator|.
name|root_button
argument_list|)
argument_list|)
expr_stmt|;
comment|/* with delay */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"after"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|winsnapintf
operator|.
name|delay_spinner
operator|=
name|gimp_spin_button_new
argument_list|(
operator|&
name|adj
argument_list|,
name|winsnapvals
operator|.
name|delay
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
literal|5.0
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|winsnapintf
operator|.
name|delay_spinner
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|winsnapintf
operator|.
name|delay_spinner
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Seconds delay"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_SET_DECOR
comment|/* With decorations */
name|winsnapintf
operator|.
name|decor_button
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"Include decorations"
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|winsnapintf
operator|.
name|decor_button
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|snap_toggle_update
argument_list|)
argument_list|,
operator|&
name|decorations
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|winsnapintf
operator|.
name|decor_button
argument_list|)
argument_list|,
name|decorations
argument_list|)
expr_stmt|;
name|gtk_box_pack_end
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|winsnapintf
operator|.
name|decor_button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|winsnapintf
operator|.
name|decor_button
argument_list|,
name|radio_pressed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|winsnapintf
operator|.
name|decor_button
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CAN_SET_DECOR */
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
if|if
condition|(
name|run
condition|)
block|{
name|winsnapvals
operator|.
name|root
operator|=
name|radio_pressed
index|[
literal|1
index|]
expr_stmt|;
name|winsnapvals
operator|.
name|decor
operator|=
name|decorations
expr_stmt|;
name|winsnapvals
operator|.
name|delay
operator|=
name|gtk_spin_button_get_value_as_int
argument_list|(
name|GTK_SPIN_BUTTON
argument_list|(
name|winsnapintf
operator|.
name|delay_spinner
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  * GIMP Plug-in entry points  ******************************************************************/
end_comment

begin_comment
comment|/*  * Plug-in Parameter definitions  */
end_comment

begin_define
DECL|macro|NUMBER_IN_ARGS
define|#
directive|define
name|NUMBER_IN_ARGS
value|3
end_define

begin_define
DECL|macro|IN_ARGS
define|#
directive|define
name|IN_ARGS
value|{ GIMP_PDB_INT32,    "run-mode",  "The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }" },\                 { GIMP_PDB_INT32,    "root",      "Root window { TRUE, FALSE }" },\                 { GIMP_PDB_INT32,    "decorations", \ 									"Include Window Decorations { TRUE, FALSE }" }
end_define

begin_define
DECL|macro|NUMBER_OUT_ARGS
define|#
directive|define
name|NUMBER_OUT_ARGS
value|1
end_define

begin_define
DECL|macro|OUT_ARGS
define|#
directive|define
name|OUT_ARGS
value|{ GIMP_PDB_IMAGE,   "image",     "Output image" }
end_define

begin_comment
comment|/*  * query  *  * The plug-in is being queried.  Install our procedure for  * capturing windows.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|query (void)
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|args
index|[]
init|=
block|{
name|IN_ARGS
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|return_vals
index|[]
init|=
block|{
name|OUT_ARGS
block|}
decl_stmt|;
comment|/* the installation of the plugin */
name|gimp_install_procedure
argument_list|(
name|PLUG_IN_PROC
argument_list|,
name|N_
argument_list|(
literal|"Capture a window or desktop image"
argument_list|)
argument_list|,
name|PLUG_IN_HELP
argument_list|,
name|PLUG_IN_AUTHOR
argument_list|,
name|PLUG_IN_COPYRIGHT
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|N_
argument_list|(
literal|"_Screen Shot..."
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|NUMBER_IN_ARGS
argument_list|,
name|NUMBER_OUT_ARGS
argument_list|,
name|args
argument_list|,
name|return_vals
argument_list|)
expr_stmt|;
name|gimp_plugin_menu_register
argument_list|(
name|PLUG_IN_PROC
argument_list|,
literal|"<Image>/File/Create/Acquire"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return values storage */
end_comment

begin_decl_stmt
DECL|variable|values
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * run  *  * The plug-in is being requested to run.  * Capture an window image.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
name|GimpRunMode
name|run_mode
decl_stmt|;
comment|/* Initialize the return values    * Always return at least the status to the caller.    */
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
comment|/* Get the runmode from the in-parameters */
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
comment|/* Set up the rest of the return parameters */
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_INT32
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|=
literal|0
expr_stmt|;
comment|/* Get the data from last run */
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|winsnapvals
argument_list|)
expr_stmt|;
comment|/* How are we running today? */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/* Get information from the dialog */
if|if
condition|(
operator|!
name|snap_dialog
argument_list|()
condition|)
return|return;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
if|if
condition|(
operator|!
name|winsnapvals
operator|.
name|root
condition|)
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* switch */
comment|/* Do the actual window capture */
if|if
condition|(
name|winsnapvals
operator|.
name|root
condition|)
name|doRootWindowCapture
argument_list|()
expr_stmt|;
else|else
name|doWindowCapture
argument_list|()
expr_stmt|;
comment|/* Check to make sure we got at least one valid    * image.    */
if|if
condition|(
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|>
literal|0
condition|)
block|{
comment|/* A window was captured.      * Do final Interactive steps.      */
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
comment|/* Store variable states for next run */
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|winsnapvals
argument_list|,
sizeof|sizeof
argument_list|(
name|WinSnapValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set return values */
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************  * GIMP format and transfer functions  ******************************************************************/
end_comment

begin_comment
comment|/*  * flipRedAndBlueBytes  *  * Microsoft has chosen to provide us a very nice (not!)  * interface for retrieving bitmap bits.  DIBSections have  * RGB information as BGR instead.  So, we have to swap  * the silly red and blue bytes before sending to the  * GIMP.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|flipRedAndBlueBytes (int width,int height)
name|flipRedAndBlueBytes
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guchar
modifier|*
name|bufp
decl_stmt|;
name|guchar
name|temp
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|height
condition|)
block|{
name|i
operator|=
name|width
expr_stmt|;
name|bufp
operator|=
name|capBytes
operator|+
name|j
operator|*
name|ROUND4
argument_list|(
name|width
argument_list|)
operator|*
literal|3
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|temp
operator|=
name|bufp
index|[
literal|2
index|]
expr_stmt|;
name|bufp
index|[
literal|2
index|]
operator|=
name|bufp
index|[
literal|0
index|]
expr_stmt|;
name|bufp
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
name|bufp
operator|+=
literal|3
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * sendBMPToGIMP  *  * Take the captured data and send it across  * to GIMP.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|sendBMPToGimp (HBITMAP hBMP,HDC hDC,RECT rect)
name|sendBMPToGimp
parameter_list|(
name|HBITMAP
name|hBMP
parameter_list|,
name|HDC
name|hDC
parameter_list|,
name|RECT
name|rect
parameter_list|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|imageType
decl_stmt|,
name|layerType
decl_stmt|;
name|gint32
name|image_id
decl_stmt|;
name|gint32
name|layer_id
decl_stmt|;
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Our width and height */
name|width
operator|=
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
expr_stmt|;
name|height
operator|=
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|)
expr_stmt|;
comment|/* Check that we got the memory */
if|if
condition|(
operator|!
name|capBytes
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"No data captured"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Flip the red and blue bytes */
name|flipRedAndBlueBytes
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Set up the image and layer types */
name|imageType
operator|=
name|GIMP_RGB
expr_stmt|;
name|layerType
operator|=
name|GIMP_RGB_IMAGE
expr_stmt|;
comment|/* Create the GIMP image and layers */
name|image_id
operator|=
name|gimp_image_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|imageType
argument_list|)
expr_stmt|;
name|layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|image_id
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|ROUND4
argument_list|(
name|width
argument_list|)
argument_list|,
name|height
argument_list|,
name|layerType
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image_id
argument_list|,
name|layer_id
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get our drawable */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|gimp_tile_cache_size
argument_list|(
name|ROUND4
argument_list|(
name|width
argument_list|)
operator|*
name|gimp_tile_height
argument_list|()
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* Initialize a pixel region for writing to the image */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ROUND4
argument_list|(
name|width
argument_list|)
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|capBytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ROUND4
argument_list|(
name|width
argument_list|)
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* HB: update data BEFORE size change */
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* Now resize the layer down to the correct size if necessary. */
if|if
condition|(
name|width
operator|!=
name|ROUND4
argument_list|(
name|width
argument_list|)
condition|)
block|{
name|gimp_layer_resize
argument_list|(
name|layer_id
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_resize
argument_list|(
name|image_id
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Finish up */
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_display_new
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

