begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * Screenshot plug-in  * Copyright 1998-2007 Sven Neumann<sven@gimp.org>  * Copyright 2003      Henrik Brix Andersen<brix@gimp.org>  * Copyright 2012      Simone Karin Lehmann - OS X patches  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Necessary in order to have SetProcessDPIAware() defined.  * This value of _WIN32_WINNT corresponds to Windows 7, which is our  * minimum supported platform.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32_WINNT
end_ifdef

begin_undef
undef|#
directive|undef
name|_WIN32_WINNT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|_WIN32_WINNT
define|#
directive|define
name|_WIN32_WINNT
value|0x0601
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"screenshot.h"
end_include

begin_include
include|#
directive|include
file|"screenshot-win32.h"
end_include

begin_include
include|#
directive|include
file|"screenshot-win32-resource.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"magnification-api-win32.h"
end_include

begin_comment
comment|/*  * Application definitions  */
end_comment

begin_define
DECL|macro|SELECT_FRAME
define|#
directive|define
name|SELECT_FRAME
value|0
end_define

begin_define
DECL|macro|SELECT_CLIENT
define|#
directive|define
name|SELECT_CLIENT
value|1
end_define

begin_define
DECL|macro|SELECT_WINDOW
define|#
directive|define
name|SELECT_WINDOW
value|2
end_define

begin_define
DECL|macro|SHOW_WINDOW
define|#
directive|define
name|SHOW_WINDOW
value|FALSE
end_define

begin_define
DECL|macro|APP_NAME
define|#
directive|define
name|APP_NAME
value|"plug_in_screenshot_win"
end_define

begin_define
DECL|macro|WM_DOCAPTURE
define|#
directive|define
name|WM_DOCAPTURE
value|(WM_USER + 100)
end_define

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
name|void
name|setCaptureType
parameter_list|(
name|int
name|capType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOL
name|InitApplication
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOL
name|InitInstance
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|,
name|int
name|nCmdShow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|winsnapWinMain
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* File variables */
end_comment

begin_decl_stmt
DECL|variable|captureType
specifier|static
name|int
name|captureType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|buffer
specifier|static
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|capBytes
specifier|static
name|guchar
modifier|*
name|capBytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|mainHwnd
specifier|static
name|HWND
name|mainHwnd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|hInst
specifier|static
name|HINSTANCE
name|hInst
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|selectCursor
specifier|static
name|HCURSOR
name|selectCursor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|iconInfo
specifier|static
name|ICONINFO
name|iconInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|returnedSrcheader
specifier|static
name|MAGIMAGEHEADER
name|returnedSrcheader
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rectScreens
specifier|static
name|RECT
modifier|*
name|rectScreens
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rectScreensCount
specifier|static
name|int
name|rectScreensCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|image_id
specifier|static
name|gint32
modifier|*
name|image_id
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sendBMPToGimp
parameter_list|(
name|HBITMAP
name|hBMP
parameter_list|,
name|HDC
name|hDC
parameter_list|,
name|RECT
name|rect
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doWindowCapture
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|doCapture
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|isWindowIsAboveCaptureRegion
parameter_list|(
name|HWND
name|hwndWindow
parameter_list|,
name|RECT
name|rectCapture
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|doCaptureMagnificationAPI
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|,
name|RECT
name|rect
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doCaptureMagnificationAPI_callback
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|void
modifier|*
name|srcdata
parameter_list|,
name|MAGIMAGEHEADER
name|srcheader
parameter_list|,
name|void
modifier|*
name|destdata
parameter_list|,
name|MAGIMAGEHEADER
name|destheader
parameter_list|,
name|RECT
name|unclipped
parameter_list|,
name|RECT
name|clipped
parameter_list|,
name|HRGN
name|dirty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|doCaptureBitBlt
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|,
name|RECT
name|rect
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOL
name|CALLBACK
name|dialogProc
parameter_list|(
name|HWND
parameter_list|,
name|UINT
parameter_list|,
name|WPARAM
parameter_list|,
name|LPARAM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|LRESULT
name|CALLBACK
name|WndProc
parameter_list|(
name|HWND
parameter_list|,
name|UINT
parameter_list|,
name|WPARAM
parameter_list|,
name|LPARAM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|CALLBACK
name|doCaptureMagnificationAPI_MonitorEnumProc
parameter_list|(
name|HMONITOR
parameter_list|,
name|HDC
parameter_list|,
name|LPRECT
parameter_list|,
name|LPARAM
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Data structure holding data between runs */
end_comment

begin_typedef
DECL|struct|__anon298c7d3b0108
typedef|typedef
struct|struct
block|{
DECL|member|root
name|gint
name|root
decl_stmt|;
DECL|member|delay
name|guint
name|delay
decl_stmt|;
DECL|member|decor
name|gint
name|decor
decl_stmt|;
DECL|typedef|WinSnapValues
block|}
name|WinSnapValues
typedef|;
end_typedef

begin_comment
comment|/* Default WinSnap values */
end_comment

begin_decl_stmt
DECL|variable|winsnapvals
specifier|static
name|WinSnapValues
name|winsnapvals
init|=
block|{
name|FALSE
block|,
literal|0
block|,
name|TRUE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dialog information */
end_comment

begin_typedef
DECL|struct|__anon298c7d3b0208
typedef|typedef
struct|struct
block|{
ifdef|#
directive|ifdef
name|CAN_SET_DECOR
DECL|member|decor_button
name|GtkWidget
modifier|*
name|decor_button
decl_stmt|;
endif|#
directive|endif
DECL|member|single_button
name|GtkWidget
modifier|*
name|single_button
decl_stmt|;
DECL|member|root_button
name|GtkWidget
modifier|*
name|root_button
decl_stmt|;
DECL|member|delay_spinner
name|GtkWidget
modifier|*
name|delay_spinner
decl_stmt|;
DECL|typedef|WinSnapInterface
block|}
name|WinSnapInterface
typedef|;
end_typedef

begin_comment
comment|/* We create a DIB section to hold the grabbed area. The scanlines in  * DIB sections are aligned on a LONG (four byte) boundary. Its pixel  * data is in RGB (BGR actually) format, three bytes per pixel.  *  * GIMP uses no alignment for its pixel regions. The GIMP image we  * create is of type RGB, i.e. three bytes per pixel, too. Thus in  * order to be able to quickly transfer all of the image at a time, we  * must use a DIB section and pixel region the scanline width in  * bytes of which is evenly divisible with both 3 and 4. I.e. it must  * be a multiple of 12 bytes, or in pixels, a multiple of four pixels.  */
end_comment

begin_define
DECL|macro|ROUND4 (width)
define|#
directive|define
name|ROUND4
parameter_list|(
name|width
parameter_list|)
value|(((width-1)/4+1)*4)
end_define

begin_function
name|gboolean
DECL|function|screenshot_win32_available (void)
name|screenshot_win32_available
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|ScreenshotCapabilities
DECL|function|screenshot_win32_get_capabilities (void)
name|screenshot_win32_get_capabilities
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|SCREENSHOT_CAN_SHOOT_DECORATIONS
operator||
name|SCREENSHOT_CAN_SHOOT_WINDOW
operator|)
return|;
block|}
end_function

begin_function
name|GimpPDBStatusType
DECL|function|screenshot_win32_shoot (ScreenshotValues * shootvals,GdkScreen * screen,gint32 * image_ID,GError ** error)
name|screenshot_win32_shoot
parameter_list|(
name|ScreenshotValues
modifier|*
name|shootvals
parameter_list|,
name|GdkScreen
modifier|*
name|screen
parameter_list|,
name|gint32
modifier|*
name|image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_EXECUTION_ERROR
decl_stmt|;
comment|/* leave "shootvals->monitor" alone until somebody patches the code    * to be able to get a monitor's color profile    */
name|image_id
operator|=
name|image_ID
expr_stmt|;
name|winsnapvals
operator|.
name|delay
operator|=
name|shootvals
operator|->
name|screenshot_delay
expr_stmt|;
if|if
condition|(
name|shootvals
operator|->
name|shoot_type
operator|==
name|SHOOT_ROOT
condition|)
block|{
name|doCapture
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shootvals
operator|->
name|shoot_type
operator|==
name|SHOOT_WINDOW
condition|)
block|{
name|doWindowCapture
argument_list|()
expr_stmt|;
name|status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shootvals
operator|->
name|shoot_type
operator|==
name|SHOOT_REGION
condition|)
block|{
comment|/* FIXME */
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
name|GimpColorProfile
modifier|*
name|profile
decl_stmt|;
comment|/* XXX No idea if the "monitor" value is right at all, especially        * considering above comment. Just make so that it at least        * compiles!        */
name|profile
operator|=
name|gimp_screen_get_color_profile
argument_list|(
name|screen
argument_list|,
name|shootvals
operator|->
name|monitor
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile
condition|)
block|{
name|gimp_image_set_color_profile
argument_list|(
operator|*
name|image_ID
argument_list|,
name|profile
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|profile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  * GIMP format and transfer functions  ******************************************************************/
end_comment

begin_comment
comment|/*  * flipRedAndBlueBytes  *  * Microsoft has chosen to provide us a very nice (not!)  * interface for retrieving bitmap bits.  DIBSections have  * RGB information as BGR instead.  So, we have to swap  * the silly red and blue bytes before sending to the  * GIMP.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|flipRedAndBlueBytes (int width,int height)
name|flipRedAndBlueBytes
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guchar
modifier|*
name|bufp
decl_stmt|;
name|guchar
name|temp
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|height
condition|)
block|{
name|i
operator|=
name|width
expr_stmt|;
name|bufp
operator|=
name|capBytes
operator|+
name|j
operator|*
name|ROUND4
argument_list|(
name|width
argument_list|)
operator|*
literal|3
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|temp
operator|=
name|bufp
index|[
literal|2
index|]
expr_stmt|;
name|bufp
index|[
literal|2
index|]
operator|=
name|bufp
index|[
literal|0
index|]
expr_stmt|;
name|bufp
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
name|bufp
operator|+=
literal|3
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * rgbaToRgbBytes  *  * Convert rgba array to rgb array  */
end_comment

begin_function
specifier|static
name|void
DECL|function|rgbaToRgbBytes (guchar * rgbBufp,guchar * rgbaBufp,int rgbaBufSize)
name|rgbaToRgbBytes
parameter_list|(
name|guchar
modifier|*
name|rgbBufp
parameter_list|,
name|guchar
modifier|*
name|rgbaBufp
parameter_list|,
name|int
name|rgbaBufSize
parameter_list|)
block|{
name|int
name|rgbPoint
init|=
literal|0
decl_stmt|,
name|rgbaPoint
decl_stmt|;
for|for
control|(
name|rgbaPoint
operator|=
literal|0
init|;
name|rgbaPoint
operator|<
name|rgbaBufSize
condition|;
name|rgbaPoint
operator|+=
literal|4
control|)
block|{
name|rgbBufp
index|[
name|rgbPoint
operator|++
index|]
operator|=
name|rgbaBufp
index|[
name|rgbaPoint
index|]
expr_stmt|;
name|rgbBufp
index|[
name|rgbPoint
operator|++
index|]
operator|=
name|rgbaBufp
index|[
name|rgbaPoint
operator|+
literal|1
index|]
expr_stmt|;
name|rgbBufp
index|[
name|rgbPoint
operator|++
index|]
operator|=
name|rgbaBufp
index|[
name|rgbaPoint
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * sendBMPToGIMP  *  * Take the captured data and send it across  * to GIMP.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|sendBMPToGimp (HBITMAP hBMP,HDC hDC,RECT rect)
name|sendBMPToGimp
parameter_list|(
name|HBITMAP
name|hBMP
parameter_list|,
name|HDC
name|hDC
parameter_list|,
name|RECT
name|rect
parameter_list|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|imageType
decl_stmt|,
name|layerType
decl_stmt|;
name|gint32
name|new_image_id
decl_stmt|;
name|gint32
name|layer_id
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|GeglRectangle
modifier|*
name|rectangle
decl_stmt|;
comment|/* Our width and height */
name|width
operator|=
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
expr_stmt|;
name|height
operator|=
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|)
expr_stmt|;
comment|/* Check that we got the memory */
if|if
condition|(
operator|!
name|capBytes
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"No data captured"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Flip the red and blue bytes */
name|flipRedAndBlueBytes
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Set up the image and layer types */
name|imageType
operator|=
name|GIMP_RGB
expr_stmt|;
name|layerType
operator|=
name|GIMP_RGB_IMAGE
expr_stmt|;
comment|/* Create the GIMP image and layers */
name|new_image_id
operator|=
name|gimp_image_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|imageType
argument_list|)
expr_stmt|;
name|layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|new_image_id
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|ROUND4
argument_list|(
name|width
argument_list|)
argument_list|,
name|height
argument_list|,
name|layerType
argument_list|,
literal|100
argument_list|,
name|gimp_image_get_default_new_layer_mode
argument_list|(
name|new_image_id
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|new_image_id
argument_list|,
name|layer_id
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make rectangle */
name|rectangle
operator|=
name|g_new
argument_list|(
name|GeglRectangle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rectangle
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|rectangle
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|rectangle
operator|->
name|width
operator|=
name|ROUND4
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|rectangle
operator|->
name|height
operator|=
name|height
expr_stmt|;
comment|/* get the buffer */
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
comment|/* fill the buffer */
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|rectangle
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|capBytes
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
comment|/* flushing data */
name|gegl_buffer_flush
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Now resize the layer down to the correct size if necessary. */
if|if
condition|(
name|width
operator|!=
name|ROUND4
argument_list|(
name|width
argument_list|)
condition|)
block|{
name|gimp_layer_resize
argument_list|(
name|layer_id
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_resize
argument_list|(
name|new_image_id
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|image_id
operator|=
name|new_image_id
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * doNonRootWindowCapture  *  * Capture a selected window.  * ENTRY POINT FOR WINSNAP NONROOT  *  */
end_comment

begin_function
specifier|static
name|void
DECL|function|doWindowCapture (void)
name|doWindowCapture
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Start up a standard Win32    * message handling loop for    * selection of the window    * to be captured    */
name|winsnapWinMain
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************  * Debug stuff  ******************************************************************/
end_comment

begin_comment
comment|/*  * formatWindowsError  *  * Format the latest Windows error message into  * a readable string.  Store in the provided  * buffer.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|formatWindowsError (char * buffer,int buf_size)
name|formatWindowsError
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|LPVOID
name|lpMsgBuf
decl_stmt|;
comment|/* Format the message */
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
operator||
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
argument_list|,
name|NULL
argument_list|,
name|GetLastError
argument_list|()
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
operator|(
name|LPTSTR
operator|)
operator|&
name|lpMsgBuf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy to the buffer */
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|lpMsgBuf
argument_list|,
name|buf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|LocalFree
argument_list|(
name|lpMsgBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************  * Bitmap capture and handling  ******************************************************************/
end_comment

begin_comment
comment|/*  * primDoWindowCapture  *  * The primitive window capture functionality.  Accepts  * the two device contexts and the rectangle to be  * captured.  */
end_comment

begin_function
specifier|static
name|HBITMAP
DECL|function|primDoWindowCapture (HDC hdcWindow,HDC hdcCompat,RECT rect)
name|primDoWindowCapture
parameter_list|(
name|HDC
name|hdcWindow
parameter_list|,
name|HDC
name|hdcCompat
parameter_list|,
name|RECT
name|rect
parameter_list|)
block|{
name|HBITMAP
name|hbmCopy
decl_stmt|;
name|HGDIOBJ
name|oldObject
decl_stmt|;
name|BITMAPINFO
name|bmi
decl_stmt|;
name|int
name|width
init|=
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
decl_stmt|;
name|int
name|height
init|=
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|)
decl_stmt|;
comment|/* Create the bitmap info header */
name|bmi
operator|.
name|bmiHeader
operator|.
name|biSize
operator|=
sizeof|sizeof
argument_list|(
name|BITMAPINFOHEADER
argument_list|)
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biWidth
operator|=
name|ROUND4
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biHeight
operator|=
operator|-
name|height
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biPlanes
operator|=
literal|1
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biBitCount
operator|=
literal|24
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biCompression
operator|=
name|BI_RGB
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biSizeImage
operator|=
literal|0
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biXPelsPerMeter
operator|=
name|bmi
operator|.
name|bmiHeader
operator|.
name|biYPelsPerMeter
operator|=
literal|0
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biClrUsed
operator|=
literal|0
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biClrImportant
operator|=
literal|0
expr_stmt|;
comment|/* Create the bitmap storage space */
name|hbmCopy
operator|=
name|CreateDIBSection
argument_list|(
name|hdcCompat
argument_list|,
operator|(
name|BITMAPINFO
operator|*
operator|)
operator|&
name|bmi
argument_list|,
name|DIB_RGB_COLORS
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|capBytes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hbmCopy
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error creating DIB section: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Select the bitmap into the compatible DC. */
name|oldObject
operator|=
name|SelectObject
argument_list|(
name|hdcCompat
argument_list|,
name|hbmCopy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldObject
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error selecting object: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Copy the data from the application to the bitmap.  Even if we did    * round up the width, BitBlt only the actual data.    */
if|if
condition|(
operator|!
name|BitBlt
argument_list|(
name|hdcCompat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|hdcWindow
argument_list|,
name|rect
operator|.
name|left
argument_list|,
name|rect
operator|.
name|top
argument_list|,
name|SRCCOPY
argument_list|)
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error copying bitmap: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Restore the original object */
name|SelectObject
argument_list|(
name|hdcCompat
argument_list|,
name|oldObject
argument_list|)
expr_stmt|;
return|return
name|hbmCopy
return|;
block|}
end_function

begin_comment
comment|/*  * doCapture  *  * Do the capture.  Accepts the window  * handle to be captured or the NULL value  * to specify the root window.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|doCapture (HWND selectedHwnd)
name|doCapture
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|)
block|{
name|RECT
name|rect
decl_stmt|;
comment|/* Try and get everything out of the way before the    * capture.    */
name|Sleep
argument_list|(
literal|500
operator|+
name|winsnapvals
operator|.
name|delay
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Are we capturing a window or the whole screen */
if|if
condition|(
name|selectedHwnd
condition|)
block|{
if|if
condition|(
operator|!
name|GetWindowRect
argument_list|(
name|selectedHwnd
argument_list|,
operator|&
name|rect
argument_list|)
condition|)
comment|/* For some reason it works only if we return here TRUE. strange... */
return|return
name|TRUE
return|;
comment|/* First try to capture the window with the magnification api.       *  This will solve the bug https://bugzilla.gnome.org/show_bug.cgi?id=793722/       */
if|if
condition|(
operator|!
name|doCaptureMagnificationAPI
argument_list|(
name|selectedHwnd
argument_list|,
name|rect
argument_list|)
condition|)
block|{
comment|/* If for some reason this capture method failed then           *  capture the window with the normal method:           */
name|HWND
name|previousHwnd
init|=
name|GetForegroundWindow
argument_list|()
decl_stmt|;
name|gboolean
name|success
decl_stmt|;
name|SetForegroundWindow
argument_list|(
name|selectedHwnd
argument_list|)
expr_stmt|;
name|BringWindowToTop
argument_list|(
name|selectedHwnd
argument_list|)
expr_stmt|;
name|success
operator|=
name|doCaptureBitBlt
argument_list|(
name|selectedHwnd
argument_list|,
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousHwnd
condition|)
name|SetForegroundWindow
argument_list|(
name|previousHwnd
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* Get the screen's rectangle */
name|rect
operator|.
name|top
operator|=
name|GetSystemMetrics
argument_list|(
name|SM_YVIRTUALSCREEN
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|GetSystemMetrics
argument_list|(
name|SM_YVIRTUALSCREEN
argument_list|)
operator|+
name|GetSystemMetrics
argument_list|(
name|SM_CYVIRTUALSCREEN
argument_list|)
expr_stmt|;
name|rect
operator|.
name|left
operator|=
name|GetSystemMetrics
argument_list|(
name|SM_XVIRTUALSCREEN
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|GetSystemMetrics
argument_list|(
name|SM_XVIRTUALSCREEN
argument_list|)
operator|+
name|GetSystemMetrics
argument_list|(
name|SM_CXVIRTUALSCREEN
argument_list|)
expr_stmt|;
return|return
name|doCaptureBitBlt
argument_list|(
name|selectedHwnd
argument_list|,
name|rect
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
comment|/* we should never get here... */
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|doCaptureBitBlt (HWND selectedHwnd,RECT rect)
name|doCaptureBitBlt
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|,
name|RECT
name|rect
parameter_list|)
block|{
name|HDC
name|hdcSrc
decl_stmt|;
name|HDC
name|hdcCompat
decl_stmt|;
name|HBITMAP
name|hbm
decl_stmt|;
comment|/* Get the device context for the whole screen    * even if we just want to capture a window.    * this will allow to capture applications that    * don't render to their main window's device    * context (e.g. browsers).   */
name|hdcSrc
operator|=
name|CreateDC
argument_list|(
name|TEXT
argument_list|(
literal|"DISPLAY"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdcSrc
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error getting device context: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hdcCompat
operator|=
name|CreateCompatibleDC
argument_list|(
name|hdcSrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdcCompat
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error getting compat device context: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Do the window capture */
name|hbm
operator|=
name|primDoWindowCapture
argument_list|(
name|hdcSrc
argument_list|,
name|hdcCompat
argument_list|,
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hbm
condition|)
return|return
name|FALSE
return|;
comment|/* Release the device context */
name|ReleaseDC
argument_list|(
name|selectedHwnd
argument_list|,
name|hdcSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbm
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sendBMPToGimp
argument_list|(
name|hbm
argument_list|,
name|hdcCompat
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|doCaptureMagnificationAPI_callback (HWND hwnd,void * srcdata,MAGIMAGEHEADER srcheader,void * destdata,MAGIMAGEHEADER destheader,RECT unclipped,RECT clipped,HRGN dirty)
name|doCaptureMagnificationAPI_callback
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|void
modifier|*
name|srcdata
parameter_list|,
name|MAGIMAGEHEADER
name|srcheader
parameter_list|,
name|void
modifier|*
name|destdata
parameter_list|,
name|MAGIMAGEHEADER
name|destheader
parameter_list|,
name|RECT
name|unclipped
parameter_list|,
name|RECT
name|clipped
parameter_list|,
name|HRGN
name|dirty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|srcdata
condition|)
return|return;
name|capBytes
operator|=
operator|(
name|guchar
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
name|srcheader
operator|.
name|cbSize
argument_list|)
expr_stmt|;
name|rgbaToRgbBytes
argument_list|(
name|capBytes
argument_list|,
name|srcdata
argument_list|,
name|srcheader
operator|.
name|cbSize
argument_list|)
expr_stmt|;
name|returnedSrcheader
operator|=
name|srcheader
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|BOOL
DECL|function|isWindowIsAboveCaptureRegion (HWND hwndWindow,RECT rectCapture)
name|isWindowIsAboveCaptureRegion
parameter_list|(
name|HWND
name|hwndWindow
parameter_list|,
name|RECT
name|rectCapture
parameter_list|)
block|{
name|RECT
name|rectWindow
decl_stmt|;
name|ZeroMemory
argument_list|(
operator|&
name|rectWindow
argument_list|,
sizeof|sizeof
argument_list|(
name|RECT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetWindowRect
argument_list|(
name|hwndWindow
argument_list|,
operator|&
name|rectWindow
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|rectWindow
operator|.
name|left
operator|>=
name|rectCapture
operator|.
name|left
operator|&&
name|rectWindow
operator|.
name|left
operator|<
name|rectCapture
operator|.
name|right
operator|)
operator|||
operator|(
name|rectWindow
operator|.
name|right
operator|<=
name|rectCapture
operator|.
name|right
operator|&&
name|rectWindow
operator|.
name|right
operator|>
name|rectCapture
operator|.
name|left
operator|)
operator|||
operator|(
name|rectWindow
operator|.
name|left
operator|<=
name|rectCapture
operator|.
name|left
operator|&&
name|rectWindow
operator|.
name|right
operator|>=
name|rectCapture
operator|.
name|right
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rectWindow
operator|.
name|top
operator|>=
name|rectCapture
operator|.
name|top
operator|&&
name|rectWindow
operator|.
name|top
operator|<
name|rectCapture
operator|.
name|bottom
operator|)
operator|||
operator|(
name|rectWindow
operator|.
name|bottom
operator|<=
name|rectCapture
operator|.
name|bottom
operator|&&
name|rectWindow
operator|.
name|bottom
operator|>
name|rectCapture
operator|.
name|top
operator|)
operator|||
operator|(
name|rectWindow
operator|.
name|top
operator|<=
name|rectCapture
operator|.
name|top
operator|&&
name|rectWindow
operator|.
name|bottom
operator|>=
name|rectCapture
operator|.
name|bottom
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|BOOL
name|CALLBACK
DECL|function|doCaptureMagnificationAPI_MonitorEnumProc (HMONITOR hMonitor,HDC hdcMonitor,LPRECT lprcMonitor,LPARAM dwData)
name|doCaptureMagnificationAPI_MonitorEnumProc
parameter_list|(
name|HMONITOR
name|hMonitor
parameter_list|,
name|HDC
name|hdcMonitor
parameter_list|,
name|LPRECT
name|lprcMonitor
parameter_list|,
name|LPARAM
name|dwData
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lprcMonitor
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|rectScreens
condition|)
name|rectScreens
operator|=
operator|(
name|RECT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RECT
argument_list|)
operator|*
operator|(
name|rectScreensCount
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|rectScreens
operator|=
operator|(
name|RECT
operator|*
operator|)
name|realloc
argument_list|(
name|rectScreens
argument_list|,
sizeof|sizeof
argument_list|(
name|RECT
argument_list|)
operator|*
operator|(
name|rectScreensCount
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rectScreens
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rectScreens
index|[
name|rectScreensCount
index|]
operator|=
operator|*
name|lprcMonitor
expr_stmt|;
name|rectScreensCount
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|doCaptureMagnificationAPI (HWND selectedHwnd,RECT rect)
name|doCaptureMagnificationAPI
parameter_list|(
name|HWND
name|selectedHwnd
parameter_list|,
name|RECT
name|rect
parameter_list|)
block|{
name|HWND
name|hwndMag
decl_stmt|;
name|HWND
name|hwndHost
decl_stmt|;
name|HWND
name|nextWindow
decl_stmt|;
name|HWND
name|excludeWins
index|[
literal|24
index|]
decl_stmt|;
name|int
name|excludeWinsCount
init|=
literal|0
decl_stmt|;
name|WINDOWPLACEMENT
name|windowplacment
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|xCenter
decl_stmt|;
name|int
name|yCenter
decl_stmt|;
if|if
condition|(
operator|!
name|LoadMagnificationLibrary
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MagInitialize
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* If the window is maximized then we need to fix the rect variable */
name|ZeroMemory
argument_list|(
operator|&
name|windowplacment
argument_list|,
sizeof|sizeof
argument_list|(
name|WINDOWPLACEMENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetWindowPlacement
argument_list|(
name|selectedHwnd
argument_list|,
operator|&
name|windowplacment
argument_list|)
operator|&&
name|windowplacment
operator|.
name|showCmd
operator|==
name|SW_SHOWMAXIMIZED
condition|)
block|{
comment|/* if this is not the first time we call this function for some reason then we reset the rectScreens array */
if|if
condition|(
name|rectScreensCount
condition|)
block|{
name|free
argument_list|(
name|rectScreens
argument_list|)
expr_stmt|;
name|rectScreens
operator|=
name|NULL
expr_stmt|;
name|rectScreensCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get the screens rects */
name|EnumDisplayMonitors
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|doCaptureMagnificationAPI_MonitorEnumProc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If for some reason the array size is 0 then we fill it with the desktop rect */
if|if
condition|(
operator|!
name|rectScreensCount
condition|)
block|{
name|rectScreens
operator|=
operator|(
name|RECT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RECT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetWindowRect
argument_list|(
name|GetDesktopWindow
argument_list|()
argument_list|,
name|rectScreens
argument_list|)
condition|)
comment|/* error: could not get rect screens */
return|return
name|FALSE
return|;
name|rectScreensCount
operator|=
literal|1
expr_stmt|;
block|}
name|xCenter
operator|=
name|rect
operator|.
name|left
operator|+
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
operator|/
literal|2
expr_stmt|;
name|yCenter
operator|=
name|rect
operator|.
name|top
operator|+
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* find on which screen the window exist */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rectScreensCount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|xCenter
operator|>
name|rectScreens
index|[
name|i
index|]
operator|.
name|left
operator|&&
name|xCenter
operator|<
name|rectScreens
index|[
name|i
index|]
operator|.
name|right
operator|&&
name|yCenter
operator|>
name|rectScreens
index|[
name|i
index|]
operator|.
name|top
operator|&&
name|yCenter
operator|<
name|rectScreens
index|[
name|i
index|]
operator|.
name|bottom
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|rectScreensCount
condition|)
comment|/* Error: did not found on which screen the window exist */
return|return
name|FALSE
return|;
if|if
condition|(
name|rectScreens
index|[
name|i
index|]
operator|.
name|left
operator|>
name|rect
operator|.
name|left
condition|)
name|rect
operator|.
name|left
operator|=
name|rectScreens
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|rectScreens
index|[
name|i
index|]
operator|.
name|right
operator|<
name|rect
operator|.
name|right
condition|)
name|rect
operator|.
name|right
operator|=
name|rectScreens
index|[
name|i
index|]
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|rectScreens
index|[
name|i
index|]
operator|.
name|top
operator|>
name|rect
operator|.
name|top
condition|)
name|rect
operator|.
name|top
operator|=
name|rectScreens
index|[
name|i
index|]
operator|.
name|top
expr_stmt|;
if|if
condition|(
name|rectScreens
index|[
name|i
index|]
operator|.
name|bottom
operator|<
name|rect
operator|.
name|bottom
condition|)
name|rect
operator|.
name|bottom
operator|=
name|rectScreens
index|[
name|i
index|]
operator|.
name|bottom
expr_stmt|;
block|}
name|rect
operator|.
name|right
operator|=
name|rect
operator|.
name|left
operator|+
name|ROUND4
argument_list|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* Create the host window that will store the mag child window */
name|hwndHost
operator|=
name|CreateWindowEx
argument_list|(
literal|0x08000000
operator||
literal|0x080000
operator||
literal|0x80
operator||
literal|0x20
argument_list|,
name|APP_NAME
argument_list|,
name|NULL
argument_list|,
literal|0x80000000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GetModuleHandle
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwndHost
condition|)
block|{
name|MagUninitialize
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|SetLayeredWindowAttributes
argument_list|(
name|hwndHost
argument_list|,
operator|(
name|COLORREF
operator|)
literal|0
argument_list|,
operator|(
name|BYTE
operator|)
literal|255
argument_list|,
operator|(
name|DWORD
operator|)
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Create the mag child window inside the host window */
name|hwndMag
operator|=
name|CreateWindow
argument_list|(
name|WC_MAGNIFIER
argument_list|,
name|TEXT
argument_list|(
literal|"MagnifierWindow"
argument_list|)
argument_list|,
name|WS_CHILD
comment|/*| MS_SHOWMAGNIFIEDCURSOR*/
comment|/*| WS_VISIBLE*/
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
argument_list|,
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
argument_list|,
name|hwndHost
argument_list|,
name|NULL
argument_list|,
name|GetModuleHandle
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set the callback function that will be called by the api to get the pixels */
if|if
condition|(
operator|!
name|MagSetImageScalingCallback
argument_list|(
name|hwndMag
argument_list|,
operator|(
name|MagImageScalingCallback
operator|)
name|doCaptureMagnificationAPI_callback
argument_list|)
condition|)
block|{
name|DestroyWindow
argument_list|(
name|hwndHost
argument_list|)
expr_stmt|;
name|MagUninitialize
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Add only windows that above the target window */
for|for
control|(
name|nextWindow
operator|=
name|GetNextWindow
argument_list|(
name|selectedHwnd
argument_list|,
name|GW_HWNDPREV
argument_list|)
init|;
name|nextWindow
operator|!=
name|NULL
condition|;
name|nextWindow
operator|=
name|GetNextWindow
argument_list|(
name|nextWindow
argument_list|,
name|GW_HWNDPREV
argument_list|)
control|)
if|if
condition|(
name|isWindowIsAboveCaptureRegion
argument_list|(
name|nextWindow
argument_list|,
name|rect
argument_list|)
condition|)
block|{
name|excludeWins
index|[
name|excludeWinsCount
operator|++
index|]
operator|=
name|nextWindow
expr_stmt|;
comment|/* This api can't work with more than 24 windows. we stop on the 24 window */
if|if
condition|(
name|excludeWinsCount
operator|>=
literal|24
condition|)
break|break;
block|}
if|if
condition|(
name|excludeWinsCount
condition|)
name|MagSetWindowFilterList
argument_list|(
name|hwndMag
argument_list|,
name|MW_FILTERMODE_EXCLUDE
argument_list|,
name|excludeWinsCount
argument_list|,
name|excludeWins
argument_list|)
expr_stmt|;
comment|/* Call the api to capture the window */
name|capBytes
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|MagSetWindowSource
argument_list|(
name|hwndMag
argument_list|,
name|rect
argument_list|)
operator|||
operator|!
name|capBytes
condition|)
block|{
name|DestroyWindow
argument_list|(
name|hwndHost
argument_list|)
expr_stmt|;
name|MagUninitialize
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Just to be safe, we reset the image size the size dimensions that the api gave*/
name|rect
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|rect
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|ROUND4
argument_list|(
name|returnedSrcheader
operator|.
name|width
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|returnedSrcheader
operator|.
name|height
expr_stmt|;
comment|/* Send it to Gimp */
name|sendBMPToGimp
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rect
argument_list|)
expr_stmt|;
name|DestroyWindow
argument_list|(
name|hwndHost
argument_list|)
expr_stmt|;
name|MagUninitialize
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  * Win32 entry point and setup...  ******************************************************************/
end_comment

begin_define
DECL|macro|DINV
define|#
directive|define
name|DINV
value|3
end_define

begin_comment
comment|/*  * highlightWindowFrame  *  * Highlight (or unhighlight) the specified  * window handle's frame.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|highlightWindowFrame (HWND hWnd)
name|highlightWindowFrame
parameter_list|(
name|HWND
name|hWnd
parameter_list|)
block|{
name|HDC
name|hdc
decl_stmt|;
name|RECT
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|IsWindow
argument_list|(
name|hWnd
argument_list|)
condition|)
return|return;
name|hdc
operator|=
name|GetWindowDC
argument_list|(
name|hWnd
argument_list|)
expr_stmt|;
name|GetWindowRect
argument_list|(
name|hWnd
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
name|OffsetRect
argument_list|(
operator|&
name|rc
argument_list|,
operator|-
name|rc
operator|.
name|left
argument_list|,
operator|-
name|rc
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsRectEmpty
argument_list|(
operator|&
name|rc
argument_list|)
condition|)
block|{
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|left
argument_list|,
name|rc
operator|.
name|top
argument_list|,
name|rc
operator|.
name|right
operator|-
name|rc
operator|.
name|left
argument_list|,
name|DINV
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|left
argument_list|,
name|rc
operator|.
name|bottom
operator|-
name|DINV
argument_list|,
name|DINV
argument_list|,
operator|-
operator|(
name|rc
operator|.
name|bottom
operator|-
name|rc
operator|.
name|top
operator|-
literal|2
operator|*
name|DINV
operator|)
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|right
operator|-
name|DINV
argument_list|,
name|rc
operator|.
name|top
operator|+
name|DINV
argument_list|,
name|DINV
argument_list|,
name|rc
operator|.
name|bottom
operator|-
name|rc
operator|.
name|top
operator|-
literal|2
operator|*
name|DINV
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
name|PatBlt
argument_list|(
name|hdc
argument_list|,
name|rc
operator|.
name|right
argument_list|,
name|rc
operator|.
name|bottom
operator|-
name|DINV
argument_list|,
operator|-
operator|(
name|rc
operator|.
name|right
operator|-
name|rc
operator|.
name|left
operator|)
argument_list|,
name|DINV
argument_list|,
name|DSTINVERT
argument_list|)
expr_stmt|;
block|}
name|ReleaseDC
argument_list|(
name|hWnd
argument_list|,
name|hdc
argument_list|)
expr_stmt|;
name|UpdateWindow
argument_list|(
name|hWnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setCaptureType  *  * Set the capture type.  Should be one of:  * SELECT_FRAME  * SELECT_CLIENT  * SELECT_WINDOW  */
end_comment

begin_function
name|void
DECL|function|setCaptureType (int capType)
name|setCaptureType
parameter_list|(
name|int
name|capType
parameter_list|)
block|{
name|captureType
operator|=
name|capType
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * myWindowFromPoint  *  * Map to the appropriate window from the  * specified point.  The chosen window is  * based on the current capture type.  */
end_comment

begin_function
specifier|static
name|HWND
DECL|function|myWindowFromPoint (POINT pt)
name|myWindowFromPoint
parameter_list|(
name|POINT
name|pt
parameter_list|)
block|{
name|HWND
name|myHwnd
decl_stmt|;
name|HWND
name|nextHwnd
decl_stmt|;
switch|switch
condition|(
name|captureType
condition|)
block|{
case|case
name|SELECT_FRAME
case|:
case|case
name|SELECT_CLIENT
case|:
name|nextHwnd
operator|=
name|WindowFromPoint
argument_list|(
name|pt
argument_list|)
expr_stmt|;
do|do
block|{
name|myHwnd
operator|=
name|nextHwnd
expr_stmt|;
name|nextHwnd
operator|=
name|GetParent
argument_list|(
name|myHwnd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nextHwnd
condition|)
do|;
return|return
name|myHwnd
return|;
break|break;
case|case
name|SELECT_WINDOW
case|:
return|return
name|WindowFromPoint
argument_list|(
name|pt
argument_list|)
return|;
break|break;
block|}
return|return
name|WindowFromPoint
argument_list|(
name|pt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dialogProc  *  * The window procedure for the window  * selection dialog box.  */
end_comment

begin_function
name|BOOL
name|CALLBACK
DECL|function|dialogProc (HWND hwndDlg,UINT msg,WPARAM wParam,LPARAM lParam)
name|dialogProc
parameter_list|(
name|HWND
name|hwndDlg
parameter_list|,
name|UINT
name|msg
parameter_list|,
name|WPARAM
name|wParam
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
specifier|static
name|int
name|mouseCaptured
decl_stmt|;
specifier|static
name|int
name|buttonDown
decl_stmt|;
specifier|static
name|HCURSOR
name|oldCursor
decl_stmt|;
specifier|static
name|RECT
name|bitmapRect
decl_stmt|;
specifier|static
name|HWND
name|highlightedHwnd
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|WM_INITDIALOG
case|:
block|{
name|int
name|nonclientHeight
decl_stmt|;
name|HWND
name|hwndGroup
decl_stmt|;
name|RECT
name|dlgRect
decl_stmt|;
name|RECT
name|clientRect
decl_stmt|;
name|RECT
name|groupRect
decl_stmt|;
name|BITMAP
name|bm
decl_stmt|;
comment|/* Set the mouse capture flag */
name|buttonDown
operator|=
literal|0
expr_stmt|;
name|mouseCaptured
operator|=
literal|0
expr_stmt|;
comment|/* Calculate the bitmap dimensions */
name|GetObject
argument_list|(
name|iconInfo
operator|.
name|hbmMask
argument_list|,
sizeof|sizeof
argument_list|(
name|BITMAP
argument_list|)
argument_list|,
operator|(
name|VOID
operator|*
operator|)
operator|&
name|bm
argument_list|)
expr_stmt|;
comment|/* Calculate the dialog window dimensions */
name|GetWindowRect
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|dlgRect
argument_list|)
expr_stmt|;
comment|/* Calculate the group box dimensions */
name|hwndGroup
operator|=
name|GetDlgItem
argument_list|(
name|hwndDlg
argument_list|,
name|IDC_GROUP
argument_list|)
expr_stmt|;
name|GetWindowRect
argument_list|(
name|hwndGroup
argument_list|,
operator|&
name|groupRect
argument_list|)
expr_stmt|;
name|OffsetRect
argument_list|(
operator|&
name|groupRect
argument_list|,
operator|-
name|dlgRect
operator|.
name|left
argument_list|,
operator|-
name|dlgRect
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* The client's rectangle */
name|GetClientRect
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|clientRect
argument_list|)
expr_stmt|;
comment|/* The non-client height */
name|nonclientHeight
operator|=
operator|(
name|dlgRect
operator|.
name|bottom
operator|-
name|dlgRect
operator|.
name|top
operator|)
operator|-
operator|(
name|clientRect
operator|.
name|bottom
operator|-
name|clientRect
operator|.
name|top
operator|)
expr_stmt|;
comment|/* Calculate the bitmap rectangle */
name|bitmapRect
operator|.
name|top
operator|=
operator|(
operator|(
name|groupRect
operator|.
name|top
operator|+
name|groupRect
operator|.
name|bottom
operator|)
operator|/
literal|2
operator|)
operator|-
operator|(
name|bm
operator|.
name|bmHeight
operator|/
literal|2
operator|)
expr_stmt|;
name|bitmapRect
operator|.
name|top
operator|-=
name|nonclientHeight
expr_stmt|;
name|bitmapRect
operator|.
name|bottom
operator|=
name|bitmapRect
operator|.
name|top
operator|+
name|bm
operator|.
name|bmHeight
expr_stmt|;
name|bitmapRect
operator|.
name|left
operator|=
operator|(
operator|(
name|groupRect
operator|.
name|left
operator|+
name|groupRect
operator|.
name|right
operator|)
operator|/
literal|2
operator|)
operator|-
operator|(
name|bm
operator|.
name|bmWidth
operator|/
literal|2
operator|)
expr_stmt|;
name|bitmapRect
operator|.
name|right
operator|=
name|bitmapRect
operator|.
name|left
operator|+
name|bm
operator|.
name|bmWidth
expr_stmt|;
block|}
break|break;
case|case
name|WM_LBUTTONDOWN
case|:
comment|/* Track the button down state */
name|buttonDown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|WM_LBUTTONUP
case|:
name|buttonDown
operator|=
literal|0
expr_stmt|;
comment|/* If we have mouse captured        * we do this stuff.        */
if|if
condition|(
name|mouseCaptured
condition|)
block|{
name|HWND
name|selectedHwnd
decl_stmt|;
name|POINT
name|cursorPos
decl_stmt|;
comment|/* Release the capture */
name|mouseCaptured
operator|=
literal|0
expr_stmt|;
name|SetCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
name|ReleaseCapture
argument_list|()
expr_stmt|;
comment|/* Remove the highlight */
if|if
condition|(
name|highlightedHwnd
condition|)
name|highlightWindowFrame
argument_list|(
name|highlightedHwnd
argument_list|)
expr_stmt|;
name|RedrawWindow
argument_list|(
name|hwndDlg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RDW_INVALIDATE
argument_list|)
expr_stmt|;
comment|/* Return the selected window */
name|GetCursorPos
argument_list|(
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
name|selectedHwnd
operator|=
name|myWindowFromPoint
argument_list|(
name|cursorPos
argument_list|)
expr_stmt|;
name|EndDialog
argument_list|(
name|hwndDlg
argument_list|,
operator|(
name|INT_PTR
operator|)
name|selectedHwnd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WM_MOUSEMOVE
case|:
comment|/* If the mouse is captured, show        * the window which is tracking        * under the mouse position.        */
if|if
condition|(
name|mouseCaptured
condition|)
block|{
name|HWND
name|currentHwnd
decl_stmt|;
name|POINT
name|cursorPos
decl_stmt|;
comment|/* Get the window */
name|GetCursorPos
argument_list|(
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
name|currentHwnd
operator|=
name|myWindowFromPoint
argument_list|(
name|cursorPos
argument_list|)
expr_stmt|;
comment|/* Do the highlighting */
if|if
condition|(
name|highlightedHwnd
operator|!=
name|currentHwnd
condition|)
block|{
if|if
condition|(
name|highlightedHwnd
condition|)
name|highlightWindowFrame
argument_list|(
name|highlightedHwnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentHwnd
condition|)
name|highlightWindowFrame
argument_list|(
name|currentHwnd
argument_list|)
expr_stmt|;
name|highlightedHwnd
operator|=
name|currentHwnd
expr_stmt|;
block|}
comment|/* If the mouse has not been captured,            * try to figure out if we should capture            * the mouse.            */
block|}
elseif|else
if|if
condition|(
name|buttonDown
condition|)
block|{
name|POINT
name|cursorPos
decl_stmt|;
comment|/* Get the current client position */
name|GetCursorPos
argument_list|(
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
name|ScreenToClient
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|cursorPos
argument_list|)
expr_stmt|;
comment|/* Check if within the rectangle formed            * by the bitmap            */
if|if
condition|(
name|PtInRect
argument_list|(
operator|&
name|bitmapRect
argument_list|,
name|cursorPos
argument_list|)
condition|)
block|{
name|mouseCaptured
operator|=
literal|1
expr_stmt|;
name|oldCursor
operator|=
name|SetCursor
argument_list|(
name|selectCursor
argument_list|)
expr_stmt|;
name|SetCapture
argument_list|(
name|hwndDlg
argument_list|)
expr_stmt|;
name|RedrawWindow
argument_list|(
name|hwndDlg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RDW_INVALIDATE
operator||
name|RDW_ERASE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|WM_PAINT
case|:
block|{
name|HDC
name|hDC
decl_stmt|;
name|PAINTSTRUCT
name|ps
decl_stmt|;
comment|/* If the mouse is not captured draw            * the cursor image            */
if|if
condition|(
operator|!
name|mouseCaptured
condition|)
block|{
name|hDC
operator|=
name|BeginPaint
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|DrawIconEx
argument_list|(
name|hDC
argument_list|,
name|bitmapRect
operator|.
name|left
argument_list|,
name|bitmapRect
operator|.
name|top
argument_list|,
name|selectCursor
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DI_NORMAL
argument_list|)
expr_stmt|;
name|EndPaint
argument_list|(
name|hwndDlg
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|WM_COMMAND
case|:
comment|/* Handle the cancel button */
switch|switch
condition|(
name|LOWORD
argument_list|(
name|wParam
argument_list|)
condition|)
block|{
case|case
name|IDCANCEL
case|:
name|EndDialog
argument_list|(
name|hwndDlg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|///* Don't use the normal WinMain from gimp.h */
end_comment

begin_comment
comment|//#define WinMain WinMain_no_thanks
end_comment

begin_comment
comment|//MAIN()
end_comment

begin_comment
comment|//#undef WinMain
end_comment

begin_comment
comment|/*  * WinMain  *  * The standard gimp plug-in WinMain won't quite cut it for  * this plug-in.  */
end_comment

begin_comment
comment|//int APIENTRY
end_comment

begin_comment
comment|//WinMain(HINSTANCE hInstance,
end_comment

begin_comment
comment|//  HINSTANCE hPrevInstance,
end_comment

begin_comment
comment|//  LPSTR     lpCmdLine,
end_comment

begin_comment
comment|//  int       nCmdShow)
end_comment

begin_comment
comment|//{
end_comment

begin_comment
comment|//  /*
end_comment

begin_comment
comment|//   * Normally, we would do all of the Windows-ish set up of
end_comment

begin_comment
comment|//   * the window classes and stuff here in WinMain.  But,
end_comment

begin_comment
comment|//   * the only time we really need the window and message
end_comment

begin_comment
comment|//   * queues is during the plug-in run.  So, all of that will
end_comment

begin_comment
comment|//   * be done during run().  This avoids all of the Windows
end_comment

begin_comment
comment|//   * setup stuff for the query().  Stash the instance handle now
end_comment

begin_comment
comment|//   * so it is available from the run() procedure.
end_comment

begin_comment
comment|//   */
end_comment

begin_comment
comment|//  hInst = hInstance;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  /*
end_comment

begin_comment
comment|//   * Now, call gimp_main... This is what the normal WinMain()
end_comment

begin_comment
comment|//   * would do.
end_comment

begin_comment
comment|//   */
end_comment

begin_comment
comment|////  return gimp_main(&PLUG_IN_INFO, __argc, __argv);
end_comment

begin_comment
comment|//}
end_comment

begin_comment
comment|/*  * InitApplication  *  * Initialize window data and register the window class  */
end_comment

begin_function
name|BOOL
DECL|function|InitApplication (HINSTANCE hInstance)
name|InitApplication
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|)
block|{
name|WNDCLASS
name|wc
decl_stmt|;
name|BOOL
name|retValue
decl_stmt|;
comment|/* Get some resources */
ifdef|#
directive|ifdef
name|_MSC_VER
comment|/* For some reason this works only with MSVC */
name|selectCursor
operator|=
name|LoadCursor
argument_list|(
name|hInstance
argument_list|,
name|MAKEINTRESOURCE
argument_list|(
name|IDC_SELECT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|selectCursor
operator|=
name|LoadCursor
argument_list|(
name|NULL
argument_list|,
name|IDC_CROSS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GetIconInfo
argument_list|(
name|selectCursor
argument_list|,
operator|&
name|iconInfo
argument_list|)
expr_stmt|;
comment|/*    * Fill in window class structure with parameters to describe    * the main window.    */
name|wc
operator|.
name|style
operator|=
name|CS_HREDRAW
operator||
name|CS_VREDRAW
expr_stmt|;
name|wc
operator|.
name|lpfnWndProc
operator|=
operator|(
name|WNDPROC
operator|)
name|WndProc
expr_stmt|;
name|wc
operator|.
name|cbClsExtra
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|cbWndExtra
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|hInstance
operator|=
name|hInstance
expr_stmt|;
name|wc
operator|.
name|hIcon
operator|=
name|LoadIcon
argument_list|(
name|NULL
argument_list|,
name|IDI_APPLICATION
argument_list|)
expr_stmt|;
name|wc
operator|.
name|hCursor
operator|=
name|LoadCursor
argument_list|(
name|NULL
argument_list|,
name|IDC_ARROW
argument_list|)
expr_stmt|;
name|wc
operator|.
name|hbrBackground
operator|=
call|(
name|HBRUSH
call|)
argument_list|(
name|COLOR_WINDOW
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wc
operator|.
name|lpszClassName
operator|=
name|APP_NAME
expr_stmt|;
name|wc
operator|.
name|lpszMenuName
operator|=
name|NULL
expr_stmt|;
comment|/* Register the window class and stash success/failure code. */
name|retValue
operator|=
name|RegisterClass
argument_list|(
operator|&
name|wc
argument_list|)
expr_stmt|;
comment|/* Log error */
if|if
condition|(
operator|!
name|retValue
condition|)
block|{
name|formatWindowsError
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"Error registering class: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/*  * InitInstance  *  * Create the main window for the application.  */
end_comment

begin_function
name|BOOL
DECL|function|InitInstance (HINSTANCE hInstance,int nCmdShow)
name|InitInstance
parameter_list|(
name|HINSTANCE
name|hInstance
parameter_list|,
name|int
name|nCmdShow
parameter_list|)
block|{
name|HINSTANCE
name|User32Library
init|=
name|LoadLibrary
argument_list|(
literal|"user32.dll"
argument_list|)
decl_stmt|;
if|if
condition|(
name|User32Library
condition|)
block|{
DECL|typedef|SET_PROC_DPI_AWARE
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|SET_PROC_DPI_AWARE
function_decl|)
parameter_list|()
function_decl|;
name|SET_PROC_DPI_AWARE
name|SetProcessDPIAware
decl_stmt|;
comment|/* This line fix bug: https://bugzilla.gnome.org/show_bug.cgi?id=796121#c4 */
name|SetProcessDPIAware
operator|=
operator|(
name|SET_PROC_DPI_AWARE
operator|)
name|GetProcAddress
argument_list|(
name|User32Library
argument_list|,
literal|"SetProcessDPIAware"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SetProcessDPIAware
condition|)
name|SetProcessDPIAware
argument_list|()
expr_stmt|;
name|FreeLibrary
argument_list|(
name|User32Library
argument_list|)
expr_stmt|;
block|}
comment|/* Create our window */
name|mainHwnd
operator|=
name|CreateWindow
argument_list|(
name|APP_NAME
argument_list|,
name|APP_NAME
argument_list|,
name|WS_OVERLAPPEDWINDOW
argument_list|,
name|CW_USEDEFAULT
argument_list|,
literal|0
argument_list|,
name|CW_USEDEFAULT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|hInstance
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mainHwnd
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|ShowWindow
argument_list|(
name|mainHwnd
argument_list|,
name|nCmdShow
argument_list|)
expr_stmt|;
name|UpdateWindow
argument_list|(
name|mainHwnd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * winsnapWinMain  *  * This is the function that represents the code that  * would normally reside in WinMain (see above).  This  * function will get called during run() in order to set  * up the windowing environment necessary for WinSnap to  * operate.  */
end_comment

begin_function
name|int
DECL|function|winsnapWinMain (void)
name|winsnapWinMain
parameter_list|(
name|void
parameter_list|)
block|{
name|MSG
name|msg
decl_stmt|;
comment|/* Perform instance initialization */
if|if
condition|(
operator|!
name|InitApplication
argument_list|(
name|hInst
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Perform application initialization */
if|if
condition|(
operator|!
name|InitInstance
argument_list|(
name|hInst
argument_list|,
name|SHOW_WINDOW
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Main message loop */
while|while
condition|(
name|GetMessage
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TranslateMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|DispatchMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|.
name|wParam
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * WndProc  *  * Process window message for the main window.  */
end_comment

begin_function
name|LRESULT
name|CALLBACK
DECL|function|WndProc (HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam)
name|WndProc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|UINT
name|message
parameter_list|,
name|WPARAM
name|wParam
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
name|HWND
name|selectedHwnd
decl_stmt|;
switch|switch
condition|(
name|message
condition|)
block|{
case|case
name|WM_CREATE
case|:
comment|/* The window is created... Send the capture message */
name|PostMessage
argument_list|(
name|hwnd
argument_list|,
name|WM_DOCAPTURE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WM_DOCAPTURE
case|:
comment|/* Get the selected window handle */
name|selectedHwnd
operator|=
operator|(
name|HWND
operator|)
name|DialogBox
argument_list|(
name|hInst
argument_list|,
name|MAKEINTRESOURCE
argument_list|(
name|IDD_SELECT
argument_list|)
argument_list|,
name|hwnd
argument_list|,
operator|(
name|DLGPROC
operator|)
name|dialogProc
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectedHwnd
condition|)
name|doCapture
argument_list|(
name|selectedHwnd
argument_list|)
expr_stmt|;
name|PostQuitMessage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WM_DESTROY
case|:
name|PostQuitMessage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DefWindowProc
argument_list|(
name|hwnd
argument_list|,
name|message
argument_list|,
name|wParam
argument_list|,
name|lParam
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* G_OS_WIN32 */
end_comment

end_unit

