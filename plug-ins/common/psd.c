begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PSD Plugin version 3.0.14  * This GIMP plug-in is designed to load Adobe Photoshop(tm) files (.PSD)  *  * Adam D. Moss<adam@gimp.org><adam@foxbox.org>  *  *     If this plug-in fails to load a file which you think it should,  *     please file a Bugzilla bug describing what seemed to go wrong,  *     and anything you know about the image you tried to load.  Attach a  *     problematic PSD file to the bug report.  *  *          Copyright (C) 1997-2004 Adam D. Moss  *          Copyright (C) 1996      Torsten Martinsen  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Adobe and Adobe Photoshop are trademarks of Adobe Systems  * Incorporated that may be registered in certain jurisdictions.  */
end_comment

begin_comment
comment|/*  * Revision history:  *  *  2004-02-12 / v3.0.14 / Adam D. Moss  *       Fix a twisted utf8-obsessive bug diagnosed by  *       Piotr Krysiuk<KrysiukP@prokom.pl>  *  *  2004-01-06 / v3.0.13 / Adam D. Moss  *       Disable one of the PanoTools fixes by default, since it causes  *       regressions in some ordinary PSD file loading.  *  *  2004-01-06 / v3.0.12 / Adam D. Moss  *       Try to avoid 0-sized drawables (including channels) in all  *       circumstances under GIMP 2.  *  *  2004-01-01 / v3.0.11 / Daniel Rogers<dsrogers@phaseveloctiy.org>  *       GIMP crashes on 0x0 layers, so we skip them.  *  *  2003-11-27 / v3.0.10 / Adam D. Moss  *       GIMP 1.3/2.0 needs its layer/channel names to be UTF8 or it  *       fails wackily, so convert the strings from the PSD file to  *       UTF8 instead of using them raw.  *  *  2003-10-05 / v3.0.9 / Morten Eriksen  *       Fixed memory corruption bug: too little memory was allocated  *       for the bitmap image buffer if (imgwidth % 8 != 0) for  *       monocolor PSD images.  *  *  2003-08-31 / v3.0.8 / applied (modified) patch from Andy Wallis  *       Fix for handling of layer masks. See bug #68538.  *  *  2003-06-16 / v3.0.7 / Adam D. Moss  *       Avoid memory corruption when things get shot to hell in the  *       image unpacking phase.  Major version bumped to distinguish  *       GIMP 1.3 development thread.  *  *  2000-08-23 / v2.0.6 / Adam D. Moss  *       Eliminate more debugging output (don't people have more  *       substantial problems to report?  I'm poised at my keyboard).  *  *  1999-11-14 / v2.0.5 / Adam D. Moss  *       Applied patch by Andy Hefner to load 1-bit images.  *  *  1999-08-13 / v2.0.4 / Adam D. Moss  *       Allowed NULL layer names again, whee.  (Also fixed the time machine.)  *  *  1999-08-20 / v2.0.3 / Adam D. Moss  *       Ensure that NULL name does not get passed to gimp_layer_new(),  *       or it will fail to create the layer and cause problems down  *       the line (only since April 1999).  *  *  1999-01-18 / v2.0.2 / Adam D. Moss  *       Better guess at how PSD files store Guide position precision.  *  *  1999-01-10 / v2.0.1 / Adam D. Moss  *       Greatly reduced memory requirements for layered image loading -  *       we now do just-in-time channel unpacking.  Some little  *       cleanups too.  *  *  1998-09-04 / v2.0.0 / Adam D. Moss  *       Now recognises and loads the new Guides extensions written  *       by Photoshop 4 and 5.  *  *  1998-07-31 / v1.9.9.9f / Adam D. Moss  *       Use GIMP_OVERLAY_MODE if available.  *  *  1998-07-31 / v1.9.9.9e / Adam D. Moss  *       Worked around some buggy PSD savers (suspect PS4 on Mac) - ugh.  *       Fixed a bug when loading layer masks of certain dimensions.  *  *  1998-05-04 / v1.9.9.9b / Adam D. Moss  *       Changed the Pascal-style string-reading stuff.  That fixed  *       some file-padding problems.  Made all debugging output  *       compile-time optional (please leave it enabled for now).  *       Reduced memory requirements; still much room for improvement.  *  *  1998-04-28 / v1.9.9.9 / Adam D. Moss  *       Fixed the correct channel interlacing of 'raw' flat images.  *       Thanks to Christian Kirsch and Jay Cox for spotting this.  *       Changed some of the I/O routines.  *  *  1998-04-26 / v1.9.9.8 / Adam D. Moss  *       Implemented Aux-channels for layered files.  Got rid  *       of<endian.h> nonsense.  Improved Layer Mask padding.  *       Enforced num_layers/num_channels limit checks.  *  *  1998-04-23 / v1.9.9.5 / Adam D. Moss  *       Got Layer Masks working, got Aux-channels working  *       for unlayered files, fixed 'raw' channel loading, fixed  *       some other mini-bugs, slightly better progress meters.  *       Thanks to everyone who is helping with the testing!  *  *  1998-04-21 / v1.9.9.1 / Adam D. Moss  *       A little cleanup.  Implemented Layer Masks but disabled  *       them again - PS masks can be a different size to their  *       owning layer, unlike those in GIMP.  *  *  1998-04-19 / v1.9.9.0 / Adam D. Moss  *       Much happier now.  *  *  1997-03-13 / v1.9.0 / Adam D. Moss  *       Layers, channels and masks, oh my.  *       + Bugfixes& rearchitecturing.  *  *  1997-01-30 / v1.0.12 / Torsten Martinsen  *       Flat PSD image loading.  */
end_comment

begin_comment
comment|/*  * TODO:  *  *      Crush 16bpp channels *  *	CMYK -> RGB *  *      * I don't think these should be done lossily -- wait for  *        GIMP to be able to support them natively.  *  *      Read in the paths.  *  *      File saving (someone has an alpha plugin for this)  */
end_comment

begin_comment
comment|/*  * BUGS:  *  *      Sometimes creates a superfluous aux channel?  Harmless.  */
end_comment

begin_comment
comment|/* *** USER DEFINES *** */
end_comment

begin_comment
comment|/* set to TRUE if you want debugging, FALSE otherwise */
end_comment

begin_define
DECL|macro|PSD_DEBUG
define|#
directive|define
name|PSD_DEBUG
value|FALSE
end_define

begin_comment
comment|/* the max number of channels that this plugin should let a layer have */
end_comment

begin_define
DECL|macro|MAX_CHANNELS
define|#
directive|define
name|MAX_CHANNELS
value|30
end_define

begin_comment
comment|/* set to TRUE to allow a fix for transparency in PSD files    generated by PanoTools that unfortunately causes regressions    in some other ordinary files saved by Photoshop. */
end_comment

begin_define
DECL|macro|PANOTOOLS_FIX
define|#
directive|define
name|PANOTOOLS_FIX
value|FALSE
end_define

begin_comment
comment|/* *** END OF USER DEFINES *** */
end_comment

begin_define
DECL|macro|IFDBG
define|#
directive|define
name|IFDBG
value|if (PSD_DEBUG)
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* Local types etc  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c2814e50103
block|{
DECL|enumerator|PSD_UNKNOWN_IMAGE
name|PSD_UNKNOWN_IMAGE
block|,
DECL|enumerator|PSD_RGB_IMAGE
name|PSD_RGB_IMAGE
block|,
DECL|enumerator|PSD_RGBA_IMAGE
name|PSD_RGBA_IMAGE
block|,
DECL|enumerator|PSD_GRAY_IMAGE
name|PSD_GRAY_IMAGE
block|,
DECL|enumerator|PSD_GRAYA_IMAGE
name|PSD_GRAYA_IMAGE
block|,
DECL|enumerator|PSD_INDEXED_IMAGE
name|PSD_INDEXED_IMAGE
block|,
DECL|enumerator|PSD_INDEXEDA_IMAGE
name|PSD_INDEXEDA_IMAGE
block|,
DECL|enumerator|PSD_BITMAP_IMAGE
name|PSD_BITMAP_IMAGE
DECL|typedef|psd_imagetype
block|}
name|psd_imagetype
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdChannel
typedef|typedef
struct|struct
name|PsdChannel
block|{
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|data
name|guchar
modifier|*
name|data
decl_stmt|;
DECL|member|type
name|gint
name|type
decl_stmt|;
DECL|member|compressedsize
name|guint32
name|compressedsize
decl_stmt|;
DECL|member|fpos
name|fpos_t
name|fpos
decl_stmt|;
comment|/* Remember where the data is in the file, so we can 		  come back to it! */
comment|/* We can't just assume that the channel's width and height are the   * same as those of the layer that owns the channel, since this   * channel may be a layer mask, which Photoshop allows to have a   * different size from the layer which it applies to.   */
DECL|member|width
name|guint32
name|width
decl_stmt|;
DECL|member|height
name|guint32
name|height
decl_stmt|;
DECL|typedef|PSDchannel
block|}
name|PSDchannel
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdGuide
typedef|typedef
struct|struct
name|PsdGuide
block|{
DECL|member|horizontal
name|gboolean
name|horizontal
decl_stmt|;
comment|/* else vertical */
DECL|member|position
name|gint
name|position
decl_stmt|;
DECL|typedef|PSDguide
block|}
name|PSDguide
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdLayer
typedef|typedef
struct|struct
name|PsdLayer
block|{
DECL|member|num_channels
name|gint
name|num_channels
decl_stmt|;
DECL|member|channel
name|PSDchannel
modifier|*
name|channel
decl_stmt|;
DECL|member|x
name|gint32
name|x
decl_stmt|;
DECL|member|y
name|gint32
name|y
decl_stmt|;
DECL|member|width
name|guint32
name|width
decl_stmt|;
DECL|member|height
name|guint32
name|height
decl_stmt|;
DECL|member|blendkey
name|gchar
name|blendkey
index|[
literal|4
index|]
decl_stmt|;
DECL|member|opacity
name|guchar
name|opacity
decl_stmt|;
DECL|member|clipping
name|gchar
name|clipping
decl_stmt|;
DECL|member|protecttrans
name|gboolean
name|protecttrans
decl_stmt|;
DECL|member|visible
name|gboolean
name|visible
decl_stmt|;
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|lm_x
name|gint32
name|lm_x
decl_stmt|;
DECL|member|lm_y
name|gint32
name|lm_y
decl_stmt|;
DECL|member|lm_width
name|gint32
name|lm_width
decl_stmt|;
DECL|member|lm_height
name|gint32
name|lm_height
decl_stmt|;
DECL|typedef|PSDlayer
block|}
name|PSDlayer
typedef|;
end_typedef

begin_typedef
DECL|typedef|Fixed
typedef|typedef
name|gint32
name|Fixed
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c2814e50208
block|{
DECL|member|hRes
name|Fixed
name|hRes
decl_stmt|;
DECL|member|hRes_unit
name|gint16
name|hRes_unit
decl_stmt|;
DECL|member|widthUnit
name|gint16
name|widthUnit
decl_stmt|;
DECL|member|vRes
name|Fixed
name|vRes
decl_stmt|;
DECL|member|vRes_unit
name|gint16
name|vRes_unit
decl_stmt|;
DECL|member|heightUnit
name|gint16
name|heightUnit
decl_stmt|;
comment|/* Res_unit : 	1 == Pixels per inch         2 == Pixels per cm */
DECL|typedef|PSDresolution
block|}
name|PSDresolution
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdImage
typedef|typedef
struct|struct
name|PsdImage
block|{
DECL|member|num_layers
name|gint
name|num_layers
decl_stmt|;
DECL|member|layer
name|PSDlayer
modifier|*
name|layer
decl_stmt|;
DECL|member|absolute_alpha
name|gboolean
name|absolute_alpha
decl_stmt|;
DECL|member|type
name|gint
name|type
decl_stmt|;
DECL|member|colmaplen
name|gulong
name|colmaplen
decl_stmt|;
DECL|member|colmapdata
name|guchar
modifier|*
name|colmapdata
decl_stmt|;
DECL|member|num_aux_channels
name|guint
name|num_aux_channels
decl_stmt|;
DECL|member|aux_channel
name|PSDchannel
name|aux_channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
DECL|member|num_guides
name|guint
name|num_guides
decl_stmt|;
DECL|member|guides
name|PSDguide
modifier|*
name|guides
decl_stmt|;
DECL|member|caption
name|gchar
modifier|*
name|caption
decl_stmt|;
DECL|member|active_layer_num
name|guint
name|active_layer_num
decl_stmt|;
DECL|member|resolution_is_set
name|guint
name|resolution_is_set
decl_stmt|;
DECL|member|resolution
name|PSDresolution
name|resolution
decl_stmt|;
DECL|typedef|PSDimage
block|}
name|PSDimage
typedef|;
end_typedef

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImageType
name|psd_type_to_gimp_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImageBaseType
name|psd_type_to_gimp_base_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpLayerModeEffects
name|psd_lmode_to_gimp_lmode
parameter_list|(
name|gchar
name|modekey
index|[
literal|4
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpUnit
name|psd_unit_to_gimp_unit
parameter_list|(
name|gint
name|psdunit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Various local variables...  */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|psd_image
specifier|static
name|PSDimage
name|psd_image
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2c2814e50308
block|{
DECL|member|signature
name|gchar
name|signature
index|[
literal|4
index|]
decl_stmt|;
DECL|member|version
name|gushort
name|version
decl_stmt|;
DECL|member|reserved
name|guchar
name|reserved
index|[
literal|6
index|]
decl_stmt|;
DECL|member|channels
name|gushort
name|channels
decl_stmt|;
DECL|member|rows
name|gulong
name|rows
decl_stmt|;
DECL|member|columns
name|gulong
name|columns
decl_stmt|;
DECL|member|bpp
name|gushort
name|bpp
decl_stmt|;
DECL|member|mode
name|gushort
name|mode
decl_stmt|;
DECL|member|imgreslen
name|gulong
name|imgreslen
decl_stmt|;
DECL|member|miscsizelen
name|gulong
name|miscsizelen
decl_stmt|;
DECL|member|compression
name|gushort
name|compression
decl_stmt|;
DECL|member|rowlength
name|gushort
modifier|*
name|rowlength
decl_stmt|;
DECL|member|imgdatalen
name|long
name|imgdatalen
decl_stmt|;
DECL|variable|PSDheader
block|}
name|PSDheader
struct|;
end_struct

begin_decl_stmt
DECL|variable|modename
specifier|static
name|gchar
modifier|*
name|modename
index|[]
init|=
block|{
literal|"Bitmap"
block|,
literal|"Grayscale"
block|,
literal|"Indexed Colour"
block|,
literal|"RGB Colour"
block|,
literal|"CMYK Colour"
block|,
literal|"<invalid>"
block|,
literal|"<invalid>"
block|,
literal|"Multichannel"
block|,
literal|"Duotone"
block|,
literal|"Lab Colour"
block|,
literal|"<invalid>"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|prog_name
specifier|static
specifier|const
name|gchar
modifier|*
name|prog_name
init|=
literal|"PSD"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|unpack_pb_channel
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint32
name|unpackedlen
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode
parameter_list|(
name|long
name|clen
parameter_list|,
name|long
name|uclen
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|packbitsdecode
parameter_list|(
name|long
modifier|*
name|clenp
parameter_list|,
name|long
name|uclen
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmyk2rgb
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|destp
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmykp2rgb
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|destp
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bitmap2gray
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|long
name|w
parameter_list|,
name|long
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
name|getguchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gshort
name|getgshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|getglong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfread
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfread_interlaced
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|,
name|gint
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_whole_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reshuffle_cmap
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|getpascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|getstring
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|throwchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seek_to_and_unpack_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint
name|layeri
parameter_list|,
name|gint
name|channeli
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|}
decl_stmt|;
specifier|static
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"loads files of the Photoshop(tm) PSD file format"
argument_list|,
literal|"This filter loads files of Adobe Photoshop(tm) native PSD format.  These files may be of any image type supported by GIMP, with or without layers, layer masks, aux channels and guides."
argument_list|,
literal|"Adam D. Moss& Torsten Martinsen"
argument_list|,
literal|"Adam D. Moss& Torsten Martinsen"
argument_list|,
literal|"1996-1998"
argument_list|,
literal|"Photoshop image"
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_return_vals
argument_list|)
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"image/x-psd"
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"psd"
argument_list|,
literal|""
argument_list|,
literal|"0,string,8BPS"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
comment|/*  GimpPDBStatusType status = GIMP_PDB_SUCCESS;*/
name|gint32
name|image_ID
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_psd_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
DECL|function|sanitise_string (char * old_name)
name|sanitise_string
parameter_list|(
name|char
modifier|*
name|old_name
parameter_list|)
block|{
if|if
condition|(
name|old_name
condition|)
block|{
name|char
modifier|*
name|rtn
init|=
name|gimp_any_to_utf8
argument_list|(
name|old_name
argument_list|,
operator|-
literal|1
argument_list|,
name|_
argument_list|(
literal|"Invalid UTF-8 string in PSD file"
argument_list|)
argument_list|)
decl_stmt|;
name|g_free
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
return|return
name|rtn
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GimpImageType
DECL|function|psd_type_to_gimp_type (psd_imagetype psdtype)
name|psd_type_to_gimp_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
name|PSD_RGBA_IMAGE
case|:
return|return
operator|(
name|GIMP_RGBA_IMAGE
operator|)
return|;
case|case
name|PSD_RGB_IMAGE
case|:
return|return
operator|(
name|GIMP_RGB_IMAGE
operator|)
return|;
case|case
name|PSD_GRAYA_IMAGE
case|:
return|return
operator|(
name|GIMP_GRAYA_IMAGE
operator|)
return|;
case|case
name|PSD_GRAY_IMAGE
case|:
return|return
operator|(
name|GIMP_GRAY_IMAGE
operator|)
return|;
case|case
name|PSD_INDEXEDA_IMAGE
case|:
return|return
operator|(
name|GIMP_INDEXEDA_IMAGE
operator|)
return|;
case|case
name|PSD_INDEXED_IMAGE
case|:
return|return
operator|(
name|GIMP_INDEXED_IMAGE
operator|)
return|;
case|case
name|PSD_BITMAP_IMAGE
case|:
return|return
operator|(
name|GIMP_GRAY_IMAGE
operator|)
return|;
default|default:
return|return
operator|(
name|GIMP_RGB_IMAGE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GimpLayerModeEffects
DECL|function|psd_lmode_to_gimp_lmode (gchar modekey[4])
name|psd_lmode_to_gimp_lmode
parameter_list|(
name|gchar
name|modekey
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"norm"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_NORMAL_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"dark"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_DARKEN_ONLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"lite"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_LIGHTEN_ONLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hue "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_HUE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sat "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_SATURATION_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"colr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_COLOR_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"mul "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_MULTIPLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"scrn"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_SCREEN_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"diss"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_DISSOLVE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"diff"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_DIFFERENCE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"lum "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_VALUE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_HARDLIGHT_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_SOFTLIGHT_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"over"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|GIMP_OVERLAY_MODE
operator|)
return|;
name|printf
argument_list|(
literal|"PSD: Warning - UNKNOWN layer-blend mode, reverting to 'normal'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|GIMP_NORMAL_MODE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpImageBaseType
DECL|function|psd_type_to_gimp_base_type (psd_imagetype psdtype)
name|psd_type_to_gimp_base_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
name|PSD_RGBA_IMAGE
case|:
case|case
name|PSD_RGB_IMAGE
case|:
return|return
operator|(
name|GIMP_RGB
operator|)
return|;
case|case
name|PSD_BITMAP_IMAGE
case|:
case|case
name|PSD_GRAYA_IMAGE
case|:
case|case
name|PSD_GRAY_IMAGE
case|:
return|return
operator|(
name|GIMP_GRAY
operator|)
return|;
case|case
name|PSD_INDEXEDA_IMAGE
case|:
case|case
name|PSD_INDEXED_IMAGE
case|:
return|return
operator|(
name|GIMP_INDEXED
operator|)
return|;
default|default:
name|g_message
argument_list|(
literal|"Error: Can't convert PSD imagetype to GIMP imagetype"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
operator|(
name|GIMP_RGB
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GimpUnit
DECL|function|psd_unit_to_gimp_unit (int psdunit)
name|psd_unit_to_gimp_unit
parameter_list|(
name|int
name|psdunit
parameter_list|)
block|{
switch|switch
condition|(
name|psdunit
condition|)
block|{
case|case
literal|1
case|:
return|return
name|GIMP_UNIT_INCH
return|;
case|case
literal|2
case|:
comment|/* this means cm to PS, but MM is as close as we have */
return|return
name|GIMP_UNIT_MM
return|;
case|case
literal|3
case|:
return|return
name|GIMP_UNIT_POINT
return|;
case|case
literal|4
case|:
return|return
name|GIMP_UNIT_PICA
return|;
case|case
literal|5
case|:
comment|/* 5 == Columns, but what the heck is a column? */
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"Warning: unable to convert psd unit %d to gimp unit\n"
argument_list|,
name|psdunit
argument_list|)
decl_stmt|;
return|return
name|GIMP_UNIT_PIXEL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GimpImageBaseType
DECL|function|psd_mode_to_gimp_base_type (gushort psdtype)
name|psd_mode_to_gimp_base_type
parameter_list|(
name|gushort
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
literal|1
case|:
return|return
name|GIMP_GRAY
return|;
case|case
literal|2
case|:
return|return
name|GIMP_INDEXED
return|;
case|case
literal|3
case|:
return|return
name|GIMP_RGB
return|;
default|default:
name|g_message
argument_list|(
literal|"Error: Can't convert PSD mode to GIMP base imagetype"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
name|GIMP_RGB
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|reshuffle_cmap (guchar * map256)
name|reshuffle_cmap
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpmap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmpmap
operator|=
name|g_malloc
argument_list|(
literal|3
operator|*
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|tmpmap
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|map256
index|[
name|i
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|256
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|512
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|map256
argument_list|,
name|tmpmap
argument_list|,
literal|3
operator|*
literal|256
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dispatch_resID (guint ID,FILE * fd,guint32 * offset,guint32 Size)
name|dispatch_resID
parameter_list|(
name|guint
name|ID
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|,
name|guint32
name|Size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ID
operator|<
literal|0x0bb6
operator|)
operator|&&
operator|(
name|ID
operator|>
literal|0x07d0
operator|)
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tPath data is irrelevant to GIMP at this time.\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res path throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|ID
condition|)
block|{
case|case
literal|0x03ee
case|:
block|{
name|gint32
name|remaining
init|=
name|Size
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tALPHA CHANNEL NAMES:\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|guchar
name|slen
decl_stmt|;
name|slen
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"alpha channel name length"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
comment|/* Check for (Mac?) Photoshop (4?) file-writing bug */
if|if
condition|(
name|slen
operator|>
name|remaining
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\nYay, a file bug.  "
literal|"Yuck.  Photoshop 4/Mac?  "
literal|"I'll work around you.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|slen
condition|)
block|{
name|guint32
name|alpha_name_len
decl_stmt|;
name|gchar
modifier|*
name|sname
init|=
name|getstring
argument_list|(
name|slen
argument_list|,
name|fd
argument_list|,
literal|"alpha channel name"
argument_list|)
decl_stmt|;
name|alpha_name_len
operator|=
name|strlen
argument_list|(
name|sname
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|alpha_name_len
expr_stmt|;
name|remaining
operator|-=
name|alpha_name_len
expr_stmt|;
name|sname
operator|=
name|sanitise_string
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
operator|=
name|sname
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tname: \"%s\"\n"
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t\tNull channel name %d.\n"
argument_list|,
name|psd_image
operator|.
name|num_aux_channels
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|psd_image
operator|.
name|num_aux_channels
operator|++
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_aux_channels
operator|>
name|MAX_CHANNELS
condition|)
block|{
name|printf
argument_list|(
literal|"\nPSD: Sorry - this image has too many "
literal|"aux channels.  Tell Adam!\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|remaining
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|remaining
condition|)
block|{
name|IFDBG
name|dumpchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"alphaname padding 0 throw"
argument_list|)
decl_stmt|;
else|else
name|throwchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"alphaname padding 0 throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|remaining
expr_stmt|;
name|remaining
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x03ef
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDISPLAYINFO STRUCTURE: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f0
case|:
comment|/* FIXME: untested */
block|{
name|psd_image
operator|.
name|caption
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"caption string"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|caption
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tcontent: \"%s\"\n"
argument_list|,
name|psd_image
operator|.
name|caption
argument_list|)
decl_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|strlen
argument_list|(
name|psd_image
operator|.
name|caption
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x03f2
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tBACKGROUND COLOR: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f4
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tGREY/MULTICHANNEL HALFTONING INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f5
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tCOLOUR HALFTONING INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f6
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDUOTONE HALFTONING INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f7
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tGREYSCALE/MULTICHANNEL TRANSFER FUNCTION: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f8
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tCOLOUR TRANSFER FUNCTION: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f9
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDUOTONE TRANSFER FUNCTION: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fa
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDUOTONE IMAGE INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fb
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tEFFECTIVE BLACK/WHITE VALUES: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fe
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tQUICK MASK INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0400
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLAYER STATE INFO:\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|active_layer_num
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"ID target_layer_num"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\ttarget: %d\n"
argument_list|,
operator|(
name|gint
operator|)
name|psd_image
operator|.
name|active_layer_num
argument_list|)
decl_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|0x0402
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLAYER GROUP INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t(Inferred number of layers: %d)\n"
argument_list|,
call|(
name|gint
call|)
argument_list|(
name|Size
operator|/
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0405
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tIMAGE MODE FOR RAW FORMAT: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0408
case|:
block|{
name|gint32
name|remaining
init|=
name|Size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tGUIDE INFORMATION:\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
name|gshort
name|magic1
decl_stmt|,
name|magic2
decl_stmt|,
name|magic3
decl_stmt|,
name|magic4
decl_stmt|,
name|magic5
decl_stmt|,
name|magic6
decl_stmt|;
name|glong
name|num_guides
decl_stmt|;
name|PSDguide
modifier|*
name|guide
decl_stmt|;
name|magic1
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|magic2
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|magic3
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|magic4
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|magic5
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|magic6
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|remaining
operator|-=
literal|12
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tMagic: %d %d %d %d %d %d\n"
argument_list|,
name|magic1
argument_list|,
name|magic2
argument_list|,
name|magic3
argument_list|,
name|magic4
argument_list|,
name|magic5
argument_list|,
name|magic6
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tMagic: 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n"
argument_list|,
name|magic1
argument_list|,
name|magic2
argument_list|,
name|magic3
argument_list|,
name|magic4
argument_list|,
name|magic5
argument_list|,
name|magic6
argument_list|)
decl_stmt|;
name|num_guides
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|remaining
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|remaining
operator|!=
name|num_guides
operator|*
literal|5
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"** FUNNY AMOUNT OF GUIDE DATA (%d)\n"
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
goto|goto
name|funny_amount_of_guide_data
goto|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tNumber of guides is %ld\n"
argument_list|,
name|num_guides
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|num_guides
operator|=
name|num_guides
expr_stmt|;
name|psd_image
operator|.
name|guides
operator|=
name|g_new
argument_list|(
name|PSDguide
argument_list|,
name|num_guides
argument_list|)
expr_stmt|;
name|guide
operator|=
name|psd_image
operator|.
name|guides
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_guides
condition|;
name|i
operator|++
operator|,
name|guide
operator|++
control|)
block|{
name|guide
operator|->
name|position
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
name|guide
operator|->
name|horizontal
operator|=
operator|(
literal|1
operator|==
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
operator|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|5
expr_stmt|;
name|remaining
operator|-=
literal|5
expr_stmt|;
if|if
condition|(
name|guide
operator|->
name|horizontal
condition|)
block|{
name|guide
operator|->
name|position
operator|=
name|RINT
argument_list|(
call|(
name|double
call|)
argument_list|(
name|guide
operator|->
name|position
operator|*
operator|(
name|magic4
operator|>>
literal|8
operator|)
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|magic4
operator|&
literal|255
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|guide
operator|->
name|position
operator|=
name|RINT
argument_list|(
call|(
name|double
call|)
argument_list|(
name|guide
operator|->
name|position
operator|*
operator|(
name|magic6
operator|>>
literal|8
operator|)
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|magic6
operator|&
literal|255
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tGuide %d at %d, %s\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|guide
operator|->
name|position
argument_list|,
name|guide
operator|->
name|horizontal
condition|?
literal|"horizontal"
else|:
literal|"vertical"
argument_list|)
decl_stmt|;
block|}
block|}
name|funny_amount_of_guide_data
label|:
if|if
condition|(
name|remaining
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"** GUIDE INFORMATION DROSS: "
argument_list|)
expr_stmt|;
name|dumpchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|throwchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|offset
operator|)
operator|+=
name|remaining
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x03ed
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tResolution Info:\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|resolution_is_set
operator|=
literal|1
expr_stmt|;
name|psd_image
operator|.
name|resolution
operator|.
name|hRes
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"hRes"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|resolution
operator|.
name|hRes_unit
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"hRes_unit"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|resolution
operator|.
name|widthUnit
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"WidthUnit"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|resolution
operator|.
name|vRes
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"vRes"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|resolution
operator|.
name|vRes_unit
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"vRes_unit"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|resolution
operator|.
name|heightUnit
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"HeightUnit"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tres = %f, %f\n"
argument_list|,
name|psd_image
operator|.
name|resolution
operator|.
name|hRes
operator|/
literal|65536.0
argument_list|,
name|psd_image
operator|.
name|resolution
operator|.
name|vRes
operator|/
literal|65536.0
argument_list|)
decl_stmt|;
block|}
break|break;
case|case
literal|0x03e9
case|:
case|case
literal|0x03f1
case|:
case|case
literal|0x03f3
case|:
case|case
literal|0x03fd
case|:
case|case
literal|0x0401
case|:
case|case
literal|0x0404
case|:
case|case
literal|0x0406
case|:
case|case
literal|0x0bb7
case|:
case|case
literal|0x2710
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Field is irrelevant to GIMP at this time.>\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03e8
case|:
case|case
literal|0x03eb
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Obsolete Photoshop 2.0 field.>\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fc
case|:
case|case
literal|0x03ff
case|:
case|case
literal|0x0403
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Obsolete field.>\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
default|default:
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t<Undocumented field.>\n"
argument_list|)
expr_stmt|;
name|dumpchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
block|}
else|else
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_record (FILE * fd,guint32 * offset,gint layernum)
name|do_layer_record
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|,
name|gint
name|layernum
parameter_list|)
block|{
name|PSDlayer
modifier|*
name|layer
decl_stmt|;
name|gint32
name|top
decl_stmt|,
name|left
decl_stmt|,
name|bottom
decl_stmt|,
name|right
decl_stmt|;
name|guint32
name|extradatasize
decl_stmt|,
name|layermaskdatasize
decl_stmt|,
name|layerrangesdatasize
decl_stmt|;
name|guint32
name|totaloff
decl_stmt|;
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|flags
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tLAYER RECORD (layer %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|layernum
argument_list|)
decl_stmt|;
name|layer
operator|=
name|psd_image
operator|.
name|layer
operator|+
name|layernum
expr_stmt|;
comment|/* table 11-12 */
name|top
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer top"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|left
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer left"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|bottom
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer bottom"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|right
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer right"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|layer
operator|->
name|x
operator|=
name|left
expr_stmt|;
name|layer
operator|->
name|y
operator|=
name|top
expr_stmt|;
name|layer
operator|->
name|width
operator|=
name|right
operator|-
name|left
expr_stmt|;
name|layer
operator|->
name|height
operator|=
name|bottom
operator|-
name|top
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer extents: (%d,%d) -> (%d,%d)\n"
argument_list|,
name|left
argument_list|,
name|top
argument_list|,
name|right
argument_list|,
name|bottom
argument_list|)
decl_stmt|;
name|layer
operator|->
name|num_channels
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer num_channels"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tNumber of channels: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|layer
operator|->
name|num_channels
argument_list|)
decl_stmt|;
if|if
condition|(
name|layer
operator|->
name|num_channels
condition|)
block|{
name|layer
operator|->
name|channel
operator|=
name|g_new
argument_list|(
name|PSDchannel
argument_list|,
name|layer
operator|->
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layer
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|PSDchannel
modifier|*
name|channel
init|=
name|layer
operator|->
name|channel
operator|+
name|i
decl_stmt|;
comment|/* table 11-13 */
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tCHANNEL LENGTH INFO (%d)\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|channel
operator|->
name|type
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"channel id"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\tChannel TYPE: %d\n"
argument_list|,
name|channel
operator|->
name|type
argument_list|)
decl_stmt|;
name|channel
operator|->
name|compressedsize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"channeldatalength"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\tChannel Data Length: %d\n"
argument_list|,
name|channel
operator|->
name|compressedsize
argument_list|)
decl_stmt|;
block|}
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tOo-er, layer has no channels.  Hmm.\n"
argument_list|)
decl_stmt|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|sig
argument_list|,
literal|4
argument_list|,
literal|"layer blend sig"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sig
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t(layer blend signature '%c%c%c%c' is incorrect: quitting)\n"
argument_list|,
name|sig
index|[
literal|0
index|]
argument_list|,
name|sig
index|[
literal|1
index|]
argument_list|,
name|sig
index|[
literal|2
index|]
argument_list|,
name|sig
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|g_message
argument_list|(
literal|"Error: layer blend signature is incorrect. :-("
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|layer
operator|->
name|blendkey
argument_list|,
literal|4
argument_list|,
literal|"layer blend key"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tBlend type: PSD(\"%c%c%c%c\") = GIMP(%d)\n"
argument_list|,
name|layer
operator|->
name|blendkey
index|[
literal|0
index|]
argument_list|,
name|layer
operator|->
name|blendkey
index|[
literal|1
index|]
argument_list|,
name|layer
operator|->
name|blendkey
index|[
literal|2
index|]
argument_list|,
name|layer
operator|->
name|blendkey
index|[
literal|3
index|]
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|layer
operator|->
name|blendkey
argument_list|)
argument_list|)
decl_stmt|;
name|layer
operator|->
name|opacity
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer opacity"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer Opacity: %d\n"
argument_list|,
name|layer
operator|->
name|opacity
argument_list|)
decl_stmt|;
name|layer
operator|->
name|clipping
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer clipping"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer Clipping: %d (%s)\n"
argument_list|,
name|layer
operator|->
name|clipping
argument_list|,
name|layer
operator|->
name|clipping
operator|==
literal|0
condition|?
literal|"base"
else|:
literal|"non-base"
argument_list|)
decl_stmt|;
name|flags
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer flags"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer Flags: %d (%s, %s)\n"
argument_list|,
name|flags
argument_list|,
name|flags
operator|&
literal|1
condition|?
literal|"preserve transparency"
else|:
literal|"don't preserve transparency"
argument_list|,
name|flags
operator|&
literal|2
condition|?
literal|"visible"
else|:
literal|"not visible"
argument_list|)
decl_stmt|;
name|layer
operator|->
name|protecttrans
operator|=
operator|(
name|flags
operator|&
literal|1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|layer
operator|->
name|visible
operator|=
operator|(
name|flags
operator|&
literal|2
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer record filler"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|extradatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer extra data size"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tEXTRA DATA SIZE: %d\n"
argument_list|,
name|extradatasize
argument_list|)
decl_stmt|;
comment|/* FIXME: should do something with this data */
comment|/*throwchunk(extradatasize, fd, "layer extradata throw");   (*offset) += extradatasize;*/
name|totaloff
operator|=
operator|(
operator|*
name|offset
operator|)
operator|+
name|extradatasize
expr_stmt|;
comment|/* table 11-14 */
name|layermaskdatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer mask data size"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\tLAYER MASK DATA SIZE: %d\n"
argument_list|,
name|layermaskdatasize
argument_list|)
decl_stmt|;
if|if
condition|(
name|layermaskdatasize
condition|)
block|{
name|top
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask top"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|left
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask left"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|bottom
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask bottom"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|right
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask right"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|layer
operator|->
name|lm_x
operator|=
name|left
expr_stmt|;
name|layer
operator|->
name|lm_y
operator|=
name|top
expr_stmt|;
name|layer
operator|->
name|lm_width
operator|=
name|right
operator|-
name|left
expr_stmt|;
name|layer
operator|->
name|lm_height
operator|=
name|bottom
operator|-
name|top
expr_stmt|;
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask data throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
comment|/*      throwchunk(layermaskdatasize, fd, "layer mask data throw");       (*offset) += layermaskdatasize;*/
block|}
name|layerrangesdatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer ranges data size"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\t\tLAYER RANGES DATA SIZE: %d\n"
argument_list|,
name|layermaskdatasize
argument_list|)
decl_stmt|;
if|if
condition|(
name|layerrangesdatasize
condition|)
block|{
name|throwchunk
argument_list|(
name|layerrangesdatasize
argument_list|,
name|fd
argument_list|,
literal|"layer ranges data throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|layerrangesdatasize
expr_stmt|;
block|}
name|layer
operator|->
name|name
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"layer name"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|name
condition|)
block|{
operator|(
operator|*
name|offset
operator|)
operator|+=
name|strlen
argument_list|(
name|layer
operator|->
name|name
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\t\tLAYER NAME: '%s'\n"
argument_list|,
name|layer
operator|->
name|name
argument_list|)
decl_stmt|;
name|layer
operator|->
name|name
operator|=
name|sanitise_string
argument_list|(
name|layer
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\t\tNULL LAYER NAME\n"
argument_list|)
decl_stmt|;
block|}
comment|/* If no layermask data - set offset and size from layer data */
if|if
condition|(
operator|!
name|layermaskdatasize
condition|)
block|{
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting layer mask data layer\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_x
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|x
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_y
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|y
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_width
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|width
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_height
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|height
expr_stmt|;
block|}
if|if
condition|(
name|totaloff
operator|-
operator|(
operator|*
name|offset
operator|)
operator|>
literal|0
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"Warning: layer record dross: "
argument_list|)
expr_stmt|;
name|dumpchunk
argument_list|(
name|totaloff
operator|-
operator|(
operator|*
name|offset
operator|)
argument_list|,
name|fd
argument_list|,
literal|"layer record dross throw"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|throwchunk
argument_list|(
name|totaloff
operator|-
operator|(
operator|*
name|offset
operator|)
argument_list|,
name|fd
argument_list|,
literal|"layer record dross throw"
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|offset
operator|)
operator|=
name|totaloff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_struct (FILE * fd,guint32 * offset)
name|do_layer_struct
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLAYER STRUCTURE SECTION\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|num_layers
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer struct numlayers"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tCanonical number of layers: %d%s\n"
argument_list|,
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|?
operator|(
name|int
operator|)
name|psd_image
operator|.
name|num_layers
else|:
name|abs
argument_list|(
name|psd_image
operator|.
name|num_layers
argument_list|)
argument_list|,
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|?
literal|""
else|:
literal|" (absolute/alpha)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_layers
operator|<
literal|0
condition|)
block|{
name|psd_image
operator|.
name|num_layers
operator|=
operator|-
name|psd_image
operator|.
name|num_layers
expr_stmt|;
name|psd_image
operator|.
name|absolute_alpha
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|psd_image
operator|.
name|absolute_alpha
operator|=
name|FALSE
expr_stmt|;
block|}
name|psd_image
operator|.
name|layer
operator|=
name|g_new
argument_list|(
name|PSDlayer
argument_list|,
name|psd_image
operator|.
name|num_layers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|i
operator|++
control|)
block|{
name|do_layer_record
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_pixeldata (FILE * fd,guint32 * offset)
name|do_layer_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|gint
name|layeri
decl_stmt|,
name|channeli
decl_stmt|;
for|for
control|(
name|layeri
operator|=
literal|0
init|;
name|layeri
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|layeri
operator|++
control|)
block|{
name|PSDlayer
modifier|*
name|layer
init|=
name|psd_image
operator|.
name|layer
operator|+
name|layeri
decl_stmt|;
for|for
control|(
name|channeli
operator|=
literal|0
init|;
name|channeli
operator|<
name|layer
operator|->
name|num_channels
condition|;
name|channeli
operator|++
control|)
block|{
name|PSDchannel
modifier|*
name|channel
init|=
name|layer
operator|->
name|channel
operator|+
name|channeli
decl_stmt|;
if|if
condition|(
name|channel
operator|->
name|type
operator|==
operator|-
literal|2
condition|)
block|{
name|channel
operator|->
name|width
operator|=
name|layer
operator|->
name|lm_width
expr_stmt|;
name|channel
operator|->
name|height
operator|=
name|layer
operator|->
name|lm_height
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|->
name|width
operator|=
name|layer
operator|->
name|width
expr_stmt|;
name|channel
operator|->
name|height
operator|=
name|layer
operator|->
name|height
expr_stmt|;
block|}
name|fgetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|channel
operator|->
name|fpos
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|channel
operator|->
name|compressedsize
argument_list|,
name|fd
argument_list|,
literal|"channel data skip"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|channel
operator|->
name|compressedsize
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|seek_to_and_unpack_pixeldata (FILE * fd,gint layeri,gint channeli)
name|seek_to_and_unpack_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint
name|layeri
parameter_list|,
name|gint
name|channeli
parameter_list|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|guchar
modifier|*
name|tmpline
decl_stmt|;
name|gint
name|compression
decl_stmt|;
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|PSDchannel
modifier|*
name|channel
init|=
operator|&
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
decl_stmt|;
name|fsetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|channel
operator|->
name|fpos
argument_list|)
expr_stmt|;
name|compression
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer channel compression type"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|width
operator|=
name|channel
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|channel
operator|->
name|height
expr_stmt|;
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t\tLayer (%d) Channel (%d:%d) Compression: %d (%s)\n"
argument_list|,
name|layeri
argument_list|,
name|channeli
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|compression
argument_list|,
name|compression
operator|==
literal|0
condition|?
literal|"raw"
else|:
operator|(
name|compression
operator|==
literal|1
condition|?
literal|"RLE"
else|:
literal|"*UNKNOWN!*"
operator|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|channel
operator|->
name|data
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|tmpline
operator|=
name|g_malloc
argument_list|(
name|width
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* raw data */
block|{
name|gint
name|linei
decl_stmt|;
for|for
control|(
name|linei
operator|=
literal|0
init|;
name|linei
operator|<
name|height
condition|;
name|linei
operator|++
control|)
block|{
name|xfread
argument_list|(
name|fd
argument_list|,
name|channel
operator|->
name|data
operator|+
name|linei
operator|*
name|width
argument_list|,
name|width
argument_list|,
literal|"raw channel line"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|width
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Pad raw data to multiple of 2? */
block|if ((height * width)& 1) 	  { 	    getguchar(fd, "raw channel padding"); 	    offset++; 	  }
endif|#
directive|endif
block|}
break|break;
case|case
literal|1
case|:
comment|/* RLE, one row at a time, padded to an even width */
block|{
name|gint
name|linei
decl_stmt|;
name|gint
name|blockread
decl_stmt|;
comment|/* we throw this away because in theory we can trust the 	   data to unpack to the right length... hmm... */
name|throwchunk
argument_list|(
name|height
operator|*
literal|2
argument_list|,
name|fd
argument_list|,
literal|"widthlist"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|height
operator|*
literal|2
expr_stmt|;
name|blockread
operator|=
name|offset
expr_stmt|;
comment|/*IFDBG {printf("\nHere comes the guitar solo...\n"); 	  fflush(stdout);}*/
for|for
control|(
name|linei
operator|=
literal|0
init|;
name|linei
operator|<
name|height
condition|;
name|linei
operator|++
control|)
block|{
comment|/*printf(" %d ", *offset);*/
name|unpack_pb_channel
argument_list|(
name|fd
argument_list|,
name|tmpline
argument_list|,
name|width
comment|/*+ (width&1)*/
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|channel
operator|->
name|data
operator|+
name|linei
operator|*
name|width
argument_list|,
name|tmpline
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t\t\t\tActual compressed size was %d bytes\n"
argument_list|,
name|offset
operator|-
name|blockread
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* *unknown* */
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\nEEP!\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|g_message
argument_list|(
literal|"*** Unknown compression type in channel."
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
break|break;
block|}
name|g_free
argument_list|(
name|tmpline
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layers (FILE * fd,guint32 * offset)
name|do_layers
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|guint32
name|section_length
decl_stmt|;
name|section_length
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layerinfo sectionlength"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tLAYER INFO SECTION\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tSECTION LENGTH: %u\n"
argument_list|,
name|section_length
argument_list|)
decl_stmt|;
name|do_layer_struct
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|do_layer_pixeldata
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_and_mask (FILE * fd)
name|do_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|guint32
name|Size
init|=
name|PSDheader
operator|.
name|miscsizelen
decl_stmt|;
name|guint32
name|offset_now
init|=
name|ftell
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"LAYER AND MASK INFO\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tSECTION LENGTH: %u\n"
argument_list|,
name|Size
argument_list|)
decl_stmt|;
if|if
condition|(
name|Size
operator|==
literal|0
condition|)
return|return;
name|do_layers
argument_list|(
name|fd
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|IFDBG
block|{
name|printf
argument_list|(
literal|"And...?\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
name|Size
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"PSD: Supposedly there are %d bytes of mask info left.\n"
argument_list|,
name|Size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Size
operator|-
name|offset
operator|==
literal|4
operator|)
operator|||
operator|(
name|Size
operator|-
name|offset
operator|==
literal|24
operator|)
condition|)
name|printf
argument_list|(
literal|"     That sounds good to me.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     That sounds strange to me.\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      if ((getguchar(fd, "mask info throw")!=0) || 	  (getguchar(fd, "mask info throw")!=0) || 	  (getguchar(fd, "mask info throw")!=0) || 	  (getguchar(fd, "mask info throw")!=0)) 	{ 	  printf("*** This mask info block looks pretty bogus.\n"); 	}*/
block|}
else|else
name|printf
argument_list|(
literal|"PSD: Stern warning - no mask info.\n"
argument_list|)
expr_stmt|;
comment|/* If 'offset' wasn't being buggily updated, we wouldn't need this. (!?) */
name|fseek
argument_list|(
name|fd
argument_list|,
name|Size
operator|+
name|offset_now
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_image_resources (FILE * fd)
name|do_image_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint16
name|ID
decl_stmt|;
name|gchar
modifier|*
name|Name
decl_stmt|;
name|guint32
name|Size
decl_stmt|;
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"IMAGE RESOURCE BLOCK:\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|resolution_is_set
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: too trusting that the file isn't corrupt */
while|while
condition|(
name|offset
operator|<
name|PSDheader
operator|.
name|imgreslen
operator|-
literal|1
condition|)
block|{
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|sig
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sig
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Error - imageresources block has invalid signature.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|offset
operator|+=
literal|4
expr_stmt|;
comment|/* generic information about a block ID */
name|ID
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"ID num"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tID: 0x%04x / "
argument_list|,
name|ID
argument_list|)
decl_stmt|;
name|Name
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"ID name"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|Name
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\"%s\" "
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|strlen
argument_list|(
name|Name
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID name throw"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|g_free
argument_list|(
name|Name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID name throw2"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|Size
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"ID Size"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Size: %d\n"
argument_list|,
name|Size
argument_list|)
decl_stmt|;
name|dispatch_resID
argument_list|(
name|ID
argument_list|,
name|fd
argument_list|,
operator|&
name|offset
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
operator|&
literal|1
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"+1"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID content throw"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
comment|/*  if (offset != PSDheader.imgreslen)     {       printf("\tSucking imageres byte...\n");       throwchunk(1, fd, "imageres suck");       offset ++;     }*/
block|}
end_function

begin_if
if|#
directive|if
name|PANOTOOLS_FIX
end_if

begin_comment
comment|/* Convert RGB data to RGBA data */
end_comment

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|RGB_to_RGBA (const guchar * rgb_data,gint numpix)
name|RGB_to_RGBA
parameter_list|(
specifier|const
name|guchar
modifier|*
name|rgb_data
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|rgb_data
condition|)
block|{
name|printf
argument_list|(
literal|"NULL rgb data - eep!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtn
operator|=
name|g_malloc
argument_list|(
name|numpix
operator|*
literal|4
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|j
operator|++
index|]
operator|=
name|rgb_data
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
name|rtn
index|[
name|j
operator|++
index|]
operator|=
name|rgb_data
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|rtn
index|[
name|j
operator|++
index|]
operator|=
name|rgb_data
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
name|rtn
index|[
name|j
operator|++
index|]
operator|=
literal|255
expr_stmt|;
block|}
return|return
name|rtn
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PANOTOOLS_FIX */
end_comment

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|chans_to_GRAYA (const guchar * grey,const guchar * alpha,gint numpix)
name|chans_to_GRAYA
parameter_list|(
specifier|const
name|guchar
modifier|*
name|grey
parameter_list|,
specifier|const
name|guchar
modifier|*
name|alpha
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|grey
operator|||
operator|!
name|alpha
condition|)
block|{
name|printf
argument_list|(
literal|"NULL channel - eep!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtn
operator|=
name|g_malloc
argument_list|(
name|numpix
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|2
index|]
operator|=
name|grey
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|alpha
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|rtn
return|;
block|}
end_function

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|chans_to_RGB (const guchar * red,const guchar * green,const guchar * blue,gint numpix)
name|chans_to_RGB
parameter_list|(
specifier|const
name|guchar
modifier|*
name|red
parameter_list|,
specifier|const
name|guchar
modifier|*
name|green
parameter_list|,
specifier|const
name|guchar
modifier|*
name|blue
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|red
operator|||
operator|!
name|green
operator|||
operator|!
name|blue
condition|)
block|{
name|printf
argument_list|(
literal|"NULL channel - eep!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtn
operator|=
name|g_malloc
argument_list|(
name|numpix
operator|*
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|red
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|green
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|blue
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|rtn
return|;
block|}
end_function

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|chans_to_RGBA (const guchar * red,const guchar * green,const guchar * blue,const guchar * alpha,gint numpix)
name|chans_to_RGBA
parameter_list|(
specifier|const
name|guchar
modifier|*
name|red
parameter_list|,
specifier|const
name|guchar
modifier|*
name|green
parameter_list|,
specifier|const
name|guchar
modifier|*
name|blue
parameter_list|,
specifier|const
name|guchar
modifier|*
name|alpha
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gboolean
name|careful
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|red
operator|||
operator|!
name|green
operator|||
operator|!
name|blue
operator|||
operator|!
name|alpha
condition|)
block|{
name|printf
argument_list|(
literal|"chans_to_RGBA : NULL channel - eep!"
argument_list|)
expr_stmt|;
name|careful
operator|=
name|TRUE
expr_stmt|;
block|}
name|rtn
operator|=
name|g_malloc
argument_list|(
name|numpix
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|careful
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|red
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|green
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|blue
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
name|alpha
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|4
index|]
operator|=
operator|(
name|red
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|red
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
operator|(
name|green
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|green
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
operator|(
name|blue
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|blue
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
operator|(
name|alpha
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|alpha
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|rtn
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|psd_layer_has_alpha (PSDlayer * layer)
name|gboolean
name|psd_layer_has_alpha
parameter_list|(
name|PSDlayer
modifier|*
name|layer
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layer
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|layer
operator|->
name|channel
index|[
name|i
index|]
operator|.
name|type
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|extract_data_and_channels (guchar * src,gint gimpstep,gint psstep,gint32 image_ID,GimpDrawable * drawable,gint width,gint height)
name|void
name|extract_data_and_channels
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|gimpstep
parameter_list|,
name|gint
name|psstep
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|guchar
modifier|*
name|primary_data
decl_stmt|;
name|guchar
modifier|*
name|aux_data
decl_stmt|;
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Extracting primary channel data (%d channels)\n"
literal|"\tand %d auxiliary channels.\n"
argument_list|,
name|gimpstep
argument_list|,
name|psstep
operator|-
name|gimpstep
argument_list|)
decl_stmt|;
comment|/* gimp doesn't like 0 width/height drawables. */
if|if
condition|(
operator|(
name|width
operator|==
literal|0
operator|)
operator|||
operator|(
name|height
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"(bad channel dimensions -- skipping)"
argument_list|)
decl_stmt|;
return|return;
block|}
name|primary_data
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|height
operator|*
name|gimpstep
argument_list|)
expr_stmt|;
block|{
name|int
name|pix
decl_stmt|,
name|chan
decl_stmt|;
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|width
operator|*
name|height
condition|;
name|pix
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|gimpstep
condition|;
name|chan
operator|++
control|)
block|{
name|primary_data
index|[
name|pix
operator|*
name|gimpstep
operator|+
name|chan
index|]
operator|=
name|src
index|[
name|pix
operator|*
name|psstep
operator|+
name|chan
index|]
expr_stmt|;
block|}
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|primary_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|primary_data
argument_list|)
expr_stmt|;
name|aux_data
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
block|{
name|int
name|pix
decl_stmt|,
name|chan
decl_stmt|;
name|gint32
name|channel_ID
decl_stmt|;
name|GimpDrawable
modifier|*
name|chdrawable
decl_stmt|;
name|GimpRGB
name|colour
decl_stmt|;
name|gimp_rgb_set
argument_list|(
operator|&
name|colour
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
name|gimpstep
init|;
name|chan
operator|<
name|psstep
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|width
operator|*
name|height
condition|;
name|pix
operator|++
control|)
block|{
name|aux_data
index|[
name|pix
index|]
operator|=
name|src
index|[
name|pix
operator|*
name|psstep
operator|+
name|chan
index|]
expr_stmt|;
block|}
name|channel_ID
operator|=
name|gimp_channel_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|chan
operator|-
name|gimpstep
index|]
operator|.
name|name
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|100.0
argument_list|,
operator|&
name|colour
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image_ID
argument_list|,
name|channel_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_drawable_set_visible
argument_list|(
name|channel_ID
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chdrawable
operator|=
name|gimp_drawable_get
argument_list|(
name|channel_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|chdrawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|aux_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|aux_data
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Done with that.\n\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|extract_channels (guchar * src,gint num_wanted,gint psstep,gint32 image_ID,gint width,gint height)
name|extract_channels
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|num_wanted
parameter_list|,
name|gint
name|psstep
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|guchar
modifier|*
name|aux_data
decl_stmt|;
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Extracting %d/%d auxiliary channels.\n"
argument_list|,
name|num_wanted
argument_list|,
name|psstep
argument_list|)
decl_stmt|;
comment|/* gimp doesn't like 0 width/height drawables. */
if|if
condition|(
operator|(
name|width
operator|==
literal|0
operator|)
operator|||
operator|(
name|height
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"(bad channel dimensions -- skipping)"
argument_list|)
decl_stmt|;
return|return;
block|}
name|aux_data
operator|=
name|g_malloc
argument_list|(
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
block|{
name|int
name|pix
decl_stmt|,
name|chan
decl_stmt|;
name|gint32
name|channel_ID
decl_stmt|;
name|GimpDrawable
modifier|*
name|chdrawable
decl_stmt|;
name|GimpRGB
name|colour
decl_stmt|;
name|gimp_rgb_set
argument_list|(
operator|&
name|colour
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
name|psstep
operator|-
name|num_wanted
init|;
name|chan
operator|<
name|psstep
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|width
operator|*
name|height
condition|;
name|pix
operator|++
control|)
block|{
name|aux_data
index|[
name|pix
index|]
operator|=
name|src
index|[
name|pix
operator|*
name|psstep
operator|+
name|chan
index|]
expr_stmt|;
block|}
name|channel_ID
operator|=
name|gimp_channel_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|chan
operator|-
operator|(
name|psstep
operator|-
name|num_wanted
operator|)
index|]
operator|.
name|name
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|100.0
argument_list|,
operator|&
name|colour
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image_ID
argument_list|,
name|channel_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_drawable_set_visible
argument_list|(
name|channel_ID
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chdrawable
operator|=
name|gimp_drawable_get
argument_list|(
name|channel_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|chdrawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|aux_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|aux_data
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Done with that.\n\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|resize_mask (guchar * src,guchar * dest,gint32 src_x,gint32 src_y,gint32 src_w,gint32 src_h,gint32 dest_w,gint32 dest_h)
name|resize_mask
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|gint32
name|src_x
parameter_list|,
name|gint32
name|src_y
parameter_list|,
name|gint32
name|src_w
parameter_list|,
name|gint32
name|src_h
parameter_list|,
name|gint32
name|dest_w
parameter_list|,
name|gint32
name|dest_h
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"--> %p %p : %d %d . %d %d . %d %d\n"
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|src_x
argument_list|,
name|src_y
argument_list|,
name|src_w
argument_list|,
name|src_h
argument_list|,
name|dest_w
argument_list|,
name|dest_h
argument_list|)
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dest_h
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dest_w
condition|;
name|x
operator|++
control|)
block|{
comment|/* Avoid a 1-pixel border top-left */
if|if
condition|(
operator|(
name|x
operator|>=
name|src_x
operator|)
operator|&&
operator|(
name|x
operator|<
name|src_x
operator|+
name|src_w
operator|)
operator|&&
operator|(
name|y
operator|>=
name|src_y
operator|)
operator|&&
operator|(
name|y
operator|<
name|src_y
operator|+
name|src_h
operator|)
condition|)
block|{
name|dest
index|[
name|dest_w
operator|*
name|y
operator|+
name|x
index|]
operator|=
name|src
index|[
name|src_w
operator|*
operator|(
name|y
operator|-
name|src_y
operator|)
operator|+
operator|(
name|x
operator|-
name|src_x
operator|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|dest_w
operator|*
name|y
operator|+
name|x
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (const gchar * name)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|gboolean
name|want_aux
decl_stmt|;
name|char
modifier|*
name|name_buf
decl_stmt|;
name|guchar
modifier|*
name|cmykbuf
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|long
name|channels
decl_stmt|,
name|nguchars
decl_stmt|;
name|psd_imagetype
name|imagetype
decl_stmt|;
name|gboolean
name|cmyk
init|=
name|FALSE
decl_stmt|;
name|gint
name|step
init|=
literal|1
decl_stmt|;
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|gint32
name|iter
decl_stmt|;
name|fpos_t
name|tmpfpos
decl_stmt|;
name|int
name|red_chan
decl_stmt|,
name|grn_chan
decl_stmt|,
name|blu_chan
decl_stmt|,
name|alpha_chan
decl_stmt|,
name|ichan
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"------- %s ---------------------------------\n"
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|name
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|name_buf
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'..."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|read_whole_file
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|)
comment|/* PS3-style */
block|{
name|int
name|lnum
decl_stmt|;
name|GimpImageBaseType
name|gimagetype
decl_stmt|;
name|gimagetype
operator|=
name|psd_mode_to_gimp_base_type
argument_list|(
name|PSDheader
operator|.
name|mode
argument_list|)
expr_stmt|;
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|gimagetype
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|resolution_is_set
condition|)
block|{
name|gimp_image_set_resolution
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|resolution
operator|.
name|hRes
operator|/
literal|65536.0
argument_list|,
name|psd_image
operator|.
name|resolution
operator|.
name|vRes
operator|/
literal|65536.0
argument_list|)
expr_stmt|;
comment|/* currently can only set one unit for the image so we use the 	     horizontal unit from the psd image */
name|gimp_image_set_unit
argument_list|(
name|image_ID
argument_list|,
name|psd_unit_to_gimp_unit
argument_list|(
name|psd_image
operator|.
name|resolution
operator|.
name|widthUnit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fgetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpfpos
argument_list|)
expr_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|lnum
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|lnum
operator|++
control|)
block|{
name|gint
name|numc
decl_stmt|;
name|guchar
modifier|*
name|merged_data
init|=
name|NULL
decl_stmt|;
name|PSDlayer
modifier|*
name|layer
init|=
name|psd_image
operator|.
name|layer
operator|+
name|lnum
decl_stmt|;
comment|/* 	   * since ps supports sloppy bounding boxes it is possible to 	   * have a 0x0 or Xx0 or 0xY layer.  Gimp doesn't support a 	   * 0x0 layer so we will just skip these.  We might be able 	   * to do something better here. 	   */
if|if
condition|(
operator|(
name|layer
operator|->
name|width
operator|==
literal|0
operator|)
operator|||
operator|(
name|layer
operator|->
name|height
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"(bad layer dimensions -- skipping)"
argument_list|)
decl_stmt|;
continue|continue;
block|}
name|numc
operator|=
name|layer
operator|->
name|num_channels
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Hey, it's a LAYER with %d channels!\n"
argument_list|,
name|numc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|gimagetype
condition|)
block|{
case|case
name|GIMP_GRAY
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"It's GRAY.\n"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|psd_layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|merged_data
operator|=
name|g_malloc
argument_list|(
name|layer
operator|->
name|width
operator|*
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|merged_data
argument_list|,
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|layer
operator|->
name|width
operator|*
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|merged_data
operator|=
name|chans_to_GRAYA
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|,
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|layer
operator|->
name|width
operator|*
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|layer
operator|->
name|name
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|,
operator|(
name|numc
operator|==
literal|1
operator|)
condition|?
name|GIMP_GRAY_IMAGE
else|:
name|GIMP_GRAYA_IMAGE
argument_list|,
operator|(
literal|100.0
operator|*
name|layer
operator|->
name|opacity
operator|)
operator|/
literal|255.0
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|layer
operator|->
name|blendkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
comment|/* case GIMP_GRAY */
case|case
name|GIMP_RGB
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"It's RGB, %dx%d.\n"
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|psd_layer_has_alpha
argument_list|(
name|layer
argument_list|)
condition|)
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|merged_data
operator|=
name|chans_to_RGB
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|layer
operator|->
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|,
name|layer
operator|->
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|,
name|layer
operator|->
name|width
operator|*
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH0a\n"
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Fix for unexpected layer data order for files                      * from PS files created by PanoTools. Rather 		     * than assuming an order, we find the actual order. 		     */
name|red_chan
operator|=
name|grn_chan
operator|=
name|blu_chan
operator|=
name|alpha_chan
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ichan
operator|=
literal|0
init|;
name|ichan
operator|<
name|numc
condition|;
name|ichan
operator|++
control|)
block|{
switch|switch
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|ichan
index|]
operator|.
name|type
condition|)
block|{
case|case
literal|0
case|:
name|red_chan
operator|=
name|ichan
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|grn_chan
operator|=
name|ichan
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|blu_chan
operator|=
name|ichan
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|alpha_chan
operator|=
name|ichan
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|red_chan
operator|<
literal|0
operator|)
operator|||
operator|(
name|grn_chan
operator|<
literal|0
operator|)
operator|||
operator|(
name|blu_chan
operator|<
literal|0
operator|)
operator|||
operator|(
name|alpha_chan
operator|<
literal|0
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"Error: Cannot identify required RGBA channels"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
break|break;
block|}
name|merged_data
operator|=
name|chans_to_RGBA
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|red_chan
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|grn_chan
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|blu_chan
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|alpha_chan
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
literal|3
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH0b\n"
argument_list|)
decl_stmt|;
block|}
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH1\n"
argument_list|)
decl_stmt|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|name
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|,
name|psd_layer_has_alpha
argument_list|(
operator|&
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
argument_list|)
condition|?
name|GIMP_RGBA_IMAGE
else|:
name|GIMP_RGB_IMAGE
argument_list|,
operator|(
literal|100.0
operator|*
operator|(
name|double
operator|)
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|opacity
operator|)
operator|/
literal|255.0
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|blendkey
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH2\n"
argument_list|)
decl_stmt|;
block|}
empty_stmt|;
break|break;
comment|/* case GIMP_RGB */
default|default:
block|{
name|g_message
argument_list|(
literal|"Error: Sorry, can't deal with a layered image of this type.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
break|break;
comment|/* default */
block|}
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH3\n"
argument_list|)
decl_stmt|;
comment|/* Do a layer mask if it exists */
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
name|layer
operator|->
name|num_channels
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|layer
operator|->
name|channel
index|[
name|iter
index|]
operator|.
name|type
operator|==
operator|-
literal|2
condition|)
comment|/* is mask */
block|{
name|gint32
name|mask_id
decl_stmt|;
name|guchar
modifier|*
name|lm_data
decl_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH3m\n"
argument_list|)
decl_stmt|;
name|lm_data
operator|=
name|g_malloc
argument_list|(
name|layer
operator|->
name|width
operator|*
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
block|{
if|#
directive|if
name|PANOTOOLS_FIX
name|guchar
modifier|*
name|tmp
decl_stmt|;
endif|#
directive|endif
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
name|iter
argument_list|)
expr_stmt|;
comment|/* PS layer masks can be a different size to 		       their owning layer, so we have to resize them. */
name|resize_mask
argument_list|(
name|layer
operator|->
name|channel
index|[
name|iter
index|]
operator|.
name|data
argument_list|,
name|lm_data
argument_list|,
name|layer
operator|->
name|lm_x
operator|-
name|layer
operator|->
name|x
argument_list|,
name|layer
operator|->
name|lm_y
operator|-
name|layer
operator|->
name|y
argument_list|,
name|layer
operator|->
name|lm_width
argument_list|,
name|layer
operator|->
name|lm_height
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* won't be needing the original data any more */
name|g_free
argument_list|(
name|layer
operator|->
name|channel
index|[
name|iter
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* give it to GIMP */
name|mask_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|PANOTOOLS_FIX
comment|/* Convert the layer RGB data (not the mask) to RGBA */
name|tmp
operator|=
name|merged_data
expr_stmt|;
name|merged_data
operator|=
name|RGB_to_RGBA
argument_list|(
name|tmp
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Add alpha - otherwise cannot add layer mask */
name|gimp_layer_add_alpha
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
comment|/* Add layer mask */
name|gimp_layer_add_mask
argument_list|(
name|layer_ID
argument_list|,
name|mask_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PANOTOOLS_FIX */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|mask_id
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|lm_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lm_data
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
block|}
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH4\n"
argument_list|)
decl_stmt|;
name|gimp_layer_translate
argument_list|(
name|layer_ID
argument_list|,
name|layer
operator|->
name|x
argument_list|,
name|layer
operator|->
name|y
argument_list|)
expr_stmt|;
name|gimp_layer_set_preserve_trans
argument_list|(
name|layer_ID
argument_list|,
name|layer
operator|->
name|protecttrans
argument_list|)
expr_stmt|;
name|gimp_drawable_set_visible
argument_list|(
name|layer_ID
argument_list|,
name|layer
operator|->
name|visible
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH5 - merged_data=%p, drawable=%p, drawdim=%dx%dx%d\n"
argument_list|,
name|merged_data
argument_list|,
name|drawable
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|)
decl_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|merged_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layer
operator|->
name|width
argument_list|,
name|layer
operator|->
name|height
argument_list|)
expr_stmt|;
name|IFDBG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YAH6\n"
argument_list|)
decl_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|NULL
expr_stmt|;
name|g_free
argument_list|(
name|merged_data
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|lnum
operator|+
literal|1.0
argument_list|)
operator|/
operator|(
name|double
operator|)
name|psd_image
operator|.
name|num_layers
argument_list|)
expr_stmt|;
block|}
name|fsetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpfpos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|psd_image
operator|.
name|num_aux_channels
operator|>
literal|0
operator|)
operator|&&
operator|(
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
operator|)
condition|)
block|{
name|want_aux
operator|=
name|TRUE
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"::::::::::: WANT AUX :::::::::::::::::::::::::::::::::::::::\n"
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|want_aux
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|want_aux
operator|||
operator|(
name|psd_image
operator|.
name|num_layers
operator|==
literal|0
operator|)
condition|)
comment|/* Photoshop2-style: NO LAYERS. */
block|{
name|IFDBG
name|printf
argument_list|(
literal|"Image data %ld chars\n"
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
decl_stmt|;
name|step
operator|=
name|PSDheader
operator|.
name|channels
expr_stmt|;
name|imagetype
operator|=
name|PSD_UNKNOWN_IMAGE
expr_stmt|;
switch|switch
condition|(
name|PSDheader
operator|.
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* Bitmap */
name|imagetype
operator|=
name|PSD_BITMAP_IMAGE
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Grayscale */
name|imagetype
operator|=
name|PSD_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Indexed Colour */
name|imagetype
operator|=
name|PSD_INDEXED_IMAGE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* RGB Colour */
name|imagetype
operator|=
name|PSD_RGB_IMAGE
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* CMYK Colour */
name|cmyk
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|PSDheader
operator|.
name|channels
condition|)
block|{
case|case
literal|4
case|:
name|imagetype
operator|=
name|PSD_RGB_IMAGE
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|imagetype
operator|=
name|PSD_RGBA_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: cannot handle CMYK with more than 5 channels\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
break|break;
case|case
literal|7
case|:
comment|/* Multichannel (?) */
case|case
literal|8
case|:
comment|/* Duotone */
case|case
literal|9
case|:
comment|/* Lab Colour */
default|default:
break|break;
block|}
if|if
condition|(
name|imagetype
operator|==
name|PSD_UNKNOWN_IMAGE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Image type %d (%s) is not supported in this data format\n"
argument_list|,
name|prog_name
argument_list|,
name|PSDheader
operator|.
name|mode
argument_list|,
operator|(
name|PSDheader
operator|.
name|mode
operator|>
literal|10
operator|)
condition|?
literal|"<out of range>"
else|:
name|modename
index|[
name|PSDheader
operator|.
name|mode
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|PSDheader
operator|.
name|bpp
operator|!=
literal|8
operator|)
operator|&&
operator|(
name|PSDheader
operator|.
name|bpp
operator|!=
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: The GIMP only supports 8-bit or 1-bit deep PSD images "
literal|"at this time.\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"psd:%d gimp:%d gimpbase:%d\n"
argument_list|,
name|imagetype
argument_list|,
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
argument_list|,
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|want_aux
condition|)
block|{
comment|/* gimp doesn't like 0 width/height drawables. */
if|if
condition|(
operator|(
name|PSDheader
operator|.
name|columns
operator|==
literal|0
operator|)
operator|||
operator|(
name|PSDheader
operator|.
name|rows
operator|==
literal|0
operator|)
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"(bad psd2-style image dimensions -- skipping)"
argument_list|)
decl_stmt|;
name|image_ID
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
operator|==
name|GIMP_INDEXED
condition|)
block|{
if|if
condition|(
operator|(
name|psd_image
operator|.
name|colmaplen
operator|%
literal|3
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"PSD: Colourmap looks screwed! Aiee!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"PSD: Indexed image has no colourmap!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|!=
literal|768
condition|)
name|printf
argument_list|(
literal|"PSD: Warning: Indexed image is %ld!=256 colours.\n"
argument_list|,
name|psd_image
operator|.
name|colmaplen
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|==
literal|768
condition|)
block|{
name|reshuffle_cmap
argument_list|(
name|psd_image
operator|.
name|colmapdata
argument_list|)
expr_stmt|;
name|gimp_image_set_colormap
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|colmapdata
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
block|}
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_aux
condition|)
block|{
switch|switch
condition|(
name|PSDheader
operator|.
name|mode
condition|)
block|{
case|case
literal|1
case|:
comment|/* Grayscale */
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Indexed Colour */
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* RGB Colour */
name|channels
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"aux? Aieeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee!!!!!!!!!\n"
argument_list|)
expr_stmt|;
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|channels
operator|=
name|PSDheader
operator|.
name|channels
operator|-
name|channels
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|absolute_alpha
condition|)
block|{
name|channels
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|channels
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|g_malloc
argument_list|(
name|step
operator|*
name|PSDheader
operator|.
name|columns
operator|*
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|compression
operator|==
literal|1
condition|)
block|{
name|nguchars
operator|=
name|PSDheader
operator|.
name|columns
operator|*
name|PSDheader
operator|.
name|rows
expr_stmt|;
name|temp
operator|=
name|g_malloc
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|temp
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"image data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmyk
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
if|if
condition|(
name|imagetype
operator|==
name|PSD_BITMAP_IMAGE
condition|)
comment|/* convert bitmap to grayscale */
block|{
name|guchar
modifier|*
name|monobuf
decl_stmt|;
name|monobuf
operator|=
name|g_malloc
argument_list|(
operator|(
operator|(
name|PSDheader
operator|.
name|columns
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
operator|>>
literal|3
argument_list|,
name|temp
argument_list|,
name|monobuf
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|bitmap2gray
argument_list|(
name|monobuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|monobuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
argument_list|,
name|temp
argument_list|,
name|dest
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|cmykbuf
operator|=
name|g_malloc
argument_list|(
name|step
operator|*
name|nguchars
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
argument_list|,
name|temp
argument_list|,
name|cmykbuf
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|cmyk2rgb
argument_list|(
name|cmykbuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|step
operator|>
literal|4
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmykbuf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cmyk
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
name|xfread_interlaced
argument_list|(
name|fd
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"raw image data"
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
name|cmykbuf
operator|=
name|g_malloc
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|xfread_interlaced
argument_list|(
name|fd
argument_list|,
name|cmykbuf
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"raw cmyk image data"
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|cmykp2rgb
argument_list|(
name|cmykbuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|step
operator|>
literal|4
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmykbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|want_aux
condition|)
comment|/* want_aux */
block|{
name|extract_channels
argument_list|(
name|dest
argument_list|,
name|channels
argument_list|,
name|step
argument_list|,
name|image_ID
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
goto|goto
name|finish_up
goto|;
comment|/* Haha!  Look!  A goto! */
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
operator|==
name|step
condition|)
comment|/* gimp bpp == psd bpp */
block|{
if|if
condition|(
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
operator|==
name|GIMP_INDEXEDA_IMAGE
condition|)
block|{
name|printf
argument_list|(
literal|"@@@@ Didn't know that this could happen...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
condition|;
name|iter
operator|++
control|)
block|{
name|dest
index|[
name|iter
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"Uhhh... uhm... extra channels... heavy...\n"
argument_list|)
decl_stmt|;
name|extract_data_and_channels
argument_list|(
name|dest
argument_list|,
name|channels
argument_list|,
name|step
argument_list|,
name|image_ID
argument_list|,
name|drawable
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_up
label|:
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|>
literal|0
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|colmapdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psd_image
operator|.
name|num_guides
operator|>
literal|0
condition|)
block|{
name|PSDguide
modifier|*
name|guide
init|=
name|psd_image
operator|.
name|guides
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"--- Adding %d Guides\n"
argument_list|,
name|psd_image
operator|.
name|num_guides
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|num_guides
condition|;
name|i
operator|++
operator|,
name|guide
operator|++
control|)
block|{
if|if
condition|(
name|guide
operator|->
name|horizontal
condition|)
name|gimp_image_add_hguide
argument_list|(
name|image_ID
argument_list|,
name|guide
operator|->
name|position
argument_list|)
expr_stmt|;
else|else
name|gimp_image_add_vguide
argument_list|(
name|image_ID
argument_list|,
name|guide
operator|->
name|position
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_displays_flush
argument_list|()
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"--- %d layers : pos %ld : a-alph %d ---\n"
argument_list|,
name|psd_image
operator|.
name|num_layers
argument_list|,
operator|(
name|long
name|int
operator|)
name|ftell
argument_list|(
name|fd
argument_list|)
argument_list|,
name|psd_image
operator|.
name|absolute_alpha
argument_list|)
decl_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|decode (long clen,long uclen,guchar * src,guchar * dst,int step)
name|decode
parameter_list|(
name|long
name|clen
parameter_list|,
name|long
name|uclen
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint32
name|l
decl_stmt|;
name|gushort
modifier|*
name|w
decl_stmt|;
name|l
operator|=
name|clen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
condition|;
operator|++
name|i
control|)
block|{
name|l
operator|-=
name|PSDheader
operator|.
name|rowlength
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
block|{
name|g_warning
argument_list|(
literal|"decode: %ld should be zero\n"
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
name|PSDheader
operator|.
name|rowlength
expr_stmt|;
name|packbitsdecode
argument_list|(
operator|&
name|clen
argument_list|,
name|uclen
argument_list|,
name|src
argument_list|,
name|dst
operator|++
argument_list|,
name|step
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|step
operator|-
literal|1
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
condition|;
operator|++
name|i
control|)
block|{
name|src
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
block|}
name|packbitsdecode
argument_list|(
operator|&
name|clen
argument_list|,
name|uclen
argument_list|,
name|src
argument_list|,
name|dst
operator|++
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"clen %ld\n"
argument_list|,
name|clen
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode a PackBits data stream.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|packbitsdecode (long * clenp,long uclen,guchar * src,guchar * dst,int step)
name|packbitsdecode
parameter_list|(
name|long
modifier|*
name|clenp
parameter_list|,
name|long
name|uclen
parameter_list|,
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|gint
name|n
decl_stmt|,
name|b
decl_stmt|;
name|gint32
name|clen
init|=
operator|*
name|clenp
decl_stmt|;
while|while
condition|(
operator|(
name|clen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uclen
operator|>
literal|0
operator|)
condition|)
block|{
name|n
operator|=
operator|(
name|int
operator|)
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* replicate next guchar -n+1 times */
name|clen
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|128
condition|)
comment|/* nop */
continue|continue;
name|n
operator|=
operator|-
name|n
operator|+
literal|1
expr_stmt|;
name|uclen
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|b
operator|=
operator|*
name|src
operator|++
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
operator|*
name|dst
operator|=
name|b
expr_stmt|;
name|dst
operator|+=
name|step
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* copy next n+1 guchars literally */
for|for
control|(
name|b
operator|=
operator|++
name|n
init|;
name|b
operator|>
literal|0
condition|;
operator|--
name|b
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|dst
operator|+=
name|step
expr_stmt|;
block|}
name|uclen
operator|-=
name|n
expr_stmt|;
name|clen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uclen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading image data\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
operator|*
name|clenp
operator|=
name|clen
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode a PackBits channel from file.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|unpack_pb_channel (FILE * fd,guchar * dst,gint32 unpackedlen,guint32 * offset)
name|unpack_pb_channel
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint32
name|unpackedlen
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|b
decl_stmt|;
name|gint32
name|upremain
init|=
name|unpackedlen
decl_stmt|;
while|while
condition|(
name|upremain
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|int
operator|)
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits1"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* replicate next guchar -n+1 times */
if|if
condition|(
name|n
operator|==
operator|-
literal|128
condition|)
comment|/* nop */
continue|continue;
name|n
operator|=
operator|-
name|n
operator|+
literal|1
expr_stmt|;
comment|/*	    upremain -= n;*/
name|b
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits2"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
name|upremain
operator|>=
literal|0
condition|)
block|{
operator|*
name|dst
operator|=
name|b
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
name|upremain
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* copy next n+1 guchars literally */
for|for
control|(
name|b
operator|=
operator|++
name|n
init|;
name|b
operator|>
literal|0
condition|;
operator|--
name|b
control|)
block|{
specifier|const
name|guchar
name|c
init|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits3"
argument_list|)
decl_stmt|;
if|if
condition|(
name|upremain
operator|>=
literal|0
condition|)
block|{
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|upremain
operator|--
expr_stmt|;
block|}
comment|/*	    upremain -= n;*/
block|}
block|}
if|if
condition|(
name|upremain
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"*** Unpacking overshot destination (%d) buffer by %d bytes!\n"
argument_list|,
name|unpackedlen
argument_list|,
operator|-
name|upremain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cmyk2rgb (unsigned char * src,unsigned char * dst,long width,long height,int alpha)
name|cmyk2rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|k
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|gimp_cmyk_to_rgb_int
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|g
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
literal|2.0
operator|*
operator|(
name|double
operator|)
name|height
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|height
operator|+
operator|(
name|double
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode planar CMYK(A) to RGB(A).  */
end_comment

begin_function
specifier|static
name|void
DECL|function|cmykp2rgb (unsigned char * src,unsigned char * dst,long width,long height,int alpha)
name|cmykp2rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|n
decl_stmt|;
name|guchar
modifier|*
name|rp
decl_stmt|,
modifier|*
name|gp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|kp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|n
operator|=
name|width
operator|*
name|height
expr_stmt|;
name|rp
operator|=
name|src
expr_stmt|;
name|gp
operator|=
name|rp
operator|+
name|n
expr_stmt|;
name|bp
operator|=
name|gp
operator|+
name|n
expr_stmt|;
name|kp
operator|=
name|bp
operator|+
name|n
expr_stmt|;
name|ap
operator|=
name|kp
operator|+
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|k
operator|=
operator|*
name|kp
operator|++
expr_stmt|;
name|gimp_cmyk_to_rgb_int
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|g
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
literal|2.0
operator|*
operator|(
name|double
operator|)
name|height
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|height
operator|+
operator|(
name|double
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|bitmap2gray (guchar * src,guchar * dest,long w,long h)
name|bitmap2gray
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|long
name|w
parameter_list|,
name|long
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
name|int
name|mask
init|=
literal|0x80
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|(
operator|*
name|src
operator|&
name|mask
operator|)
condition|?
literal|0
else|:
literal|255
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|!=
literal|0x80
condition|)
name|src
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dumpchunk (size_t n,FILE * fd,gchar * why)
name|dumpchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|int
operator|)
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|throwchunk (size_t n,FILE * fd,gchar * why)
name|throwchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|#
directive|if
literal|0
block|guchar *tmpchunk;    if (n==0)     {       return;     }    tmpchunk = g_malloc(n);   xfread(fd, tmpchunk, n, why);   g_free(tmpchunk);
else|#
directive|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fseek
argument_list|(
name|fd
argument_list|,
name|n
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to seek forward while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|getstring (size_t n,FILE * fd,gchar * why)
name|getstring
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gchar
modifier|*
name|tmpchunk
decl_stmt|;
name|tmpchunk
operator|=
name|g_malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|n
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|tmpchunk
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|tmpchunk
return|;
comment|/* caller should free memory */
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|getpascalstring (FILE * fd,gchar * why)
name|getpascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpchunk
decl_stmt|;
name|guchar
name|len
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|,
name|why
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tmpchunk
operator|=
name|g_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|tmpchunk
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|gchar
operator|*
operator|)
name|tmpchunk
return|;
comment|/* caller should free memory */
block|}
end_function

begin_function
specifier|static
name|guchar
DECL|function|getguchar (FILE * fd,gchar * why)
name|getguchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gint
name|tmp
decl_stmt|;
name|tmp
operator|=
name|fgetc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|EOF
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|gshort
DECL|function|getgshort (FILE * fd,gchar * why)
name|getgshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|guchar
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|b1
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|b2
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
return|return
call|(
name|gshort
call|)
argument_list|(
operator|(
name|b1
operator|*
literal|256
operator|)
operator|+
name|b2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|glong
DECL|function|getglong (FILE * fd,gchar * why)
name|getglong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|guchar
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|s4
decl_stmt|;
name|s1
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|s2
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|s3
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|s4
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
return|return
call|(
name|glong
call|)
argument_list|(
operator|(
name|s1
operator|*
literal|256
operator|*
literal|256
operator|*
literal|256
operator|)
operator|+
operator|(
name|s2
operator|*
literal|256
operator|*
literal|256
operator|)
operator|+
operator|(
name|s3
operator|*
literal|256
operator|)
operator|+
name|s4
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfread (FILE * fd,void * buf,long len,gchar * why)
name|xfread
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfread_interlaced (FILE * fd,guchar * buf,long len,gchar * why,gint step)
name|xfread_interlaced
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|,
name|gint
name|step
parameter_list|)
block|{
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gint
name|pix
decl_stmt|,
name|pos
decl_stmt|,
name|bpplane
decl_stmt|;
name|bpplane
operator|=
name|len
operator|/
name|step
expr_stmt|;
if|if
condition|(
name|len
operator|%
name|step
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Stern warning: data size is not a factor of step size!\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|step
condition|;
name|pix
operator|++
control|)
block|{
name|dest
operator|=
name|buf
operator|+
name|pix
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|bpplane
condition|;
name|pos
operator|++
control|)
block|{
operator|*
name|dest
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|step
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|read_whole_file (FILE * fd)
name|read_whole_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint16
name|w
decl_stmt|;
name|gint32
name|pos
decl_stmt|;
name|gchar
name|dummy
index|[
literal|6
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|PSDheader
operator|.
name|signature
argument_list|,
literal|4
argument_list|,
literal|"signature"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|version
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|dummy
argument_list|,
literal|6
argument_list|,
literal|"reserved"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|channels
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"channels"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|rows
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|columns
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"columns"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|bpp
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"depth"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|mode
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|num_layers
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|type
operator|=
name|PSDheader
operator|.
name|mode
expr_stmt|;
name|psd_image
operator|.
name|colmaplen
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|num_aux_channels
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|num_guides
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|colmaplen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|>
literal|0
condition|)
block|{
name|psd_image
operator|.
name|colmapdata
operator|=
name|g_malloc
argument_list|(
name|psd_image
operator|.
name|colmaplen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|psd_image
operator|.
name|colmapdata
argument_list|,
name|psd_image
operator|.
name|colmaplen
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|imgreslen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"image resource length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|imgreslen
operator|>
literal|0
condition|)
block|{
name|do_image_resources
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|miscsizelen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"misc size data length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|miscsizelen
operator|>
literal|0
condition|)
block|{
name|do_layer_and_mask
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|compression
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"compression"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"<<compr:%d>>"
argument_list|,
operator|(
name|int
operator|)
name|PSDheader
operator|.
name|compression
argument_list|)
decl_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|compression
operator|==
literal|1
condition|)
comment|/* RLE */
block|{
name|PSDheader
operator|.
name|rowlength
operator|=
name|g_malloc
argument_list|(
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
operator|*
sizeof|sizeof
argument_list|(
name|gushort
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
condition|;
operator|++
name|i
control|)
name|PSDheader
operator|.
name|rowlength
index|[
name|i
index|]
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|imgdatalen
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
operator|-
name|pos
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|PSDheader
operator|.
name|signature
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: not an Adobe Photoshop PSD file\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|PSDheader
operator|.
name|version
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad version number '%d', not 1\n"
argument_list|,
name|prog_name
argument_list|,
name|PSDheader
operator|.
name|version
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|PSDheader
operator|.
name|mode
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"HEAD:\n"
literal|"\tChannels %d\n\tRows %ld\n\tColumns %ld\n\tDepth %d\n\tMode %d (%s)\n"
literal|"\tColour data %ld guchars\n"
argument_list|,
name|PSDheader
operator|.
name|channels
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|bpp
argument_list|,
name|w
argument_list|,
name|modename
index|[
name|w
operator|<
literal|10
condition|?
name|w
else|:
literal|10
index|]
argument_list|,
name|psd_image
operator|.
name|colmaplen
argument_list|)
decl_stmt|;
comment|/*    printf("\tImage resource length: %lu\n", PSDheader.imgreslen);*/
name|IFDBG
name|printf
argument_list|(
literal|"\tLayer/Mask Data length: %lu\n"
argument_list|,
name|PSDheader
operator|.
name|miscsizelen
argument_list|)
decl_stmt|;
name|w
operator|=
name|PSDheader
operator|.
name|compression
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tCompression %d (%s)\n"
argument_list|,
name|w
argument_list|,
name|w
condition|?
literal|"RLE"
else|:
literal|"raw"
argument_list|)
decl_stmt|;
block|}
end_function

end_unit

