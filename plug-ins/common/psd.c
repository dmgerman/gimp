begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PSD Plugin version 2.0.1  * This GIMP plug-in is designed to load Adobe Photoshop(tm) files (.PSD)  *  * Adam D. Moss<adam@gimp.org><adam@foxbox.org>  *  *     If this plug-in fails to load a file which you think it should,  *     please tell me what seemed to go wrong, and anything you know  *     about the image you tried to load.  Please don't send big PSD  *     files to me without asking first.  *  *          Copyright (C) 1997-98 Adam D. Moss  *          Copyright (C) 1996    Torsten Martinsen  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Adobe and Adobe Photoshop are trademarks of Adobe Systems  * Incorporated that may be registered in certain jurisdictions.  */
end_comment

begin_comment
comment|/*  * Revision history:  *  *  1999.01.10 / v2.0.1 / Adam D. Moss  *       Greatly reduced memory requirements for layered image loading -  *       we now do just-in-time channel unpacking.  Some little  *       cleanups too.  *  *  1998.09.04 / v2.0.0 / Adam D. Moss  *       Now recognises and loads the new Guides extensions written  *       by Photoshop 4 and 5.  *  *  1998.07.31 / v1.9.9.9f / Adam D. Moss  *       Use OVERLAY_MODE if available.  *  *  1998.07.31 / v1.9.9.9e / Adam D. Moss  *       Worked around some buggy PSD savers (suspect PS4 on Mac) - ugh.  *       Fixed a bug when loading layer masks of certain dimensions.  *  *  1998.05.04 / v1.9.9.9b / Adam D. Moss  *       Changed the Pascal-style string-reading stuff.  That fixed  *       some file-padding problems.  Made all debugging output  *       compile-time optional (please leave it enabled for now).  *       Reduced memory requirements; still much room for improvement.  *  *  1998.04.28 / v1.9.9.9 / Adam D. Moss  *       Fixed the correct channel interlacing of 'raw' flat images.  *       Thanks to Christian Kirsch and Jay Cox for spotting this.  *       Changed some of the I/O routines.  *  *  1998.04.26 / v1.9.9.8 / Adam D. Moss  *       Implemented Aux-channels for layered files.  Got rid  *       of<endian.h> nonsense.  Improved Layer Mask padding.  *       Enforced num_layers/num_channels limit checks.  *  *  1998.04.23 / v1.9.9.5 / Adam D. Moss  *       Got Layer Masks working, got Aux-channels working  *       for unlayered files, fixed 'raw' channel loading, fixed  *       some other mini-bugs, slightly better progress meters.  *       Thanks to everyone who is helping with the testing!  *  *  1998.04.21 / v1.9.9.1 / Adam D. Moss  *       A little cleanup.  Implemented Layer Masks but disabled  *       them again - PS masks can be a different size to their  *       owning layer, unlike those in GIMP.  *  *  1998.04.19 / v1.9.9.0 / Adam D. Moss  *       Much happier now.  *  *  1997.03.13 / v1.9.0 / Adam D. Moss  *       Layers, channels and masks, oh my.  *       + Bugfixes& rearchitecturing.  *  *  1997.01.30 / v1.0.12 / Torsten Martinsen  *       Flat PSD image loading.  */
end_comment

begin_comment
comment|/*  * TODO:  *  *      Crush 16bpp channels (Wait until GIMP 2.0, probably)  *	CMYK -> RGB  *	Load BITMAP mode  *  *      File saving  */
end_comment

begin_comment
comment|/*  * BUGS:  *  *      Sometimes creates a superfluous aux channel?  Harmless.  */
end_comment

begin_comment
comment|/* *** USER DEFINES *** */
end_comment

begin_comment
comment|/* set to TRUE if you want debugging, FALSE otherwise */
end_comment

begin_define
DECL|macro|PSD_DEBUG
define|#
directive|define
name|PSD_DEBUG
value|TRUE
end_define

begin_comment
comment|/* the max number of layers that this plugin should try to load */
end_comment

begin_define
DECL|macro|MAX_LAYERS
define|#
directive|define
name|MAX_LAYERS
value|100
end_define

begin_comment
comment|/* the max number of channels that this plugin should let a layer have */
end_comment

begin_define
DECL|macro|MAX_CHANNELS
define|#
directive|define
name|MAX_CHANNELS
value|30
end_define

begin_comment
comment|/* the max number of guides that this plugin should let an image have */
end_comment

begin_define
DECL|macro|MAX_GUIDES
define|#
directive|define
name|MAX_GUIDES
value|200
end_define

begin_comment
comment|/* *** END OF USER DEFINES *** */
end_comment

begin_define
DECL|macro|IFDBG
define|#
directive|define
name|IFDBG
value|if (PSD_DEBUG)
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* Local types etc  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2b15dcf20103
block|{
DECL|enumerator|PSD_UNKNOWN_IMAGE
name|PSD_UNKNOWN_IMAGE
block|,
DECL|enumerator|PSD_RGB_IMAGE
name|PSD_RGB_IMAGE
block|,
DECL|enumerator|PSD_RGBA_IMAGE
name|PSD_RGBA_IMAGE
block|,
DECL|enumerator|PSD_GRAY_IMAGE
name|PSD_GRAY_IMAGE
block|,
DECL|enumerator|PSD_GRAYA_IMAGE
name|PSD_GRAYA_IMAGE
block|,
DECL|enumerator|PSD_INDEXED_IMAGE
name|PSD_INDEXED_IMAGE
block|,
DECL|enumerator|PSD_INDEXEDA_IMAGE
name|PSD_INDEXEDA_IMAGE
DECL|typedef|psd_imagetype
block|}
name|psd_imagetype
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdChannel
typedef|typedef
struct|struct
name|PsdChannel
block|{
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|data
name|guchar
modifier|*
name|data
decl_stmt|;
DECL|member|type
name|gint
name|type
decl_stmt|;
DECL|member|compressedsize
name|guint32
name|compressedsize
decl_stmt|;
DECL|member|fpos
name|fpos_t
name|fpos
decl_stmt|;
comment|/* Remember where the data is in the file, so we can 		  come back to it! */
comment|/* We can't just assume that the channel's width and height are the   * same as those of the layer that owns the channel, since this   * channel may be a layer mask, which Photoshop allows to have a   * different size from the layer which it applies to.   */
DECL|member|width
name|guint32
name|width
decl_stmt|;
DECL|member|height
name|guint32
name|height
decl_stmt|;
DECL|typedef|PSDchannel
block|}
name|PSDchannel
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdGuide
typedef|typedef
struct|struct
name|PsdGuide
block|{
DECL|member|horizontal
name|gboolean
name|horizontal
decl_stmt|;
comment|/* else vertical */
DECL|member|position
name|gint
name|position
decl_stmt|;
DECL|typedef|PSDguide
block|}
name|PSDguide
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdLayer
typedef|typedef
struct|struct
name|PsdLayer
block|{
DECL|member|num_channels
name|gint
name|num_channels
decl_stmt|;
DECL|member|channel
name|PSDchannel
name|channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
DECL|member|x
name|gint32
name|x
decl_stmt|;
DECL|member|y
name|gint32
name|y
decl_stmt|;
DECL|member|width
name|guint32
name|width
decl_stmt|;
DECL|member|height
name|guint32
name|height
decl_stmt|;
DECL|member|blendkey
name|gchar
name|blendkey
index|[
literal|4
index|]
decl_stmt|;
DECL|member|opacity
name|guchar
name|opacity
decl_stmt|;
DECL|member|clipping
name|gchar
name|clipping
decl_stmt|;
DECL|member|protecttrans
name|gboolean
name|protecttrans
decl_stmt|;
DECL|member|visible
name|gboolean
name|visible
decl_stmt|;
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|lm_x
name|gint32
name|lm_x
decl_stmt|;
DECL|member|lm_y
name|gint32
name|lm_y
decl_stmt|;
DECL|member|lm_width
name|gint32
name|lm_width
decl_stmt|;
DECL|member|lm_height
name|gint32
name|lm_height
decl_stmt|;
DECL|typedef|PSDlayer
block|}
name|PSDlayer
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdImage
typedef|typedef
struct|struct
name|PsdImage
block|{
DECL|member|num_layers
name|gint
name|num_layers
decl_stmt|;
DECL|member|layer
name|PSDlayer
name|layer
index|[
name|MAX_LAYERS
index|]
decl_stmt|;
DECL|member|absolute_alpha
name|gboolean
name|absolute_alpha
decl_stmt|;
DECL|member|type
name|gint
name|type
decl_stmt|;
DECL|member|colmaplen
name|gulong
name|colmaplen
decl_stmt|;
DECL|member|colmapdata
name|guchar
modifier|*
name|colmapdata
decl_stmt|;
DECL|member|num_aux_channels
name|guint
name|num_aux_channels
decl_stmt|;
DECL|member|aux_channel
name|PSDchannel
name|aux_channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
DECL|member|num_guides
name|guint
name|num_guides
decl_stmt|;
DECL|member|guides
name|PSDguide
name|guides
index|[
name|MAX_GUIDES
index|]
decl_stmt|;
DECL|member|caption
name|gchar
modifier|*
name|caption
decl_stmt|;
DECL|member|active_layer_num
name|guint
name|active_layer_num
decl_stmt|;
DECL|typedef|PSDimage
block|}
name|PSDimage
typedef|;
end_typedef

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GDrawableType
name|psd_type_to_gimp_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GImageType
name|psd_type_to_gimp_base_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GLayerMode
name|psd_lmode_to_gimp_lmode
parameter_list|(
name|gchar
name|modekey
index|[
literal|4
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Various local variables...  */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|psd_image
specifier|static
name|PSDimage
name|psd_image
decl_stmt|;
end_decl_stmt

begin_struct
DECL|struct|__anon2b15dcf20208
specifier|static
struct|struct
block|{
DECL|member|signature
name|gchar
name|signature
index|[
literal|4
index|]
decl_stmt|;
DECL|member|version
name|gushort
name|version
decl_stmt|;
DECL|member|reserved
name|guchar
name|reserved
index|[
literal|6
index|]
decl_stmt|;
DECL|member|channels
name|gushort
name|channels
decl_stmt|;
DECL|member|rows
name|gulong
name|rows
decl_stmt|;
DECL|member|columns
name|gulong
name|columns
decl_stmt|;
DECL|member|bpp
name|gushort
name|bpp
decl_stmt|;
DECL|member|mode
name|gushort
name|mode
decl_stmt|;
DECL|member|imgreslen
name|gulong
name|imgreslen
decl_stmt|;
DECL|member|miscsizelen
name|gulong
name|miscsizelen
decl_stmt|;
DECL|member|compression
name|gushort
name|compression
decl_stmt|;
DECL|member|rowlength
name|gushort
modifier|*
name|rowlength
decl_stmt|;
DECL|member|imgdatalen
name|long
name|imgdatalen
decl_stmt|;
DECL|variable|PSDheader
block|}
name|PSDheader
struct|;
end_struct

begin_decl_stmt
DECL|variable|modename
specifier|static
name|gchar
modifier|*
name|modename
index|[]
init|=
block|{
literal|"Bitmap"
block|,
literal|"Grayscale"
block|,
literal|"Indexed Colour"
block|,
literal|"RGB Colour"
block|,
literal|"CMYK Colour"
block|,
literal|"<invalid>"
block|,
literal|"<invalid>"
block|,
literal|"Multichannel"
block|,
literal|"Duotone"
block|,
literal|"Lab Colour"
block|,
literal|"<invalid>"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|prog_name
specifier|static
specifier|const
name|gchar
modifier|*
name|prog_name
init|=
literal|"PSD"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|unpack_pb_channel
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint32
name|unpackedlen
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode
parameter_list|(
name|long
name|clen
parameter_list|,
name|long
name|uclen
parameter_list|,
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|packbitsdecode
parameter_list|(
name|long
modifier|*
name|clenp
parameter_list|,
name|long
name|uclen
parameter_list|,
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmyk2rgb
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|destp
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmykp2rgb
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|destp
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmyk_to_rgb
parameter_list|(
name|int
modifier|*
name|c
parameter_list|,
name|int
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|k
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
name|getguchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gshort
name|getgshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|glong
name|getglong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfread
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfread_interlaced
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|,
name|gint
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_whole_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reshuffle_cmap
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|getpascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|getstring
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|throwchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seek_to_and_unpack_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint
name|layeri
parameter_list|,
name|gint
name|channeli
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nload_return_vals
init|=
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"loads files of the Photoshop(tm) PSD file format"
argument_list|,
literal|"This filter loads files of Adobe Photoshop(tm) native PSD format.  These files may be of any image type supported by GIMP, with or without layers, layer masks, aux channels and guides."
argument_list|,
literal|"Adam D. Moss& Torsten Martinsen"
argument_list|,
literal|"Adam D. Moss& Torsten Martinsen"
argument_list|,
literal|"1996-1998"
argument_list|,
literal|"<Load>/PSD"
argument_list|,
name|NULL
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_load_handler
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"psd"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (char * name,int nparams,GParam * param,int * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
comment|/*  GStatusType status = STATUS_SUCCESS;*/
name|gint32
name|image_ID
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_psd_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PARAM_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|GDrawableType
DECL|function|psd_type_to_gimp_type (psd_imagetype psdtype)
name|psd_type_to_gimp_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
name|PSD_RGBA_IMAGE
case|:
return|return
operator|(
name|RGBA_IMAGE
operator|)
return|;
case|case
name|PSD_RGB_IMAGE
case|:
return|return
operator|(
name|RGB_IMAGE
operator|)
return|;
case|case
name|PSD_GRAYA_IMAGE
case|:
return|return
operator|(
name|GRAYA_IMAGE
operator|)
return|;
case|case
name|PSD_GRAY_IMAGE
case|:
return|return
operator|(
name|GRAY_IMAGE
operator|)
return|;
case|case
name|PSD_INDEXEDA_IMAGE
case|:
return|return
operator|(
name|INDEXEDA_IMAGE
operator|)
return|;
case|case
name|PSD_INDEXED_IMAGE
case|:
return|return
operator|(
name|INDEXED_IMAGE
operator|)
return|;
default|default:
return|return
operator|(
name|RGB_IMAGE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|GLayerMode
DECL|function|psd_lmode_to_gimp_lmode (gchar modekey[4])
name|psd_lmode_to_gimp_lmode
parameter_list|(
name|gchar
name|modekey
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"norm"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NORMAL_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"dark"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DARKEN_ONLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"lite"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|LIGHTEN_ONLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hue "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|HUE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sat "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SATURATION_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"colr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|COLOR_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"mul "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|MULTIPLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"scrn"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SCREEN_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"diss"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DISSOLVE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"diff"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DIFFERENCE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"lum "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|VALUE_MODE
operator|)
return|;
if|#
directive|if
operator|(
name|GIMP_MAJOR_VERSION
operator|>
literal|0
operator|)
operator|&&
operator|(
name|GIMP_MINOR_VERSION
operator|>
literal|0
operator|)
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"over"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|OVERLAY_MODE
operator|)
return|;
name|printf
argument_list|(
literal|"PSD: Warning - unsupported layer-blend mode '%c%c%c%c', using "
literal|"'overlay' mode\n"
argument_list|,
name|modekey
index|[
literal|0
index|]
argument_list|,
name|modekey
index|[
literal|1
index|]
argument_list|,
name|modekey
index|[
literal|2
index|]
argument_list|,
name|modekey
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|OVERLAY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|OVERLAY_MODE
operator|)
return|;
else|#
directive|else
name|printf
argument_list|(
literal|"PSD: Warning - unsupported layer-blend mode '%c%c%c%c', using "
literal|"'addition' mode\n"
argument_list|,
name|modekey
index|[
literal|0
index|]
argument_list|,
name|modekey
index|[
literal|1
index|]
argument_list|,
name|modekey
index|[
literal|2
index|]
argument_list|,
name|modekey
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"over"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ADDITION_MODE
operator|)
return|;
comment|/* ? */
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|ADDITION_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|ADDITION_MODE
operator|)
return|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"PSD: Warning - UNKNOWN layer-blend mode, reverting to 'normal'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NORMAL_MODE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GImageType
DECL|function|psd_type_to_gimp_base_type (psd_imagetype psdtype)
name|psd_type_to_gimp_base_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
name|PSD_RGBA_IMAGE
case|:
case|case
name|PSD_RGB_IMAGE
case|:
return|return
operator|(
name|RGB
operator|)
return|;
case|case
name|PSD_GRAYA_IMAGE
case|:
case|case
name|PSD_GRAY_IMAGE
case|:
return|return
operator|(
name|GRAY
operator|)
return|;
case|case
name|PSD_INDEXEDA_IMAGE
case|:
case|case
name|PSD_INDEXED_IMAGE
case|:
return|return
operator|(
name|INDEXED
operator|)
return|;
default|default:
name|g_message
argument_list|(
literal|"PSD: Error: Can't convert PSD imagetype to GIMP imagetype\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
operator|(
name|RGB
operator|)
return|;
block|}
block|}
end_function

begin_function
name|GImageType
DECL|function|psd_mode_to_gimp_base_type (gushort psdtype)
name|psd_mode_to_gimp_base_type
parameter_list|(
name|gushort
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|GRAY
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|INDEXED
operator|)
return|;
case|case
literal|3
case|:
return|return
operator|(
name|RGB
operator|)
return|;
default|default:
name|g_message
argument_list|(
literal|"PSD: Error: Can't convert PSD mode to GIMP base imagetype\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
operator|(
name|RGB
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|reshuffle_cmap (guchar * map256)
name|reshuffle_cmap
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpmap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmpmap
operator|=
name|xmalloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|tmpmap
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|map256
index|[
name|i
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|256
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|512
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
block|{
name|map256
index|[
name|i
index|]
operator|=
name|tmpmap
index|[
name|i
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|tmpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dispatch_resID (guint ID,FILE * fd,guint32 * offset,guint32 Size)
name|dispatch_resID
parameter_list|(
name|guint
name|ID
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|,
name|guint32
name|Size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ID
operator|<
literal|0x0bb6
operator|)
operator|&&
operator|(
name|ID
operator|>
literal|0x07d0
operator|)
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tPath data is irrelevant to GIMP at this time.\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res path throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|ID
condition|)
block|{
case|case
literal|0x03ee
case|:
block|{
name|gint32
name|remaining
init|=
name|Size
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tALPHA CHANNEL NAMES:\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|guchar
name|slen
decl_stmt|;
name|gchar
modifier|*
name|sname
decl_stmt|;
name|slen
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"alpha channel name length"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
comment|/* Check for (Mac?) Photoshop (4?) file-writing bug */
if|if
condition|(
name|slen
operator|>
name|remaining
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\nYay, a file bug.  "
literal|"Yuck.  Photoshop 4/Mac?  "
literal|"I'll work around you.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|slen
condition|)
block|{
name|sname
operator|=
name|getstring
argument_list|(
name|slen
argument_list|,
name|fd
argument_list|,
literal|"alpha channel name"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
operator|=
name|sname
expr_stmt|;
block|}
else|else
block|{
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t\tNull channel name %d.\n"
argument_list|,
name|psd_image
operator|.
name|num_aux_channels
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
condition|)
block|{
name|guint32
name|alpha_name_len
decl_stmt|;
name|alpha_name_len
operator|=
name|strlen
argument_list|(
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tname: \"%s\"\n"
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|alpha_name_len
expr_stmt|;
name|remaining
operator|-=
name|alpha_name_len
expr_stmt|;
block|}
name|psd_image
operator|.
name|num_aux_channels
operator|++
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_aux_channels
operator|>
name|MAX_CHANNELS
condition|)
block|{
name|printf
argument_list|(
literal|"\nPSD: Sorry - this image has too many "
literal|"aux channels.  Tell Adam!\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|remaining
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|remaining
condition|)
block|{
name|dumpchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"alphaname padding 0 throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|remaining
expr_stmt|;
name|remaining
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x03ef
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDISPLAYINFO STRUCTURE: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f0
case|:
comment|/* FIXME: untested */
block|{
name|psd_image
operator|.
name|caption
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"caption string"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|caption
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tcontent: \"%s\"\n"
argument_list|,
name|psd_image
operator|.
name|caption
argument_list|)
decl_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|strlen
argument_list|(
name|psd_image
operator|.
name|caption
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x03f2
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tBACKGROUND COLOR: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f4
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tGREY/MULTICHANNEL HALFTONING INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f5
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tCOLOUR HALFTONING INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f6
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDUOTONE HALFTONING INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f7
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tGREYSCALE/MULTICHANNEL TRANSFER FUNCTION: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f8
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tCOLOUR TRANSFER FUNCTION: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f9
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDUOTONE TRANSFER FUNCTION: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fa
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tDUOTONE IMAGE INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fb
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tEFFECTIVE BLACK/WHITE VALUES: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fe
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tQUICK MASK INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0400
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLAYER STATE INFO:\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|active_layer_num
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"ID target_layer_num"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\ttarget: %d\n"
argument_list|,
operator|(
name|gint
operator|)
name|psd_image
operator|.
name|active_layer_num
argument_list|)
decl_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|0x0402
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLAYER GROUP INFO: unhandled\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t(Inferred number of layers: %d)\n"
argument_list|,
call|(
name|gint
call|)
argument_list|(
name|Size
operator|/
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0405
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\tIMAGE MODE FOR RAW FORMAT: unhandled\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0408
case|:
block|{
name|gint32
name|remaining
init|=
name|Size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tGUIDE INFORMATION:\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
name|glong
name|magic1
decl_stmt|,
name|magic2
decl_stmt|,
name|magic3
decl_stmt|;
name|glong
name|num_guides
decl_stmt|;
name|magic1
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|magic2
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|magic3
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|remaining
operator|-=
literal|12
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tMagic: %ld %ld %ld\n"
argument_list|,
name|magic1
argument_list|,
name|magic2
argument_list|,
name|magic3
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tMagic: %lx %lx %lx\n"
argument_list|,
name|magic1
argument_list|,
name|magic2
argument_list|,
name|magic3
argument_list|)
decl_stmt|;
name|num_guides
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|remaining
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|remaining
operator|!=
name|num_guides
operator|*
literal|5
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"** FUNNY AMOUNT OF GUIDE DATA (%d)\n"
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
goto|goto
name|funny_amount_of_guide_data
goto|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tNumber of guides is %ld\n"
argument_list|,
name|num_guides
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_guides
operator|>
name|MAX_GUIDES
condition|)
block|{
name|g_message
argument_list|(
literal|"Sorry, this image has too many Guides.  "
literal|"Tell Adam!\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|psd_image
operator|.
name|num_guides
operator|=
name|num_guides
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_guides
condition|;
name|i
operator|++
control|)
block|{
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|position
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
expr_stmt|;
comment|/* FIXME: not 32 -- magic enum/denom!? */
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|position
operator|=
name|rint
argument_list|(
operator|(
name|double
operator|)
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|position
operator|/
operator|(
name|double
operator|)
literal|32.0
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|horizontal
operator|=
operator|(
literal|1
operator|==
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"guide"
argument_list|)
operator|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|5
expr_stmt|;
name|remaining
operator|-=
literal|5
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tGuide %d at %d, %s\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|position
argument_list|,
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|horizontal
condition|?
literal|"horizontal"
else|:
literal|"vertical"
argument_list|)
decl_stmt|;
block|}
block|}
name|funny_amount_of_guide_data
label|:
if|if
condition|(
name|remaining
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"** GUIDE INFORMATION DROSS: "
argument_list|)
decl_stmt|;
name|dumpchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|remaining
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x03e9
case|:
case|case
literal|0x03ed
case|:
case|case
literal|0x03f1
case|:
case|case
literal|0x03f3
case|:
case|case
literal|0x03fd
case|:
case|case
literal|0x0401
case|:
case|case
literal|0x0404
case|:
case|case
literal|0x0406
case|:
case|case
literal|0x0bb7
case|:
case|case
literal|0x2710
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Field is irrelevant to GIMP at this time.>\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03e8
case|:
case|case
literal|0x03eb
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Obsolete Photoshop 2.0 field.>\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fc
case|:
case|case
literal|0x03ff
case|:
case|case
literal|0x0403
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Obsolete field.>\n"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"\t\t<Undocumented field.>\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|dumpchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
decl_stmt|;
else|else
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|Size
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_record (FILE * fd,guint32 * offset,gint layernum)
name|do_layer_record
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|,
name|gint
name|layernum
parameter_list|)
block|{
name|gint32
name|top
decl_stmt|,
name|left
decl_stmt|,
name|bottom
decl_stmt|,
name|right
decl_stmt|;
name|guint32
name|extradatasize
decl_stmt|,
name|layermaskdatasize
decl_stmt|,
name|layerrangesdatasize
decl_stmt|;
name|guint32
name|totaloff
decl_stmt|;
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|flags
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tLAYER RECORD (layer %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|layernum
argument_list|)
decl_stmt|;
comment|/* table 11-12 */
name|top
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer top"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|left
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer left"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|bottom
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer bottom"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|right
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer right"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|x
operator|=
name|left
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|y
operator|=
name|top
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|width
operator|=
name|right
operator|-
name|left
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|height
operator|=
name|bottom
operator|-
name|top
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer extents: (%d,%d) -> (%d,%d)\n"
argument_list|,
name|left
argument_list|,
name|top
argument_list|,
name|right
argument_list|,
name|bottom
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer num_channels"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
operator|>
name|MAX_CHANNELS
condition|)
block|{
name|g_message
argument_list|(
literal|"\nPSD: Sorry - this image has too many channels.  Tell Adam!\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tNumber of channels: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
comment|/* table 11-13 */
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tCHANNEL LENGTH INFO (%d)\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|type
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"channel id"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\tChannel TYPE: %d\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|type
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|compressedsize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"channeldatalength"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\tChannel Data Length: %d\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|compressedsize
argument_list|)
decl_stmt|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|sig
argument_list|,
literal|4
argument_list|,
literal|"layer blend sig"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sig
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"PSD: Error - layer blend signature is incorrect. :-(\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
argument_list|,
literal|4
argument_list|,
literal|"layer blend key"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tBlend type: PSD(\"%c%c%c%c\") = GIMP(%d)\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|0
index|]
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|1
index|]
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|2
index|]
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|3
index|]
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
argument_list|)
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|opacity
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer opacity"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer Opacity: %d\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|opacity
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|clipping
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer clipping"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer Clipping: %d (%s)\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|clipping
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|clipping
operator|==
literal|0
condition|?
literal|"base"
else|:
literal|"non-base"
argument_list|)
decl_stmt|;
name|flags
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer flags"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tLayer Flags: %d (%s, %s)\n"
argument_list|,
name|flags
argument_list|,
name|flags
operator|&
literal|1
condition|?
literal|"preserve transparency"
else|:
literal|"don't preserve transparency"
argument_list|,
name|flags
operator|&
literal|2
condition|?
literal|"visible"
else|:
literal|"not visible"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|protecttrans
operator|=
operator|(
name|flags
operator|&
literal|1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|visible
operator|=
operator|(
name|flags
operator|&
literal|2
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer record filler"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|extradatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer extra data size"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\tEXTRA DATA SIZE: %d\n"
argument_list|,
name|extradatasize
argument_list|)
decl_stmt|;
comment|/* FIXME: should do something with this data */
comment|/*throwchunk(extradatasize, fd, "layer extradata throw");   (*offset) += extradatasize;*/
name|totaloff
operator|=
operator|(
operator|*
name|offset
operator|)
operator|+
name|extradatasize
expr_stmt|;
comment|/* table 11-14 */
name|layermaskdatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer mask data size"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\tLAYER MASK DATA SIZE: %d\n"
argument_list|,
name|layermaskdatasize
argument_list|)
decl_stmt|;
if|if
condition|(
name|layermaskdatasize
condition|)
block|{
name|top
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask top"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|left
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask left"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|bottom
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask bottom"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|right
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask right"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_x
operator|=
name|left
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_y
operator|=
name|top
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_width
operator|=
name|right
operator|-
name|left
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|lm_height
operator|=
name|bottom
operator|-
name|top
expr_stmt|;
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"lmask data throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
comment|/*      throwchunk(layermaskdatasize, fd, "layer mask data throw");       (*offset) += layermaskdatasize;*/
block|}
name|layerrangesdatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer ranges data size"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\t\tLAYER RANGES DATA SIZE: %d\n"
argument_list|,
name|layermaskdatasize
argument_list|)
decl_stmt|;
if|if
condition|(
name|layerrangesdatasize
condition|)
block|{
name|throwchunk
argument_list|(
name|layerrangesdatasize
argument_list|,
name|fd
argument_list|,
literal|"layer ranges data throw"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|layerrangesdatasize
expr_stmt|;
block|}
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|name
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"layer name"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|name
condition|)
block|{
operator|(
operator|*
name|offset
operator|)
operator|+=
name|strlen
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\t\t\t\tLAYER NAME: '%s'\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|totaloff
operator|-
operator|(
operator|*
name|offset
operator|)
operator|>
literal|0
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"Warning: layer record dross: "
argument_list|)
expr_stmt|;
name|dumpchunk
argument_list|(
name|totaloff
operator|-
operator|(
operator|*
name|offset
operator|)
argument_list|,
name|fd
argument_list|,
literal|"layer record dross throw"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|throwchunk
argument_list|(
name|totaloff
operator|-
operator|(
operator|*
name|offset
operator|)
argument_list|,
name|fd
argument_list|,
literal|"layer record dross throw"
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|offset
operator|)
operator|=
name|totaloff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_struct (FILE * fd,guint32 * offset)
name|do_layer_struct
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLAYER STRUCTURE SECTION\n"
argument_list|)
decl_stmt|;
name|psd_image
operator|.
name|num_layers
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer struct numlayers"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tCanonical number of layers: %d%s\n"
argument_list|,
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|?
operator|(
name|int
operator|)
name|psd_image
operator|.
name|num_layers
else|:
name|abs
argument_list|(
name|psd_image
operator|.
name|num_layers
argument_list|)
argument_list|,
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|?
literal|""
else|:
literal|" (absolute/alpha)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_layers
operator|<
literal|0
condition|)
block|{
name|psd_image
operator|.
name|num_layers
operator|=
operator|-
name|psd_image
operator|.
name|num_layers
expr_stmt|;
name|psd_image
operator|.
name|absolute_alpha
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|psd_image
operator|.
name|absolute_alpha
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|psd_image
operator|.
name|num_layers
operator|>
name|MAX_LAYERS
condition|)
block|{
name|g_message
argument_list|(
literal|"\nPSD: Sorry - this image has too many layers.  Tell Adam!\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|i
operator|++
control|)
block|{
name|do_layer_record
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_pixeldata (FILE * fd,guint32 * offset)
name|do_layer_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|gint
name|layeri
decl_stmt|,
name|channeli
decl_stmt|;
for|for
control|(
name|layeri
operator|=
literal|0
init|;
name|layeri
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|layeri
operator|++
control|)
block|{
for|for
control|(
name|channeli
operator|=
literal|0
init|;
name|channeli
operator|<
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|num_channels
condition|;
name|channeli
operator|++
control|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|type
operator|==
operator|-
literal|2
condition|)
block|{
name|width
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|lm_width
expr_stmt|;
name|height
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|lm_height
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
expr_stmt|;
name|height
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
expr_stmt|;
block|}
name|fgetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|fpos
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|throwchunk
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|compressedsize
argument_list|,
name|fd
argument_list|,
literal|"channel data skip"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|compressedsize
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|seek_to_and_unpack_pixeldata (FILE * fd,gint layeri,gint channeli)
name|seek_to_and_unpack_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint
name|layeri
parameter_list|,
name|gint
name|channeli
parameter_list|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|guchar
modifier|*
name|tmpline
decl_stmt|;
name|gint
name|compression
decl_stmt|;
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|fsetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|fpos
argument_list|)
expr_stmt|;
name|compression
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer channel compression type"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|width
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|width
expr_stmt|;
name|height
operator|=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|height
expr_stmt|;
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t\tLayer (%d) Channel (%d:%d) Compression: %d (%s)\n"
argument_list|,
name|layeri
argument_list|,
name|channeli
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|type
argument_list|,
name|compression
argument_list|,
name|compression
operator|==
literal|0
condition|?
literal|"raw"
else|:
operator|(
name|compression
operator|==
literal|1
condition|?
literal|"RLE"
else|:
literal|"*UNKNOWN!*"
operator|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|data
operator|=
name|xmalloc
argument_list|(
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|tmpline
operator|=
name|xmalloc
argument_list|(
name|width
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* raw data */
block|{
name|gint
name|linei
decl_stmt|;
for|for
control|(
name|linei
operator|=
literal|0
init|;
name|linei
operator|<
name|height
condition|;
name|linei
operator|++
control|)
block|{
name|xfread
argument_list|(
name|fd
argument_list|,
operator|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|data
operator|+
name|linei
operator|*
name|width
operator|)
argument_list|,
name|width
argument_list|,
literal|"raw channel line"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|width
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Pad raw data to multiple of 2? */
block|if ((height * width)& 1) 	  { 	    getguchar(fd, "raw channel padding"); 	    offset++; 	  }
endif|#
directive|endif
block|}
break|break;
case|case
literal|1
case|:
comment|/* RLE, one row at a time, padded to an even width */
block|{
name|gint
name|linei
decl_stmt|;
name|gint
name|blockread
decl_stmt|;
comment|/* we throw this away because in theory we can trust the 	   data to unpack to the right length... hmm... */
name|throwchunk
argument_list|(
name|height
operator|*
literal|2
argument_list|,
name|fd
argument_list|,
literal|"widthlist"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|height
operator|*
literal|2
expr_stmt|;
name|blockread
operator|=
name|offset
expr_stmt|;
comment|/*IFDBG {printf("\nHere comes the guitar solo...\n"); 	  fflush(stdout);}*/
for|for
control|(
name|linei
operator|=
literal|0
init|;
name|linei
operator|<
name|height
condition|;
name|linei
operator|++
control|)
block|{
comment|/*printf(" %d ", *offset);*/
name|unpack_pb_channel
argument_list|(
name|fd
argument_list|,
name|tmpline
argument_list|,
name|width
comment|/*+ (width&1)*/
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|data
operator|+
name|linei
operator|*
name|width
operator|)
argument_list|,
name|tmpline
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\t\t\t\t\tActual compressed size was %d bytes\n"
argument_list|,
name|offset
operator|-
name|blockread
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* *unknown* */
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\nEEP!\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|g_message
argument_list|(
literal|"*** Unknown compression type in channel.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tmpline
condition|)
name|g_free
argument_list|(
name|tmpline
argument_list|)
expr_stmt|;
else|else
name|IFDBG
block|{
name|printf
argument_list|(
literal|"\nTRIED TO FREE NULL!"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layers (FILE * fd,guint32 * offset)
name|do_layers
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|guint32
name|section_length
decl_stmt|;
name|section_length
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layerinfo sectionlength"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tLAYER INFO SECTION\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tSECTION LENGTH: %u\n"
argument_list|,
name|section_length
argument_list|)
decl_stmt|;
name|do_layer_struct
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|do_layer_pixeldata
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_and_mask (FILE * fd)
name|do_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|guint32
name|Size
init|=
name|PSDheader
operator|.
name|miscsizelen
decl_stmt|;
name|guint32
name|offset_now
init|=
name|ftell
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"LAYER AND MASK INFO\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tSECTION LENGTH: %u\n"
argument_list|,
name|Size
argument_list|)
decl_stmt|;
if|if
condition|(
name|Size
operator|==
literal|0
condition|)
return|return;
name|do_layers
argument_list|(
name|fd
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|IFDBG
block|{
name|printf
argument_list|(
literal|"And...?\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
name|Size
condition|)
block|{
name|IFDBG
block|{
name|printf
argument_list|(
literal|"PSD: Supposedly there are %d bytes of mask info left.\n"
argument_list|,
name|Size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Size
operator|-
name|offset
operator|==
literal|4
operator|)
operator|||
operator|(
name|Size
operator|-
name|offset
operator|==
literal|24
operator|)
condition|)
name|printf
argument_list|(
literal|"     That sounds good to me.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     That sounds strange to me.\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      if ((getguchar(fd, "mask info throw")!=0) || 	  (getguchar(fd, "mask info throw")!=0) || 	  (getguchar(fd, "mask info throw")!=0) || 	  (getguchar(fd, "mask info throw")!=0)) 	{ 	  printf("*** This mask info block looks pretty bogus.\n"); 	}*/
block|}
else|else
name|printf
argument_list|(
literal|"PSD: Stern warning - no mask info.\n"
argument_list|)
expr_stmt|;
comment|/* If 'offset' wasn't being buggily updated, we wouldn't need this. (!?) */
name|fseek
argument_list|(
name|fd
argument_list|,
name|Size
operator|+
name|offset_now
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_image_resources (FILE * fd)
name|do_image_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint16
name|ID
decl_stmt|;
name|gchar
modifier|*
name|Name
decl_stmt|;
name|guint32
name|Size
decl_stmt|;
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"IMAGE RESOURCE BLOCK:\n"
argument_list|)
decl_stmt|;
comment|/* FIXME: too trusting that the file isn't corrupt */
while|while
condition|(
name|offset
operator|<
name|PSDheader
operator|.
name|imgreslen
operator|-
literal|1
condition|)
block|{
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|sig
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sig
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Error - imageresources block has invalid signature.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|offset
operator|+=
literal|4
expr_stmt|;
comment|/* generic information about a block ID */
name|ID
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"ID num"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tID: 0x%04x / "
argument_list|,
name|ID
argument_list|)
decl_stmt|;
name|Name
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"ID name"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|Name
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\"%s\" "
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|strlen
argument_list|(
name|Name
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID name throw"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|g_free
argument_list|(
name|Name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID name throw2"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|Size
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"ID Size"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Size: %d\n"
argument_list|,
name|Size
argument_list|)
decl_stmt|;
name|dispatch_resID
argument_list|(
name|ID
argument_list|,
name|fd
argument_list|,
operator|&
name|offset
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
operator|&
literal|1
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"+1"
argument_list|)
decl_stmt|;
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID content throw"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
comment|/*  if (offset != PSDheader.imgreslen)     {       printf("\tSucking imageres byte...\n");       throwchunk(1, fd, "imageres suck");       offset ++;     }*/
block|}
end_function

begin_function
specifier|static
DECL|function|chans_to_GRAYA (guchar * grey,guchar * alpha,gint numpix)
name|guchar
modifier|*
name|chans_to_GRAYA
parameter_list|(
name|guchar
modifier|*
name|grey
parameter_list|,
name|guchar
modifier|*
name|alpha
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* clearly, 'i' stands for 'Imaginative loop variable' */
if|if
condition|(
operator|(
name|grey
operator|==
name|NULL
operator|)
operator|||
operator|(
name|alpha
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"NULL channel - eep!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtn
operator|=
name|xmalloc
argument_list|(
name|numpix
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|2
index|]
operator|=
name|grey
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|alpha
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|chans_to_RGB (guchar * red,guchar * green,guchar * blue,gint numpix)
name|guchar
modifier|*
name|chans_to_RGB
parameter_list|(
name|guchar
modifier|*
name|red
parameter_list|,
name|guchar
modifier|*
name|green
parameter_list|,
name|guchar
modifier|*
name|blue
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|red
operator|==
name|NULL
operator|)
operator|||
operator|(
name|green
operator|==
name|NULL
operator|)
operator|||
operator|(
name|blue
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"NULL channel - eep!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtn
operator|=
name|xmalloc
argument_list|(
name|numpix
operator|*
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|red
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|green
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|blue
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|chans_to_RGBA (guchar * red,guchar * green,guchar * blue,guchar * alpha,gint numpix)
name|guchar
modifier|*
name|chans_to_RGBA
parameter_list|(
name|guchar
modifier|*
name|red
parameter_list|,
name|guchar
modifier|*
name|green
parameter_list|,
name|guchar
modifier|*
name|blue
parameter_list|,
name|guchar
modifier|*
name|alpha
parameter_list|,
name|gint
name|numpix
parameter_list|)
block|{
name|guchar
modifier|*
name|rtn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gboolean
name|careful
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|red
operator|==
name|NULL
operator|)
operator|||
operator|(
name|green
operator|==
name|NULL
operator|)
operator|||
operator|(
name|blue
operator|==
name|NULL
operator|)
operator|||
operator|(
name|alpha
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"chans_to_RGBA : NULL channel - eep!"
argument_list|)
expr_stmt|;
name|careful
operator|=
name|TRUE
expr_stmt|;
block|}
name|rtn
operator|=
name|xmalloc
argument_list|(
name|numpix
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|careful
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|red
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|green
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|blue
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
name|alpha
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpix
condition|;
name|i
operator|++
control|)
block|{
name|rtn
index|[
name|i
operator|*
literal|4
index|]
operator|=
operator|(
name|red
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|red
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
operator|(
name|green
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|green
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
operator|(
name|blue
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|blue
index|[
name|i
index|]
expr_stmt|;
name|rtn
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
operator|(
name|alpha
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|alpha
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|psd_layer_has_alpha (PSDlayer * layer)
name|gboolean
name|psd_layer_has_alpha
parameter_list|(
name|PSDlayer
modifier|*
name|layer
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layer
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|layer
operator|->
name|channel
index|[
name|i
index|]
operator|.
name|type
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|extract_data_and_channels (guchar * src,gint gimpstep,gint psstep,gint32 image_ID,GDrawable * drawable,gint width,gint height)
name|void
name|extract_data_and_channels
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|gimpstep
parameter_list|,
name|gint
name|psstep
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|GDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|guchar
modifier|*
name|primary_data
decl_stmt|;
name|guchar
modifier|*
name|aux_data
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Extracting primary channel data (%d channels)\n"
literal|"\tand %d auxiliary channels.\n"
argument_list|,
name|gimpstep
argument_list|,
name|psstep
operator|-
name|gimpstep
argument_list|)
decl_stmt|;
name|primary_data
operator|=
name|xmalloc
argument_list|(
name|width
operator|*
name|height
operator|*
name|gimpstep
argument_list|)
expr_stmt|;
block|{
name|int
name|pix
decl_stmt|,
name|chan
decl_stmt|;
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|width
operator|*
name|height
condition|;
name|pix
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|gimpstep
condition|;
name|chan
operator|++
control|)
block|{
name|primary_data
index|[
name|pix
operator|*
name|gimpstep
operator|+
name|chan
index|]
operator|=
name|src
index|[
name|pix
operator|*
name|psstep
operator|+
name|chan
index|]
expr_stmt|;
block|}
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|primary_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|primary_data
argument_list|)
expr_stmt|;
name|aux_data
operator|=
name|xmalloc
argument_list|(
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
block|{
name|int
name|pix
decl_stmt|,
name|chan
decl_stmt|;
name|gint32
name|channel_ID
decl_stmt|;
name|GDrawable
modifier|*
name|chdrawable
decl_stmt|;
name|guchar
name|colour
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|chan
operator|=
name|gimpstep
init|;
name|chan
operator|<
name|psstep
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|width
operator|*
name|height
condition|;
name|pix
operator|++
control|)
block|{
name|aux_data
index|[
name|pix
index|]
operator|=
name|src
index|[
name|pix
operator|*
name|psstep
operator|+
name|chan
index|]
expr_stmt|;
block|}
name|channel_ID
operator|=
name|gimp_channel_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|chan
operator|-
name|gimpstep
index|]
operator|.
name|name
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|100.0
argument_list|,
name|colour
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image_ID
argument_list|,
name|channel_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_channel_set_visible
argument_list|(
name|channel_ID
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chdrawable
operator|=
name|gimp_drawable_get
argument_list|(
name|channel_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|chdrawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|aux_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|aux_data
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Done with that.\n\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
specifier|static
DECL|function|extract_channels (guchar * src,gint num_wanted,gint psstep,gint32 image_ID,gint width,gint height)
name|void
name|extract_channels
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|num_wanted
parameter_list|,
name|gint
name|psstep
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|guchar
modifier|*
name|aux_data
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Extracting %d/%d auxiliary channels.\n"
argument_list|,
name|num_wanted
argument_list|,
name|psstep
argument_list|)
decl_stmt|;
name|aux_data
operator|=
name|xmalloc
argument_list|(
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
block|{
name|int
name|pix
decl_stmt|,
name|chan
decl_stmt|;
name|gint32
name|channel_ID
decl_stmt|;
name|GDrawable
modifier|*
name|chdrawable
decl_stmt|;
name|guchar
name|colour
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|chan
operator|=
name|psstep
operator|-
name|num_wanted
init|;
name|chan
operator|<
name|psstep
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|width
operator|*
name|height
condition|;
name|pix
operator|++
control|)
block|{
name|aux_data
index|[
name|pix
index|]
operator|=
name|src
index|[
name|pix
operator|*
name|psstep
operator|+
name|chan
index|]
expr_stmt|;
block|}
name|channel_ID
operator|=
name|gimp_channel_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|chan
operator|-
operator|(
name|psstep
operator|-
name|num_wanted
operator|)
index|]
operator|.
name|name
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|100.0
argument_list|,
name|colour
argument_list|)
expr_stmt|;
name|gimp_image_add_channel
argument_list|(
name|image_ID
argument_list|,
name|channel_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_channel_set_visible
argument_list|(
name|channel_ID
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chdrawable
operator|=
name|gimp_drawable_get
argument_list|(
name|channel_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|chdrawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|aux_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|chdrawable
operator|->
name|width
argument_list|,
name|chdrawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|chdrawable
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|aux_data
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Done with that.\n\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|resize_mask (guchar * src,guchar * dest,gint32 src_x,gint32 src_y,gint32 src_w,gint32 src_h,gint32 dest_w,gint32 dest_h)
name|resize_mask
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|,
name|gint32
name|src_x
parameter_list|,
name|gint32
name|src_y
parameter_list|,
name|gint32
name|src_w
parameter_list|,
name|gint32
name|src_h
parameter_list|,
name|gint32
name|dest_w
parameter_list|,
name|gint32
name|dest_h
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"--> %p %p : %d %d . %d %d . %d %d\n"
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|src_x
argument_list|,
name|src_y
argument_list|,
name|src_w
argument_list|,
name|src_h
argument_list|,
name|dest_w
argument_list|,
name|dest_h
argument_list|)
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dest_h
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dest_w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|>
name|src_x
operator|)
operator|&&
operator|(
name|x
operator|<
name|src_x
operator|+
name|src_w
operator|)
operator|&&
operator|(
name|y
operator|>
name|src_y
operator|)
operator|&&
operator|(
name|y
operator|<
name|src_y
operator|+
name|src_h
operator|)
condition|)
block|{
name|dest
index|[
name|dest_w
operator|*
name|y
operator|+
name|x
index|]
operator|=
name|src
index|[
name|src_w
operator|*
operator|(
name|y
operator|-
name|src_y
operator|)
operator|+
operator|(
name|x
operator|-
name|src_x
operator|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|dest
index|[
name|dest_w
operator|*
name|y
operator|+
name|x
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (char * name)
name|load_image
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|gboolean
name|want_aux
decl_stmt|;
name|char
modifier|*
name|name_buf
decl_stmt|;
name|guchar
modifier|*
name|cmykbuf
decl_stmt|;
specifier|static
name|int
name|number
init|=
literal|1
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|long
name|channels
decl_stmt|,
name|nguchars
decl_stmt|;
name|psd_imagetype
name|imagetype
decl_stmt|;
name|int
name|cmyk
init|=
literal|0
decl_stmt|,
name|step
init|=
literal|1
decl_stmt|;
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
name|gint32
name|layer_ID
init|=
operator|-
literal|1
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
init|=
name|NULL
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|gint32
name|iter
decl_stmt|;
name|fpos_t
name|tmpfpos
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"------- %s ---------------------------------\n"
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|name_buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"%s-%d"
argument_list|,
name|name
argument_list|,
name|number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"Loading %s:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't open \"%s\"\n"
argument_list|,
name|prog_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|read_whole_file
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|)
comment|/* PS3-style */
block|{
name|int
name|lnum
decl_stmt|;
name|GImageType
name|gimagetype
decl_stmt|;
name|gimagetype
operator|=
name|psd_mode_to_gimp_base_type
argument_list|(
name|PSDheader
operator|.
name|mode
argument_list|)
expr_stmt|;
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|gimagetype
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fgetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpfpos
argument_list|)
expr_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|lnum
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|lnum
operator|++
control|)
block|{
name|gint
name|numc
decl_stmt|;
name|guchar
modifier|*
name|merged_data
init|=
name|NULL
decl_stmt|;
name|numc
operator|=
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|num_channels
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"Hey, it's a LAYER with %d channels!\n"
argument_list|,
name|numc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|gimagetype
condition|)
block|{
case|case
name|GRAY
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"It's GRAY.\n"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|psd_layer_has_alpha
argument_list|(
operator|&
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
argument_list|)
condition|)
block|{
name|merged_data
operator|=
name|xmalloc
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|merged_data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|merged_data
operator|=
name|chans_to_GRAYA
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|name
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|,
operator|(
name|numc
operator|==
literal|1
operator|)
condition|?
name|GRAY_IMAGE
else|:
name|GRAYA_IMAGE
argument_list|,
operator|(
literal|100.0
operator|*
operator|(
name|double
operator|)
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|opacity
operator|)
operator|/
literal|255.0
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|blendkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
comment|/* case GRAY */
case|case
name|RGB
case|:
block|{
name|IFDBG
name|printf
argument_list|(
literal|"It's RGB.\n"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|psd_layer_has_alpha
argument_list|(
operator|&
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
argument_list|)
condition|)
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|merged_data
operator|=
name|chans_to_RGB
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|2
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|merged_data
operator|=
name|chans_to_RGBA
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|3
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|1
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|2
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|2
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|3
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
literal|3
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|name
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|,
operator|(
name|numc
operator|==
literal|3
operator|)
condition|?
name|RGB_IMAGE
else|:
name|RGBA_IMAGE
argument_list|,
operator|(
literal|100.0
operator|*
operator|(
name|double
operator|)
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|opacity
operator|)
operator|/
literal|255.0
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|blendkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
comment|/* case RGB */
default|default:
block|{
name|printf
argument_list|(
literal|"Error: Sorry, can't deal with a layered image of this type.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
break|break;
comment|/* default */
block|}
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do a layer mask if it exists */
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|num_channels
condition|;
name|iter
operator|++
control|)
block|{
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|iter
index|]
operator|.
name|type
operator|==
operator|-
literal|2
condition|)
comment|/* is mask */
block|{
name|gint32
name|mask_id
decl_stmt|;
name|guchar
modifier|*
name|lm_data
decl_stmt|;
name|lm_data
operator|=
name|xmalloc
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
block|{
name|seek_to_and_unpack_pixeldata
argument_list|(
name|fd
argument_list|,
name|lnum
argument_list|,
name|iter
argument_list|)
expr_stmt|;
comment|/* PS layer masks can be a different size to 		       their owning layer, so we have to resize them. */
name|resize_mask
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|iter
index|]
operator|.
name|data
argument_list|,
name|lm_data
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|lm_x
operator|-
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|x
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|lm_y
operator|-
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|y
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|lm_width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|lm_height
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
comment|/* won't be needing the original data any more */
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|iter
index|]
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|channel
index|[
name|iter
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* give it to GIMP */
name|mask_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_add_layer_mask
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
name|mask_id
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|mask_id
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|lm_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lm_data
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_layer_translate
argument_list|(
name|layer_ID
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|x
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|gimp_layer_set_preserve_transparency
argument_list|(
name|layer_ID
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|protecttrans
argument_list|)
expr_stmt|;
name|gimp_layer_set_visible
argument_list|(
name|layer_ID
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|visible
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|merged_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|width
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|lnum
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_data
condition|)
name|g_free
argument_list|(
name|merged_data
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|lnum
operator|+
literal|1.0
argument_list|)
operator|/
operator|(
name|double
operator|)
name|psd_image
operator|.
name|num_layers
argument_list|)
expr_stmt|;
block|}
name|fsetpos
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpfpos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|psd_image
operator|.
name|num_aux_channels
operator|>
literal|0
operator|)
operator|&&
operator|(
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
operator|)
condition|)
block|{
name|want_aux
operator|=
name|TRUE
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"::::::::::: WANT AUX :::::::::::::::::::::::::::::::::::::::\n"
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|want_aux
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|want_aux
operator|||
operator|(
name|psd_image
operator|.
name|num_layers
operator|==
literal|0
operator|)
condition|)
comment|/* Photoshop2-style: NO LAYERS. */
block|{
name|IFDBG
name|printf
argument_list|(
literal|"Image data %ld chars\n"
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
decl_stmt|;
name|step
operator|=
name|PSDheader
operator|.
name|channels
expr_stmt|;
name|imagetype
operator|=
name|PSD_UNKNOWN_IMAGE
expr_stmt|;
switch|switch
condition|(
name|PSDheader
operator|.
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* Bitmap */
break|break;
case|case
literal|1
case|:
comment|/* Grayscale */
name|imagetype
operator|=
name|PSD_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Indexed Colour */
name|imagetype
operator|=
name|PSD_INDEXED_IMAGE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* RGB Colour */
name|imagetype
operator|=
name|PSD_RGB_IMAGE
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* CMYK Colour */
name|cmyk
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|PSDheader
operator|.
name|channels
condition|)
block|{
case|case
literal|4
case|:
name|imagetype
operator|=
name|PSD_RGB_IMAGE
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|imagetype
operator|=
name|PSD_RGBA_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: cannot handle CMYK with more than 5 channels\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
break|break;
case|case
literal|7
case|:
comment|/* Multichannel (?) */
case|case
literal|8
case|:
comment|/* Duotone */
case|case
literal|9
case|:
comment|/* Lab Colour */
default|default:
break|break;
block|}
if|if
condition|(
name|imagetype
operator|==
name|PSD_UNKNOWN_IMAGE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Image type %d (%s) is not supported in this data format\n"
argument_list|,
name|prog_name
argument_list|,
name|PSDheader
operator|.
name|mode
argument_list|,
operator|(
name|PSDheader
operator|.
name|mode
operator|>
literal|10
operator|)
condition|?
literal|"<out of range>"
else|:
name|modename
index|[
name|PSDheader
operator|.
name|mode
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|PSDheader
operator|.
name|bpp
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"%s: The GIMP only supports 8-bit deep PSD images "
literal|"at this time.\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"psd:%d gimp:%d gimpbase:%d\n"
argument_list|,
name|imagetype
argument_list|,
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
argument_list|,
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|want_aux
condition|)
block|{
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
operator|==
name|INDEXED
condition|)
block|{
if|if
condition|(
operator|(
name|psd_image
operator|.
name|colmaplen
operator|%
literal|3
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"PSD: Colourmap looks screwed! Aiee!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"PSD: Indexed image has no colourmap!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|!=
literal|768
condition|)
name|printf
argument_list|(
literal|"PSD: Warning: Indexed image is %ld!=256 colours.\n"
argument_list|,
name|psd_image
operator|.
name|colmaplen
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|==
literal|768
condition|)
block|{
name|reshuffle_cmap
argument_list|(
name|psd_image
operator|.
name|colmapdata
argument_list|)
expr_stmt|;
name|gimp_image_set_cmap
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|colmapdata
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
block|}
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
literal|"Background"
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_aux
condition|)
block|{
switch|switch
condition|(
name|PSDheader
operator|.
name|mode
condition|)
block|{
case|case
literal|1
case|:
comment|/* Grayscale */
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Indexed Colour */
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* RGB Colour */
name|channels
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"aux? Aieeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee!!!!!!!!!\n"
argument_list|)
expr_stmt|;
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|channels
operator|=
name|PSDheader
operator|.
name|channels
operator|-
name|channels
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|absolute_alpha
condition|)
block|{
name|channels
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|channels
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|xmalloc
argument_list|(
name|step
operator|*
name|PSDheader
operator|.
name|columns
operator|*
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|compression
operator|==
literal|1
condition|)
block|{
name|nguchars
operator|=
name|PSDheader
operator|.
name|columns
operator|*
name|PSDheader
operator|.
name|rows
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|temp
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"image data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmyk
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
argument_list|,
name|temp
argument_list|,
name|dest
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
name|cmykbuf
operator|=
name|xmalloc
argument_list|(
name|step
operator|*
name|nguchars
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
argument_list|,
name|temp
argument_list|,
name|cmykbuf
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|cmyk2rgb
argument_list|(
name|cmykbuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|step
operator|>
literal|4
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmykbuf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cmyk
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
name|xfread_interlaced
argument_list|(
name|fd
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"raw image data"
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
name|cmykbuf
operator|=
name|xmalloc
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|xfread_interlaced
argument_list|(
name|fd
argument_list|,
name|cmykbuf
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"raw cmyk image data"
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|cmykp2rgb
argument_list|(
name|cmykbuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|step
operator|>
literal|4
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmykbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|want_aux
condition|)
comment|/* want_aux */
block|{
name|extract_channels
argument_list|(
name|dest
argument_list|,
name|channels
argument_list|,
name|step
argument_list|,
name|image_ID
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
goto|goto
name|finish_up
goto|;
comment|/* Haha!  Look!  A goto! */
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
operator|==
name|step
condition|)
comment|/* gimp bpp == psd bpp */
block|{
if|if
condition|(
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
operator|==
name|INDEXEDA_IMAGE
condition|)
block|{
name|printf
argument_list|(
literal|"@@@@ Didn't know that this could happen...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
condition|;
name|iter
operator|++
control|)
block|{
name|dest
index|[
name|iter
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"Uhhh... uhm... extra channels... heavy...\n"
argument_list|)
decl_stmt|;
name|extract_data_and_channels
argument_list|(
name|dest
argument_list|,
name|channels
argument_list|,
name|step
argument_list|,
name|image_ID
argument_list|,
name|drawable
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_up
label|:
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|>
literal|0
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|colmapdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psd_image
operator|.
name|num_guides
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"--- Adding %d Guides\n"
argument_list|,
name|psd_image
operator|.
name|num_guides
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|num_guides
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|horizontal
condition|)
name|gimp_image_add_hguide
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|position
argument_list|)
expr_stmt|;
else|else
name|gimp_image_add_vguide
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|guides
index|[
name|i
index|]
operator|.
name|position
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_displays_flush
argument_list|()
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"--- %d layers : pos %ld : a-alph %d ---\n"
argument_list|,
name|psd_image
operator|.
name|num_layers
argument_list|,
operator|(
name|long
name|int
operator|)
name|ftell
argument_list|(
name|fd
argument_list|)
argument_list|,
name|psd_image
operator|.
name|absolute_alpha
argument_list|)
decl_stmt|;
return|return
operator|(
name|image_ID
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|decode (long clen,long uclen,char * src,char * dst,int step)
name|decode
parameter_list|(
name|long
name|clen
parameter_list|,
name|long
name|uclen
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint32
name|l
decl_stmt|;
name|gushort
modifier|*
name|w
decl_stmt|;
name|l
operator|=
name|clen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
condition|;
operator|++
name|i
control|)
block|{
name|l
operator|-=
name|PSDheader
operator|.
name|rowlength
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
block|{
name|g_warning
argument_list|(
literal|"decode: %ld should be zero\n"
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
name|PSDheader
operator|.
name|rowlength
expr_stmt|;
name|packbitsdecode
argument_list|(
operator|&
name|clen
argument_list|,
name|uclen
argument_list|,
name|src
argument_list|,
name|dst
operator|++
argument_list|,
name|step
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|step
operator|-
literal|1
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
condition|;
operator|++
name|i
control|)
block|{
name|src
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
block|}
name|packbitsdecode
argument_list|(
operator|&
name|clen
argument_list|,
name|uclen
argument_list|,
name|src
argument_list|,
name|dst
operator|++
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"clen %ld\n"
argument_list|,
name|clen
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode a PackBits data stream.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|packbitsdecode (long * clenp,long uclen,char * src,char * dst,int step)
name|packbitsdecode
parameter_list|(
name|long
modifier|*
name|clenp
parameter_list|,
name|long
name|uclen
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|gint
name|n
decl_stmt|,
name|b
decl_stmt|;
name|gint32
name|clen
init|=
operator|*
name|clenp
decl_stmt|;
while|while
condition|(
operator|(
name|clen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uclen
operator|>
literal|0
operator|)
condition|)
block|{
name|n
operator|=
operator|(
name|int
operator|)
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* replicate next guchar -n+1 times */
name|clen
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|128
condition|)
comment|/* nop */
continue|continue;
name|n
operator|=
operator|-
name|n
operator|+
literal|1
expr_stmt|;
name|uclen
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|b
operator|=
operator|*
name|src
operator|++
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
operator|*
name|dst
operator|=
name|b
expr_stmt|;
name|dst
operator|+=
name|step
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* copy next n+1 guchars literally */
for|for
control|(
name|b
operator|=
operator|++
name|n
init|;
name|b
operator|>
literal|0
condition|;
operator|--
name|b
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|dst
operator|+=
name|step
expr_stmt|;
block|}
name|uclen
operator|-=
name|n
expr_stmt|;
name|clen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uclen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading image data\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
operator|*
name|clenp
operator|=
name|clen
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode a PackBits channel from file.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|unpack_pb_channel (FILE * fd,guchar * dst,gint32 unpackedlen,guint32 * offset)
name|unpack_pb_channel
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint32
name|unpackedlen
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|b
decl_stmt|;
name|gint32
name|upremain
init|=
name|unpackedlen
decl_stmt|;
while|while
condition|(
name|upremain
operator|>
literal|0
condition|)
block|{
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* replicate next guchar -n+1 times */
if|if
condition|(
name|n
operator|==
operator|-
literal|128
condition|)
comment|/* nop */
continue|continue;
name|n
operator|=
operator|-
name|n
operator|+
literal|1
expr_stmt|;
comment|/*	    upremain -= n;*/
name|b
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits2"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
operator|*
name|dst
operator|=
name|b
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|upremain
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* copy next n+1 guchars literally */
for|for
control|(
name|b
operator|=
operator|++
name|n
init|;
name|b
operator|>
literal|0
condition|;
operator|--
name|b
control|)
block|{
operator|*
name|dst
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits3"
argument_list|)
expr_stmt|;
empty_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|upremain
operator|--
expr_stmt|;
block|}
comment|/*	    upremain -= n;*/
block|}
block|}
if|if
condition|(
name|upremain
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"*** Unpacking overshot destination (%d) buffer by %d bytes!\n"
argument_list|,
name|unpackedlen
argument_list|,
operator|-
name|upremain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cmyk2rgb (unsigned char * src,unsigned char * dst,long width,long height,int alpha)
name|cmyk2rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|k
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|cmyk_to_rgb
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|g
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
literal|2.0
operator|*
operator|(
name|double
operator|)
name|height
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|height
operator|+
operator|(
name|double
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode planar CMYK(A) to RGB(A).  */
end_comment

begin_function
specifier|static
name|void
DECL|function|cmykp2rgb (unsigned char * src,unsigned char * dst,long width,long height,int alpha)
name|cmykp2rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|,
modifier|*
name|gp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|kp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|n
operator|=
name|width
operator|*
name|height
expr_stmt|;
name|rp
operator|=
name|src
expr_stmt|;
name|gp
operator|=
name|rp
operator|+
name|n
expr_stmt|;
name|bp
operator|=
name|gp
operator|+
name|n
expr_stmt|;
name|kp
operator|=
name|bp
operator|+
name|n
expr_stmt|;
name|ap
operator|=
name|kp
operator|+
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|k
operator|=
operator|*
name|kp
operator|++
expr_stmt|;
name|cmyk_to_rgb
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|g
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
literal|2.0
operator|*
operator|(
name|double
operator|)
name|height
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|height
operator|+
operator|(
name|double
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cmyk_to_rgb (gint * c,gint * m,gint * y,gint * k)
name|cmyk_to_rgb
parameter_list|(
name|gint
modifier|*
name|c
parameter_list|,
name|gint
modifier|*
name|m
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gint
modifier|*
name|k
parameter_list|)
block|{
if|#
directive|if
literal|0
block|gint cyan, magenta, yellow, black;      cyan = *c;     magenta = *m;     yellow = *y;     black = *k;      if (black> 0) { 	cyan -= black; 	magenta -= black; 	yellow -= black;     }     *c = 255 - cyan;     *m = 255 - magenta;     *y = 255 - yellow;     if (*c< 0) *c = 0; else if (*c> 255) *c = 255;     if (*m< 0) *m = 0; else if (*m> 255) *m = 255;     if (*y< 0) *y = 0; else if (*y> 255) *y = 255;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dumpchunk (size_t n,FILE * fd,gchar * why)
name|dumpchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|int
operator|)
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|throwchunk (size_t n,FILE * fd,gchar * why)
name|throwchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|#
directive|if
literal|0
block|guchar *tmpchunk;    if (n==0)     {       return;     }    tmpchunk = xmalloc(n);   xfread(fd, tmpchunk, n, why);   g_free(tmpchunk);
else|#
directive|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fseek
argument_list|(
name|fd
argument_list|,
name|n
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to seek forward while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|getstring (size_t n,FILE * fd,gchar * why)
name|getstring
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gchar
modifier|*
name|tmpchunk
decl_stmt|;
name|tmpchunk
operator|=
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|n
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|tmpchunk
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tmpchunk
operator|)
return|;
comment|/* caller should free memory */
block|}
end_function

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|getpascalstring (FILE * fd,gchar * why)
name|getpascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpchunk
decl_stmt|;
name|guchar
name|len
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|,
name|why
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tmpchunk
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|tmpchunk
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tmpchunk
operator|)
return|;
comment|/* caller should free memory */
block|}
end_function

begin_function
specifier|static
name|guchar
DECL|function|getguchar (FILE * fd,gchar * why)
name|getguchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gint
name|tmp
decl_stmt|;
name|tmp
operator|=
name|fgetc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|EOF
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gshort
DECL|function|getgshort (FILE * fd,gchar * why)
name|getgshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gushort
name|w
decl_stmt|;
name|guchar
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|b1
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|b2
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|w
operator|=
operator|(
name|b1
operator|*
literal|256
operator|)
operator|+
name|b2
expr_stmt|;
return|return
operator|(
operator|(
name|gshort
operator|)
name|w
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|glong
DECL|function|getglong (FILE * fd,gchar * why)
name|getglong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|s4
decl_stmt|;
name|gulong
name|w
decl_stmt|;
name|s1
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|s2
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|s3
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|s4
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|w
operator|=
operator|(
name|s1
operator|*
literal|256
operator|*
literal|256
operator|*
literal|256
operator|)
operator|+
operator|(
name|s2
operator|*
literal|256
operator|*
literal|256
operator|)
operator|+
operator|(
name|s3
operator|*
literal|256
operator|)
operator|+
name|s4
expr_stmt|;
return|return
operator|(
name|glong
operator|)
name|w
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfread (FILE * fd,void * buf,long len,gchar * why)
name|xfread
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfread_interlaced (FILE * fd,guchar * buf,long len,gchar * why,gint step)
name|xfread_interlaced
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|,
name|gint
name|step
parameter_list|)
block|{
name|guchar
modifier|*
name|dest
decl_stmt|;
name|gint
name|pix
decl_stmt|,
name|pos
decl_stmt|,
name|bpplane
decl_stmt|;
name|bpplane
operator|=
name|len
operator|/
name|step
expr_stmt|;
if|if
condition|(
name|len
operator|%
name|step
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Stern warning: data size is not a factor of step size!\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pix
operator|=
literal|0
init|;
name|pix
operator|<
name|step
condition|;
name|pix
operator|++
control|)
block|{
name|dest
operator|=
name|buf
operator|+
name|pix
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|bpplane
condition|;
name|pos
operator|++
control|)
block|{
operator|*
name|dest
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|step
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|xmalloc (size_t n)
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"PSD: WARNING: %s: xmalloc asked for zero-sized chunk\n"
argument_list|,
name|prog_name
argument_list|)
decl_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|g_malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
name|printf
argument_list|(
literal|"%s: out of memory\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|read_whole_file (FILE * fd)
name|read_whole_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint16
name|w
decl_stmt|;
name|gint32
name|pos
decl_stmt|;
name|gchar
name|dummy
index|[
literal|6
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|PSDheader
operator|.
name|signature
argument_list|,
literal|4
argument_list|,
literal|"signature"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|version
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|dummy
argument_list|,
literal|6
argument_list|,
literal|"reserved"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|channels
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"channels"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|rows
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|columns
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"columns"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|bpp
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"depth"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|mode
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|num_layers
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|type
operator|=
name|PSDheader
operator|.
name|mode
expr_stmt|;
name|psd_image
operator|.
name|colmaplen
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|num_aux_channels
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|num_guides
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|colmaplen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|>
literal|0
condition|)
block|{
name|psd_image
operator|.
name|colmapdata
operator|=
name|xmalloc
argument_list|(
name|psd_image
operator|.
name|colmaplen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|psd_image
operator|.
name|colmapdata
argument_list|,
name|psd_image
operator|.
name|colmaplen
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|imgreslen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"image resource length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|imgreslen
operator|>
literal|0
condition|)
block|{
name|do_image_resources
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|miscsizelen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"misc size data length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|miscsizelen
operator|>
literal|0
condition|)
block|{
name|do_layer_and_mask
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|compression
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"compression"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"<<compr:%d>>"
argument_list|,
operator|(
name|int
operator|)
name|PSDheader
operator|.
name|compression
argument_list|)
decl_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|compression
operator|==
literal|1
condition|)
comment|/* RLE */
block|{
name|PSDheader
operator|.
name|rowlength
operator|=
name|xmalloc
argument_list|(
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
operator|*
sizeof|sizeof
argument_list|(
name|gushort
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
condition|;
operator|++
name|i
control|)
name|PSDheader
operator|.
name|rowlength
index|[
name|i
index|]
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|imgdatalen
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
operator|-
name|pos
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|PSDheader
operator|.
name|signature
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: not an Adobe Photoshop PSD file\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|PSDheader
operator|.
name|version
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad version number '%d', not 1\n"
argument_list|,
name|prog_name
argument_list|,
name|PSDheader
operator|.
name|version
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|PSDheader
operator|.
name|mode
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"HEAD:\n"
literal|"\tChannels %d\n\tRows %ld\n\tColumns %ld\n\tDepth %d\n\tMode %d (%s)\n"
literal|"\tColour data %ld guchars\n"
argument_list|,
name|PSDheader
operator|.
name|channels
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|bpp
argument_list|,
name|w
argument_list|,
name|modename
index|[
name|w
operator|<
literal|10
condition|?
name|w
else|:
literal|10
index|]
argument_list|,
name|psd_image
operator|.
name|colmaplen
argument_list|)
decl_stmt|;
comment|/*    printf("\tImage resource length: %lu\n", PSDheader.imgreslen);*/
name|IFDBG
name|printf
argument_list|(
literal|"\tLayer/Mask Data length: %lu\n"
argument_list|,
name|PSDheader
operator|.
name|miscsizelen
argument_list|)
decl_stmt|;
name|w
operator|=
name|PSDheader
operator|.
name|compression
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tCompression %d (%s)\n"
argument_list|,
name|w
argument_list|,
name|w
condition|?
literal|"RLE"
else|:
literal|"raw"
argument_list|)
decl_stmt|;
block|}
end_function

end_unit

