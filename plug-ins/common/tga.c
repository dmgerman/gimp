begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * $Id$  * TrueVision Targa loading and saving file filter for the Gimp.  * Targa code Copyright (C) 1997 Raphael FRANCOIS and Gordon Matzigkeit  *  * The Targa reading and writing code was written from scratch by  * Raphael FRANCOIS<fraph@ibm.net> and Gordon Matzigkeit  *<gord@gnu.ai.mit.edu> based on the TrueVision TGA File Format  * Specification, Version 2.0:  *  *<URL:ftp://ftp.truevision.com/pub/TGA.File.Format.Spec/>  *  * It does not contain any code written for other TGA file loaders.  * Not even the RLE handling. ;)  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Release 1.2, 1997-09-24, Gordon Matzigkeit<gord@gnu.ai.mit.edu>:  *   - Bug fixes and source cleanups.  *  * Release 1.1, 1997-09-19, Gordon Matzigkeit<gord@gnu.ai.mit.edu>:  *   - Preserve alpha channels.  For indexed images, this can only be  *     done if there is at least one free colormap entry.  *  * Release 1.0, 1997-09-06, Gordon Matzigkeit<gord@gnu.ai.mit.edu>:  *   - Handle loading all image types from the 2.0 specification.  *   - Fix many alignment and endianness problems.  *   - Use tiles for lower memory consumption and better speed.  *   - Rewrite RLE code for clarity and speed.  *   - Handle saving with RLE.  *  * Release 0.9, 1997-06-18, Raphael FRANCOIS<fraph@ibm.net>:  *   - Can load 24 and 32-bit Truecolor images, with and without RLE.  *   - Saving currently only works without RLE.  *  *  * TODO:  *   - Handle loading images that aren't 8 bits per channel.  *   - Maybe handle special features in developer and extension sections  *     (the `save' dialogue would give access to them).  *   - The GIMP stores the indexed alpha channel as a separate byte,  *     one for each pixel.  The TGA file format spec requires that the  *     alpha channel be stored as part of the colormap, not with each  *     individual pixel.  This means that we have no good way of  *     saving and loading INDEXEDA images that use alpha channel values  *     other than 0 and 255.  Find a workaround.  */
end_comment

begin_define
DECL|macro|SAVE_ID_STRING
define|#
directive|define
name|SAVE_ID_STRING
value|"CREATOR: The GIMP's TGA Filter Version 1.2"
end_define

begin_comment
comment|/* Set these for debugging. */
end_comment

begin_comment
comment|/* #define PROFILE 1 */
end_comment

begin_comment
comment|/* #define VERBOSE 1 */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PROFILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* Round up a division to the nearest integer. */
end_comment

begin_define
DECL|macro|ROUNDUP_DIVIDE (n,d)
define|#
directive|define
name|ROUNDUP_DIVIDE
parameter_list|(
name|n
parameter_list|,
name|d
parameter_list|)
value|(((n) + (d - 1)) / (d))
end_define

begin_typedef
DECL|struct|_TgaSaveVals
typedef|typedef
struct|struct
name|_TgaSaveVals
block|{
DECL|member|rle
name|gint
name|rle
decl_stmt|;
DECL|typedef|TgaSaveVals
block|}
name|TgaSaveVals
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|tsvals
specifier|static
name|TgaSaveVals
name|tsvals
init|=
block|{
literal|1
block|,
comment|/* rle */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|_TgaSaveInterface
typedef|typedef
struct|struct
name|_TgaSaveInterface
block|{
DECL|member|run
name|gint
name|run
decl_stmt|;
DECL|typedef|TgaSaveInterface
block|}
name|TgaSaveInterface
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|tsint
specifier|static
name|TgaSaveInterface
name|tsint
init|=
block|{
name|FALSE
comment|/*  run  */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
DECL|struct|tga_header
struct|struct
name|tga_header
block|{
DECL|member|idLength
name|guint8
name|idLength
decl_stmt|;
DECL|member|colorMapType
name|guint8
name|colorMapType
decl_stmt|;
comment|/* The image type. */
DECL|macro|TGA_TYPE_MAPPED
define|#
directive|define
name|TGA_TYPE_MAPPED
value|1
DECL|macro|TGA_TYPE_COLOR
define|#
directive|define
name|TGA_TYPE_COLOR
value|2
DECL|macro|TGA_TYPE_GRAY
define|#
directive|define
name|TGA_TYPE_GRAY
value|3
DECL|macro|TGA_TYPE_MAPPED_RLE
define|#
directive|define
name|TGA_TYPE_MAPPED_RLE
value|9
DECL|macro|TGA_TYPE_COLOR_RLE
define|#
directive|define
name|TGA_TYPE_COLOR_RLE
value|10
DECL|macro|TGA_TYPE_GRAY_RLE
define|#
directive|define
name|TGA_TYPE_GRAY_RLE
value|11
DECL|member|imageType
name|guint8
name|imageType
decl_stmt|;
comment|/* Color Map Specification. */
comment|/* We need to separately specify high and low bytes to avoid endianness      and alignment problems. */
DECL|member|colorMapIndexLo
DECL|member|colorMapIndexHi
name|guint8
name|colorMapIndexLo
decl_stmt|,
name|colorMapIndexHi
decl_stmt|;
DECL|member|colorMapLengthLo
DECL|member|colorMapLengthHi
name|guint8
name|colorMapLengthLo
decl_stmt|,
name|colorMapLengthHi
decl_stmt|;
DECL|member|colorMapSize
name|guint8
name|colorMapSize
decl_stmt|;
comment|/* Image Specification. */
DECL|member|xOriginLo
DECL|member|xOriginHi
name|guint8
name|xOriginLo
decl_stmt|,
name|xOriginHi
decl_stmt|;
DECL|member|yOriginLo
DECL|member|yOriginHi
name|guint8
name|yOriginLo
decl_stmt|,
name|yOriginHi
decl_stmt|;
DECL|member|widthLo
DECL|member|widthHi
name|guint8
name|widthLo
decl_stmt|,
name|widthHi
decl_stmt|;
DECL|member|heightLo
DECL|member|heightHi
name|guint8
name|heightLo
decl_stmt|,
name|heightHi
decl_stmt|;
DECL|member|bpp
name|guint8
name|bpp
decl_stmt|;
comment|/* Image descriptor.      3-0: attribute bpp      4:   left-to-right ordering      5:   top-to-bottom ordering      7-6: zero      */
DECL|macro|TGA_DESC_ABITS
define|#
directive|define
name|TGA_DESC_ABITS
value|0x0f
DECL|macro|TGA_DESC_HORIZONTAL
define|#
directive|define
name|TGA_DESC_HORIZONTAL
value|0x10
DECL|macro|TGA_DESC_VERTICAL
define|#
directive|define
name|TGA_DESC_VERTICAL
value|0x20
DECL|member|descriptor
name|guint8
name|descriptor
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2b3b8fa20108
block|{
DECL|member|extensionAreaOffset
name|guint32
name|extensionAreaOffset
decl_stmt|;
DECL|member|developerDirectoryOffset
name|guint32
name|developerDirectoryOffset
decl_stmt|;
DECL|macro|TGA_SIGNATURE
define|#
directive|define
name|TGA_SIGNATURE
value|"TRUEVISION-XFILE"
DECL|member|signature
name|gchar
name|signature
index|[
literal|16
index|]
decl_stmt|;
DECL|member|dot
name|gchar
name|dot
decl_stmt|;
DECL|member|null
name|gchar
name|null
decl_stmt|;
DECL|variable|tga_footer
block|}
name|tga_footer
struct|;
end_struct

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_gtk
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|MAIN
argument_list|()
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|VERBOSE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
name|VERBOSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|query (void)
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|gint
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|gint
name|nload_return_vals
init|=
operator|(
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
specifier|static
name|GParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"rle"
block|,
literal|"Enable RLE compression"
block|}
block|,   }
decl_stmt|;
specifier|static
name|gint
name|nsave_args
init|=
sizeof|sizeof
argument_list|(
name|save_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|save_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_tga_load"
argument_list|,
literal|"Loads files of Targa file format"
argument_list|,
literal|"FIXME: write help for tga_load"
argument_list|,
literal|"Raphael FRANCOIS, Gordon Matzigkeit"
argument_list|,
literal|"Raphael FRANCOIS, Gordon Matzigkeit"
argument_list|,
literal|"1997"
argument_list|,
literal|"<Load>/TGA"
argument_list|,
name|NULL
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_tga_save"
argument_list|,
literal|"saves files in the Targa file format"
argument_list|,
literal|"FIXME: write help for tga_save"
argument_list|,
literal|"Raphael FRANCOIS, Gordon Matzigkeit"
argument_list|,
literal|"Raphael FRANCOIS, Gordon Matzigkeit"
argument_list|,
literal|"1997"
argument_list|,
literal|"<Save>/TGA"
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nsave_args
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
literal|"file_tga_load"
argument_list|,
literal|"tga"
argument_list|,
literal|""
argument_list|,
literal|"0&,byte,10,2&,byte,1,3&,byte,>0,3,byte,<9"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_tga_save"
argument_list|,
literal|"tga"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparams,GParam * param,gint * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|GimpExportReturnType
name|export
init|=
name|EXPORT_CANCEL
decl_stmt|;
ifdef|#
directive|ifdef
name|PROFILE
name|struct
name|tms
name|tbuf1
decl_stmt|,
name|tbuf2
decl_stmt|;
endif|#
directive|endif
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: RUN %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_tga_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INIT_I18N
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILE
name|times
argument_list|(
operator|&
name|tbuf1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PARAM_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_tga_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INIT_I18N_UI
argument_list|()
expr_stmt|;
name|init_gtk
argument_list|()
expr_stmt|;
name|image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
case|case
name|RUN_WITH_LAST_VALS
case|:
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
literal|"TGA"
argument_list|,
operator|(
name|CAN_HANDLE_RGB
operator||
name|CAN_HANDLE_GRAY
operator||
name|CAN_HANDLE_INDEXED
operator||
name|CAN_HANDLE_ALPHA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_tga_save"
argument_list|,
operator|&
name|tsvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
name|status
operator|=
name|STATUS_CANCEL
expr_stmt|;
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|6
condition|)
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|tsvals
operator|.
name|rle
operator|=
operator|(
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_tga_save"
argument_list|,
operator|&
name|tsvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|PROFILE
name|times
argument_list|(
operator|&
name|tbuf1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|)
condition|)
block|{
comment|/*  Store psvals data  */
name|gimp_set_data
argument_list|(
literal|"file_tga_save"
argument_list|,
operator|&
name|tsvals
argument_list|,
sizeof|sizeof
argument_list|(
name|tsvals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILE
name|times
argument_list|(
operator|&
name|tbuf2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TGA: %s profile: %ld user %ld system\n"
argument_list|,
name|name
argument_list|,
operator|(
name|long
operator|)
name|tbuf2
operator|.
name|tms_utime
operator|-
name|tbuf1
operator|.
name|tms_utime
argument_list|,
operator|(
name|long
operator|)
name|tbuf2
operator|.
name|tms_stime
operator|-
name|tbuf2
operator|.
name|tms_stime
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function_decl
specifier|static
name|gint32
name|ReadImage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|tga_header
modifier|*
name|hdr
parameter_list|,
name|gchar
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|gint32
DECL|function|load_image (gchar * filename)
name|load_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|name_buf
decl_stmt|;
name|struct
name|tga_header
name|hdr
decl_stmt|;
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|g_message
argument_list|(
literal|"TGA: can't open \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|name_buf
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Loading %s:"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
comment|/* Check the footer. */
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|tga_footer
argument_list|)
operator|)
argument_list|,
name|SEEK_END
argument_list|)
operator|||
name|fread
argument_list|(
operator|&
name|tga_footer
argument_list|,
sizeof|sizeof
argument_list|(
name|tga_footer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"TGA: Cannot read footer from \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check the signature. */
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|memcmp
argument_list|(
name|tga_footer
operator|.
name|signature
argument_list|,
name|TGA_SIGNATURE
argument_list|,
sizeof|sizeof
argument_list|(
name|tga_footer
operator|.
name|signature
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: found New TGA\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: found Original TGA\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|||
name|fread
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"TGA: Cannot read header from \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Skip the image ID field. */
if|if
condition|(
name|hdr
operator|.
name|idLength
operator|&&
name|fseek
argument_list|(
name|fp
argument_list|,
name|hdr
operator|.
name|idLength
argument_list|,
name|SEEK_CUR
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"TGA: Cannot skip ID field in \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|image_ID
operator|=
name|ReadImage
argument_list|(
name|fp
argument_list|,
operator|&
name|hdr
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VERBOSE
end_ifdef

begin_decl_stmt
DECL|variable|totbytes
specifier|static
name|int
name|totbytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
DECL|function|std_fread (guchar * buf,int datasize,int nelems,FILE * fp)
name|std_fread
parameter_list|(
name|guchar
modifier|*
name|buf
parameter_list|,
name|int
name|datasize
parameter_list|,
name|int
name|nelems
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|totbytes
operator|+=
name|nelems
operator|*
name|datasize
expr_stmt|;
name|printf
argument_list|(
literal|"TGA: std_fread %d (total %d)\n"
argument_list|,
name|nelems
operator|*
name|datasize
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fread
argument_list|(
name|buf
argument_list|,
name|datasize
argument_list|,
name|nelems
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|std_fwrite (guchar * buf,int datasize,int nelems,FILE * fp)
name|std_fwrite
parameter_list|(
name|guchar
modifier|*
name|buf
parameter_list|,
name|int
name|datasize
parameter_list|,
name|int
name|nelems
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|totbytes
operator|+=
name|nelems
operator|*
name|datasize
expr_stmt|;
name|printf
argument_list|(
literal|"TGA: std_fwrite %d (total %d)\n"
argument_list|,
name|nelems
operator|*
name|datasize
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fwrite
argument_list|(
name|buf
argument_list|,
name|datasize
argument_list|,
name|nelems
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_define
DECL|macro|RLE_PACKETSIZE
define|#
directive|define
name|RLE_PACKETSIZE
value|0x80
end_define

begin_comment
comment|/* Decode a bufferful of file. */
end_comment

begin_function
specifier|static
name|int
DECL|function|rle_fread (guchar * buf,int datasize,int nelems,FILE * fp)
name|rle_fread
parameter_list|(
name|guchar
modifier|*
name|buf
parameter_list|,
name|int
name|datasize
parameter_list|,
name|int
name|nelems
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|guchar
modifier|*
name|statebuf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|statelen
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|laststate
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|count
decl_stmt|,
name|bytes
decl_stmt|;
name|guchar
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|int
name|curbytes
init|=
name|totbytes
decl_stmt|;
endif|#
directive|endif
comment|/* Scale the buffer length. */
name|buflen
operator|=
name|nelems
operator|*
name|datasize
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|buflen
condition|)
block|{
if|if
condition|(
name|laststate
operator|<
name|statelen
condition|)
block|{
comment|/* Copy bytes from our previously decoded buffer. */
name|bytes
operator|=
name|MIN
argument_list|(
name|buflen
operator|-
name|j
argument_list|,
name|statelen
operator|-
name|laststate
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|j
argument_list|,
name|statebuf
operator|+
name|laststate
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|j
operator|+=
name|bytes
expr_stmt|;
name|laststate
operator|+=
name|bytes
expr_stmt|;
comment|/* If we used up all of our state bytes, then reset them. */
if|if
condition|(
name|laststate
operator|>=
name|statelen
condition|)
block|{
name|laststate
operator|=
literal|0
expr_stmt|;
name|statelen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we filled the buffer, then exit the loop. */
if|if
condition|(
name|j
operator|>=
name|buflen
condition|)
break|break;
block|}
comment|/* Decode the next packet. */
name|count
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|EOF
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: hit EOF while looking for count\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|j
operator|/
name|datasize
return|;
block|}
comment|/* Scale the byte length to the size of the data. */
name|bytes
operator|=
operator|(
operator|(
name|count
operator|&
operator|~
name|RLE_PACKETSIZE
operator|)
operator|+
literal|1
operator|)
operator|*
name|datasize
expr_stmt|;
if|if
condition|(
name|j
operator|+
name|bytes
operator|<=
name|buflen
condition|)
block|{
comment|/* We can copy directly into the image buffer. */
name|p
operator|=
name|buf
operator|+
name|j
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|PROFILE
argument_list|)
operator|||
name|defined
argument_list|(
name|VERBOSE
argument_list|)
name|printf
argument_list|(
literal|"TGA: needed to use statebuf for %d bytes\n"
argument_list|,
name|buflen
operator|-
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate the state buffer if we haven't already. */
if|if
condition|(
operator|!
name|statebuf
condition|)
name|statebuf
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|RLE_PACKETSIZE
operator|*
name|datasize
argument_list|)
expr_stmt|;
name|p
operator|=
name|statebuf
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
name|RLE_PACKETSIZE
condition|)
block|{
comment|/* Fill the buffer with the next value. */
if|if
condition|(
name|fread
argument_list|(
name|p
argument_list|,
name|datasize
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: EOF while reading %d/%d element RLE packet\n"
argument_list|,
name|bytes
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|j
operator|/
name|datasize
return|;
block|}
comment|/* Optimized case for single-byte encoded data. */
if|if
condition|(
name|datasize
operator|==
literal|1
condition|)
name|memset
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|*
name|p
argument_list|,
name|bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|k
operator|=
name|datasize
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|+=
name|datasize
control|)
name|memcpy
argument_list|(
name|p
operator|+
name|k
argument_list|,
name|p
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read in the buffer. */
if|if
condition|(
name|fread
argument_list|(
name|p
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: EOF while reading %d/%d element raw packet\n"
argument_list|,
name|bytes
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|j
operator|/
name|datasize
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|totbytes
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"TGA: %s packet %d/%d\n"
argument_list|,
operator|(
name|count
operator|&
name|RLE_PACKETSIZE
operator|)
condition|?
literal|"RLE"
else|:
literal|"raw"
argument_list|,
name|bytes
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We may need to copy bytes from the state buffer. */
if|if
condition|(
name|p
operator|==
name|statebuf
condition|)
name|statelen
operator|=
name|bytes
expr_stmt|;
else|else
name|j
operator|+=
name|bytes
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: rle_fread %d/%d (total %d)\n"
argument_list|,
name|nelems
operator|*
name|datasize
argument_list|,
name|totbytes
operator|-
name|curbytes
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|nelems
return|;
block|}
end_function

begin_comment
comment|/* This function is stateless, which means that we always finish packets    on buffer boundaries.  As a beneficial side-effect, rle_fread    never has to allocate a state buffer when it loads our files, provided    it is called using the same buffer lengths!     So, we get better compression than line-by-line encoders, and better    loading performance than whole-stream images. */
end_comment

begin_comment
comment|/* RunLength Encode a bufferful of file. */
end_comment

begin_function
specifier|static
name|int
DECL|function|rle_fwrite (guchar * buf,int datasize,int nelems,FILE * fp)
name|rle_fwrite
parameter_list|(
name|guchar
modifier|*
name|buf
parameter_list|,
name|int
name|datasize
parameter_list|,
name|int
name|nelems
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
comment|/* Now runlength-encode the whole buffer. */
name|int
name|count
decl_stmt|,
name|j
decl_stmt|,
name|buflen
decl_stmt|;
name|guchar
modifier|*
name|begin
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|int
name|curbytes
init|=
name|totbytes
decl_stmt|;
endif|#
directive|endif
comment|/* Scale the buffer length. */
name|buflen
operator|=
name|datasize
operator|*
name|nelems
expr_stmt|;
name|begin
operator|=
name|buf
expr_stmt|;
name|j
operator|=
name|datasize
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|buflen
condition|)
block|{
comment|/* BUF[J] is our lookahead element, BEGIN is the beginning of this 	 run, and COUNT is the number of elements in this run. */
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|j
argument_list|,
name|begin
argument_list|,
name|datasize
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We have a run of identical characters. */
name|count
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|j
operator|+=
name|datasize
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|buflen
operator|&&
name|count
operator|<
name|RLE_PACKETSIZE
operator|&&
name|memcmp
argument_list|(
name|buf
operator|+
name|j
argument_list|,
name|begin
argument_list|,
name|datasize
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* J now either points to the beginning of the next run, 	     or close to the end of the buffer. */
comment|/* Write out the run. */
if|if
condition|(
name|fputc
argument_list|(
operator|(
name|count
operator|-
literal|1
operator|)
operator||
name|RLE_PACKETSIZE
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|||
name|fwrite
argument_list|(
name|begin
argument_list|,
name|datasize
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|totbytes
operator|+=
name|count
operator|*
name|datasize
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"TGA: RLE packet %d/%d\n"
argument_list|,
name|count
operator|*
name|datasize
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We have a run of raw characters. */
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|j
operator|+=
name|datasize
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|buflen
operator|&&
name|count
operator|<
name|RLE_PACKETSIZE
operator|&&
name|memcmp
argument_list|(
name|buf
operator|+
name|j
operator|-
name|datasize
argument_list|,
name|buf
operator|+
name|j
argument_list|,
name|datasize
argument_list|)
operator|!=
literal|0
condition|)
do|;
comment|/* Back up to the previous character. */
name|j
operator|-=
name|datasize
expr_stmt|;
comment|/* J now either points to the beginning of the next run, 	     or at the end of the buffer. */
comment|/* Write out the raw packet. */
if|if
condition|(
name|fputc
argument_list|(
name|count
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|||
name|fwrite
argument_list|(
name|begin
argument_list|,
name|datasize
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
operator|!=
name|count
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|totbytes
operator|+=
name|count
operator|*
name|datasize
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"TGA: raw packet %d/%d\n"
argument_list|,
name|count
operator|*
name|datasize
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Set the beginning of the next run and the next lookahead. */
name|begin
operator|=
name|buf
operator|+
name|j
expr_stmt|;
name|j
operator|+=
name|datasize
expr_stmt|;
block|}
comment|/* If we didn't encode all the elements, write one last packet. */
if|if
condition|(
name|begin
operator|<
name|buf
operator|+
name|buflen
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|totbytes
operator|+=
name|datasize
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"TGA: FINAL raw packet %d/%d\n"
argument_list|,
name|datasize
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|||
name|fwrite
argument_list|(
name|begin
argument_list|,
name|datasize
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: rle_fwrite %d/%d (total %d)\n"
argument_list|,
name|totbytes
operator|-
name|curbytes
argument_list|,
name|nelems
operator|*
name|datasize
argument_list|,
name|totbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|nelems
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|ReadImage (FILE * fp,struct tga_header * hdr,char * filename)
name|ReadImage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|tga_header
modifier|*
name|hdr
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|static
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|layer_ID
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|GDrawableType
name|dtype
decl_stmt|;
name|GImageType
name|itype
decl_stmt|;
name|guchar
modifier|*
name|alphas
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|,
name|bpp
decl_stmt|,
name|abpp
decl_stmt|,
name|pbpp
decl_stmt|,
name|nalphas
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|pelbytes
decl_stmt|,
name|tileheight
decl_stmt|,
name|wbytes
decl_stmt|,
name|bsize
decl_stmt|,
name|npels
decl_stmt|,
name|pels
decl_stmt|;
name|int
name|rle
decl_stmt|,
name|badread
decl_stmt|;
name|int
function_decl|(
modifier|*
name|myfread
function_decl|)
parameter_list|(
name|guchar
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* Find out whether the image is horizontally or vertically reversed.      The GIMP likes things left-to-right, top-to-bottom. */
name|gchar
name|horzrev
init|=
name|hdr
operator|->
name|descriptor
operator|&
name|TGA_DESC_HORIZONTAL
decl_stmt|;
name|gchar
name|vertrev
init|=
operator|!
operator|(
name|hdr
operator|->
name|descriptor
operator|&
name|TGA_DESC_VERTICAL
operator|)
decl_stmt|;
comment|/* Reassemble the multi-byte values correctly, regardless of      host endianness. */
name|width
operator|=
operator|(
name|hdr
operator|->
name|widthHi
operator|<<
literal|8
operator|)
operator||
name|hdr
operator|->
name|widthLo
expr_stmt|;
name|height
operator|=
operator|(
name|hdr
operator|->
name|heightHi
operator|<<
literal|8
operator|)
operator||
name|hdr
operator|->
name|heightLo
expr_stmt|;
name|bpp
operator|=
name|hdr
operator|->
name|bpp
expr_stmt|;
name|abpp
operator|=
name|hdr
operator|->
name|descriptor
operator|&
name|TGA_DESC_ABITS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|imageType
operator|==
name|TGA_TYPE_COLOR
operator|||
name|hdr
operator|->
name|imageType
operator|==
name|TGA_TYPE_COLOR_RLE
condition|)
name|pbpp
operator|=
name|MIN
argument_list|(
name|bpp
operator|/
literal|3
argument_list|,
literal|8
argument_list|)
operator|*
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|abpp
operator|<
name|bpp
condition|)
name|pbpp
operator|=
name|bpp
operator|-
name|abpp
expr_stmt|;
else|else
name|pbpp
operator|=
name|bpp
expr_stmt|;
if|if
condition|(
name|abpp
operator|+
name|pbpp
operator|>
name|bpp
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: %d bit image, %d bit alpha is greater than %d total bits per pixel\n"
argument_list|,
name|pbpp
argument_list|,
name|abpp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
comment|/* Assume that alpha bits were set incorrectly. */
name|abpp
operator|=
name|bpp
operator|-
name|pbpp
expr_stmt|;
name|printf
argument_list|(
literal|"TGA: reducing to %d bit alpha\n"
argument_list|,
name|abpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abpp
operator|+
name|pbpp
operator|<
name|bpp
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: %d bit image, %d bit alpha is less than %d total bits per pixel\n"
argument_list|,
name|pbpp
argument_list|,
name|abpp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
comment|/* Again, assume that alpha bits were set incorrectly. */
name|abpp
operator|=
name|bpp
operator|-
name|pbpp
expr_stmt|;
name|printf
argument_list|(
literal|"TGA: increasing to %d bit alpha\n"
argument_list|,
name|abpp
argument_list|)
expr_stmt|;
block|}
name|rle
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|imageType
condition|)
block|{
case|case
name|TGA_TYPE_MAPPED_RLE
case|:
name|rle
operator|=
literal|1
expr_stmt|;
case|case
name|TGA_TYPE_MAPPED
case|:
name|itype
operator|=
name|INDEXED
expr_stmt|;
comment|/* Find the size of palette elements. */
name|pbpp
operator|=
name|MIN
argument_list|(
name|hdr
operator|->
name|colorMapSize
operator|/
literal|3
argument_list|,
literal|8
argument_list|)
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|pbpp
operator|<
name|hdr
operator|->
name|colorMapSize
condition|)
name|abpp
operator|=
name|hdr
operator|->
name|colorMapSize
operator|-
name|pbpp
expr_stmt|;
else|else
name|abpp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: %d bit indexed image, %d bit alpha (%d bit indices)\n"
argument_list|,
name|pbpp
argument_list|,
name|abpp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bpp
operator|!=
literal|8
condition|)
block|{
comment|/* We can only cope with 8-bit indices. */
name|printf
argument_list|(
literal|"TGA: index sizes other than 8 bits are unimplemented\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|abpp
condition|)
name|dtype
operator|=
name|INDEXEDA_IMAGE
expr_stmt|;
else|else
name|dtype
operator|=
name|INDEXED_IMAGE
expr_stmt|;
break|break;
case|case
name|TGA_TYPE_GRAY_RLE
case|:
name|rle
operator|=
literal|1
expr_stmt|;
case|case
name|TGA_TYPE_GRAY
case|:
name|itype
operator|=
name|GRAY
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: %d bit grayscale image, %d bit alpha\n"
argument_list|,
name|pbpp
argument_list|,
name|abpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abpp
condition|)
name|dtype
operator|=
name|GRAYA_IMAGE
expr_stmt|;
else|else
name|dtype
operator|=
name|GRAY_IMAGE
expr_stmt|;
break|break;
case|case
name|TGA_TYPE_COLOR_RLE
case|:
name|rle
operator|=
literal|1
expr_stmt|;
case|case
name|TGA_TYPE_COLOR
case|:
name|itype
operator|=
name|RGB
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: %d bit color image, %d bit alpha\n"
argument_list|,
name|pbpp
argument_list|,
name|abpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abpp
condition|)
name|dtype
operator|=
name|RGBA_IMAGE
expr_stmt|;
else|else
name|dtype
operator|=
name|RGB_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"TGA: unrecognized image type %d\n"
argument_list|,
name|hdr
operator|->
name|imageType
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|abpp
operator|&&
name|abpp
operator|!=
literal|8
operator|)
operator|||
operator|(
operator|(
name|itype
operator|==
name|RGB
operator|||
name|itype
operator|==
name|INDEXED
operator|)
operator|&&
name|pbpp
operator|!=
literal|24
operator|)
operator|||
operator|(
name|itype
operator|==
name|GRAY
operator|&&
name|pbpp
operator|!=
literal|8
operator|)
condition|)
block|{
comment|/* FIXME: We haven't implemented bit-packed fields yet. */
name|printf
argument_list|(
literal|"TGA: channel sizes other than 8 bits are unimplemented\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check that we have a color map only when we need it. */
if|if
condition|(
name|itype
operator|==
name|INDEXED
condition|)
block|{
if|if
condition|(
name|hdr
operator|->
name|colorMapType
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: indexed image has invalid color map type %d\n"
argument_list|,
name|hdr
operator|->
name|colorMapType
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|hdr
operator|->
name|colorMapType
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: non-indexed image has invalid color map type %d\n"
argument_list|,
name|hdr
operator|->
name|colorMapType
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|alphas
operator|=
literal|0
expr_stmt|;
name|nalphas
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|colorMapType
operator|==
literal|1
condition|)
block|{
comment|/* We need to read in the colormap. */
name|int
name|index
decl_stmt|,
name|length
decl_stmt|,
name|colors
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|index
operator|=
operator|(
name|hdr
operator|->
name|colorMapIndexHi
operator|<<
literal|8
operator|)
operator||
name|hdr
operator|->
name|colorMapIndexLo
expr_stmt|;
name|length
operator|=
operator|(
name|hdr
operator|->
name|colorMapLengthHi
operator|<<
literal|8
operator|)
operator||
name|hdr
operator|->
name|colorMapLengthLo
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"TGA: reading color map (%d + %d) * (%d bits)\n"
argument_list|,
name|index
argument_list|,
name|length
argument_list|,
name|hdr
operator|->
name|colorMapSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: invalid color map length %d\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pelbytes
operator|=
name|ROUNDUP_DIVIDE
argument_list|(
name|hdr
operator|->
name|colorMapSize
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|colors
operator|=
name|length
operator|+
name|index
expr_stmt|;
name|cmap
operator|=
name|g_malloc
argument_list|(
name|colors
operator|*
name|pelbytes
argument_list|)
expr_stmt|;
comment|/* Zero the entries up to the beginning of the map. */
name|memset
argument_list|(
name|cmap
argument_list|,
literal|0
argument_list|,
name|index
operator|*
name|pelbytes
argument_list|)
expr_stmt|;
comment|/* Read in the rest of the colormap. */
if|if
condition|(
name|fread
argument_list|(
name|cmap
operator|+
operator|(
name|index
operator|*
name|pelbytes
operator|)
argument_list|,
name|pelbytes
argument_list|,
name|length
argument_list|,
name|fp
argument_list|)
operator|!=
name|length
condition|)
block|{
name|printf
argument_list|(
literal|"TGA: error reading colormap (ftell == %ld)\n"
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* If we have an alpha channel, then create a mapping to the alpha 	 values. */
if|if
condition|(
name|pelbytes
operator|>
literal|3
condition|)
name|alphas
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|colors
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|colors
operator|*
name|pelbytes
condition|;
name|j
operator|+=
name|pelbytes
control|)
block|{
comment|/* Swap from BGR to RGB. */
name|tmp
operator|=
name|cmap
index|[
name|j
index|]
expr_stmt|;
name|cmap
index|[
name|k
operator|++
index|]
operator|=
name|cmap
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|cmap
index|[
name|k
operator|++
index|]
operator|=
name|cmap
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|cmap
index|[
name|k
operator|++
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Take the alpha values out of the colormap. */
if|if
condition|(
name|alphas
condition|)
name|alphas
index|[
name|nalphas
operator|++
index|]
operator|=
name|cmap
index|[
name|j
operator|+
literal|3
index|]
expr_stmt|;
block|}
comment|/* If the last color was transparent, then omit it from the 	 GIMP mapping. */
if|if
condition|(
name|nalphas
operator|&&
name|alphas
index|[
name|nalphas
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|colors
operator|--
expr_stmt|;
comment|/* Set the colormap. */
name|gimp_image_set_cmap
argument_list|(
name|image_ID
argument_list|,
name|cmap
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
comment|/* Now pretend as if we only have 8 bpp. */
name|abpp
operator|=
literal|0
expr_stmt|;
name|pbpp
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Continue initializing. */
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dtype
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
comment|/* Prepare the pixel region. */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Calculate number of GIMP bytes per pixel. */
name|pelbytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
comment|/* Calculate TGA bytes per pixel. */
name|bpp
operator|=
name|ROUNDUP_DIVIDE
argument_list|(
name|pbpp
operator|+
name|abpp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Allocate the data. */
name|tileheight
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
operator|*
name|tileheight
operator|*
name|pelbytes
argument_list|)
expr_stmt|;
comment|/* Maybe we need to reverse the data. */
name|buffer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|horzrev
operator|||
name|vertrev
condition|)
name|buffer
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
operator|*
name|tileheight
operator|*
name|pelbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
condition|)
name|myfread
operator|=
name|rle_fread
expr_stmt|;
else|else
name|myfread
operator|=
name|std_fread
expr_stmt|;
name|wbytes
operator|=
name|width
operator|*
name|pelbytes
expr_stmt|;
name|badread
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|+=
name|tileheight
control|)
block|{
name|tileheight
operator|=
name|MIN
argument_list|(
name|tileheight
argument_list|,
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"TGA: reading %dx(%d+%d)x%d pixel region\n"
argument_list|,
name|width
argument_list|,
operator|(
name|vertrev
condition|?
operator|(
name|height
operator|-
operator|(
name|i
operator|+
name|tileheight
operator|)
operator|)
else|:
name|i
operator|)
argument_list|,
name|tileheight
argument_list|,
name|pelbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|npels
operator|=
name|width
operator|*
name|tileheight
expr_stmt|;
name|bsize
operator|=
name|wbytes
operator|*
name|tileheight
expr_stmt|;
comment|/* Suck in the data one tileheight at a time. */
if|if
condition|(
name|badread
condition|)
name|pels
operator|=
literal|0
expr_stmt|;
else|else
name|pels
operator|=
call|(
modifier|*
name|myfread
call|)
argument_list|(
name|data
argument_list|,
name|bpp
argument_list|,
name|npels
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pels
operator|!=
name|npels
condition|)
block|{
if|if
condition|(
operator|!
name|badread
condition|)
block|{
comment|/* Probably premature end of file. */
name|printf
argument_list|(
literal|"TGA: error reading (ftell == %ld)\n"
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|badread
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|verbose = 2;   printf ("TGA: debug %d\n", getpid ());   kill (getpid (), 19);
endif|#
directive|endif
comment|/* Fill the rest of this tile with zeros. */
name|memset
argument_list|(
name|data
operator|+
operator|(
name|pels
operator|*
name|bpp
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|npels
operator|-
name|pels
operator|)
operator|*
name|bpp
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have indexed alphas, then set them. */
if|if
condition|(
name|nalphas
condition|)
block|{
comment|/* Start at the end of the buffer, and work backwards. */
name|k
operator|=
operator|(
name|npels
operator|-
literal|1
operator|)
operator|*
name|bpp
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bsize
operator|-
name|pelbytes
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
name|pelbytes
control|)
block|{
comment|/* Find the alpha for this index. */
name|data
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|alphas
index|[
name|data
index|[
name|k
index|]
index|]
expr_stmt|;
name|data
index|[
name|j
index|]
operator|=
name|data
index|[
name|k
operator|--
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pelbytes
operator|>=
literal|3
condition|)
block|{
comment|/* Rearrange the colors from BGR to RGB. */
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bsize
condition|;
name|j
operator|+=
name|pelbytes
control|)
block|{
name|tmp
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
name|data
index|[
name|j
index|]
operator|=
name|data
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|data
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|horzrev
operator|||
name|vertrev
condition|)
block|{
name|guchar
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|vertrev
condition|)
block|{
comment|/* We need to mirror only vertically. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bsize
condition|;
name|j
operator|+=
name|wbytes
control|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|data
operator|+
name|bsize
operator|-
operator|(
name|j
operator|+
name|wbytes
operator|)
argument_list|,
name|wbytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|horzrev
condition|)
block|{
comment|/* We need to mirror only horizontally. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bsize
condition|;
name|j
operator|+=
name|wbytes
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|wbytes
condition|;
name|k
operator|+=
name|pelbytes
control|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|k
operator|+
name|j
argument_list|,
name|data
operator|+
operator|(
name|j
operator|+
name|wbytes
operator|)
operator|-
operator|(
name|k
operator|+
name|pelbytes
operator|)
argument_list|,
name|pelbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Completely reverse the pixels in the buffer. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bsize
condition|;
name|j
operator|+=
name|pelbytes
control|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|data
operator|+
name|bsize
operator|-
operator|(
name|j
operator|+
name|pelbytes
operator|)
argument_list|,
name|pelbytes
argument_list|)
expr_stmt|;
block|}
comment|/* Swap the buffers because we modified them. */
name|tmp
operator|=
name|buffer
expr_stmt|;
name|buffer
operator|=
name|data
expr_stmt|;
name|data
operator|=
name|tmp
expr_stmt|;
block|}
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|i
operator|+
name|tileheight
argument_list|)
operator|/
operator|(
name|double
operator|)
name|height
argument_list|)
expr_stmt|;
comment|/* If vertically reversed, put the data at the end. */
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
operator|(
name|vertrev
condition|?
operator|(
name|height
operator|-
operator|(
name|i
operator|+
name|tileheight
operator|)
operator|)
else|:
name|i
operator|)
argument_list|,
name|width
argument_list|,
name|tileheight
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
name|printf
argument_list|(
literal|"TGA: too much input data, ignoring extra...\n"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|alphas
condition|)
name|g_free
argument_list|(
name|alphas
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_comment
comment|/*read_image*/
end_comment

begin_function
specifier|static
name|gint
DECL|function|save_image (gchar * filename,gint32 image_ID,gint32 drawable_ID)
name|save_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
block|{
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|GDrawableType
name|dtype
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|guchar
modifier|*
name|name_buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|npels
decl_stmt|,
name|tileheight
decl_stmt|,
name|pelbytes
decl_stmt|,
name|bsize
decl_stmt|;
name|int
name|transparent
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|tga_header
name|hdr
decl_stmt|;
name|int
function_decl|(
modifier|*
name|myfwrite
function_decl|)
parameter_list|(
name|guchar
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|width
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|name_buf
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Saving %s:"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We like our images top-to-bottom, thank you! */
name|hdr
operator|.
name|descriptor
operator||=
name|TGA_DESC_VERTICAL
expr_stmt|;
comment|/* Choose the imageType based on our drawable and compression option. */
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|INDEXEDA_IMAGE
case|:
case|case
name|INDEXED_IMAGE
case|:
name|hdr
operator|.
name|bpp
operator|=
literal|8
expr_stmt|;
name|hdr
operator|.
name|imageType
operator|=
name|TGA_TYPE_MAPPED
expr_stmt|;
break|break;
case|case
name|GRAYA_IMAGE
case|:
name|hdr
operator|.
name|bpp
operator|=
literal|8
expr_stmt|;
name|hdr
operator|.
name|descriptor
operator||=
literal|8
expr_stmt|;
case|case
name|GRAY_IMAGE
case|:
name|hdr
operator|.
name|bpp
operator|+=
literal|8
expr_stmt|;
name|hdr
operator|.
name|imageType
operator|=
name|TGA_TYPE_GRAY
expr_stmt|;
break|break;
case|case
name|RGBA_IMAGE
case|:
name|hdr
operator|.
name|bpp
operator|=
literal|8
expr_stmt|;
name|hdr
operator|.
name|descriptor
operator||=
literal|8
expr_stmt|;
case|case
name|RGB_IMAGE
case|:
name|hdr
operator|.
name|bpp
operator|+=
literal|24
expr_stmt|;
name|hdr
operator|.
name|imageType
operator|=
name|TGA_TYPE_COLOR
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|tsvals
operator|.
name|rle
condition|)
block|{
comment|/* Here we take advantage of the fact that the RLE image type codes 	 are exactly 8 greater than the non-RLE. */
name|hdr
operator|.
name|imageType
operator|+=
literal|8
expr_stmt|;
name|myfwrite
operator|=
name|rle_fwrite
expr_stmt|;
block|}
else|else
name|myfwrite
operator|=
name|std_fwrite
expr_stmt|;
name|hdr
operator|.
name|widthLo
operator|=
operator|(
name|width
operator|&
literal|0xff
operator|)
expr_stmt|;
name|hdr
operator|.
name|widthHi
operator|=
operator|(
name|width
operator|>>
literal|8
operator|)
expr_stmt|;
name|hdr
operator|.
name|heightLo
operator|=
operator|(
name|height
operator|&
literal|0xff
operator|)
expr_stmt|;
name|hdr
operator|.
name|heightHi
operator|=
operator|(
name|height
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
literal|"TGA: can't create \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Mark our save ID. */
name|hdr
operator|.
name|idLength
operator|=
name|strlen
argument_list|(
name|SAVE_ID_STRING
argument_list|)
expr_stmt|;
comment|/* See if we have to write out the colour map. */
name|transparent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|imageType
operator|==
name|TGA_TYPE_MAPPED_RLE
operator|||
name|hdr
operator|.
name|imageType
operator|==
name|TGA_TYPE_MAPPED
condition|)
block|{
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|int
name|colors
decl_stmt|;
name|hdr
operator|.
name|colorMapType
operator|=
literal|1
expr_stmt|;
name|cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
if|if
condition|(
name|colors
operator|>
literal|256
condition|)
block|{
name|g_message
argument_list|(
literal|"TGA: cannot handle colormap with more than 256 colors (got %d)\n"
argument_list|,
name|colors
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we already have more than 256 colors, then ignore the 	 alpha channel.  Otherwise, create an entry for any completely 	 transparent pixels. */
if|if
condition|(
name|dtype
operator|==
name|INDEXEDA_IMAGE
operator|&&
name|colors
operator|<
literal|256
condition|)
block|{
name|transparent
operator|=
name|colors
expr_stmt|;
name|hdr
operator|.
name|colorMapSize
operator|=
literal|32
expr_stmt|;
name|hdr
operator|.
name|colorMapLengthLo
operator|=
operator|(
operator|(
name|colors
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|hdr
operator|.
name|colorMapLengthHi
operator|=
operator|(
operator|(
name|colors
operator|+
literal|1
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|.
name|colorMapSize
operator|=
literal|24
expr_stmt|;
name|hdr
operator|.
name|colorMapLengthLo
operator|=
operator|(
name|colors
operator|&
literal|0xff
operator|)
expr_stmt|;
name|hdr
operator|.
name|colorMapLengthHi
operator|=
operator|(
name|colors
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
comment|/* Write the header. */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fwrite
argument_list|(
name|SAVE_ID_STRING
argument_list|,
name|hdr
operator|.
name|idLength
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|pelbytes
operator|=
name|ROUNDUP_DIVIDE
argument_list|(
name|hdr
operator|.
name|colorMapSize
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|transparent
condition|)
block|{
name|guchar
modifier|*
name|newcmap
decl_stmt|;
comment|/* Reallocate our colormap to have an alpha channel and 	     a fully transparent color. */
name|newcmap
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
operator|(
name|colors
operator|+
literal|1
operator|)
operator|*
name|pelbytes
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|colors
operator|*
literal|3
condition|;
name|j
operator|+=
literal|3
control|)
block|{
comment|/* Rearrange from RGB to BGR. */
name|newcmap
index|[
name|k
operator|++
index|]
operator|=
name|cmap
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|newcmap
index|[
name|k
operator|++
index|]
operator|=
name|cmap
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|newcmap
index|[
name|k
operator|++
index|]
operator|=
name|cmap
index|[
name|j
index|]
expr_stmt|;
comment|/* Set to maximum opacity. */
name|newcmap
index|[
name|k
operator|++
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Add the transparent color. */
name|memset
argument_list|(
name|newcmap
operator|+
name|k
argument_list|,
literal|0
argument_list|,
name|pelbytes
argument_list|)
expr_stmt|;
comment|/* Write out the colormap. */
if|if
condition|(
name|fwrite
argument_list|(
name|newcmap
argument_list|,
name|pelbytes
argument_list|,
name|colors
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
name|colors
operator|+
literal|1
condition|)
return|return
name|FALSE
return|;
name|g_free
argument_list|(
name|newcmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Rearrange the colors from RGB to BGR. */
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|colors
operator|*
name|pelbytes
condition|;
name|j
operator|+=
name|pelbytes
control|)
block|{
name|tmp
operator|=
name|cmap
index|[
name|j
index|]
expr_stmt|;
name|cmap
index|[
name|j
index|]
operator|=
name|cmap
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|cmap
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Write out the colormap. */
if|if
condition|(
name|fwrite
argument_list|(
name|cmap
argument_list|,
name|pelbytes
argument_list|,
name|colors
argument_list|,
name|fp
argument_list|)
operator|!=
name|colors
condition|)
return|return
name|FALSE
return|;
block|}
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
block|}
comment|/* Just write the header. */
else|else
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fwrite
argument_list|(
name|SAVE_ID_STRING
argument_list|,
name|hdr
operator|.
name|idLength
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Allocate a new set of pixels. */
name|tileheight
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|data
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|width
operator|*
name|tileheight
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Write out the pixel data. */
name|pelbytes
operator|=
name|ROUNDUP_DIVIDE
argument_list|(
name|hdr
operator|.
name|bpp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|status
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|+=
name|tileheight
control|)
block|{
comment|/* Get a horizontal slice of the image. */
name|tileheight
operator|=
name|MIN
argument_list|(
name|tileheight
argument_list|,
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|tileheight
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"TGA: writing %dx(%d+%d)x%d pixel region\n"
argument_list|,
name|width
argument_list|,
name|i
argument_list|,
name|tileheight
argument_list|,
name|pelbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|npels
operator|=
name|width
operator|*
name|tileheight
expr_stmt|;
name|bsize
operator|=
name|npels
operator|*
name|pelbytes
expr_stmt|;
comment|/* If the GIMP's bpp does not match the TGA format, strip 	 the excess bytes. */
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>
name|pelbytes
condition|)
block|{
name|int
name|nbytes
decl_stmt|,
name|difference
decl_stmt|,
name|fullbsize
decl_stmt|;
name|j
operator|=
name|k
operator|=
literal|0
expr_stmt|;
name|fullbsize
operator|=
name|npels
operator|*
name|drawable
operator|->
name|bpp
expr_stmt|;
name|difference
operator|=
name|drawable
operator|->
name|bpp
operator|-
name|pelbytes
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|fullbsize
condition|)
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nbytes
operator|=
literal|0
init|;
name|nbytes
operator|<
name|pelbytes
condition|;
name|nbytes
operator|++
control|)
comment|/* Be careful to handle overlapping pixels. */
name|data
index|[
name|k
operator|++
index|]
operator|=
name|data
index|[
name|j
operator|++
index|]
expr_stmt|;
comment|/* If this is an indexed image, and data[j] (alpha 		 channel) is zero, then we should write our transparent 		 pixel's index. */
if|if
condition|(
name|dtype
operator|==
name|INDEXEDA_IMAGE
operator|&&
name|transparent
operator|&&
name|data
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|data
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|transparent
expr_stmt|;
comment|/* Increment J to the next pixel. */
name|j
operator|+=
name|difference
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pelbytes
operator|>=
literal|3
condition|)
block|{
comment|/* Rearrange the colors from RGB to BGR. */
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bsize
condition|;
name|j
operator|+=
name|pelbytes
control|)
block|{
name|tmp
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
name|data
index|[
name|j
index|]
operator|=
name|data
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|data
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
call|(
modifier|*
name|myfwrite
call|)
argument_list|(
name|data
argument_list|,
name|pelbytes
argument_list|,
name|npels
argument_list|,
name|fp
argument_list|)
operator|!=
name|npels
condition|)
block|{
comment|/* We have no choice but to break and truncate the file 	     if we are writing with RLE. */
name|status
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|i
operator|+
name|tileheight
argument_list|)
operator|/
operator|(
name|double
operator|)
name|height
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|init_gtk (void)
name|init_gtk
parameter_list|(
name|void
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|gint
name|argc
decl_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"tga"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gtk_rc_parse
argument_list|(
name|gimp_gtkrc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_dialog (void)
name|save_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Save as TGA"
argument_list|)
argument_list|,
literal|"tga"
argument_list|,
name|gimp_plugin_help_func
argument_list|,
literal|"filters/tga.html"
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|_
argument_list|(
literal|"OK"
argument_list|)
argument_list|,
name|save_ok_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|_
argument_list|(
literal|"Cancel"
argument_list|)
argument_list|,
name|gtk_widget_destroy
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gtk_main_quit
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* regular tga parameter settings */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|_
argument_list|(
literal|"Targa Options"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
comment|/*  rle  */
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"RLE compression"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|tsvals
operator|.
name|rle
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|tsvals
operator|.
name|rle
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|tsint
operator|.
name|run
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_ok_callback (GtkWidget * widget,gpointer data)
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|tsint
operator|.
name|run
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

