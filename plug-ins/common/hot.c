begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/*  * hot.c - Scan an image for pixels with RGB values that will give  *      "unsafe" values of chrominance signal or composite signal  *      amplitude when encoded into an NTSC or PAL colour signal.  *      (This happens for certain high-intensity high-saturation colours  *      that are rare in real scenes, but can easily be present  *      in synthetic images.)  *  *      Such pixels can be flagged so the user may then choose other  *      colours.  Or, the offending pixels can be made "safe"  *      in a manner that preserves hue.  *  *      There are two reasonable ways to make a pixel "safe":  *      We can reduce its intensity (luminance) while leaving  *      hue and saturation the same.  Or, we can reduce saturation  *      while leaving hue and luminance the same.  A #define selects  *      which strategy to use.  *  * Note to the user: You must add your own read_pixel() and write_pixel()  *      routines.  You may have to modify pix_decode() and pix_encode().  *      MAXPIX, WID, and HGT are likely to need modification.  */
end_comment

begin_comment
comment|/*  * Originally written as "ikNTSC.c" by Alan Wm Paeth,  *      University of Waterloo, August, 1985  * Updated by Dave Martindale, Imax Systems Corp., December 1990  */
end_comment

begin_comment
comment|/*  * Compile time options:  *  *  * CHROMA_LIM is the limit (in IRE units) of the overall  *      chrominance amplitude; it should be 50 or perhaps  *      very slightly higher.  *  * COMPOS_LIM is the maximum amplitude (in IRE units) allowed for  *      the composite signal.  A value of 100 is the maximum  *      monochrome white, and is always safe.  120 is the absolute  *      limit for NTSC broadcasting, since the transmitter's carrier  *      goes to zero with 120 IRE input signal.  Generally, 110  *      is a good compromise - it allows somewhat brighter colours  *      than 100, while staying safely away from the hard limit.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|PLUG_IN_PROC
define|#
directive|define
name|PLUG_IN_PROC
value|"plug-in-hot"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"hot"
end_define

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28d9c3440108
block|{
DECL|member|image
name|gint32
name|image
decl_stmt|;
DECL|member|drawable
name|gint32
name|drawable
decl_stmt|;
DECL|member|mode
name|gint32
name|mode
decl_stmt|;
DECL|member|action
name|gint32
name|action
decl_stmt|;
DECL|member|new_layerp
name|gint32
name|new_layerp
decl_stmt|;
DECL|typedef|piArgs
block|}
name|piArgs
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon28d9c3440203
block|{
DECL|enumerator|ACT_LREDUX
name|ACT_LREDUX
block|,
DECL|enumerator|ACT_SREDUX
name|ACT_SREDUX
block|,
DECL|enumerator|ACT_FLAG
name|ACT_FLAG
DECL|typedef|hotAction
block|}
name|hotAction
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon28d9c3440303
block|{
DECL|enumerator|MODE_NTSC
name|MODE_NTSC
block|,
DECL|enumerator|MODE_PAL
name|MODE_PAL
DECL|typedef|hotModes
block|}
name|hotModes
typedef|;
end_typedef

begin_define
DECL|macro|CHROMA_LIM
define|#
directive|define
name|CHROMA_LIM
value|50.0
end_define

begin_comment
DECL|macro|CHROMA_LIM
comment|/* chroma amplitude limit */
end_comment

begin_define
DECL|macro|COMPOS_LIM
define|#
directive|define
name|COMPOS_LIM
value|110.0
end_define

begin_comment
DECL|macro|COMPOS_LIM
comment|/* max IRE amplitude */
end_comment

begin_comment
comment|/*  * RGB to YIQ encoding matrix.  */
end_comment

begin_struct
struct|struct
DECL|struct|__anon28d9c3440408
block|{
DECL|member|pedestal
name|gdouble
name|pedestal
decl_stmt|;
DECL|member|gamma
name|gdouble
name|gamma
decl_stmt|;
DECL|member|code
name|gdouble
name|code
index|[
literal|3
index|]
index|[
literal|3
index|]
decl_stmt|;
DECL|variable|mode
block|}
decl|static
name|mode
index|[
literal|2
index|]
init|=
block|{
block|{
literal|7.5
block|,
literal|2.2
block|,
block|{
block|{
literal|0.2989
block|,
literal|0.5866
block|,
literal|0.1144
block|}
block|,
block|{
literal|0.5959
block|,
operator|-
literal|0.2741
block|,
operator|-
literal|0.3218
block|}
block|,
block|{
literal|0.2113
block|,
operator|-
literal|0.5227
block|,
literal|0.3113
block|}
block|}
block|}
block|,
block|{
literal|0.0
block|,
literal|2.8
block|,
block|{
block|{
literal|0.2989
block|,
literal|0.5866
block|,
literal|0.1144
block|}
block|,
block|{
operator|-
literal|0.1473
block|,
operator|-
literal|0.2891
block|,
literal|0.4364
block|}
block|,
block|{
literal|0.6149
block|,
operator|-
literal|0.5145
block|,
operator|-
literal|0.1004
block|}
block|}
block|}
block|}
struct|;
end_struct

begin_define
DECL|macro|SCALE
define|#
directive|define
name|SCALE
value|8192
end_define

begin_comment
DECL|macro|SCALE
comment|/* scale factor: do floats with int math */
end_comment

begin_define
DECL|macro|MAXPIX
define|#
directive|define
name|MAXPIX
value|255
end_define

begin_comment
DECL|macro|MAXPIX
comment|/* white value */
end_comment

begin_decl_stmt
DECL|variable|tab
specifier|static
name|gint
name|tab
index|[
literal|3
index|]
index|[
literal|3
index|]
index|[
name|MAXPIX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|tab
comment|/* multiply lookup table */
end_comment

begin_decl_stmt
DECL|variable|chroma_lim
specifier|static
name|gdouble
name|chroma_lim
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|chroma_lim
comment|/* chroma limit */
end_comment

begin_decl_stmt
DECL|variable|compos_lim
specifier|static
name|gdouble
name|compos_lim
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|compos_lim
comment|/* composite amplitude limit */
end_comment

begin_decl_stmt
DECL|variable|ichroma_lim2
specifier|static
name|glong
name|ichroma_lim2
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|ichroma_lim2
comment|/* chroma limit squared (scaled integer) */
end_comment

begin_decl_stmt
DECL|variable|icompos_lim
specifier|static
name|gint
name|icompos_lim
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|icompos_lim
comment|/* composite amplitude limit (scaled integer) */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|retvals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|pluginCore
parameter_list|(
name|piArgs
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|plugin_dialog
parameter_list|(
name|piArgs
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|hotp
parameter_list|(
name|guint8
name|r
parameter_list|,
name|guint8
name|g
parameter_list|,
name|guint8
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_tab
parameter_list|(
name|gint
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * gc: apply the gamma correction specified for this video standard.  * inv_gc: inverse function of gc.  *  * These are generally just a call to pow(), but be careful!  * Future standards may use more complex functions.  * (e.g. SMPTE 240M's "electro-optic transfer characteristic").  */
end_comment

begin_define
DECL|macro|gc (x,m)
define|#
directive|define
name|gc
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
value|pow(x, 1.0 / mode[m].gamma)
end_define

begin_define
DECL|macro|inv_gc (x,m)
define|#
directive|define
name|inv_gc
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
value|pow(x,       mode[m].gamma)
end_define

begin_comment
comment|/*  * pix_decode: decode an integer pixel value into a floating-point  *      intensity in the range [0, 1].  *  * pix_encode: encode a floating-point intensity into an integer  *      pixel value.  *  * The code given here assumes simple linear encoding; you must change  * these routines if you use a different pixel encoding technique.  */
end_comment

begin_define
DECL|macro|pix_decode (v)
define|#
directive|define
name|pix_decode
parameter_list|(
name|v
parameter_list|)
value|((double)v / (double)MAXPIX)
end_define

begin_define
DECL|macro|pix_encode (v)
define|#
directive|define
name|pix_encode
parameter_list|(
name|v
parameter_list|)
value|((int)(v * (double)MAXPIX + 0.5))
end_define

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"The Image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The Drawable"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"mode"
block|,
literal|"Mode { NTSC (0), PAL (1) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"action"
block|,
literal|"The action to perform"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"new-layer"
block|,
literal|"Create a new layer { TRUE, FALSE }"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|PLUG_IN_PROC
argument_list|,
name|N_
argument_list|(
literal|"Find and fix pixels that may be unsafely bright"
argument_list|)
argument_list|,
literal|"hot scans an image for pixels that will give unsave "
literal|"values of chrominance or composite signale "
literal|"amplitude when encoded into an NTSC or PAL signal.  "
literal|"Three actions can be performed on these ``hot'' "
literal|"pixels. (0) reduce luminance, (1) reduce "
literal|"saturation, or (2) Blacken."
argument_list|,
literal|"Eric L. Hernes, Alan Wm Paeth"
argument_list|,
literal|"Eric L. Hernes"
argument_list|,
literal|"1997"
argument_list|,
name|N_
argument_list|(
literal|"_Hot..."
argument_list|)
argument_list|,
literal|"RGB"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_plugin_menu_register
argument_list|(
name|PLUG_IN_PROC
argument_list|,
literal|"<Image>/Colors/Modify"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparam,const GimpParam * param,gint * nretvals,GimpParam ** retvals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|retvals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|rvals
index|[
literal|1
index|]
decl_stmt|;
name|piArgs
name|args
decl_stmt|;
operator|*
name|nretvals
operator|=
literal|1
expr_stmt|;
operator|*
name|retvals
operator|=
name|rvals
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|mode
operator|=
operator|-
literal|1
expr_stmt|;
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|image
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
expr_stmt|;
name|args
operator|.
name|drawable
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
expr_stmt|;
name|rvals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/* XXX: add code here for interactive running */
if|if
condition|(
name|args
operator|.
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
name|args
operator|.
name|mode
operator|=
name|MODE_NTSC
expr_stmt|;
name|args
operator|.
name|action
operator|=
name|ACT_LREDUX
expr_stmt|;
name|args
operator|.
name|new_layerp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|plugin_dialog
argument_list|(
operator|&
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
block|}
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/* XXX: add code here for non-interactive running */
if|if
condition|(
name|nparam
operator|!=
literal|6
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|mode
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|args
operator|.
name|action
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|args
operator|.
name|new_layerp
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
operator|!
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/* XXX: add code here for last-values running */
if|if
condition|(
operator|!
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|pluginCore (piArgs * argp)
name|pluginCore
parameter_list|(
name|piArgs
modifier|*
name|argp
parameter_list|)
block|{
name|GimpDrawable
modifier|*
name|drw
decl_stmt|,
modifier|*
name|ndrw
init|=
name|NULL
decl_stmt|;
name|GimpPixelRgn
name|srcPr
decl_stmt|,
name|dstPr
decl_stmt|;
name|gboolean
name|success
init|=
name|TRUE
decl_stmt|;
name|gint
name|nl
init|=
literal|0
decl_stmt|;
name|gint
name|y
decl_stmt|,
name|i
decl_stmt|;
name|gint
name|Y
decl_stmt|,
name|I
decl_stmt|,
name|Q
decl_stmt|;
name|guint
name|width
decl_stmt|,
name|height
decl_stmt|,
name|bpp
decl_stmt|;
name|gint
name|sel_x1
decl_stmt|,
name|sel_x2
decl_stmt|,
name|sel_y1
decl_stmt|,
name|sel_y2
decl_stmt|;
name|gint
name|prog_interval
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
name|r
decl_stmt|,
name|prev_r
init|=
literal|0
decl_stmt|,
name|new_r
init|=
literal|0
decl_stmt|;
name|guchar
name|g
decl_stmt|,
name|prev_g
init|=
literal|0
decl_stmt|,
name|new_g
init|=
literal|0
decl_stmt|;
name|guchar
name|b
decl_stmt|,
name|prev_b
init|=
literal|0
decl_stmt|,
name|new_b
init|=
literal|0
decl_stmt|;
name|gdouble
name|fy
decl_stmt|,
name|fc
decl_stmt|,
name|t
decl_stmt|,
name|scale
decl_stmt|;
name|gdouble
name|pr
decl_stmt|,
name|pg
decl_stmt|,
name|pb
decl_stmt|;
name|gdouble
name|py
decl_stmt|;
name|drw
operator|=
name|gimp_drawable_get
argument_list|(
name|argp
operator|->
name|drawable
argument_list|)
expr_stmt|;
name|width
operator|=
name|drw
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|drw
operator|->
name|height
expr_stmt|;
name|bpp
operator|=
name|drw
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
block|{
name|gchar
name|name
index|[
literal|40
index|]
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|mode_names
index|[]
init|=
block|{
literal|"ntsc"
block|,
literal|"pal"
block|,       }
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|action_names
index|[]
init|=
block|{
literal|"lum redux"
block|,
literal|"sat redux"
block|,
literal|"flag"
block|,       }
decl_stmt|;
name|g_snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"hot mask (%s, %s)"
argument_list|,
name|mode_names
index|[
name|argp
operator|->
name|mode
index|]
argument_list|,
name|action_names
index|[
name|argp
operator|->
name|action
index|]
argument_list|)
expr_stmt|;
name|nl
operator|=
name|gimp_layer_new
argument_list|(
name|argp
operator|->
name|image
argument_list|,
name|name
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
operator|(
name|gdouble
operator|)
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|ndrw
operator|=
name|gimp_drawable_get
argument_list|(
name|nl
argument_list|)
expr_stmt|;
name|gimp_drawable_fill
argument_list|(
name|nl
argument_list|,
name|GIMP_TRANSPARENT_FILL
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|argp
operator|->
name|image
argument_list|,
name|nl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_mask_bounds
argument_list|(
name|drw
operator|->
name|drawable_id
argument_list|,
operator|&
name|sel_x1
argument_list|,
operator|&
name|sel_y1
argument_list|,
operator|&
name|sel_x2
argument_list|,
operator|&
name|sel_y2
argument_list|)
expr_stmt|;
name|width
operator|=
name|sel_x2
operator|-
name|sel_x1
expr_stmt|;
name|height
operator|=
name|sel_y2
operator|-
name|sel_y1
expr_stmt|;
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|dst
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
operator|*
literal|4
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|srcPr
argument_list|,
name|drw
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
block|{
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dstPr
argument_list|,
name|ndrw
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dstPr
argument_list|,
name|drw
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|srcPr
argument_list|,
name|src
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
name|build_tab
argument_list|(
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Hot"
argument_list|)
argument_list|)
expr_stmt|;
name|prog_interval
operator|=
name|height
operator|/
literal|10
expr_stmt|;
for|for
control|(
name|y
operator|=
name|sel_y1
init|;
name|y
operator|<
name|sel_y2
condition|;
name|y
operator|++
control|)
block|{
name|gint
name|x
decl_stmt|;
if|if
condition|(
name|y
operator|%
name|prog_interval
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|y
operator|/
call|(
name|double
call|)
argument_list|(
name|sel_y2
operator|-
name|sel_y1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|sel_x1
init|;
name|x
operator|<
name|sel_x2
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|hotp
argument_list|(
name|r
operator|=
operator|*
operator|(
name|s
operator|+
literal|0
operator|)
argument_list|,
name|g
operator|=
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|,
name|b
operator|=
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|argp
operator|->
name|action
operator|==
name|ACT_FLAG
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
comment|/*                    * Optimization: cache the last-computed hot pixel.                    */
if|if
condition|(
name|r
operator|==
name|prev_r
operator|&&
name|g
operator|==
name|prev_g
operator|&&
name|b
operator|==
name|prev_b
condition|)
block|{
operator|*
name|d
operator|++
operator|=
name|new_r
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_g
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_b
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|Y
operator|=
name|tab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|I
operator|=
name|tab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|Q
operator|=
name|tab
index|[
literal|2
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|prev_r
operator|=
name|r
expr_stmt|;
name|prev_g
operator|=
name|g
expr_stmt|;
name|prev_b
operator|=
name|b
expr_stmt|;
comment|/*                        * Get Y and chroma amplitudes in floating point.                        *                        * If your C library doesn't have hypot(), just use                        * hypot(a,b) = sqrt(a*a, b*b);                        *                        * Then extract linear (un-gamma-corrected)                        * floating-point pixel RGB values.                        */
name|fy
operator|=
operator|(
name|double
operator|)
name|Y
operator|/
operator|(
name|double
operator|)
name|SCALE
expr_stmt|;
name|fc
operator|=
name|hypot
argument_list|(
operator|(
name|double
operator|)
name|I
operator|/
operator|(
name|double
operator|)
name|SCALE
argument_list|,
operator|(
name|double
operator|)
name|Q
operator|/
operator|(
name|double
operator|)
name|SCALE
argument_list|)
expr_stmt|;
name|pr
operator|=
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|pg
operator|=
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|pb
operator|=
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/*                        * Reducing overall pixel intensity by scaling R,                        * G, and B reduces Y, I, and Q by the same factor.                        * This changes luminance but not saturation, since                        * saturation is determined by the chroma/luminance                        * ratio.                        *                        * On the other hand, by linearly interpolating                        * between the original pixel value and a grey                        * pixel with the same luminance (R=G=B=Y), we                        * change saturation without affecting luminance.                        */
if|if
condition|(
name|argp
operator|->
name|action
operator|==
name|ACT_LREDUX
condition|)
block|{
comment|/*                            * Calculate a scale factor that will bring the pixel                            * within both chroma and composite limits, if we scale                            * luminance and chroma simultaneously.                            *                            * The calculated chrominance reduction applies                            * to the gamma-corrected RGB values that are                            * the input to the RGB-to-YIQ operation.                            * Multiplying the original un-gamma-corrected                            * pixel values by the scaling factor raised to                            * the "gamma" power is equivalent, and avoids                            * calling gc() and inv_gc() three times each.  */
name|scale
operator|=
name|chroma_lim
operator|/
name|fc
expr_stmt|;
name|t
operator|=
name|compos_lim
operator|/
operator|(
name|fy
operator|+
name|fc
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|scale
condition|)
name|scale
operator|=
name|t
expr_stmt|;
name|scale
operator|=
name|pow
argument_list|(
name|scale
argument_list|,
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|guint8
operator|)
name|pix_encode
argument_list|(
name|scale
operator|*
name|pr
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
name|guint8
operator|)
name|pix_encode
argument_list|(
name|scale
operator|*
name|pg
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|guint8
operator|)
name|pix_encode
argument_list|(
name|scale
operator|*
name|pb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ACT_SREDUX hopefully */
comment|/*                            * Calculate a scale factor that will bring the                            * pixel within both chroma and composite                            * limits, if we scale chroma while leaving                            * luminance unchanged.                            *                            * We have to interpolate gamma-corrected RGB                            * values, so we must convert from linear to                            * gamma-corrected before interpolation and then                            * back to linear afterwards.                            */
name|scale
operator|=
name|chroma_lim
operator|/
name|fc
expr_stmt|;
name|t
operator|=
operator|(
name|compos_lim
operator|-
name|fy
operator|)
operator|/
name|fc
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|scale
condition|)
name|scale
operator|=
name|t
expr_stmt|;
name|pr
operator|=
name|gc
argument_list|(
name|pr
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|pg
operator|=
name|gc
argument_list|(
name|pg
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|pb
operator|=
name|gc
argument_list|(
name|pb
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|py
operator|=
name|pr
operator|*
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|pg
operator|*
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|pb
operator|*
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|r
operator|=
name|pix_encode
argument_list|(
name|inv_gc
argument_list|(
name|py
operator|+
name|scale
operator|*
operator|(
name|pr
operator|-
name|py
operator|)
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|=
name|pix_encode
argument_list|(
name|inv_gc
argument_list|(
name|py
operator|+
name|scale
operator|*
operator|(
name|pg
operator|-
name|py
operator|)
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|pix_encode
argument_list|(
name|inv_gc
argument_list|(
name|py
operator|+
name|scale
operator|*
operator|(
name|pb
operator|-
name|py
operator|)
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
name|new_r
operator|=
name|r
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_g
operator|=
name|g
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_b
operator|=
name|b
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|argp
operator|->
name|new_layerp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|+=
name|bpp
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|dstPr
argument_list|,
name|dst
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
block|{
name|gimp_drawable_flush
argument_list|(
name|ndrw
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|nl
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_drawable_flush
argument_list|(
name|drw
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drw
operator|->
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drw
operator|->
name|drawable_id
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
name|gimp_displays_flush
argument_list|()
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|plugin_dialog (piArgs * argp)
name|plugin_dialog
parameter_list|(
name|piArgs
modifier|*
name|argp
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Hot"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|PLUG_IN_PROC
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Mode"
argument_list|)
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|mode
argument_list|,
name|argp
operator|->
name|mode
argument_list|,
literal|"N_TSC"
argument_list|,
name|MODE_NTSC
argument_list|,
name|NULL
argument_list|,
literal|"_PAL"
argument_list|,
name|MODE_PAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Create _new layer"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|argp
operator|->
name|new_layerp
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|new_layerp
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Action"
argument_list|)
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|action
argument_list|,
name|argp
operator|->
name|action
argument_list|,
name|_
argument_list|(
literal|"Reduce _Luminance"
argument_list|)
argument_list|,
name|ACT_LREDUX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reduce _Saturation"
argument_list|)
argument_list|,
name|ACT_SREDUX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"_Blacken"
argument_list|)
argument_list|,
name|ACT_FLAG
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dlg
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  * build_tab: Build multiply lookup table.  *  * For each possible pixel value, decode value into floating-point  * intensity.  Then do gamma correction required by the video  * standard.  Scale the result by our fixed-point scale factor.  * Then calculate 9 lookup table entries for this pixel value.  *  * We also calculate floating-point and scaled integer versions  * of our limits here.  This prevents evaluating expressions every pixel  * when the compiler is too stupid to evaluate constant-valued  * floating-point expressions at compile time.  *  * For convenience, the limits are #defined using IRE units.  * We must convert them here into the units in which YIQ  * are measured.  The conversion from IRE to internal units  * depends on the pedestal level in use, since as Y goes from  * 0 to 1, the signal goes from the pedestal level to 100 IRE.  * Chroma is always scaled to remain consistent with Y.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|build_tab (int m)
name|build_tab
parameter_list|(
name|int
name|m
parameter_list|)
block|{
name|double
name|f
decl_stmt|;
name|int
name|pv
decl_stmt|;
for|for
control|(
name|pv
operator|=
literal|0
init|;
name|pv
operator|<=
name|MAXPIX
condition|;
name|pv
operator|++
control|)
block|{
name|f
operator|=
operator|(
name|double
operator|)
name|SCALE
operator|*
operator|(
name|double
operator|)
name|gc
argument_list|(
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|pv
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
index|[
literal|2
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|1
index|]
index|[
literal|2
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|2
index|]
index|[
literal|0
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|2
index|]
index|[
literal|1
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
name|chroma_lim
operator|=
operator|(
name|double
operator|)
name|CHROMA_LIM
operator|/
operator|(
literal|100.0
operator|-
name|mode
index|[
name|m
index|]
operator|.
name|pedestal
operator|)
expr_stmt|;
name|compos_lim
operator|=
operator|(
operator|(
name|double
operator|)
name|COMPOS_LIM
operator|-
name|mode
index|[
name|m
index|]
operator|.
name|pedestal
operator|)
operator|/
operator|(
literal|100.0
operator|-
name|mode
index|[
name|m
index|]
operator|.
name|pedestal
operator|)
expr_stmt|;
name|ichroma_lim2
operator|=
call|(
name|int
call|)
argument_list|(
name|chroma_lim
operator|*
name|SCALE
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ichroma_lim2
operator|*=
name|ichroma_lim2
expr_stmt|;
name|icompos_lim
operator|=
call|(
name|int
call|)
argument_list|(
name|compos_lim
operator|*
name|SCALE
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|hotp (guint8 r,guint8 g,guint8 b)
name|hotp
parameter_list|(
name|guint8
name|r
parameter_list|,
name|guint8
name|g
parameter_list|,
name|guint8
name|b
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|i
decl_stmt|,
name|q
decl_stmt|;
name|long
name|y2
decl_stmt|,
name|c2
decl_stmt|;
comment|/*    * Pixel decoding, gamma correction, and matrix multiplication    * all done by lookup table.    *    * "i" and "q" are the two chrominance components;    * they are I and Q for NTSC.    * For PAL, "i" is U (scaled B-Y) and "q" is V (scaled R-Y).    * Since we only care about the length of the chroma vector,    * not its angle, we don't care which is which.    */
name|y
operator|=
name|tab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|i
operator|=
name|tab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|q
operator|=
name|tab
index|[
literal|2
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
comment|/*    * Check to see if the chrominance vector is too long or the    * composite waveform amplitude is too large.    *    * Chrominance is too large if    *    *    sqrt(i^2, q^2)>  chroma_lim.    *    * The composite signal amplitude is too large if    *    *    y + sqrt(i^2, q^2)>  compos_lim.    *    * We avoid doing the sqrt by checking    *    *    i^2 + q^2>  chroma_lim^2    * and    *    y + sqrt(i^2 + q^2)>  compos_lim    *    sqrt(i^2 + q^2)>  compos_lim - y    *    i^2 + q^2>  (compos_lim - y)^2    *    */
name|c2
operator|=
operator|(
name|long
operator|)
name|i
operator|*
name|i
operator|+
operator|(
name|long
operator|)
name|q
operator|*
name|q
expr_stmt|;
name|y2
operator|=
operator|(
name|long
operator|)
name|icompos_lim
operator|-
name|y
expr_stmt|;
name|y2
operator|*=
name|y2
expr_stmt|;
if|if
condition|(
name|c2
operator|<=
name|ichroma_lim2
operator|&&
name|c2
operator|<=
name|y2
condition|)
block|{
comment|/* no problems */
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

