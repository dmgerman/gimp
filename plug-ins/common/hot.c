begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * file: hot/hot.c  *  * $Id$  */
end_comment

begin_comment
comment|/*  * hot.c - Scan an image for pixels with RGB values that will give  *	"unsafe" values of chrominance signal or composite signal  *	amplitude when encoded into an NTSC or PAL colour signal.  *	(This happens for certain high-intensity high-saturation colours  *	that are rare in real scenes, but can easily be present  *	in synthetic images.)  *  * 	Such pixels can be flagged so the user may then choose other  *	colours.  Or, the offending pixels can be made "safe"  *	in a manner that preserves hue.  *  *	There are two reasonable ways to make a pixel "safe":  *	We can reduce its intensity (luminance) while leaving  *	hue and saturation the same.  Or, we can reduce saturation  *	while leaving hue and luminance the same.  A #define selects  *	which strategy to use.  *  * Note to the user: You must add your own read_pixel() and write_pixel()  *	routines.  You may have to modify pix_decode() and pix_encode().  *	MAXPIX, WID, and HGT are likely to need modification.  */
end_comment

begin_comment
comment|/*  * Originally written as "ikNTSC.c" by Alan Wm Paeth,  *	University of Waterloo, August, 1985  * Updated by Dave Martindale, Imax Systems Corp., December 1990  */
end_comment

begin_comment
comment|/*  * Compile time options:  *  *  * CHROMA_LIM is the limit (in IRE units) of the overall  *	chrominance amplitude; it should be 50 or perhaps  *	very slightly higher.  *   * COMPOS_LIM is the maximum amplitude (in IRE units) allowed for  *	the composite signal.  A value of 100 is the maximum  *	monochrome white, and is always safe.  120 is the absolute  *	limit for NTSC broadcasting, since the transmitter's carrier  *	goes to zero with 120 IRE input signal.  Generally, 110  *	is a good compromise - it allows somewhat brighter colours  *	than 100, while staying safely away from the hard limit.  */
end_comment

begin_comment
comment|/*  * run-time options:  *  * Define either NTSC or PAL as 1 to select the colour system.  * Define the other one as zero, or leave it undefined.  *  * Define FLAG_HOT as 1 if you want "hot" pixels set to black  *	to identify them.  Otherwise they will be made safe.  *  * Define REDUCE_SAT as 1 if you want hot pixels to be repaired by  *	reducing their saturation.  By default, luminance is reduced.  *  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpmath.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_struct
DECL|struct|Grgb
struct|struct
name|Grgb
block|{
DECL|member|red
name|guint8
name|red
decl_stmt|;
DECL|member|green
name|guint8
name|green
decl_stmt|;
DECL|member|blue
name|guint8
name|blue
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|GRegion
struct|struct
name|GRegion
block|{
DECL|member|x
name|gint32
name|x
decl_stmt|;
DECL|member|y
name|gint32
name|y
decl_stmt|;
DECL|member|width
name|gint32
name|width
decl_stmt|;
DECL|member|height
name|gint32
name|height
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|piArgs
struct|struct
name|piArgs
block|{
DECL|member|image
name|gint32
name|image
decl_stmt|;
DECL|member|drawable
name|gint32
name|drawable
decl_stmt|;
DECL|member|mode
name|gint32
name|mode
decl_stmt|;
DECL|member|action
name|gint32
name|action
decl_stmt|;
DECL|member|new_layerp
name|gint32
name|new_layerp
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2b4a03d10103
block|{
DECL|enumerator|act_lredux
name|act_lredux
init|=
literal|0
block|,
DECL|enumerator|act_sredux
name|act_sredux
init|=
literal|1
block|,
DECL|enumerator|act_flag
name|act_flag
init|=
literal|2
DECL|typedef|hotAction
block|}
name|hotAction
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2b4a03d10203
block|{
DECL|enumerator|mode_ntsc
name|mode_ntsc
init|=
literal|0
block|,
DECL|enumerator|mode_pal
name|mode_pal
init|=
literal|1
DECL|typedef|hotModes
block|}
name|hotModes
typedef|;
end_typedef

begin_define
DECL|macro|CHROMA_LIM
define|#
directive|define
name|CHROMA_LIM
value|50.0
end_define

begin_comment
DECL|macro|CHROMA_LIM
comment|/* chroma amplitude limit */
end_comment

begin_define
DECL|macro|COMPOS_LIM
define|#
directive|define
name|COMPOS_LIM
value|110.0
end_define

begin_comment
DECL|macro|COMPOS_LIM
comment|/* max IRE amplitude */
end_comment

begin_comment
comment|/*  * RGB to YIQ encoding matrix.  */
end_comment

begin_struct
struct|struct
DECL|struct|__anon2b4a03d10308
block|{
DECL|member|pedestal
name|gdouble
name|pedestal
decl_stmt|;
DECL|member|gamma
name|gdouble
name|gamma
decl_stmt|;
DECL|member|code
name|gdouble
name|code
index|[
literal|3
index|]
index|[
literal|3
index|]
decl_stmt|;
DECL|variable|mode
block|}
name|mode
index|[
literal|2
index|]
init|=
block|{
block|{
literal|7.5
block|,
literal|2.2
block|,
block|{
block|{
literal|0.2989
block|,
literal|0.5866
block|,
literal|0.1144
block|}
block|,
block|{
literal|0.5959
block|,
operator|-
literal|0.2741
block|,
operator|-
literal|0.3218
block|}
block|,
block|{
literal|0.2113
block|,
operator|-
literal|0.5227
block|,
literal|0.3113
block|}
block|}
block|}
block|,
block|{
literal|0.0
block|,
literal|2.8
block|,
block|{
block|{
literal|0.2989
block|,
literal|0.5866
block|,
literal|0.1144
block|}
block|,
block|{
operator|-
literal|0.1473
block|,
operator|-
literal|0.2891
block|,
literal|0.4364
block|}
block|,
block|{
literal|0.6149
block|,
operator|-
literal|0.5145
block|,
operator|-
literal|0.1004
block|}
block|}
block|}
block|}
struct|;
end_struct

begin_define
DECL|macro|SCALE
define|#
directive|define
name|SCALE
value|8192
end_define

begin_comment
DECL|macro|SCALE
comment|/* scale factor: do floats with int math */
end_comment

begin_define
DECL|macro|MAXPIX
define|#
directive|define
name|MAXPIX
value|255
end_define

begin_comment
DECL|macro|MAXPIX
comment|/* white value */
end_comment

begin_decl_stmt
DECL|variable|tab
name|gint
name|tab
index|[
literal|3
index|]
index|[
literal|3
index|]
index|[
name|MAXPIX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|tab
comment|/* multiply lookup table */
end_comment

begin_decl_stmt
DECL|variable|chroma_lim
name|gdouble
name|chroma_lim
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|chroma_lim
comment|/* chroma limit */
end_comment

begin_decl_stmt
DECL|variable|compos_lim
name|gdouble
name|compos_lim
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|compos_lim
comment|/* composite amplitude limit */
end_comment

begin_decl_stmt
DECL|variable|ichroma_lim2
name|glong
name|ichroma_lim2
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|ichroma_lim2
comment|/* chroma limit squared (scaled integer) */
end_comment

begin_decl_stmt
DECL|variable|icompos_lim
name|gint
name|icompos_lim
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|icompos_lim
comment|/* composite amplitude limit (scaled integer) */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|retvals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|pluginCore
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|pluginCoreIA
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|hotp
parameter_list|(
specifier|register
name|guint8
name|r
parameter_list|,
specifier|register
name|guint8
name|g
parameter_list|,
specifier|register
name|guint8
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_tab
parameter_list|(
name|int
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * gc: apply the gamma correction specified for this video standard.  * inv_gc: inverse function of gc.  *  * These are generally just a call to pow(), but be careful!  * Future standards may use more complex functions.  * (e.g. SMPTE 240M's "electro-optic transfer characteristic").  */
end_comment

begin_define
DECL|macro|gc (x,m)
define|#
directive|define
name|gc
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
value|pow(x, 1.0 / mode[m].gamma)
end_define

begin_define
DECL|macro|inv_gc (x,m)
define|#
directive|define
name|inv_gc
parameter_list|(
name|x
parameter_list|,
name|m
parameter_list|)
value|pow(x, mode[m].gamma)
end_define

begin_comment
comment|/*  * pix_decode: decode an integer pixel value into a floating-point  *	intensity in the range [0, 1].  *  * pix_encode: encode a floating-point intensity into an integer  *	pixel value.  *  * The code given here assumes simple linear encoding; you must change  * these routines if you use a different pixel encoding technique.  */
end_comment

begin_define
DECL|macro|pix_decode (v)
define|#
directive|define
name|pix_decode
parameter_list|(
name|v
parameter_list|)
value|((double)v / (double)MAXPIX)
end_define

begin_define
DECL|macro|pix_encode (v)
define|#
directive|define
name|pix_encode
parameter_list|(
name|v
parameter_list|)
value|((int)(v * (double)MAXPIX + 0.5))
end_define

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init  */
name|NULL
block|,
comment|/* quit  */
name|query
block|,
comment|/* query */
name|run
block|,
comment|/* run   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GParamDef
name|args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"The Image"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"The Drawable"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"mode"
block|,
literal|"Mode -- NTSC/PAL"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"action"
block|,
literal|"The action to perform"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"new_layerp"
block|,
literal|"Create a new layer iff True"
block|}
block|,   }
decl_stmt|;
specifier|static
name|gint
name|nargs
init|=
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|GParamDef
modifier|*
name|rets
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|nrets
init|=
literal|0
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_hot"
argument_list|,
name|_
argument_list|(
literal|"Look for hot NTSC or PAL pixels "
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"hot scans an image for pixels that will give unsave values of chrominance or composite signale amplitude when encoded into an NTSC or PAL signal.  Three actions can be performed on these ``hot'' pixels. (0) reduce luminance, (1) reduce saturation, or (2) Blacken."
argument_list|)
argument_list|,
literal|"Eric L. Hernes, Alan Wm Paeth"
argument_list|,
literal|"Eric L. Hernes"
argument_list|,
literal|"1997"
argument_list|,
name|N_
argument_list|(
literal|"<Image>/Filters/Colors/Hot..."
argument_list|)
argument_list|,
literal|"RGB"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nargs
argument_list|,
name|nrets
argument_list|,
name|args
argument_list|,
name|rets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparam,GParam * param,gint * nretvals,GParam ** retvals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|retvals
parameter_list|)
block|{
specifier|static
name|GParam
name|rvals
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|piArgs
name|args
decl_stmt|;
operator|*
name|nretvals
operator|=
literal|1
expr_stmt|;
operator|*
name|retvals
operator|=
name|rvals
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
operator|(
name|int
operator|)
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|piArgs
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|mode
operator|=
operator|-
literal|1
expr_stmt|;
name|gimp_get_data
argument_list|(
literal|"plug_in_hot"
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|image
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
expr_stmt|;
name|args
operator|.
name|drawable
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
expr_stmt|;
name|rvals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
name|INIT_I18N_UI
argument_list|()
expr_stmt|;
comment|/* XXX: add code here for interactive running */
if|if
condition|(
name|args
operator|.
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
name|args
operator|.
name|mode
operator|=
name|mode_ntsc
expr_stmt|;
name|args
operator|.
name|action
operator|=
name|act_lredux
expr_stmt|;
name|args
operator|.
name|new_layerp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pluginCoreIA
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
name|gimp_set_data
argument_list|(
literal|"plug_in_hot"
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|piArgs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
name|INIT_I18N
argument_list|()
expr_stmt|;
comment|/* XXX: add code here for non-interactive running */
if|if
condition|(
name|nparam
operator|!=
literal|6
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|mode
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|args
operator|.
name|action
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|args
operator|.
name|new_layerp
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
name|INIT_I18N
argument_list|()
expr_stmt|;
comment|/* XXX: add code here for last-values running */
if|if
condition|(
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|pluginCore (struct piArgs * argp)
name|pluginCore
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
block|{
name|GDrawable
modifier|*
name|drw
decl_stmt|,
modifier|*
name|ndrw
init|=
name|NULL
decl_stmt|;
name|GPixelRgn
name|srcPr
decl_stmt|,
name|dstPr
decl_stmt|;
name|gint
name|retval
init|=
literal|0
decl_stmt|;
name|gint
name|nl
init|=
literal|0
decl_stmt|;
name|gint
name|y
decl_stmt|,
name|x
decl_stmt|,
name|i
decl_stmt|;
name|gint
name|Y
decl_stmt|,
name|I
decl_stmt|,
name|Q
decl_stmt|;
name|guint
name|width
decl_stmt|,
name|height
decl_stmt|,
name|Bpp
decl_stmt|;
name|gint
name|prog_interval
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
name|r
decl_stmt|,
name|prev_r
init|=
literal|0
decl_stmt|,
name|new_r
init|=
literal|0
decl_stmt|;
name|guchar
name|g
decl_stmt|,
name|prev_g
init|=
literal|0
decl_stmt|,
name|new_g
init|=
literal|0
decl_stmt|;
name|guchar
name|b
decl_stmt|,
name|prev_b
init|=
literal|0
decl_stmt|,
name|new_b
init|=
literal|0
decl_stmt|;
name|gdouble
name|fy
decl_stmt|,
name|fc
decl_stmt|,
name|t
decl_stmt|,
name|scale
decl_stmt|;
name|gdouble
name|pr
decl_stmt|,
name|pg
decl_stmt|,
name|pb
decl_stmt|;
name|gdouble
name|py
decl_stmt|;
name|drw
operator|=
name|gimp_drawable_get
argument_list|(
name|argp
operator|->
name|drawable
argument_list|)
expr_stmt|;
name|width
operator|=
name|drw
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|drw
operator|->
name|height
expr_stmt|;
name|Bpp
operator|=
name|drw
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
block|{
name|gchar
name|name
index|[
literal|40
index|]
decl_stmt|;
name|gchar
modifier|*
name|mode_names
index|[]
init|=
block|{
literal|"ntsc"
block|,
literal|"pal"
block|,       }
decl_stmt|;
name|gchar
modifier|*
name|action_names
index|[]
init|=
block|{
literal|"lum redux"
block|,
literal|"sat redux"
block|,
literal|"flag"
block|,       }
decl_stmt|;
name|g_snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"hot mask (%s, %s)"
argument_list|,
name|mode_names
index|[
name|argp
operator|->
name|mode
index|]
argument_list|,
name|action_names
index|[
name|argp
operator|->
name|action
index|]
argument_list|)
expr_stmt|;
name|nl
operator|=
name|gimp_layer_new
argument_list|(
name|argp
operator|->
name|image
argument_list|,
name|name
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|RGBA_IMAGE
argument_list|,
operator|(
name|gdouble
operator|)
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|ndrw
operator|=
name|gimp_drawable_get
argument_list|(
name|nl
argument_list|)
expr_stmt|;
name|gimp_drawable_fill
argument_list|(
name|nl
argument_list|,
name|TRANS_IMAGE_FILL
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|argp
operator|->
name|image
argument_list|,
name|nl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
operator|*
name|Bpp
argument_list|)
expr_stmt|;
name|dst
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
operator|*
literal|4
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|srcPr
argument_list|,
name|drw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
block|{
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dstPr
argument_list|,
name|ndrw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dstPr
argument_list|,
name|drw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|srcPr
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
name|build_tab
argument_list|(
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Hot"
argument_list|)
argument_list|)
expr_stmt|;
name|prog_interval
operator|=
name|height
operator|/
literal|10
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|%
name|prog_interval
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|y
operator|/
operator|(
name|double
operator|)
name|height
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|hotp
argument_list|(
name|r
operator|=
operator|*
operator|(
name|s
operator|+
literal|0
operator|)
argument_list|,
name|g
operator|=
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|,
name|b
operator|=
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|argp
operator|->
name|action
operator|==
name|act_flag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|Bpp
operator|==
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
comment|/* 		   * Optimization: cache the last-computed hot pixel. 		   */
if|if
condition|(
name|r
operator|==
name|prev_r
operator|&&
name|g
operator|==
name|prev_g
operator|&&
name|b
operator|==
name|prev_b
condition|)
block|{
operator|*
name|d
operator|++
operator|=
name|new_r
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_g
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_b
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|Bpp
operator|==
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
name|Y
operator|=
name|tab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|I
operator|=
name|tab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|Q
operator|=
name|tab
index|[
literal|2
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|prev_r
operator|=
name|r
expr_stmt|;
name|prev_g
operator|=
name|g
expr_stmt|;
name|prev_b
operator|=
name|b
expr_stmt|;
comment|/* 		       * Get Y and chroma amplitudes in floating point. 		       * 		       * If your C library doesn't have hypot(), just use 		       * hypot(a,b) = sqrt(a*a, b*b); 		       * 		       * Then extract linear (un-gamma-corrected) 		       * floating-point pixel RGB values. 		       */
name|fy
operator|=
operator|(
name|double
operator|)
name|Y
operator|/
operator|(
name|double
operator|)
name|SCALE
expr_stmt|;
name|fc
operator|=
name|hypot
argument_list|(
operator|(
name|double
operator|)
name|I
operator|/
operator|(
name|double
operator|)
name|SCALE
argument_list|,
operator|(
name|double
operator|)
name|Q
operator|/
operator|(
name|double
operator|)
name|SCALE
argument_list|)
expr_stmt|;
name|pr
operator|=
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|pg
operator|=
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|pb
operator|=
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* 		       * Reducing overall pixel intensity by scaling R, 		       * G, and B reduces Y, I, and Q by the same factor. 		       * This changes luminance but not saturation, since 		       * saturation is determined by the chroma/luminance 		       * ratio. 		       * 		       * On the other hand, by linearly interpolating 		       * between the original pixel value and a grey 		       * pixel with the same luminance (R=G=B=Y), we 		       * change saturation without affecting luminance. 		       */
if|if
condition|(
name|argp
operator|->
name|action
operator|==
name|act_lredux
condition|)
block|{
comment|/* 			   * Calculate a scale factor that will bring the pixel 			   * within both chroma and composite limits, if we scale 			   * luminance and chroma simultaneously. 			   * 			   * The calculated chrominance reduction applies 			   * to the gamma-corrected RGB values that are 			   * the input to the RGB-to-YIQ operation. 			   * Multiplying the original un-gamma-corrected 			   * pixel values by the scaling factor raised to 			   * the "gamma" power is equivalent, and avoids 			   * calling gc() and inv_gc() three times each.  */
name|scale
operator|=
name|chroma_lim
operator|/
name|fc
expr_stmt|;
name|t
operator|=
name|compos_lim
operator|/
operator|(
name|fy
operator|+
name|fc
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|scale
condition|)
name|scale
operator|=
name|t
expr_stmt|;
name|scale
operator|=
name|pow
argument_list|(
name|scale
argument_list|,
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|guint8
operator|)
name|pix_encode
argument_list|(
name|scale
operator|*
name|pr
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
name|guint8
operator|)
name|pix_encode
argument_list|(
name|scale
operator|*
name|pg
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|guint8
operator|)
name|pix_encode
argument_list|(
name|scale
operator|*
name|pb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* act_sredux hopefully */
comment|/* 			   * Calculate a scale factor that will bring the 			   * pixel within both chroma and composite 			   * limits, if we scale chroma while leaving 			   * luminance unchanged. 			   * 			   * We have to interpolate gamma-corrected RGB 			   * values, so we must convert from linear to 			   * gamma-corrected before interpolation and then 			   * back to linear afterwards. 			   */
name|scale
operator|=
name|chroma_lim
operator|/
name|fc
expr_stmt|;
name|t
operator|=
operator|(
name|compos_lim
operator|-
name|fy
operator|)
operator|/
name|fc
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|scale
condition|)
name|scale
operator|=
name|t
expr_stmt|;
name|pr
operator|=
name|gc
argument_list|(
name|pr
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|pg
operator|=
name|gc
argument_list|(
name|pg
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|pb
operator|=
name|gc
argument_list|(
name|pb
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|py
operator|=
name|pr
operator|*
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|pg
operator|*
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|pb
operator|*
name|mode
index|[
name|argp
operator|->
name|mode
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|r
operator|=
name|pix_encode
argument_list|(
name|inv_gc
argument_list|(
name|py
operator|+
name|scale
operator|*
operator|(
name|pr
operator|-
name|py
operator|)
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|=
name|pix_encode
argument_list|(
name|inv_gc
argument_list|(
name|py
operator|+
name|scale
operator|*
operator|(
name|pg
operator|-
name|py
operator|)
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|pix_encode
argument_list|(
name|inv_gc
argument_list|(
name|py
operator|+
name|scale
operator|*
operator|(
name|pb
operator|-
name|py
operator|)
argument_list|,
name|argp
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
name|new_r
operator|=
name|r
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_g
operator|=
name|g
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|new_b
operator|=
name|b
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|Bpp
operator|==
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
operator|*
name|d
operator|++
operator|=
literal|255
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|argp
operator|->
name|new_layerp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Bpp
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|+=
name|Bpp
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|dstPr
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|new_layerp
condition|)
block|{
name|gimp_drawable_flush
argument_list|(
name|ndrw
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|nl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_drawable_flush
argument_list|(
name|drw
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drw
operator|->
name|id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drw
operator|->
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
name|gimp_displays_flush
argument_list|()
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|run_flag
name|gboolean
name|run_flag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|hot_ok_callback (GtkWidget * widget,gpointer data)
name|hot_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|run_flag
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|pluginCoreIA (struct piArgs * argp)
name|pluginCoreIA
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|gint
name|argc
decl_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"hot"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gtk_rc_parse
argument_list|(
name|gimp_gtkrc
argument_list|()
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Hot"
argument_list|)
argument_list|,
literal|"hot"
argument_list|,
name|gimp_plugin_help_func
argument_list|,
literal|"filters/hot.html"
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|_
argument_list|(
literal|"OK"
argument_list|)
argument_list|,
name|hot_ok_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|_
argument_list|(
literal|"Cancel"
argument_list|)
argument_list|,
name|gtk_widget_destroy
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gtk_main_quit
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"Create New Layer"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|argp
operator|->
name|new_layerp
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|new_layerp
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_radio_group_new2
argument_list|(
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Mode"
argument_list|)
argument_list|,
name|gimp_radio_button_update
argument_list|,
operator|&
name|argp
operator|->
name|mode
argument_list|,
operator|(
name|gpointer
operator|)
name|argp
operator|->
name|mode
argument_list|,
literal|"NTSC"
argument_list|,
operator|(
name|gpointer
operator|)
name|mode_ntsc
argument_list|,
name|NULL
argument_list|,
literal|"PAL"
argument_list|,
operator|(
name|gpointer
operator|)
name|mode_pal
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_radio_group_new2
argument_list|(
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Action"
argument_list|)
argument_list|,
name|gimp_radio_button_update
argument_list|,
operator|&
name|argp
operator|->
name|action
argument_list|,
operator|(
name|gpointer
operator|)
name|argp
operator|->
name|action
argument_list|,
name|_
argument_list|(
literal|"Reduce Luminance"
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|act_lredux
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reduce Saturation"
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|act_sredux
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Blacken"
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|act_flag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|run_flag
condition|)
return|return
name|pluginCore
argument_list|(
name|argp
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * build_tab: Build multiply lookup table.  *  * For each possible pixel value, decode value into floating-point  * intensity.  Then do gamma correction required by the video  * standard.  Scale the result by our fixed-point scale factor.  * Then calculate 9 lookup table entries for this pixel value.  *  * We also calculate floating-point and scaled integer versions  * of our limits here.  This prevents evaluating expressions every pixel  * when the compiler is too stupid to evaluate constant-valued  * floating-point expressions at compile time.  *  * For convenience, the limits are #defined using IRE units.  * We must convert them here into the units in which YIQ  * are measured.  The conversion from IRE to internal units  * depends on the pedestal level in use, since as Y goes from  * 0 to 1, the signal goes from the pedestal level to 100 IRE.  * Chroma is always scaled to remain consistent with Y.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|build_tab (int m)
name|build_tab
parameter_list|(
name|int
name|m
parameter_list|)
block|{
specifier|register
name|double
name|f
decl_stmt|;
specifier|register
name|int
name|pv
decl_stmt|;
for|for
control|(
name|pv
operator|=
literal|0
init|;
name|pv
operator|<=
name|MAXPIX
condition|;
name|pv
operator|++
control|)
block|{
name|f
operator|=
operator|(
name|double
operator|)
name|SCALE
operator|*
operator|(
name|double
operator|)
name|gc
argument_list|(
operator|(
name|double
operator|)
name|pix_decode
argument_list|(
name|pv
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
index|[
literal|2
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|1
index|]
index|[
literal|2
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|2
index|]
index|[
literal|0
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|2
index|]
index|[
literal|1
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
name|pv
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|f
operator|*
name|mode
index|[
name|m
index|]
operator|.
name|code
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
name|chroma_lim
operator|=
operator|(
name|double
operator|)
name|CHROMA_LIM
operator|/
operator|(
literal|100.0
operator|-
name|mode
index|[
name|m
index|]
operator|.
name|pedestal
operator|)
expr_stmt|;
name|compos_lim
operator|=
operator|(
operator|(
name|double
operator|)
name|COMPOS_LIM
operator|-
name|mode
index|[
name|m
index|]
operator|.
name|pedestal
operator|)
operator|/
operator|(
literal|100.0
operator|-
name|mode
index|[
name|m
index|]
operator|.
name|pedestal
operator|)
expr_stmt|;
name|ichroma_lim2
operator|=
call|(
name|int
call|)
argument_list|(
name|chroma_lim
operator|*
name|SCALE
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ichroma_lim2
operator|*=
name|ichroma_lim2
expr_stmt|;
name|icompos_lim
operator|=
call|(
name|int
call|)
argument_list|(
name|compos_lim
operator|*
name|SCALE
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|hotp (register guint8 r,register guint8 g,register guint8 b)
name|hotp
parameter_list|(
specifier|register
name|guint8
name|r
parameter_list|,
specifier|register
name|guint8
name|g
parameter_list|,
specifier|register
name|guint8
name|b
parameter_list|)
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|i
decl_stmt|,
name|q
decl_stmt|;
specifier|register
name|long
name|y2
decl_stmt|,
name|c2
decl_stmt|;
comment|/*  fprintf(stderr, "\tr: %d, g: %d, b: %d\n", r, g, b);*/
comment|/*    * Pixel decoding, gamma correction, and matrix multiplication    * all done by lookup table.    *    * "i" and "q" are the two chrominance components;    * they are I and Q for NTSC.    * For PAL, "i" is U (scaled B-Y) and "q" is V (scaled R-Y).    * Since we only care about the length of the chroma vector,    * not its angle, we don't care which is which.    */
name|y
operator|=
name|tab
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|0
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|i
operator|=
name|tab
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|1
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
name|q
operator|=
name|tab
index|[
literal|2
index|]
index|[
literal|0
index|]
index|[
name|r
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|1
index|]
index|[
name|g
index|]
operator|+
name|tab
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
name|b
index|]
expr_stmt|;
comment|/*    * Check to see if the chrominance vector is too long or the    * composite waveform amplitude is too large.    *    * Chrominance is too large if    *    *	sqrt(i^2, q^2)>  chroma_lim.    *    * The composite signal amplitude is too large if    *    *	y + sqrt(i^2, q^2)>  compos_lim.    *    * We avoid doing the sqrt by checking    *    *	i^2 + q^2>  chroma_lim^2    * and    *	y + sqrt(i^2 + q^2)>  compos_lim    *	sqrt(i^2 + q^2)>  compos_lim - y    *	i^2 + q^2>  (compos_lim - y)^2    *    */
name|c2
operator|=
operator|(
name|long
operator|)
name|i
operator|*
name|i
operator|+
operator|(
name|long
operator|)
name|q
operator|*
name|q
expr_stmt|;
name|y2
operator|=
operator|(
name|long
operator|)
name|icompos_lim
operator|-
name|y
expr_stmt|;
name|y2
operator|*=
name|y2
expr_stmt|;
comment|/*  fprintf(stderr, "hotp: c2: %d; ichroma_lim2: %d; y2: %d; ", 	  c2, ichroma_lim2, y2);*/
if|if
condition|(
name|c2
operator|<=
name|ichroma_lim2
operator|&&
name|c2
operator|<=
name|y2
condition|)
block|{
comment|/* no problems */
comment|/*    fprintf(stderr, "nope\n");*/
return|return
literal|0
return|;
block|}
comment|/*  fprintf(stderr, "yup\n");*/
return|return
literal|1
return|;
block|}
end_function

end_unit

