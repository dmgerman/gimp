begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PSD Save Plugin version 1.0 (BETA)  * This GIMP plug-in is designed to save Adobe Photoshop(tm) files (.PSD)  *  * Monigotes  *  *     If this plug-in fails to save a file which you think it should,  *     please tell me what seemed to go wrong, and anything you know  *     about the image you tried to save.  Please don't send big PSD  *     files to me without asking first.  *  *          Copyright (C) 2000 Monigotes  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Adobe and Adobe Photoshop are trademarks of Adobe Systems  * Incorporated that may be registered in certain jurisdictions.  */
end_comment

begin_comment
comment|/*  * Revision history:  *  *  2000.02 / v1.0 / Monigotes  *       First version.  *  */
end_comment

begin_comment
comment|/*  * TODO:  */
end_comment

begin_comment
comment|/*  * BUGS:  */
end_comment

begin_comment
comment|/* *** DEFINES *** */
end_comment

begin_comment
comment|/* set to TRUE if you want debugging, FALSE otherwise */
end_comment

begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|FALSE
end_define

begin_comment
comment|/* 1: Normal debuggin, 2: Deep debuggin */
end_comment

begin_define
DECL|macro|DEBUG_LEVEL
define|#
directive|define
name|DEBUG_LEVEL
value|1
end_define

begin_define
DECL|macro|IFDBG
define|#
directive|define
name|IFDBG
value|if (DEBUG)
end_define

begin_define
DECL|macro|IF_DEEP_DBG
define|#
directive|define
name|IF_DEEP_DBG
value|if (DEBUG&& DEBUG_LEVEL==2)
end_define

begin_comment
comment|/* *** END OF DEFINES *** */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* Local types etc  */
end_comment

begin_typedef
DECL|struct|PsdLayerDimension
typedef|typedef
struct|struct
name|PsdLayerDimension
block|{
DECL|member|left
name|gint
name|left
decl_stmt|;
DECL|member|top
name|gint
name|top
decl_stmt|;
DECL|member|width
name|gint32
name|width
decl_stmt|;
DECL|member|height
name|gint32
name|height
decl_stmt|;
DECL|typedef|PSD_Layer_Dimension
block|}
name|PSD_Layer_Dimension
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdImageData
typedef|typedef
struct|struct
name|PsdImageData
block|{
DECL|member|compression
name|gint
name|compression
decl_stmt|;
comment|/* 0, if there's no compresion; 1, if there is */
DECL|member|image_height
name|gint32
name|image_height
decl_stmt|;
DECL|member|image_width
name|gint32
name|image_width
decl_stmt|;
DECL|member|baseType
name|gint
name|baseType
decl_stmt|;
DECL|member|nChannels
name|gint
name|nChannels
decl_stmt|;
comment|/* Numero de canales de usuario de la imagen */
DECL|member|lChannels
name|gint32
modifier|*
name|lChannels
decl_stmt|;
comment|/* Canales de usuario de la imagen */
DECL|member|nLayers
name|gint
name|nLayers
decl_stmt|;
comment|/* Num de capas de la imagen */
DECL|member|lLayers
name|gint32
modifier|*
name|lLayers
decl_stmt|;
comment|/* Identificador de cada capa */
DECL|member|layersDim
name|PSD_Layer_Dimension
modifier|*
name|layersDim
decl_stmt|;
comment|/* Dimensiones de cada capa */
DECL|typedef|PSD_Image_Data
block|}
name|PSD_Image_Data
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|PSDImageData
specifier|static
name|PSD_Image_Data
name|PSDImageData
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GimpParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psd_lmode_layer
parameter_list|(
name|gint32
name|idLayer
parameter_list|,
name|gchar
modifier|*
name|psdMode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reshuffle_cmap_write
parameter_list|(
name|guchar
modifier|*
name|mapGimp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_header
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_color_mode_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_layerAndMask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfwrite
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_pascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gint
name|paded
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_string
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gshort
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_glong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|glong
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|prog_name
specifier|static
specifier|const
name|gchar
modifier|*
name|prog_name
init|=
literal|"PSD"
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"compression"
block|,
literal|"Compression type: { NONE (0), LZW (1), PACKBITS (2)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"fillorder"
block|,
literal|"Fill Order: { MSB to LSB (0), LSB to MSB (1)"
block|}
block|}
decl_stmt|;
specifier|static
name|int
name|nsave_args
init|=
sizeof|sizeof
argument_list|(
name|save_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|save_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_psd_save"
argument_list|,
literal|"saves files in the Photoshop(tm) PSD file format"
argument_list|,
literal|"This filter saves files of Adobe Photoshop(tm) native PSD format.  These files may be of any image type supported by GIMP, with or without layers, layer masks, aux channels and guides."
argument_list|,
literal|"Monigotes"
argument_list|,
literal|"Monigotes"
argument_list|,
literal|"2000"
argument_list|,
literal|"<Save>/PSD"
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|nsave_args
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_psd_save"
argument_list|,
literal|"psd"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,int nparams,GimpParam * param,int * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GimpParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_psd_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\n---------------- %s ----------------\n"
argument_list|,
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
comment|/* Nombre del fichero */
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
argument_list|)
condition|)
comment|/* Identificador de la imagen */
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|xmalloc (size_t n)
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"PSD: WARNING: %s: xmalloc asked for zero-sized chunk\n"
argument_list|,
name|prog_name
argument_list|)
decl_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|g_malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
name|IFDBG
name|printf
argument_list|(
literal|"%s: out of memory\n"
argument_list|,
name|prog_name
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
DECL|function|psd_lmode_layer (gint32 idLayer,gchar * psdMode)
specifier|static
name|void
name|psd_lmode_layer
parameter_list|(
name|gint32
name|idLayer
parameter_list|,
name|gchar
modifier|*
name|psdMode
parameter_list|)
block|{
switch|switch
condition|(
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
condition|)
block|{
case|case
name|GIMP_NORMAL_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DARKEN_ONLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"dark"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LIGHTEN_ONLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"lite"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_HUE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"hue "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_SATURATION_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"sat "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"colr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_MULTIPLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"mul "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_SCREEN_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"scrn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DISSOLVE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"diss"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DIFFERENCE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"diff"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_VALUE_MODE
case|:
comment|/* ? */
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"lum "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_OVERLAY_MODE
case|:
comment|/* ? */
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"over"
argument_list|)
expr_stmt|;
break|break;
comment|/*    case GIMP_BEHIND_MODE:                 Estos son de GIMP 1.1.14*/
comment|/*    case GIMP_DIVIDE_MODE:                 Estos son de GIMP 1.1.14*/
case|case
name|GIMP_ADDITION_MODE
case|:
case|case
name|GIMP_SUBTRACT_MODE
case|:
name|IFDBG
name|printf
argument_list|(
literal|"PSD: Warning - unsupported layer-blend mode: %c, using 'norm' mode\n"
argument_list|,
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"PSD: Warning - UNKNOWN layer-blend mode, reverting to 'norm'\n"
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
DECL|function|write_string (FILE * fd,char * val,gchar * why)
specifier|static
name|void
name|write_string
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|write_pascalstring (FILE * fd,char * val,gint paded,gchar * why)
specifier|static
name|void
name|write_pascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gint
name|paded
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|valLength
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Calcula la longitud del string a grabar y lo limita a 255 */
name|valLength
operator|=
operator|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|>
literal|255
operator|)
condition|?
literal|255
else|:
operator|(
name|unsigned
name|char
operator|)
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Se realiza la grabacion */
if|if
condition|(
name|valLength
operator|!=
literal|0
condition|)
block|{
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|valLength
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|val
argument_list|,
name|valLength
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
else|else
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* Si la longitud total (longitud + contenido) no es multiplo del valor 'paded',      se añaden los ceros necesarios para rellenar */
name|valLength
operator|++
expr_stmt|;
comment|/* Le añado el campo longitud */
if|if
condition|(
operator|(
name|valLength
operator|%
name|paded
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|paded
operator|-
operator|(
name|valLength
operator|%
name|paded
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|xfwrite (FILE * fd,void * buf,long len,gchar * why)
specifier|static
name|void
name|xfwrite
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: xfwrite: Error mientras grababa '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|write_gchar (FILE * fd,unsigned char val,gchar * why)
specifier|static
name|void
name|write_gchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|gint32
name|pos
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: write_gchar: Error mientras grababa '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fd
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|write_gshort (FILE * fd,gshort val,gchar * why)
specifier|static
name|void
name|write_gshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gshort
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
comment|/*  b[0] = val& 255;       b[1] = (val>> 8)& 255;*/
name|b
index|[
literal|1
index|]
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: write_gshort: Error mientras grababa '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|write_glong (FILE * fd,glong val,gchar * why)
specifier|static
name|void
name|write_glong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|glong
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
comment|/*  b[0] = val& 255;       b[1] = (val>> 8)& 255;       b[2] = (val>> 16)& 255;       b[3] = (val>> 24)& 255;*/
name|b
index|[
literal|3
index|]
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: write_glong: Error mientras grababa '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|pack_pb_line (guchar * ini,guchar * fin,guchar * datosRes,gshort * longitud)
specifier|static
name|void
name|pack_pb_line
parameter_list|(
name|guchar
modifier|*
name|ini
parameter_list|,
name|guchar
modifier|*
name|fin
parameter_list|,
name|guchar
modifier|*
name|datosRes
parameter_list|,
name|gshort
modifier|*
name|longitud
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint32
name|restantes
decl_stmt|;
name|restantes
operator|=
name|fin
operator|-
name|ini
expr_stmt|;
operator|*
name|longitud
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|restantes
operator|>
literal|0
condition|)
block|{
comment|/* Busca caracteres iguales a la muestra */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|128
operator|)
operator|&&
operator|(
name|ini
operator|+
name|i
operator|<
name|fin
operator|)
operator|&&
operator|(
operator|(
operator|*
name|ini
operator|)
operator|==
operator|*
operator|(
name|ini
operator|+
name|i
operator|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
comment|/* Ha encontrado iguales */
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"Repeticion: '%d', %d veces ------------> "
argument_list|,
operator|*
name|ini
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"Grabo: '%d' %d\n"
argument_list|,
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|ini
argument_list|)
decl_stmt|;
operator|*
operator|(
name|datosRes
operator|++
operator|)
operator|=
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|datosRes
operator|++
operator|)
operator|=
operator|*
name|ini
expr_stmt|;
name|ini
operator|+=
name|i
expr_stmt|;
name|restantes
operator|-=
name|i
expr_stmt|;
operator|*
name|longitud
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* Busca caracteres distintos al anterior */
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|128
operator|)
operator|&&
operator|(
name|ini
operator|+
name|i
operator|+
literal|1
operator|<=
name|fin
operator|)
operator|&&
operator|(
operator|*
operator|(
name|ini
operator|+
name|i
operator|)
operator|!=
operator|*
operator|(
name|ini
operator|+
name|i
operator|+
literal|1
operator|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Si solo quedaba 1 en la linea, el while anterior no lo coje  */
if|if
condition|(
name|restantes
operator|==
literal|1
condition|)
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"1 Restante:\t"
argument_list|)
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* Ha encontrado distintos */
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"%d distintos              ------------> Grabo: '%d' "
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
operator|*
operator|(
name|datosRes
operator|++
operator|)
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"%d "
argument_list|,
operator|*
operator|(
name|ini
operator|+
name|j
operator|)
argument_list|)
decl_stmt|;
operator|*
operator|(
name|datosRes
operator|++
operator|)
operator|=
operator|*
operator|(
name|ini
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|ini
operator|+=
name|i
expr_stmt|;
name|restantes
operator|-=
name|i
expr_stmt|;
operator|*
name|longitud
operator|+=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|/* else */
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"Restantes: %d\n"
argument_list|,
name|restantes
argument_list|)
decl_stmt|;
block|}
comment|/* while principal */
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\nLongitud total: %d\n"
argument_list|,
operator|*
name|longitud
argument_list|)
decl_stmt|;
comment|/*  if ( *longitud& 1 )		// longitud impar, se añade un nop (128)   {     *longitud += 1;     *(datosRes++) = 128;      IF_DEEP_DBG printf("Longitud total modificada: %d\n", *longitud);   } */
block|}
end_function

begin_function
DECL|function|GRAYA_to_chans (guchar * greyA,gint numpix,guchar ** grey,guchar ** alpha)
specifier|static
name|void
name|GRAYA_to_chans
parameter_list|(
name|guchar
modifier|*
name|greyA
parameter_list|,
name|gint
name|numpix
parameter_list|,
name|guchar
modifier|*
modifier|*
name|grey
parameter_list|,
name|guchar
modifier|*
modifier|*
name|alpha
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gint
name|nPix
decl_stmt|;
if|if
condition|(
name|greyA
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"greyA es un canal nulo"
argument_list|)
decl_stmt|;
operator|*
name|grey
operator|=
name|NULL
expr_stmt|;
operator|*
name|alpha
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|nPix
operator|=
name|numpix
operator|/
literal|2
expr_stmt|;
operator|*
name|grey
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|alpha
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPix
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|grey
operator|)
index|[
name|i
index|]
operator|=
name|greyA
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|alpha
operator|)
index|[
name|i
index|]
operator|=
name|greyA
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|RGB_to_chans (guchar * rgb,gint numpix,guchar ** red,guchar ** green,guchar ** blue)
specifier|static
name|void
name|RGB_to_chans
parameter_list|(
name|guchar
modifier|*
name|rgb
parameter_list|,
name|gint
name|numpix
parameter_list|,
name|guchar
modifier|*
modifier|*
name|red
parameter_list|,
name|guchar
modifier|*
modifier|*
name|green
parameter_list|,
name|guchar
modifier|*
modifier|*
name|blue
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gint
name|nPix
decl_stmt|;
if|if
condition|(
name|rgb
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"rgb es un canal nulo"
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|NULL
expr_stmt|;
operator|*
name|green
operator|=
name|NULL
expr_stmt|;
operator|*
name|blue
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|nPix
operator|=
name|numpix
operator|/
literal|3
expr_stmt|;
operator|*
name|red
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|green
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|blue
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPix
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|red
operator|)
index|[
name|i
index|]
operator|=
name|rgb
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
operator|(
operator|*
name|green
operator|)
index|[
name|i
index|]
operator|=
name|rgb
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|blue
operator|)
index|[
name|i
index|]
operator|=
name|rgb
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|RGBA_to_chans (guchar * rgbA,gint numpix,guchar ** red,guchar ** green,guchar ** blue,guchar ** alpha)
specifier|static
name|void
name|RGBA_to_chans
parameter_list|(
name|guchar
modifier|*
name|rgbA
parameter_list|,
name|gint
name|numpix
parameter_list|,
name|guchar
modifier|*
modifier|*
name|red
parameter_list|,
name|guchar
modifier|*
modifier|*
name|green
parameter_list|,
name|guchar
modifier|*
modifier|*
name|blue
parameter_list|,
name|guchar
modifier|*
modifier|*
name|alpha
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gint
name|nPix
decl_stmt|;
if|if
condition|(
name|rgbA
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"rgb es un canal nulo"
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|NULL
expr_stmt|;
operator|*
name|green
operator|=
name|NULL
expr_stmt|;
operator|*
name|blue
operator|=
name|NULL
expr_stmt|;
operator|*
name|alpha
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|nPix
operator|=
name|numpix
operator|/
literal|4
expr_stmt|;
operator|*
name|red
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|green
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|blue
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|alpha
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPix
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|red
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
index|]
expr_stmt|;
operator|(
operator|*
name|green
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|blue
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|alpha
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|gimpBaseTypeToPsdMode (gint gimpBaseType)
specifier|static
name|gint
name|gimpBaseTypeToPsdMode
parameter_list|(
name|gint
name|gimpBaseType
parameter_list|)
block|{
switch|switch
condition|(
name|gimpBaseType
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
return|return
operator|(
literal|3
operator|)
return|;
comment|/* RGB */
case|case
name|GIMP_GRAY_IMAGE
case|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Grayscale */
case|case
name|GIMP_INDEXED_IMAGE
case|:
return|return
operator|(
literal|2
operator|)
return|;
comment|/* Indexed */
default|default:
name|g_message
argument_list|(
literal|"PSD: Error: Can't convert GIMP base imagetype to PSD mode\n"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"PSD Save: el gimpBaseType vale %d, no puede convertirlo a PSD mode"
argument_list|,
name|gimpBaseType
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
comment|/* Retorno RGB por defecto */
block|}
block|}
end_function

begin_function
DECL|function|nCanalesLayer (gint gimpBaseType,gint hasAlpha)
specifier|static
name|gint
name|nCanalesLayer
parameter_list|(
name|gint
name|gimpBaseType
parameter_list|,
name|gint
name|hasAlpha
parameter_list|)
block|{
name|int
name|incAlpha
init|=
literal|0
decl_stmt|;
name|incAlpha
operator|=
operator|(
name|hasAlpha
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
switch|switch
condition|(
name|gimpBaseType
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
return|return
operator|(
literal|3
operator|+
name|incAlpha
operator|)
return|;
comment|/* R,G,B y Alpha (Si existe) */
case|case
name|GIMP_GRAY_IMAGE
case|:
return|return
operator|(
literal|1
operator|+
name|incAlpha
operator|)
return|;
comment|/* G y Alpha (Si existe) */
case|case
name|GIMP_INDEXED_IMAGE
case|:
return|return
operator|(
literal|1
operator|+
name|incAlpha
operator|)
return|;
comment|/* I y Alpha (Si existe) */
default|default:
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Retorno 0 cananles por defecto */
block|}
block|}
end_function

begin_function
DECL|function|reshuffle_cmap_write (guchar * mapGimp)
specifier|static
name|void
name|reshuffle_cmap_write
parameter_list|(
name|guchar
modifier|*
name|mapGimp
parameter_list|)
block|{
name|guchar
modifier|*
name|mapPSD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mapPSD
operator|=
name|xmalloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|mapPSD
index|[
name|i
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
name|mapPSD
index|[
name|i
operator|+
literal|256
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|mapPSD
index|[
name|i
operator|+
literal|512
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
block|{
name|mapGimp
index|[
name|i
index|]
operator|=
name|mapPSD
index|[
name|i
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|mapPSD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|save_header (FILE * fd,gint32 image_id)
specifier|static
name|void
name|save_header
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: save_header\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Filas: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Columnas: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Tipo base: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|baseType
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Numero de canales: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nChannels
argument_list|)
decl_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|,
literal|"signature"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"reserved 1"
argument_list|)
expr_stmt|;
comment|/* 6 bytes para el campo 'reservado'. 4 bytes de un long */
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"reserved 1"
argument_list|)
expr_stmt|;
comment|/* y 2 bytes de un short */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|nChannels
operator|+
name|nCanalesLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"channels"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
literal|"columns"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|8
argument_list|,
literal|"depth"
argument_list|)
expr_stmt|;
comment|/* Parece que GIMP solo soporta las                                            imagenes PSD de 8 bits de profundidad */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|gimpBaseTypeToPsdMode
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|)
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|save_color_mode_data (FILE * fd,gint32 image_id)
specifier|static
name|void
name|save_color_mode_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|guchar
modifier|*
name|cmap_modificado
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gint32
name|nColors
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: save_color_mode_data\n"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|IFDBG
name|printf
argument_list|(
literal|"      Tipo de la imagen: INDEXED\n"
argument_list|)
decl_stmt|;
name|cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_id
argument_list|,
operator|&
name|nColors
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Longitud del colormap devuelto por gimp_image_get_cmap: %d\n"
argument_list|,
name|nColors
argument_list|)
decl_stmt|;
if|if
condition|(
name|nColors
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      La imagen indexada no tiene colormap\n"
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nColors
operator|!=
literal|256
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      La imagen indexada tiene %d!=256 colores\n"
argument_list|,
name|nColors
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Relleno hasta llegar a 256 con ceros\n"
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|768
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
comment|/* Para este tipo, longitud siempre 768 */
name|cmap_modificado
operator|=
name|xmalloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nColors
operator|*
literal|3
condition|;
name|i
operator|++
control|)
name|cmap_modificado
index|[
name|i
index|]
operator|=
name|cmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nColors
operator|*
literal|3
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
name|cmap_modificado
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reshuffle_cmap_write
argument_list|(
name|cmap_modificado
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|cmap_modificado
argument_list|,
literal|768
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
comment|/* Graba el mapa de colores reajustado */
name|g_free
argument_list|(
name|cmap_modificado
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* nColors es igual a 256 */
block|{
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|768
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
comment|/* Para este tipo, longitud siempre 768 */
name|reshuffle_cmap_write
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|cmap
argument_list|,
literal|768
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
comment|/* Graba el mapa de colores reajustado */
block|}
break|break;
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"      Tipo de la imagen: No INDEXED\n"
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|save_resources (FILE * fd,gint32 image_id)
specifier|static
name|void
name|save_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|chName
init|=
name|NULL
decl_stmt|;
comment|/* Nombres de los canales */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Nombre del fichero de la imagen */
name|gint32
name|idActLayer
decl_stmt|;
comment|/* Id de la capa activa */
name|guint
name|nActiveLayer
init|=
literal|0
decl_stmt|;
comment|/* Num de la capa activa */
name|gboolean
name|hayActiveLayer
decl_stmt|;
comment|/* TRUE si hay alguna capa activa */
name|gint32
name|posActual
decl_stmt|;
comment|/* Posicion: Fin de fichero */
name|gint32
name|posTotal
decl_stmt|;
comment|/* Posicion: Longitud de la seccion recursos */
name|gint32
name|posNombres
decl_stmt|;
comment|/* Posicion: Longitud de Nombres de canales */
comment|/* Los unicos recursos relevantes en GIMP son: 0x03EE, 0x03F0 y 0x0400 */
comment|/* Para la version 4.0 de Adobe Photoshop, estudiar: 0x0408, 0x040A y 0x040B */
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: save_resources\n"
argument_list|)
decl_stmt|;
comment|/* Obtiene los nombres de los canales */
if|if
condition|(
name|PSDImageData
operator|.
name|nChannels
operator|>
literal|0
condition|)
name|chName
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|PSDImageData
operator|.
name|nChannels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDImageData
operator|.
name|nChannels
condition|;
name|i
operator|++
control|)
block|{
name|chName
index|[
name|i
index|]
operator|=
name|gimp_channel_get_name
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Nombre del canal %d: %s\n"
argument_list|,
name|i
argument_list|,
name|chName
index|[
name|i
index|]
argument_list|)
decl_stmt|;
block|}
comment|/* Obtiene el titulo de la imagen, su nombre de fichero */
name|fileName
operator|=
name|gimp_image_get_filename
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Titulo de la imagen: %s\n"
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
comment|/* Obtiene el numero de la capa activa */
name|idActLayer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Identificador de capa activa es: %d\n"
argument_list|,
name|idActLayer
argument_list|)
decl_stmt|;
name|hayActiveLayer
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDImageData
operator|.
name|nLayers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idActLayer
operator|==
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
condition|)
block|{
name|nActiveLayer
operator|=
name|i
expr_stmt|;
name|hayActiveLayer
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|hayActiveLayer
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      El numero de capa activa es: %d\n"
argument_list|,
name|nActiveLayer
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      No hay capa activa\n"
argument_list|)
decl_stmt|;
block|}
comment|/* Aqui empiezo a grabar toda la historia */
name|posTotal
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"image resources length"
argument_list|)
expr_stmt|;
comment|/* --------------- Voy a grabar: Nombres de los canales --------------- */
if|if
condition|(
name|PSDImageData
operator|.
name|nChannels
operator|>
literal|0
condition|)
block|{
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0x03EE
argument_list|,
literal|"0x03EE Id"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring(fd, Name, "Id name"); */
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Pongo un string nulo, dos ceros */
comment|/* Marco la posicion actual del fichero */
name|posNombres
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"0x03EE resource size"
argument_list|)
expr_stmt|;
comment|/* Grabo todos los strings */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/*      write_pascalstring(fd, chName[i], 2, "chanel name"); */
name|write_string
argument_list|(
name|fd
argument_list|,
name|chName
index|[
name|i
index|]
argument_list|,
literal|"channel name"
argument_list|)
expr_stmt|;
comment|/* Calculo y grabo la longitud real de este recurso */
name|posActual
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Posicion del fin de fichero */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posNombres
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|posActual
operator|-
name|posNombres
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"0x03EE resource size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n      Longitud total de 0x03EE resource: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|posActual
operator|-
name|posNombres
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Vuelve al final de fichero para continuar con la grabacion */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posActual
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Si la longitud es impar, añado un cero */
if|if
condition|(
operator|(
name|posActual
operator|-
name|posNombres
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
operator|)
operator|&
literal|1
condition|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"pad byte"
argument_list|)
expr_stmt|;
block|}
comment|/* --------------- Voy a grabar: Numero de capa activa --------------- */
if|if
condition|(
name|hayActiveLayer
condition|)
block|{
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0x0400
argument_list|,
literal|"0x0400 Id"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring(fd, Name, "Id name"); */
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Pongo un string nulo, que son dos ceros */
name|write_glong
argument_list|(
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
argument_list|,
literal|"0x0400 resource size"
argument_list|)
expr_stmt|;
comment|/* Grabo el titulo como gshort, tendra siempre una longitud par */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|nActiveLayer
argument_list|,
literal|"active layer"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Longitud total de 0x0400 resource: %d\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
argument_list|)
decl_stmt|;
block|}
comment|/* --------------- Voy a grabar: Longitud total de la seccion --------------- */
name|posActual
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Posicion del fin de fichero */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posTotal
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|posActual
operator|-
name|posTotal
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"image resources length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Longitud total de la seccion de recursos: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|posActual
operator|-
name|posTotal
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Vuelve al final de fichero para continuar con la grabacion */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posActual
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|chName
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|get_compress_channel_data (guchar * channel_data,gint32 channel_cols,gint32 channel_rows,gshort ** tablaLongitudes,guchar ** datosRes,glong * longTotalComprimido)
specifier|static
name|void
name|get_compress_channel_data
parameter_list|(
name|guchar
modifier|*
name|channel_data
parameter_list|,
name|gint32
name|channel_cols
parameter_list|,
name|gint32
name|channel_rows
parameter_list|,
name|gshort
modifier|*
modifier|*
name|tablaLongitudes
parameter_list|,
name|guchar
modifier|*
modifier|*
name|datosRes
parameter_list|,
name|glong
modifier|*
name|longTotalComprimido
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint32
name|longitud
decl_stmt|;
comment|/* Longitud de datos comprimidos */
name|gshort
name|longAux
decl_stmt|;
comment|/* Auxiliar */
name|guchar
modifier|*
name|ini
decl_stmt|;
comment|/* Posicion de inicio de una fila en channel_data */
name|guchar
modifier|*
name|fin
decl_stmt|;
comment|/* Posicion de fin de una fila en channel_data */
name|gint32
name|channel_length
decl_stmt|;
comment|/* Longitud total del canal */
name|channel_length
operator|=
name|channel_cols
operator|*
name|channel_rows
expr_stmt|;
operator|*
name|datosRes
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|channel_length
operator|*
literal|2
argument_list|)
expr_stmt|;
operator|*
name|tablaLongitudes
operator|=
name|g_new
argument_list|(
name|gshort
argument_list|,
name|channel_rows
argument_list|)
expr_stmt|;
comment|/* Para cada una de las filas del canal */
name|longitud
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
block|{
name|ini
operator|=
name|channel_data
operator|+
operator|(
name|i
operator|*
name|channel_cols
operator|)
expr_stmt|;
name|fin
operator|=
name|ini
operator|+
name|channel_cols
expr_stmt|;
comment|/* Creando los datos comprimidos de la linea */
name|pack_pb_line
argument_list|(
name|ini
argument_list|,
name|fin
argument_list|,
operator|(
operator|*
name|datosRes
operator|)
operator|+
name|longitud
argument_list|,
operator|&
name|longAux
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tablaLongitudes
operator|)
index|[
name|i
index|]
operator|=
name|longAux
expr_stmt|;
name|longitud
operator|+=
name|longAux
expr_stmt|;
block|}
operator|*
name|longTotalComprimido
operator|=
operator|(
name|longitud
operator|+
name|channel_rows
operator|*
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|save_channel_data (FILE * fd,guchar * channel_data,gint32 channel_cols,gint32 channel_rows,gint32 posLong,gchar * why)
specifier|static
name|void
name|save_channel_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|channel_data
parameter_list|,
name|gint32
name|channel_cols
parameter_list|,
name|gint32
name|channel_rows
parameter_list|,
name|gint32
name|posLong
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint32
name|longitud
decl_stmt|;
comment|/* Longitud de datos comprimidos */
name|glong
name|longTotalCrudo
decl_stmt|;
comment|/* Longitud total de los datos en crudo */
name|glong
name|longTotalComprimido
decl_stmt|;
comment|/* Longitud total de los datos coprimidos */
name|gshort
modifier|*
name|tablaLongitudes
decl_stmt|;
comment|/* Longitudes de cada linea comprimida */
name|gshort
name|longAux
decl_stmt|;
comment|/* Auxiliar */
name|guchar
modifier|*
name|datosRes
decl_stmt|;
comment|/* Datos comprimidos de una linea */
name|guchar
modifier|*
name|ini
decl_stmt|;
comment|/* Posicion de inicio de una fila en channel_data */
name|guchar
modifier|*
name|fin
decl_stmt|;
comment|/* Posicion de fin de una fila en channel_data */
name|gint32
name|channel_length
decl_stmt|;
comment|/* Longitud total del canal */
name|channel_length
operator|=
name|channel_cols
operator|*
name|channel_rows
expr_stmt|;
name|datosRes
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|channel_length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|tablaLongitudes
operator|=
name|g_new
argument_list|(
name|gshort
argument_list|,
name|channel_rows
argument_list|)
expr_stmt|;
comment|/* Para cada una de las filas del canal */
name|longitud
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
block|{
name|ini
operator|=
name|channel_data
operator|+
operator|(
name|i
operator|*
name|channel_cols
operator|)
expr_stmt|;
name|fin
operator|=
name|ini
operator|+
name|channel_cols
expr_stmt|;
comment|/* Creando los datos comprimidos de la linea */
name|pack_pb_line
argument_list|(
name|ini
argument_list|,
name|fin
argument_list|,
name|datosRes
operator|+
name|longitud
argument_list|,
operator|&
name|longAux
argument_list|)
expr_stmt|;
name|tablaLongitudes
index|[
name|i
index|]
operator|=
name|longAux
expr_stmt|;
name|longitud
operator|+=
name|longAux
expr_stmt|;
block|}
comment|/* Calcula las longitudes totales de los dos tipos */
name|longTotalCrudo
operator|=
operator|(
name|channel_rows
operator|*
name|channel_cols
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
expr_stmt|;
name|longTotalComprimido
operator|=
operator|(
name|longitud
operator|+
name|channel_rows
operator|*
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
expr_stmt|;
comment|/*  IFDBG printf("\nLongitud comprimida: %ld\n", longTotalComprimido );    IFDBG printf("\nLongitud cruda: %ld\n", longTotalCrudo ); */
if|if
condition|(
name|longTotalComprimido
operator|<
name|longTotalCrudo
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"        Grabo datos (RLE): %ld\n"
argument_list|,
name|longTotalComprimido
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"Compression"
argument_list|)
expr_stmt|;
comment|/* Graba el tipo de compresion */
comment|/* Graba la tabla de longitudes de linea comprimida */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|tablaLongitudes
index|[
name|i
index|]
argument_list|,
literal|"RLE length"
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|datosRes
argument_list|,
name|longitud
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* Graba los datos comprimidos */
comment|/* Actualiza el valor correspondiente a la longitud de los datos del canal */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posLong
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|longTotalComprimido
argument_list|,
literal|"channel data length"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"        Grabo datos (raw): %ld\n"
argument_list|,
name|longTotalCrudo
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Compression"
argument_list|)
expr_stmt|;
comment|/* Graba el tipo de compresion */
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|channel_data
argument_list|,
name|channel_length
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* Graba los datos en crudo */
block|}
block|}
end_function

begin_function
DECL|function|save_layerAndMask (FILE * fd,gint32 image_id)
specifier|static
name|void
name|save_layerAndMask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|idCanal
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
comment|/* Offset x de cada capa */
name|gint
name|offset_y
decl_stmt|;
comment|/* Offset y de cada capa*/
name|gint32
name|layerHeight
decl_stmt|;
comment|/* Altura de cada capa */
name|gint32
name|layerWidth
decl_stmt|;
comment|/* Anchura de cada capa*/
name|gchar
name|blendMode
index|[
literal|5
index|]
decl_stmt|;
comment|/* Blend mode de la capa */
name|unsigned
name|char
name|layerOpacity
decl_stmt|;
comment|/* Opacidad de la capa */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Banderas de la capa */
name|gint
name|nChannelsLayer
decl_stmt|;
comment|/* Numero de canales de una capa */
name|gint32
name|longCanal
decl_stmt|;
comment|/* Longitud de los datos de un canal */
name|char
modifier|*
name|layerName
decl_stmt|;
comment|/* Nombre de la capa */
name|gint32
name|posActual
decl_stmt|;
comment|/* Posicion: Fin de fichero */
name|gint32
name|posExtraData
decl_stmt|;
comment|/* Posicion: Longitud de Extra data */
name|gint32
name|posLayerMask
decl_stmt|;
comment|/* Posicion: Longitud Layer& Mask section */
name|gint32
name|posLayerInfo
decl_stmt|;
comment|/* Posicion: Longitud Layer info section */
name|gint32
modifier|*
modifier|*
name|posLongChannel
decl_stmt|;
comment|/* Posicion: Longitud de un canal */
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: save_layer&mask\n"
argument_list|)
decl_stmt|;
comment|/* Creo la primera dimension del array (capas, canales) */
name|posLongChannel
operator|=
name|g_new
argument_list|(
name|gint32
operator|*
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
comment|/* Seccion Layer and mask information  */
name|posLayerMask
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers& mask information length"
argument_list|)
expr_stmt|;
comment|/* Seccion Layer info */
name|posLayerInfo
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
comment|/* Seccion Layer structure */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|,
literal|"Layer structure count"
argument_list|)
expr_stmt|;
comment|/* Seccion Layer records */
comment|/* La ultima capa que tiene GIMP debe grabarse la primera */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gimp_drawable_offsets
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|layerHeight
operator|=
name|gimp_drawable_height
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|layerWidth
operator|=
name|gimp_drawable_width
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
operator|=
name|offset_x
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
operator|=
name|offset_y
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|=
name|layerHeight
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|=
name|layerWidth
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Capa numero: %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Offset x: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Offset y: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Height: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Width: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|,
literal|"Layer top"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|,
literal|"Layer left"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|+
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|,
literal|"Layer top"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|+
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|,
literal|"Layer right"
argument_list|)
expr_stmt|;
name|nChannelsLayer
operator|=
name|nCanalesLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|nChannelsLayer
argument_list|,
literal|"Number channels in the layer"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Numero de canales: %d\n"
argument_list|,
name|nChannelsLayer
argument_list|)
decl_stmt|;
comment|/* Creo la segunda dimension del array (capas, canales) */
name|posLongChannel
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|nChannelsLayer
argument_list|)
expr_stmt|;
comment|/* Probar con gimp_drawable_bytes() */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nChannelsLayer
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|idCanal
operator|=
name|j
operator|-
literal|1
expr_stmt|;
else|else
name|idCanal
operator|=
name|j
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|idCanal
argument_list|,
literal|"Channel ID"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"           - Identificador: %d\n"
argument_list|,
name|idCanal
argument_list|)
decl_stmt|;
comment|/* Grabo la longitud como si no hubiese compression. Si en realidad          la hay, lo modifico mas tarde, cuando grabe los datos */
name|posLongChannel
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|longCanal
operator|=
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|+
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|*
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|longCanal
argument_list|,
literal|"Channel ID"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"             Longitud: %d\n"
argument_list|,
name|longCanal
argument_list|)
decl_stmt|;
block|}
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"blend mode signature"
argument_list|)
expr_stmt|;
name|psd_lmode_layer
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
name|blendMode
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Blend mode: %s\n"
argument_list|,
name|blendMode
argument_list|)
decl_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|blendMode
argument_list|,
literal|4
argument_list|,
literal|"blend mode key"
argument_list|)
expr_stmt|;
name|layerOpacity
operator|=
operator|(
name|gimp_layer_get_opacity
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
operator|*
literal|255.0
operator|)
operator|/
literal|100.0
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Opacity: %u\n"
argument_list|,
name|layerOpacity
argument_list|)
decl_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|layerOpacity
argument_list|,
literal|"Opacity"
argument_list|)
expr_stmt|;
comment|/* Parece que el siguiente campo no se usa en GIMP */
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Clipping"
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gimp_layer_get_preserve_transparency
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|flags
operator|=
name|flags
operator||
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_layer_get_visible
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|flags
operator|=
name|flags
operator||
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Flags: %u\n"
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|flags
argument_list|,
literal|"Flags"
argument_list|)
expr_stmt|;
comment|/* Byte de relleno para parear */
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Filler"
argument_list|)
expr_stmt|;
name|posExtraData
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Posicion de Extra Data size */
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Extra data size"
argument_list|)
expr_stmt|;
comment|/* OJO Pongo vacia Layer mask / adjustment layer data */
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer mask size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n         Layer mask size: %d\n"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* OJO Pongo vacia Layer blending ranges data */
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer blending size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n         Layer blending size: %d\n"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|layerName
operator|=
name|gimp_layer_get_name
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write_pascalstring
argument_list|(
name|fd
argument_list|,
name|layerName
argument_list|,
literal|4
argument_list|,
literal|"layer name"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n         Layer name: %s\n"
argument_list|,
name|layerName
argument_list|)
decl_stmt|;
comment|/* Graba la longitud real de: Extra data */
name|posActual
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Posicion del fin de fichero */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posExtraData
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|posActual
operator|-
name|posExtraData
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"Extra data size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Longitud total de ExtraData: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|posActual
operator|-
name|posExtraData
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Vuelve al final de fichero para continuar con la grabacion */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posActual
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
comment|/* Seccion channel image data */
comment|/* La ultima capa que tiene GIMP debe grabarse la primera */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|nCanal
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpPixelRgn
name|region
decl_stmt|;
comment|/* Region de la imagen */
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* Bytes que componen un layer con todos sus canales */
name|guchar
modifier|*
name|red
decl_stmt|;
comment|/* Bytes que componen un canal R */
name|guchar
modifier|*
name|green
decl_stmt|;
comment|/* Bytes que componen un canal G */
name|guchar
modifier|*
name|blue
decl_stmt|;
comment|/* Bytes que componen un canal B */
name|guchar
modifier|*
name|gray
decl_stmt|;
comment|/* Bytes que componen un canal G */
name|guchar
modifier|*
name|alpha
decl_stmt|;
comment|/* Bytes que componen un canal Alpha */
name|gint32
name|longCanal
decl_stmt|;
comment|/* Longitud de los datos de un canal */
name|IFDBG
name|printf
argument_list|(
literal|"\n     Chanels image data. Layer: %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|longCanal
operator|=
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|*
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
expr_stmt|;
name|nChannelsLayer
operator|=
name|nCanalesLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|longCanal
operator|*
name|nChannelsLayer
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Longitud canal: %d\n"
argument_list|,
name|longCanal
argument_list|)
decl_stmt|;
name|nCanal
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|RGBA_to_chans
argument_list|(
name|data
argument_list|,
name|longCanal
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|,
operator|&
name|alpha
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal alpha...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|alpha
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"alpha channel"
argument_list|)
expr_stmt|;
block|}
else|else
name|RGB_to_chans
argument_list|(
name|data
argument_list|,
name|longCanal
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal red...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|red
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"red channel"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal green...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|green
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"green channel"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal blue...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|blue
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"blue channel"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|GRAYA_to_chans
argument_list|(
name|data
argument_list|,
name|longCanal
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|gray
argument_list|,
operator|&
name|alpha
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal alpha...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|alpha
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"alpha channel"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal gray...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|gray
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"gray channel"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal gray...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"gray channel"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|IFDBG
name|printf
argument_list|(
literal|"        Grabando canal indexed...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|posLongChannel
index|[
name|i
index|]
index|[
name|nCanal
operator|++
index|]
argument_list|,
literal|"indexed channel"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|posActual
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Posicion del fin de fichero */
comment|/* Graba la longitud real de: Seccion Layer info */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posLayerInfo
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|posActual
operator|-
name|posLayerInfo
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n      Longitud total de layers info section: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|posActual
operator|-
name|posLayerInfo
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Graba la longitud real de: Seccion Layer and mask information  */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posLayerMask
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|posActual
operator|-
name|posLayerMask
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"layers& mask information length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Longitud total de layers& mask information: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|posActual
operator|-
name|posLayerMask
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Vuelve al final de fichero para continuar con la grabacion */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posActual
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|save_data (FILE * fd,gint32 image_id)
specifier|static
name|void
name|save_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|nCanales
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nCanal
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
comment|/* Offset x de cada capa */
name|gint
name|offset_y
decl_stmt|;
comment|/* Offset y de cada capa*/
name|gint32
name|layerHeight
decl_stmt|;
comment|/* Altura de cada capa */
name|gint32
name|layerWidth
decl_stmt|;
comment|/* Anchura de cada capa*/
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpPixelRgn
name|region
decl_stmt|;
comment|/* Region de la imagen */
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* Bytes que componen un layer con todos sus canales */
name|guchar
modifier|*
name|red
decl_stmt|;
comment|/* Bytes que componen un canal R */
name|guchar
modifier|*
name|green
decl_stmt|;
comment|/* Bytes que componen un canal G */
name|guchar
modifier|*
name|blue
decl_stmt|;
comment|/* Bytes que componen un canal B */
name|guchar
modifier|*
name|gray_indexed
init|=
name|NULL
decl_stmt|;
comment|/* Bytes que componen un canal B */
name|gint32
name|longCanal
decl_stmt|;
comment|/* Longitud de los datos de un canal */
name|gint
name|nChannelsLayer
decl_stmt|;
comment|/* Numero de canales de una capa */
name|gshort
modifier|*
modifier|*
name|TLdataCompress
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|dataCompress
decl_stmt|;
name|glong
modifier|*
name|longDataCompress
decl_stmt|;
name|glong
name|longTotal
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n Funcion: save_data\n"
argument_list|)
decl_stmt|;
name|nCanales
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|+
name|nCanalesLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TLdataCompress
operator|=
name|g_new
argument_list|(
name|gshort
operator|*
argument_list|,
name|nCanales
argument_list|)
expr_stmt|;
name|dataCompress
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|nCanales
argument_list|)
expr_stmt|;
name|longDataCompress
operator|=
name|g_new
argument_list|(
name|glong
argument_list|,
name|nCanales
argument_list|)
expr_stmt|;
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
expr_stmt|;
comment|/* Canal a grabar */
name|IFDBG
name|printf
argument_list|(
literal|"     Procesando capa %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|layerHeight
operator|=
name|gimp_drawable_height
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|layerWidth
operator|=
name|gimp_drawable_width
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|longCanal
operator|=
name|layerWidth
operator|*
name|layerHeight
expr_stmt|;
name|nChannelsLayer
operator|=
name|nCanalesLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|longCanal
operator|*
name|nChannelsLayer
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|)
expr_stmt|;
name|nCanal
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|RGB_to_chans
argument_list|(
name|data
argument_list|,
name|longCanal
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|red
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|longDataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Longitud comprimida canal rojo: %ld\n"
argument_list|,
name|longDataCompress
index|[
name|nCanal
index|]
argument_list|)
decl_stmt|;
name|nCanal
operator|++
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|green
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|longDataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Longitud comprimida canal verde: %ld\n"
argument_list|,
name|longDataCompress
index|[
name|nCanal
index|]
argument_list|)
decl_stmt|;
name|nCanal
operator|++
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|blue
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|longDataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Longitud comprimida canal azul: %ld\n"
argument_list|,
name|longDataCompress
index|[
name|nCanal
index|]
argument_list|)
decl_stmt|;
name|nCanal
operator|++
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|gray_indexed
operator|=
name|data
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|gray_indexed
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|longDataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Longitud comprimida canal gray o indexed: %ld\n"
argument_list|,
name|longDataCompress
index|[
name|nCanal
index|]
argument_list|)
decl_stmt|;
name|nCanal
operator|++
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|longCanal
operator|=
name|PSDImageData
operator|.
name|image_width
operator|*
name|PSDImageData
operator|.
name|image_height
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|data
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|,
operator|&
operator|(
name|longDataCompress
index|[
name|nCanal
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"     Longitud comprimida canal usuario: %ld\n"
argument_list|,
name|longDataCompress
index|[
name|nCanal
index|]
argument_list|)
decl_stmt|;
name|nCanal
operator|++
expr_stmt|;
block|}
comment|/* Calculo la longitud de todos los canales comprimidos */
name|longTotal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCanales
condition|;
name|i
operator|++
control|)
name|longTotal
operator|+=
name|longDataCompress
index|[
name|i
index|]
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n     Longitud total de datos comprimidos: %ld\n"
argument_list|,
name|longTotal
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"     Longitud total de datos en crudo: %d\n"
argument_list|,
name|nCanales
operator|*
name|longCanal
argument_list|)
decl_stmt|;
comment|/* Decido si grabo los datos comprimidos o crudos */
if|if
condition|(
name|longTotal
operator|<
name|nCanales
operator|*
name|longCanal
condition|)
comment|/* Grabo comprimidos */
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\n     Grabando los datos comprimidos\n"
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"RLE compression"
argument_list|)
expr_stmt|;
comment|/* Se graban primero todas las longitudes de linea */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCanales
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|layerHeight
condition|;
name|j
operator|++
control|)
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|TLdataCompress
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|"line lengths"
argument_list|)
expr_stmt|;
comment|/* Y ahora los datos comprimidos */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCanales
condition|;
name|i
operator|++
control|)
block|{
name|longTotal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|layerHeight
condition|;
name|j
operator|++
control|)
name|longTotal
operator|+=
name|TLdataCompress
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|dataCompress
index|[
name|i
index|]
argument_list|,
name|longTotal
argument_list|,
literal|"channel data"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Grabo crudos */
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\n     Grabando los datos en crudo\n"
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"RLE compression"
argument_list|)
expr_stmt|;
comment|/* Los canales de la capa a grabar ya los tengo de antes */
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|red
argument_list|,
name|longCanal
argument_list|,
literal|"red channel data"
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|green
argument_list|,
name|longCanal
argument_list|,
literal|"green channel data"
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|blue
argument_list|,
name|longCanal
argument_list|,
literal|"blue channel data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|gray_indexed
argument_list|,
name|longCanal
argument_list|,
literal|"gray or indexed channel data"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Y ahora voy a por los canales de usuario */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|longCanal
argument_list|,
literal|"channel data"
argument_list|)
expr_stmt|;
block|}
comment|/* ¡¡¡ y... YATAAAAA !!!  (¿Como?,¿Yataaa?) */
block|}
block|}
end_function

begin_function
DECL|function|get_image_data (FILE * fd,gint32 image_id)
specifier|static
name|void
name|get_image_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: get_image_data\n"
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|compression
operator|=
literal|0
expr_stmt|;
comment|/* No hay compresion */
name|PSDImageData
operator|.
name|image_height
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Obtenido numero de filas: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|image_width
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Obtenido numero de columnas: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|baseType
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Obtenido tipo base: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|baseType
argument_list|)
decl_stmt|;
comment|/* El formato PSD no permite imagenes indexadas con capas */
if|if
condition|(
name|PSDImageData
operator|.
name|baseType
operator|==
name|GIMP_INDEXED_IMAGE
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      Realizo el flatten de la imagen indexada\n"
argument_list|)
decl_stmt|;
name|gimp_image_flatten
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
block|}
name|PSDImageData
operator|.
name|lChannels
operator|=
name|gimp_image_get_channels
argument_list|(
name|image_id
argument_list|,
operator|&
name|PSDImageData
operator|.
name|nChannels
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Obtenido numero de canales: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nChannels
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|lLayers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Obtenido numero de capas: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|layersDim
operator|=
name|g_new
argument_list|(
name|PSD_Layer_Dimension
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|save_image (gchar * filename,gint32 image_id)
name|int
name|save_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|gchar
modifier|*
name|name_buf
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Funcion: save_image\n"
argument_list|)
decl_stmt|;
name|name_buf
operator|=
name|g_malloc
argument_list|(
literal|64
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
name|name_buf
argument_list|,
literal|"Saving %s:"
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Se ha puesto el mensaje en GIMP\n"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"PSD Save: no pudo abrir \"%s\"\n"
argument_list|,
name|filename
argument_list|)
decl_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|IFDBG
name|printf
argument_list|(
literal|"      Se ha abierto el fichero \"%s\"\n"
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|get_image_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_header
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_color_mode_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_resources
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
comment|/* El formato PSD no permite imagenes indexadas con capas */
if|if
condition|(
name|PSDImageData
operator|.
name|baseType
operator|==
name|GIMP_INDEXED_IMAGE
condition|)
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
else|else
name|save_layerAndMask
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
comment|/* Si es una indexada, aqui irá la información de la capa y los canales */
name|save_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

