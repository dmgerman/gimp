begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PSD Save Plugin version 1.0 (BETA)  * This GIMP plug-in is designed to save Adobe Photoshop(tm) files (.PSD)  *  * Monigotes  *  *     If this plug-in fails to save a file which you think it should,  *     please tell me what seemed to go wrong, and anything you know  *     about the image you tried to save.  Please don't send big PSD  *     files to me without asking first.  *  *          Copyright (C) 2000 Monigotes  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Adobe and Adobe Photoshop are trademarks of Adobe Systems  * Incorporated that may be registered in certain jurisdictions.  */
end_comment

begin_comment
comment|/*  * Revision history:  *  *  2000.02 / v1.0 / Monigotes  *       First version.  *  *  2003-05-10  Pedro Gimeno<pggimeno@wanadoo.es>  *       - Cleaned up and GNUstylized.  *       - Translated all comments and vars in Spanish to English.  *  *  2005-2-11 Jay Cox<jaycox@gimp.org>  *       Rewrote all the code that deals with pixels to be stingy with  *       memory and opperate on tile-size chunks.  Create a flattened  *       copy of the image when necessary. Fixes file corruption bug  *       #167139 and memory bug #121871  *  *  2006-03-29 Guillermo S. Romero<gsr.bugs@infernal-iceberg.com>  *       - Added/enabled basic support for layer masks based in psd.c  *         and whatever was already here.  *         Layers that are not canvas sized need investigation, here  *         or in the import plugin something seems wrong.  *       - Cosmetic changes about the debug messages, more like psd.c.  */
end_comment

begin_comment
comment|/*  * TODO:  *       Save preview  */
end_comment

begin_comment
comment|/*  * BUGS:  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* *** DEFINES *** */
end_comment

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-psd-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"psd_save"
end_define

begin_comment
comment|/* set to TRUE if you want debugging, FALSE otherwise */
end_comment

begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|FALSE
end_define

begin_comment
comment|/* 1: Normal debuggin, 2: Deep debuggin */
end_comment

begin_define
DECL|macro|DEBUG_LEVEL
define|#
directive|define
name|DEBUG_LEVEL
value|1
end_define

begin_define
DECL|macro|IFDBG
define|#
directive|define
name|IFDBG
value|if (DEBUG)
end_define

begin_define
DECL|macro|IF_DEEP_DBG
define|#
directive|define
name|IF_DEEP_DBG
value|if (DEBUG&& DEBUG_LEVEL == 2)
end_define

begin_define
DECL|macro|PSD_UNIT_INCH
define|#
directive|define
name|PSD_UNIT_INCH
value|1
end_define

begin_define
DECL|macro|PSD_UNIT_CM
define|#
directive|define
name|PSD_UNIT_CM
value|2
end_define

begin_comment
comment|/* *** END OF DEFINES *** */
end_comment

begin_comment
comment|/* Local types etc  */
end_comment

begin_typedef
DECL|struct|PsdLayerDimension
typedef|typedef
struct|struct
name|PsdLayerDimension
block|{
DECL|member|left
name|gint
name|left
decl_stmt|;
DECL|member|top
name|gint
name|top
decl_stmt|;
DECL|member|width
name|gint32
name|width
decl_stmt|;
DECL|member|height
name|gint32
name|height
decl_stmt|;
DECL|typedef|PSD_Layer_Dimension
block|}
name|PSD_Layer_Dimension
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdImageData
typedef|typedef
struct|struct
name|PsdImageData
block|{
DECL|member|compression
name|gboolean
name|compression
decl_stmt|;
DECL|member|image_height
name|gint32
name|image_height
decl_stmt|;
DECL|member|image_width
name|gint32
name|image_width
decl_stmt|;
DECL|member|baseType
name|GimpImageBaseType
name|baseType
decl_stmt|;
DECL|member|nChannels
name|gint
name|nChannels
decl_stmt|;
comment|/* Number of user channels in the image */
DECL|member|lChannels
name|gint32
modifier|*
name|lChannels
decl_stmt|;
comment|/* User channels in the image */
DECL|member|nLayers
name|gint
name|nLayers
decl_stmt|;
comment|/* Number of layers in the image */
DECL|member|lLayers
name|gint32
modifier|*
name|lLayers
decl_stmt|;
comment|/* Identifier of each layer */
DECL|member|layersDim
name|PSD_Layer_Dimension
modifier|*
name|layersDim
decl_stmt|;
comment|/* Dimensions of each layer */
DECL|typedef|PSD_Image_Data
block|}
name|PSD_Image_Data
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|PSDImageData
specifier|static
name|PSD_Image_Data
name|PSDImageData
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psd_lmode_layer
parameter_list|(
name|gint32
name|idLayer
parameter_list|,
name|gchar
modifier|*
name|psdMode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reshuffle_cmap_write
parameter_list|(
name|guchar
modifier|*
name|mapGimp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_header
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_color_mode_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfwrite
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_pascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gint
name|padding
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_string
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gint16
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint16
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gint32
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_pixel_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|drawableID
parameter_list|,
name|gint32
modifier|*
name|ChanLenPosition
parameter_list|,
name|gint32
name|rowlenOffset
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"compression"
block|,
literal|"Compression type: { NONE (0), LZW (1), PACKBITS (2)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"fill-order"
block|,
literal|"Fill Order: { MSB to LSB (0), LSB to MSB (1)"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"saves files in the Photoshop(tm) PSD file format"
argument_list|,
literal|"This filter saves files of Adobe Photoshop(tm) native PSD format.  These files may be of any image type supported by GIMP, with or without layers, layer masks, aux channels and guides."
argument_list|,
literal|"Monigotes"
argument_list|,
literal|"Monigotes"
argument_list|,
literal|"2000"
argument_list|,
name|N_
argument_list|(
literal|"Photoshop image"
argument_list|)
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"image/x-psd"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"psd"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gint32
name|image_id
decl_stmt|;
name|gint32
name|drawable_id
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_IGNORE
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n---------------- %s ----------------\n"
argument_list|,
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
decl_stmt|;
name|image_id
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_id
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_id
argument_list|,
operator|&
name|drawable_id
argument_list|,
literal|"PSD"
argument_list|,
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator||
name|GIMP_EXPORT_CAN_HANDLE_LAYERS
operator||
name|GIMP_EXPORT_CAN_HANDLE_LAYER_MASKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_id
argument_list|)
condition|)
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
else|else
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|psd_lmode_layer (gint32 idLayer,gchar * psdMode)
name|psd_lmode_layer
parameter_list|(
name|gint32
name|idLayer
parameter_list|,
name|gchar
modifier|*
name|psdMode
parameter_list|)
block|{
switch|switch
condition|(
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
condition|)
block|{
case|case
name|GIMP_NORMAL_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DARKEN_ONLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"dark"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LIGHTEN_ONLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"lite"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_HUE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"hue "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_SATURATION_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"sat "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"colr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_MULTIPLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"mul "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_SCREEN_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"scrn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DISSOLVE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"diss"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DIFFERENCE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"diff"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_VALUE_MODE
case|:
comment|/* ? */
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"lum "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_OVERLAY_MODE
case|:
comment|/* ? */
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"over"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_ADDITION_MODE
case|:
case|case
name|GIMP_SUBTRACT_MODE
case|:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to save layer with mode '%c'. The psd file format does not support that, using normal mode instead."
argument_list|)
argument_list|,
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"PSD: Warning - unsupported layer-blend mode: %c, using 'norm' mode\n"
argument_list|,
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to save layer with UNKNOWN mode. Using normal mode as fallback."
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"PSD: Warning - UNKNOWN layer-blend mode, reverting to 'norm'\n"
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_string (FILE * fd,char * val,gchar * why)
name|write_string
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_pascalstring (FILE * fd,char * val,gint padding,gchar * why)
name|write_pascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gint
name|padding
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|len
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Calculate string length to write and limit it to 255 */
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|>
literal|255
operator|)
condition|?
literal|255
else|:
operator|(
name|unsigned
name|char
operator|)
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Perform actual writing */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|val
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
else|else
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* If total length (length byte + content) is not a multiple of PADDING,      add zeros to pad it.  */
name|len
operator|++
expr_stmt|;
comment|/* Add the length field */
if|if
condition|(
operator|(
name|len
operator|%
name|padding
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|padding
operator|-
operator|(
name|len
operator|%
name|padding
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfwrite (FILE * fd,void * buf,long len,gchar * why)
name|xfwrite
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: xfwrite: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_gchar (FILE * fd,guchar val,gchar * why)
name|write_gchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|gint32
name|pos
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_gchar: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fd
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_gint16 (FILE * fd,gint16 val,gchar * why)
name|write_gint16
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint16
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
comment|/*  b[0] = val& 255;       b[1] = (val>> 8)& 255;*/
name|b
index|[
literal|1
index|]
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_gint16: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_gint32 (FILE * fd,gint32 val,gchar * why)
name|write_gint32
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|b
index|[
literal|3
index|]
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_gint32: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|pack_pb_line (guchar * start,gint32 length,gint32 stride,guchar * dest_ptr)
name|pack_pb_line
parameter_list|(
name|guchar
modifier|*
name|start
parameter_list|,
name|gint32
name|length
parameter_list|,
name|gint32
name|stride
parameter_list|,
name|guchar
modifier|*
name|dest_ptr
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint32
name|remaining
decl_stmt|;
name|remaining
operator|=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
comment|/* Look for characters matching the first */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|128
operator|)
operator|&&
operator|(
name|remaining
operator|-
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|start
index|[
literal|0
index|]
operator|==
name|start
index|[
name|i
operator|*
name|stride
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
comment|/* Match found */
block|{
operator|*
name|dest_ptr
operator|++
operator|=
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|dest_ptr
operator|++
operator|=
operator|*
name|start
expr_stmt|;
name|start
operator|+=
name|i
operator|*
name|stride
expr_stmt|;
name|remaining
operator|-=
name|i
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* Look for characters different from the previous */
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|128
operator|)
operator|&&
operator|(
name|remaining
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|start
index|[
name|i
operator|*
name|stride
index|]
operator|!=
name|start
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|stride
index|]
operator|||
name|remaining
operator|-
operator|(
name|i
operator|+
literal|2
operator|)
operator|<=
literal|0
operator|||
name|start
index|[
name|i
operator|*
name|stride
index|]
operator|!=
name|start
index|[
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
name|stride
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* If there's only 1 remaining, the previous WHILE stmt doesn't              catch it */
if|if
condition|(
name|remaining
operator|==
literal|1
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* Some distinct ones found */
block|{
operator|*
name|dest_ptr
operator|++
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dest_ptr
operator|++
operator|=
name|start
index|[
name|j
operator|*
name|stride
index|]
expr_stmt|;
block|}
name|start
operator|+=
name|i
operator|*
name|stride
expr_stmt|;
name|remaining
operator|-=
name|i
expr_stmt|;
name|length
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimpBaseTypeToPsdMode (GimpImageBaseType gimpBaseType)
name|gimpBaseTypeToPsdMode
parameter_list|(
name|GimpImageBaseType
name|gimpBaseType
parameter_list|)
block|{
switch|switch
condition|(
name|gimpBaseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
literal|3
return|;
comment|/* RGB */
case|case
name|GIMP_GRAY
case|:
return|return
literal|1
return|;
comment|/* Grayscale */
case|case
name|GIMP_INDEXED
case|:
return|return
literal|2
return|;
comment|/* Indexed */
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Error: Can't convert GIMP base imagetype to PSD mode"
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"PSD Save: gimpBaseType value is %d, can't convert to PSD mode"
argument_list|,
name|gimpBaseType
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
literal|3
return|;
comment|/* Return RGB by default */
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|nChansLayer (gint gimpBaseType,gint hasAlpha,gint hasMask)
name|nChansLayer
parameter_list|(
name|gint
name|gimpBaseType
parameter_list|,
name|gint
name|hasAlpha
parameter_list|,
name|gint
name|hasMask
parameter_list|)
block|{
name|gint
name|incAlpha
init|=
literal|0
decl_stmt|;
name|gint
name|incMask
init|=
literal|0
decl_stmt|;
name|incAlpha
operator|=
operator|(
name|hasAlpha
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|incMask
operator|=
operator|(
name|hasMask
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
switch|switch
condition|(
name|gimpBaseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
literal|3
operator|+
name|incAlpha
operator|+
name|incMask
return|;
comment|/* R,G,B& Alpha& Mask (if any) */
case|case
name|GIMP_GRAY
case|:
return|return
literal|1
operator|+
name|incAlpha
operator|+
name|incMask
return|;
comment|/* G& Alpha& Mask (if any) */
case|case
name|GIMP_INDEXED
case|:
return|return
literal|1
operator|+
name|incAlpha
operator|+
name|incMask
return|;
comment|/* I& Alpha& Mask (if any) */
default|default:
return|return
literal|0
return|;
comment|/* Return 0 channels by default */
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|reshuffle_cmap_write (guchar * mapGimp)
name|reshuffle_cmap_write
parameter_list|(
name|guchar
modifier|*
name|mapGimp
parameter_list|)
block|{
name|guchar
modifier|*
name|mapPSD
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|mapPSD
operator|=
name|g_malloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|mapPSD
index|[
name|i
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
name|mapPSD
index|[
name|i
operator|+
literal|256
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|mapPSD
index|[
name|i
operator|+
literal|512
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
block|{
name|mapGimp
index|[
name|i
index|]
operator|=
name|mapPSD
index|[
name|i
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|mapPSD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_header (FILE * fd,gint32 image_id)
name|save_header
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_header\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tRows: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tColumns: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tBase type: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|baseType
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tNumber of channels: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nChannels
argument_list|)
decl_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|,
literal|"signature"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"reserved 1"
argument_list|)
expr_stmt|;
comment|/* 6 for the 'reserved' field + 4 bytes for a long */
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"reserved 1"
argument_list|)
expr_stmt|;
comment|/* and 2 bytes for a short */
name|write_gint16
argument_list|(
name|fd
argument_list|,
operator|(
name|PSDImageData
operator|.
name|nChannels
operator|+
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|,
literal|"channels"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
literal|"columns"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|8
argument_list|,
literal|"depth"
argument_list|)
expr_stmt|;
comment|/* Apparently GIMP only supports 8 bit deep                                      PSD images.  */
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|gimpBaseTypeToPsdMode
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|)
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_color_mode_data (FILE * fd,gint32 image_id)
name|save_color_mode_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|guchar
modifier|*
name|cmap_modified
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint32
name|nColors
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_color_mode_data\n"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_INDEXED
case|:
name|IFDBG
name|printf
argument_list|(
literal|"\tImage type: INDEXED\n"
argument_list|)
decl_stmt|;
name|cmap
operator|=
name|gimp_image_get_colormap
argument_list|(
name|image_id
argument_list|,
operator|&
name|nColors
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLength of colormap returned by gimp_image_get_colormap: %d\n"
argument_list|,
name|nColors
argument_list|)
decl_stmt|;
if|if
condition|(
name|nColors
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tThe indexed image lacks a colormap\n"
argument_list|)
decl_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nColors
operator|!=
literal|256
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tThe indexed image has %d!=256 colors\n"
argument_list|,
name|nColors
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tPadding with zeros up to 256\n"
argument_list|)
decl_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|768
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
comment|/* For this type, length is always 768 */
name|cmap_modified
operator|=
name|g_malloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nColors
operator|*
literal|3
condition|;
name|i
operator|++
control|)
name|cmap_modified
index|[
name|i
index|]
operator|=
name|cmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nColors
operator|*
literal|3
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
name|cmap_modified
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reshuffle_cmap_write
argument_list|(
name|cmap_modified
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|cmap_modified
argument_list|,
literal|768
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
comment|/* Write readjusted colormap */
name|g_free
argument_list|(
name|cmap_modified
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* nColors equals 256 */
block|{
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|768
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
comment|/* For this type, length is always 768 */
name|reshuffle_cmap_write
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|cmap
argument_list|,
literal|768
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
comment|/* Write readjusted colormap */
block|}
break|break;
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"\tImage type: Not INDEXED\n"
argument_list|)
decl_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_resources (FILE * fd,gint32 image_id)
name|save_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gchar
modifier|*
name|fileName
decl_stmt|;
comment|/* Image file name */
name|gint32
name|idActLayer
decl_stmt|;
comment|/* Id of the active layer */
name|guint
name|nActiveLayer
init|=
literal|0
decl_stmt|;
comment|/* Number of the active layer */
name|gboolean
name|ActiveLayerPresent
decl_stmt|;
comment|/* TRUE if there's an active layer */
name|gint32
name|eof_pos
decl_stmt|;
comment|/* Position for End of file */
name|gint32
name|rsc_pos
decl_stmt|;
comment|/* Position for Lengths of Resources section */
name|gint32
name|name_sec
decl_stmt|;
comment|/* Position for Lengths of Channel Names */
comment|/* Only relevant resources in GIMP are: 0x03EE, 0x03F0& 0x0400 */
comment|/* For Adobe Photoshop version 4.0 these can also be considered:      0x0408, 0x040A& 0x040B */
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_resources\n"
argument_list|)
decl_stmt|;
comment|/* Get the image title from its filename */
name|fileName
operator|=
name|gimp_image_get_filename
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tImage title: %s\n"
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
comment|/* Get the active layer number id */
name|idActLayer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tCurrent layer id: %d\n"
argument_list|,
name|idActLayer
argument_list|)
decl_stmt|;
name|ActiveLayerPresent
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDImageData
operator|.
name|nLayers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idActLayer
operator|==
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
condition|)
block|{
name|nActiveLayer
operator|=
name|i
expr_stmt|;
name|ActiveLayerPresent
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ActiveLayerPresent
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tActive layer is number %d\n"
argument_list|,
name|nActiveLayer
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tNo active layer\n"
argument_list|)
decl_stmt|;
block|}
comment|/* Here's where actual writing starts */
name|rsc_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"image resources length"
argument_list|)
expr_stmt|;
comment|/* --------------- Write Channel names --------------- */
if|if
condition|(
name|PSDImageData
operator|.
name|nChannels
operator|>
literal|0
condition|)
block|{
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0x03EE
argument_list|,
literal|"0x03EE Id"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring (fd, Name, "Id name"); */
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Set to null string (two zeros) */
comment|/* Mark current position in the file */
name|name_sec
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"0x03EE resource size"
argument_list|)
expr_stmt|;
comment|/* Write all strings */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|chName
init|=
name|gimp_drawable_get_name
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|write_string
argument_list|(
name|fd
argument_list|,
name|chName
argument_list|,
literal|"channel name"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|chName
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate and write actual resource's length */
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|name_sec
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|name_sec
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|,
literal|"0x03EE resource size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tTotal length of 0x03EE resource: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|name_sec
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Pad if length is odd */
if|if
condition|(
operator|(
name|eof_pos
operator|-
name|name_sec
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
operator|)
operator|&
literal|1
condition|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"pad byte"
argument_list|)
expr_stmt|;
block|}
comment|/* --------------- Write Guides --------------- */
if|if
condition|(
name|gimp_image_find_next_guide
argument_list|(
name|image_id
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gint
name|n_guides
init|=
literal|0
decl_stmt|;
name|gint
name|guide_id
init|=
literal|0
decl_stmt|;
comment|/* Count the guides */
while|while
condition|(
operator|(
name|guide_id
operator|=
name|gimp_image_find_next_guide
argument_list|(
name|image_id
argument_list|,
name|guide_id
argument_list|)
operator|)
condition|)
name|n_guides
operator|++
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0x0408
argument_list|,
literal|"0x0408 Id (Guides)"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring (fd, Name, "Id name"); */
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Set to null string (two zeros) */
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|16
operator|+
literal|5
operator|*
name|n_guides
argument_list|,
literal|"0x0408 resource size"
argument_list|)
expr_stmt|;
comment|/* Save grid and guide header */
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"grid/guide header version"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|576
argument_list|,
literal|"grid custom spacing horizontal"
argument_list|)
expr_stmt|;
comment|/* dpi*32/4??*/
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|576
argument_list|,
literal|"grid custom spacing vertical"
argument_list|)
expr_stmt|;
comment|/* dpi*32/4??*/
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|n_guides
argument_list|,
literal|"number of guides"
argument_list|)
expr_stmt|;
comment|/* write the guides */
while|while
condition|(
operator|(
name|guide_id
operator|=
name|gimp_image_find_next_guide
argument_list|(
name|image_id
argument_list|,
name|guide_id
argument_list|)
operator|)
condition|)
block|{
name|gchar
name|orientation
decl_stmt|;
name|gint32
name|position
decl_stmt|;
name|orientation
operator|=
name|gimp_image_get_guide_orientation
argument_list|(
name|image_id
argument_list|,
name|guide_id
argument_list|)
expr_stmt|;
name|position
operator|=
literal|32
operator|*
name|gimp_image_get_guide_position
argument_list|(
name|image_id
argument_list|,
name|guide_id
argument_list|)
expr_stmt|;
name|orientation
operator|^=
literal|1
expr_stmt|;
comment|/* in the psd vert =0 , horiz = 1 */
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|position
argument_list|,
literal|"Position of guide"
argument_list|)
expr_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|orientation
argument_list|,
literal|"Orientation of guide"
argument_list|)
expr_stmt|;
name|n_guides
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ftell
argument_list|(
name|fd
argument_list|)
operator|&
literal|1
operator|)
condition|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"pad byte"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_guides
operator|!=
literal|0
condition|)
name|g_warning
argument_list|(
literal|"Screwed up guide resource:: wrong number of guides\n"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tTotal length of 0x0400 resource: %d\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
argument_list|)
decl_stmt|;
block|}
comment|/* --------------- Write resolution data ------------------- */
block|{
name|gdouble
name|xres
init|=
literal|0
decl_stmt|,
name|yres
init|=
literal|0
decl_stmt|;
name|guint32
name|xres_fix
decl_stmt|,
name|yres_fix
decl_stmt|;
name|GimpUnit
name|g_unit
decl_stmt|;
name|gint16
name|psd_unit
decl_stmt|;
name|g_unit
operator|=
name|gimp_image_get_unit
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|gimp_image_get_resolution
argument_list|(
name|image_id
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_unit
operator|==
name|GIMP_UNIT_MM
condition|)
block|{
name|gdouble
name|factor
init|=
name|gimp_unit_get_factor
argument_list|(
name|g_unit
argument_list|)
operator|/
literal|10.0
decl_stmt|;
name|xres
operator|/=
name|factor
expr_stmt|;
name|yres
operator|/=
name|factor
expr_stmt|;
name|psd_unit
operator|=
name|PSD_UNIT_CM
expr_stmt|;
block|}
else|else
block|{
name|psd_unit
operator|=
name|PSD_UNIT_INCH
expr_stmt|;
block|}
name|xres_fix
operator|=
name|xres
operator|*
literal|65536.0
operator|+
literal|.5
expr_stmt|;
comment|/* Convert to 16.16 fixed point */
name|yres_fix
operator|=
name|yres
operator|*
literal|65536.0
operator|+
literal|.5
expr_stmt|;
comment|/* Convert to 16.16 fixed point */
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature (for resolution)"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0x03ed
argument_list|,
literal|"0x03ed Id (resolution)"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Set to null string (two zeros) */
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|16
argument_list|,
literal|"0x0400 resource size"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|xres_fix
argument_list|,
literal|"hRes (16.16 fixed point)"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|psd_unit
argument_list|,
literal|"hRes unit"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|psd_unit
argument_list|,
literal|"width unit"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|yres_fix
argument_list|,
literal|"vRes (16.16 fixed point)"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|psd_unit
argument_list|,
literal|"vRes unit"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|psd_unit
argument_list|,
literal|"height unit"
argument_list|)
expr_stmt|;
block|}
comment|/* --------------- Write Active Layer Number --------------- */
if|if
condition|(
name|ActiveLayerPresent
condition|)
block|{
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0x0400
argument_list|,
literal|"0x0400 Id"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring (fd, Name, "Id name"); */
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Set to null string (two zeros) */
name|write_gint32
argument_list|(
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
argument_list|,
literal|"0x0400 resource size"
argument_list|)
expr_stmt|;
comment|/* Save title as gint16 (length always even) */
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|nActiveLayer
argument_list|,
literal|"active layer"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tTotal length of 0x0400 resource: %d\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
argument_list|)
decl_stmt|;
block|}
comment|/* --------------- Write Total Section Length --------------- */
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|rsc_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|rsc_pos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|,
literal|"image resources length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tResource section total length: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|rsc_pos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|get_compress_channel_data (guchar * channel_data,gint32 channel_cols,gint32 channel_rows,gint32 stride,gint16 * LengthsTable,guchar * remdata)
name|get_compress_channel_data
parameter_list|(
name|guchar
modifier|*
name|channel_data
parameter_list|,
name|gint32
name|channel_cols
parameter_list|,
name|gint32
name|channel_rows
parameter_list|,
name|gint32
name|stride
parameter_list|,
name|gint16
modifier|*
name|LengthsTable
parameter_list|,
name|guchar
modifier|*
name|remdata
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint32
name|len
decl_stmt|;
comment|/* Length of compressed data */
name|guchar
modifier|*
name|start
decl_stmt|;
comment|/* Starting position of a row in channel_data */
name|gint32
name|channel_length
decl_stmt|;
comment|/* Total channel's length */
name|channel_length
operator|=
name|channel_cols
operator|*
name|channel_rows
expr_stmt|;
comment|/* For every row in the channel */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
block|{
name|start
operator|=
name|channel_data
operator|+
operator|(
name|i
operator|*
name|channel_cols
operator|*
name|stride
operator|)
expr_stmt|;
comment|/* Create packed data for this row */
name|LengthsTable
index|[
name|i
index|]
operator|=
name|pack_pb_line
argument_list|(
name|start
argument_list|,
name|channel_cols
argument_list|,
name|stride
argument_list|,
operator|&
name|remdata
index|[
name|len
index|]
argument_list|)
expr_stmt|;
name|len
operator|+=
name|LengthsTable
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/*  return((len + channel_rows * sizeof (gint16)) + sizeof (gint16));*/
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_layer_and_mask (FILE * fd,gint32 image_id)
name|save_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|idChannel
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
comment|/* X offset for each layer */
name|gint
name|offset_y
decl_stmt|;
comment|/* Y offset for each layer */
name|gint32
name|layerWidth
decl_stmt|;
comment|/* Width of each layer */
name|gint32
name|layerHeight
decl_stmt|;
comment|/* Height of each layer */
name|gchar
name|blendMode
index|[
literal|5
index|]
decl_stmt|;
comment|/* Blending mode of the layer */
name|guchar
name|layerOpacity
decl_stmt|;
comment|/* Opacity of the layer */
name|guchar
name|flags
decl_stmt|;
comment|/* Layer flags */
name|gint
name|nChannelsLayer
decl_stmt|;
comment|/* Number of channels of a layer */
name|gint32
name|ChanSize
decl_stmt|;
comment|/* Data length for a channel */
name|gchar
modifier|*
name|layerName
decl_stmt|;
comment|/* Layer name */
name|gint
name|mask
decl_stmt|;
comment|/* Layer mask */
name|gint32
name|eof_pos
decl_stmt|;
comment|/* Position: End of file */
name|gint32
name|ExtraDataPos
decl_stmt|;
comment|/* Position: Extra data length */
name|gint32
name|LayerMaskPos
decl_stmt|;
comment|/* Position: Layer& Mask section length */
name|gint32
name|LayerInfoPos
decl_stmt|;
comment|/* Position: Layer info section length*/
name|gint32
modifier|*
modifier|*
name|ChannelLengthPos
decl_stmt|;
comment|/* Position: Channel length */
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_layer_and_mask\n"
argument_list|)
decl_stmt|;
comment|/* Create first array dimension (layers, channels) */
name|ChannelLengthPos
operator|=
name|g_new
argument_list|(
name|gint32
operator|*
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
comment|/* Layer and mask information section */
name|LayerMaskPos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers& mask information length"
argument_list|)
expr_stmt|;
comment|/* Layer info section */
name|LayerInfoPos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
comment|/* Layer structure section */
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|,
literal|"Layer structure count"
argument_list|)
expr_stmt|;
comment|/* Layer records section */
comment|/* GIMP layers must be written in reverse order */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gint
name|hasMask
init|=
literal|0
decl_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|layerWidth
operator|=
name|gimp_drawable_width
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|layerHeight
operator|=
name|gimp_drawable_height
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
operator|=
name|offset_x
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
operator|=
name|offset_y
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|=
name|layerWidth
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|=
name|layerHeight
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tLayer number: %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tX offset: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tY offset: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tWidth: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tHeight: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|,
literal|"Layer top"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|,
literal|"Layer left"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|+
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
operator|)
argument_list|,
literal|"Layer bottom"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|+
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
operator|)
argument_list|,
literal|"Layer right"
argument_list|)
expr_stmt|;
name|hasMask
operator|=
operator|(
name|gimp_layer_get_mask
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|nChannelsLayer
operator|=
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|,
name|hasMask
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|nChannelsLayer
argument_list|,
literal|"Number channels in the layer"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tNumber of channels: %d\n"
argument_list|,
name|nChannelsLayer
argument_list|)
decl_stmt|;
comment|/* Create second array dimension (layers, channels) */
name|ChannelLengthPos
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|nChannelsLayer
argument_list|)
expr_stmt|;
comment|/* Try with gimp_drawable_bpp() */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nChannelsLayer
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|idChannel
operator|=
name|j
operator|-
literal|1
expr_stmt|;
else|else
name|idChannel
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|hasMask
operator|&&
operator|(
name|j
operator|+
literal|1
operator|==
name|nChannelsLayer
operator|)
condition|)
comment|/* Last channel ... */
name|idChannel
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* ... will be layer mask */
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|idChannel
argument_list|,
literal|"Channel ID"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tChannel Identifier: %d\n"
argument_list|,
name|idChannel
argument_list|)
decl_stmt|;
comment|/* Write the length assuming no compression.  In case there is,              will modify it later when writing data.  */
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ChanSize
operator|=
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
operator|+
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|*
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|ChanSize
argument_list|,
literal|"Channel Size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\t\tLength: %d\n"
argument_list|,
name|ChanSize
argument_list|)
decl_stmt|;
block|}
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"blend mode signature"
argument_list|)
expr_stmt|;
name|psd_lmode_layer
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
name|blendMode
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tBlend mode: %s\n"
argument_list|,
name|blendMode
argument_list|)
decl_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|blendMode
argument_list|,
literal|4
argument_list|,
literal|"blend mode key"
argument_list|)
expr_stmt|;
name|layerOpacity
operator|=
operator|(
name|gimp_layer_get_opacity
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
operator|*
literal|255.0
operator|)
operator|/
literal|100.0
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tOpacity: %u\n"
argument_list|,
name|layerOpacity
argument_list|)
decl_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|layerOpacity
argument_list|,
literal|"Opacity"
argument_list|)
expr_stmt|;
comment|/* Apparently this field is not used in GIMP */
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Clipping"
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gimp_layer_get_lock_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|flags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_drawable_get_visible
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|flags
operator||=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tFlags: %u\n"
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|flags
argument_list|,
literal|"Flags"
argument_list|)
expr_stmt|;
comment|/* Padding byte to make the length even */
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Filler"
argument_list|)
expr_stmt|;
name|ExtraDataPos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Position of Extra Data size */
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Extra data size"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|gimp_layer_get_mask
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|>=
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLayer mask size: %d\n"
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|20
argument_list|,
literal|"Layer mask size"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer mask top"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer mask left"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|gimp_drawable_height
argument_list|(
name|mask
argument_list|)
argument_list|,
literal|"Layer mask bottom"
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|gimp_drawable_width
argument_list|(
name|mask
argument_list|)
argument_list|,
literal|"Layer mask right"
argument_list|)
expr_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"lmask default color"
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
literal|1
operator||
comment|/* relative */
operator|(
name|gimp_layer_get_apply_mask
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
operator|<<
literal|1
operator|)
operator||
comment|/* disabled?*/
operator|(
literal|0
operator|<<
literal|2
operator|)
comment|/* invert   */
operator|)
expr_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|flags
argument_list|,
literal|"layer mask flags"
argument_list|)
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer mask Padding"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTE Writing empty Layer mask / adjustment layer data */
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer mask size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLayer mask size: %d\n"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
comment|/* NOTE Writing empty Layer blending ranges data */
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer blending size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLayer blending size: %d\n"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|layerName
operator|=
name|gimp_drawable_get_name
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write_pascalstring
argument_list|(
name|fd
argument_list|,
name|layerName
argument_list|,
literal|4
argument_list|,
literal|"layer name"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tLayer name: %s\n"
argument_list|,
name|layerName
argument_list|)
decl_stmt|;
comment|/* Write real length for: Extra data */
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|ExtraDataPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|ExtraDataPos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|,
literal|"Extra data size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tExtraData size: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|ExtraDataPos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
comment|/* Channel image data section */
comment|/* Gimp layers must be written in reverse order */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tWriting pixel data for layer slot %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|write_pixel_data
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Write actual size of Layer info section */
name|fseek
argument_list|(
name|fd
argument_list|,
name|LayerInfoPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|LayerInfoPos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tTotal layers info section length: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|LayerInfoPos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Write actual size of Layer and mask information secton */
name|fseek
argument_list|(
name|fd
argument_list|,
name|LayerMaskPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|LayerMaskPos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|,
literal|"layers& mask information length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tTotal layers& mask information length: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|LayerMaskPos
operator|-
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_pixel_data (FILE * fd,gint32 drawableID,gint32 * ChanLenPosition,gint32 ltable_offset)
name|write_pixel_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|drawableID
parameter_list|,
name|gint32
modifier|*
name|ChanLenPosition
parameter_list|,
name|gint32
name|ltable_offset
parameter_list|)
block|{
name|GimpPixelRgn
name|region
decl_stmt|;
comment|/* Image region */
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* Temporary copy of pixel data */
name|gint32
name|tile_height
init|=
name|gimp_tile_height
argument_list|()
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
init|=
name|gimp_drawable_get
argument_list|(
name|drawableID
argument_list|)
decl_stmt|;
name|gint32
name|maskID
init|=
name|gimp_layer_get_mask
argument_list|(
name|drawableID
argument_list|)
decl_stmt|;
name|gint32
name|height
init|=
name|drawable
operator|->
name|height
decl_stmt|;
name|gint32
name|width
init|=
name|drawable
operator|->
name|width
decl_stmt|;
name|gint32
name|bytes
init|=
name|drawable
operator|->
name|bpp
decl_stmt|;
name|gint32
name|colors
init|=
name|bytes
decl_stmt|;
comment|/* fixed up down below */
name|gint32
name|y
decl_stmt|;
name|gint32
name|len
decl_stmt|;
comment|/* Length of compressed data */
name|gint16
modifier|*
name|LengthsTable
decl_stmt|;
comment|/* Lengths of every compressed row */
name|guchar
modifier|*
name|rledata
decl_stmt|;
comment|/* Compressed data from a region */
name|gint32
name|length_table_pos
decl_stmt|;
comment|/* position in file of the length table */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_pixel_data, drw %d, lto %d\n"
argument_list|,
name|drawableID
argument_list|,
name|ltable_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawableID
argument_list|)
operator|&&
operator|!
name|gimp_drawable_is_indexed
argument_list|(
name|drawableID
argument_list|)
condition|)
name|colors
operator|-=
literal|1
expr_stmt|;
name|gimp_tile_cache_ntiles
argument_list|(
literal|2
operator|*
operator|(
name|drawable
operator|->
name|width
operator|/
name|gimp_tile_width
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|LengthsTable
operator|=
name|g_new
argument_list|(
name|gint16
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|rledata
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
operator|(
name|MIN
argument_list|(
name|height
argument_list|,
name|tile_height
argument_list|)
operator|*
operator|(
name|width
operator|+
literal|10
operator|+
operator|(
name|width
operator|/
literal|100
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|MIN
argument_list|(
name|height
argument_list|,
name|tile_height
argument_list|)
operator|*
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|chan
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|colors
condition|)
comment|/* Need to write alpha channel first */
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ltable_offset
operator|>
literal|0
condition|)
continue|continue;
name|chan
operator|=
name|bytes
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|chan
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|chan
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ChanLenPosition
condition|)
block|{
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"Compression type (RLE)"
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ltable_offset
operator|>
literal|0
condition|)
block|{
name|length_table_pos
operator|=
name|ltable_offset
operator|+
literal|2
operator|*
name|chan
operator|*
name|height
expr_stmt|;
block|}
else|else
block|{
name|length_table_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|LengthsTable
argument_list|,
name|height
operator|*
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
argument_list|,
literal|"Dummy RLE length"
argument_list|)
expr_stmt|;
name|len
operator|+=
name|height
operator|*
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. ltable, pos %d len %d\n"
argument_list|,
name|length_table_pos
argument_list|,
name|len
argument_list|)
decl_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|tile_height
control|)
block|{
name|int
name|tlen
decl_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|MIN
argument_list|(
name|height
operator|-
name|y
argument_list|,
name|tile_height
argument_list|)
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|get_compress_channel_data
argument_list|(
operator|&
name|data
index|[
name|chan
index|]
argument_list|,
name|width
argument_list|,
name|MIN
argument_list|(
name|height
operator|-
name|y
argument_list|,
name|tile_height
argument_list|)
argument_list|,
name|bytes
argument_list|,
operator|&
name|LengthsTable
index|[
name|y
index|]
argument_list|,
name|rledata
argument_list|)
expr_stmt|;
name|len
operator|+=
name|tlen
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|rledata
argument_list|,
name|tlen
argument_list|,
literal|"Compressed pixel data"
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. Writing compressed pixels, stream of %d\n"
argument_list|,
name|tlen
argument_list|)
decl_stmt|;
block|}
comment|/* Write compressed lengths table */
name|fseek
argument_list|(
name|fd
argument_list|,
name|length_table_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
name|j
operator|++
control|)
comment|/* write real length table */
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|LengthsTable
index|[
name|j
index|]
argument_list|,
literal|"RLE length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ChanLenPosition
condition|)
comment|/* Update total compressed length */
block|{
name|fseek
argument_list|(
name|fd
argument_list|,
name|ChanLenPosition
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|len
argument_list|,
literal|"channel data length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tUpdating data len to %d\n"
argument_list|,
name|len
argument_list|)
decl_stmt|;
block|}
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. Cur pos %ld\n"
argument_list|,
name|ftell
argument_list|(
name|fd
argument_list|)
argument_list|)
decl_stmt|;
block|}
comment|/* Write layer mask, as last channel, id -2 */
if|if
condition|(
name|maskID
operator|!=
operator|-
literal|1
condition|)
block|{
name|GimpDrawable
modifier|*
name|mdrawable
init|=
name|gimp_drawable_get
argument_list|(
name|maskID
argument_list|)
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|mdrawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ChanLenPosition
condition|)
block|{
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"Compression type (RLE)"
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. ChanLenPos, len %d\n"
argument_list|,
name|len
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|ltable_offset
operator|>
literal|0
condition|)
block|{
name|length_table_pos
operator|=
name|ltable_offset
operator|+
literal|2
operator|*
operator|(
name|bytes
operator|+
literal|1
operator|)
operator|*
name|height
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. ltable, pos %d\n"
argument_list|,
name|length_table_pos
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|length_table_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|LengthsTable
argument_list|,
name|height
operator|*
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
argument_list|,
literal|"Dummy RLE length"
argument_list|)
expr_stmt|;
name|len
operator|+=
name|height
operator|*
sizeof|sizeof
argument_list|(
name|gint16
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. ltable, pos %d len %d\n"
argument_list|,
name|length_table_pos
argument_list|,
name|len
argument_list|)
decl_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|tile_height
control|)
block|{
name|int
name|tlen
decl_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|MIN
argument_list|(
name|height
operator|-
name|y
argument_list|,
name|tile_height
argument_list|)
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|get_compress_channel_data
argument_list|(
operator|&
name|data
index|[
literal|0
index|]
argument_list|,
name|width
argument_list|,
name|MIN
argument_list|(
name|height
operator|-
name|y
argument_list|,
name|tile_height
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|LengthsTable
index|[
name|y
index|]
argument_list|,
name|rledata
argument_list|)
expr_stmt|;
name|len
operator|+=
name|tlen
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|rledata
argument_list|,
name|tlen
argument_list|,
literal|"Compressed mask data"
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. Writing compressed mask, stream of %d\n"
argument_list|,
name|tlen
argument_list|)
decl_stmt|;
block|}
comment|/* Write compressed lengths table */
name|fseek
argument_list|(
name|fd
argument_list|,
name|length_table_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/*POS WHERE???*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
name|j
operator|++
control|)
comment|/* write real length table */
block|{
name|write_gint16
argument_list|(
name|fd
argument_list|,
name|LengthsTable
index|[
name|j
index|]
argument_list|,
literal|"RLE length"
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. Updating RLE len %d\n"
argument_list|,
name|LengthsTable
index|[
name|j
index|]
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|ChanLenPosition
condition|)
comment|/* Update total compressed length */
block|{
name|fseek
argument_list|(
name|fd
argument_list|,
name|ChanLenPosition
index|[
name|bytes
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/*+bytes OR SOMETHING*/
name|write_gint32
argument_list|(
name|fd
argument_list|,
name|len
argument_list|,
literal|"channel data length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tUpdating data len to %d, at %ld\n"
argument_list|,
name|len
argument_list|,
name|ftell
argument_list|(
name|fd
argument_list|)
argument_list|)
decl_stmt|;
block|}
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\t\t\t\t. Cur pos %ld\n"
argument_list|,
name|ftell
argument_list|(
name|fd
argument_list|)
argument_list|)
decl_stmt|;
name|gimp_drawable_detach
argument_list|(
name|mdrawable
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|rledata
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|LengthsTable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_data (FILE * fd,gint32 image_id)
name|save_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|gint
name|ChanCount
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|nChannel
decl_stmt|;
name|gint32
name|imageHeight
decl_stmt|;
comment|/* Height of image */
name|gint32
name|offset
decl_stmt|;
comment|/* offset in file of rle lengths */
name|gint
name|chan
decl_stmt|;
name|gint32
name|bottom_layer
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_data\n"
argument_list|)
decl_stmt|;
name|ChanCount
operator|=
operator|(
name|PSDImageData
operator|.
name|nChannels
operator|+
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
expr_stmt|;
comment|/* Layers to be written */
name|IFDBG
name|printf
argument_list|(
literal|"\tProcessing %d layers\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|imageHeight
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|nChannel
operator|=
literal|0
expr_stmt|;
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"RLE compression"
argument_list|)
expr_stmt|;
comment|/* All line lengths go before the rle pixel data */
name|offset
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Offset in file of line lengths */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChanCount
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|imageHeight
condition|;
name|j
operator|++
control|)
name|write_gint16
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"junk line lengths"
argument_list|)
expr_stmt|;
name|bottom_layer
operator|=
name|PSDImageData
operator|.
name|lLayers
index|[
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|PSDImageData
operator|.
name|nLayers
operator|!=
literal|1
operator|||
name|gimp_drawable_width
argument_list|(
name|bottom_layer
argument_list|)
operator|!=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
operator|||
name|gimp_drawable_height
argument_list|(
name|bottom_layer
argument_list|)
operator|!=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
condition|)
block|{
name|gint32
name|flat_image
decl_stmt|;
name|gint32
name|flat_drawable
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tCreating flattened image\n"
argument_list|)
decl_stmt|;
name|flat_image
operator|=
name|gimp_image_duplicate
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|gimp_image_undo_disable
argument_list|(
name|flat_image
argument_list|)
expr_stmt|;
name|flat_drawable
operator|=
name|gimp_image_flatten
argument_list|(
name|flat_image
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\t\tWriting compressed flattened image data\n"
argument_list|)
decl_stmt|;
name|write_pixel_data
argument_list|(
name|fd
argument_list|,
name|flat_drawable
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|gimp_image_delete
argument_list|(
name|flat_image
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tWriting compressed image data\n"
argument_list|)
decl_stmt|;
name|write_pixel_data
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|lLayers
index|[
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\t\tWriting compressed channel data for channel %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|write_pixel_data
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|offset
operator|+
literal|2
operator|*
name|imageHeight
operator|*
name|chan
argument_list|)
expr_stmt|;
name|chan
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_image_data (FILE * fd,gint32 image_id)
name|get_image_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: get_image_data\n"
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|compression
operator|=
name|FALSE
expr_stmt|;
name|PSDImageData
operator|.
name|image_height
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tGot number of rows: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|image_width
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tGot number of cols: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|baseType
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tGot base type: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|baseType
argument_list|)
decl_stmt|;
comment|/* PSD format does not support indexed layered images */
if|if
condition|(
name|PSDImageData
operator|.
name|baseType
operator|==
name|GIMP_INDEXED
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\tFlattening indexed image\n"
argument_list|)
decl_stmt|;
name|gimp_image_flatten
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
block|}
name|PSDImageData
operator|.
name|lChannels
operator|=
name|gimp_image_get_channels
argument_list|(
name|image_id
argument_list|,
operator|&
name|PSDImageData
operator|.
name|nChannels
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tGot number of channels: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nChannels
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|lLayers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\tGot number of layers: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|layersDim
operator|=
name|g_new
argument_list|(
name|PSD_Layer_Dimension
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|save_image (const gchar * filename,gint32 image_id)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|gint32
modifier|*
name|layers
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_image\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
operator|>
literal|30000
operator|||
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
operator|>
literal|30000
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to save '%s'.  The psd file format does not support images that are more than 30000 pixels wide or tall."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Need to check each of the layers size individually also */
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlayers
condition|;
name|i
operator|++
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|width
operator|>
literal|30000
operator|||
name|drawable
operator|->
name|height
operator|>
literal|30000
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Unable to save '%s'.  The psd file format does not support images with layers that are more than 30000 pixels wide or tall."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
name|fd
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
name|g_print
argument_list|(
literal|"\tFile '%s' has been opened\n"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|get_image_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_header
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_color_mode_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_resources
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
comment|/* PSD format does not support layers in indexed images */
if|if
condition|(
name|PSDImageData
operator|.
name|baseType
operator|==
name|GIMP_INDEXED
condition|)
name|write_gint32
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
else|else
name|save_layer_and_mask
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
comment|/* If this is an indexed image, write now channel and layer info */
name|save_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"----- Closing PSD file, done -----\n\n"
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

