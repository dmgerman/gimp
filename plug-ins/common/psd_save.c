begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PSD Save Plugin version 1.0 (BETA)  * This GIMP plug-in is designed to save Adobe Photoshop(tm) files (.PSD)  *  * Monigotes  *  *     If this plug-in fails to save a file which you think it should,  *     please tell me what seemed to go wrong, and anything you know  *     about the image you tried to save.  Please don't send big PSD  *     files to me without asking first.  *  *          Copyright (C) 2000 Monigotes  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Adobe and Adobe Photoshop are trademarks of Adobe Systems  * Incorporated that may be registered in certain jurisdictions.  */
end_comment

begin_comment
comment|/*  * Revision history:  *  *  2000.02 / v1.0 / Monigotes  *       First version.  *  *  2003-05-10  Pedro Gimeno<pggimeno@wanadoo.es>  *       - Cleaned up and GNUstylized.  *       - Translated all comments and vars in Spanish to English.  *  */
end_comment

begin_comment
comment|/*  * TODO:  */
end_comment

begin_comment
comment|/*  * BUGS:  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* *** DEFINES *** */
end_comment

begin_comment
comment|/* set to TRUE if you want debugging, FALSE otherwise */
end_comment

begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|FALSE
end_define

begin_comment
comment|/* 1: Normal debuggin, 2: Deep debuggin */
end_comment

begin_define
DECL|macro|DEBUG_LEVEL
define|#
directive|define
name|DEBUG_LEVEL
value|1
end_define

begin_define
DECL|macro|IFDBG
define|#
directive|define
name|IFDBG
value|if (DEBUG)
end_define

begin_define
DECL|macro|IF_DEEP_DBG
define|#
directive|define
name|IF_DEEP_DBG
value|if (DEBUG&& DEBUG_LEVEL == 2)
end_define

begin_comment
comment|/* *** END OF DEFINES *** */
end_comment

begin_comment
comment|/* Local types etc  */
end_comment

begin_typedef
DECL|struct|PsdLayerDimension
typedef|typedef
struct|struct
name|PsdLayerDimension
block|{
DECL|member|left
name|gint
name|left
decl_stmt|;
DECL|member|top
name|gint
name|top
decl_stmt|;
DECL|member|width
name|gint32
name|width
decl_stmt|;
DECL|member|height
name|gint32
name|height
decl_stmt|;
DECL|typedef|PSD_Layer_Dimension
block|}
name|PSD_Layer_Dimension
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdImageData
typedef|typedef
struct|struct
name|PsdImageData
block|{
DECL|member|compression
name|gboolean
name|compression
decl_stmt|;
DECL|member|image_height
name|gint32
name|image_height
decl_stmt|;
DECL|member|image_width
name|gint32
name|image_width
decl_stmt|;
DECL|member|baseType
name|GimpImageBaseType
name|baseType
decl_stmt|;
DECL|member|nChannels
name|gint
name|nChannels
decl_stmt|;
comment|/* Number of user channels in the image */
DECL|member|lChannels
name|gint32
modifier|*
name|lChannels
decl_stmt|;
comment|/* User channels in the image */
DECL|member|nLayers
name|gint
name|nLayers
decl_stmt|;
comment|/* Number of layers in the image */
DECL|member|lLayers
name|gint32
modifier|*
name|lLayers
decl_stmt|;
comment|/* Identifier of each layer */
DECL|member|layersDim
name|PSD_Layer_Dimension
modifier|*
name|layersDim
decl_stmt|;
comment|/* Dimensions of each layer */
DECL|typedef|PSD_Image_Data
block|}
name|PSD_Image_Data
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|PSDImageData
specifier|static
name|PSD_Image_Data
name|PSDImageData
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psd_lmode_layer
parameter_list|(
name|gint32
name|idLayer
parameter_list|,
name|gchar
modifier|*
name|psdMode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reshuffle_cmap_write
parameter_list|(
name|guchar
modifier|*
name|mapGimp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_header
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_color_mode_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfwrite
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_pascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gint
name|padding
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_string
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_gshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gshort
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_glong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|glong
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|prog_name
specifier|static
specifier|const
name|gchar
modifier|*
name|prog_name
init|=
literal|"PSD"
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"compression"
block|,
literal|"Compression type: { NONE (0), LZW (1), PACKBITS (2)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"fillorder"
block|,
literal|"Fill Order: { MSB to LSB (0), LSB to MSB (1)"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_psd_save"
argument_list|,
literal|"saves files in the Photoshop(tm) PSD file format"
argument_list|,
literal|"This filter saves files of Adobe Photoshop(tm) native PSD format.  These files may be of any image type supported by GIMP, with or without layers, layer masks, aux channels and guides."
argument_list|,
literal|"Monigotes"
argument_list|,
literal|"Monigotes"
argument_list|,
literal|"2000"
argument_list|,
literal|"<Save>/PSD"
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_psd_save"
argument_list|,
literal|"psd"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_psd_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gint32
name|image_id
decl_stmt|;
name|gint32
name|drawable_id
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_IGNORE
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n---------------- %s ----------------\n"
argument_list|,
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
decl_stmt|;
name|image_id
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_id
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
literal|"psd_save"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_id
argument_list|,
operator|&
name|drawable_id
argument_list|,
literal|"PSD"
argument_list|,
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator||
name|GIMP_EXPORT_CAN_HANDLE_LAYERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_id
argument_list|)
condition|)
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
else|else
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|xmalloc (size_t n)
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"PSD: WARNING: %s: xmalloc asked for zero-sized chunk\n"
argument_list|,
name|prog_name
argument_list|)
decl_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|g_malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
name|IFDBG
name|printf
argument_list|(
literal|"%s: out of memory\n"
argument_list|,
name|prog_name
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|psd_lmode_layer (gint32 idLayer,gchar * psdMode)
name|psd_lmode_layer
parameter_list|(
name|gint32
name|idLayer
parameter_list|,
name|gchar
modifier|*
name|psdMode
parameter_list|)
block|{
switch|switch
condition|(
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
condition|)
block|{
case|case
name|GIMP_NORMAL_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DARKEN_ONLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"dark"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LIGHTEN_ONLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"lite"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_HUE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"hue "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_SATURATION_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"sat "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"colr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_MULTIPLY_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"mul "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_SCREEN_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"scrn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DISSOLVE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"diss"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_DIFFERENCE_MODE
case|:
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"diff"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_VALUE_MODE
case|:
comment|/* ? */
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"lum "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_OVERLAY_MODE
case|:
comment|/* ? */
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"over"
argument_list|)
expr_stmt|;
break|break;
comment|/*    case GIMP_BEHIND_MODE:                 These are from GIMP 1.1.14*/
comment|/*    case GIMP_DIVIDE_MODE:                 These are from GIMP 1.1.14*/
case|case
name|GIMP_ADDITION_MODE
case|:
case|case
name|GIMP_SUBTRACT_MODE
case|:
name|IFDBG
name|printf
argument_list|(
literal|"PSD: Warning - unsupported layer-blend mode: %c, using 'norm' mode\n"
argument_list|,
name|gimp_layer_get_mode
argument_list|(
name|idLayer
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"PSD: Warning - UNKNOWN layer-blend mode, reverting to 'norm'\n"
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|psdMode
argument_list|,
literal|"norm"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_string (FILE * fd,char * val,gchar * why)
name|write_string
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_pascalstring (FILE * fd,char * val,gint padding,gchar * why)
name|write_pascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|gint
name|padding
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|len
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Calculate string length to write and limit it to 255 */
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|>
literal|255
operator|)
condition|?
literal|255
else|:
operator|(
name|unsigned
name|char
operator|)
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Perform actual writing */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|val
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
else|else
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* If total length (length byte + content) is not a multiple of PADDING,      add zeros to pad it.  */
name|len
operator|++
expr_stmt|;
comment|/* Add the length field */
if|if
condition|(
operator|(
name|len
operator|%
name|padding
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|padding
operator|-
operator|(
name|len
operator|%
name|padding
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfwrite (FILE * fd,void * buf,long len,gchar * why)
name|xfwrite
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: xfwrite: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_gchar (FILE * fd,unsigned char val,gchar * why)
name|write_gchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|gint32
name|pos
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_gchar: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fd
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_gshort (FILE * fd,gshort val,gchar * why)
name|write_gshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gshort
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
comment|/*  b[0] = val& 255;       b[1] = (val>> 8)& 255;*/
name|b
index|[
literal|1
index|]
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_gshort: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_glong (FILE * fd,glong val,gchar * why)
name|write_glong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|glong
name|val
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
comment|/*  b[0] = val& 255;       b[1] = (val>> 8)& 255;       b[2] = (val>> 16)& 255;       b[3] = (val>> 24)& 255;*/
name|b
index|[
literal|3
index|]
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: write_glong: Error while writing '%s'\n"
argument_list|,
name|why
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|pack_pb_line (guchar * start,guchar * end,guchar * dest_ptr,gshort * length)
name|pack_pb_line
parameter_list|(
name|guchar
modifier|*
name|start
parameter_list|,
name|guchar
modifier|*
name|end
parameter_list|,
name|guchar
modifier|*
name|dest_ptr
parameter_list|,
name|gshort
modifier|*
name|length
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint32
name|remaining
decl_stmt|;
name|remaining
operator|=
name|end
operator|-
name|start
expr_stmt|;
operator|*
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
comment|/* Look for characters matching the first */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|128
operator|)
operator|&&
operator|(
name|start
operator|+
name|i
operator|<
name|end
operator|)
operator|&&
operator|(
name|start
index|[
literal|0
index|]
operator|==
name|start
index|[
name|i
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
comment|/* Match found */
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"Repetition: '%d', %d times ------------> "
argument_list|,
operator|*
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"Writing: '%d' %d\n"
argument_list|,
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|start
argument_list|)
decl_stmt|;
operator|*
name|dest_ptr
operator|++
operator|=
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|dest_ptr
operator|++
operator|=
operator|*
name|start
expr_stmt|;
name|start
operator|+=
name|i
expr_stmt|;
name|remaining
operator|-=
name|i
expr_stmt|;
operator|*
name|length
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* Look for characters different from the previous */
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|128
operator|)
operator|&&
operator|(
name|start
operator|+
name|i
operator|+
literal|1
operator|<=
name|end
operator|)
operator|&&
operator|(
name|start
index|[
name|i
index|]
operator|!=
name|start
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* If there's only 1 remaining, the previous WHILE stmt doesn't              catch it */
if|if
condition|(
name|remaining
operator|==
literal|1
condition|)
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"1 Remaining:\t"
argument_list|)
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* Some distinct ones found */
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"%d distinct              ------------> Writing: '%d' "
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
operator|*
name|dest_ptr
operator|++
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|start
index|[
name|j
index|]
argument_list|)
decl_stmt|;
operator|*
name|dest_ptr
operator|++
operator|=
name|start
index|[
name|j
index|]
expr_stmt|;
block|}
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|start
operator|+=
name|i
expr_stmt|;
name|remaining
operator|-=
name|i
expr_stmt|;
operator|*
name|length
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"Remaining: %d\n"
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
block|}
name|IF_DEEP_DBG
name|printf
argument_list|(
literal|"\nTotal length: %d\n"
argument_list|,
operator|*
name|length
argument_list|)
decl_stmt|;
comment|/*  if (*length& 1)        // length is odd, NOP added (128)     {       *length += 1;       *dest_ptr++ = 128;        IF_DEEP_DBG printf ("Total modified length: %d\n", *length);     } */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GRAYA_to_chans (guchar * greyA,gint numpix,guchar ** grey,guchar ** alpha)
name|GRAYA_to_chans
parameter_list|(
name|guchar
modifier|*
name|greyA
parameter_list|,
name|gint
name|numpix
parameter_list|,
name|guchar
modifier|*
modifier|*
name|grey
parameter_list|,
name|guchar
modifier|*
modifier|*
name|alpha
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|nPix
decl_stmt|;
if|if
condition|(
name|greyA
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"greyA is a null channel"
argument_list|)
decl_stmt|;
operator|*
name|grey
operator|=
name|NULL
expr_stmt|;
operator|*
name|alpha
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|nPix
operator|=
name|numpix
operator|/
literal|2
expr_stmt|;
operator|*
name|grey
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|alpha
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPix
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|grey
operator|)
index|[
name|i
index|]
operator|=
name|greyA
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|alpha
operator|)
index|[
name|i
index|]
operator|=
name|greyA
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|RGB_to_chans (guchar * rgb,gint numpix,guchar ** red,guchar ** green,guchar ** blue)
name|RGB_to_chans
parameter_list|(
name|guchar
modifier|*
name|rgb
parameter_list|,
name|gint
name|numpix
parameter_list|,
name|guchar
modifier|*
modifier|*
name|red
parameter_list|,
name|guchar
modifier|*
modifier|*
name|green
parameter_list|,
name|guchar
modifier|*
modifier|*
name|blue
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|nPix
decl_stmt|;
if|if
condition|(
name|rgb
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"rgb is a null channel"
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|NULL
expr_stmt|;
operator|*
name|green
operator|=
name|NULL
expr_stmt|;
operator|*
name|blue
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|nPix
operator|=
name|numpix
operator|/
literal|3
expr_stmt|;
operator|*
name|red
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|green
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|blue
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPix
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|red
operator|)
index|[
name|i
index|]
operator|=
name|rgb
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
operator|(
operator|*
name|green
operator|)
index|[
name|i
index|]
operator|=
name|rgb
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|blue
operator|)
index|[
name|i
index|]
operator|=
name|rgb
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|RGBA_to_chans (guchar * rgbA,gint numpix,guchar ** red,guchar ** green,guchar ** blue,guchar ** alpha)
name|RGBA_to_chans
parameter_list|(
name|guchar
modifier|*
name|rgbA
parameter_list|,
name|gint
name|numpix
parameter_list|,
name|guchar
modifier|*
modifier|*
name|red
parameter_list|,
name|guchar
modifier|*
modifier|*
name|green
parameter_list|,
name|guchar
modifier|*
modifier|*
name|blue
parameter_list|,
name|guchar
modifier|*
modifier|*
name|alpha
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint
name|nPix
decl_stmt|;
if|if
condition|(
name|rgbA
operator|==
name|NULL
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"rgb is a null channel"
argument_list|)
decl_stmt|;
operator|*
name|red
operator|=
name|NULL
expr_stmt|;
operator|*
name|green
operator|=
name|NULL
expr_stmt|;
operator|*
name|blue
operator|=
name|NULL
expr_stmt|;
operator|*
name|alpha
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|nPix
operator|=
name|numpix
operator|/
literal|4
expr_stmt|;
operator|*
name|red
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|green
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|blue
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
operator|*
name|alpha
operator|=
name|xmalloc
argument_list|(
name|nPix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPix
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|red
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
index|]
expr_stmt|;
operator|(
operator|*
name|green
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|blue
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|alpha
operator|)
index|[
name|i
index|]
operator|=
name|rgbA
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|gimpBaseTypeToPsdMode (GimpImageBaseType gimpBaseType)
name|gimpBaseTypeToPsdMode
parameter_list|(
name|GimpImageBaseType
name|gimpBaseType
parameter_list|)
block|{
switch|switch
condition|(
name|gimpBaseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
literal|3
return|;
comment|/* RGB */
case|case
name|GIMP_GRAY
case|:
return|return
literal|1
return|;
comment|/* Grayscale */
case|case
name|GIMP_INDEXED
case|:
return|return
literal|2
return|;
comment|/* Indexed */
default|default:
name|g_message
argument_list|(
literal|"Error: Can't convert GIMP base imagetype to PSD mode"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"PSD Save: gimpBaseType value is %d, can't convert to PSD mode"
argument_list|,
name|gimpBaseType
argument_list|)
decl_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
return|return
literal|3
return|;
comment|/* Return RGB by default */
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|nChansLayer (gint gimpBaseType,gint hasAlpha)
name|nChansLayer
parameter_list|(
name|gint
name|gimpBaseType
parameter_list|,
name|gint
name|hasAlpha
parameter_list|)
block|{
name|gint
name|incAlpha
init|=
literal|0
decl_stmt|;
name|incAlpha
operator|=
operator|(
name|hasAlpha
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
switch|switch
condition|(
name|gimpBaseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
return|return
literal|3
operator|+
name|incAlpha
return|;
comment|/* R,G,B& Alpha (if any) */
case|case
name|GIMP_GRAY
case|:
return|return
literal|1
operator|+
name|incAlpha
return|;
comment|/* G& Alpha (if any) */
case|case
name|GIMP_INDEXED
case|:
return|return
literal|1
operator|+
name|incAlpha
return|;
comment|/* I& Alpha (if any) */
default|default:
return|return
literal|0
return|;
comment|/* Return 0 channels by default */
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|reshuffle_cmap_write (guchar * mapGimp)
name|reshuffle_cmap_write
parameter_list|(
name|guchar
modifier|*
name|mapGimp
parameter_list|)
block|{
name|guchar
modifier|*
name|mapPSD
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|mapPSD
operator|=
name|xmalloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|mapPSD
index|[
name|i
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
index|]
expr_stmt|;
name|mapPSD
index|[
name|i
operator|+
literal|256
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|mapPSD
index|[
name|i
operator|+
literal|512
index|]
operator|=
name|mapGimp
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
block|{
name|mapGimp
index|[
name|i
index|]
operator|=
name|mapPSD
index|[
name|i
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|mapPSD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_header (FILE * fd,gint32 image_id)
name|save_header
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_header\n"
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Rows: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Columns: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Base type: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|baseType
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Number of channels: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nChannels
argument_list|)
decl_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|,
literal|"signature"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"reserved 1"
argument_list|)
expr_stmt|;
comment|/* 6 for the 'reserved' field + 4 bytes for a long */
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"reserved 1"
argument_list|)
expr_stmt|;
comment|/* and 2 bytes for a short */
name|write_gshort
argument_list|(
name|fd
argument_list|,
operator|(
name|PSDImageData
operator|.
name|nChannels
operator|+
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|,
literal|"channels"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
literal|"columns"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|8
argument_list|,
literal|"depth"
argument_list|)
expr_stmt|;
comment|/* Apparently GIMP only supports 8 bit deep                                      PSD images.  */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|gimpBaseTypeToPsdMode
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|)
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_color_mode_data (FILE * fd,gint32 image_id)
name|save_color_mode_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|guchar
modifier|*
name|cmap_modified
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint32
name|nColors
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_color_mode_data\n"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_INDEXED
case|:
name|IFDBG
name|printf
argument_list|(
literal|"      Image type: INDEXED\n"
argument_list|)
decl_stmt|;
name|cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_id
argument_list|,
operator|&
name|nColors
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Length of colormap returned by gimp_image_get_cmap: %d\n"
argument_list|,
name|nColors
argument_list|)
decl_stmt|;
if|if
condition|(
name|nColors
operator|==
literal|0
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      The indexed image lacks a colormap\n"
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nColors
operator|!=
literal|256
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      The indexed image has %d!=256 colors\n"
argument_list|,
name|nColors
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Padding with zeros up to 256\n"
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|768
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
comment|/* For this type, length is always 768 */
name|cmap_modified
operator|=
name|xmalloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nColors
operator|*
literal|3
condition|;
name|i
operator|++
control|)
name|cmap_modified
index|[
name|i
index|]
operator|=
name|cmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nColors
operator|*
literal|3
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
name|cmap_modified
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reshuffle_cmap_write
argument_list|(
name|cmap_modified
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|cmap_modified
argument_list|,
literal|768
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
comment|/* Write readjusted colormap */
name|g_free
argument_list|(
name|cmap_modified
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* nColors equals 256 */
block|{
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|768
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
comment|/* For this type, length is always 768 */
name|reshuffle_cmap_write
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|cmap
argument_list|,
literal|768
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
comment|/* Write readjusted colormap */
block|}
break|break;
default|default:
name|IFDBG
name|printf
argument_list|(
literal|"      Image type: Not INDEXED\n"
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_resources (FILE * fd,gint32 image_id)
name|save_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|chName
init|=
name|NULL
decl_stmt|;
comment|/* Channel names */
name|gchar
modifier|*
name|fileName
decl_stmt|;
comment|/* Image file name */
name|gint32
name|idActLayer
decl_stmt|;
comment|/* Id of the active layer */
name|guint
name|nActiveLayer
init|=
literal|0
decl_stmt|;
comment|/* Number of the active layer */
name|gboolean
name|ActiveLayerPresent
decl_stmt|;
comment|/* TRUE if there's an active layer */
name|gint32
name|eof_pos
decl_stmt|;
comment|/* Position for End of file */
name|gint32
name|rsc_pos
decl_stmt|;
comment|/* Position for Lengths of Resources section */
name|gint32
name|name_sec
decl_stmt|;
comment|/* Position for Lengths of Channel Names */
comment|/* Only relevant resources in GIMP are: 0x03EE, 0x03F0& 0x0400 */
comment|/* For Adobe Photoshop version 4.0 these can also be considered:      0x0408, 0x040A& 0x040B */
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_resources\n"
argument_list|)
decl_stmt|;
comment|/* Get channel names */
if|if
condition|(
name|PSDImageData
operator|.
name|nChannels
operator|>
literal|0
condition|)
name|chName
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|PSDImageData
operator|.
name|nChannels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDImageData
operator|.
name|nChannels
condition|;
name|i
operator|++
control|)
block|{
name|chName
index|[
name|i
index|]
operator|=
name|gimp_drawable_get_name
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Channel %d name: %s\n"
argument_list|,
name|i
argument_list|,
name|chName
index|[
name|i
index|]
argument_list|)
decl_stmt|;
block|}
comment|/* Get the image title from its filename */
name|fileName
operator|=
name|gimp_image_get_filename
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Image title: %s\n"
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
comment|/* Get the active layer number id */
name|idActLayer
operator|=
name|gimp_image_get_active_layer
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Current layer id: %d\n"
argument_list|,
name|idActLayer
argument_list|)
decl_stmt|;
name|ActiveLayerPresent
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDImageData
operator|.
name|nLayers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|idActLayer
operator|==
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
condition|)
block|{
name|nActiveLayer
operator|=
name|i
expr_stmt|;
name|ActiveLayerPresent
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ActiveLayerPresent
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      Active layer number is: %d\n"
argument_list|,
name|nActiveLayer
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      No active layer\n"
argument_list|)
decl_stmt|;
block|}
comment|/* Here's where actual writing starts */
name|rsc_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"image resources length"
argument_list|)
expr_stmt|;
comment|/* --------------- Write Channel names --------------- */
if|if
condition|(
name|PSDImageData
operator|.
name|nChannels
operator|>
literal|0
condition|)
block|{
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0x03EE
argument_list|,
literal|"0x03EE Id"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring (fd, Name, "Id name"); */
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Set to null string (two zeros) */
comment|/* Mark current position in the file */
name|name_sec
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"0x03EE resource size"
argument_list|)
expr_stmt|;
comment|/* Write all strings */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/*write_pascalstring (fd, chName[i], 2, "chanel name"); */
name|write_string
argument_list|(
name|fd
argument_list|,
name|chName
index|[
name|i
index|]
argument_list|,
literal|"channel name"
argument_list|)
expr_stmt|;
comment|/* Calculate and write actual resource's length */
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|name_sec
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|name_sec
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"0x03EE resource size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n      Total length of 0x03EE resource: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|name_sec
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Pad if length is odd */
if|if
condition|(
operator|(
name|eof_pos
operator|-
name|name_sec
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
operator|)
operator|&
literal|1
condition|)
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"pad byte"
argument_list|)
expr_stmt|;
block|}
comment|/* --------------- Write Active Layer Number --------------- */
if|if
condition|(
name|ActiveLayerPresent
condition|)
block|{
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0x0400
argument_list|,
literal|"0x0400 Id"
argument_list|)
expr_stmt|;
comment|/* write_pascalstring (fd, Name, "Id name"); */
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Id name"
argument_list|)
expr_stmt|;
comment|/* Set to null string (two zeros) */
name|write_glong
argument_list|(
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
argument_list|,
literal|"0x0400 resource size"
argument_list|)
expr_stmt|;
comment|/* Save title as gshort (length always even) */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|nActiveLayer
argument_list|,
literal|"active layer"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Total length of 0x0400 resource: %d\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
argument_list|)
decl_stmt|;
block|}
comment|/* --------------- Write Total Section Length --------------- */
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|rsc_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|rsc_pos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"image resources length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Resource section total length: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|rsc_pos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|chName
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_compress_channel_data (guchar * channel_data,gint32 channel_cols,gint32 channel_rows,gshort ** LengthsTable,guchar ** remdata,glong * TotalCompressedLen)
name|get_compress_channel_data
parameter_list|(
name|guchar
modifier|*
name|channel_data
parameter_list|,
name|gint32
name|channel_cols
parameter_list|,
name|gint32
name|channel_rows
parameter_list|,
name|gshort
modifier|*
modifier|*
name|LengthsTable
parameter_list|,
name|guchar
modifier|*
modifier|*
name|remdata
parameter_list|,
name|glong
modifier|*
name|TotalCompressedLen
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint32
name|len
decl_stmt|;
comment|/* Length of compressed data */
name|gshort
name|rowlen
decl_stmt|;
comment|/* Length of current row */
name|guchar
modifier|*
name|start
decl_stmt|;
comment|/* Starting position of a row in channel_data */
name|guchar
modifier|*
name|end
decl_stmt|;
comment|/* End position of a row in channel_data */
name|gint32
name|channel_length
decl_stmt|;
comment|/* Total channel's length */
name|channel_length
operator|=
name|channel_cols
operator|*
name|channel_rows
expr_stmt|;
operator|*
name|remdata
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|channel_length
operator|*
literal|2
argument_list|)
expr_stmt|;
operator|*
name|LengthsTable
operator|=
name|g_new
argument_list|(
name|gshort
argument_list|,
name|channel_rows
argument_list|)
expr_stmt|;
comment|/* For every row in the channel */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
block|{
name|start
operator|=
name|channel_data
operator|+
operator|(
name|i
operator|*
name|channel_cols
operator|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|channel_cols
expr_stmt|;
comment|/* Create packed data for this row */
name|pack_pb_line
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
operator|(
operator|*
name|remdata
operator|)
operator|+
name|len
argument_list|,
operator|&
name|rowlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|LengthsTable
operator|)
index|[
name|i
index|]
operator|=
name|rowlen
expr_stmt|;
name|len
operator|+=
name|rowlen
expr_stmt|;
block|}
operator|*
name|TotalCompressedLen
operator|=
operator|(
operator|(
name|len
operator|+
name|channel_rows
operator|*
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
DECL|function|save_channel_data (FILE * fd,guchar * channel_data,gint32 channel_cols,gint32 channel_rows,gint32 posLong,gchar * why)
name|save_channel_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|channel_data
parameter_list|,
name|gint32
name|channel_cols
parameter_list|,
name|gint32
name|channel_rows
parameter_list|,
name|gint32
name|posLong
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gint32
name|len
decl_stmt|;
comment|/* Length of compressed data */
name|glong
name|TotalRawLen
decl_stmt|;
comment|/* Total length of raw data */
name|glong
name|TotalCompressedLen
decl_stmt|;
comment|/* Total length of compressed data */
name|gshort
modifier|*
name|LengthsTable
decl_stmt|;
comment|/* Lengths of every compressed row */
name|gshort
name|rowlen
decl_stmt|;
comment|/* Length of row currently being handled */
name|guchar
modifier|*
name|remdata
decl_stmt|;
comment|/* Compressed data from a row */
name|guchar
modifier|*
name|start
decl_stmt|;
comment|/* Start position of a row in channel_data */
name|guchar
modifier|*
name|end
decl_stmt|;
comment|/* End position of a row in channel_data */
name|gint32
name|channel_length
decl_stmt|;
comment|/* Total channel's length */
name|channel_length
operator|=
name|channel_cols
operator|*
name|channel_rows
expr_stmt|;
name|remdata
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|channel_length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|LengthsTable
operator|=
name|g_new
argument_list|(
name|gshort
argument_list|,
name|channel_rows
argument_list|)
expr_stmt|;
comment|/* For every row in the channel */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
block|{
name|start
operator|=
name|channel_data
operator|+
operator|(
name|i
operator|*
name|channel_cols
operator|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|channel_cols
expr_stmt|;
comment|/* Create compressed data for this row */
name|pack_pb_line
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|remdata
operator|+
name|len
argument_list|,
operator|&
name|rowlen
argument_list|)
expr_stmt|;
name|LengthsTable
index|[
name|i
index|]
operator|=
name|rowlen
expr_stmt|;
name|len
operator|+=
name|rowlen
expr_stmt|;
block|}
comment|/* Calculate total lengths of both kinds */
name|TotalRawLen
operator|=
operator|(
name|channel_rows
operator|*
name|channel_cols
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
expr_stmt|;
name|TotalCompressedLen
operator|=
operator|(
operator|(
name|len
operator|+
name|channel_rows
operator|*
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|)
expr_stmt|;
comment|/*  IFDBG printf ("\nCompressed length: %ld\n", TotalCompressedLen);   IFDBG printf ("\nRaw length: %ld\n", TotalRawLen); */
if|if
condition|(
name|TotalCompressedLen
operator|<
name|TotalRawLen
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"        Saving data (RLE): %ld\n"
argument_list|,
name|TotalCompressedLen
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"Compression"
argument_list|)
expr_stmt|;
comment|/* Write compression type */
comment|/* Write compressed lengths table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel_rows
condition|;
name|i
operator|++
control|)
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|LengthsTable
index|[
name|i
index|]
argument_list|,
literal|"RLE length"
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|remdata
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* Write compressed data */
comment|/* Update total compressed length */
name|fseek
argument_list|(
name|fd
argument_list|,
name|posLong
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|TotalCompressedLen
argument_list|,
literal|"channel data length"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"        Write raw data: %ld\n"
argument_list|,
name|TotalRawLen
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Compression"
argument_list|)
expr_stmt|;
comment|/* Save compression type */
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|channel_data
argument_list|,
name|channel_length
argument_list|,
name|why
argument_list|)
expr_stmt|;
comment|/* Save raw data */
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_layer_and_mask (FILE * fd,gint32 image_id)
name|save_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|idChannel
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
comment|/* X offset for each layer */
name|gint
name|offset_y
decl_stmt|;
comment|/* Y offset for each layer */
name|gint32
name|layerWidth
decl_stmt|;
comment|/* Width of each layer */
name|gint32
name|layerHeight
decl_stmt|;
comment|/* Height of each layer */
name|gchar
name|blendMode
index|[
literal|5
index|]
decl_stmt|;
comment|/* Blending mode of the layer */
name|guchar
name|layerOpacity
decl_stmt|;
comment|/* Opacity of the layer */
name|guchar
name|flags
decl_stmt|;
comment|/* Layer flags */
name|gint
name|nChannelsLayer
decl_stmt|;
comment|/* Number of channels of a layer */
name|gint32
name|ChanSize
decl_stmt|;
comment|/* Data length for a channel */
name|gchar
modifier|*
name|layerName
decl_stmt|;
comment|/* Layer name */
name|gint32
name|eof_pos
decl_stmt|;
comment|/* Position: End of file */
name|gint32
name|ExtraDataPos
decl_stmt|;
comment|/* Position: Extra data length */
name|gint32
name|LayerMaskPos
decl_stmt|;
comment|/* Position: Layer& Mask section length */
name|gint32
name|LayerInfoPos
decl_stmt|;
comment|/* Position: Layer info section length*/
name|gint32
modifier|*
modifier|*
name|ChannelLengthPos
decl_stmt|;
comment|/* Position: Channel length */
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_layer&mask\n"
argument_list|)
decl_stmt|;
comment|/* Create first array dimension (layers, channels) */
name|ChannelLengthPos
operator|=
name|g_new
argument_list|(
name|gint32
operator|*
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
comment|/* Layer and mask information section */
name|LayerMaskPos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers& mask information length"
argument_list|)
expr_stmt|;
comment|/* Layer info section */
name|LayerInfoPos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
comment|/* Layer structure section */
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|,
literal|"Layer structure count"
argument_list|)
expr_stmt|;
comment|/* Layer records section */
comment|/* GIMP layers must be written in reverse order */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gimp_drawable_offsets
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|layerWidth
operator|=
name|gimp_drawable_width
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|layerHeight
operator|=
name|gimp_drawable_height
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
operator|=
name|offset_x
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
operator|=
name|offset_y
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|=
name|layerWidth
expr_stmt|;
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|=
name|layerHeight
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Layer number: %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Offset x: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Offset y: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Width: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Height: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
argument_list|,
literal|"Layer top"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
argument_list|,
literal|"Layer left"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|+
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|top
operator|)
argument_list|,
literal|"Layer bottom"
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|+
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|left
operator|)
argument_list|,
literal|"Layer right"
argument_list|)
expr_stmt|;
name|nChannelsLayer
operator|=
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|nChannelsLayer
argument_list|,
literal|"Number channels in the layer"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Number of channels: %d\n"
argument_list|,
name|nChannelsLayer
argument_list|)
decl_stmt|;
comment|/* Create second array dimension (layers, channels) */
name|ChannelLengthPos
index|[
name|i
index|]
operator|=
name|g_new
argument_list|(
name|gint32
argument_list|,
name|nChannelsLayer
argument_list|)
expr_stmt|;
comment|/* Try with gimp_drawable_bpp() */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nChannelsLayer
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|idChannel
operator|=
name|j
operator|-
literal|1
expr_stmt|;
else|else
name|idChannel
operator|=
name|j
expr_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|idChannel
argument_list|,
literal|"Channel ID"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"           - Identifier: %d\n"
argument_list|,
name|idChannel
argument_list|)
decl_stmt|;
comment|/* Write the length assuming no compression.  In case there is,              will modify it later when writing data.  */
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ChanSize
operator|=
sizeof|sizeof
argument_list|(
name|gshort
argument_list|)
operator|+
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|*
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|ChanSize
argument_list|,
literal|"Channel ID"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"             Length: %d\n"
argument_list|,
name|ChanSize
argument_list|)
decl_stmt|;
block|}
name|xfwrite
argument_list|(
name|fd
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|,
literal|"blend mode signature"
argument_list|)
expr_stmt|;
name|psd_lmode_layer
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
name|blendMode
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Blend mode: %s\n"
argument_list|,
name|blendMode
argument_list|)
decl_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|blendMode
argument_list|,
literal|4
argument_list|,
literal|"blend mode key"
argument_list|)
expr_stmt|;
name|layerOpacity
operator|=
operator|(
name|gimp_layer_get_opacity
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
operator|*
literal|255.0
operator|)
operator|/
literal|100.0
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Opacity: %u\n"
argument_list|,
name|layerOpacity
argument_list|)
decl_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|layerOpacity
argument_list|,
literal|"Opacity"
argument_list|)
expr_stmt|;
comment|/* Apparently this field is not used in GIMP */
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Clipping"
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gimp_layer_get_preserve_trans
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|flags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_drawable_get_visible
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
name|flags
operator||=
literal|2
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"         Flags: %u\n"
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|write_gchar
argument_list|(
name|fd
argument_list|,
name|flags
argument_list|,
literal|"Flags"
argument_list|)
expr_stmt|;
comment|/* Padding byte to make the length even */
name|write_gchar
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Filler"
argument_list|)
expr_stmt|;
name|ExtraDataPos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Position of Extra Data size */
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Extra data size"
argument_list|)
expr_stmt|;
comment|/* NOTE Writing empty Layer mask / adjustment layer data */
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer mask size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n         Layer mask size: %d\n"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* NOTE Writing empty Layer blending ranges data */
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"Layer blending size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n         Layer blending size: %d\n"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|layerName
operator|=
name|gimp_drawable_get_name
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write_pascalstring
argument_list|(
name|fd
argument_list|,
name|layerName
argument_list|,
literal|4
argument_list|,
literal|"layer name"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n         Layer name: %s\n"
argument_list|,
name|layerName
argument_list|)
decl_stmt|;
comment|/* Write real length for: Extra data */
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|ExtraDataPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|ExtraDataPos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"Extra data size"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      ExtraData size: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|ExtraDataPos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
comment|/* Channel image data section */
comment|/* Gimp layers must be written in reverse order */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gint
name|nChannel
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpPixelRgn
name|region
decl_stmt|;
comment|/* Image region */
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* Full layer data including all channels */
name|guchar
modifier|*
name|red
decl_stmt|;
comment|/* R channel data */
name|guchar
modifier|*
name|green
decl_stmt|;
comment|/* G channel data */
name|guchar
modifier|*
name|blue
decl_stmt|;
comment|/* B channel data */
name|guchar
modifier|*
name|gray
decl_stmt|;
comment|/* Gray channel data */
name|guchar
modifier|*
name|alpha
decl_stmt|;
comment|/* Alpha channel data */
name|gint32
name|ChanSize
decl_stmt|;
comment|/* Length of channel data */
name|IFDBG
name|printf
argument_list|(
literal|"\n     Channels image data. Layer: %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|ChanSize
operator|=
operator|(
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
operator|*
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
operator|)
expr_stmt|;
name|nChannelsLayer
operator|=
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|ChanSize
operator|*
name|nChannelsLayer
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Channeel size: %d\n"
argument_list|,
name|ChanSize
argument_list|)
decl_stmt|;
name|nChannel
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|RGBA_to_chans
argument_list|(
name|data
argument_list|,
name|ChanSize
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|,
operator|&
name|alpha
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Writing alpha channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|alpha
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"alpha channel"
argument_list|)
expr_stmt|;
block|}
else|else
name|RGB_to_chans
argument_list|(
name|data
argument_list|,
name|ChanSize
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Writing red channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|red
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"red channel"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Writing green channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|green
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"green channel"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Writing blue channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|blue
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"blue channel"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|GRAYA_to_chans
argument_list|(
name|data
argument_list|,
name|ChanSize
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|gray
argument_list|,
operator|&
name|alpha
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Writing alpha channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|alpha
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"alpha channel"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Writing gray channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|gray
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"gray channel"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
name|printf
argument_list|(
literal|"        Writing gray channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"gray channel"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXED
case|:
name|IFDBG
name|printf
argument_list|(
literal|"        Writing indexed channel...\n"
argument_list|)
decl_stmt|;
name|save_channel_data
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|PSDImageData
operator|.
name|layersDim
index|[
name|i
index|]
operator|.
name|height
argument_list|,
name|ChannelLengthPos
index|[
name|i
index|]
index|[
name|nChannel
operator|++
index|]
argument_list|,
literal|"indexed channel"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|eof_pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Write actual size of Layer info section */
name|fseek
argument_list|(
name|fd
argument_list|,
name|LayerInfoPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|LayerInfoPos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n      Total layers info section length: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|LayerInfoPos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Write actual size of Layer and mask information secton */
name|fseek
argument_list|(
name|fd
argument_list|,
name|LayerMaskPos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write_glong
argument_list|(
name|fd
argument_list|,
name|eof_pos
operator|-
name|LayerMaskPos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|,
literal|"layers& mask information length"
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Total layers& mask information length: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eof_pos
operator|-
name|LayerMaskPos
operator|-
sizeof|sizeof
argument_list|(
name|glong
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Return to EOF to continue writing */
name|fseek
argument_list|(
name|fd
argument_list|,
name|eof_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_data (FILE * fd,gint32 image_id)
name|save_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|gint
name|ChanCount
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|nChannel
decl_stmt|;
name|gint
name|offset_x
decl_stmt|;
comment|/* X offset for each layer */
name|gint
name|offset_y
decl_stmt|;
comment|/* Y offset for each layer */
name|gint32
name|layerWidth
decl_stmt|;
comment|/* Width of each layer */
name|gint32
name|layerHeight
decl_stmt|;
comment|/* Height of each layer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpPixelRgn
name|region
decl_stmt|;
comment|/* Image region */
name|guchar
modifier|*
name|data
decl_stmt|;
comment|/* Full layer data including all channels */
name|guchar
modifier|*
name|red
decl_stmt|;
comment|/* R channel data */
name|guchar
modifier|*
name|green
decl_stmt|;
comment|/* G channel data */
name|guchar
modifier|*
name|blue
decl_stmt|;
comment|/* B channel data */
name|guchar
modifier|*
name|gray_indexed
init|=
name|NULL
decl_stmt|;
comment|/* Gray/indexed channel data */
name|gint32
name|ChanSize
decl_stmt|;
comment|/* Length of channel data */
name|gint
name|nChannelsLayer
decl_stmt|;
comment|/* Number of channels in a layer */
name|gshort
modifier|*
modifier|*
name|TLdataCompress
decl_stmt|;
name|guchar
modifier|*
modifier|*
name|dataCompress
decl_stmt|;
name|glong
modifier|*
name|CompressDataSize
decl_stmt|;
name|glong
name|TotalSize
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n Function: save_data\n"
argument_list|)
decl_stmt|;
name|ChanCount
operator|=
operator|(
name|PSDImageData
operator|.
name|nChannels
operator|+
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|TLdataCompress
operator|=
name|g_new
argument_list|(
name|gshort
operator|*
argument_list|,
name|ChanCount
argument_list|)
expr_stmt|;
name|dataCompress
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|ChanCount
argument_list|)
expr_stmt|;
name|CompressDataSize
operator|=
name|g_new
argument_list|(
name|glong
argument_list|,
name|ChanCount
argument_list|)
expr_stmt|;
name|i
operator|=
name|PSDImageData
operator|.
name|nLayers
operator|-
literal|1
expr_stmt|;
comment|/* Channel to be written */
name|IFDBG
name|printf
argument_list|(
literal|"     Processing layer %d\n"
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|layerHeight
operator|=
name|gimp_drawable_height
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|layerWidth
operator|=
name|gimp_drawable_width
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ChanSize
operator|=
name|layerWidth
operator|*
name|layerHeight
expr_stmt|;
name|nChannelsLayer
operator|=
name|nChansLayer
argument_list|(
name|PSDImageData
operator|.
name|baseType
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|ChanSize
operator|*
name|nChannelsLayer
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lLayers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|)
expr_stmt|;
name|nChannel
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|RGB_to_chans
argument_list|(
name|data
argument_list|,
name|ChanSize
operator|*
name|nChannelsLayer
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|red
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|CompressDataSize
index|[
name|nChannel
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Compressed length of red channel: %ld\n"
argument_list|,
name|CompressDataSize
index|[
name|nChannel
index|]
argument_list|)
decl_stmt|;
name|nChannel
operator|++
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|green
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|CompressDataSize
index|[
name|nChannel
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Compressed length of green channel: %ld\n"
argument_list|,
name|CompressDataSize
index|[
name|nChannel
index|]
argument_list|)
decl_stmt|;
name|nChannel
operator|++
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|blue
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|CompressDataSize
index|[
name|nChannel
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Compressed length of blue channel: %ld\n"
argument_list|,
name|CompressDataSize
index|[
name|nChannel
index|]
argument_list|)
decl_stmt|;
name|nChannel
operator|++
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
case|case
name|GIMP_INDEXED
case|:
name|gray_indexed
operator|=
name|data
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|gray_indexed
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|CompressDataSize
index|[
name|nChannel
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"        Compressed length for gray or indexed channel: %ld\n"
argument_list|,
name|CompressDataSize
index|[
name|nChannel
index|]
argument_list|)
decl_stmt|;
name|nChannel
operator|++
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ChanSize
operator|=
operator|(
name|PSDImageData
operator|.
name|image_width
operator|*
name|PSDImageData
operator|.
name|image_height
operator|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
expr_stmt|;
name|get_compress_channel_data
argument_list|(
name|data
argument_list|,
name|layerWidth
argument_list|,
name|layerHeight
argument_list|,
operator|&
operator|(
name|TLdataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|dataCompress
index|[
name|nChannel
index|]
operator|)
argument_list|,
operator|&
operator|(
name|CompressDataSize
index|[
name|nChannel
index|]
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"     Compressed length of user-defined channel: %ld\n"
argument_list|,
name|CompressDataSize
index|[
name|nChannel
index|]
argument_list|)
decl_stmt|;
name|nChannel
operator|++
expr_stmt|;
block|}
comment|/* Calculate length of all compressed channels */
name|TotalSize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChanCount
condition|;
name|i
operator|++
control|)
name|TotalSize
operator|+=
name|CompressDataSize
index|[
name|i
index|]
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n     Total size of compressed data: %ld\n"
argument_list|,
name|TotalSize
argument_list|)
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"     Total size of raw data: %d\n"
argument_list|,
name|ChanCount
operator|*
name|ChanSize
argument_list|)
decl_stmt|;
comment|/* Decide whether to write compressed or raw data */
if|if
condition|(
name|TotalSize
operator|<
name|ChanCount
operator|*
name|ChanSize
condition|)
comment|/* Write compressed data */
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\n     Writing compressed data\n"
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
literal|"RLE compression"
argument_list|)
expr_stmt|;
comment|/* Write all line lengths first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChanCount
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|layerHeight
condition|;
name|j
operator|++
control|)
name|write_gshort
argument_list|(
name|fd
argument_list|,
name|TLdataCompress
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|"line lengths"
argument_list|)
expr_stmt|;
comment|/* Now compressed data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChanCount
condition|;
name|i
operator|++
control|)
block|{
name|TotalSize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|layerHeight
condition|;
name|j
operator|++
control|)
name|TotalSize
operator|+=
name|TLdataCompress
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|dataCompress
index|[
name|i
index|]
argument_list|,
name|TotalSize
argument_list|,
literal|"channel data"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Write raw */
block|{
name|IFDBG
name|printf
argument_list|(
literal|"\n     Writing raw data\n"
argument_list|)
decl_stmt|;
name|write_gshort
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"RLE compression"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PSDImageData
operator|.
name|baseType
condition|)
block|{
case|case
name|GIMP_RGB
case|:
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|red
argument_list|,
name|ChanSize
argument_list|,
literal|"red channel data"
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|green
argument_list|,
name|ChanSize
argument_list|,
literal|"green channel data"
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|blue
argument_list|,
name|ChanSize
argument_list|,
literal|"blue channel data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
case|case
name|GIMP_INDEXED
case|:
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|gray_indexed
argument_list|,
name|ChanSize
argument_list|,
literal|"gray or indexed channel data"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now for user channels */
for|for
control|(
name|i
operator|=
name|PSDImageData
operator|.
name|nChannels
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|PSDImageData
operator|.
name|lChannels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|region
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|region
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|ChanSize
argument_list|,
literal|"channel data"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|get_image_data (FILE * fd,gint32 image_id)
name|get_image_data
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|" Function: get_image_data\n"
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|compression
operator|=
name|FALSE
expr_stmt|;
name|PSDImageData
operator|.
name|image_height
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Got number of rows: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_height
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|image_width
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Got number of cols: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|image_width
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|baseType
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Got base type: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|baseType
argument_list|)
decl_stmt|;
comment|/* PSD format does not support indexed layered images */
if|if
condition|(
name|PSDImageData
operator|.
name|baseType
operator|==
name|GIMP_INDEXED
condition|)
block|{
name|IFDBG
name|printf
argument_list|(
literal|"      Flattening indexed image\n"
argument_list|)
decl_stmt|;
name|gimp_image_flatten
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
block|}
name|PSDImageData
operator|.
name|lChannels
operator|=
name|gimp_image_get_channels
argument_list|(
name|image_id
argument_list|,
operator|&
name|PSDImageData
operator|.
name|nChannels
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Got number of channels: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nChannels
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|lLayers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"      Got number of layers: %d\n"
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
decl_stmt|;
name|PSDImageData
operator|.
name|layersDim
operator|=
name|g_new
argument_list|(
name|PSD_Layer_Dimension
argument_list|,
name|PSDImageData
operator|.
name|nLayers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|save_image (const gchar * filename,gint32 image_id)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|gchar
modifier|*
name|name_buf
decl_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|" Function: save_image\n"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|name_buf
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'..."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|IFDBG
name|g_print
argument_list|(
literal|"      File \"%s\" has been opened\n"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|get_image_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_header
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_color_mode_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|save_resources
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
comment|/* PSD format does not support layers in indexed images */
if|if
condition|(
name|PSDImageData
operator|.
name|baseType
operator|==
name|GIMP_INDEXED
condition|)
name|write_glong
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|"layers info section length"
argument_list|)
expr_stmt|;
else|else
name|save_layer_and_mask
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
comment|/* If this is an indexed image, write now channel and layer info */
name|save_data
argument_list|(
name|fd
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

