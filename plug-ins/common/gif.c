begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIF saving file filter for The GIMP version 1.3/1.4  *  *    Copyright  *    - Adam D. Moss  *    - Peter Mattis  *    - Spencer Kimball  *  *      Based around original GIF code by David Koblas.  *  *  * Version 4.1.0 - 2003-06-16  *                        Adam D. Moss -<adam@gimp.org><adam@foxbox.org>  */
end_comment

begin_comment
comment|/*  * This filter uses code taken from the "giftopnm" and "ppmtogif" programs  *    which are part of the "netpbm" package.  */
end_comment

begin_comment
comment|/*  *  "The Graphics Interchange Format(c) is the Copyright property of  *  CompuServe Incorporated.  GIF(sm) is a Service Mark property of  *  CompuServe Incorporated."  */
end_comment

begin_comment
comment|/* Copyright notice for GIF code from which this plugin was long ago     */
end_comment

begin_comment
comment|/* derived (David Koblas has granted permission to relicense):           */
end_comment

begin_comment
comment|/* +-------------------------------------------------------------------+ */
end_comment

begin_comment
comment|/* | Copyright 1990, 1991, 1993, David Koblas.  (koblas@extra.com)     | */
end_comment

begin_comment
comment|/* +-------------------------------------------------------------------+ */
end_comment

begin_comment
comment|/*  * REVISION HISTORY  *  * 2003-06-16  * 4.01.00 - Attempt to use the palette colour closest to that of the  *           GIMP's current brush background colour for the GIF file's  *           background index hint for non-transparency-aware image  *           viewers.  NOTE that this is merely a hint and may be  *           ignored by this plugin for various (rare) reasons that  *           would usually entail writing a somewhat larger image file.  *           + major version bump to indicate 1.3/1.4 branch.  *  * 2002/04/24 - Cameron Gregory, http://www.flamingtext.com/  *           Added no compress option  *           Added rlecompress().  Should not be covered by lzw patent,  *           but this is not legal advice.  *  * 99/04/25  * 3.00.02 - Save the comment back onto the image as a persistent  *           parasite if the comment was edited.  *  * 99/03/30  * 3.00.01 - Round image timing to nearest 10ms instead of  *           truncating.  Insert a mandatory 10ms minimum delay  *           for the frames of looping animated GIFs, to avoid  *           generating an evil CPU-sucking animation that 'other'  *           GIF-animators sometimes like to save.  *  * 99/03/20  * 3.00.00 - GIF-loading code moved to separate plugin.  *  * 99/02/22  * 2.01.02 - Don't show a progress bar when loading non-interactively  *  * 99/01/23  * 2.01.01 - Use a text-box to permit multi-line comments.  Don't  *           try to write comment blocks which are longer than  *           permitted.  *  * 98/10/09  * 2.01.00 - Added support for persistent GIF Comments through  *           the GIMP 1.1 GimpParasite mechanism where available.  *           Did some user-interface tweaks.  *           Fixed a bug when trying to save a GIF smaller  *           than five pixels high as interlaced.  *  * 98/09/28  * 2.00.05 - Fixed TigerT's Infinite GIF Bug.  Icky one.  *  * 98/09/15  * 2.00.04 - The facility to specify the background colour of  *           a transparent/animated GIF for non-transparent  *           viewers now works very much more consistantly.  *  *           The only situations in which it will fail to work  *           as expected now are those where file size can be reduced  *           (abeit not by much, as the plugin is sometimes more pessimistic  *           than it need be) by re-using an existing unused colour  *           index rather than using another bit per pixel in the  *           encoded file.  That will never be an issue with an image  *           which was freshly converted from RGB to INDEXED with the  *           Quantize option, as that option removes any unused colours  *           from the image.  *  *           Let me know if you find the consistancy/size tradeoff more  *           annoying than helpful and I can adjust it.  IMHO it is too  *           arcane a feature to present to any user as a runtime option.  *  * 98/05/18  * 2.00.03 - If we did manage to decode at least one frame of a  *           gif, be sure to display the resulting image even if  *           it terminated abruptly.  *  * 98/04/28  * 2.00.02 - Fixed a bug with (ms) tag parsing.  *  * 98/03/16  * 2.00.01 - Fixed a long-standing bug when loading GIFs which layer  *           opaque frames onto transparent ones.  *  * 98/03/15  * 2.00.00 - No longer beta.  Uses the current GIMP brush background  *           colour as the transparent-index colour for viewers that  *           don't know about transparency, instead of magenta.  Note  *           that this is by no means likely to actually work, but  *           is more likely to do so if your image has been freshly  *           to-index'd before saving.  *  *           Also added some analysis to gif-reading to prevent the  *           number of encoded bits being pumped up inadvertantly for  *           successive load/saves of the same image.  [Adam]  *  * 97/12/11  * 1.99.18 - Bleh.  Disposals should specify how the next frame will  *           be composed with this frame, NOT how this frame will  *           be composed with the previous frame.  Fixed.  [Adam]  *  * 97/11/30  * 1.99.17 - No more bogus transparency indices in animated GIFs,  *           hopefully.  Saved files are better-behaved, sometimes  *           smaller.  [Adam]  *  * 97/09/29  * 1.99.16 - Added a dialog for the user to choose what to do if  *           one of the layers of the image extends beyond the image  *           borders - crop or cancel.  Added code behind it.  *  *           Corrected the number of bits for the base image to be  *           on the generous side.  Hopefully we can no longer generate  *           GIFs which make XV barf.  *  *           Now a lot more careful about whether we choose to encode  *           as a GIF87a or a GIF89a.  Hopefully does everything by the  *           book.  It should now be nigh-on impossible to torture the  *           plugin into generating a GIF which isn't extremely well  *           behaved with respect to the GIF89a specification.  *  *           Fixed(?) a lot of dialog callback details, should now be  *           happy with window deletion (GTK+970925).  Fixed the  *           cancellation of a save.  [Adam]  *  * 97/09/16  * 1.99.15 - Hey!  We can now cope with loading images which change  *           colourmap between frames.  This plugin will never save  *           such abominations of nature while I still live, though.  *           There should be no noncorrupt GIF in the universe which  *           GIMP can't load and play now.  [Adam]  *  * 97/09/14  * 1.99.14 - Added a check for layers whose extents don't lay  *           within the image boundaries, which would make it a  *           lot harder to generate badly-behaved GIFs.  Doesn't  *           do anything about it yet, but it should crop all layers  *           to the image boundaries.  Also, there's now a (separate)  *           animation-preview plugin!  [Adam]  *  * 97/08/29  * 1.99.13 - Basic ability to embed GIF comments within saved images.  *           Fixed a bug with encoding the number of loops in a GIF file -  *           would have been important, but we're not using that feature  *           yet anyway.  ;)  *           Subtly improved dialog layout a little. [Adam]  *  * 97/07/25  * 1.99.12 - Fixed attempts to load GIFs which don't exist.  Made a  *           related cosmetic adjustment. [Adam]  *  * 97/07/10  * 1.99.11 - Fixed a bug with loading and saving GIFs where the bottom  *           layer wasn't the same size as the image. [Adam]  *  * 97/07/06  * 1.99.10 - New 'save' dialog, now most of the default behaviour of  *           animated GIF saving is user-settable (looping, default  *           time between frames, etc.)  *           PDB entry for saving is no longer compatible.  Fortunately  *           I don't think that anyone is using file_gif_save in  *           scripts.  [Adam]  *  * 97/07/05  * 1.99.9  - More animated GIF work: now loads and saves frame disposal  *           information.  This is neat and will also allow some delta  *           stuff in the future.  *           The disposal-method is kept in the layer name, like the timing  *           info.  *           (replace) - this frame replaces whatever else has been shown  *                       so far.  *           (combine) - this frame builds apon the previous frame.  *           If a disposal method is not specified, it is assumed to mean  *           "don't care."  [Adam]  *  * 97/07/04  * 1.99.8  - Can save per-frame timing information too, now.  The time  *           for which a frame is visible is specified within the layer name  *           as i,e. (250ms).  If a frame doesn't have this timing value  *           it defaults to lasting 100ms. [Adam]  *  * 97/07/02  * 1.99.7  - For animated GIFs, fixed the saving of timing information for  *           frames which couldn't be made transparent.  *           Added the loading of timing information into the layer  *           names.  Adjusted GIMP's GIF magic number very slightly. [Adam]  *  * 97/06/30  * 1.99.6  - Now saves GRAY and GRAYA images, albeit not always  *           optimally (yet). [Adam]  *  * 97/06/25  * 1.99.5  - Good, the transparancy-on-big-architectures bug is  *           fixed.  Cleaned up some stuff.  *           (Adam D. Moss, adam@foxbox.org)  *  * 97/06/23  * 1.99.4  - Trying to fix some endianness/word-size problems with  *           transparent gif-saving on some architectures... does  *           this help?  (Adam D. Moss, adam@foxbox.org)  *  * 97/05/18  * 1.99.3  - Fixed the problem with GIFs getting loop extensions even  *           if they only had one frame (thanks to Zach for noticing -  *           git!  :) )  (Adam D. Moss, adam@foxbox.org)  *  * 97/05/17  * 1.99.2  - Can now save animated GIFs.  Correctly handles saving of  *           image offsets.  Uses N*tscape extentions to loop infinitely.  *           Some notable shortcomings - see TODO list below.  *           (Adam D. Moss, adam@foxbox.org)  *  * 97/05/16  * 1.99.1  - Implemented image offsets in animated GIF loading.  Requires  *           a fix to gimp_layer_translate in libgimp/gimplayer.c if used  *           with GIMP versions<= 0.99.10.  Started work on saving animated  *           GIFs.  Started TODO list.  (Adam D. Moss, adam@foxbox.org)  *  * 97/05/15  * 1.99.0  - Started revision log.  GIF plugin now loads/saves INDEXED  *           and INDEXEDA images with correct transparency where possible.  *           Loads multi-image (animated) GIFs as a framestack implemented  *           in GIMP layers.  Some bug fixes to original code, some new bugs  *           cheerfully added.  (Adam D. Moss, adam@foxbox.org)  *  * Previous versions - load/save INDEXED images.  *           (Peter Mattis& Spencer Kimball, gimp@scam.xcf.berkeley.edu)  */
end_comment

begin_comment
comment|/*  * TODO (more *'s means more important!)  *  * - PDB stuff for comments  *  * - 'requantize' option for INDEXEDA images which really have 256 colours  *   in them  *  * - Be a bit smarter about finding unused/superfluous colour indices for  *   lossless colour crunching of INDEXEDA images.  (Specifically, look  *   for multiple indices which correspond to the same physical colour.)  *  * - Tidy up parameters for the GIFEncode routines  *  * - Remove unused colourmap entries for GRAYSCALE images.  *  * - Button to activate the animation preview plugin from the GIF-save  *   dialog.  *  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* Define only one of these to determine which kind of gif's you would like.  * GIF_UN means use uncompressed gifs.  These will be large, but no  * patent problems.  * GIF_RLE uses Run-length-encoding, which should not be covered by the  * patent, but this is not legal advice.  */
end_comment

begin_comment
comment|/* #define GIF_UN */
end_comment

begin_comment
comment|/* #define GIF_RLE */
end_comment

begin_comment
comment|/* uncomment the line below for a little debugging info */
end_comment

begin_comment
comment|/* #define GIFDEBUG yesplease */
end_comment

begin_comment
comment|/* Does the version of GIMP we're compiling for support    data attachments to images?  ('Parasites') */
end_comment

begin_define
DECL|macro|FACEHUGGERS
define|#
directive|define
name|FACEHUGGERS
value|aieee
end_define

begin_comment
comment|/* PS: I know that technically facehuggers aren't parasites,    the pupal-forms are.  But facehuggers are ky00te. */
end_comment

begin_enum
enum|enum
DECL|enum|__anon2b6522260103
block|{
DECL|enumerator|DISPOSE_UNSPECIFIED
name|DISPOSE_UNSPECIFIED
block|,
DECL|enumerator|DISPOSE_COMBINE
name|DISPOSE_COMBINE
block|,
DECL|enumerator|DISPOSE_REPLACE
name|DISPOSE_REPLACE
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2b6522260208
block|{
DECL|member|interlace
name|gint
name|interlace
decl_stmt|;
DECL|member|save_comment
name|gint
name|save_comment
decl_stmt|;
DECL|member|loop
name|gint
name|loop
decl_stmt|;
DECL|member|default_delay
name|gint
name|default_delay
decl_stmt|;
DECL|member|default_dispose
name|gint
name|default_dispose
decl_stmt|;
DECL|typedef|GIFSaveVals
block|}
name|GIFSaveVals
typedef|;
end_typedef

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|boundscheck
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|badbounds_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comment_entry_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|comment_was_edited
specifier|static
name|gboolean
name|comment_was_edited
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|run_mode
specifier|static
name|GimpRunMode
name|run_mode
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FACEHUGGERS
end_ifdef

begin_decl_stmt
DECL|variable|comment_parasite
name|GimpParasite
modifier|*
name|comment_parasite
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For compression code */
end_comment

begin_decl_stmt
DECL|variable|Interlace
specifier|static
name|gint
name|Interlace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gsvals
specifier|static
name|GIFSaveVals
name|gsvals
init|=
block|{
name|FALSE
block|,
comment|/* interlace                            */
name|TRUE
block|,
comment|/* save comment                         */
name|TRUE
block|,
comment|/* loop infinitely                      */
literal|100
block|,
comment|/* default_delay between frames (100ms) */
literal|0
comment|/* default_dispose = "don't care"       */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Image to save"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"interlace"
block|,
literal|"Try to save as interlaced"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"loop"
block|,
literal|"(animated gif) loop infinitely"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"default_delay"
block|,
literal|"(animated gif) Default delay between framese in milliseconds"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"default_dispose"
block|,
literal|"(animated gif) Default disposal type (0=`don't care`, 1=combine, 2=replace)"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_gif_save"
argument_list|,
literal|"saves files in Compuserve GIF file format"
argument_list|,
literal|"Save a file in Compuserve GIF format, with "
literal|"possible animation, transparency, and comment.  "
literal|"To save an animation, operate on a multi-layer "
literal|"file.  The plug-in will intrepret<50% alpha as "
literal|"transparent.  When run non-interactively, the "
literal|"value for the comment is taken from the "
literal|"'gimp-comment' parasite.  "
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"1995-1997"
argument_list|,
name|N_
argument_list|(
literal|"GIF image"
argument_list|)
argument_list|,
literal|"INDEXED*, GRAY*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
literal|"file_gif_save"
argument_list|,
literal|"image/gif"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_gif_save"
argument_list|,
literal|"gif"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|gint32
name|orig_image_ID
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_gif_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|orig_image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
literal|"gif"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
literal|"GIF"
argument_list|,
operator|(
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator||
name|GIMP_EXPORT_CAN_HANDLE_LAYERS_AS_ANIMATION
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|boundscheck
argument_list|(
name|image_ID
argument_list|)
condition|)
comment|/* The image may or may not have had layers out of 	   bounds, but the user didn't mind cropping it down. */
block|{
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_gif_save"
argument_list|,
operator|&
name|gsvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|image_ID
argument_list|)
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|9
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|gsvals
operator|.
name|interlace
operator|=
operator|(
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|gsvals
operator|.
name|save_comment
operator|=
name|TRUE
expr_stmt|;
comment|/*  no way to to specify that through the PDB  */
name|gsvals
operator|.
name|loop
operator|=
operator|(
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|gsvals
operator|.
name|default_delay
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gsvals
operator|.
name|default_dispose
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_gif_save"
argument_list|,
operator|&
name|gsvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|,
name|orig_image_ID
argument_list|)
condition|)
block|{
comment|/*  Store psvals data  */
name|gimp_set_data
argument_list|(
literal|"file_gif_save"
argument_list|,
operator|&
name|gsvals
argument_list|,
sizeof|sizeof
argument_list|(
name|GIFSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Some layers were out of bounds and the user wishes 	      to abort.  */
block|{
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_define
DECL|macro|MAXCOLORMAPSIZE
define|#
directive|define
name|MAXCOLORMAPSIZE
value|256
end_define

begin_define
DECL|macro|INTERLACE
define|#
directive|define
name|INTERLACE
value|0x40
end_define

begin_define
DECL|macro|LOCALCOLORMAP
define|#
directive|define
name|LOCALCOLORMAP
value|0x80
end_define

begin_define
DECL|macro|GRAYSCALE
define|#
directive|define
name|GRAYSCALE
value|1
end_define

begin_define
DECL|macro|COLOR
define|#
directive|define
name|COLOR
value|2
end_define

begin_typedef
DECL|typedef|CMap
typedef|typedef
name|guchar
name|CMap
index|[
literal|3
index|]
index|[
name|MAXCOLORMAPSIZE
index|]
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|globalcomment
specifier|static
name|gchar
modifier|*
name|globalcomment
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ppmtogif.c - read a portable pixmap and produce a GIF file ** ** Based on GIFENCOD by David Rowley<mgardi@watdscu.waterloo.edu>. A ** Lempel-Ziv compression based on "compress". ** ** Modified by Marcel Wijkstra<wijkstra@fwi.uva.nl> ** ** ** Copyright (C) 1989 by Jef Poskanzer. ** ** Permission to use, copy, modify, and distribute this software and its ** documentation for any purpose and without fee is hereby granted, provided ** that the above copyright notice appear in all copies and that both that ** copyright notice and this permission notice appear in supporting ** documentation.  This software is provided "as is" without express or ** implied warranty. ** ** The Graphics Interchange Format(c) is the Copyright property of ** CompuServe Incorporated.  GIF(sm) is a Service Mark property of ** CompuServe Incorporated. */
end_comment

begin_define
DECL|macro|MAXCOLORS
define|#
directive|define
name|MAXCOLORS
value|256
end_define

begin_comment
comment|/*  * Pointer to function returning an int  */
end_comment

begin_typedef
DECL|typedef|ifunptr
typedef|typedef
name|int
function_decl|(
modifier|*
name|ifunptr
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * a code_int must be able to hold 2**BITS values of type int, and also -1  */
end_comment

begin_typedef
DECL|typedef|code_int
typedef|typedef
name|int
name|code_int
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
end_ifdef

begin_typedef
DECL|typedef|count_int
typedef|typedef
name|unsigned
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_typedef
DECL|typedef|count_short
typedef|typedef
name|unsigned
name|short
name|int
name|count_short
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*SIGNED_COMPARE_SLOW */
end_comment

begin_typedef
DECL|typedef|count_int
typedef|typedef
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SIGNED_COMPARE_SLOW */
end_comment

begin_function_decl
specifier|static
name|gint
name|find_unused_ia_colour
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
name|numpixels
parameter_list|,
name|gint
name|num_indices
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|special_flatten_indexed_alpha
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
modifier|*
name|transparent
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|,
name|gint
name|numpixels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|colorstobpp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpptocolors
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GetPixel
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|BumpPixel
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GIFNextPixel
parameter_list|(
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeHeader
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|gboolean
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeGraphicControlExt
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeImageData
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|ifunptr
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeClose
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeLoopExt
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeCommentExt
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|gchar
modifier|*
name|comment
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|rowstride
name|int
name|rowstride
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pixels
name|guchar
modifier|*
name|pixels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_progress
name|int
name|cur_progress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_progress
name|int
name|max_progress
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|Putword
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GIF_UN
end_ifdef

begin_function_decl
specifier|static
name|void
name|nocompress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|GIF_RLE
end_ifdef

begin_function_decl
specifier|static
name|void
name|rlecompress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|normalcompress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|output
parameter_list|(
name|code_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cl_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cl_hash
parameter_list|(
name|count_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeerr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|char_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|char_out
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_char
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|gint
DECL|function|find_unused_ia_colour (guchar * pixels,gint numpixels,gint num_indices,gint * colors)
name|find_unused_ia_colour
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
name|numpixels
parameter_list|,
name|gint
name|num_indices
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gboolean
name|ix_used
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_printerr
argument_list|(
literal|"GIF: fuiac: Image claims to use %d/%d indices - finding free "
literal|"index...\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|colors
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|num_indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|ix_used
index|[
name|i
index|]
operator|=
operator|(
name|gboolean
operator|)
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
condition|)
name|ix_used
index|[
name|pixels
index|[
name|i
operator|*
literal|2
index|]
index|]
operator|=
operator|(
name|gboolean
operator|)
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|num_indices
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ix_used
index|[
name|i
index|]
operator|==
operator|(
name|gboolean
operator|)
name|FALSE
condition|)
block|{
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_printerr
argument_list|(
literal|"GIF: Found unused colour index %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|i
return|;
block|}
block|}
comment|/* Couldn't find an unused colour index within the number of      bits per pixel we wanted.  Will have to increment the number      of colours in the image and assign a transparent pixel there. */
if|if
condition|(
operator|(
operator|*
name|colors
operator|)
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|colors
operator|)
operator|++
expr_stmt|;
name|g_printerr
argument_list|(
literal|"GIF: 2nd pass "
literal|"- Increasing bounds and using colour index %d.\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|colors
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|colors
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Couldn't simply reduce colors further. Saving as opaque."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|special_flatten_indexed_alpha (guchar * pixels,int * transparent,int * colors,int numpixels)
name|special_flatten_indexed_alpha
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
modifier|*
name|transparent
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|,
name|int
name|numpixels
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
comment|/* Each transparent pixel in the image is mapped to a uniform value for      encoding, if image already has<=255 colours */
if|if
condition|(
operator|(
operator|*
name|transparent
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* tough, no indices left for the trans. index */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixels
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
else|else
comment|/* make transparent */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|&
literal|128
operator|)
condition|)
block|{
name|pixels
index|[
name|i
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|*
name|transparent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pixels
index|[
name|i
index|]
operator|=
name|pixels
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Pixel data now takes half as much space (the alpha data has been      discarded) */
comment|/*  pixels = g_realloc (pixels, numpixels);*/
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|parse_ms_tag (char * str)
name|parse_ms_tag
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|gint
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|offset
init|=
literal|0
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|find_another_bra
label|:
while|while
condition|(
operator|(
name|offset
operator|<
name|length
operator|)
operator|&&
operator|(
name|str
index|[
name|offset
index|]
operator|!=
literal|'('
operator|)
condition|)
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|length
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|g_ascii_isdigit
argument_list|(
name|str
index|[
operator|++
name|offset
index|]
argument_list|)
condition|)
goto|goto
name|find_another_bra
goto|;
do|do
block|{
name|sum
operator|*=
literal|10
expr_stmt|;
name|sum
operator|+=
name|str
index|[
name|offset
index|]
operator|-
literal|'0'
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|offset
operator|<
name|length
operator|)
operator|&&
operator|(
name|g_ascii_isdigit
argument_list|(
name|str
index|[
name|offset
index|]
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|length
operator|-
name|offset
operator|<=
literal|2
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
if|if
condition|(
operator|(
name|g_ascii_toupper
argument_list|(
name|str
index|[
name|offset
index|]
argument_list|)
operator|!=
literal|'M'
operator|)
operator|||
operator|(
name|g_ascii_toupper
argument_list|(
name|str
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|'S'
operator|)
condition|)
return|return
operator|-
literal|4
return|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|parse_disposal_tag (char * str)
name|parse_disposal_tag
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|gint
name|offset
init|=
literal|0
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|offset
operator|+
literal|9
operator|)
operator|<=
name|length
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|offset
index|]
argument_list|,
literal|"(combine)"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0x01
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|offset
index|]
argument_list|,
literal|"(replace)"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0x02
operator|)
return|;
name|offset
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|gsvals
operator|.
name|default_dispose
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|boundscheck (gint32 image_ID)
name|boundscheck
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
modifier|*
name|layers
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
comment|/* get a list of layers for this image_ID */
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
comment|/*** Iterate through the layers to make sure they're all ***/
comment|/*** within the bounds of the image                      ***/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlayers
condition|;
name|i
operator|++
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset_x
operator|<
literal|0
operator|)
operator|||
operator|(
name|offset_y
operator|<
literal|0
operator|)
operator|||
operator|(
name|offset_x
operator|+
name|drawable
operator|->
name|width
operator|>
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
operator|)
operator|||
operator|(
name|offset_y
operator|+
name|drawable
operator|->
name|height
operator|>
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
operator|)
condition|)
block|{
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* Image has illegal bounds - ask the user what it wants to do */
comment|/* Do the crop if we can't talk to the user, or if we asked 	   * the user and they said yes. */
if|if
condition|(
operator|(
name|run_mode
operator|==
name|GIMP_RUN_NONINTERACTIVE
operator|)
operator|||
name|badbounds_dialog
argument_list|()
condition|)
block|{
name|gimp_image_crop
argument_list|(
name|image_ID
argument_list|,
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
argument_list|,
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_image (const gchar * filename,gint32 image_ID,gint32 drawable_ID,gint32 orig_image_ID)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|)
block|{
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpImageType
name|drawable_type
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|gint
name|Red
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|gint
name|Green
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|gint
name|Blue
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|guint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|gint
name|BitsPerPixel
decl_stmt|,
name|liberalBPP
init|=
literal|0
decl_stmt|,
name|useBPP
init|=
literal|0
decl_stmt|;
name|gint
name|colors
decl_stmt|;
name|gchar
modifier|*
name|temp_buf
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|transparent
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|gint32
modifier|*
name|layers
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gboolean
name|is_gif89
init|=
name|FALSE
decl_stmt|;
name|gint
name|Delay89
decl_stmt|;
name|gint
name|Disposal
decl_stmt|;
name|gchar
modifier|*
name|layer_name
decl_stmt|;
name|GimpRGB
name|background
decl_stmt|;
name|guchar
name|bgred
decl_stmt|,
name|bggreen
decl_stmt|,
name|bgblue
decl_stmt|;
name|guchar
name|bgindex
init|=
literal|0
decl_stmt|;
name|guint
name|best_error
init|=
literal|0xFFFFFFFF
decl_stmt|;
ifdef|#
directive|ifdef
name|FACEHUGGERS
comment|/* Save the comment back to the ImageID, if appropriate */
if|if
condition|(
name|globalcomment
operator|!=
name|NULL
operator|&&
name|comment_was_edited
condition|)
block|{
name|comment_parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|globalcomment
argument_list|)
operator|+
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|globalcomment
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|orig_image_ID
argument_list|,
name|comment_parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|comment_parasite
argument_list|)
expr_stmt|;
name|comment_parasite
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The GIF spec says 7bit ASCII for the comment block. */
if|if
condition|(
name|gsvals
operator|.
name|save_comment
operator|&&
name|globalcomment
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|c
init|=
name|globalcomment
decl_stmt|;
name|gint
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
name|strlen
argument_list|(
name|c
argument_list|)
init|;
name|len
condition|;
name|c
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|guchar
operator|)
operator|*
name|c
operator|>
literal|127
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The GIF format only supports comments in "
literal|"7bit ASCII encoding. No comment is saved."
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
name|globalcomment
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* get a list of layers for this image_ID */
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|layers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If the image has multiple layers (i.e. will be animated), a comment,      or transparency, then it must be encoded as a GIF89a file, not a vanilla      GIF87a. */
if|if
condition|(
name|nlayers
operator|>
literal|1
condition|)
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|gsvals
operator|.
name|save_comment
condition|)
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|drawable_type
condition|)
block|{
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
operator|&
name|background
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|background
argument_list|,
operator|&
name|bgred
argument_list|,
operator|&
name|bggreen
argument_list|,
operator|&
name|bgblue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
name|Green
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
name|Blue
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
name|bgred
expr_stmt|;
name|Green
index|[
name|i
index|]
operator|=
name|bggreen
expr_stmt|;
name|Blue
index|[
name|i
index|]
operator|=
name|bgblue
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|colors
operator|=
literal|256
expr_stmt|;
comment|/* FIXME: Not ideal. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
name|Green
index|[
name|i
index|]
operator|=
name|Blue
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot save RGB color images. Convert to "
literal|"indexed color or grayscale first."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* find earliest index in palette which is closest to the background      colour, and ATTEMPT to use that as the GIF's default background colour. */
for|for
control|(
name|i
operator|=
literal|255
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unsigned
name|int
name|local_error
init|=
literal|0
decl_stmt|;
name|local_error
operator|+=
operator|(
name|Red
index|[
name|i
index|]
operator|-
name|bgred
operator|)
operator|*
operator|(
name|Red
index|[
name|i
index|]
operator|-
name|bgred
operator|)
expr_stmt|;
name|local_error
operator|+=
operator|(
name|Green
index|[
name|i
index|]
operator|-
name|bggreen
operator|)
operator|*
operator|(
name|Green
index|[
name|i
index|]
operator|-
name|bggreen
operator|)
expr_stmt|;
name|local_error
operator|+=
operator|(
name|Blue
index|[
name|i
index|]
operator|-
name|bgblue
operator|)
operator|*
operator|(
name|Blue
index|[
name|i
index|]
operator|-
name|bgblue
operator|)
expr_stmt|;
if|if
condition|(
name|local_error
operator|<=
name|best_error
condition|)
block|{
name|bgindex
operator|=
name|i
expr_stmt|;
name|best_error
operator|=
name|local_error
expr_stmt|;
block|}
block|}
comment|/* open the destination file for writing */
name|outfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* init the progress meter */
name|temp_buf
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'..."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
comment|/* write the GIFheader */
if|if
condition|(
name|colors
operator|<
literal|256
condition|)
block|{
comment|/* we keep track of how many bits we promised to have in liberalBPP, 	 so that we don't accidentally come under this when doing 	 clever transparency stuff where we can re-use wasted indices. */
name|liberalBPP
operator|=
name|BitsPerPixel
operator|=
name|colorstobpp
argument_list|(
name|colors
operator|+
operator|(
operator|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|liberalBPP
operator|=
name|BitsPerPixel
operator|=
name|colorstobpp
argument_list|(
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
condition|)
block|{
name|g_printerr
argument_list|(
literal|"GIF: Too many colours?\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cols
operator|=
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|rows
operator|=
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|Interlace
operator|=
name|gsvals
operator|.
name|interlace
expr_stmt|;
name|GIFEncodeHeader
argument_list|(
name|outfile
argument_list|,
name|is_gif89
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|bgindex
argument_list|,
name|BitsPerPixel
argument_list|,
name|Red
argument_list|,
name|Green
argument_list|,
name|Blue
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
comment|/* If the image has multiple layers it'll be made into an      animated GIF, so write out the infinite-looping extension */
if|if
condition|(
operator|(
name|nlayers
operator|>
literal|1
operator|)
operator|&&
operator|(
name|gsvals
operator|.
name|loop
operator|)
condition|)
name|GIFEncodeLoopExt
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write comment extension - mustn't be written before the looping ext. */
if|if
condition|(
name|gsvals
operator|.
name|save_comment
operator|&&
name|globalcomment
condition|)
block|{
name|GIFEncodeCommentExt
argument_list|(
name|outfile
argument_list|,
name|globalcomment
argument_list|)
expr_stmt|;
block|}
comment|/*** Now for each layer in the image, save an image in a compound GIF ***/
comment|/************************************************************************/
name|i
operator|=
name|nlayers
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|cols
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|rows
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|rowstride
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cur_progress
operator|=
literal|0
expr_stmt|;
name|max_progress
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|pixels
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
operator|*
operator|(
operator|(
operator|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
operator|)
operator|||
operator|(
name|drawable_type
operator|==
name|GIMP_GRAYA_IMAGE
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* sort out whether we need to do transparency jiggery-pokery */
if|if
condition|(
operator|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
operator|)
operator|||
operator|(
name|drawable_type
operator|==
name|GIMP_GRAYA_IMAGE
operator|)
condition|)
block|{
comment|/* Try to find an entry which isn't actually used in the 	     image, for a transparency index. */
name|transparent
operator|=
name|find_unused_ia_colour
argument_list|(
name|pixels
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
argument_list|,
name|bpptocolors
argument_list|(
name|colorstobpp
argument_list|(
name|colors
argument_list|)
argument_list|)
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|special_flatten_indexed_alpha
argument_list|(
name|pixels
argument_list|,
operator|&
name|transparent
argument_list|,
operator|&
name|colors
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
else|else
name|transparent
operator|=
operator|-
literal|1
expr_stmt|;
name|BitsPerPixel
operator|=
name|colorstobpp
argument_list|(
name|colors
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitsPerPixel
operator|!=
name|liberalBPP
condition|)
block|{
comment|/* We were able to re-use an index within the existing bitspace, 	     whereas the estimate in the header was pessimistic but still 	     needs to be upheld... */
specifier|static
name|gboolean
name|onceonly
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|onceonly
condition|)
block|{
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_warning
argument_list|(
literal|"Promised %d bpp, pondered writing chunk with %d bpp!"
argument_list|,
name|liberalBPP
argument_list|,
name|BitsPerPixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Warning:\n"
literal|"Transparent color in written file might be "
literal|"incorrect on viewers which don't support "
literal|"transparency."
argument_list|)
argument_list|)
expr_stmt|;
name|onceonly
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|useBPP
operator|=
operator|(
name|BitsPerPixel
operator|>
name|liberalBPP
operator|)
condition|?
name|BitsPerPixel
else|:
name|liberalBPP
expr_stmt|;
if|if
condition|(
name|is_gif89
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|layer_name
operator|=
name|gimp_drawable_get_name
argument_list|(
name|layers
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|Disposal
operator|=
name|parse_disposal_tag
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
block|}
else|else
name|Disposal
operator|=
name|gsvals
operator|.
name|default_dispose
expr_stmt|;
name|layer_name
operator|=
name|gimp_drawable_get_name
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Delay89
operator|=
name|parse_ms_tag
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delay89
operator|<
literal|0
condition|)
name|Delay89
operator|=
operator|(
name|gsvals
operator|.
name|default_delay
operator|+
literal|5
operator|)
operator|/
literal|10
expr_stmt|;
else|else
name|Delay89
operator|=
operator|(
name|Delay89
operator|+
literal|5
operator|)
operator|/
literal|10
expr_stmt|;
comment|/* don't allow a CPU-sucking completely 0-delay looping anim */
if|if
condition|(
operator|(
name|nlayers
operator|>
literal|1
operator|)
operator|&&
name|gsvals
operator|.
name|loop
operator|&&
operator|(
name|Delay89
operator|==
literal|0
operator|)
condition|)
block|{
specifier|static
name|gboolean
name|onceonly
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|onceonly
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Delay inserted to prevent evil "
literal|"CPU-sucking anim."
argument_list|)
argument_list|)
expr_stmt|;
name|onceonly
operator|=
name|TRUE
expr_stmt|;
block|}
name|Delay89
operator|=
literal|1
expr_stmt|;
block|}
name|GIFEncodeGraphicControlExt
argument_list|(
name|outfile
argument_list|,
name|Disposal
argument_list|,
name|Delay89
argument_list|,
name|nlayers
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|transparent
argument_list|,
name|useBPP
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
block|}
name|GIFEncodeImageData
argument_list|(
name|outfile
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
operator|(
name|rows
operator|>
literal|4
operator|)
condition|?
name|gsvals
operator|.
name|interlace
else|:
literal|0
argument_list|,
name|useBPP
argument_list|,
name|GetPixel
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
name|GIFEncodeClose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|badbounds_dialog (void)
name|badbounds_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|gboolean
name|crop
decl_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"GIF Warning"
argument_list|)
argument_list|,
literal|"gif_warning"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
literal|"file-gif-save"
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  the warning message  */
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"The image which you are trying to save as a GIF\n"
literal|"contains layers which extend beyond the actual\n"
literal|"borders of the image.  This isn't allowed in GIFs,\n"
literal|"I'm afraid.\n\n"
literal|"You may choose whether to crop all of the layers to\n"
literal|"the image borders, or cancel this save."
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|crop
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dlg
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
return|return
name|crop
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_dialog (gint32 image_ID)
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|main_vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|spinbutton
decl_stmt|;
name|GtkObject
modifier|*
name|adj
decl_stmt|;
name|GtkWidget
modifier|*
name|text_view
decl_stmt|;
name|GtkTextBuffer
modifier|*
name|text_buffer
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|align
decl_stmt|;
name|GtkWidget
modifier|*
name|combo
decl_stmt|;
name|GtkWidget
modifier|*
name|scrolled_window
decl_stmt|;
ifdef|#
directive|ifdef
name|FACEHUGGERS
name|GimpParasite
modifier|*
name|GIF2_CMNT
decl_stmt|;
endif|#
directive|endif
name|gint32
name|nlayers
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Save as GIF"
argument_list|)
argument_list|,
literal|"gif"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
literal|"file-gif-save"
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|main_vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|main_vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|main_vbox
argument_list|)
expr_stmt|;
comment|/*  regular gif parameter settings  */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"GIF Options"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Interlace"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|gsvals
operator|.
name|interlace
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|gsvals
operator|.
name|interlace
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|align
operator|=
name|gtk_alignment_new
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|align
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|align
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_GIF comment:"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|align
argument_list|)
argument_list|,
name|toggle
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|gsvals
operator|.
name|save_comment
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|gsvals
operator|.
name|save_comment
argument_list|)
expr_stmt|;
comment|/* the comment text_view in a gtk_scrolled_window */
name|scrolled_window
operator|=
name|gtk_scrolled_window_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_scrolled_window_set_shadow_type
argument_list|(
name|GTK_SCROLLED_WINDOW
argument_list|(
name|scrolled_window
argument_list|)
argument_list|,
name|GTK_SHADOW_IN
argument_list|)
expr_stmt|;
name|gtk_scrolled_window_set_policy
argument_list|(
name|GTK_SCROLLED_WINDOW
argument_list|(
name|scrolled_window
argument_list|)
argument_list|,
name|GTK_POLICY_AUTOMATIC
argument_list|,
name|GTK_POLICY_AUTOMATIC
argument_list|)
expr_stmt|;
name|gtk_box_pack_start_defaults
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|scrolled_window
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|scrolled_window
argument_list|)
expr_stmt|;
name|text_buffer
operator|=
name|gtk_text_buffer_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|text_view
operator|=
name|gtk_text_view_new_with_buffer
argument_list|(
name|text_buffer
argument_list|)
expr_stmt|;
name|gtk_text_view_set_wrap_mode
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|text_view
argument_list|)
argument_list|,
name|GTK_WRAP_WORD
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|scrolled_window
argument_list|)
argument_list|,
name|text_view
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|text_view
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|text_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|globalcomment
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FACEHUGGERS
name|GIF2_CMNT
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image_ID
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIF2_CMNT
condition|)
block|{
name|globalcomment
operator|=
name|g_malloc
argument_list|(
name|GIF2_CMNT
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|globalcomment
argument_list|,
name|GIF2_CMNT
operator|->
name|data
argument_list|,
name|GIF2_CMNT
operator|->
name|size
argument_list|)
expr_stmt|;
name|globalcomment
index|[
name|GIF2_CMNT
operator|->
name|size
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|globalcomment
operator|=
name|gimp_get_default_comment
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FACEHUGGERS
block|}
name|gimp_parasite_free
argument_list|(
name|GIF2_CMNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|globalcomment
condition|)
name|gtk_text_buffer_set_text
argument_list|(
name|text_buffer
argument_list|,
name|globalcomment
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|text_buffer
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|comment_entry_callback
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/*  additional animated gif parameter settings  */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"Animated GIF Options"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Loop forever"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|gsvals
operator|.
name|loop
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|gsvals
operator|.
name|loop
argument_list|)
expr_stmt|;
comment|/* default_delay entry field */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"_Delay between frames where unspecified:"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|spinbutton
operator|=
name|gimp_spin_button_new
argument_list|(
operator|&
name|adj
argument_list|,
name|gsvals
operator|.
name|default_delay
argument_list|,
literal|0
argument_list|,
literal|65000
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|spinbutton
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|spinbutton
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value_changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|gsvals
operator|.
name|default_delay
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"milliseconds"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/* Disposal selector */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Frame disposal where unspecified: "
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|combo
operator|=
name|gimp_int_combo_box_new
argument_list|(
name|_
argument_list|(
literal|"I don't care"
argument_list|)
argument_list|,
name|DISPOSE_UNSPECIFIED
argument_list|,
name|_
argument_list|(
literal|"Cumulative layers (combine)"
argument_list|)
argument_list|,
name|DISPOSE_COMBINE
argument_list|,
name|_
argument_list|(
literal|"One frame per layer (replace)"
argument_list|)
argument_list|,
name|DISPOSE_REPLACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_int_combo_box_set_active
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|,
name|gsvals
operator|.
name|default_dispose
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|combo
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_combo_box_get_active
argument_list|)
argument_list|,
operator|&
name|gsvals
operator|.
name|default_dispose
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|combo
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|combo
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
comment|/* If the image has only one layer it can't be animated, so      desensitize the animation options. */
if|if
condition|(
name|nlayers
operator|==
literal|1
condition|)
name|gtk_widget_set_sensitive
argument_list|(
name|frame
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dlg
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|colorstobpp (int colors)
name|colorstobpp
parameter_list|(
name|int
name|colors
parameter_list|)
block|{
name|int
name|bpp
decl_stmt|;
if|if
condition|(
name|colors
operator|<=
literal|2
condition|)
name|bpp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|4
condition|)
name|bpp
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|8
condition|)
name|bpp
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|16
condition|)
name|bpp
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|32
condition|)
name|bpp
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|64
condition|)
name|bpp
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|128
condition|)
name|bpp
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|256
condition|)
name|bpp
operator|=
literal|8
expr_stmt|;
else|else
block|{
name|g_warning
argument_list|(
literal|"GIF: colorstobpp - Eep! too many colours: %d\n"
argument_list|,
name|colors
argument_list|)
expr_stmt|;
return|return
literal|8
return|;
block|}
return|return
name|bpp
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bpptocolors (int bpp)
name|bpptocolors
parameter_list|(
name|int
name|bpp
parameter_list|)
block|{
name|int
name|colors
decl_stmt|;
if|if
condition|(
name|bpp
operator|>
literal|8
condition|)
block|{
name|g_warning
argument_list|(
literal|"GIF: bpptocolors - Eep! bpp==%d !\n"
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
literal|256
return|;
block|}
name|colors
operator|=
literal|1
operator|<<
name|bpp
expr_stmt|;
return|return
operator|(
name|colors
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|GetPixel (int x,int y)
name|GetPixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
operator|*
operator|(
name|pixels
operator|+
operator|(
name|rowstride
operator|*
operator|(
name|long
operator|)
name|y
operator|)
operator|+
operator|(
name|long
operator|)
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * GIFENCODE.C    - GIF Image compression interface  *  * GIFEncode( FName, GHeight, GWidth, GInterlace, Background, Transparent,  *            BitsPerPixel, Red, Green, Blue, GetPixel )  *  *****************************************************************************/
end_comment

begin_decl_stmt
DECL|variable|Width
DECL|variable|Height
specifier|static
name|gint
name|Width
decl_stmt|,
name|Height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curx
DECL|variable|cury
specifier|static
name|gint
name|curx
decl_stmt|,
name|cury
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|CountDown
specifier|static
name|glong
name|CountDown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|Pass
specifier|static
name|gint
name|Pass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Bump the 'curx' and 'cury' to point to the next pixel  */
end_comment

begin_function
specifier|static
name|void
DECL|function|BumpPixel (void)
name|BumpPixel
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * Bump the current X position    */
name|curx
operator|++
expr_stmt|;
comment|/*    * If we are at the end of a scan line, set curx back to the beginning    * If we are interlaced, bump the cury to the appropriate spot,    * otherwise, just increment it.    */
if|if
condition|(
name|curx
operator|==
name|Width
condition|)
block|{
name|cur_progress
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cur_progress
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|cur_progress
operator|/
operator|(
name|double
operator|)
name|max_progress
argument_list|)
expr_stmt|;
name|curx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Interlace
condition|)
operator|++
name|cury
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|Pass
condition|)
block|{
case|case
literal|0
case|:
name|cury
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|cury
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|cury
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|cury
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the next pixel from the image  */
end_comment

begin_function
specifier|static
name|int
DECL|function|GIFNextPixel (ifunptr getpixel)
name|GIFNextPixel
parameter_list|(
name|ifunptr
name|getpixel
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|CountDown
operator|==
literal|0
condition|)
return|return
name|EOF
return|;
operator|--
name|CountDown
expr_stmt|;
name|r
operator|=
call|(
modifier|*
name|getpixel
call|)
argument_list|(
name|curx
argument_list|,
name|cury
argument_list|)
expr_stmt|;
name|BumpPixel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* public */
end_comment

begin_function
specifier|static
name|void
DECL|function|GIFEncodeHeader (FILE * fp,gboolean gif89,int GWidth,int GHeight,int Background,int BitsPerPixel,int Red[],int Green[],int Blue[],ifunptr GetPixel)
name|GIFEncodeHeader
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gboolean
name|gif89
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|Background
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|int
name|Red
index|[]
parameter_list|,
name|int
name|Green
index|[]
parameter_list|,
name|int
name|Blue
index|[]
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|)
block|{
name|int
name|B
decl_stmt|;
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
name|TopOfs
operator|=
literal|0
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write the Magic header    */
name|fwrite
argument_list|(
name|gif89
condition|?
literal|"GIF89a"
else|:
literal|"GIF87a"
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the screen width and height    */
name|Putword
argument_list|(
name|RWidth
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|RHeight
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Indicate that there is a global colour map    */
name|B
operator|=
literal|0x80
expr_stmt|;
comment|/* Yes, there is a color map */
comment|/*    * OR in the resolution    */
name|B
operator||=
operator|(
name|Resolution
operator|-
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
comment|/*    * OR in the Bits per Pixel    */
name|B
operator||=
operator|(
name|BitsPerPixel
operator|-
literal|1
operator|)
expr_stmt|;
comment|/*    * Write it out    */
name|fputc
argument_list|(
name|B
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the Background colour    */
name|fputc
argument_list|(
name|Background
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Byte of 0's (future expansion)    */
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the Global Colour Map    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ColorMapSize
condition|;
name|i
operator|++
control|)
block|{
name|fputc
argument_list|(
name|Red
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Green
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Blue
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeGraphicControlExt (FILE * fp,int Disposal,int Delay89,int NumFramesInImage,int GWidth,int GHeight,int Transparent,int BitsPerPixel,ifunptr GetPixel)
name|GIFEncodeGraphicControlExt
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|Disposal
parameter_list|,
name|int
name|Delay89
parameter_list|,
name|int
name|NumFramesInImage
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|Transparent
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|)
block|{
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
name|TopOfs
operator|=
literal|0
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write out extension for transparent colour index, if necessary.    */
if|if
condition|(
operator|(
name|Transparent
operator|>=
literal|0
operator|)
operator|||
operator|(
name|NumFramesInImage
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* Extension Introducer - fixed. */
name|fputc
argument_list|(
literal|'!'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Graphic Control Label - fixed. */
name|fputc
argument_list|(
literal|0xf9
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Block Size - fixed. */
name|fputc
argument_list|(
literal|4
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Packed Fields - XXXdddut (d=disposal, u=userInput, t=transFlag) */
comment|/*                    s8421                                        */
name|fputc
argument_list|(
operator|(
operator|(
name|Transparent
operator|>=
literal|0
operator|)
condition|?
literal|0x01
else|:
literal|0x00
operator|)
comment|/* TRANSPARENCY */
comment|/* DISPOSAL */
operator||
operator|(
operator|(
name|NumFramesInImage
operator|>
literal|1
operator|)
condition|?
operator|(
name|Disposal
operator|<<
literal|2
operator|)
else|:
literal|0x00
operator|)
argument_list|,
comment|/* 0x03 or 0x01 build frames cumulatively */
comment|/* 0x02 clears frame before drawing */
comment|/* 0x00 'don't care' */
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Delay89
operator|&
literal|255
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|Delay89
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Transparent
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeImageData (FILE * fp,int GWidth,int GHeight,int GInterlace,int BitsPerPixel,ifunptr GetPixel,gint offset_x,gint offset_y)
name|GIFEncodeImageData
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|GInterlace
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|Interlace
operator|=
name|GInterlace
expr_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
operator|(
name|int
operator|)
name|offset_x
expr_stmt|;
name|TopOfs
operator|=
operator|(
name|int
operator|)
name|offset_y
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/*    * Write an Image separator    */
block|fputc (',', fp);
comment|/*    * Write the Image header    */
block|Putword (LeftOfs, fp);   Putword (TopOfs, fp);   Putword (Width, fp);   Putword (Height, fp);
comment|/*    * Write out whether or not the image is interlaced    */
block|if (Interlace)     fputc (0x40, fp);   else     fputc (0x00, fp);
comment|/*    * Write out the initial code size    */
block|fputc (InitCodeSize, fp);
comment|/*    * Go and actually compress the data    */
block|compress (InitCodeSize + 1, fp, GetPixel);
comment|/*    * Write out a Zero-length packet (to end the series)    */
block|fputc (0, fp);
comment|/***************************/
block|Interlace = GInterlace;   ColorMapSize = 1<< BitsPerPixel;   RWidth = Width = GWidth;   RHeight = Height = GHeight;   LeftOfs = TopOfs = 0;   Resolution = BitsPerPixel;    CountDown = (long) Width *(long) Height;   Pass = 0;
comment|/*    * The initial code size    */
block|if (BitsPerPixel<= 1)     InitCodeSize = 2;   else     InitCodeSize = BitsPerPixel;
comment|/*    * Set up the current x and y position    */
block|curx = cury = 0;
endif|#
directive|endif
name|cur_progress
operator|=
literal|0
expr_stmt|;
comment|/*    * Write an Image separator    */
name|fputc
argument_list|(
literal|','
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write the Image header    */
name|Putword
argument_list|(
name|LeftOfs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|TopOfs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|Width
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|Height
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out whether or not the image is interlaced    */
if|if
condition|(
name|Interlace
condition|)
name|fputc
argument_list|(
literal|0x40
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the initial code size    */
name|fputc
argument_list|(
name|InitCodeSize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Go and actually compress the data    */
name|compress
argument_list|(
name|InitCodeSize
operator|+
literal|1
argument_list|,
name|fp
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
comment|/*    * Write out a Zero-length packet (to end the series)    */
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeClose (FILE * fp)
name|GIFEncodeClose
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
comment|/*    * Write the GIF file terminator    */
name|fputc
argument_list|(
literal|';'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * And close the file    */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeLoopExt (FILE * fp,guint num_loops)
name|GIFEncodeLoopExt
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
name|num_loops
parameter_list|)
block|{
name|fputc
argument_list|(
literal|0x21
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x0b
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"NETSCAPE2.0"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x03
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x01
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|num_loops
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* NOTE: num_loops==0 means 'loop infinitely' */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeCommentExt (FILE * fp,const gchar * comment)
name|GIFEncodeCommentExt
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|gchar
modifier|*
name|comment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|comment
operator|||
operator|!
operator|*
name|comment
condition|)
return|return;
if|if
condition|(
name|strlen
argument_list|(
name|comment
argument_list|)
operator|>
literal|240
condition|)
block|{
name|g_printerr
argument_list|(
literal|"GIF: warning:"
literal|"comment too large - comment block not written.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputc
argument_list|(
literal|0x21
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0xfe
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|strlen
argument_list|(
name|comment
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|comment
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out a word to the GIF file  */
end_comment

begin_function
specifier|static
name|void
DECL|function|Putword (int w,FILE * fp)
name|Putword
parameter_list|(
name|int
name|w
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fputc
argument_list|(
name|w
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|w
operator|/
literal|256
operator|)
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  *  GIFCOMPR.C       - GIF Image compression routines  *  *  Lempel-Ziv compression based on 'compress'.  GIF modifications by  *  David Rowley (mgardi@watdcsu.waterloo.edu)  *  ***************************************************************************/
end_comment

begin_comment
comment|/*  * General DEFINEs  */
end_comment

begin_define
DECL|macro|GIF_BITS
define|#
directive|define
name|GIF_BITS
value|12
end_define

begin_define
DECL|macro|HSIZE
define|#
directive|define
name|HSIZE
value|5003
end_define

begin_comment
DECL|macro|HSIZE
comment|/* 80% occupancy */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UCHAR
end_ifdef

begin_typedef
DECL|typedef|char_type
typedef|typedef
name|char
name|char_type
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*NO_UCHAR */
end_comment

begin_typedef
DECL|typedef|char_type
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NO_UCHAR */
end_comment

begin_comment
comment|/*   * GIF Image compression - modified 'compress'  *  * Based on: compress.c - File compression ala IEEE Computer, June 1984.  *  * By Authors:  Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)  *              Jim McKie               (decvax!mcvax!jim)  *              Steve Davies            (decvax!vax135!petsd!peora!srd)  *              Ken Turkowski           (decvax!decwrl!turtlevax!ken)  *              James A. Woods          (decvax!ihnp4!ames!jaw)  *              Joe Orost               (decvax!vax135!petsd!joe)  *  */
end_comment

begin_define
DECL|macro|ARGVAL ()
define|#
directive|define
name|ARGVAL
parameter_list|()
value|(*++(*argv) || (--argc&& *++argv))
end_define

begin_decl_stmt
DECL|variable|n_bits
specifier|static
name|int
name|n_bits
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|n_bits
comment|/* number of bits/code */
end_comment

begin_decl_stmt
DECL|variable|maxbits
specifier|static
name|int
name|maxbits
init|=
name|GIF_BITS
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxbits
comment|/* user settable max # bits/code */
end_comment

begin_decl_stmt
DECL|variable|maxcode
specifier|static
name|code_int
name|maxcode
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxcode
comment|/* maximum code, given n_bits */
end_comment

begin_decl_stmt
DECL|variable|maxmaxcode
specifier|static
name|code_int
name|maxmaxcode
init|=
operator|(
name|code_int
operator|)
literal|1
operator|<<
name|GIF_BITS
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxmaxcode
comment|/* should NEVER generate this code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_comment
comment|/* But wrong! */
end_comment

begin_define
DECL|macro|MAXCODE (Mn_bits)
define|#
directive|define
name|MAXCODE
parameter_list|(
name|Mn_bits
parameter_list|)
value|((code_int) 1<< (Mn_bits) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*COMPATIBLE */
end_comment

begin_define
DECL|macro|MAXCODE (Mn_bits)
define|#
directive|define
name|MAXCODE
parameter_list|(
name|Mn_bits
parameter_list|)
value|(((code_int) 1<< (Mn_bits)) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*COMPATIBLE */
end_comment

begin_decl_stmt
DECL|variable|htab
specifier|static
name|count_int
name|htab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|codetab
specifier|static
name|unsigned
name|short
name|codetab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|HashTabOf (i)
define|#
directive|define
name|HashTabOf
parameter_list|(
name|i
parameter_list|)
value|htab[i]
end_define

begin_define
DECL|macro|CodeTabOf (i)
define|#
directive|define
name|CodeTabOf
parameter_list|(
name|i
parameter_list|)
value|codetab[i]
end_define

begin_decl_stmt
DECL|variable|hsize
specifier|static
specifier|const
name|code_int
name|hsize
init|=
name|HSIZE
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|hsize
comment|/* the original reason for this being 				   variable was "for dynamic table sizing", 				   but since it was never actually changed 				   I made it const   --Adam. */
end_comment

begin_comment
comment|/*  * To save much memory, we overlay the table used by compress() with those  * used by decompress().  The tab_prefix table is the same size and type  * as the codetab.  The tab_suffix table needs 2**GIF_BITS characters.  We  * get this from the beginning of htab.  The output stack uses the rest  * of htab, and contains characters.  There is plenty of room for any  * possible stack (stack used to be 8000 characters).  */
end_comment

begin_define
DECL|macro|tab_prefixof (i)
define|#
directive|define
name|tab_prefixof
parameter_list|(
name|i
parameter_list|)
value|CodeTabOf(i)
end_define

begin_define
DECL|macro|tab_suffixof (i)
define|#
directive|define
name|tab_suffixof
parameter_list|(
name|i
parameter_list|)
value|((char_type*)(htab))[i]
end_define

begin_define
DECL|macro|de_stack
define|#
directive|define
name|de_stack
value|((char_type*)&tab_suffixof((code_int)1<<GIF_BITS))
end_define

begin_decl_stmt
DECL|variable|free_ent
specifier|static
name|code_int
name|free_ent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|free_ent
comment|/* first unused entry */
end_comment

begin_comment
comment|/*  * block compression parameters -- after all codes are used up,  * and compression rate changes, start over.  */
end_comment

begin_decl_stmt
DECL|variable|clear_flg
specifier|static
name|int
name|clear_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|offset
specifier|static
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|in_count
specifier|static
name|long
name|int
name|in_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|in_count
comment|/* length of input */
end_comment

begin_decl_stmt
DECL|variable|out_count
specifier|static
name|long
name|int
name|out_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|out_count
comment|/* # of codes output (for debugging) */
end_comment

begin_comment
comment|/*  * compress stdin to stdout  *  * Algorithm:  use open addressing double hashing (no chaining) on the  * prefix code / next character combination.  We do a variant of Knuth's  * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime  * secondary probe.  Here, the modular division first probe is gives way  * to a faster exclusive-or manipulation.  Also do block compression with  * an adaptive reset, whereby the code table is cleared when the compression  * ratio decreases, but after the table fills.  The variable-length output  * codes are re-sized at this point, and a special CLEAR code is generated  * for the decompressor.  Late addition:  construct the table according to  * file size for noticeable speed improvement on small files.  Please direct  * questions about this implementation to ames!jaw.  */
end_comment

begin_decl_stmt
DECL|variable|g_init_bits
specifier|static
name|int
name|g_init_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|g_outfile
specifier|static
name|FILE
modifier|*
name|g_outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ClearCode
specifier|static
name|int
name|ClearCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|EOFCode
specifier|static
name|int
name|EOFCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_accum
specifier|static
name|unsigned
name|long
name|cur_accum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_bits
specifier|static
name|int
name|cur_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|masks
specifier|static
name|unsigned
name|long
name|masks
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000F
block|,
literal|0x001F
block|,
literal|0x003F
block|,
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x01FF
block|,
literal|0x03FF
block|,
literal|0x07FF
block|,
literal|0x0FFF
block|,
literal|0x1FFF
block|,
literal|0x3FFF
block|,
literal|0x7FFF
block|,
literal|0xFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|compress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|compress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GIF_UN
name|nocompress
argument_list|(
name|init_bits
argument_list|,
name|outfile
argument_list|,
name|ReadValue
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|GIF_RLE
name|rlecompress
argument_list|(
name|init_bits
argument_list|,
name|outfile
argument_list|,
name|ReadValue
argument_list|)
expr_stmt|;
else|#
directive|else
name|normalcompress
argument_list|(
name|init_bits
argument_list|,
name|outfile
argument_list|,
name|ReadValue
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GIF_UN
end_ifdef

begin_function
specifier|static
name|void
DECL|function|nocompress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|nocompress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|ent
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|GIF_RLE
specifier|static
name|void
DECL|function|rlecompress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|rlecompress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|last
operator|=
name|ent
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|last
operator|==
name|c
condition|)
block|{
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
block|}
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|last
operator|=
name|ent
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
specifier|static
name|void
DECL|function|normalcompress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|normalcompress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|ent
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/*****************************************************************  * TAG( output )  *  * Output the given code.  * Inputs:  *      code:   A n_bits-bit integer.  If == -1, then EOF.  This assumes  *              that n_bits =< (long)wordsize - 1.  * Outputs:  *      Outputs code to the file.  * Assumptions:  *      Chars are 8 bits long.  * Algorithm:  *      Maintain a GIF_BITS character long buffer (so that 8 codes will  * fit in it exactly).  Use the VAX insv instruction to insert each  * code in turn.  When the buffer fills up empty it and start over.  */
specifier|static
name|void
DECL|function|output (code_int code)
name|output
parameter_list|(
name|code_int
name|code
parameter_list|)
block|{
name|cur_accum
operator|&=
name|masks
index|[
name|cur_bits
index|]
expr_stmt|;
if|if
condition|(
name|cur_bits
operator|>
literal|0
condition|)
name|cur_accum
operator||=
operator|(
operator|(
name|long
operator|)
name|code
operator|<<
name|cur_bits
operator|)
expr_stmt|;
else|else
name|cur_accum
operator|=
name|code
expr_stmt|;
name|cur_bits
operator|+=
name|n_bits
expr_stmt|;
while|while
condition|(
name|cur_bits
operator|>=
literal|8
condition|)
block|{
name|char_out
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cur_accum
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|cur_accum
operator|>>=
literal|8
expr_stmt|;
name|cur_bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/*    * If the next entry is going to be too big for the code size,    * then increase it, if possible.    */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
operator|||
name|clear_flg
condition|)
block|{
if|if
condition|(
name|clear_flg
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|g_init_bits
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|n_bits
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|EOFCode
condition|)
block|{
comment|/*        * At EOF, write the rest of the buffer.        */
while|while
condition|(
name|cur_bits
operator|>
literal|0
condition|)
block|{
name|char_out
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cur_accum
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|cur_accum
operator|>>=
literal|8
expr_stmt|;
name|cur_bits
operator|-=
literal|8
expr_stmt|;
block|}
name|flush_char
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|g_outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|g_outfile
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  * Clear out the hash table  */
specifier|static
name|void
DECL|function|cl_block (void)
name|cl_block
parameter_list|(
name|void
parameter_list|)
comment|/* table clear for block compress */
block|{
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|)
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|cl_hash (count_int hsize)
name|cl_hash
parameter_list|(
name|count_int
name|hsize
parameter_list|)
comment|/* reset code table */
block|{
specifier|register
name|count_int
modifier|*
name|htab_p
init|=
name|htab
operator|+
name|hsize
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|long
name|m1
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
name|hsize
operator|-
literal|16
expr_stmt|;
do|do
block|{
comment|/* might use Sys V memset(3) here */
operator|*
operator|(
name|htab_p
operator|-
literal|16
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|15
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|14
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|13
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|12
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|11
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|10
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|9
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|8
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|7
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|6
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|5
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|4
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|3
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|2
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|1
operator|)
operator|=
name|m1
expr_stmt|;
name|htab_p
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|-=
literal|16
operator|)
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|+=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
operator|--
name|htab_p
operator|=
name|m1
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|writeerr (void)
name|writeerr
parameter_list|(
name|void
parameter_list|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Error writing output file."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/******************************************************************************  *  * GIF Specific routines  *  ******************************************************************************/
comment|/*  * Number of characters so far in this 'packet'  */
DECL|variable|a_count
specifier|static
name|int
name|a_count
decl_stmt|;
comment|/*  * Set up the 'byte output' routine  */
specifier|static
name|void
DECL|function|char_init (void)
name|char_init
parameter_list|(
name|void
parameter_list|)
block|{
name|a_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Define the storage for the packet accumulator  */
DECL|variable|accum
specifier|static
name|char
name|accum
index|[
literal|256
index|]
decl_stmt|;
comment|/*  * Add a character to the end of the current packet, and if it is 254  * characters, flush the packet to disk.  */
specifier|static
name|void
DECL|function|char_out (int c)
name|char_out
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|accum
index|[
name|a_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|a_count
operator|>=
literal|254
condition|)
name|flush_char
argument_list|()
expr_stmt|;
block|}
comment|/*  * Flush the packet to disk, and reset the accumulator  */
specifier|static
name|void
DECL|function|flush_char (void)
name|flush_char
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|a_count
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
name|a_count
argument_list|,
name|g_outfile
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|accum
argument_list|,
literal|1
argument_list|,
name|a_count
argument_list|,
name|g_outfile
argument_list|)
expr_stmt|;
name|a_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  Save interface functions  */
specifier|static
name|void
DECL|function|comment_entry_callback (GtkTextBuffer * buffer)
name|comment_entry_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|GtkTextIter
name|start_iter
decl_stmt|;
name|GtkTextIter
name|end_iter
decl_stmt|;
name|gchar
modifier|*
name|text
decl_stmt|;
name|gtk_text_buffer_get_bounds
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_text_buffer_get_text
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|>
literal|240
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The default comment is limited to %d characters."
argument_list|)
argument_list|,
literal|240
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_iter_at_offset
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
literal|240
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_end_iter
argument_list|(
name|buffer
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
comment|/*  this calls us recursivaly, but in the else branch        */
name|gtk_text_buffer_delete
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
name|globalcomment
operator|=
name|g_strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|comment_was_edited
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

