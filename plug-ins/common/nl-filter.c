begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************  * file: nlfilt/nlfilt.c  *  * Copyright (c) 1997 Eric L. Hernes (erich@rrnet.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Algorithm fixes, V2.0 compatibility by David Hodson  hodsond@ozemail.com.au  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|PLUG_IN_PROC
define|#
directive|define
name|PLUG_IN_PROC
value|"plug-in-nlfilt"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"nl-filter"
end_define

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon296881bd0108
block|{
DECL|member|alpha
name|gdouble
name|alpha
decl_stmt|;
DECL|member|radius
name|gdouble
name|radius
decl_stmt|;
DECL|member|filter
name|gint
name|filter
decl_stmt|;
DECL|typedef|NLFilterValues
block|}
name|NLFilterValues
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon296881bd0203
block|{
DECL|enumerator|filter_alpha_trim
name|filter_alpha_trim
block|,
DECL|enumerator|filter_opt_est
name|filter_opt_est
block|,
DECL|enumerator|filter_edge_enhance
name|filter_edge_enhance
DECL|typedef|FilterType
block|}
name|FilterType
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|nlfvals
specifier|static
name|NLFilterValues
name|nlfvals
init|=
block|{
literal|0.3
block|,
literal|0.3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function protos */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|retvals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlfilter
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|nlfilter_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gint
name|nlfiltInit
parameter_list|(
name|gdouble
name|alpha
parameter_list|,
name|gdouble
name|radius
parameter_list|,
name|FilterType
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|nlfiltRow
parameter_list|(
name|guchar
modifier|*
name|srclast
parameter_list|,
name|guchar
modifier|*
name|srcthis
parameter_list|,
name|guchar
modifier|*
name|srcnext
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|filtno
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"img"
block|,
literal|"The Image to Filter"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drw"
block|,
literal|"The Drawable"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"alpha"
block|,
literal|"The amount of the filter to apply"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"radius"
block|,
literal|"The filter radius"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"filter"
block|,
literal|"The Filter to Run, "
literal|"0 - alpha trimmed mean; "
literal|"1 - optimal estimation (alpha controls noise variance); "
literal|"2 - edge enhancement"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|PLUG_IN_PROC
argument_list|,
name|N_
argument_list|(
literal|"Nonlinear swiss army knife filter"
argument_list|)
argument_list|,
literal|"This is the pnmnlfilt, in gimp's clothing.  "
literal|"See the pnmnlfilt manpage for details."
argument_list|,
literal|"Graeme W. Gill, gimp 0.99 plugin by Eric L. Hernes"
argument_list|,
literal|"Graeme W. Gill, Eric L. Hernes"
argument_list|,
literal|"1997"
argument_list|,
name|N_
argument_list|(
literal|"_NL Filter..."
argument_list|)
argument_list|,
literal|"RGB,GRAY"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_plugin_menu_register
argument_list|(
name|PLUG_IN_PROC
argument_list|,
literal|"<Image>/Filters/Enhance"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|nlfvals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nlfilter_dialog
argument_list|(
name|drawable
argument_list|)
condition|)
return|return;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
if|if
condition|(
name|nparams
operator|!=
literal|6
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|nlfvals
operator|.
name|alpha
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|nlfvals
operator|.
name|radius
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|nlfvals
operator|.
name|filter
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|nlfvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
name|nlfilter
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Store data */
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|nlfvals
argument_list|,
sizeof|sizeof
argument_list|(
name|NLFilterValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pnmnlfilt.c - 4 in 1 (2 non-linear) filter **             - smooth an anyimage **             - do alpha trimmed mean filtering on an anyimage **             - do optimal estimation smoothing on an anyimage **             - do edge enhancement on an anyimage ** ** Version 1.0 ** ** The implementation of an alpha-trimmed mean filter ** is based on the description in IEEE CG&A May 1990 ** Page 23 by Mark E. Lee and Richard A. Redner. ** ** The paper recommends using a hexagon sampling region around each ** pixel being processed, allowing an effective sub pixel radius to be ** specified. The hexagon values are sythesised by area sampling the ** rectangular pixels with a hexagon grid. The seven hexagon values ** obtained from the 3x3 pixel grid are used to compute the alpha ** trimmed mean. Note that an alpha value of 0.0 gives a conventional ** mean filter (where the radius controls the contribution of ** surrounding pixels), while a value of 0.5 gives a median filter. ** Although there are only seven values to trim from before finding ** the mean, the algorithm has been extended from that described in ** CG&A by using interpolation, to allow a continuous selection of ** alpha value between and including 0.0 to 0.5  The useful values ** for radius are between 0.3333333 (where the filter will have no ** effect because only one pixel is sampled), to 1.0, where all ** pixels in the 3x3 grid are sampled. ** ** The optimal estimation filter is taken from an article "Converting Dithered ** Images Back to Gray Scale" by Allen Stenger, Dr Dobb's Journal, November ** 1992, and this article references "Digital Image Enhancement andNoise Filtering by ** Use of Local Statistics", Jong-Sen Lee, IEEE Transactions on Pattern Analysis and ** Machine Intelligence, March 1980. ** ** Also borrow the  technique used in pgmenhance(1) to allow edge ** enhancement if the alpha value is negative. ** ** Author: **         Graeme W. Gill, 30th Jan 1993 **         graeme@labtam.oz.au ** ** Permission is hereby granted, to use, copy, modify, distribute, ** and sell this software and its associated documentation files ** (the "Software") for any purpose without fee, provided ** that: ** **     1) The above copyright notices and this permission notice **        accompany all source code copies of the Software and **        related documentation. ** and ** **     2) If executable code based on the Software only is distributed, **        then the accompanying documentation must acknowledge that **        "this software is based in part on the work of Graeme W. Gill". ** and ** **     3) It is accepted that Graeme W. Gill (the "Author") accepts **        NO LIABILITY for damages of any kind.  The Software is **        provided without fee by the Author "AS-IS" and without **        warranty of any kind, express, implied or otherwise, **        including without limitation, any warranty of merchantability **        or fitness for a particular purpose. ** and ** **     4) These conditions apply to any software derived from or based **        on the Software, not just to the unmodified library. ** */
end_comment

begin_comment
comment|/* ************************************************** */
end_comment

begin_comment
comment|/* Hexagon intersecting square area functions */
end_comment

begin_comment
comment|/* Compute the area of the intersection of a triangle */
end_comment

begin_comment
comment|/* and a rectangle */
end_comment

begin_function_decl
specifier|static
name|gdouble
name|triang_area
parameter_list|(
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
name|rectang_area
parameter_list|(
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
name|hex_area
parameter_list|(
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|atfilt0
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|atfilt1
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|atfilt2
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|atfilt3
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|atfilt4
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|atfilt5
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|atfuncs
name|gint
function_decl|(
modifier|*
name|atfuncs
index|[
literal|6
index|]
function_decl|)
parameter_list|(
name|gint
modifier|*
parameter_list|)
init|=
block|{
name|atfilt0
operator|,
function_decl|atfilt1
operator|,
function_decl|atfilt2
operator|,
function_decl|atfilt3
operator|,
function_decl|atfilt4
operator|,
function_decl|atfilt5
end_function_decl

begin_decl_stmt
unit|};
DECL|variable|noisevariance
specifier|static
name|gint
name|noisevariance
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|MXIVAL
define|#
directive|define
name|MXIVAL
value|255
end_define

begin_comment
DECL|macro|MXIVAL
comment|/* maximum input value */
end_comment

begin_define
DECL|macro|NOIVAL
define|#
directive|define
name|NOIVAL
value|(MXIVAL + 1)
end_define

begin_comment
DECL|macro|NOIVAL
comment|/* number of possible input values */
end_comment

begin_define
DECL|macro|SCALEB
define|#
directive|define
name|SCALEB
value|8
end_define

begin_comment
DECL|macro|SCALEB
comment|/* scale bits */
end_comment

begin_define
DECL|macro|SCALE
define|#
directive|define
name|SCALE
value|(1<< SCALEB)
end_define

begin_comment
DECL|macro|SCALE
comment|/* scale factor */
end_comment

begin_define
DECL|macro|CSCALEB
define|#
directive|define
name|CSCALEB
value|2
end_define

begin_comment
DECL|macro|CSCALEB
comment|/* coarse scale bits */
end_comment

begin_define
DECL|macro|CSCALE
define|#
directive|define
name|CSCALE
value|(1<< CSCALEB)
end_define

begin_comment
DECL|macro|CSCALE
comment|/* coarse scale factor */
end_comment

begin_define
DECL|macro|MXCSVAL
define|#
directive|define
name|MXCSVAL
value|(MXIVAL * CSCALE)
end_define

begin_comment
DECL|macro|MXCSVAL
comment|/* maximum coarse scaled values */
end_comment

begin_define
DECL|macro|NOCSVAL
define|#
directive|define
name|NOCSVAL
value|(MXCSVAL + 1)
end_define

begin_comment
DECL|macro|NOCSVAL
comment|/* number of coarse scaled values */
end_comment

begin_define
DECL|macro|SCTOCSC (x)
define|#
directive|define
name|SCTOCSC
parameter_list|(
name|x
parameter_list|)
value|((x)>> (SCALEB - CSCALEB))
end_define

begin_comment
DECL|macro|SCTOCSC (x)
comment|/* convert from scaled to coarse scaled */
end_comment

begin_define
DECL|macro|CSCTOSC (x)
define|#
directive|define
name|CSCTOSC
parameter_list|(
name|x
parameter_list|)
value|((x)<< (SCALEB - CSCALEB))
end_define

begin_comment
DECL|macro|CSCTOSC (x)
comment|/* convert from course scaled to scaled */
end_comment

begin_comment
comment|/* round and scale floating point to scaled integer */
end_comment

begin_define
DECL|macro|SROUND (x)
define|#
directive|define
name|SROUND
parameter_list|(
name|x
parameter_list|)
value|((gint)(((x) * (gdouble)SCALE) + 0.5))
end_define

begin_comment
comment|/* round and un-scale scaled integer value */
end_comment

begin_define
DECL|macro|RUNSCALE (x)
define|#
directive|define
name|RUNSCALE
parameter_list|(
name|x
parameter_list|)
value|(((x) + (1<< (SCALEB-1)))>> SCALEB)
end_define

begin_comment
DECL|macro|RUNSCALE (x)
comment|/* rounded un-scale */
end_comment

begin_define
DECL|macro|UNSCALE (x)
define|#
directive|define
name|UNSCALE
parameter_list|(
name|x
parameter_list|)
value|((x)>> SCALEB)
end_define

begin_comment
comment|/* Note: modified by David Hodson, nlfiltRow now accesses  * srclast, srcthis, and srcnext from [-bpp] to [width*bpp-1].  * Beware if you use this code anywhere else!  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
DECL|function|nlfiltRow (guchar * srclast,guchar * srcthis,guchar * srcnext,guchar * dst,gint width,gint bpp,gint filtno)
name|nlfiltRow
parameter_list|(
name|guchar
modifier|*
name|srclast
parameter_list|,
name|guchar
modifier|*
name|srcthis
parameter_list|,
name|guchar
modifier|*
name|srcnext
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|bpp
parameter_list|,
name|gint
name|filtno
parameter_list|)
block|{
name|gint
name|pf
index|[
literal|9
index|]
decl_stmt|;
name|guchar
modifier|*
name|ip0
decl_stmt|,
modifier|*
name|ip1
decl_stmt|,
modifier|*
name|ip2
decl_stmt|,
modifier|*
name|or
decl_stmt|,
modifier|*
name|orend
decl_stmt|;
name|or
operator|=
name|dst
expr_stmt|;
name|orend
operator|=
name|dst
operator|+
name|width
operator|*
name|bpp
expr_stmt|;
name|ip0
operator|=
name|srclast
expr_stmt|;
name|ip1
operator|=
name|srcthis
expr_stmt|;
name|ip2
operator|=
name|srcnext
expr_stmt|;
for|for
control|(
name|or
operator|=
name|dst
init|;
name|or
operator|<
name|orend
condition|;
name|ip0
operator|++
operator|,
name|ip1
operator|++
operator|,
name|ip2
operator|++
operator|,
name|or
operator|++
control|)
block|{
name|pf
index|[
literal|0
index|]
operator|=
operator|*
name|ip1
expr_stmt|;
name|pf
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|ip1
operator|-
name|bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|2
index|]
operator|=
operator|*
operator|(
name|ip2
operator|-
name|bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|3
index|]
operator|=
operator|*
operator|(
name|ip2
operator|)
expr_stmt|;
name|pf
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|ip2
operator|+
name|bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|5
index|]
operator|=
operator|*
operator|(
name|ip1
operator|+
name|bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|6
index|]
operator|=
operator|*
operator|(
name|ip0
operator|+
name|bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|7
index|]
operator|=
operator|*
operator|(
name|ip0
operator|)
expr_stmt|;
name|pf
index|[
literal|8
index|]
operator|=
operator|*
operator|(
name|ip0
operator|-
name|bpp
operator|)
expr_stmt|;
operator|*
name|or
operator|=
operator|(
name|atfuncs
index|[
name|filtno
index|]
operator|)
operator|(
name|pf
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We restrict radius to the values: 0.333333<= radius<= 1.0 */
end_comment

begin_comment
comment|/* so that no fewer and no more than a 3x3 grid of pixels around */
end_comment

begin_comment
comment|/* the pixel in question needs to be read. Given this, we only */
end_comment

begin_comment
comment|/* need 3 or 4 weightings per hexagon, as follows: */
end_comment

begin_comment
comment|/*                  _ _                         */
end_comment

begin_comment
comment|/* Virtical hex:   |_|_|  1 2                   */
end_comment

begin_comment
comment|/*                 |X|_|  0 3                   */
end_comment

begin_comment
comment|/*                                       _      */
end_comment

begin_comment
comment|/*              _                      _|_|   1 */
end_comment

begin_comment
comment|/* Middle hex: |_| 1  Horizontal hex: |X|_| 0 2 */
end_comment

begin_comment
comment|/*             |X| 0                    |_|   3 */
end_comment

begin_comment
comment|/*             |_| 2                            */
end_comment

begin_comment
comment|/* all filters */
end_comment

begin_decl_stmt
DECL|variable|V0
DECL|variable|V1
DECL|variable|V2
DECL|variable|V3
name|gint
name|V0
index|[
name|NOIVAL
index|]
decl_stmt|,
name|V1
index|[
name|NOIVAL
index|]
decl_stmt|,
name|V2
index|[
name|NOIVAL
index|]
decl_stmt|,
name|V3
index|[
name|NOIVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|V0
DECL|variable|V1
DECL|variable|V2
DECL|variable|V3
comment|/* vertical hex */
end_comment

begin_decl_stmt
DECL|variable|M0
DECL|variable|M1
DECL|variable|M2
name|gint
name|M0
index|[
name|NOIVAL
index|]
decl_stmt|,
name|M1
index|[
name|NOIVAL
index|]
decl_stmt|,
name|M2
index|[
name|NOIVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|M0
DECL|variable|M1
DECL|variable|M2
comment|/* middle hex */
end_comment

begin_decl_stmt
DECL|variable|H0
DECL|variable|H1
DECL|variable|H2
DECL|variable|H3
name|gint
name|H0
index|[
name|NOIVAL
index|]
decl_stmt|,
name|H1
index|[
name|NOIVAL
index|]
decl_stmt|,
name|H2
index|[
name|NOIVAL
index|]
decl_stmt|,
name|H3
index|[
name|NOIVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|H0
DECL|variable|H1
DECL|variable|H2
DECL|variable|H3
comment|/* horizontal hex */
end_comment

begin_comment
comment|/* alpha trimmed and edge enhancement only */
end_comment

begin_decl_stmt
DECL|variable|ALFRAC
name|gint
name|ALFRAC
index|[
name|NOIVAL
operator|*
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|ALFRAC
comment|/* fractional alpha divider table */
end_comment

begin_comment
comment|/* optimal estimation only */
end_comment

begin_decl_stmt
DECL|variable|AVEDIV
name|gint
name|AVEDIV
index|[
literal|7
operator|*
name|NOCSVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|AVEDIV
comment|/* divide by 7 to give average value */
end_comment

begin_decl_stmt
DECL|variable|SQUARE
name|gint
name|SQUARE
index|[
literal|2
operator|*
name|NOCSVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|SQUARE
comment|/* scaled square lookup table */
end_comment

begin_comment
comment|/* Table initialisation function - return alpha range */
end_comment

begin_function
specifier|static
specifier|inline
name|gint
DECL|function|nlfiltInit (gdouble alpha,gdouble radius,FilterType filter)
name|nlfiltInit
parameter_list|(
name|gdouble
name|alpha
parameter_list|,
name|gdouble
name|radius
parameter_list|,
name|FilterType
name|filter
parameter_list|)
block|{
name|gint
name|alpharange
decl_stmt|;
comment|/* alpha range value 0 - 3 */
name|gdouble
name|meanscale
decl_stmt|;
comment|/* scale for finding mean */
name|gdouble
name|mmeanscale
decl_stmt|;
comment|/* scale for finding mean - midle hex */
name|gdouble
name|alphafraction
decl_stmt|;
comment|/* fraction of next largest/smallest                              *  to subtract from sum                              */
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|filter_alpha_trim
case|:
block|{
name|gdouble
name|noinmean
decl_stmt|;
comment|/* alpha only makes sense in range 0.0 - 0.5 */
name|alpha
operator|/=
literal|2.0
expr_stmt|;
comment|/* number of elements (out of a possible 7) used in the mean */
name|noinmean
operator|=
operator|(
operator|(
literal|0.5
operator|-
name|alpha
operator|)
operator|*
literal|12.0
operator|)
operator|+
literal|1.0
expr_stmt|;
name|mmeanscale
operator|=
name|meanscale
operator|=
literal|1.0
operator|/
name|noinmean
expr_stmt|;
if|if
condition|(
name|alpha
operator|==
literal|0.0
condition|)
block|{
comment|/* mean filter */
name|alpharange
operator|=
literal|0
expr_stmt|;
name|alphafraction
operator|=
literal|0.0
expr_stmt|;
comment|/* not used */
block|}
elseif|else
if|if
condition|(
name|alpha
operator|<
operator|(
literal|1.0
operator|/
literal|6.0
operator|)
condition|)
block|{
comment|/* mean of 5 to 7 middle values */
name|alpharange
operator|=
literal|1
expr_stmt|;
name|alphafraction
operator|=
operator|(
literal|7.0
operator|-
name|noinmean
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alpha
operator|<
operator|(
literal|1.0
operator|/
literal|3.0
operator|)
condition|)
block|{
comment|/* mean of 3 to 5 middle values */
name|alpharange
operator|=
literal|2
expr_stmt|;
name|alphafraction
operator|=
operator|(
literal|5.0
operator|-
name|noinmean
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
else|else
block|{
comment|/* mean of 1 to 3 middle values */
comment|/* alpha==0.5  => median filter */
name|alpharange
operator|=
literal|3
expr_stmt|;
name|alphafraction
operator|=
operator|(
literal|3.0
operator|-
name|noinmean
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|filter_opt_est
case|:
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|noinmean
init|=
literal|7.0
decl_stmt|;
comment|/* edge enhancement function */
name|alpharange
operator|=
literal|5
expr_stmt|;
comment|/* compute scaled hex values */
name|mmeanscale
operator|=
name|meanscale
operator|=
literal|1.0
expr_stmt|;
comment|/* Set up 1:1 division lookup - not used */
name|alphafraction
operator|=
literal|1.0
operator|/
name|noinmean
expr_stmt|;
comment|/* estimate of noise variance */
name|noisevariance
operator|=
name|alpha
operator|*
operator|(
name|gdouble
operator|)
literal|255
expr_stmt|;
name|noisevariance
operator|=
name|noisevariance
operator|*
name|noisevariance
operator|/
literal|8.0
expr_stmt|;
comment|/* set yp optimal estimation specific stuff */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|7
operator|*
name|NOCSVAL
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* divide scaled value by 7 lookup */
name|AVEDIV
index|[
name|i
index|]
operator|=
name|CSCTOSC
argument_list|(
name|i
argument_list|)
operator|/
literal|7
expr_stmt|;
comment|/* scaled divide by 7 */
block|}
comment|/* compute square and rescale by                * (val>> (2 * SCALEB + 2)) table                */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|2
operator|*
name|NOCSVAL
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|val
decl_stmt|;
comment|/* NOCSVAL offset to cope with -ve input values */
name|val
operator|=
name|CSCTOSC
argument_list|(
name|i
operator|-
name|NOCSVAL
argument_list|)
expr_stmt|;
name|SQUARE
index|[
name|i
index|]
operator|=
operator|(
name|val
operator|*
name|val
operator|)
operator|>>
operator|(
literal|2
operator|*
name|SCALEB
operator|+
literal|2
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|filter_edge_enhance
case|:
block|{
if|if
condition|(
name|alpha
operator|==
literal|1.0
condition|)
name|alpha
operator|=
literal|0.99
expr_stmt|;
name|alpharange
operator|=
literal|4
expr_stmt|;
comment|/* mean of 7 and scaled by -alpha/(1-alpha) */
name|meanscale
operator|=
literal|1.0
operator|*
operator|(
operator|-
name|alpha
operator|/
operator|(
operator|(
literal|1.0
operator|-
name|alpha
operator|)
operator|*
literal|7.0
operator|)
operator|)
expr_stmt|;
comment|/* middle pixel has 1/(1-alpha) as well */
name|mmeanscale
operator|=
literal|1.0
operator|*
operator|(
literal|1.0
operator|/
operator|(
literal|1.0
operator|-
name|alpha
operator|)
operator|+
name|meanscale
operator|)
expr_stmt|;
name|alphafraction
operator|=
literal|0.0
expr_stmt|;
comment|/* not used */
block|}
break|break;
default|default:
name|g_printerr
argument_list|(
literal|"unknown filter %d\n"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*         * Setup pixel weighting tables -         * note we pre-compute mean division here too.         */
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|hexhoff
decl_stmt|,
name|hexvoff
decl_stmt|;
name|gdouble
name|tabscale
decl_stmt|,
name|mtabscale
decl_stmt|;
name|gdouble
name|v0
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|,
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|;
comment|/* horizontal offset of virtical hex centers */
name|hexhoff
operator|=
name|radius
operator|/
literal|2
expr_stmt|;
comment|/* vertical offset of virtical hex centers */
name|hexvoff
operator|=
literal|3.0
operator|*
name|radius
operator|/
name|sqrt
argument_list|(
literal|12.0
argument_list|)
expr_stmt|;
comment|/*            * scale tables to normalise by hexagon            * area, and number of hexes used in mean            */
name|tabscale
operator|=
name|meanscale
operator|/
operator|(
name|radius
operator|*
name|hexvoff
operator|)
expr_stmt|;
name|mtabscale
operator|=
name|mmeanscale
operator|/
operator|(
name|radius
operator|*
name|hexvoff
operator|)
expr_stmt|;
name|v0
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|v1
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|v2
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|v3
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|m0
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|mtabscale
expr_stmt|;
name|m1
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|mtabscale
expr_stmt|;
name|m2
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|mtabscale
expr_stmt|;
name|h0
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|h1
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|h2
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|h3
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MXIVAL
condition|;
name|i
operator|++
control|)
block|{
name|gdouble
name|fi
decl_stmt|;
name|fi
operator|=
operator|(
name|gdouble
operator|)
name|i
expr_stmt|;
name|V0
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v0
argument_list|)
expr_stmt|;
name|V1
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v1
argument_list|)
expr_stmt|;
name|V2
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v2
argument_list|)
expr_stmt|;
name|V3
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v3
argument_list|)
expr_stmt|;
name|M0
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|m0
argument_list|)
expr_stmt|;
name|M1
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|m1
argument_list|)
expr_stmt|;
name|M2
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|m2
argument_list|)
expr_stmt|;
name|H0
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h0
argument_list|)
expr_stmt|;
name|H1
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h1
argument_list|)
expr_stmt|;
name|H2
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h2
argument_list|)
expr_stmt|;
name|H3
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h3
argument_list|)
expr_stmt|;
block|}
comment|/* set up alpha fraction lookup table used on big/small */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|NOIVAL
operator|*
literal|8
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ALFRAC
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
operator|(
name|gdouble
operator|)
name|i
operator|*
name|alphafraction
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|alpharange
return|;
block|}
end_function

begin_comment
comment|/* Core pixel processing function - hand it 3x3 pixels and return result. */
end_comment

begin_comment
comment|/* Mean filter */
end_comment

begin_function
specifier|static
name|gint
DECL|function|atfilt0 (gint32 * p)
name|atfilt0
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|retv
decl_stmt|;
comment|/* map to scaled hexagon values */
name|retv
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
return|return
name|UNSCALE
argument_list|(
name|retv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mean of 5 - 7 middle values */
end_comment

begin_function
specifier|static
name|gint
DECL|function|atfilt1 (gint32 * p)
name|atfilt1
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
name|gint
name|big
decl_stmt|,
name|small
decl_stmt|;
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* sum values and also discover the largest and smallest */
name|big
operator|=
name|small
operator|=
name|h0
expr_stmt|;
DECL|macro|CHECK (xx)
define|#
directive|define
name|CHECK
parameter_list|(
name|xx
parameter_list|)
define|\
value|h0 += xx; \         if (xx> big) \                 big = xx; \         else if (xx< small) \                 small = xx;
name|CHECK
argument_list|(
argument|h1
argument_list|)
name|CHECK
argument_list|(
argument|h2
argument_list|)
name|CHECK
argument_list|(
argument|h3
argument_list|)
name|CHECK
argument_list|(
argument|h4
argument_list|)
name|CHECK
argument_list|(
argument|h5
argument_list|)
name|CHECK
argument_list|(
argument|h6
argument_list|)
undef|#
directive|undef
name|CHECK
comment|/* Compute mean of middle 5-7 values */
return|return
name|UNSCALE
argument_list|(
name|h0
operator|-
name|ALFRAC
index|[
operator|(
name|big
operator|+
name|small
operator|)
operator|>>
name|SCALEB
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mean of 3 - 5 middle values */
end_comment

begin_function
specifier|static
name|gint
DECL|function|atfilt2 (gint32 * p)
name|atfilt2
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
name|gint
name|big0
decl_stmt|,
name|big1
decl_stmt|,
name|small0
decl_stmt|,
name|small1
decl_stmt|;
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* sum values and also discover the 2 largest and 2 smallest */
name|big0
operator|=
name|small0
operator|=
name|h0
expr_stmt|;
name|small1
operator|=
name|G_MAXINT
expr_stmt|;
name|big1
operator|=
literal|0
expr_stmt|;
DECL|macro|CHECK (xx)
define|#
directive|define
name|CHECK
parameter_list|(
name|xx
parameter_list|)
define|\
value|h0 += xx; \         if (xx> big1) \                 { \                 if (xx> big0) \                         { \                         big1 = big0; \                         big0 = xx; \                         } \                 else \                         big1 = xx; \                 } \         if (xx< small1) \                 { \                 if (xx< small0) \                         { \                         small1 = small0; \                         small0 = xx; \                         } \                 else \                         small1 = xx; \                 }
name|CHECK
argument_list|(
argument|h1
argument_list|)
name|CHECK
argument_list|(
argument|h2
argument_list|)
name|CHECK
argument_list|(
argument|h3
argument_list|)
name|CHECK
argument_list|(
argument|h4
argument_list|)
name|CHECK
argument_list|(
argument|h5
argument_list|)
name|CHECK
argument_list|(
argument|h6
argument_list|)
undef|#
directive|undef
name|CHECK
comment|/* Compute mean of middle 3-5 values */
return|return
name|UNSCALE
argument_list|(
name|h0
operator|-
name|big0
operator|-
name|small0
operator|-
name|ALFRAC
index|[
operator|(
name|big1
operator|+
name|small1
operator|)
operator|>>
name|SCALEB
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mean of 1 - 3 middle values.  * If only 1 value, then this is a median filter.  */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|atfilt3 (gint32 * p)
name|atfilt3
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
name|gint
name|big0
decl_stmt|,
name|big1
decl_stmt|,
name|big2
decl_stmt|,
name|small0
decl_stmt|,
name|small1
decl_stmt|,
name|small2
decl_stmt|;
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* sum values and also discover the 3 largest and 3 smallest */
name|big0
operator|=
name|small0
operator|=
name|h0
expr_stmt|;
name|small1
operator|=
name|small2
operator|=
name|G_MAXINT
expr_stmt|;
name|big1
operator|=
name|big2
operator|=
literal|0
expr_stmt|;
DECL|macro|CHECK (xx)
define|#
directive|define
name|CHECK
parameter_list|(
name|xx
parameter_list|)
define|\
value|h0 += xx; \         if (xx> big2) \                 { \                 if (xx> big1) \                         { \                         if (xx> big0) \                                 { \                                 big2 = big1; \                                 big1 = big0; \                                 big0 = xx; \                                 } \                         else \                                 { \                                 big2 = big1; \                                 big1 = xx; \                                 } \                         } \                 else \                         big2 = xx; \                 } \         if (xx< small2) \                 { \                 if (xx< small1) \                         { \                         if (xx< small0) \                                 { \                                 small2 = small1; \                                 small1 = small0; \                                 small0 = xx; \                                 } \                         else \                                 { \                                 small2 = small1; \                                 small1 = xx; \                                 } \                         } \                 else \                         small2 = xx; \                 }
name|CHECK
argument_list|(
argument|h1
argument_list|)
name|CHECK
argument_list|(
argument|h2
argument_list|)
name|CHECK
argument_list|(
argument|h3
argument_list|)
name|CHECK
argument_list|(
argument|h4
argument_list|)
name|CHECK
argument_list|(
argument|h5
argument_list|)
name|CHECK
argument_list|(
argument|h6
argument_list|)
undef|#
directive|undef
name|CHECK
comment|/* Compute mean of middle 1-3 values */
return|return
name|UNSCALE
argument_list|(
name|h0
operator|-
name|big0
operator|-
name|big1
operator|-
name|small0
operator|-
name|small1
operator|-
name|ALFRAC
index|[
operator|(
name|big2
operator|+
name|small2
operator|)
operator|>>
name|SCALEB
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Edge enhancement */
end_comment

begin_function
specifier|static
name|gint
DECL|function|atfilt4 (gint * p)
name|atfilt4
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|hav
decl_stmt|;
comment|/* map to scaled hexagon values and compute enhance value */
name|hav
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|hav
operator|<
literal|0
condition|)
name|hav
operator|=
literal|0
expr_stmt|;
name|hav
operator|=
name|UNSCALE
argument_list|(
name|hav
argument_list|)
expr_stmt|;
if|if
condition|(
name|hav
operator|>
operator|(
name|gdouble
operator|)
literal|255
condition|)
name|hav
operator|=
operator|(
name|gdouble
operator|)
literal|255
expr_stmt|;
return|return
name|hav
return|;
block|}
end_function

begin_comment
comment|/* Optimal estimation - do smoothing in inverse proportion */
end_comment

begin_comment
comment|/* to the local variance. */
end_comment

begin_comment
comment|/* notice we use the globals noisevariance */
end_comment

begin_function
name|gint
DECL|function|atfilt5 (gint * p)
name|atfilt5
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|mean
decl_stmt|,
name|variance
decl_stmt|,
name|temp
decl_stmt|;
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|mean
operator|=
name|h0
operator|+
name|h1
operator|+
name|h2
operator|+
name|h3
operator|+
name|h4
operator|+
name|h5
operator|+
name|h6
expr_stmt|;
comment|/* compute scaled mean by dividing by 7 */
name|mean
operator|=
name|AVEDIV
index|[
name|SCTOCSC
argument_list|(
name|mean
argument_list|)
index|]
expr_stmt|;
comment|/* compute scaled variance */
name|temp
operator|=
operator|(
name|h1
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
comment|/* and rescale to keep */
name|temp
operator|=
operator|(
name|h2
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
comment|/* within 32 bit limits */
name|temp
operator|=
operator|(
name|h3
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
operator|(
name|h4
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
operator|(
name|h5
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
operator|(
name|h6
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
comment|/* (temp = h0 - mean) */
name|temp
operator|=
operator|(
name|h0
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|variance
operator|!=
literal|0
condition|)
comment|/* avoid possible divide by 0 */
comment|/* optimal estimate */
name|temp
operator|=
name|mean
operator|+
operator|(
name|variance
operator|*
name|temp
operator|)
operator|/
operator|(
name|variance
operator|+
name|noisevariance
operator|)
expr_stmt|;
else|else
name|temp
operator|=
name|h0
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|RUNSCALE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
operator|(
name|gdouble
operator|)
literal|255
condition|)
name|temp
operator|=
operator|(
name|gdouble
operator|)
literal|255
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Triangle orientation is per geometric axes (not graphical axies) */
end_comment

begin_define
DECL|macro|NW
define|#
directive|define
name|NW
value|0
end_define

begin_comment
DECL|macro|NW
comment|/* North west triangle /| */
end_comment

begin_define
DECL|macro|NE
define|#
directive|define
name|NE
value|1
end_define

begin_comment
DECL|macro|NE
comment|/* North east triangle |\ */
end_comment

begin_define
DECL|macro|SW
define|#
directive|define
name|SW
value|2
end_define

begin_comment
DECL|macro|SW
comment|/* South west triangle \| */
end_comment

begin_define
DECL|macro|SE
define|#
directive|define
name|SE
value|3
end_define

begin_comment
DECL|macro|SE
comment|/* South east triangle |/ */
end_comment

begin_define
DECL|macro|STH
define|#
directive|define
name|STH
value|2
end_define

begin_define
DECL|macro|EST
define|#
directive|define
name|EST
value|1
end_define

begin_define
DECL|macro|SWAPI (a,b)
define|#
directive|define
name|SWAPI
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(t = a, a = -b, b = -t)
end_define

begin_comment
comment|/* compute the area of overlap of a hexagon diameter d, */
end_comment

begin_comment
comment|/* centered at hx,hy, with a unit square of center sx,sy. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|hex_area (gdouble sx,gdouble sy,gdouble hx,gdouble hy,gdouble d)
name|hex_area
parameter_list|(
name|gdouble
name|sx
parameter_list|,
name|gdouble
name|sy
parameter_list|,
name|gdouble
name|hx
parameter_list|,
name|gdouble
name|hy
parameter_list|,
name|gdouble
name|d
parameter_list|)
block|{
name|gdouble
name|hx0
decl_stmt|,
name|hx1
decl_stmt|,
name|hx2
decl_stmt|,
name|hy0
decl_stmt|,
name|hy1
decl_stmt|,
name|hy2
decl_stmt|,
name|hy3
decl_stmt|;
name|gdouble
name|sx0
decl_stmt|,
name|sx1
decl_stmt|,
name|sy0
decl_stmt|,
name|sy1
decl_stmt|;
comment|/* compute square co-ordinates */
name|sx0
operator|=
name|sx
operator|-
literal|0.5
expr_stmt|;
name|sy0
operator|=
name|sy
operator|-
literal|0.5
expr_stmt|;
name|sx1
operator|=
name|sx
operator|+
literal|0.5
expr_stmt|;
name|sy1
operator|=
name|sy
operator|+
literal|0.5
expr_stmt|;
comment|/* compute hexagon co-ordinates */
name|hx0
operator|=
name|hx
operator|-
name|d
operator|/
literal|2.0
expr_stmt|;
name|hx1
operator|=
name|hx
expr_stmt|;
name|hx2
operator|=
name|hx
operator|+
name|d
operator|/
literal|2.0
expr_stmt|;
name|hy0
operator|=
name|hy
operator|-
literal|0.5773502692
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(3) */
name|hy1
operator|=
name|hy
operator|-
literal|0.2886751346
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(12) */
name|hy2
operator|=
name|hy
operator|+
literal|0.2886751346
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(12) */
name|hy3
operator|=
name|hy
operator|+
literal|0.5773502692
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(3) */
return|return
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx0
argument_list|,
name|hy2
argument_list|,
name|hx1
argument_list|,
name|hy3
argument_list|,
name|NW
argument_list|)
operator|+
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx1
argument_list|,
name|hy2
argument_list|,
name|hx2
argument_list|,
name|hy3
argument_list|,
name|NE
argument_list|)
operator|+
name|rectang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx0
argument_list|,
name|hy1
argument_list|,
name|hx2
argument_list|,
name|hy2
argument_list|)
operator|+
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx0
argument_list|,
name|hy0
argument_list|,
name|hx1
argument_list|,
name|hy1
argument_list|,
name|SW
argument_list|)
operator|+
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx1
argument_list|,
name|hy0
argument_list|,
name|hx2
argument_list|,
name|hy1
argument_list|,
name|SE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gdouble
DECL|function|triang_area (gdouble rx0,gdouble ry0,gdouble rx1,gdouble ry1,gdouble tx0,gdouble ty0,gdouble tx1,gdouble ty1,gint tt)
name|triang_area
parameter_list|(
name|gdouble
name|rx0
parameter_list|,
name|gdouble
name|ry0
parameter_list|,
name|gdouble
name|rx1
parameter_list|,
name|gdouble
name|ry1
parameter_list|,
name|gdouble
name|tx0
parameter_list|,
name|gdouble
name|ty0
parameter_list|,
name|gdouble
name|tx1
parameter_list|,
name|gdouble
name|ty1
parameter_list|,
name|gint
name|tt
parameter_list|)
block|{
name|gdouble
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|gdouble
name|lx0
decl_stmt|,
name|ly0
decl_stmt|,
name|lx1
decl_stmt|,
name|ly1
decl_stmt|;
comment|/* Convert everything to a NW triangle */
if|if
condition|(
name|tt
operator|&
name|STH
condition|)
block|{
name|gdouble
name|t
decl_stmt|;
name|SWAPI
argument_list|(
name|ry0
argument_list|,
name|ry1
argument_list|)
expr_stmt|;
name|SWAPI
argument_list|(
name|ty0
argument_list|,
name|ty1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tt
operator|&
name|EST
condition|)
block|{
name|gdouble
name|t
decl_stmt|;
name|SWAPI
argument_list|(
name|rx0
argument_list|,
name|rx1
argument_list|)
expr_stmt|;
name|SWAPI
argument_list|(
name|tx0
argument_list|,
name|tx1
argument_list|)
expr_stmt|;
block|}
comment|/* Compute overlapping box */
if|if
condition|(
name|tx0
operator|>
name|rx0
condition|)
name|rx0
operator|=
name|tx0
expr_stmt|;
if|if
condition|(
name|ty0
operator|>
name|ry0
condition|)
name|ry0
operator|=
name|ty0
expr_stmt|;
if|if
condition|(
name|tx1
operator|<
name|rx1
condition|)
name|rx1
operator|=
name|tx1
expr_stmt|;
if|if
condition|(
name|ty1
operator|<
name|ry1
condition|)
name|ry1
operator|=
name|ty1
expr_stmt|;
if|if
condition|(
name|rx1
operator|<=
name|rx0
operator|||
name|ry1
operator|<=
name|ry0
condition|)
return|return
literal|0.0
return|;
comment|/* Need to compute diagonal line intersection with the box */
comment|/* First compute co-efficients to formulas x = a + by and y = c + dx */
name|b
operator|=
operator|(
name|tx1
operator|-
name|tx0
operator|)
operator|/
operator|(
name|ty1
operator|-
name|ty0
operator|)
expr_stmt|;
name|a
operator|=
name|tx0
operator|-
name|b
operator|*
name|ty0
expr_stmt|;
name|d
operator|=
operator|(
name|ty1
operator|-
name|ty0
operator|)
operator|/
operator|(
name|tx1
operator|-
name|tx0
operator|)
expr_stmt|;
name|c
operator|=
name|ty0
operator|-
name|d
operator|*
name|tx0
expr_stmt|;
comment|/* compute top or right intersection */
name|tt
operator|=
literal|0
expr_stmt|;
name|ly1
operator|=
name|ry1
expr_stmt|;
name|lx1
operator|=
name|a
operator|+
name|b
operator|*
name|ly1
expr_stmt|;
if|if
condition|(
name|lx1
operator|<=
name|rx0
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
elseif|else
if|if
condition|(
name|lx1
operator|>
name|rx1
condition|)
block|{
comment|/* could be right hand side */
name|lx1
operator|=
name|rx1
expr_stmt|;
name|ly1
operator|=
name|c
operator|+
name|d
operator|*
name|lx1
expr_stmt|;
if|if
condition|(
name|ly1
operator|<=
name|ry0
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
name|tt
operator|=
literal|1
expr_stmt|;
comment|/* right hand side intersection */
block|}
comment|/* compute left or bottom intersection */
name|lx0
operator|=
name|rx0
expr_stmt|;
name|ly0
operator|=
name|c
operator|+
name|d
operator|*
name|lx0
expr_stmt|;
if|if
condition|(
name|ly0
operator|>=
name|ry1
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
elseif|else
if|if
condition|(
name|ly0
operator|<
name|ry0
condition|)
block|{
comment|/* could be right hand side */
name|ly0
operator|=
name|ry0
expr_stmt|;
name|lx0
operator|=
name|a
operator|+
name|b
operator|*
name|ly0
expr_stmt|;
if|if
condition|(
name|lx0
operator|>=
name|rx1
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
name|tt
operator||=
literal|2
expr_stmt|;
comment|/* bottom intersection */
block|}
if|if
condition|(
name|tt
operator|==
literal|0
condition|)
block|{
comment|/* top and left intersection */
comment|/* rectangle minus triangle */
return|return
operator|(
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
operator|)
operator|-
operator|(
literal|0.5
operator|*
operator|(
name|lx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ly0
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|==
literal|1
condition|)
block|{
comment|/* right and left intersection */
return|return
operator|(
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ly0
operator|-
name|ry0
operator|)
operator|)
operator|+
operator|(
literal|0.5
operator|*
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ly1
operator|-
name|ly0
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|==
literal|2
condition|)
block|{
comment|/* top and bottom intersection */
return|return
operator|(
operator|(
name|rx1
operator|-
name|lx1
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
operator|)
operator|+
operator|(
literal|0.5
operator|*
operator|(
name|lx1
operator|-
name|lx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
operator|)
return|;
block|}
else|else
block|{
comment|/* tt == 3 */
comment|/* right and bottom intersection */
comment|/* triangle */
return|return
operator|(
literal|0.5
operator|*
operator|(
name|rx1
operator|-
name|lx0
operator|)
operator|*
operator|(
name|ly1
operator|-
name|ry0
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute rectangle area */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|rectang_area (gdouble rx0,gdouble ry0,gdouble rx1,gdouble ry1,gdouble tx0,gdouble ty0,gdouble tx1,gdouble ty1)
name|rectang_area
parameter_list|(
name|gdouble
name|rx0
parameter_list|,
name|gdouble
name|ry0
parameter_list|,
name|gdouble
name|rx1
parameter_list|,
name|gdouble
name|ry1
parameter_list|,
name|gdouble
name|tx0
parameter_list|,
name|gdouble
name|ty0
parameter_list|,
name|gdouble
name|tx1
parameter_list|,
name|gdouble
name|ty1
parameter_list|)
block|{
comment|/* Compute overlapping box */
if|if
condition|(
name|tx0
operator|>
name|rx0
condition|)
name|rx0
operator|=
name|tx0
expr_stmt|;
if|if
condition|(
name|ty0
operator|>
name|ry0
condition|)
name|ry0
operator|=
name|ty0
expr_stmt|;
if|if
condition|(
name|tx1
operator|<
name|rx1
condition|)
name|rx1
operator|=
name|tx1
expr_stmt|;
if|if
condition|(
name|ty1
operator|<
name|ry1
condition|)
name|ry1
operator|=
name|ty1
expr_stmt|;
if|if
condition|(
name|rx1
operator|<=
name|rx0
operator|||
name|ry1
operator|<=
name|ry0
condition|)
return|return
literal|0.0
return|;
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|nlfilter (GimpDrawable * drawable,GimpPreview * preview)
name|nlfilter
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|GimpPixelRgn
name|srcPr
decl_stmt|,
name|dstPr
decl_stmt|;
name|guchar
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|dstbuf
decl_stmt|;
name|guchar
modifier|*
name|lastrow
decl_stmt|,
modifier|*
name|thisrow
decl_stmt|,
modifier|*
name|nextrow
decl_stmt|,
modifier|*
name|temprow
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|,
name|bpp
decl_stmt|;
name|gint
name|filtno
decl_stmt|,
name|y
decl_stmt|,
name|rowsize
decl_stmt|,
name|exrowsize
decl_stmt|,
name|p_update
decl_stmt|;
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_preview_get_position
argument_list|(
name|preview
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|gimp_preview_get_size
argument_list|(
name|preview
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
name|width
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
name|height
expr_stmt|;
block|}
else|else
block|{
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
block|}
name|bpp
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
name|rowsize
operator|=
name|width
operator|*
name|bpp
expr_stmt|;
name|exrowsize
operator|=
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
name|bpp
expr_stmt|;
name|p_update
operator|=
name|width
operator|/
literal|20
operator|+
literal|1
expr_stmt|;
name|gimp_tile_cache_ntiles
argument_list|(
literal|2
operator|*
operator|(
name|width
operator|/
name|gimp_tile_width
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|srcPr
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dstPr
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|preview
operator|==
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* source buffer gives one pixel margin all around destination buffer */
name|srcbuf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|exrowsize
operator|*
literal|3
argument_list|)
expr_stmt|;
name|dstbuf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|rowsize
argument_list|)
expr_stmt|;
comment|/* pointers to second pixel in each source row */
name|lastrow
operator|=
name|srcbuf
operator|+
name|bpp
expr_stmt|;
name|thisrow
operator|=
name|lastrow
operator|+
name|exrowsize
expr_stmt|;
name|nextrow
operator|=
name|thisrow
operator|+
name|exrowsize
expr_stmt|;
name|filtno
operator|=
name|nlfiltInit
argument_list|(
name|nlfvals
operator|.
name|alpha
argument_list|,
name|nlfvals
operator|.
name|radius
argument_list|,
name|nlfvals
operator|.
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preview
condition|)
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"NL Filter"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first row */
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|srcPr
argument_list|,
name|thisrow
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* copy thisrow[0] to thisrow[-1], thisrow[width-1] to thisrow[width] */
name|memcpy
argument_list|(
name|thisrow
operator|-
name|bpp
argument_list|,
name|thisrow
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|thisrow
operator|+
name|rowsize
argument_list|,
name|thisrow
operator|+
name|rowsize
operator|-
name|bpp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
comment|/* copy whole thisrow to lastrow */
name|memcpy
argument_list|(
name|lastrow
operator|-
name|bpp
argument_list|,
name|thisrow
operator|-
name|bpp
argument_list|,
name|exrowsize
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<
name|y2
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|y
operator|%
name|p_update
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|y
operator|/
operator|(
name|gdouble
operator|)
name|height
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|srcPr
argument_list|,
name|nextrow
argument_list|,
name|x1
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nextrow
operator|-
name|bpp
argument_list|,
name|nextrow
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nextrow
operator|+
name|rowsize
argument_list|,
name|nextrow
operator|+
name|rowsize
operator|-
name|bpp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|nlfiltRow
argument_list|(
name|lastrow
argument_list|,
name|thisrow
argument_list|,
name|nextrow
argument_list|,
name|dstbuf
argument_list|,
name|width
argument_list|,
name|bpp
argument_list|,
name|filtno
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_row
argument_list|(
operator|&
name|dstPr
argument_list|,
name|dstbuf
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* rotate row buffers */
name|temprow
operator|=
name|lastrow
expr_stmt|;
name|lastrow
operator|=
name|thisrow
expr_stmt|;
name|thisrow
operator|=
name|nextrow
expr_stmt|;
name|nextrow
operator|=
name|temprow
expr_stmt|;
block|}
comment|/* last row */
name|memcpy
argument_list|(
name|nextrow
operator|-
name|bpp
argument_list|,
name|thisrow
operator|-
name|bpp
argument_list|,
name|exrowsize
argument_list|)
expr_stmt|;
name|nlfiltRow
argument_list|(
name|lastrow
argument_list|,
name|thisrow
argument_list|,
name|nextrow
argument_list|,
name|dstbuf
argument_list|,
name|width
argument_list|,
name|bpp
argument_list|,
name|filtno
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_row
argument_list|(
operator|&
name|dstPr
argument_list|,
name|dstbuf
argument_list|,
name|x1
argument_list|,
name|y2
operator|-
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|srcbuf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dstbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_drawable_preview_draw_region
argument_list|(
name|GIMP_DRAWABLE_PREVIEW
argument_list|(
name|preview
argument_list|)
argument_list|,
operator|&
name|dstPr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimp_displays_flush
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|nlfilter_dialog (GimpDrawable * drawable)
name|nlfilter_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|main_vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|alpha_trim
decl_stmt|;
name|GtkWidget
modifier|*
name|opt_est
decl_stmt|;
name|GtkWidget
modifier|*
name|edge_enhance
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkObject
modifier|*
name|adj
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"NL Filter"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|PLUG_IN_PROC
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|main_vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|main_vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|main_vbox
argument_list|)
expr_stmt|;
name|preview
operator|=
name|gimp_drawable_preview_new
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|preview
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|preview
argument_list|,
literal|"invalidated"
argument_list|,
name|G_CALLBACK
argument_list|(
name|nlfilter
argument_list|)
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Filter"
argument_list|)
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|nlfvals
operator|.
name|filter
argument_list|,
name|nlfvals
operator|.
name|filter
argument_list|,
name|_
argument_list|(
literal|"_Alpha trimmed mean"
argument_list|)
argument_list|,
name|filter_alpha_trim
argument_list|,
operator|&
name|alpha_trim
argument_list|,
name|_
argument_list|(
literal|"Op_timal estimation"
argument_list|)
argument_list|,
name|filter_opt_est
argument_list|,
operator|&
name|opt_est
argument_list|,
name|_
argument_list|(
literal|"_Edge enhancement"
argument_list|)
argument_list|,
name|filter_edge_enhance
argument_list|,
operator|&
name|edge_enhance
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|alpha_trim
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|opt_est
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|edge_enhance
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|table
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"A_lpha:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|nlfvals
operator|.
name|alpha
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.05
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|nlfvals
operator|.
name|alpha
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"_Radius:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|nlfvals
operator|.
name|radius
argument_list|,
literal|1.0
operator|/
literal|3.0
argument_list|,
literal|1.0
argument_list|,
literal|0.05
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|nlfvals
operator|.
name|radius
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

end_unit

