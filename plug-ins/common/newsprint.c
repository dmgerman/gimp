begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * newsprint plug-in  * Copyright (C) 1997-1998 Austin Donnelly<austin@greenend.org.uk>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Portions of this plug-in are copyright 1991-1992 Adobe Systems  * Incorporated.  See the spot_PS*() functions for details.  */
end_comment

begin_comment
comment|/*  * version 0.51  * This version requires gtk-1.0.4 or above.  *  * This plug-in puts an image through a screen at a particular angle  * and lines per inch, to arrive at a newspaper-style effect.  *  * Austin Donnelly<austin@greenend.org.uk>  * http://www.cl.cam.ac.uk/~and1000/newsprint/  *  * Richard Mortier<rmm1002@cam.ac.uk> did the spot_round() function  * with correct tonal balance.  *  * Tim Harris<tim.harris@acm.org> provided valuable feedback on  * pre-press issues.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
DECL|variable|rcsid
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|VERSION
define|#
directive|define
name|VERSION
value|"v0.51"
end_define

begin_comment
comment|/* Some useful macros */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|DEBUG_PRINT (x)
define|#
directive|define
name|DEBUG_PRINT
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|DEBUG_PRINT (x)
define|#
directive|define
name|DEBUG_PRINT
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HACK so we compile with old gtks.  Won't work on machines where the  * size of an int is different from the size of a void*, eg Alphas */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GINT_TO_POINTER
end_ifndef

begin_warning
warning|#
directive|warning
warning|glib did not define GINT_TO_POINTER, assuming same size as int
end_warning

begin_define
DECL|macro|GINT_TO_POINTER (x)
define|#
directive|define
name|GINT_TO_POINTER
parameter_list|(
name|x
parameter_list|)
value|((gpointer)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GPOINTER_TO_INT
end_ifndef

begin_warning
warning|#
directive|warning
warning|glib did not define GPOINTER_TO_INT, assuming same size as int
end_warning

begin_define
DECL|macro|GPOINTER_TO_INT (x)
define|#
directive|define
name|GPOINTER_TO_INT
parameter_list|(
name|x
parameter_list|)
value|((int)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#define TIMINGS*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIMINGS
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
DECL|macro|TM_INIT ()
define|#
directive|define
name|TM_INIT
parameter_list|()
value|struct timeval tm_start, tm_end
end_define

begin_define
DECL|macro|TM_START ()
define|#
directive|define
name|TM_START
parameter_list|()
value|gettimeofday(&tm_start, NULL)
end_define

begin_define
DECL|macro|TM_END ()
define|#
directive|define
name|TM_END
parameter_list|()
define|\
value|do {									 \     gettimeofday(&tm_end, NULL);					 \     tm_end.tv_sec  -= tm_start.tv_sec;					 \     tm_end.tv_usec -= tm_start.tv_usec;					 \     if (tm_end.tv_usec< 0)						 \     {									 \ 	tm_end.tv_usec += 1000000;					 \ 	tm_end.tv_sec  -= 1;						 \     }									 \     printf("operation took %ld.%06ld\n", tm_end.tv_sec, tm_end.tv_usec); \ } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|TM_INIT ()
define|#
directive|define
name|TM_INIT
parameter_list|()
end_define

begin_define
DECL|macro|TM_START ()
define|#
directive|define
name|TM_START
parameter_list|()
end_define

begin_define
DECL|macro|TM_END ()
define|#
directive|define
name|TM_END
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|TILE_CACHE_SIZE
define|#
directive|define
name|TILE_CACHE_SIZE
value|16
end_define

begin_define
DECL|macro|ENTSCALE_SCALE_WIDTH
define|#
directive|define
name|ENTSCALE_SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|ENTSCALE_ENTRY_WIDTH
define|#
directive|define
name|ENTSCALE_ENTRY_WIDTH
value|40
end_define

begin_define
DECL|macro|DEF_OVERSAMPLE
define|#
directive|define
name|DEF_OVERSAMPLE
value|1
end_define

begin_comment
DECL|macro|DEF_OVERSAMPLE
comment|/* default for how much to oversample by */
end_comment

begin_define
DECL|macro|SPOT_PREVIEW_SZ
define|#
directive|define
name|SPOT_PREVIEW_SZ
value|16
end_define

begin_define
DECL|macro|PREVIEW_OVERSAMPLE
define|#
directive|define
name|PREVIEW_OVERSAMPLE
value|3
end_define

begin_define
DECL|macro|BOUNDS (a,x,y)
define|#
directive|define
name|BOUNDS
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|((a< x) ? x : ((a> y) ? y : a))
end_define

begin_define
DECL|macro|ISNEG (x)
define|#
directive|define
name|ISNEG
parameter_list|(
name|x
parameter_list|)
value|(((x)< 0)? 1 : 0)
end_define

begin_define
DECL|macro|DEG2RAD (d)
define|#
directive|define
name|DEG2RAD
parameter_list|(
name|d
parameter_list|)
value|((d) * M_PI / 180)
end_define

begin_define
DECL|macro|VALID_BOOL (x)
define|#
directive|define
name|VALID_BOOL
parameter_list|(
name|x
parameter_list|)
value|((x) == TRUE || (x) == FALSE)
end_define

begin_define
DECL|macro|CLAMPED_ADD (a,b)
define|#
directive|define
name|CLAMPED_ADD
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)+(b)> 0xff)? 0xff : (a) + (b))
end_define

begin_comment
comment|/* Ideally, this would be in a common header file somewhere.  This was  * nicked from app/convert.c */
end_comment

begin_define
DECL|macro|INTENSITY (r,g,b)
define|#
directive|define
name|INTENSITY
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
value|(r * 0.30 + g * 0.59 + b * 0.11 + 0.001)
end_define

begin_comment
comment|/* Bartlett window supersampling weight function.  See table 4.1, page  * 123 of Alan Watt and Mark Watt, Advanced Animation and Rendering  * Techniques, theory and practice. Addison-Wesley, 1992. ISBN  * 0-201-54412-1 */
end_comment

begin_define
DECL|macro|BARTLETT (x,y)
define|#
directive|define
name|BARTLETT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((oversample/2)+1-ABS(x)) * ((oversample/2)+1-ABS(y)))
end_define

begin_define
DECL|macro|WGT (x,y)
define|#
directive|define
name|WGT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|wgt[((y+oversample/2)*oversample) + x+oversample/2]
end_define

begin_comment
comment|/* colourspaces we can separate to: */
end_comment

begin_define
DECL|macro|CS_GREY
define|#
directive|define
name|CS_GREY
value|0
end_define

begin_define
DECL|macro|CS_RGB
define|#
directive|define
name|CS_RGB
value|1
end_define

begin_define
DECL|macro|CS_CMYK
define|#
directive|define
name|CS_CMYK
value|2
end_define

begin_define
DECL|macro|CS_INTENSITY
define|#
directive|define
name|CS_INTENSITY
value|3
end_define

begin_define
DECL|macro|NUM_CS
define|#
directive|define
name|NUM_CS
value|4
end_define

begin_define
DECL|macro|VALID_CS (x)
define|#
directive|define
name|VALID_CS
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)<= NUM_CS-1)
end_define

begin_comment
comment|/* Spot function related types and definitions */
end_comment

begin_typedef
DECL|typedef|y
typedef|typedef
name|gdouble
name|spotfn_t
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* forward declaration of the functions themselves */
end_comment

begin_decl_stmt
DECL|variable|spot_round
specifier|static
name|spotfn_t
name|spot_round
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_line
specifier|static
name|spotfn_t
name|spot_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_diamond
specifier|static
name|spotfn_t
name|spot_diamond
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_PSsquare
specifier|static
name|spotfn_t
name|spot_PSsquare
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_PSdiamond
specifier|static
name|spotfn_t
name|spot_PSdiamond
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|__anon275750700108
typedef|typedef
struct|struct
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* function's name */
DECL|member|fn
name|spotfn_t
modifier|*
name|fn
decl_stmt|;
comment|/* function itself */
DECL|member|thresh
name|guchar
modifier|*
name|thresh
decl_stmt|;
comment|/* cached threshold matrix */
DECL|member|prev_lvl
name|gdouble
name|prev_lvl
index|[
literal|3
index|]
decl_stmt|;
comment|/* intensities to preview */
DECL|member|prev_thresh
name|guchar
modifier|*
name|prev_thresh
decl_stmt|;
comment|/* preview-sized threshold matrix */
DECL|member|balanced
name|gint
name|balanced
decl_stmt|;
comment|/* TRUE if spot fn is already balanced */
DECL|typedef|spot_info_t
block|}
name|spot_info_t
typedef|;
end_typedef

begin_comment
comment|/* This is all the info needed per spot function.  Functions are refered to  * by their index into this array. */
end_comment

begin_decl_stmt
DECL|variable|spotfn_list
specifier|static
name|spot_info_t
name|spotfn_list
index|[]
init|=
block|{
DECL|macro|SPOTFN_DOT
define|#
directive|define
name|SPOTFN_DOT
value|0
block|{
literal|"round"
block|,
name|spot_round
block|,
name|NULL
block|,
block|{
literal|.22
block|,
literal|.50
block|,
literal|.90
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
block|{
literal|"line"
block|,
name|spot_line
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.80
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
block|{
literal|"diamond"
block|,
name|spot_diamond
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.80
block|}
block|,
name|NULL
block|,
name|TRUE
block|}
block|,
block|{
literal|"PS square (Euclidean dot)"
block|,
name|spot_PSsquare
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.90
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
block|{
literal|"PS diamond"
block|,
name|spot_PSdiamond
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.90
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
comment|/* NULL-name terminates */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|NUM_SPOTFN
define|#
directive|define
name|NUM_SPOTFN
value|((sizeof(spotfn_list) / sizeof(spot_info_t)) - 1)
end_define

begin_define
DECL|macro|VALID_SPOTFN (x)
define|#
directive|define
name|VALID_SPOTFN
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)< NUM_SPOTFN)
end_define

begin_define
DECL|macro|THRESH (x,y)
define|#
directive|define
name|THRESH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(thresh[(y)*width + (x)])
end_define

begin_define
DECL|macro|THRESHn (n,x,y)
define|#
directive|define
name|THRESHn
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|((thresh[n])[(y)*width + (x)])
end_define

begin_comment
comment|/* Arguments to filter */
end_comment

begin_comment
comment|/* Some of these are here merely to save them across calls.  They are  * marked as "UI use".  Everything else is a valid arg. */
end_comment

begin_typedef
DECL|struct|__anon275750700208
typedef|typedef
struct|struct
block|{
comment|/* resolution section: */
DECL|member|cell_width
name|gint
name|cell_width
decl_stmt|;
comment|/* screening section: */
DECL|member|colourspace
name|gint
name|colourspace
decl_stmt|;
comment|/* 0: RGB, 1: CMYK, 2: Intensity */
DECL|member|k_pullout
name|gint
name|k_pullout
decl_stmt|;
comment|/* percentage of black to pull out */
comment|/* grey screen (only used if greyscale drawable) */
DECL|member|gry_ang
name|gdouble
name|gry_ang
decl_stmt|;
DECL|member|gry_spotfn
name|gint
name|gry_spotfn
decl_stmt|;
comment|/* red / cyan screen */
DECL|member|red_ang
name|gdouble
name|red_ang
decl_stmt|;
DECL|member|red_spotfn
name|gint
name|red_spotfn
decl_stmt|;
comment|/* green / magenta screen */
DECL|member|grn_ang
name|gdouble
name|grn_ang
decl_stmt|;
DECL|member|grn_spotfn
name|gint
name|grn_spotfn
decl_stmt|;
comment|/* blue / yellow screen */
DECL|member|blu_ang
name|gdouble
name|blu_ang
decl_stmt|;
DECL|member|blu_spotfn
name|gint
name|blu_spotfn
decl_stmt|;
comment|/* anti-alias section */
DECL|member|oversample
name|gint
name|oversample
decl_stmt|;
comment|/* 1 == no anti-aliasing, else small odd int */
DECL|typedef|NewsprintValues
block|}
name|NewsprintValues
typedef|;
end_typedef

begin_comment
comment|/* bits of state used by the UI, but not visible from the PDB */
end_comment

begin_typedef
DECL|struct|__anon275750700308
typedef|typedef
struct|struct
block|{
DECL|member|input_spi
name|gint
name|input_spi
decl_stmt|;
comment|/* input samples per inch */
DECL|member|output_lpi
name|gdouble
name|output_lpi
decl_stmt|;
comment|/* desired output lines per inch */
DECL|member|lock_channels
name|gint
name|lock_channels
decl_stmt|;
comment|/* changes to one channel affect all */
DECL|typedef|NewsprintUIValues
block|}
name|NewsprintUIValues
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon275750700408
typedef|typedef
struct|struct
block|{
DECL|member|run
name|gint
name|run
decl_stmt|;
DECL|typedef|NewsprintInterface
block|}
name|NewsprintInterface
typedef|;
end_typedef

begin_typedef
DECL|typedef|EntscaleCallbackFunc
typedef|typedef
name|void
function_decl|(
modifier|*
name|EntscaleCallbackFunc
function_decl|)
parameter_list|(
name|gdouble
name|new_val
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|enum|__anon275750700503
typedef|typedef
enum|enum
block|{
DECL|enumerator|ENTSCALE_INT
name|ENTSCALE_INT
block|,
DECL|enumerator|ENTSCALE_DOUBLE
name|ENTSCALE_DOUBLE
DECL|typedef|EntscaleType
block|}
name|EntscaleType
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon275750700608
typedef|typedef
struct|struct
block|{
DECL|member|adjustment
name|GtkObject
modifier|*
name|adjustment
decl_stmt|;
DECL|member|entry
name|GtkWidget
modifier|*
name|entry
decl_stmt|;
DECL|member|label
name|GtkWidget
modifier|*
name|label
decl_stmt|;
DECL|member|hbox
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
DECL|member|type
name|EntscaleType
name|type
decl_stmt|;
DECL|member|fmt_string
name|gchar
name|fmt_string
index|[
literal|16
index|]
decl_stmt|;
DECL|member|constraint
name|gint
name|constraint
decl_stmt|;
DECL|member|callback
name|EntscaleCallbackFunc
name|callback
decl_stmt|;
DECL|member|call_data
name|gpointer
name|call_data
decl_stmt|;
DECL|typedef|Entscale
block|}
name|Entscale
typedef|;
end_typedef

begin_comment
comment|/* state for the preview widgets */
end_comment

begin_typedef
DECL|struct|__anon275750700708
typedef|typedef
struct|struct
block|{
DECL|member|widget
name|GtkWidget
modifier|*
name|widget
decl_stmt|;
comment|/* preview widget itself */
DECL|member|label
name|GtkWidget
modifier|*
name|label
decl_stmt|;
comment|/* the label below it */
DECL|typedef|preview_st
block|}
name|preview_st
typedef|;
end_typedef

begin_comment
comment|/* state for the channel frames */
end_comment

begin_typedef
DECL|struct|_channel_st
typedef|typedef
struct|struct
name|_channel_st
block|{
DECL|member|frame
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
comment|/* frame around this channel */
DECL|member|spotfn_num
name|gint
modifier|*
name|spotfn_num
decl_stmt|;
comment|/* which spotfn the menu is controlling */
DECL|member|prev
name|preview_st
name|prev
index|[
literal|3
index|]
decl_stmt|;
comment|/* state for 3 preview widgets */
DECL|member|entscale
name|Entscale
modifier|*
name|entscale
decl_stmt|;
comment|/* angle entscale widget */
DECL|member|option_menu
name|GtkWidget
modifier|*
name|option_menu
decl_stmt|;
comment|/* popup for spot function */
DECL|member|menuitem
name|GtkWidget
modifier|*
name|menuitem
index|[
name|NUM_SPOTFN
index|]
decl_stmt|;
comment|/* menuitems for each spot function */
DECL|member|ch_menuitem
name|GtkWidget
modifier|*
name|ch_menuitem
decl_stmt|;
comment|/* menuitem for the channel selector */
DECL|member|ch_menu_num
name|gint
name|ch_menu_num
decl_stmt|;
comment|/* this channel's position in the selector */
DECL|member|next
name|struct
name|_channel_st
modifier|*
name|next
decl_stmt|;
comment|/* circular list of channels in locked group */
DECL|typedef|channel_st
block|}
name|channel_st
typedef|;
end_typedef

begin_comment
comment|/* State associated with the configuration dialog and passed to its  * callback functions */
end_comment

begin_typedef
DECL|struct|__anon275750700808
typedef|typedef
struct|struct
block|{
DECL|member|dlg
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
comment|/* main dialog itself */
DECL|member|pull
name|Entscale
modifier|*
name|pull
decl_stmt|;
comment|/* black pullout percentage */
DECL|member|input_spi
name|Entscale
modifier|*
name|input_spi
decl_stmt|;
DECL|member|output_lpi
name|Entscale
modifier|*
name|output_lpi
decl_stmt|;
DECL|member|cellsize
name|Entscale
modifier|*
name|cellsize
decl_stmt|;
DECL|member|vbox
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
comment|/* container for screen info */
DECL|member|current_ch
name|GtkWidget
modifier|*
name|current_ch
decl_stmt|;
comment|/* which channel is currently being edited */
DECL|member|channel_menu
name|GtkWidget
modifier|*
name|channel_menu
decl_stmt|;
comment|/* menu of channels */
DECL|member|channel_option
name|GtkWidget
modifier|*
name|channel_option
decl_stmt|;
comment|/* option menu for channels */
comment|/* room for up to 4 channels per colourspace */
DECL|member|chst
name|channel_st
modifier|*
name|chst
index|[
name|NUM_CS
index|]
index|[
literal|4
index|]
decl_stmt|;
DECL|typedef|NewsprintDialog_st
block|}
name|NewsprintDialog_st
typedef|;
end_typedef

begin_comment
comment|/***** Local vars *****/
end_comment

begin_comment
comment|/* defaults */
end_comment

begin_comment
comment|/* fixed copy so we can reset them */
end_comment

begin_decl_stmt
DECL|variable|factory_defaults
specifier|static
specifier|const
name|NewsprintValues
name|factory_defaults
init|=
block|{
comment|/* resolution stuff */
literal|10
block|,
comment|/* cell width */
comment|/* screen setup (default is the classic rosette pattern) */
name|CS_RGB
block|,
comment|/* use RGB, not CMYK or Intensity */
literal|100
block|,
comment|/* max pullout */
comment|/* grey/black */
literal|45.0
block|,
name|SPOTFN_DOT
block|,
comment|/* red/cyan */
literal|15.0
block|,
name|SPOTFN_DOT
block|,
comment|/* green/magenta */
literal|75.0
block|,
name|SPOTFN_DOT
block|,
comment|/* blue/yellow */
literal|0.0
block|,
name|SPOTFN_DOT
block|,
comment|/* anti-alias control */
name|DEF_OVERSAMPLE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|factory_defaults_ui
specifier|static
specifier|const
name|NewsprintUIValues
name|factory_defaults_ui
init|=
block|{
literal|72
block|,
comment|/* input spi */
literal|7.2
block|,
comment|/* output lpi */
name|FALSE
comment|/* lock channels */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mutable copy for normal use.  Initialised in run(). */
end_comment

begin_decl_stmt
DECL|variable|pvals
specifier|static
name|NewsprintValues
name|pvals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pvals_ui
specifier|static
name|NewsprintUIValues
name|pvals_ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pint
specifier|static
name|NewsprintInterface
name|pint
init|=
block|{
name|FALSE
comment|/* run */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* channel templates */
end_comment

begin_typedef
DECL|struct|__anon275750700908
typedef|typedef
struct|struct
block|{
DECL|member|name
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
comment|/* pointers to the variables this channel updates */
DECL|member|angle
name|gdouble
modifier|*
name|angle
decl_stmt|;
DECL|member|spotfn
name|gint
modifier|*
name|spotfn
decl_stmt|;
comment|/* factory defaults for the angle and spot function (as pointers so      * the silly compiler can see they're really constants) */
DECL|member|factory_angle
specifier|const
name|gdouble
modifier|*
name|factory_angle
decl_stmt|;
DECL|member|factory_spotfn
specifier|const
name|gint
modifier|*
name|factory_spotfn
decl_stmt|;
DECL|typedef|chan_tmpl
block|}
name|chan_tmpl
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|grey_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|grey_tmpl
index|[]
init|=
block|{
block|{
literal|"Grey"
block|,
operator|&
name|pvals
operator|.
name|gry_ang
block|,
operator|&
name|pvals
operator|.
name|gry_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|gry_ang
block|,
operator|&
name|factory_defaults
operator|.
name|gry_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rgb_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|rgb_tmpl
index|[]
init|=
block|{
block|{
literal|"Red"
block|,
operator|&
name|pvals
operator|.
name|red_ang
block|,
operator|&
name|pvals
operator|.
name|red_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|red_ang
block|,
operator|&
name|factory_defaults
operator|.
name|red_spotfn
block|}
block|,
block|{
literal|"Green"
block|,
operator|&
name|pvals
operator|.
name|grn_ang
block|,
operator|&
name|pvals
operator|.
name|grn_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|grn_ang
block|,
operator|&
name|factory_defaults
operator|.
name|grn_spotfn
block|}
block|,
block|{
literal|"Blue"
block|,
operator|&
name|pvals
operator|.
name|blu_ang
block|,
operator|&
name|pvals
operator|.
name|blu_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|blu_ang
block|,
operator|&
name|factory_defaults
operator|.
name|blu_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cmyk_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|cmyk_tmpl
index|[]
init|=
block|{
block|{
literal|"Cyan"
block|,
operator|&
name|pvals
operator|.
name|red_ang
block|,
operator|&
name|pvals
operator|.
name|red_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|red_ang
block|,
operator|&
name|factory_defaults
operator|.
name|red_spotfn
block|}
block|,
block|{
literal|"Magenta"
block|,
operator|&
name|pvals
operator|.
name|grn_ang
block|,
operator|&
name|pvals
operator|.
name|grn_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|grn_ang
block|,
operator|&
name|factory_defaults
operator|.
name|grn_spotfn
block|}
block|,
block|{
literal|"Yellow"
block|,
operator|&
name|pvals
operator|.
name|blu_ang
block|,
operator|&
name|pvals
operator|.
name|blu_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|blu_ang
block|,
operator|&
name|factory_defaults
operator|.
name|blu_spotfn
block|}
block|,
block|{
literal|"Black"
block|,
operator|&
name|pvals
operator|.
name|gry_ang
block|,
operator|&
name|pvals
operator|.
name|gry_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|gry_ang
block|,
operator|&
name|factory_defaults
operator|.
name|gry_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|intensity_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|intensity_tmpl
index|[]
init|=
block|{
block|{
literal|"Intensity"
block|,
operator|&
name|pvals
operator|.
name|gry_ang
block|,
operator|&
name|pvals
operator|.
name|gry_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|gry_ang
block|,
operator|&
name|factory_defaults
operator|.
name|gry_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cspace_chan_tmpl is indexed by colourspace, and gives an array of  * channel templates for that colourspace */
end_comment

begin_decl_stmt
DECL|variable|cspace_chan_tmpl
specifier|static
specifier|const
name|chan_tmpl
modifier|*
name|cspace_chan_tmpl
index|[]
init|=
block|{
name|grey_tmpl
block|,
name|rgb_tmpl
block|,
name|cmyk_tmpl
block|,
name|intensity_tmpl
block|}
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|NCHANS (x)
define|#
directive|define
name|NCHANS
parameter_list|(
name|x
parameter_list|)
value|((sizeof(x) / sizeof(chan_tmpl)) - 1)
end_define

begin_comment
comment|/* cspace_nchans gives a quick way of finding the number of channels  * in a colourspace.  Alternatively, if you're walking the channel  * template, you can use the NULL entry at the end to stop. */
end_comment

begin_decl_stmt
DECL|variable|cspace_nchans
specifier|static
specifier|const
name|gint
name|cspace_nchans
index|[]
init|=
block|{
name|NCHANS
argument_list|(
name|grey_tmpl
argument_list|)
block|,
name|NCHANS
argument_list|(
name|rgb_tmpl
argument_list|)
block|,
name|NCHANS
argument_list|(
name|cmyk_tmpl
argument_list|)
block|,
name|NCHANS
argument_list|(
argument|intensity_tmpl
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|newsprint_dialog
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_cspace_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|spot2thresh
parameter_list|(
name|gint
name|type
parameter_list|,
name|gint
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Entscale
modifier|*
name|entscale_new
parameter_list|(
name|GtkWidget
modifier|*
name|table
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gchar
modifier|*
name|caption
parameter_list|,
name|EntscaleType
name|type
parameter_list|,
name|gpointer
name|variable
parameter_list|,
name|gdouble
name|min
parameter_list|,
name|gdouble
name|max
parameter_list|,
name|gdouble
name|step
parameter_list|,
name|gint
name|constraint
parameter_list|,
name|EntscaleCallbackFunc
name|callback
parameter_list|,
name|gpointer
name|call_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|entscale_get_precision
parameter_list|(
name|gdouble
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_destroy_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_entry_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_set_sensitive
parameter_list|(
name|Entscale
modifier|*
name|ent
parameter_list|,
name|gint
name|sensitive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_set_value
parameter_list|(
name|Entscale
modifier|*
name|ent
parameter_list|,
name|gfloat
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***** Functions *****/
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Input image (unused)"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Input drawable"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"cell_width"
block|,
literal|"screen cell width, in pixels"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"colourspace"
block|,
literal|"separate to 0:RGB, 1:CMYK, 2:Intensity"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"k_pullout"
block|,
literal|"Percentage of black to pullout (CMYK only)"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"gry_ang"
block|,
literal|"Grey/black screen angle (degrees)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"gry_spotfn"
block|,
literal|"Grey/black spot function (0=dots, 1=lines, 2=diamonds, 3=euclidean dot, 4=PS diamond)"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"red_ang"
block|,
literal|"Red/cyan screen angle (degrees)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"red_spotfn"
block|,
literal|"Red/cyan spot function (values as gry_spotfn)"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"grn_ang"
block|,
literal|"Green/magenta screen angle (degrees)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"grn_spotfn"
block|,
literal|"Green/magenta spot function (values as gry_spotfn)"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"blu_ang"
block|,
literal|"Blue/yellow screen angle (degrees)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"blu_spotfn"
block|,
literal|"Blue/yellow spot function (values as gry_spotfn)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"oversample"
block|,
literal|"how many times to oversample spot fn"
block|}
comment|/* 15 args */
block|}
decl_stmt|;
specifier|static
name|GParamDef
modifier|*
name|return_vals
init|=
name|NULL
decl_stmt|;
specifier|static
name|gint
name|nargs
init|=
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|gint
name|nreturn_vals
init|=
literal|0
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_newsprint"
argument_list|,
literal|"Re-sample the image to give a newspaper-like "
literal|"effect"
argument_list|,
literal|"Halftone the image, trading off "
literal|"resolution to represent colours or grey levels "
literal|"using the process described both in the PostScript "
literal|"language definition, and also by Robert Ulichney, "
literal|"\"Digital halftoning\", MIT Press, 1987."
argument_list|,
literal|"Austin Donnelly"
argument_list|,
literal|"Austin Donnelly"
argument_list|,
literal|"1998 ("
name|VERSION
literal|")"
argument_list|,
literal|"<Image>/Filters/Render/Newsprint"
argument_list|,
literal|"RGB*, GRAY*"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nargs
argument_list|,
name|nreturn_vals
argument_list|,
name|args
argument_list|,
name|return_vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparams,GParam * param,gint * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
comment|/* basic defaults */
name|pvals
operator|=
name|factory_defaults
expr_stmt|;
name|pvals_ui
operator|=
name|factory_defaults_ui
expr_stmt|;
comment|/*  Get the specified drawable  */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"plug_in_newsprint"
argument_list|,
operator|&
name|pvals
argument_list|)
expr_stmt|;
name|gimp_get_data
argument_list|(
literal|"plug_in_newsprint_ui"
argument_list|,
operator|&
name|pvals_ui
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|newsprint_dialog
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|15
condition|)
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
break|break;
block|}
name|pvals
operator|.
name|cell_width
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|colourspace
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|k_pullout
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|gry_ang
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|gry_spotfn
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|red_ang
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|red_spotfn
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|grn_ang
operator|=
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|grn_spotfn
operator|=
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|blu_ang
operator|=
name|param
index|[
literal|12
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|blu_spotfn
operator|=
name|param
index|[
literal|13
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|oversample
operator|=
name|param
index|[
literal|14
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/* check values are within permitted ranges */
if|if
condition|(
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|gry_spotfn
argument_list|)
operator|||
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|red_spotfn
argument_list|)
operator|||
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|grn_spotfn
argument_list|)
operator|||
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|blu_spotfn
argument_list|)
operator|||
operator|!
name|VALID_CS
argument_list|(
name|pvals
operator|.
name|colourspace
argument_list|)
operator|||
name|pvals
operator|.
name|k_pullout
operator|<
literal|0
operator|||
name|pvals
operator|.
name|k_pullout
operator|>
literal|100
condition|)
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"plug_in_newsprint"
argument_list|,
operator|&
name|pvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
comment|/*  Make sure that the drawable is gray or RGB color  */
if|if
condition|(
name|gimp_drawable_color
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
operator|||
name|gimp_drawable_gray
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
condition|)
block|{
name|gimp_progress_init
argument_list|(
literal|"Newsprintifing..."
argument_list|)
expr_stmt|;
comment|/*  set the tile cache size  */
name|gimp_tile_cache_ntiles
argument_list|(
name|TILE_CACHE_SIZE
argument_list|)
expr_stmt|;
comment|/*  run the newsprint effect  */
name|newsprint
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|!=
name|RUN_NONINTERACTIVE
condition|)
name|gimp_displays_flush
argument_list|()
expr_stmt|;
comment|/*  Store data  */
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|gimp_set_data
argument_list|(
literal|"plug_in_newsprint"
argument_list|,
operator|&
name|pvals
argument_list|,
sizeof|sizeof
argument_list|(
name|NewsprintValues
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_set_data
argument_list|(
literal|"plug_in_newsprint_ui"
argument_list|,
operator|&
name|pvals_ui
argument_list|,
sizeof|sizeof
argument_list|(
name|NewsprintUIValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*gimp_message ("newsprint: cannot operate on indexed images");*/
name|status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* create new menu state, and the preview widgets for it */
end_comment

begin_function
specifier|static
name|channel_st
modifier|*
DECL|function|new_preview (gint * sfn)
name|new_preview
parameter_list|(
name|gint
modifier|*
name|sfn
parameter_list|)
block|{
name|channel_st
modifier|*
name|st
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|st
operator|=
name|g_new
argument_list|(
name|channel_st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
operator|->
name|spotfn_num
operator|=
name|sfn
expr_stmt|;
comment|/* make the preview widgets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|preview
operator|=
name|gtk_preview_new
argument_list|(
name|GTK_PREVIEW_COLOR
argument_list|)
expr_stmt|;
name|gtk_preview_size
argument_list|(
name|GTK_PREVIEW
argument_list|(
name|preview
argument_list|)
argument_list|,
name|SPOT_PREVIEW_SZ
operator|*
literal|2
operator|+
literal|1
argument_list|,
name|SPOT_PREVIEW_SZ
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|st
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|widget
operator|=
name|preview
expr_stmt|;
name|st
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|label
operator|=
name|label
expr_stmt|;
comment|/* st->prev[i].value changed by preview_update */
block|}
return|return
name|st
return|;
block|}
end_function

begin_comment
comment|/* the popup menu "st" has changed, so the previews associated with it   * need re-calculation */
end_comment

begin_function
specifier|static
name|void
DECL|function|preview_update (channel_st * st)
name|preview_update
parameter_list|(
name|channel_st
modifier|*
name|st
parameter_list|)
block|{
name|gint
name|sfn
init|=
operator|*
operator|(
name|st
operator|->
name|spotfn_num
operator|)
decl_stmt|;
name|preview_st
modifier|*
name|prev
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gint
name|y
decl_stmt|;
name|gint
name|width
init|=
name|SPOT_PREVIEW_SZ
operator|*
name|PREVIEW_OVERSAMPLE
decl_stmt|;
name|gint
name|oversample
init|=
name|PREVIEW_OVERSAMPLE
decl_stmt|;
name|guchar
modifier|*
name|thresh
decl_stmt|;
name|gchar
name|pct
index|[
literal|12
index|]
decl_stmt|;
name|guchar
name|value
decl_stmt|;
name|guchar
name|row
index|[
literal|3
operator|*
operator|(
literal|2
operator|*
name|SPOT_PREVIEW_SZ
operator|+
literal|1
operator|)
index|]
decl_stmt|;
comment|/* If we don't yet have a preview threshold matrix for this spot      * function, generate one now. */
if|if
condition|(
operator|!
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_thresh
condition|)
block|{
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_thresh
operator|=
name|spot2thresh
argument_list|(
name|sfn
argument_list|,
name|SPOT_PREVIEW_SZ
operator|*
name|PREVIEW_OVERSAMPLE
argument_list|)
expr_stmt|;
block|}
name|thresh
operator|=
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_thresh
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|prev
operator|=
operator|&
name|st
operator|->
name|prev
index|[
name|i
index|]
expr_stmt|;
name|value
operator|=
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_lvl
index|[
name|i
index|]
operator|*
literal|0xff
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<=
name|SPOT_PREVIEW_SZ
operator|*
literal|2
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|SPOT_PREVIEW_SZ
operator|*
literal|2
condition|;
name|x
operator|++
control|)
block|{
name|guint32
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gint
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|gint
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|rx
operator|=
name|x
operator|*
name|PREVIEW_OVERSAMPLE
expr_stmt|;
name|ry
operator|=
name|y
operator|*
name|PREVIEW_OVERSAMPLE
expr_stmt|;
for|for
control|(
name|sy
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sy
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sy
operator|++
control|)
for|for
control|(
name|sx
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sx
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sx
operator|++
control|)
block|{
name|tx
operator|=
name|rx
operator|+
name|sx
expr_stmt|;
name|ty
operator|=
name|ry
operator|+
name|sy
expr_stmt|;
while|while
condition|(
name|tx
operator|<
literal|0
condition|)
name|tx
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|<
literal|0
condition|)
name|ty
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|tx
operator|>=
name|width
condition|)
name|tx
operator|-=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|>=
name|width
condition|)
name|ty
operator|-=
name|width
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|THRESH
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
condition|)
name|sum
operator|+=
literal|0xff
operator|*
name|BARTLETT
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
name|sum
operator|/=
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|*
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* blue lines on cell boundaries */
if|if
condition|(
operator|(
name|x
operator|%
name|SPOT_PREVIEW_SZ
operator|)
operator|==
literal|0
operator|||
operator|(
name|y
operator|%
name|SPOT_PREVIEW_SZ
operator|)
operator|==
literal|0
condition|)
block|{
name|row
index|[
name|x
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|row
index|[
name|x
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|row
index|[
name|x
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|row
index|[
name|x
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|sum
expr_stmt|;
name|row
index|[
name|x
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|sum
expr_stmt|;
name|row
index|[
name|x
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
name|gtk_preview_draw_row
argument_list|(
name|GTK_PREVIEW
argument_list|(
name|prev
operator|->
name|widget
argument_list|)
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|SPOT_PREVIEW_SZ
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* redraw preview widget */
name|gtk_widget_draw
argument_list|(
name|prev
operator|->
name|widget
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pct
argument_list|,
literal|"%2d%%"
argument_list|,
operator|(
name|int
operator|)
name|rint
argument_list|(
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_lvl
index|[
name|i
index|]
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_label_set
argument_list|(
name|GTK_LABEL
argument_list|(
name|prev
operator|->
name|label
argument_list|)
argument_list|,
name|pct
argument_list|)
expr_stmt|;
block|}
name|gdk_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_menu_callback (GtkWidget * widget,gpointer data)
name|newsprint_menu_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|channel_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gpointer
name|ud
decl_stmt|;
name|gint
name|menufn
decl_stmt|;
specifier|static
name|gint
name|in_progress
init|=
name|FALSE
decl_stmt|;
comment|/* we shouldn't need recursion protection, but if lock_channels is      * set, and gtk_option_menu_set_history ever generates an      * "activated" signal, then we'll get back here.  So we've defensive. */
if|if
condition|(
name|in_progress
condition|)
block|{
name|printf
argument_list|(
literal|"newsprint_menu_callback: unexpected recursion: "
literal|"can't happen\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|in_progress
operator|=
name|TRUE
expr_stmt|;
name|ud
operator|=
name|gtk_object_get_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|menufn
operator|=
name|GPOINTER_TO_INT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
operator|*
operator|(
name|st
operator|->
name|spotfn_num
operator|)
operator|=
name|menufn
expr_stmt|;
name|preview_update
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* ripple the change to the other popups if the channels are      * locked together. */
if|if
condition|(
name|pvals_ui
operator|.
name|lock_channels
condition|)
block|{
name|channel_st
modifier|*
name|c
init|=
name|st
operator|->
name|next
decl_stmt|;
name|gint
name|oldfn
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|st
condition|)
block|{
name|gtk_option_menu_set_history
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|c
operator|->
name|option_menu
argument_list|)
argument_list|,
name|menufn
argument_list|)
expr_stmt|;
name|oldfn
operator|=
operator|*
operator|(
name|c
operator|->
name|spotfn_num
operator|)
expr_stmt|;
operator|*
operator|(
name|c
operator|->
name|spotfn_num
operator|)
operator|=
name|menufn
expr_stmt|;
if|if
condition|(
name|oldfn
operator|!=
name|menufn
condition|)
name|preview_update
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
name|in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|angle_callback (gdouble new_val,gpointer data)
name|angle_callback
parameter_list|(
name|gdouble
name|new_val
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|channel_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|channel_st
modifier|*
name|c
decl_stmt|;
specifier|static
name|gint
name|in_progress
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|pvals_ui
operator|.
name|lock_channels
operator|&&
operator|!
name|in_progress
condition|)
block|{
name|in_progress
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
name|st
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|st
condition|)
block|{
name|entscale_set_value
argument_list|(
name|c
operator|->
name|entscale
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
name|in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|spi_callback (gdouble new_val,gpointer data)
name|spi_callback
parameter_list|(
name|gdouble
name|new_val
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|Entscale
modifier|*
name|save
decl_stmt|;
name|save
operator|=
name|st
operator|->
name|input_spi
expr_stmt|;
name|st
operator|->
name|input_spi
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|output_lpi
condition|)
name|entscale_set_value
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|,
name|new_val
operator|/
name|pvals
operator|.
name|cell_width
argument_list|)
expr_stmt|;
name|st
operator|->
name|input_spi
operator|=
name|save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|lpi_callback (gdouble new_val,gpointer data)
name|lpi_callback
parameter_list|(
name|gdouble
name|new_val
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|Entscale
modifier|*
name|save
decl_stmt|;
name|save
operator|=
name|st
operator|->
name|output_lpi
expr_stmt|;
name|st
operator|->
name|output_lpi
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|cellsize
condition|)
name|entscale_set_value
argument_list|(
name|st
operator|->
name|cellsize
argument_list|,
name|pvals_ui
operator|.
name|input_spi
operator|/
name|new_val
argument_list|)
expr_stmt|;
name|st
operator|->
name|output_lpi
operator|=
name|save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cellsize_callback (gdouble new_val,gpointer data)
name|cellsize_callback
parameter_list|(
name|gdouble
name|new_val
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|Entscale
modifier|*
name|save
decl_stmt|;
name|save
operator|=
name|st
operator|->
name|cellsize
expr_stmt|;
name|st
operator|->
name|cellsize
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|output_lpi
condition|)
name|entscale_set_value
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|,
name|pvals_ui
operator|.
name|input_spi
operator|/
name|pvals
operator|.
name|cell_width
argument_list|)
expr_stmt|;
name|st
operator|->
name|cellsize
operator|=
name|save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_channel_select_callback (GtkWidget * widget,gpointer data)
name|newsprint_channel_select_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|channel_st
modifier|*
name|chst
decl_stmt|;
name|chst
operator|=
name|gtk_object_get_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hide the current channel, and show our channel */
if|if
condition|(
name|st
operator|->
name|current_ch
condition|)
name|gtk_widget_hide
argument_list|(
name|st
operator|->
name|current_ch
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|chst
operator|->
name|frame
argument_list|)
expr_stmt|;
name|st
operator|->
name|current_ch
operator|=
name|chst
operator|->
name|frame
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_defaults_callback (GtkWidget * widget,gpointer data)
name|newsprint_defaults_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gint
name|saved_lock
decl_stmt|;
name|gint
name|cspace
decl_stmt|;
name|channel_st
modifier|*
modifier|*
name|chst
decl_stmt|;
specifier|const
name|chan_tmpl
modifier|*
name|ct
decl_stmt|;
name|gint
name|spotfn
decl_stmt|;
name|gint
name|c
decl_stmt|;
comment|/* temporarily turn off channel lock */
name|saved_lock
operator|=
name|pvals_ui
operator|.
name|lock_channels
expr_stmt|;
name|pvals_ui
operator|.
name|lock_channels
operator|=
name|FALSE
expr_stmt|;
comment|/* for each colourspace, reset its channel info */
for|for
control|(
name|cspace
operator|=
literal|0
init|;
name|cspace
operator|<
name|NUM_CS
condition|;
name|cspace
operator|++
control|)
block|{
name|chst
operator|=
name|st
operator|->
name|chst
index|[
name|cspace
index|]
expr_stmt|;
name|ct
operator|=
name|cspace_chan_tmpl
index|[
name|cspace
index|]
expr_stmt|;
comment|/* skip this colourspace if we haven't used it yet */
if|if
condition|(
operator|!
name|chst
index|[
literal|0
index|]
condition|)
continue|continue;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ct
operator|->
name|name
condition|)
block|{
name|entscale_set_value
argument_list|(
name|chst
index|[
name|c
index|]
operator|->
name|entscale
argument_list|,
operator|*
operator|(
name|ct
operator|->
name|factory_angle
operator|)
argument_list|)
expr_stmt|;
comment|/* change the popup menu and also activate the menuitem in 	     * question, in order to run the handler that re-computes 	     * the preview area */
name|spotfn
operator|=
operator|*
operator|(
name|ct
operator|->
name|factory_spotfn
operator|)
expr_stmt|;
name|gtk_option_menu_set_history
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|chst
index|[
name|c
index|]
operator|->
name|option_menu
argument_list|)
argument_list|,
name|spotfn
argument_list|)
expr_stmt|;
name|gtk_menu_item_activate
argument_list|(
name|GTK_MENU_ITEM
argument_list|(
name|chst
index|[
name|c
index|]
operator|->
name|menuitem
index|[
name|spotfn
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
name|ct
operator|++
expr_stmt|;
block|}
block|}
name|pvals_ui
operator|.
name|lock_channels
operator|=
name|saved_lock
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create (but don't yet show) a new frame for a channel 'widget'.  * Return the channel state, so caller can find the frame and place it  * in a container. */
end_comment

begin_function
specifier|static
name|channel_st
modifier|*
DECL|function|new_channel (const chan_tmpl * ct)
name|new_channel
parameter_list|(
specifier|const
name|chan_tmpl
modifier|*
name|ct
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|menu
decl_stmt|;
name|spot_info_t
modifier|*
name|sf
decl_stmt|;
name|channel_st
modifier|*
name|chst
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* create the channel state record */
name|chst
operator|=
name|new_preview
argument_list|(
name|ct
operator|->
name|spotfn
argument_list|)
expr_stmt|;
name|chst
operator|->
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|ct
operator|->
name|name
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|chst
operator|->
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|chst
operator|->
name|frame
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|chst
operator|->
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
comment|/* angle slider */
name|chst
operator|->
name|entscale
operator|=
name|entscale_new
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"angle"
argument_list|,
name|ENTSCALE_DOUBLE
argument_list|,
name|ct
operator|->
name|angle
argument_list|,
operator|-
literal|90.0
argument_list|,
literal|90.0
argument_list|,
literal|1.0
argument_list|,
name|TRUE
comment|/*constrain*/
argument_list|,
name|angle_callback
argument_list|,
name|chst
argument_list|)
expr_stmt|;
comment|/* spot function popup */
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"spot function"
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|chst
operator|->
name|option_menu
operator|=
name|gtk_option_menu_new
argument_list|()
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|chst
operator|->
name|option_menu
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|chst
operator|->
name|option_menu
argument_list|)
expr_stmt|;
name|menu
operator|=
name|gtk_menu_new
argument_list|()
expr_stmt|;
name|sf
operator|=
name|spotfn_list
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sf
operator|->
name|name
condition|)
block|{
name|chst
operator|->
name|menuitem
index|[
name|i
index|]
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
name|sf
operator|->
name|name
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|chst
operator|->
name|menuitem
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|"activate"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_menu_callback
argument_list|,
name|chst
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|chst
operator|->
name|menuitem
index|[
name|i
index|]
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|chst
operator|->
name|menuitem
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gtk_menu_append
argument_list|(
name|GTK_MENU
argument_list|(
name|menu
argument_list|)
argument_list|,
name|GTK_WIDGET
argument_list|(
name|chst
operator|->
name|menuitem
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sf
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|gtk_menu_set_active
argument_list|(
name|GTK_MENU
argument_list|(
name|menu
argument_list|)
argument_list|,
operator|*
name|ct
operator|->
name|spotfn
argument_list|)
expr_stmt|;
name|gtk_option_menu_set_menu
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|chst
operator|->
name|option_menu
argument_list|)
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|chst
operator|->
name|option_menu
argument_list|)
expr_stmt|;
comment|/* spot function previews go in table slots 1-2, 1-3 (double      * height) */
block|{
name|GtkWidget
modifier|*
name|sub
decl_stmt|;
name|GtkWidget
modifier|*
name|align
decl_stmt|;
name|sub
operator|=
name|gtk_table_new
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|sub
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|align
operator|=
name|gtk_alignment_new
argument_list|(
literal|0.5
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|align
argument_list|)
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|align
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|sub
argument_list|)
argument_list|,
name|chst
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|widget
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|sub
argument_list|)
argument_list|,
name|chst
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|label
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_show
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
comment|/* fire the update once to make sure we start with something      * in the preview windows */
name|preview_update
argument_list|(
name|chst
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* create the menuitem used to select this channel for editing */
name|chst
operator|->
name|ch_menuitem
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
name|ct
operator|->
name|name
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|chst
operator|->
name|ch_menuitem
argument_list|)
argument_list|,
name|chst
argument_list|)
expr_stmt|;
comment|/* signal attachment and showing left to caller */
comment|/* deliberately don't show the chst->frame, leave that up to      * the caller */
return|return
name|chst
return|;
block|}
end_function

begin_comment
comment|/* Make all the channels needed for "colourspace", and fill in  * the respective channel state fields in "st". */
end_comment

begin_function
specifier|static
name|void
DECL|function|gen_channels (NewsprintDialog_st * st,gint colourspace)
name|gen_channels
parameter_list|(
name|NewsprintDialog_st
modifier|*
name|st
parameter_list|,
name|gint
name|colourspace
parameter_list|)
block|{
specifier|static
name|int
name|cur_menu_num
init|=
literal|0
decl_stmt|;
specifier|const
name|chan_tmpl
modifier|*
name|ct
decl_stmt|;
name|channel_st
modifier|*
modifier|*
name|chst
decl_stmt|;
name|channel_st
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|chst
operator|=
name|st
operator|->
name|chst
index|[
name|colourspace
index|]
expr_stmt|;
name|ct
operator|=
name|cspace_chan_tmpl
index|[
name|colourspace
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ct
operator|->
name|name
condition|)
block|{
name|chst
index|[
name|i
index|]
operator|=
name|new_channel
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|chst
index|[
name|i
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|,
literal|"activate"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_channel_select_callback
argument_list|,
name|st
argument_list|)
expr_stmt|;
comment|/* only link in the menuitem if we're doing multiple channels */
if|if
condition|(
name|st
operator|->
name|channel_menu
condition|)
block|{
name|gtk_menu_append
argument_list|(
name|GTK_MENU
argument_list|(
name|st
operator|->
name|channel_menu
argument_list|)
argument_list|,
name|GTK_WIDGET
argument_list|(
name|chst
index|[
name|i
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|)
expr_stmt|;
name|chst
index|[
name|i
index|]
operator|->
name|ch_menu_num
operator|=
name|cur_menu_num
expr_stmt|;
name|cur_menu_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
name|chst
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|chst
index|[
name|i
index|]
expr_stmt|;
else|else
name|base
operator|=
name|chst
index|[
name|i
index|]
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|->
name|vbox
argument_list|)
argument_list|,
name|chst
index|[
name|i
index|]
operator|->
name|frame
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_reorder_child
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|->
name|vbox
argument_list|)
argument_list|,
name|chst
index|[
name|i
index|]
operator|->
name|frame
argument_list|,
literal|5
operator|+
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ct
operator|++
expr_stmt|;
block|}
comment|/* make the list circular */
name|chst
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|base
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|newsprint_dialog (GDrawable * drawable)
name|newsprint_dialog
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|gint
name|argc
decl_stmt|;
comment|/* widgets we need from callbacks stored here */
name|NewsprintDialog_st
name|st
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|align
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GSList
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|guchar
modifier|*
name|color_cube
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"newsprint"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gtk_rc_parse
argument_list|(
name|gimp_gtkrc
argument_list|()
argument_list|)
expr_stmt|;
name|gtk_preview_set_gamma
argument_list|(
name|gimp_gamma
argument_list|()
argument_list|)
expr_stmt|;
name|gtk_preview_set_install_cmap
argument_list|(
name|gimp_install_cmap
argument_list|()
argument_list|)
expr_stmt|;
name|color_cube
operator|=
name|gimp_color_cube
argument_list|()
expr_stmt|;
name|gtk_preview_set_color_cube
argument_list|(
name|color_cube
index|[
literal|0
index|]
argument_list|,
name|color_cube
index|[
literal|1
index|]
argument_list|,
name|color_cube
index|[
literal|2
index|]
argument_list|,
name|color_cube
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gtk_widget_set_default_visual
argument_list|(
name|gtk_preview_get_visual
argument_list|()
argument_list|)
expr_stmt|;
name|gtk_widget_set_default_colormap
argument_list|(
name|gtk_preview_get_cmap
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("newsprint: waiting... (pid %d)\n", getpid());     kill(getpid(), 19);
endif|#
directive|endif
comment|/* flag values to say we haven't filled these channel      * states in yet */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CS
condition|;
name|i
operator|++
control|)
name|st
operator|.
name|chst
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* we haven't shown any channels yet */
name|st
operator|.
name|current_ch
operator|=
name|NULL
expr_stmt|;
comment|/* need to know the bpp, so we can tell if we're doing       * RGB/CMYK or grey style of dialog box */
name|bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
condition|)
name|bpp
operator|--
expr_stmt|;
comment|/* force greyscale if it's the only thing we can do */
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
name|pvals
operator|.
name|colourspace
operator|=
name|CS_GREY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_GREY
condition|)
name|pvals
operator|.
name|colourspace
operator|=
name|CS_RGB
expr_stmt|;
block|}
name|st
operator|.
name|dlg
operator|=
name|gtk_dialog_new
argument_list|()
expr_stmt|;
name|gtk_window_set_title
argument_list|(
name|GTK_WINDOW
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
argument_list|,
literal|"Newsprint"
argument_list|)
expr_stmt|;
name|gtk_window_position
argument_list|(
name|GTK_WINDOW
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_close_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Action area  */
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_ok_callback
argument_list|,
name|st
operator|.
name|dlg
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_grab_default
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect_object
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|gtk_widget_destroy
argument_list|,
name|GTK_OBJECT
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
comment|/* resolution settings  */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"Resolution"
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GIMP_HAVE_RESOLUTION_INFO
block|{
name|float
name|xres
decl_stmt|,
name|yres
decl_stmt|;
name|gimp_image_get_resolution
argument_list|(
name|gimp_drawable_image_id
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
comment|/* XXX hack: should really note both resolutions, and use 	 * rectangular cells, not square cells.  But I'm being lazy, 	 * and the majority of the world works with xres == yres */
name|pvals_ui
operator|.
name|input_spi
operator|=
name|xres
expr_stmt|;
block|}
endif|#
directive|endif
name|st
operator|.
name|input_spi
operator|=
name|NULL
expr_stmt|;
name|st
operator|.
name|output_lpi
operator|=
name|NULL
expr_stmt|;
name|st
operator|.
name|cellsize
operator|=
name|NULL
expr_stmt|;
name|st
operator|.
name|input_spi
operator|=
name|entscale_new
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Input SPI "
argument_list|,
name|ENTSCALE_INT
argument_list|,
operator|&
name|pvals_ui
operator|.
name|input_spi
argument_list|,
literal|1.0
argument_list|,
literal|1200.0
argument_list|,
literal|5.0
argument_list|,
name|FALSE
comment|/*constrain*/
argument_list|,
name|spi_callback
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|st
operator|.
name|output_lpi
operator|=
name|entscale_new
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"Output LPI "
argument_list|,
name|ENTSCALE_DOUBLE
argument_list|,
operator|&
name|pvals_ui
operator|.
name|output_lpi
argument_list|,
literal|1.0
argument_list|,
literal|1200.0
argument_list|,
literal|5.0
argument_list|,
name|FALSE
comment|/*constrain*/
argument_list|,
name|lpi_callback
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|st
operator|.
name|cellsize
operator|=
name|entscale_new
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|"Cell size "
argument_list|,
name|ENTSCALE_INT
argument_list|,
operator|&
name|pvals
operator|.
name|cell_width
argument_list|,
literal|3.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|FALSE
comment|/*constrain*/
argument_list|,
name|cellsize_callback
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* screen settings */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"Screen"
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|.
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|st
operator|.
name|vbox
argument_list|)
expr_stmt|;
comment|/* we only create the channel menu and option menu if there are       * more than one channels involved */
name|st
operator|.
name|channel_menu
operator|=
name|NULL
expr_stmt|;
name|st
operator|.
name|channel_option
operator|=
name|NULL
expr_stmt|;
comment|/* optional portion begins */
if|if
condition|(
name|bpp
operator|!=
literal|1
condition|)
block|{
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
argument_list|,
name|table
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* black pullout */
name|st
operator|.
name|pull
operator|=
name|entscale_new
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"Black pullout (%)"
argument_list|,
name|ENTSCALE_INT
argument_list|,
operator|&
name|pvals
operator|.
name|k_pullout
argument_list|,
literal|0.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
name|TRUE
comment|/*constrain*/
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|entscale_set_sensitive
argument_list|(
name|st
operator|.
name|pull
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_CMYK
operator|)
argument_list|)
expr_stmt|;
comment|/* RGB / CMYK / Intensity select */
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Separate to"
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|group
argument_list|,
literal|"RGB"
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_RGB
operator|)
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_cspace_update
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|CS_RGB
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|group
argument_list|,
literal|"CMYK"
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_CMYK
operator|)
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_cspace_update
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|CS_CMYK
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_radio_button_new_with_label
argument_list|(
name|group
argument_list|,
literal|"Intensity"
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_INTENSITY
operator|)
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_cspace_update
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|CS_INTENSITY
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|hbox
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* channel lock& factory defaults button */
name|align
operator|=
name|gtk_alignment_new
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.1
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbutton_box_new
argument_list|()
expr_stmt|;
name|gtk_button_box_set_spacing
argument_list|(
name|GTK_BUTTON_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_button_box_set_layout
argument_list|(
name|GTK_BUTTON_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|GTK_BUTTONBOX_SPREAD
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|align
argument_list|)
argument_list|,
name|hbox
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
argument_list|,
name|align
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure it went in the right place, since colourspace 	 * radio button callbacks may have already inserted the 	 * channel frames */
name|gtk_box_reorder_child
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|align
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Lock channels"
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_toggle_update
argument_list|,
operator|&
name|pvals_ui
operator|.
name|lock_channels
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pvals_ui
operator|.
name|lock_channels
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|st
operator|.
name|channel_menu
operator|=
name|gtk_menu_new
argument_list|()
expr_stmt|;
name|st
operator|.
name|channel_option
operator|=
name|gtk_option_menu_new
argument_list|()
expr_stmt|;
name|gtk_option_menu_set_menu
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|st
operator|.
name|channel_option
argument_list|)
argument_list|,
name|st
operator|.
name|channel_menu
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|st
operator|.
name|channel_option
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|st
operator|.
name|channel_option
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Factory defaults"
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|newsprint_defaults_callback
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
block|}
comment|/* Make the channels appropriate for this colourspace and      * currently selected defaults.  They may have already been      * created as a result of callbacks to cspace_update from      * gtk_toggle_button_set_state().  Other channel frames are      * created lazily the first time they are required. */
if|if
condition|(
operator|!
name|st
operator|.
name|chst
index|[
name|pvals
operator|.
name|colourspace
index|]
index|[
literal|0
index|]
condition|)
block|{
name|channel_st
modifier|*
modifier|*
name|chst
decl_stmt|;
name|gen_channels
argument_list|(
operator|&
name|st
argument_list|,
name|pvals
operator|.
name|colourspace
argument_list|)
expr_stmt|;
name|chst
operator|=
name|st
operator|.
name|chst
index|[
name|pvals
operator|.
name|colourspace
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cspace_nchans
index|[
name|pvals
operator|.
name|colourspace
index|]
condition|;
name|i
operator|++
control|)
name|gtk_widget_show
argument_list|(
name|GTK_WIDGET
argument_list|(
name|chst
index|[
name|i
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* select the first channel to edit */
if|if
condition|(
name|st
operator|.
name|channel_option
condition|)
name|gtk_option_menu_set_history
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|st
operator|.
name|channel_option
argument_list|)
argument_list|,
name|chst
index|[
literal|0
index|]
operator|->
name|ch_menu_num
argument_list|)
expr_stmt|;
name|gtk_menu_item_activate
argument_list|(
name|GTK_MENU_ITEM
argument_list|(
name|chst
index|[
literal|0
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_show
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* anti-alias control */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"Anti-alias"
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|entscale_new
argument_list|(
name|table
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"oversample "
argument_list|,
name|ENTSCALE_INT
argument_list|,
operator|&
name|pvals
operator|.
name|oversample
argument_list|,
literal|1.0
argument_list|,
literal|15.0
argument_list|,
literal|1.0
argument_list|,
name|TRUE
comment|/*constrain*/
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|st
operator|.
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|pint
operator|.
name|run
return|;
block|}
end_function

begin_comment
comment|/*  Newsprint interface functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|newsprint_close_callback (GtkWidget * widget,gpointer data)
name|newsprint_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_ok_callback (GtkWidget * widget,gpointer data)
name|newsprint_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|pint
operator|.
name|run
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_toggle_update (GtkWidget * widget,gpointer data)
name|newsprint_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|int
modifier|*
name|toggle_val
decl_stmt|;
name|toggle_val
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|toggle_val
operator|=
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_cspace_update (GtkWidget * widget,gpointer data)
name|newsprint_cspace_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
decl_stmt|;
name|gint
name|new_cs
init|=
name|GPOINTER_TO_INT
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gint
name|old_cs
init|=
name|pvals
operator|.
name|colourspace
decl_stmt|;
name|channel_st
modifier|*
modifier|*
name|chst
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|st
operator|=
name|gtk_object_get_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
condition|)
name|printf
argument_list|(
literal|"newsprint: cspace_update: no state, can't happen!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
block|{
comment|/* the CMYK widget looks after the black pullout widget */
if|if
condition|(
name|new_cs
operator|==
name|CS_CMYK
condition|)
block|{
name|entscale_set_sensitive
argument_list|(
name|st
operator|->
name|pull
argument_list|,
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
argument_list|)
expr_stmt|;
block|}
comment|/* if we're not activate, then there's nothing more to do */
if|if
condition|(
operator|!
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
condition|)
return|return;
name|pvals
operator|.
name|colourspace
operator|=
name|new_cs
expr_stmt|;
comment|/* make sure we have the necessary channels for the new          * colourspace */
if|if
condition|(
operator|!
name|st
operator|->
name|chst
index|[
name|new_cs
index|]
index|[
literal|0
index|]
condition|)
name|gen_channels
argument_list|(
name|st
argument_list|,
name|new_cs
argument_list|)
expr_stmt|;
comment|/* hide the old channels (if any) */
if|if
condition|(
name|st
operator|->
name|chst
index|[
name|old_cs
index|]
index|[
literal|0
index|]
condition|)
block|{
name|chst
operator|=
name|st
operator|->
name|chst
index|[
name|old_cs
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cspace_nchans
index|[
name|old_cs
index|]
condition|;
name|i
operator|++
control|)
name|gtk_widget_hide
argument_list|(
name|GTK_WIDGET
argument_list|(
name|chst
index|[
name|i
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* show the new channels */
name|chst
operator|=
name|st
operator|->
name|chst
index|[
name|new_cs
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cspace_nchans
index|[
name|new_cs
index|]
condition|;
name|i
operator|++
control|)
name|gtk_widget_show
argument_list|(
name|GTK_WIDGET
argument_list|(
name|chst
index|[
name|i
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and select the first one */
name|gtk_option_menu_set_history
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|st
operator|->
name|channel_option
argument_list|)
argument_list|,
name|chst
index|[
literal|0
index|]
operator|->
name|ch_menu_num
argument_list|)
expr_stmt|;
name|gtk_menu_item_activate
argument_list|(
name|GTK_MENU_ITEM
argument_list|(
name|chst
index|[
literal|0
index|]
operator|->
name|ch_menuitem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Newsprint Effect  */
end_comment

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* Spot functions */
end_comment

begin_comment
comment|/* Spot functions define the order in which pixels should be whitened  * as a cell lightened in colour.  They are defined over the entire  * cell, and are called over each pixel in the cell.  The cell  * co-ordinate space ranges from -1.0 .. +1.0 inclusive, in both x- and  * y-axes.  *  * This means the spot function f(x, y) must be defined for:  *     -1<= x<= +1, where x is a real number,   and  *     -1<= y<= +1, where y is a real number.  *  * The function f's range is -1.0 .. +1.0 inclusive, but it is  * permissible for f to return values outside this range: the nearest  * valid value will be used instead.  NOTE: this is in contrast with  * PostScript spot functions, where it is a RangeError for the spot  * function to go outside these limits.  *  * An initially black cell is filled from lowest spot function value  * to highest.  The actual values returned do not matter - it is their  * relative orderings that count.  This means that spot functions do  * not need to be tonally balanced.  A tonally balanced spot function  * is one which for all slices though the function (eg say at z), the  * area of the slice = 4z.  In particular, almost all PostScript spot  * functions are _not_ tonally balanced.  */
end_comment

begin_comment
comment|/* The classic growing dot spot function.  This one isn't tonally  * balanced.  It can be made so, but it's _really_ ugly.  Thanks to  * Richard Mortier for this one:  *  * #define a(r) \  *     ((r<=1)? M_PI * (r*r) : \  *	4 * sqrt(r*r - 1)  +  M_PI*r*r  -  4*r*r*acos(1/r))  *  *   radius = sqrt(x*x + y*y);  *  * return a(radius) / 4; */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_round (gdouble x,gdouble y)
name|spot_round
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
return|return
literal|1
operator|-
operator|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Another commonly seen spot function is the v-shaped wedge. Tonally  * balanced. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_line (gdouble x,gdouble y)
name|spot_line
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
return|return
name|ABS
argument_list|(
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Square/Diamond dot that never becomes round.  Tonally balanced. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_diamond (gdouble x,gdouble y)
name|spot_diamond
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gdouble
name|xy
init|=
name|ABS
argument_list|(
name|x
argument_list|)
operator|+
name|ABS
argument_list|(
name|y
argument_list|)
decl_stmt|;
comment|/* spot only valid for 0<= xy<= 2 */
return|return
operator|(
operator|(
name|xy
operator|<=
literal|1
operator|)
condition|?
literal|2
operator|*
name|xy
operator|*
name|xy
else|:
literal|2
operator|*
name|xy
operator|*
name|xy
operator|-
literal|4
operator|*
operator|(
name|xy
operator|-
literal|1
operator|)
operator|*
operator|(
name|xy
operator|-
literal|1
operator|)
operator|)
operator|/
literal|4
return|;
block|}
end_function

begin_comment
comment|/* The following functions were derived from a peice of PostScript by  * Peter Fink and published in his book, "PostScript Screening: Adobe  * Accurate Screens" (Adobe Press, 1992).  Adobe Systems Incorporated  * allow its use, provided the following copyright message is present:  *  *  % Film Test Pages for Screenset Development  *  % Copyright (c) 1991 and 1992 Adobe Systems Incorporated  *  % All rights reserved.  *  %  *  % NOTICE: This code is copyrighted by Adobe Systems Incorporated, and  *  % may not be reproduced for sale except by permission of Adobe Systems  *  % Incorporated. Adobe Systems Incorporated grants permission to use  *  % this code for the development of screen sets for use with Adobe  *  % Accurate Screens software, as long as the copyright notice remains  *  % intact.  *  %  *  % By Peter Fink 1991/1992  */
end_comment

begin_comment
comment|/* Square (or Euclidean) dot.  Also very common. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_PSsquare (gdouble x,gdouble y)
name|spot_PSsquare
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gdouble
name|ax
init|=
name|ABS
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|gdouble
name|ay
init|=
name|ABS
argument_list|(
name|y
argument_list|)
decl_stmt|;
return|return
operator|(
name|ax
operator|+
name|ay
operator|)
operator|>
literal|1
condition|?
operator|(
operator|(
name|ay
operator|-
literal|1
operator|)
operator|*
operator|(
name|ay
operator|-
literal|1
operator|)
operator|+
operator|(
name|ax
operator|-
literal|1
operator|)
operator|*
operator|(
name|ax
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
else|:
literal|1
operator|-
operator|(
name|ay
operator|*
name|ay
operator|+
name|ax
operator|*
name|ax
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Diamond spot function, again from Peter Fink's PostScript  * original.  Copyright as for previous function. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_PSdiamond (gdouble x,gdouble y)
name|spot_PSdiamond
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gdouble
name|ax
init|=
name|ABS
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|gdouble
name|ay
init|=
name|ABS
argument_list|(
name|y
argument_list|)
decl_stmt|;
return|return
operator|(
name|ax
operator|+
name|ay
operator|)
operator|<=
literal|0.75
condition|?
literal|1
operator|-
operator|(
name|ax
operator|*
name|ax
operator|+
name|ay
operator|*
name|ay
operator|)
else|:
comment|/* dot */
operator|(
operator|(
name|ax
operator|+
name|ay
operator|)
operator|<=
literal|1.23
condition|?
literal|1
operator|-
operator|(
operator|(
name|ay
operator|*
literal|0.76
operator|)
operator|+
name|ax
operator|)
else|:
comment|/* to diamond (0.76 distort) */
operator|(
operator|(
name|ay
operator|-
literal|1
operator|)
operator|*
operator|(
name|ay
operator|-
literal|1
operator|)
operator|+
operator|(
name|ax
operator|-
literal|1
operator|)
operator|*
operator|(
name|ax
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* back to dot */
block|}
end_function

begin_comment
comment|/* end of Adobe Systems Incorporated copyrighted functions */
end_comment

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* Spot function to threshold matrix conversion */
end_comment

begin_comment
comment|/* Each call of the spot function results in one of these */
end_comment

begin_typedef
DECL|struct|__anon275750700a08
typedef|typedef
struct|struct
block|{
DECL|member|index
name|gint
name|index
decl_stmt|;
comment|/* (y * width) + x */
DECL|member|value
name|gdouble
name|value
decl_stmt|;
comment|/* return value of the spot function */
DECL|typedef|order_t
block|}
name|order_t
typedef|;
end_typedef

begin_comment
comment|/* qsort(3) compare function */
end_comment

begin_function
specifier|static
name|int
DECL|function|order_cmp (const void * va,const void * vb)
name|order_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|order_t
modifier|*
name|a
init|=
name|va
decl_stmt|;
specifier|const
name|order_t
modifier|*
name|b
init|=
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|value
operator|<
name|b
operator|->
name|value
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|a
operator|->
name|value
operator|>
name|b
operator|->
name|value
operator|)
condition|?
operator|+
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert spot function "type" to a threshold matrix of size "width"  * times "width".  Returns newly allocated threshold matrix.  The  * reason for qsort()ing the results rather than just using the spot  * function's value directly as the threshold value is that we want to  * ensure that the threshold matrix is tonally balanced - that is, for  * a threshold value of x%, x% of the values in the matrix are< x%.  *  * Actually, it turns out that qsort()ing a function which is already  * balanced can quite significantly detract from the quality of the  * final result.  This is particularly noticable with the line or  * diamond spot functions at 45 degrees.  This is because if the spot  * function has multiple locations with the same value, qsort may use  * them in any order.  Often, there is quite clearly an optimal order  * however.  By marking functions as pre-balanced, this random  * shuffling is avoided.  WARNING: a non-balanced spot function marked  * as pre-balanced is bad: you'll end up with dark areas becoming too  * dark or too light, and vice versa for light areas.  This is most  * easily checked by halftoning an area, then bluring it back - you  * should get the same colour back again.  The only way of getting a  * correctly balanced function is by getting a formula for the spot's  * area as a function of x and y - this can be fairly tough (ie  * possiblly an integral in two dimensions that must be solved  * analytically).  *  * The threshold matrix is used to compare against image values.  If  * the image value is greater than the threshold value, then the  * output pixel is illuminated.  This means that a threshold matrix  * entry of 0 never causes output pixels to be illuminated.  */
end_comment

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|spot2thresh (gint type,gint width)
name|spot2thresh
parameter_list|(
name|gint
name|type
parameter_list|,
name|gint
name|width
parameter_list|)
block|{
name|gdouble
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gdouble
name|val
decl_stmt|;
name|spotfn_t
modifier|*
name|spotfn
decl_stmt|;
name|guchar
modifier|*
name|thresh
decl_stmt|;
name|order_t
modifier|*
name|order
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|wid2
init|=
name|width
operator|*
name|width
decl_stmt|;
name|gint
name|balanced
init|=
name|spotfn_list
index|[
name|type
index|]
operator|.
name|balanced
decl_stmt|;
name|thresh
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|wid2
argument_list|)
expr_stmt|;
name|spotfn
operator|=
name|spotfn_list
index|[
name|type
index|]
operator|.
name|fn
expr_stmt|;
name|order
operator|=
name|g_new
argument_list|(
name|order_t
argument_list|,
name|wid2
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|width
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
comment|/* scale x& y to -1 ... +1 inclusive */
name|sx
operator|=
operator|(
operator|(
operator|(
name|gdouble
operator|)
name|x
operator|)
operator|/
operator|(
name|width
operator|-
literal|1
operator|)
operator|-
literal|0.5
operator|)
operator|*
literal|2
expr_stmt|;
name|sy
operator|=
operator|(
operator|(
operator|(
name|gdouble
operator|)
name|y
operator|)
operator|/
operator|(
name|width
operator|-
literal|1
operator|)
operator|-
literal|0.5
operator|)
operator|*
literal|2
expr_stmt|;
name|val
operator|=
name|spotfn
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|val
operator|=
name|BOUNDS
argument_list|(
name|val
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* interval is inclusive */
name|order
index|[
name|i
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|order
index|[
name|i
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|balanced
condition|)
block|{
comment|/* now sort array of (point, value) pairs in ascending order */
name|qsort
argument_list|(
name|order
argument_list|,
name|wid2
argument_list|,
sizeof|sizeof
argument_list|(
name|order_t
argument_list|)
argument_list|,
name|order_cmp
argument_list|)
expr_stmt|;
block|}
comment|/* compile threshold matrix in order from darkest to lightest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wid2
condition|;
name|i
operator|++
control|)
block|{
comment|/* thresh[] contains values from 0 .. 254.  The reason for not 	 * including 255 is so that an image value of 255 remains 	 * unmolested.  It would be bad to filter a completely white 	 * image and end up with black speckles.  */
if|if
condition|(
name|balanced
condition|)
name|thresh
index|[
name|order
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
name|order
index|[
name|i
index|]
operator|.
name|value
operator|*
literal|0xfe
expr_stmt|;
else|else
name|thresh
index|[
name|order
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
name|i
operator|*
literal|0xff
operator|/
name|wid2
expr_stmt|;
block|}
name|g_free
argument_list|(
name|order
argument_list|)
expr_stmt|;
comment|/* TODO: this is where the code to apply a transfer or dot gain      * function to the threshold matrix would go. */
return|return
name|thresh
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* Main loop */
end_comment

begin_comment
comment|/* This function operates on the image, striding across it in tiles. */
end_comment

begin_function
specifier|static
name|void
DECL|function|newsprint (GDrawable * drawable)
name|newsprint
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GPixelRgn
name|src_rgn
decl_stmt|,
name|dest_rgn
decl_stmt|;
name|guchar
modifier|*
name|src_row
decl_stmt|,
modifier|*
name|dest_row
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|guchar
modifier|*
name|thresh
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|r
decl_stmt|;
name|gdouble
name|theta
decl_stmt|;
name|gdouble
name|rot
index|[
literal|4
index|]
decl_stmt|;
name|gdouble
name|k_pullout
decl_stmt|;
name|gint
name|bpp
decl_stmt|,
name|colour_bpp
decl_stmt|;
name|gint
name|has_alpha
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|tile_width
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|x_step
decl_stmt|,
name|y_step
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|gint
name|progress
decl_stmt|,
name|max_progress
decl_stmt|;
name|gint
name|oversample
decl_stmt|;
name|gint
name|colourspace
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|w002
decl_stmt|;
name|TM_INIT
argument_list|()
expr_stmt|;
name|width
operator|=
name|pvals
operator|.
name|cell_width
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
operator|-
name|width
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|1
condition|)
name|width
operator|=
literal|1
expr_stmt|;
name|oversample
operator|=
name|pvals
operator|.
name|oversample
expr_stmt|;
name|k_pullout
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|pvals
operator|.
name|k_pullout
operator|)
operator|/
literal|100.0
expr_stmt|;
name|width
operator|*=
name|oversample
expr_stmt|;
name|tile_width
operator|=
name|gimp_tile_width
argument_list|()
expr_stmt|;
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
operator|->
name|id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|colour_bpp
operator|=
name|has_alpha
condition|?
name|bpp
operator|-
literal|1
else|:
name|bpp
expr_stmt|;
name|colourspace
operator|=
name|pvals
operator|.
name|colourspace
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
name|colourspace
operator|=
name|CS_GREY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|colourspace
operator|==
name|CS_GREY
condition|)
name|colourspace
operator|=
name|CS_RGB
expr_stmt|;
block|}
comment|/* Bartlett window matrix optimisation */
name|w002
operator|=
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|*
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It turns out to be slightly slower to cache a pre-computed      * bartlett matrix!   I put it down to d-cache pollution *shrug* */
block|wgt = g_new(gint, oversample*oversample);     for(y=-oversample/2; y<=oversample/2; y++) 	for(x=-oversample/2; x<=oversample/2; x++) 	    WGT(x,y) = BARTLETT(x,y);
endif|#
directive|endif
comment|/* 0 */
DECL|macro|ASRT (_x)
define|#
directive|define
name|ASRT
parameter_list|(
name|_x
parameter_list|)
define|\
value|do {								\     if (!VALID_SPOTFN(_x))					\     {								\ 	printf("newsprint: %d is not a valid spot type\n", _x);	\ 	_x = SPOTFN_DOT;					\     }								\ } while(0)
comment|/* calculate the RGB / CMYK rotations and threshold matrices */
if|if
condition|(
name|bpp
operator|==
literal|1
operator|||
name|colourspace
operator|==
name|CS_INTENSITY
condition|)
block|{
name|rot
index|[
literal|0
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|gry_ang
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|0
index|]
operator|=
name|spot2thresh
argument_list|(
name|pvals
operator|.
name|gry_spotfn
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gint
name|rf
init|=
name|pvals
operator|.
name|red_spotfn
decl_stmt|;
name|gint
name|gf
init|=
name|pvals
operator|.
name|grn_spotfn
decl_stmt|;
name|gint
name|bf
init|=
name|pvals
operator|.
name|blu_spotfn
decl_stmt|;
name|rot
index|[
literal|0
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|red_ang
argument_list|)
expr_stmt|;
name|rot
index|[
literal|1
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|grn_ang
argument_list|)
expr_stmt|;
name|rot
index|[
literal|2
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|blu_ang
argument_list|)
expr_stmt|;
comment|/* always need at least one threshold matrix */
name|ASRT
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|spotfn_list
index|[
name|rf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|rf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|0
index|]
operator|=
name|spotfn_list
index|[
name|rf
index|]
operator|.
name|thresh
expr_stmt|;
comment|/* optimisation: only use separate threshold matrices if the 	 * spot functions are actually different */
name|ASRT
argument_list|(
name|gf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
condition|)
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|gf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|1
index|]
operator|=
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
expr_stmt|;
name|ASRT
argument_list|(
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spotfn_list
index|[
name|bf
index|]
operator|.
name|thresh
condition|)
name|spotfn_list
index|[
name|bf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|bf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|2
index|]
operator|=
name|spotfn_list
index|[
name|bf
index|]
operator|.
name|thresh
expr_stmt|;
if|if
condition|(
name|colourspace
operator|==
name|CS_CMYK
condition|)
block|{
name|rot
index|[
literal|3
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|gry_ang
argument_list|)
expr_stmt|;
name|gf
operator|=
name|pvals
operator|.
name|gry_spotfn
expr_stmt|;
name|ASRT
argument_list|(
name|gf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
condition|)
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|gf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|3
index|]
operator|=
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
expr_stmt|;
block|}
block|}
comment|/* Initialize progress */
name|progress
operator|=
literal|0
expr_stmt|;
name|max_progress
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|TM_START
argument_list|()
expr_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<
name|y2
condition|;
name|y
operator|+=
name|tile_width
operator|-
operator|(
name|y
operator|%
name|tile_width
operator|)
control|)
block|{
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<
name|x2
condition|;
name|x
operator|+=
name|tile_width
operator|-
operator|(
name|x
operator|%
name|tile_width
operator|)
control|)
block|{
comment|/* snap to tile boundary */
name|x_step
operator|=
name|tile_width
operator|-
operator|(
name|x
operator|%
name|tile_width
operator|)
expr_stmt|;
name|y_step
operator|=
name|tile_width
operator|-
operator|(
name|y
operator|%
name|tile_width
operator|)
expr_stmt|;
comment|/* don't step off the end of the image */
name|x_step
operator|=
name|MIN
argument_list|(
name|x_step
argument_list|,
name|x2
operator|-
name|x
argument_list|)
expr_stmt|;
name|y_step
operator|=
name|MIN
argument_list|(
name|y_step
argument_list|,
name|y2
operator|-
name|y
argument_list|)
expr_stmt|;
comment|/* set up the source and dest regions */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x_step
argument_list|,
name|y_step
argument_list|,
name|FALSE
comment|/*dirty*/
argument_list|,
name|FALSE
comment|/*shadow*/
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|drawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x_step
argument_list|,
name|y_step
argument_list|,
name|TRUE
comment|/*dirty*/
argument_list|,
name|TRUE
comment|/*shadow*/
argument_list|)
expr_stmt|;
comment|/* page in the image, one tile at a time */
for|for
control|(
name|pr
operator|=
name|gimp_pixel_rgns_register
argument_list|(
literal|2
argument_list|,
operator|&
name|src_rgn
argument_list|,
operator|&
name|dest_rgn
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|gimp_pixel_rgns_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src_row
operator|=
name|src_rgn
operator|.
name|data
expr_stmt|;
name|dest_row
operator|=
name|dest_rgn
operator|.
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|src_rgn
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|src
operator|=
name|src_row
expr_stmt|;
name|dest
operator|=
name|dest_row
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|src_rgn
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
name|guchar
name|data
index|[
literal|4
index|]
decl_stmt|;
name|rx
operator|=
operator|(
name|x
operator|+
name|col
operator|)
operator|*
name|oversample
expr_stmt|;
name|ry
operator|=
operator|(
name|y
operator|+
name|row
operator|)
operator|*
name|oversample
expr_stmt|;
comment|/* convert rx and ry to polar (r, theta) */
name|r
operator|=
name|sqrt
argument_list|(
operator|(
operator|(
name|double
operator|)
name|rx
operator|)
operator|*
name|rx
operator|+
operator|(
operator|(
name|double
operator|)
name|ry
operator|)
operator|*
name|ry
argument_list|)
expr_stmt|;
name|theta
operator|=
name|atan2
argument_list|(
operator|(
operator|(
name|gdouble
operator|)
name|ry
operator|)
argument_list|,
operator|(
operator|(
name|gdouble
operator|)
name|rx
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|colour_bpp
condition|;
name|b
operator|++
control|)
name|data
index|[
name|b
index|]
operator|=
name|src
index|[
name|b
index|]
expr_stmt|;
comment|/* do colour space conversion */
switch|switch
condition|(
name|colourspace
condition|)
block|{
case|case
name|CS_CMYK
case|:
name|data
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|1
index|]
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|2
index|]
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|data
index|[
literal|3
index|]
operator|)
operator|*
name|k_pullout
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|-=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|-=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|-=
name|data
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|CS_INTENSITY
case|:
name|data
index|[
literal|3
index|]
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* save orig for later */
name|data
index|[
literal|0
index|]
operator|=
name|INTENSITY
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|cspace_nchans
index|[
name|colourspace
index|]
condition|;
name|b
operator|++
control|)
block|{
name|rx
operator|=
name|rint
argument_list|(
name|r
operator|*
name|cos
argument_list|(
name|theta
operator|+
name|rot
index|[
name|b
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ry
operator|=
name|rint
argument_list|(
name|r
operator|*
name|sin
argument_list|(
name|theta
operator|+
name|rot
index|[
name|b
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure rx and ry are positive and within 			     * the range 0 .. width-1 (incl).  Can't use % 			     * operator, since its definition on negative 			     * numbers is not helpful.  Can't use ABS(), 			     * since that would cause reflection about the 			     * x- and y-axes.  Relies on integer division 			     * rounding towards zero. */
name|rx
operator|-=
operator|(
operator|(
name|rx
operator|-
name|ISNEG
argument_list|(
name|rx
argument_list|)
operator|*
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|/
name|width
operator|)
operator|*
name|width
expr_stmt|;
name|ry
operator|-=
operator|(
operator|(
name|ry
operator|-
name|ISNEG
argument_list|(
name|ry
argument_list|)
operator|*
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|/
name|width
operator|)
operator|*
name|width
expr_stmt|;
block|{
name|guint32
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gint
name|tx
decl_stmt|,
name|ty
decl_stmt|;
for|for
control|(
name|sy
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sy
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sy
operator|++
control|)
for|for
control|(
name|sx
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sx
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sx
operator|++
control|)
block|{
name|tx
operator|=
name|rx
operator|+
name|sx
expr_stmt|;
name|ty
operator|=
name|ry
operator|+
name|sy
expr_stmt|;
while|while
condition|(
name|tx
operator|<
literal|0
condition|)
name|tx
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|<
literal|0
condition|)
name|ty
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|tx
operator|>=
name|width
condition|)
name|tx
operator|-=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|>=
name|width
condition|)
name|ty
operator|-=
name|width
expr_stmt|;
if|if
condition|(
name|data
index|[
name|b
index|]
operator|>
name|THRESHn
argument_list|(
name|b
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|)
condition|)
name|sum
operator|+=
literal|0xff
operator|*
name|BARTLETT
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
name|sum
operator|/=
name|w002
expr_stmt|;
name|data
index|[
name|b
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has_alpha
condition|)
name|dest
index|[
name|colour_bpp
index|]
operator|=
name|src
index|[
name|colour_bpp
index|]
expr_stmt|;
comment|/* re-pack the colours into RGB */
switch|switch
condition|(
name|colourspace
condition|)
block|{
case|case
name|CS_CMYK
case|:
name|data
index|[
literal|0
index|]
operator|=
name|CLAMPED_ADD
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|CLAMPED_ADD
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|CLAMPED_ADD
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|1
index|]
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|CS_INTENSITY
case|:
if|if
condition|(
name|has_alpha
condition|)
block|{
name|dest
index|[
name|colour_bpp
index|]
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
name|data
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|*
name|data
index|[
literal|0
index|]
operator|/
literal|0xff
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|2
index|]
operator|*
name|data
index|[
literal|0
index|]
operator|/
literal|0xff
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|3
index|]
operator|*
name|data
index|[
literal|0
index|]
operator|/
literal|0xff
expr_stmt|;
break|break;
default|default:
comment|/* no other special cases */
break|break;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|colour_bpp
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|data
index|[
name|b
index|]
expr_stmt|;
name|src
operator|+=
name|src_rgn
operator|.
name|bpp
expr_stmt|;
name|dest
operator|+=
name|dest_rgn
operator|.
name|bpp
expr_stmt|;
block|}
name|src_row
operator|+=
name|src_rgn
operator|.
name|rowstride
expr_stmt|;
name|dest_row
operator|+=
name|dest_rgn
operator|.
name|rowstride
expr_stmt|;
block|}
comment|/* Update progress */
name|progress
operator|+=
name|src_rgn
operator|.
name|w
operator|*
name|src_rgn
operator|.
name|h
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|progress
operator|/
operator|(
name|double
operator|)
name|max_progress
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TM_END
argument_list|()
expr_stmt|;
comment|/* We don't free the threshold matrices, since we're about to      * exit, and the OS should clean up after us. */
comment|/* update the affected region */
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drawable
operator|->
name|id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drawable
operator|->
name|id
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* Support routines */
end_comment

begin_comment
comment|/* Lightly modified entscale:  *  o Added entscale_set_sensitive() method */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/**									**/
end_comment

begin_comment
comment|/**			+++ Entscale					**/
end_comment

begin_comment
comment|/**									**/
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/* these routines are taken from gflare.c */
end_comment

begin_comment
comment|/* -*- mode:c -*- */
end_comment

begin_comment
comment|/*   Entry and Scale pair (int and double integrated)    This is an attempt to combine entscale_int and double.   Never compiled yet.    TODO:   - Do the proper thing when the user changes value in entry,   so that callback should not be called when value is actually not changed.   - Update delay  */
end_comment

begin_function_decl
specifier|static
name|void
name|entscale_destroy_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entscale_entry_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Create an entry, a scale and a label, then attach them to  *  specified table.  *  1 row and 2 cols of table are needed.  *  *  Input:  *    table:	  table which entscale is attached to  *    x, y:	  starting row and col in table  *    caption:	  label string  *    type:	  type of variable (ENTSCALE_INT or ENTSCALE_DOUBLE)  *    variable:	  pointer to variable  *    min, max:	  boundary of scale  *    step:	  step of scale (ignored when (type == ENTSCALE_INT))  *    constraint: (bool) true iff the value of *variable should be  *		  constraint by min and max  *    callback:	  called when the value is actually changed  *		  (*variable is automatically changed, so there's no  *		  need of callback func usually.)  *    call_data:  data for callback func  */
end_comment

begin_function
name|Entscale
modifier|*
DECL|function|entscale_new (GtkWidget * table,gint x,gint y,gchar * caption,EntscaleType type,gpointer variable,gdouble min,gdouble max,gdouble step,gint constraint,EntscaleCallbackFunc callback,gpointer call_data)
name|entscale_new
parameter_list|(
name|GtkWidget
modifier|*
name|table
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gchar
modifier|*
name|caption
parameter_list|,
name|EntscaleType
name|type
parameter_list|,
name|gpointer
name|variable
parameter_list|,
name|gdouble
name|min
parameter_list|,
name|gdouble
name|max
parameter_list|,
name|gdouble
name|step
parameter_list|,
name|gint
name|constraint
parameter_list|,
name|EntscaleCallbackFunc
name|callback
parameter_list|,
name|gpointer
name|call_data
parameter_list|)
block|{
name|Entscale
modifier|*
name|entscale
decl_stmt|;
name|GtkWidget
modifier|*
name|entry
decl_stmt|;
name|GtkWidget
modifier|*
name|scale
decl_stmt|;
name|GtkObject
modifier|*
name|adjustment
decl_stmt|;
name|gchar
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|gdouble
name|val
decl_stmt|;
name|gdouble
name|constraint_val
decl_stmt|;
name|entscale
operator|=
name|g_new0
argument_list|(
name|Entscale
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|entscale
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|entscale
operator|->
name|constraint
operator|=
name|constraint
expr_stmt|;
name|entscale
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|entscale
operator|->
name|call_data
operator|=
name|call_data
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ENTSCALE_INT
case|:
name|step
operator|=
literal|1.0
expr_stmt|;
name|strcpy
argument_list|(
name|entscale
operator|->
name|fmt_string
argument_list|,
literal|"%.0f"
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
operator|(
name|gint
operator|*
operator|)
name|variable
expr_stmt|;
break|break;
case|case
name|ENTSCALE_DOUBLE
case|:
name|sprintf
argument_list|(
name|entscale
operator|->
name|fmt_string
argument_list|,
literal|"%%.%df"
argument_list|,
name|entscale_get_precision
argument_list|(
name|step
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
operator|(
name|gdouble
operator|*
operator|)
name|variable
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"TYPE must be either ENTSCALE_INT or ENTSCALE_DOUBLE"
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|entscale
operator|->
name|label
operator|=
name|gtk_label_new
argument_list|(
name|caption
argument_list|)
expr_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|entscale
operator|->
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
comment|/*     If the first arg of gtk_adjustment_new() isn't between min and     max, it is automatically corrected by gtk later with     "value_changed" signal. I don't like this, since I want to leave     *variable untouched when `constraint' is false.     The lines below might look oppositely, but this is OK.    */
if|if
condition|(
name|constraint
condition|)
name|constraint_val
operator|=
name|val
expr_stmt|;
else|else
name|constraint_val
operator|=
name|BOUNDS
argument_list|(
name|val
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|adjustment
operator|=
name|entscale
operator|->
name|adjustment
operator|=
name|gtk_adjustment_new
argument_list|(
name|constraint_val
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|step
argument_list|,
name|step
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|adjustment
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|scale
argument_list|,
name|ENTSCALE_SCALE_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_draw_value
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entscale
operator|->
name|entry
operator|=
name|gtk_entry_new
argument_list|()
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|entry
argument_list|,
name|ENTSCALE_ENTRY_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|entscale
operator|->
name|fmt_string
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|gtk_entry_set_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* entscale is done */
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|,
name|entscale
argument_list|)
expr_stmt|;
name|gtk_object_set_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entscale
argument_list|)
expr_stmt|;
comment|/* now ready for signals */
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|"changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|entscale_entry_update
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|entscale_scale_update
argument_list|,
name|variable
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|entscale_destroy_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* start packing */
name|entscale
operator|->
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|entscale
operator|->
name|hbox
argument_list|)
argument_list|,
name|scale
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|entscale
operator|->
name|hbox
argument_list|)
argument_list|,
name|entry
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|entscale
operator|->
name|label
argument_list|,
name|x
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|entscale
operator|->
name|hbox
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|x
operator|+
literal|2
argument_list|,
name|y
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|entscale
operator|->
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|entscale
operator|->
name|hbox
argument_list|)
expr_stmt|;
return|return
name|entscale
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|entscale_get_precision (gdouble step)
name|entscale_get_precision
parameter_list|(
name|gdouble
name|step
parameter_list|)
block|{
name|int
name|precision
decl_stmt|;
if|if
condition|(
name|step
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|precision
operator|=
literal|0
init|;
name|pow
argument_list|(
literal|0.1
argument_list|,
name|precision
argument_list|)
operator|>
name|step
condition|;
name|precision
operator|++
control|)
empty_stmt|;
return|return
name|precision
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|entscale_destroy_callback (GtkWidget * widget,gpointer data)
name|entscale_destroy_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|Entscale
modifier|*
name|entscale
decl_stmt|;
name|entscale
operator|=
name|gtk_object_get_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|entscale
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|entscale_scale_update (GtkAdjustment * adjustment,gpointer data)
name|entscale_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|Entscale
modifier|*
name|entscale
decl_stmt|;
name|GtkEntry
modifier|*
name|entry
decl_stmt|;
name|gchar
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|gdouble
name|old_val
decl_stmt|,
name|new_val
decl_stmt|;
name|entscale
operator|=
name|gtk_object_get_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|)
expr_stmt|;
name|new_val
operator|=
name|adjustment
operator|->
name|value
expr_stmt|;
comment|/* adjustmet->value is always constrainted */
switch|switch
condition|(
name|entscale
operator|->
name|type
condition|)
block|{
case|case
name|ENTSCALE_INT
case|:
name|old_val
operator|=
operator|*
operator|(
name|gint
operator|*
operator|)
name|data
expr_stmt|;
operator|*
operator|(
name|gint
operator|*
operator|)
name|data
operator|=
operator|(
name|gint
operator|)
name|new_val
expr_stmt|;
name|DEBUG_PRINT
argument_list|(
operator|(
literal|"entscale_scale_update(int): fmt=\"%s\" old=%g new=%g\n"
operator|,
name|entscale
operator|->
name|fmt_string
operator|,
name|old_val
operator|,
name|new_val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENTSCALE_DOUBLE
case|:
name|old_val
operator|=
operator|*
operator|(
name|gdouble
operator|*
operator|)
name|data
expr_stmt|;
operator|*
operator|(
name|gdouble
operator|*
operator|)
name|data
operator|=
name|new_val
expr_stmt|;
name|DEBUG_PRINT
argument_list|(
operator|(
literal|"entscale_scale_update(double): fmt=\"%s\" old=%g new=%g\n"
operator|,
name|entscale
operator|->
name|fmt_string
operator|,
name|old_val
operator|,
name|new_val
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_warning
argument_list|(
literal|"entscale_scale_update: invalid type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|GTK_ENTRY
argument_list|(
name|entscale
operator|->
name|entry
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|entscale
operator|->
name|fmt_string
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
comment|/* avoid infinite loop (scale, entry, scale, entry ...) */
name|gtk_signal_handler_block_by_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|entry
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gtk_entry_set_text
argument_list|(
name|entry
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|gtk_signal_handler_unblock_by_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|entry
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|entscale
operator|->
name|callback
operator|&&
operator|(
name|old_val
operator|!=
name|new_val
operator|)
condition|)
call|(
modifier|*
name|entscale
operator|->
name|callback
call|)
argument_list|(
name|new_val
argument_list|,
name|entscale
operator|->
name|call_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|entscale_entry_update (GtkWidget * widget,gpointer data)
name|entscale_entry_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|Entscale
modifier|*
name|entscale
decl_stmt|;
name|GtkAdjustment
modifier|*
name|adjustment
decl_stmt|;
name|gdouble
name|old_val
decl_stmt|,
name|val
decl_stmt|,
name|new_val
decl_stmt|,
name|constraint_val
decl_stmt|;
name|entscale
operator|=
name|gtk_object_get_user_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|adjustment
operator|=
name|GTK_ADJUSTMENT
argument_list|(
name|entscale
operator|->
name|adjustment
argument_list|)
expr_stmt|;
name|val
operator|=
name|atof
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|widget
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|constraint_val
operator|=
name|BOUNDS
argument_list|(
name|val
argument_list|,
name|adjustment
operator|->
name|lower
argument_list|,
name|adjustment
operator|->
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
name|entscale
operator|->
name|constraint
condition|)
name|new_val
operator|=
name|constraint_val
expr_stmt|;
else|else
name|new_val
operator|=
name|val
expr_stmt|;
switch|switch
condition|(
name|entscale
operator|->
name|type
condition|)
block|{
case|case
name|ENTSCALE_INT
case|:
name|old_val
operator|=
operator|*
operator|(
name|gint
operator|*
operator|)
name|data
expr_stmt|;
operator|*
operator|(
name|gint
operator|*
operator|)
name|data
operator|=
operator|(
name|gint
operator|)
name|new_val
expr_stmt|;
name|DEBUG_PRINT
argument_list|(
operator|(
literal|"entscale_entry_update(int): old=%g new=%g const=%g\n"
operator|,
name|old_val
operator|,
name|new_val
operator|,
name|constraint_val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENTSCALE_DOUBLE
case|:
name|old_val
operator|=
operator|*
operator|(
name|gdouble
operator|*
operator|)
name|data
expr_stmt|;
operator|*
operator|(
name|gdouble
operator|*
operator|)
name|data
operator|=
name|new_val
expr_stmt|;
name|DEBUG_PRINT
argument_list|(
operator|(
literal|"entscale_entry_update(double): old=%g new=%g const=%g\n"
operator|,
name|old_val
operator|,
name|new_val
operator|,
name|constraint_val
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_warning
argument_list|(
literal|"entscale_entry_update: invalid type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|adjustment
operator|->
name|value
operator|=
name|constraint_val
expr_stmt|;
comment|/* avoid infinite loop (scale, entry, scale, entry ...) */
name|gtk_signal_handler_block_by_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gtk_signal_emit_by_name
argument_list|(
name|GTK_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|)
expr_stmt|;
name|gtk_signal_handler_unblock_by_data
argument_list|(
name|GTK_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|entscale
operator|->
name|callback
operator|&&
operator|(
name|old_val
operator|!=
name|new_val
operator|)
condition|)
call|(
modifier|*
name|entscale
operator|->
name|callback
call|)
argument_list|(
name|new_val
argument_list|,
name|entscale
operator|->
name|call_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|entscale_set_sensitive (Entscale * ent,gint sensitive)
specifier|static
name|void
name|entscale_set_sensitive
parameter_list|(
name|Entscale
modifier|*
name|ent
parameter_list|,
name|gint
name|sensitive
parameter_list|)
block|{
name|gtk_widget_set_sensitive
argument_list|(
name|GTK_WIDGET
argument_list|(
name|ent
operator|->
name|label
argument_list|)
argument_list|,
name|sensitive
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|GTK_WIDGET
argument_list|(
name|ent
operator|->
name|hbox
argument_list|)
argument_list|,
name|sensitive
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|entscale_set_value (Entscale * ent,gfloat value)
specifier|static
name|void
name|entscale_set_value
parameter_list|(
name|Entscale
modifier|*
name|ent
parameter_list|,
name|gfloat
name|value
parameter_list|)
block|{
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|ent
operator|->
name|adjustment
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

