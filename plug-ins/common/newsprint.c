begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * newsprint plug-in  * Copyright (C) 1997-1998 Austin Donnelly<austin@gimp.org>  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/*  * version 0.60  *  * This plug-in puts an image through a screen at a particular angle  * and lines per inch, to arrive at a newspaper-style effect.  *  * Austin Donnelly<austin@greenend.org.uk>  * http://www.cl.cam.ac.uk/~and1000/newsprint/  *  * Richard Mortier<rmm1002@cam.ac.uk> did the spot_round() function  * with correct tonal balance.  *  * Tim Harris<tim.harris@acm.org> provided valuable feedback on  * pre-press issues.  *  *  * 0.52: 10 Jan 1999<austin@greenend.org.uk>  *    gtk_label_set() -> gtk_label_set_text()  * 0.60: 18 Jun 2001<austin@gimp.org>  *    fixed long-standing bug where newsprint() function in GREYA images  *    treated them as RGB (bpp rather than colour_bpp) to select  *    colourspace to use.  Thanks to warner-gnome.bugzilla@lothar.com for  *    spotting this and providing the patch.  Bug #52981.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|VERSION
define|#
directive|define
name|VERSION
value|"v0.60"
end_define

begin_comment
comment|/* Some useful macros */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
DECL|macro|DEBUG_PRINT (x)
define|#
directive|define
name|DEBUG_PRINT
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|DEBUG_PRINT (x)
define|#
directive|define
name|DEBUG_PRINT
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#define TIMINGS*/
end_comment

begin_define
DECL|macro|PLUG_IN_PROC
define|#
directive|define
name|PLUG_IN_PROC
value|"plug-in-newsprint"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"newsprint"
end_define

begin_define
DECL|macro|TILE_CACHE_SIZE
define|#
directive|define
name|TILE_CACHE_SIZE
value|16
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|DEF_OVERSAMPLE
define|#
directive|define
name|DEF_OVERSAMPLE
value|1
end_define

begin_comment
DECL|macro|DEF_OVERSAMPLE
comment|/* default for how much to oversample by */
end_comment

begin_define
DECL|macro|SPOT_PREVIEW_SZ
define|#
directive|define
name|SPOT_PREVIEW_SZ
value|16
end_define

begin_define
DECL|macro|PREVIEW_SIZE
define|#
directive|define
name|PREVIEW_SIZE
value|(2 * SPOT_PREVIEW_SZ + 1)
end_define

begin_define
DECL|macro|PREVIEW_OVERSAMPLE
define|#
directive|define
name|PREVIEW_OVERSAMPLE
value|3
end_define

begin_define
DECL|macro|ISNEG (x)
define|#
directive|define
name|ISNEG
parameter_list|(
name|x
parameter_list|)
value|(((x)< 0)? 1 : 0)
end_define

begin_define
DECL|macro|DEG2RAD (d)
define|#
directive|define
name|DEG2RAD
parameter_list|(
name|d
parameter_list|)
value|((d) * G_PI / 180)
end_define

begin_define
DECL|macro|CLAMPED_ADD (a,b)
define|#
directive|define
name|CLAMPED_ADD
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)+(b)> 0xff)? 0xff : (a) + (b))
end_define

begin_comment
comment|/* Bartlett window supersampling weight function.  See table 4.1, page  * 123 of Alan Watt and Mark Watt, Advanced Animation and Rendering  * Techniques, theory and practice. Addison-Wesley, 1992. ISBN  * 0-201-54412-1 */
end_comment

begin_define
DECL|macro|BARTLETT (x,y)
define|#
directive|define
name|BARTLETT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((oversample/2)+1-ABS(x)) * ((oversample/2)+1-ABS(y)))
end_define

begin_define
DECL|macro|WGT (x,y)
define|#
directive|define
name|WGT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|wgt[((y+oversample/2)*oversample) + x+oversample/2]
end_define

begin_comment
comment|/* colourspaces we can separate to: */
end_comment

begin_define
DECL|macro|CS_GREY
define|#
directive|define
name|CS_GREY
value|0
end_define

begin_define
DECL|macro|CS_RGB
define|#
directive|define
name|CS_RGB
value|1
end_define

begin_define
DECL|macro|CS_CMYK
define|#
directive|define
name|CS_CMYK
value|2
end_define

begin_define
DECL|macro|CS_LUMINANCE
define|#
directive|define
name|CS_LUMINANCE
value|3
end_define

begin_define
DECL|macro|NUM_CS
define|#
directive|define
name|NUM_CS
value|4
end_define

begin_define
DECL|macro|VALID_CS (x)
define|#
directive|define
name|VALID_CS
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)<= NUM_CS-1)
end_define

begin_comment
comment|/* Spot function related types and definitions */
end_comment

begin_typedef
DECL|typedef|y
typedef|typedef
name|gdouble
name|spotfn_t
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* forward declaration of the functions themselves */
end_comment

begin_decl_stmt
DECL|variable|spot_round
specifier|static
name|spotfn_t
name|spot_round
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_line
specifier|static
name|spotfn_t
name|spot_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_diamond
specifier|static
name|spotfn_t
name|spot_diamond
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_PSsquare
specifier|static
name|spotfn_t
name|spot_PSsquare
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|spot_PSdiamond
specifier|static
name|spotfn_t
name|spot_PSdiamond
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970108
block|{
DECL|member|name
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
comment|/* function's name */
DECL|member|fn
name|spotfn_t
modifier|*
name|fn
decl_stmt|;
comment|/* function itself */
DECL|member|thresh
name|guchar
modifier|*
name|thresh
decl_stmt|;
comment|/* cached threshold matrix */
DECL|member|prev_lvl
name|gdouble
name|prev_lvl
index|[
literal|3
index|]
decl_stmt|;
comment|/* intensities to preview */
DECL|member|prev_thresh
name|guchar
modifier|*
name|prev_thresh
decl_stmt|;
comment|/* preview-sized threshold matrix */
DECL|member|balanced
name|gint
name|balanced
decl_stmt|;
comment|/* TRUE if spot fn is already balanced */
DECL|typedef|spot_info_t
block|}
name|spot_info_t
typedef|;
end_typedef

begin_comment
comment|/* This is all the info needed per spot function.  Functions are refered to  * by their index into this array. */
end_comment

begin_decl_stmt
DECL|variable|spotfn_list
specifier|static
name|spot_info_t
name|spotfn_list
index|[]
init|=
block|{
DECL|macro|SPOTFN_DOT
define|#
directive|define
name|SPOTFN_DOT
value|0
block|{
name|N_
argument_list|(
literal|"Round"
argument_list|)
block|,
name|spot_round
block|,
name|NULL
block|,
block|{
literal|.22
block|,
literal|.50
block|,
literal|.90
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
block|{
name|N_
argument_list|(
literal|"Line"
argument_list|)
block|,
name|spot_line
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.80
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
block|{
name|N_
argument_list|(
literal|"Diamond"
argument_list|)
block|,
name|spot_diamond
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.80
block|}
block|,
name|NULL
block|,
name|TRUE
block|}
block|,
block|{
name|N_
argument_list|(
literal|"PS Square (Euclidean Dot)"
argument_list|)
block|,
name|spot_PSsquare
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.90
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
block|{
name|N_
argument_list|(
literal|"PS Diamond"
argument_list|)
block|,
name|spot_PSdiamond
block|,
name|NULL
block|,
block|{
literal|.15
block|,
literal|.50
block|,
literal|.90
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|,
comment|/* NULL-name terminates */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
name|NULL
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|NUM_SPOTFN
define|#
directive|define
name|NUM_SPOTFN
value|(G_N_ELEMENTS (spotfn_list))
end_define

begin_define
DECL|macro|VALID_SPOTFN (x)
define|#
directive|define
name|VALID_SPOTFN
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)< NUM_SPOTFN)
end_define

begin_define
DECL|macro|THRESH (x,y)
define|#
directive|define
name|THRESH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(thresh[(y)*width + (x)])
end_define

begin_define
DECL|macro|THRESHn (n,x,y)
define|#
directive|define
name|THRESHn
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|((thresh[n])[(y)*width + (x)])
end_define

begin_comment
comment|/* Arguments to filter */
end_comment

begin_comment
comment|/* Some of these are here merely to save them across calls.  They are  * marked as "UI use".  Everything else is a valid arg. */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970208
block|{
comment|/* resolution section: */
DECL|member|cell_width
name|gint
name|cell_width
decl_stmt|;
comment|/* screening section: */
DECL|member|colourspace
name|gint
name|colourspace
decl_stmt|;
comment|/* 0: RGB, 1: CMYK, 2: Luminance */
DECL|member|k_pullout
name|gint
name|k_pullout
decl_stmt|;
comment|/* percentage of black to pull out */
comment|/* grey screen (only used if greyscale drawable) */
DECL|member|gry_ang
name|gdouble
name|gry_ang
decl_stmt|;
DECL|member|gry_spotfn
name|gint
name|gry_spotfn
decl_stmt|;
comment|/* red / cyan screen */
DECL|member|red_ang
name|gdouble
name|red_ang
decl_stmt|;
DECL|member|red_spotfn
name|gint
name|red_spotfn
decl_stmt|;
comment|/* green / magenta screen */
DECL|member|grn_ang
name|gdouble
name|grn_ang
decl_stmt|;
DECL|member|grn_spotfn
name|gint
name|grn_spotfn
decl_stmt|;
comment|/* blue / yellow screen */
DECL|member|blu_ang
name|gdouble
name|blu_ang
decl_stmt|;
DECL|member|blu_spotfn
name|gint
name|blu_spotfn
decl_stmt|;
comment|/* anti-alias section */
DECL|member|oversample
name|gint
name|oversample
decl_stmt|;
comment|/* 1 == no anti-aliasing, else small odd int */
DECL|typedef|NewsprintValues
block|}
name|NewsprintValues
typedef|;
end_typedef

begin_comment
comment|/* bits of state used by the UI, but not visible from the PDB */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970308
block|{
DECL|member|input_spi
name|gdouble
name|input_spi
decl_stmt|;
comment|/* input samples per inch */
DECL|member|output_lpi
name|gdouble
name|output_lpi
decl_stmt|;
comment|/* desired output lines per inch */
DECL|member|lock_channels
name|gboolean
name|lock_channels
decl_stmt|;
comment|/* changes to one channel affect all */
DECL|typedef|NewsprintUIValues
block|}
name|NewsprintUIValues
typedef|;
end_typedef

begin_comment
comment|/* state for the preview widgets */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970408
block|{
DECL|member|widget
name|GtkWidget
modifier|*
name|widget
decl_stmt|;
comment|/* preview widget itself */
DECL|member|label
name|GtkWidget
modifier|*
name|label
decl_stmt|;
comment|/* the label below it */
DECL|typedef|preview_st
block|}
name|preview_st
typedef|;
end_typedef

begin_comment
comment|/* state for the channel notebook pages */
end_comment

begin_typedef
DECL|typedef|channel_st
typedef|typedef
name|struct
name|_channel_st
name|channel_st
typedef|;
end_typedef

begin_struct
DECL|struct|_channel_st
struct|struct
name|_channel_st
block|{
DECL|member|vbox
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
comment|/* vbox of this channel */
DECL|member|spotfn_num
name|gint
modifier|*
name|spotfn_num
decl_stmt|;
comment|/* which spotfn the menu is controlling */
DECL|member|prev
name|preview_st
name|prev
index|[
literal|3
index|]
decl_stmt|;
comment|/* state for 3 preview widgets */
DECL|member|angle_adj
name|GtkObject
modifier|*
name|angle_adj
decl_stmt|;
comment|/* angle adjustment */
DECL|member|combo
name|GtkWidget
modifier|*
name|combo
decl_stmt|;
comment|/* popup for spot function */
DECL|member|menuitem
name|GtkWidget
modifier|*
name|menuitem
index|[
name|NUM_SPOTFN
index|]
decl_stmt|;
comment|/* menuitems for each spot function */
DECL|member|ch_menuitem
name|GtkWidget
modifier|*
name|ch_menuitem
decl_stmt|;
comment|/* menuitem for the channel selector */
DECL|member|ch_menu_num
name|gint
name|ch_menu_num
decl_stmt|;
comment|/* this channel's position in the selector */
DECL|member|next
name|channel_st
modifier|*
name|next
decl_stmt|;
comment|/* circular list of channels in locked group */
block|}
struct|;
end_struct

begin_comment
comment|/* State associated with the configuration dialog and passed to its  * callback functions */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970508
block|{
DECL|member|pull_table
name|GtkWidget
modifier|*
name|pull_table
decl_stmt|;
DECL|member|pull
name|GtkObject
modifier|*
name|pull
decl_stmt|;
comment|/* black pullout percentage */
DECL|member|input_spi
name|GtkObject
modifier|*
name|input_spi
decl_stmt|;
DECL|member|output_lpi
name|GtkObject
modifier|*
name|output_lpi
decl_stmt|;
DECL|member|cellsize
name|GtkObject
modifier|*
name|cellsize
decl_stmt|;
DECL|member|vbox
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
comment|/* container for screen info */
comment|/* Notebook for the channels (one per colorspace) */
DECL|member|channel_notebook
name|GtkWidget
modifier|*
name|channel_notebook
index|[
name|NUM_CS
index|]
decl_stmt|;
comment|/* room for up to 4 channels per colourspace */
DECL|member|chst
name|channel_st
modifier|*
name|chst
index|[
name|NUM_CS
index|]
index|[
literal|4
index|]
decl_stmt|;
DECL|typedef|NewsprintDialog_st
block|}
name|NewsprintDialog_st
typedef|;
end_typedef

begin_comment
comment|/***** Local vars *****/
end_comment

begin_comment
comment|/* defaults */
end_comment

begin_comment
comment|/* fixed copy so we can reset them */
end_comment

begin_decl_stmt
DECL|variable|factory_defaults
specifier|static
specifier|const
name|NewsprintValues
name|factory_defaults
init|=
block|{
comment|/* resolution stuff */
literal|10
block|,
comment|/* cell width */
comment|/* screen setup (default is the classic rosette pattern) */
name|CS_RGB
block|,
comment|/* use RGB, not CMYK or Luminance */
literal|100
block|,
comment|/* max pullout */
comment|/* grey/black */
literal|45.0
block|,
name|SPOTFN_DOT
block|,
comment|/* red/cyan */
literal|15.0
block|,
name|SPOTFN_DOT
block|,
comment|/* green/magenta */
literal|75.0
block|,
name|SPOTFN_DOT
block|,
comment|/* blue/yellow */
literal|0.0
block|,
name|SPOTFN_DOT
block|,
comment|/* anti-alias control */
name|DEF_OVERSAMPLE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|factory_defaults_ui
specifier|static
specifier|const
name|NewsprintUIValues
name|factory_defaults_ui
init|=
block|{
literal|72
block|,
comment|/* input spi     */
literal|7.2
block|,
comment|/* output lpi    */
name|FALSE
comment|/* lock channels */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mutable copy for normal use.  Initialised in run(). */
end_comment

begin_decl_stmt
DECL|variable|pvals
specifier|static
name|NewsprintValues
name|pvals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pvals_ui
specifier|static
name|NewsprintUIValues
name|pvals_ui
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* channel templates */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970608
block|{
DECL|member|name
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
comment|/* pointers to the variables this channel updates */
DECL|member|angle
name|gdouble
modifier|*
name|angle
decl_stmt|;
DECL|member|spotfn
name|gint
modifier|*
name|spotfn
decl_stmt|;
comment|/* factory defaults for the angle and spot function (as pointers so    * the silly compiler can see they're really constants) */
DECL|member|factory_angle
specifier|const
name|gdouble
modifier|*
name|factory_angle
decl_stmt|;
DECL|member|factory_spotfn
specifier|const
name|gint
modifier|*
name|factory_spotfn
decl_stmt|;
DECL|typedef|chan_tmpl
block|}
name|chan_tmpl
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|grey_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|grey_tmpl
index|[]
init|=
block|{
block|{
name|N_
argument_list|(
literal|"_Grey"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|gry_ang
block|,
operator|&
name|pvals
operator|.
name|gry_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|gry_ang
block|,
operator|&
name|factory_defaults
operator|.
name|gry_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rgb_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|rgb_tmpl
index|[]
init|=
block|{
block|{
name|N_
argument_list|(
literal|"R_ed"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|red_ang
block|,
operator|&
name|pvals
operator|.
name|red_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|red_ang
block|,
operator|&
name|factory_defaults
operator|.
name|red_spotfn
block|}
block|,
block|{
name|N_
argument_list|(
literal|"_Green"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|grn_ang
block|,
operator|&
name|pvals
operator|.
name|grn_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|grn_ang
block|,
operator|&
name|factory_defaults
operator|.
name|grn_spotfn
block|}
block|,
block|{
name|N_
argument_list|(
literal|"_Blue"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|blu_ang
block|,
operator|&
name|pvals
operator|.
name|blu_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|blu_ang
block|,
operator|&
name|factory_defaults
operator|.
name|blu_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cmyk_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|cmyk_tmpl
index|[]
init|=
block|{
block|{
name|N_
argument_list|(
literal|"C_yan"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|red_ang
block|,
operator|&
name|pvals
operator|.
name|red_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|red_ang
block|,
operator|&
name|factory_defaults
operator|.
name|red_spotfn
block|}
block|,
block|{
name|N_
argument_list|(
literal|"Magen_ta"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|grn_ang
block|,
operator|&
name|pvals
operator|.
name|grn_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|grn_ang
block|,
operator|&
name|factory_defaults
operator|.
name|grn_spotfn
block|}
block|,
block|{
name|N_
argument_list|(
literal|"_Yellow"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|blu_ang
block|,
operator|&
name|pvals
operator|.
name|blu_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|blu_ang
block|,
operator|&
name|factory_defaults
operator|.
name|blu_spotfn
block|}
block|,
block|{
name|N_
argument_list|(
literal|"_Black"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|gry_ang
block|,
operator|&
name|pvals
operator|.
name|gry_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|gry_ang
block|,
operator|&
name|factory_defaults
operator|.
name|gry_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|luminance_tmpl
specifier|static
specifier|const
name|chan_tmpl
name|luminance_tmpl
index|[]
init|=
block|{
block|{
name|N_
argument_list|(
literal|"Luminance"
argument_list|)
block|,
operator|&
name|pvals
operator|.
name|gry_ang
block|,
operator|&
name|pvals
operator|.
name|gry_spotfn
block|,
operator|&
name|factory_defaults
operator|.
name|gry_ang
block|,
operator|&
name|factory_defaults
operator|.
name|gry_spotfn
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cspace_chan_tmpl is indexed by colourspace, and gives an array of  * channel templates for that colourspace */
end_comment

begin_decl_stmt
DECL|variable|cspace_chan_tmpl
specifier|static
specifier|const
name|chan_tmpl
modifier|*
name|cspace_chan_tmpl
index|[]
init|=
block|{
name|grey_tmpl
block|,
name|rgb_tmpl
block|,
name|cmyk_tmpl
block|,
name|luminance_tmpl
block|}
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|NCHANS (x)
define|#
directive|define
name|NCHANS
parameter_list|(
name|x
parameter_list|)
value|((sizeof(x) / sizeof(chan_tmpl)) - 1)
end_define

begin_comment
comment|/* cspace_nchans gives a quick way of finding the number of channels  * in a colourspace.  Alternatively, if you're walking the channel  * template, you can use the NULL entry at the end to stop. */
end_comment

begin_decl_stmt
DECL|variable|cspace_nchans
specifier|static
specifier|const
name|gint
name|cspace_nchans
index|[]
init|=
block|{
name|NCHANS
argument_list|(
name|grey_tmpl
argument_list|)
block|,
name|NCHANS
argument_list|(
name|rgb_tmpl
argument_list|)
block|,
name|NCHANS
argument_list|(
name|cmyk_tmpl
argument_list|)
block|,
name|NCHANS
argument_list|(
argument|luminance_tmpl
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|newsprint_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_cspace_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_menu_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|angle_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpi_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spi_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cellsize_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint_defaults_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newsprint
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|spot2thresh
parameter_list|(
name|gint
name|type
parameter_list|,
name|gint
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|preview_update
parameter_list|(
name|channel_st
modifier|*
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***** Functions *****/
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image (unused)"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Input drawable"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"cell-width"
block|,
literal|"Screen cell width in pixels"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"colorspace"
block|,
literal|"Separate to { GRAYSCALE (0), RGB (1), CMYK (2), LUMINANCE (3) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"k-pullout"
block|,
literal|"Percentage of black to pullout (CMYK only)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"gry-ang"
block|,
literal|"Grey/black screen angle (degrees)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"gry-spotfn"
block|,
literal|"Grey/black spot function { DOTS (0), LINES (1), DIAMONDS (2), EUCLIDIAN-DOT (3), PS-DIAMONDS (4) }"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"red-ang"
block|,
literal|"Red/cyan screen angle (degrees)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"red-spotfn"
block|,
literal|"Red/cyan spot function (values as gry-spotfn)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"grn-ang"
block|,
literal|"Green/magenta screen angle (degrees)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"grn-spotfn"
block|,
literal|"Green/magenta spot function (values as gry-spotfn)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"blu-ang"
block|,
literal|"Blue/yellow screen angle (degrees)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"blu-spotfn"
block|,
literal|"Blue/yellow spot function (values as gry-spotfn)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"oversample"
block|,
literal|"how many times to oversample spot fn"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|PLUG_IN_PROC
argument_list|,
name|N_
argument_list|(
literal|"Halftone the image to give newspaper-like effect"
argument_list|)
argument_list|,
literal|"Halftone the image, trading off resolution to "
literal|"represent colors or grey levels using the process "
literal|"described both in the PostScript language "
literal|"definition, and also by Robert Ulichney, \"Digital "
literal|"halftoning\", MIT Press, 1987."
argument_list|,
literal|"Austin Donnelly"
argument_list|,
literal|"Austin Donnelly"
argument_list|,
literal|"1998 ("
name|VERSION
literal|")"
argument_list|,
name|N_
argument_list|(
literal|"Newsprin_t..."
argument_list|)
argument_list|,
literal|"RGB*, GRAY*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_plugin_menu_register
argument_list|(
name|PLUG_IN_PROC
argument_list|,
literal|"<Image>/Filters/Distorts"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
comment|/* basic defaults */
name|pvals
operator|=
name|factory_defaults
expr_stmt|;
name|pvals_ui
operator|=
name|factory_defaults_ui
expr_stmt|;
comment|/*  Get the specified drawable  */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|pvals
argument_list|)
expr_stmt|;
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
literal|"-ui"
argument_list|,
operator|&
name|pvals_ui
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|newsprint_dialog
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|15
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
break|break;
block|}
name|pvals
operator|.
name|cell_width
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|colourspace
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|k_pullout
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|gry_ang
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|gry_spotfn
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|red_ang
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|red_spotfn
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|grn_ang
operator|=
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|grn_spotfn
operator|=
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|blu_ang
operator|=
name|param
index|[
literal|12
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|pvals
operator|.
name|blu_spotfn
operator|=
name|param
index|[
literal|13
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pvals
operator|.
name|oversample
operator|=
name|param
index|[
literal|14
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/* check values are within permitted ranges */
if|if
condition|(
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|gry_spotfn
argument_list|)
operator|||
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|red_spotfn
argument_list|)
operator|||
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|grn_spotfn
argument_list|)
operator|||
operator|!
name|VALID_SPOTFN
argument_list|(
name|pvals
operator|.
name|blu_spotfn
argument_list|)
operator|||
operator|!
name|VALID_CS
argument_list|(
name|pvals
operator|.
name|colourspace
argument_list|)
operator|||
name|pvals
operator|.
name|k_pullout
operator|<
literal|0
operator|||
name|pvals
operator|.
name|k_pullout
operator|>
literal|100
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|pvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
comment|/*  Make sure that the drawable is gray or RGB color  */
if|if
condition|(
name|gimp_drawable_is_rgb
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
operator|||
name|gimp_drawable_is_gray
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Newsprint"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  set the tile cache size  */
name|gimp_tile_cache_ntiles
argument_list|(
name|TILE_CACHE_SIZE
argument_list|)
expr_stmt|;
comment|/*  run the newsprint effect  */
name|newsprint
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|!=
name|GIMP_RUN_NONINTERACTIVE
condition|)
name|gimp_displays_flush
argument_list|()
expr_stmt|;
comment|/*  Store data  */
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|pvals
argument_list|,
sizeof|sizeof
argument_list|(
name|NewsprintValues
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
literal|"-ui"
argument_list|,
operator|&
name|pvals_ui
argument_list|,
sizeof|sizeof
argument_list|(
name|NewsprintUIValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*gimp_message ("newsprint: cannot operate on indexed images");*/
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* create new menu state, and the preview widgets for it */
end_comment

begin_function
specifier|static
name|channel_st
modifier|*
DECL|function|new_preview (gint * sfn)
name|new_preview
parameter_list|(
name|gint
modifier|*
name|sfn
parameter_list|)
block|{
name|channel_st
modifier|*
name|st
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|st
operator|=
name|g_new
argument_list|(
name|channel_st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
operator|->
name|spotfn_num
operator|=
name|sfn
expr_stmt|;
comment|/* make the preview widgets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|preview
operator|=
name|gimp_preview_area_new
argument_list|()
expr_stmt|;
name|gtk_widget_set_size_request
argument_list|(
name|preview
argument_list|,
name|PREVIEW_SIZE
argument_list|,
name|PREVIEW_SIZE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|preview
argument_list|,
literal|"size-allocate"
argument_list|,
name|G_CALLBACK
argument_list|(
name|preview_update
argument_list|)
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|st
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|widget
operator|=
name|preview
expr_stmt|;
name|st
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|label
operator|=
name|label
expr_stmt|;
comment|/* st->prev[i].value changed by preview_update */
block|}
return|return
name|st
return|;
block|}
end_function

begin_comment
comment|/* the popup menu "st" has changed, so the previews associated with it  * need re-calculation */
end_comment

begin_function
specifier|static
name|void
DECL|function|preview_update (channel_st * st)
name|preview_update
parameter_list|(
name|channel_st
modifier|*
name|st
parameter_list|)
block|{
name|gint
name|sfn
init|=
operator|*
operator|(
name|st
operator|->
name|spotfn_num
operator|)
decl_stmt|;
name|preview_st
modifier|*
name|prev
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gint
name|y
decl_stmt|;
name|gint
name|width
init|=
name|SPOT_PREVIEW_SZ
operator|*
name|PREVIEW_OVERSAMPLE
decl_stmt|;
name|gint
name|oversample
init|=
name|PREVIEW_OVERSAMPLE
decl_stmt|;
name|guchar
modifier|*
name|thresh
decl_stmt|;
name|gchar
name|pct
index|[
literal|12
index|]
decl_stmt|;
name|guchar
name|value
decl_stmt|;
name|guchar
name|rgb
index|[
literal|3
operator|*
name|PREVIEW_SIZE
operator|*
name|PREVIEW_SIZE
index|]
decl_stmt|;
comment|/* If we don't yet have a preview threshold matrix for this spot    * function, generate one now. */
if|if
condition|(
operator|!
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_thresh
condition|)
block|{
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_thresh
operator|=
name|spot2thresh
argument_list|(
name|sfn
argument_list|,
name|SPOT_PREVIEW_SZ
operator|*
name|PREVIEW_OVERSAMPLE
argument_list|)
expr_stmt|;
block|}
name|thresh
operator|=
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_thresh
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|prev
operator|=
operator|&
name|st
operator|->
name|prev
index|[
name|i
index|]
expr_stmt|;
name|value
operator|=
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_lvl
index|[
name|i
index|]
operator|*
literal|0xff
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|PREVIEW_SIZE
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|PREVIEW_SIZE
condition|;
name|x
operator|++
control|)
block|{
name|guint32
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gint
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|gint
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|rx
operator|=
name|x
operator|*
name|PREVIEW_OVERSAMPLE
expr_stmt|;
name|ry
operator|=
name|y
operator|*
name|PREVIEW_OVERSAMPLE
expr_stmt|;
for|for
control|(
name|sy
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sy
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sy
operator|++
control|)
for|for
control|(
name|sx
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sx
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sx
operator|++
control|)
block|{
name|tx
operator|=
name|rx
operator|+
name|sx
expr_stmt|;
name|ty
operator|=
name|ry
operator|+
name|sy
expr_stmt|;
while|while
condition|(
name|tx
operator|<
literal|0
condition|)
name|tx
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|<
literal|0
condition|)
name|ty
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|tx
operator|>=
name|width
condition|)
name|tx
operator|-=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|>=
name|width
condition|)
name|ty
operator|-=
name|width
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|THRESH
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
condition|)
name|sum
operator|+=
literal|0xff
operator|*
name|BARTLETT
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
name|sum
operator|/=
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|*
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* blue lines on cell boundaries */
if|if
condition|(
operator|(
name|x
operator|%
name|SPOT_PREVIEW_SZ
operator|)
operator|==
literal|0
operator|||
operator|(
name|y
operator|%
name|SPOT_PREVIEW_SZ
operator|)
operator|==
literal|0
condition|)
block|{
name|rgb
index|[
operator|(
name|y
operator|*
name|PREVIEW_SIZE
operator|+
name|x
operator|)
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rgb
index|[
operator|(
name|y
operator|*
name|PREVIEW_SIZE
operator|+
name|x
operator|)
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rgb
index|[
operator|(
name|y
operator|*
name|PREVIEW_SIZE
operator|+
name|x
operator|)
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|rgb
index|[
operator|(
name|y
operator|*
name|PREVIEW_SIZE
operator|+
name|x
operator|)
operator|*
literal|3
operator|+
literal|0
index|]
operator|=
name|sum
expr_stmt|;
name|rgb
index|[
operator|(
name|y
operator|*
name|PREVIEW_SIZE
operator|+
name|x
operator|)
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|sum
expr_stmt|;
name|rgb
index|[
operator|(
name|y
operator|*
name|PREVIEW_SIZE
operator|+
name|x
operator|)
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
block|}
comment|/* redraw preview widget */
name|gimp_preview_area_draw
argument_list|(
name|GIMP_PREVIEW_AREA
argument_list|(
name|prev
operator|->
name|widget
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PREVIEW_SIZE
argument_list|,
name|PREVIEW_SIZE
argument_list|,
name|GIMP_RGB_IMAGE
argument_list|,
name|rgb
argument_list|,
name|PREVIEW_SIZE
operator|*
literal|3
argument_list|)
expr_stmt|;
name|g_snprintf
argument_list|(
name|pct
argument_list|,
sizeof|sizeof
argument_list|(
name|pct
argument_list|)
argument_list|,
literal|"%2d%%"
argument_list|,
operator|(
name|int
operator|)
name|RINT
argument_list|(
name|spotfn_list
index|[
name|sfn
index|]
operator|.
name|prev_lvl
index|[
name|i
index|]
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_label_set_text
argument_list|(
name|GTK_LABEL
argument_list|(
name|prev
operator|->
name|label
argument_list|)
argument_list|,
name|pct
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_menu_callback (GtkWidget * widget,gpointer data)
name|newsprint_menu_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|channel_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gint
name|value
decl_stmt|;
specifier|static
name|gboolean
name|in_progress
init|=
name|FALSE
decl_stmt|;
comment|/* We shouldn't need recursion protection, but if lock_channels is    * set, and gimp_int_combo_box_set_active ever generates a "changed"    * signal, then we'll get back here.    */
if|if
condition|(
name|in_progress
condition|)
block|{
name|printf
argument_list|(
literal|"newsprint_menu_callback: unexpected recursion: can't happen\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|in_progress
operator|=
name|TRUE
expr_stmt|;
name|gimp_int_combo_box_get_active
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|widget
argument_list|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
operator|*
operator|(
name|st
operator|->
name|spotfn_num
operator|)
operator|=
name|value
expr_stmt|;
name|preview_update
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* ripple the change to the other popups if the channels are    * locked together. */
if|if
condition|(
name|pvals_ui
operator|.
name|lock_channels
condition|)
block|{
name|channel_st
modifier|*
name|c
init|=
name|st
operator|->
name|next
decl_stmt|;
name|gint
name|old_value
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|st
condition|)
block|{
name|gimp_int_combo_box_set_active
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|c
operator|->
name|combo
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|old_value
operator|=
operator|*
operator|(
name|c
operator|->
name|spotfn_num
operator|)
expr_stmt|;
operator|*
operator|(
name|c
operator|->
name|spotfn_num
operator|)
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|old_value
operator|!=
name|value
condition|)
name|preview_update
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
name|in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|angle_callback (GtkAdjustment * adjustment,gpointer data)
name|angle_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|channel_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|channel_st
modifier|*
name|c
decl_stmt|;
name|gdouble
modifier|*
name|angle_ptr
decl_stmt|;
specifier|static
name|gint
name|in_progress
init|=
name|FALSE
decl_stmt|;
name|angle_ptr
operator|=
name|g_object_get_data
argument_list|(
name|G_OBJECT
argument_list|(
name|adjustment
argument_list|)
argument_list|,
literal|"angle"
argument_list|)
expr_stmt|;
name|gimp_double_adjustment_update
argument_list|(
name|adjustment
argument_list|,
name|angle_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvals_ui
operator|.
name|lock_channels
operator|&&
operator|!
name|in_progress
condition|)
block|{
name|in_progress
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
name|st
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|st
condition|)
block|{
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|c
operator|->
name|angle_adj
argument_list|)
argument_list|,
operator|*
name|angle_ptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
name|in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|lpi_callback (GtkAdjustment * adjustment,gpointer data)
name|lpi_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gimp_double_adjustment_update
argument_list|(
name|adjustment
argument_list|,
operator|&
name|pvals_ui
operator|.
name|output_lpi
argument_list|)
expr_stmt|;
name|g_signal_handlers_block_by_func
argument_list|(
name|st
operator|->
name|cellsize
argument_list|,
name|cellsize_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|st
operator|->
name|cellsize
argument_list|)
argument_list|,
name|pvals_ui
operator|.
name|input_spi
operator|/
name|pvals_ui
operator|.
name|output_lpi
argument_list|)
expr_stmt|;
name|g_signal_handlers_unblock_by_func
argument_list|(
name|st
operator|->
name|cellsize
argument_list|,
name|cellsize_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|spi_callback (GtkAdjustment * adjustment,gpointer data)
name|spi_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gimp_double_adjustment_update
argument_list|(
name|adjustment
argument_list|,
operator|&
name|pvals_ui
operator|.
name|input_spi
argument_list|)
expr_stmt|;
name|g_signal_handlers_block_by_func
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|,
name|lpi_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|)
argument_list|,
name|pvals_ui
operator|.
name|input_spi
operator|/
name|pvals
operator|.
name|cell_width
argument_list|)
expr_stmt|;
name|g_signal_handlers_unblock_by_func
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|,
name|lpi_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cellsize_callback (GtkAdjustment * adjustment,gpointer data)
name|cellsize_callback
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gimp_int_adjustment_update
argument_list|(
name|adjustment
argument_list|,
operator|&
name|pvals
operator|.
name|cell_width
argument_list|)
expr_stmt|;
name|g_signal_handlers_block_by_func
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|,
name|lpi_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|)
argument_list|,
name|pvals_ui
operator|.
name|input_spi
operator|/
name|pvals
operator|.
name|cell_width
argument_list|)
expr_stmt|;
name|g_signal_handlers_unblock_by_func
argument_list|(
name|st
operator|->
name|output_lpi
argument_list|,
name|lpi_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|newsprint_defaults_callback (GtkWidget * widget,gpointer data)
name|newsprint_defaults_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
init|=
name|data
decl_stmt|;
name|gint
name|saved_lock
decl_stmt|;
name|gint
name|cspace
decl_stmt|;
name|channel_st
modifier|*
modifier|*
name|chst
decl_stmt|;
specifier|const
name|chan_tmpl
modifier|*
name|ct
decl_stmt|;
name|gint
name|spotfn
decl_stmt|;
name|gint
name|c
decl_stmt|;
comment|/* temporarily turn off channel lock */
name|saved_lock
operator|=
name|pvals_ui
operator|.
name|lock_channels
expr_stmt|;
name|pvals_ui
operator|.
name|lock_channels
operator|=
name|FALSE
expr_stmt|;
comment|/* for each colourspace, reset its channel info */
for|for
control|(
name|cspace
operator|=
literal|0
init|;
name|cspace
operator|<
name|NUM_CS
condition|;
name|cspace
operator|++
control|)
block|{
name|chst
operator|=
name|st
operator|->
name|chst
index|[
name|cspace
index|]
expr_stmt|;
name|ct
operator|=
name|cspace_chan_tmpl
index|[
name|cspace
index|]
expr_stmt|;
comment|/* skip this colourspace if we haven't used it yet */
if|if
condition|(
operator|!
name|chst
index|[
literal|0
index|]
condition|)
continue|continue;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ct
operator|->
name|name
condition|)
block|{
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|chst
index|[
name|c
index|]
operator|->
name|angle_adj
argument_list|)
argument_list|,
operator|*
operator|(
name|ct
operator|->
name|factory_angle
operator|)
argument_list|)
expr_stmt|;
comment|/* change the popup menu and also activate the menuitem in            * question, in order to run the handler that re-computes            * the preview area */
name|spotfn
operator|=
operator|*
operator|(
name|ct
operator|->
name|factory_spotfn
operator|)
expr_stmt|;
name|gimp_int_combo_box_set_active
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|chst
index|[
name|c
index|]
operator|->
name|combo
argument_list|)
argument_list|,
name|spotfn
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
name|ct
operator|++
expr_stmt|;
block|}
block|}
name|pvals_ui
operator|.
name|lock_channels
operator|=
name|saved_lock
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create (but don't yet show) a new vbox for a channel 'widget'.  * Return the channel state, so caller can find the vbox and place it  * in the notebook. */
end_comment

begin_function
specifier|static
name|channel_st
modifier|*
DECL|function|new_channel (const chan_tmpl * ct,GtkWidget * preview)
name|new_channel
parameter_list|(
specifier|const
name|chan_tmpl
modifier|*
name|ct
parameter_list|,
name|GtkWidget
modifier|*
name|preview
parameter_list|)
block|{
name|GtkSizeGroup
modifier|*
name|group
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox2
decl_stmt|;
name|GtkWidget
modifier|*
name|abox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|spot_info_t
modifier|*
name|sf
decl_stmt|;
name|channel_st
modifier|*
name|chst
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* create the channel state record */
name|chst
operator|=
name|new_preview
argument_list|(
name|ct
operator|->
name|spotfn
argument_list|)
expr_stmt|;
name|chst
operator|->
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|chst
operator|->
name|vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|chst
operator|->
name|vbox
argument_list|)
argument_list|,
name|table
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_size_group_new
argument_list|(
name|GTK_SIZE_GROUP_HORIZONTAL
argument_list|)
expr_stmt|;
comment|/* angle slider */
name|chst
operator|->
name|angle_adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"_Angle:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
operator|*
name|ct
operator|->
name|angle
argument_list|,
operator|-
literal|90
argument_list|,
literal|90
argument_list|,
literal|1
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|chst
operator|->
name|angle_adj
argument_list|)
argument_list|,
literal|"angle"
argument_list|,
name|ct
operator|->
name|angle
argument_list|)
expr_stmt|;
name|gtk_size_group_add_widget
argument_list|(
name|group
argument_list|,
name|GIMP_SCALE_ENTRY_LABEL
argument_list|(
name|chst
operator|->
name|angle_adj
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|chst
operator|->
name|angle_adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|angle_callback
argument_list|)
argument_list|,
name|chst
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|chst
operator|->
name|angle_adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
comment|/* spot function popup */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|chst
operator|->
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|abox
operator|=
name|gtk_alignment_new
argument_list|(
literal|0.5
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|abox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|abox
argument_list|)
expr_stmt|;
name|hbox2
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|abox
argument_list|)
argument_list|,
name|hbox2
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox2
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Spot function:"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox2
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_size_group_add_widget
argument_list|(
name|group
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|chst
operator|->
name|combo
operator|=
name|g_object_new
argument_list|(
name|GIMP_TYPE_INT_COMBO_BOX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|sf
operator|=
name|spotfn_list
operator|,
name|i
operator|=
literal|0
init|;
name|sf
operator|->
name|name
condition|;
name|sf
operator|++
operator|,
name|i
operator|++
control|)
name|gimp_int_combo_box_append
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|chst
operator|->
name|combo
argument_list|)
argument_list|,
name|GIMP_INT_STORE_VALUE
argument_list|,
name|i
argument_list|,
name|GIMP_INT_STORE_LABEL
argument_list|,
name|gettext
argument_list|(
name|sf
operator|->
name|name
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_int_combo_box_set_active
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|chst
operator|->
name|combo
argument_list|)
argument_list|,
operator|*
name|ct
operator|->
name|spotfn
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|chst
operator|->
name|combo
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|newsprint_menu_callback
argument_list|)
argument_list|,
name|chst
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|chst
operator|->
name|combo
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox2
argument_list|)
argument_list|,
name|chst
operator|->
name|combo
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|chst
operator|->
name|combo
argument_list|)
expr_stmt|;
comment|/* spot function previews */
block|{
name|GtkWidget
modifier|*
name|sub
decl_stmt|;
name|sub
operator|=
name|gtk_table_new
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|sub
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|sub
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|sub
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|sub
argument_list|)
argument_list|,
name|chst
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|widget
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_SHRINK
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|sub
argument_list|)
argument_list|,
name|chst
operator|->
name|prev
index|[
name|i
index|]
operator|.
name|label
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_SHRINK
operator||
name|GTK_FILL
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_show
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
comment|/* fire the update once to make sure we start with something    * in the preview windows */
name|preview_update
argument_list|(
name|chst
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* create the menuitem used to select this channel for editing */
name|chst
operator|->
name|ch_menuitem
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
name|gettext
argument_list|(
name|ct
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* signal attachment and showing left to caller */
comment|/* deliberately don't show the chst->frame, leave that up to    * the caller */
return|return
name|chst
return|;
block|}
end_function

begin_comment
comment|/* Make all the channels needed for "colourspace", and fill in  * the respective channel state fields in "st". */
end_comment

begin_function
specifier|static
name|void
DECL|function|gen_channels (NewsprintDialog_st * st,gint colourspace,GtkWidget * preview)
name|gen_channels
parameter_list|(
name|NewsprintDialog_st
modifier|*
name|st
parameter_list|,
name|gint
name|colourspace
parameter_list|,
name|GtkWidget
modifier|*
name|preview
parameter_list|)
block|{
specifier|const
name|chan_tmpl
modifier|*
name|ct
decl_stmt|;
name|channel_st
modifier|*
modifier|*
name|chst
decl_stmt|;
name|channel_st
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|chst
operator|=
name|st
operator|->
name|chst
index|[
name|colourspace
index|]
expr_stmt|;
name|ct
operator|=
name|cspace_chan_tmpl
index|[
name|colourspace
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|channel_notebook
index|[
name|colourspace
index|]
operator|=
name|gtk_notebook_new
argument_list|()
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|->
name|vbox
argument_list|)
argument_list|,
name|st
operator|->
name|channel_notebook
index|[
name|colourspace
index|]
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_reorder_child
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|->
name|vbox
argument_list|)
argument_list|,
name|st
operator|->
name|channel_notebook
index|[
name|colourspace
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|st
operator|->
name|channel_notebook
index|[
name|colourspace
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|ct
operator|->
name|name
condition|)
block|{
name|chst
index|[
name|i
index|]
operator|=
name|new_channel
argument_list|(
name|ct
argument_list|,
name|preview
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|chst
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|chst
index|[
name|i
index|]
expr_stmt|;
else|else
name|base
operator|=
name|chst
index|[
name|i
index|]
expr_stmt|;
name|gtk_notebook_append_page
argument_list|(
name|GTK_NOTEBOOK
argument_list|(
name|st
operator|->
name|channel_notebook
index|[
name|colourspace
index|]
argument_list|)
argument_list|,
name|chst
index|[
name|i
index|]
operator|->
name|vbox
argument_list|,
name|gtk_label_new_with_mnemonic
argument_list|(
name|gettext
argument_list|(
name|ct
operator|->
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|chst
index|[
name|i
index|]
operator|->
name|vbox
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ct
operator|++
expr_stmt|;
block|}
comment|/* make the list circular */
name|chst
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|base
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|newsprint_dialog (GimpDrawable * drawable)
name|newsprint_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
comment|/* widgets we need from callbacks stored here */
name|NewsprintDialog_st
name|st
decl_stmt|;
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|paned
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkObject
modifier|*
name|adj
decl_stmt|;
name|GSList
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|gint
name|bpp
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gdouble
name|xres
decl_stmt|,
name|yres
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* flag values to say we haven't filled these channel    * states in yet */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CS
condition|;
name|i
operator|++
control|)
name|st
operator|.
name|chst
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* need to know the bpp, so we can tell if we're doing    * RGB/CMYK or grey style of dialog box */
name|bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
condition|)
name|bpp
operator|--
expr_stmt|;
comment|/* force greyscale if it's the only thing we can do */
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
name|pvals
operator|.
name|colourspace
operator|=
name|CS_GREY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_GREY
condition|)
name|pvals
operator|.
name|colourspace
operator|=
name|CS_RGB
expr_stmt|;
block|}
name|dialog
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Newsprint"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|PLUG_IN_PROC
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|paned
operator|=
name|gtk_hpaned_new
argument_list|()
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|paned
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|paned
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|paned
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_paned_pack1
argument_list|(
name|GTK_PANED
argument_list|(
name|paned
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_end
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|preview
operator|=
name|gimp_drawable_preview_new
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|preview
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|preview
argument_list|,
literal|"invalidated"
argument_list|,
name|G_CALLBACK
argument_list|(
name|newsprint
argument_list|)
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_paned_pack2
argument_list|(
name|GTK_PANED
argument_list|(
name|paned
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
comment|/* resolution settings  */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"Resolution"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gimp_image_get_resolution
argument_list|(
name|gimp_drawable_get_image
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
comment|/* XXX hack: should really note both resolutions, and use    * rectangular cells, not square cells.  But I'm being lazy,    * and the majority of the world works with xres == yres */
name|pvals_ui
operator|.
name|input_spi
operator|=
name|xres
expr_stmt|;
name|st
operator|.
name|input_spi
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"_Input SPI:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|7
argument_list|,
name|pvals_ui
operator|.
name|input_spi
argument_list|,
literal|1.0
argument_list|,
literal|1200.0
argument_list|,
literal|1.0
argument_list|,
literal|10.0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|GIMP_MIN_RESOLUTION
argument_list|,
name|GIMP_MAX_RESOLUTION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|st
operator|.
name|input_spi
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|spi_callback
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|st
operator|.
name|input_spi
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|st
operator|.
name|output_lpi
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"O_utput LPI:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|7
argument_list|,
name|pvals_ui
operator|.
name|output_lpi
argument_list|,
literal|1.0
argument_list|,
literal|1200.0
argument_list|,
literal|1.0
argument_list|,
literal|10.0
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
name|GIMP_MIN_RESOLUTION
argument_list|,
name|GIMP_MAX_RESOLUTION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|st
operator|.
name|output_lpi
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|lpi_callback
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|st
operator|.
name|output_lpi
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|st
operator|.
name|cellsize
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"C_ell size:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|7
argument_list|,
name|pvals
operator|.
name|cell_width
argument_list|,
literal|3.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
literal|5.0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|3.0
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|st
operator|.
name|cellsize
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|cellsize_callback
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|st
operator|.
name|cellsize
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
comment|/* screen settings */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"Screen"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|.
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|st
operator|.
name|vbox
argument_list|)
expr_stmt|;
comment|/* optional portion begins */
if|if
condition|(
name|bpp
operator|!=
literal|1
condition|)
block|{
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|st
operator|.
name|pull_table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|st
operator|.
name|pull_table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* black pullout */
name|st
operator|.
name|pull
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|st
operator|.
name|pull_table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"B_lack pullout (%):"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|pvals
operator|.
name|k_pullout
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|st
operator|.
name|pull_table
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_CMYK
operator|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|st
operator|.
name|pull_table
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|st
operator|.
name|pull
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|pvals
operator|.
name|k_pullout
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|st
operator|.
name|pull
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
comment|/* RGB / CMYK / Luminance select */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  pack the scaleentry table  */
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
argument_list|,
name|st
operator|.
name|pull_table
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|_
argument_list|(
literal|"Separate to:"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_radio_button_new_with_mnemonic
argument_list|(
name|group
argument_list|,
name|_
argument_list|(
literal|"_RGB"
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_get_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_RGB
operator|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"dialog"
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"preview"
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|newsprint_cspace_update
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|CS_RGB
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_radio_button_new_with_mnemonic
argument_list|(
name|group
argument_list|,
name|_
argument_list|(
literal|"C_MYK"
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_get_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_CMYK
operator|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"dialog"
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"preview"
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|newsprint_cspace_update
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|CS_CMYK
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_radio_button_new_with_mnemonic
argument_list|(
name|group
argument_list|,
name|_
argument_list|(
literal|"I_ntensity"
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
name|gtk_radio_button_get_group
argument_list|(
name|GTK_RADIO_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|pvals
operator|.
name|colourspace
operator|==
name|CS_LUMINANCE
operator|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"dialog"
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"preview"
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|newsprint_cspace_update
argument_list|)
argument_list|,
name|GINT_TO_POINTER
argument_list|(
name|CS_LUMINANCE
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/* channel lock& factory defaults button */
name|hbox
operator|=
name|gtk_hbutton_box_new
argument_list|()
expr_stmt|;
name|gtk_box_set_spacing
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Lock channels"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pvals_ui
operator|.
name|lock_channels
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pvals_ui
operator|.
name|lock_channels
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Factory Defaults"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_end
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|button
argument_list|,
literal|"clicked"
argument_list|,
name|G_CALLBACK
argument_list|(
name|newsprint_defaults_callback
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|button
argument_list|,
literal|"clicked"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
block|}
comment|/*  Make the channels appropriate for this colourspace and    *  currently selected defaults.  They may have already been    *  created as a result of callbacks to cspace_update from    *  gtk_toggle_button_set_active().    */
if|if
condition|(
operator|!
name|st
operator|.
name|chst
index|[
name|pvals
operator|.
name|colourspace
index|]
index|[
literal|0
index|]
condition|)
block|{
name|gen_channels
argument_list|(
operator|&
name|st
argument_list|,
name|pvals
operator|.
name|colourspace
argument_list|,
name|preview
argument_list|)
expr_stmt|;
block|}
name|gtk_widget_show
argument_list|(
name|st
operator|.
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* anti-alias control */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"Antialiasing"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"O_versample:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|pvals
operator|.
name|oversample
argument_list|,
literal|1.0
argument_list|,
literal|15.0
argument_list|,
literal|1.0
argument_list|,
literal|5.0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|pvals
operator|.
name|oversample
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|preview_update
argument_list|(
name|st
operator|.
name|chst
index|[
name|pvals
operator|.
name|colourspace
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  Newsprint interface functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|newsprint_cspace_update (GtkWidget * widget,gpointer data)
name|newsprint_cspace_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|NewsprintDialog_st
modifier|*
name|st
decl_stmt|;
name|gint
name|new_cs
init|=
name|GPOINTER_TO_INT
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|gint
name|old_cs
init|=
name|pvals
operator|.
name|colourspace
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|st
operator|=
name|g_object_get_data
argument_list|(
name|G_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|,
literal|"dialog"
argument_list|)
expr_stmt|;
name|preview
operator|=
name|g_object_get_data
argument_list|(
name|G_OBJECT
argument_list|(
name|widget
argument_list|)
argument_list|,
literal|"preview"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
condition|)
name|printf
argument_list|(
literal|"newsprint: cspace_update: no state, can't happen!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
block|{
name|gboolean
name|active
init|=
name|gtk_toggle_button_get_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
argument_list|)
decl_stmt|;
comment|/* the CMYK widget looks after the black pullout widget */
if|if
condition|(
name|new_cs
operator|==
name|CS_CMYK
condition|)
block|{
name|gtk_widget_set_sensitive
argument_list|(
name|st
operator|->
name|pull_table
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
comment|/* if we're not activate, then there's nothing more to do */
if|if
condition|(
operator|!
name|active
condition|)
return|return;
name|pvals
operator|.
name|colourspace
operator|=
name|new_cs
expr_stmt|;
comment|/* make sure we have the necessary channels for the new        * colourspace */
if|if
condition|(
operator|!
name|st
operator|->
name|chst
index|[
name|new_cs
index|]
index|[
literal|0
index|]
condition|)
name|gen_channels
argument_list|(
name|st
argument_list|,
name|new_cs
argument_list|,
name|preview
argument_list|)
expr_stmt|;
comment|/* hide the old channels (if any) */
if|if
condition|(
name|st
operator|->
name|channel_notebook
index|[
name|old_cs
index|]
condition|)
block|{
name|gtk_widget_hide
argument_list|(
name|st
operator|->
name|channel_notebook
index|[
name|old_cs
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* show the new channels */
name|gtk_widget_show
argument_list|(
name|st
operator|->
name|channel_notebook
index|[
name|new_cs
index|]
argument_list|)
expr_stmt|;
name|gtk_notebook_set_current_page
argument_list|(
name|GTK_NOTEBOOK
argument_list|(
name|st
operator|->
name|channel_notebook
index|[
name|new_cs
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preview_update
argument_list|(
name|st
operator|->
name|chst
index|[
name|new_cs
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Newsprint Effect  */
end_comment

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* Spot functions */
end_comment

begin_comment
comment|/* Spot functions define the order in which pixels should be whitened  * as a cell lightened in colour.  They are defined over the entire  * cell, and are called over each pixel in the cell.  The cell  * co-ordinate space ranges from -1.0 .. +1.0 inclusive, in both x- and  * y-axes.  *  * This means the spot function f(x, y) must be defined for:  *     -1<= x<= +1, where x is a real number,   and  *     -1<= y<= +1, where y is a real number.  *  * The function f's range is -1.0 .. +1.0 inclusive, but it is  * permissible for f to return values outside this range: the nearest  * valid value will be used instead.  NOTE: this is in contrast with  * PostScript spot functions, where it is a RangeError for the spot  * function to go outside these limits.  *  * An initially black cell is filled from lowest spot function value  * to highest.  The actual values returned do not matter - it is their  * relative orderings that count.  This means that spot functions do  * not need to be tonally balanced.  A tonally balanced spot function  * is one which for all slices though the function (eg say at z), the  * area of the slice = 4z.  In particular, almost all PostScript spot  * functions are _not_ tonally balanced.  */
end_comment

begin_comment
comment|/* The classic growing dot spot function.  This one isn't tonally  * balanced.  It can be made so, but it's _really_ ugly.  Thanks to  * Richard Mortier for this one:  *  * #define a(r) \  *     ((r<=1)? G_PI * (r*r) : \  *      4 * sqrt(r*r - 1)  +  G_PI*r*r  -  4*r*r*acos(1/r))  *  *   radius = sqrt(x*x + y*y);  *  * return a(radius) / 4; */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_round (gdouble x,gdouble y)
name|spot_round
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
return|return
literal|1
operator|-
operator|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Another commonly seen spot function is the v-shaped wedge. Tonally  * balanced. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_line (gdouble x,gdouble y)
name|spot_line
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
return|return
name|ABS
argument_list|(
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Square/Diamond dot that never becomes round.  Tonally balanced. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_diamond (gdouble x,gdouble y)
name|spot_diamond
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gdouble
name|xy
init|=
name|ABS
argument_list|(
name|x
argument_list|)
operator|+
name|ABS
argument_list|(
name|y
argument_list|)
decl_stmt|;
comment|/* spot only valid for 0<= xy<= 2 */
return|return
operator|(
operator|(
name|xy
operator|<=
literal|1
operator|)
condition|?
literal|2
operator|*
name|xy
operator|*
name|xy
else|:
literal|2
operator|*
name|xy
operator|*
name|xy
operator|-
literal|4
operator|*
operator|(
name|xy
operator|-
literal|1
operator|)
operator|*
operator|(
name|xy
operator|-
literal|1
operator|)
operator|)
operator|/
literal|4
return|;
block|}
end_function

begin_comment
comment|/* The following two functions are implementations of algorithms  * described in "Postscript Screening: Adobe Accurate Screens"  * (Adobe Press, 1992) by Peter Fink.  */
end_comment

begin_comment
comment|/* Square (or Euclidean) dot.  Also very common. */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_PSsquare (gdouble x,gdouble y)
name|spot_PSsquare
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gdouble
name|ax
init|=
name|ABS
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|gdouble
name|ay
init|=
name|ABS
argument_list|(
name|y
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ax
operator|+
name|ay
operator|)
operator|>
literal|1
condition|?
operator|(
operator|(
name|ay
operator|-
literal|1
operator|)
operator|*
operator|(
name|ay
operator|-
literal|1
operator|)
operator|+
operator|(
name|ax
operator|-
literal|1
operator|)
operator|*
operator|(
name|ax
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
else|:
literal|1
operator|-
operator|(
name|ay
operator|*
name|ay
operator|+
name|ax
operator|*
name|ax
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Diamond spot function */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|spot_PSdiamond (gdouble x,gdouble y)
name|spot_PSdiamond
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gdouble
name|ax
init|=
name|ABS
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|gdouble
name|ay
init|=
name|ABS
argument_list|(
name|y
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ax
operator|+
name|ay
operator|)
operator|<=
literal|0.75
condition|?
literal|1
operator|-
operator|(
name|ax
operator|*
name|ax
operator|+
name|ay
operator|*
name|ay
operator|)
else|:
comment|/* dot */
operator|(
operator|(
name|ax
operator|+
name|ay
operator|)
operator|<=
literal|1.23
condition|?
literal|1
operator|-
operator|(
operator|(
name|ay
operator|*
literal|0.76
operator|)
operator|+
name|ax
operator|)
else|:
comment|/* to diamond (0.76 distort) */
operator|(
operator|(
name|ay
operator|-
literal|1
operator|)
operator|*
operator|(
name|ay
operator|-
literal|1
operator|)
operator|+
operator|(
name|ax
operator|-
literal|1
operator|)
operator|*
operator|(
name|ax
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
comment|/* back to dot */
block|}
end_function

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* Spot function to threshold matrix conversion */
end_comment

begin_comment
comment|/* Each call of the spot function results in one of these */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29faa5970708
block|{
DECL|member|index
name|gint
name|index
decl_stmt|;
comment|/* (y * width) + x */
DECL|member|value
name|gdouble
name|value
decl_stmt|;
comment|/* return value of the spot function */
DECL|typedef|order_t
block|}
name|order_t
typedef|;
end_typedef

begin_comment
comment|/* qsort(3) compare function */
end_comment

begin_function
specifier|static
name|gint
DECL|function|order_cmp (const void * va,const void * vb)
name|order_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|order_t
modifier|*
name|a
init|=
name|va
decl_stmt|;
specifier|const
name|order_t
modifier|*
name|b
init|=
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|value
operator|<
name|b
operator|->
name|value
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|a
operator|->
name|value
operator|>
name|b
operator|->
name|value
operator|)
condition|?
operator|+
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert spot function "type" to a threshold matrix of size "width"  * times "width".  Returns newly allocated threshold matrix.  The  * reason for qsort()ing the results rather than just using the spot  * function's value directly as the threshold value is that we want to  * ensure that the threshold matrix is tonally balanced - that is, for  * a threshold value of x%, x% of the values in the matrix are< x%.  *  * Actually, it turns out that qsort()ing a function which is already  * balanced can quite significantly detract from the quality of the  * final result.  This is particularly noticable with the line or  * diamond spot functions at 45 degrees.  This is because if the spot  * function has multiple locations with the same value, qsort may use  * them in any order.  Often, there is quite clearly an optimal order  * however.  By marking functions as pre-balanced, this random  * shuffling is avoided.  WARNING: a non-balanced spot function marked  * as pre-balanced is bad: you'll end up with dark areas becoming too  * dark or too light, and vice versa for light areas.  This is most  * easily checked by halftoning an area, then bluring it back - you  * should get the same colour back again.  The only way of getting a  * correctly balanced function is by getting a formula for the spot's  * area as a function of x and y - this can be fairly tough (ie  * possiblly an integral in two dimensions that must be solved  * analytically).  *  * The threshold matrix is used to compare against image values.  If  * the image value is greater than the threshold value, then the  * output pixel is illuminated.  This means that a threshold matrix  * entry of 0 never causes output pixels to be illuminated.  */
end_comment

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|spot2thresh (gint type,gint width)
name|spot2thresh
parameter_list|(
name|gint
name|type
parameter_list|,
name|gint
name|width
parameter_list|)
block|{
name|gdouble
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gdouble
name|val
decl_stmt|;
name|spotfn_t
modifier|*
name|spotfn
decl_stmt|;
name|guchar
modifier|*
name|thresh
decl_stmt|;
name|order_t
modifier|*
name|order
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|wid2
init|=
name|width
operator|*
name|width
decl_stmt|;
name|gint
name|balanced
init|=
name|spotfn_list
index|[
name|type
index|]
operator|.
name|balanced
decl_stmt|;
name|thresh
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|wid2
argument_list|)
expr_stmt|;
name|spotfn
operator|=
name|spotfn_list
index|[
name|type
index|]
operator|.
name|fn
expr_stmt|;
name|order
operator|=
name|g_new
argument_list|(
name|order_t
argument_list|,
name|wid2
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|width
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
control|)
block|{
comment|/* scale x& y to -1 ... +1 inclusive */
name|sx
operator|=
operator|(
operator|(
operator|(
name|gdouble
operator|)
name|x
operator|)
operator|/
operator|(
name|width
operator|-
literal|1
operator|)
operator|-
literal|0.5
operator|)
operator|*
literal|2
expr_stmt|;
name|sy
operator|=
operator|(
operator|(
operator|(
name|gdouble
operator|)
name|y
operator|)
operator|/
operator|(
name|width
operator|-
literal|1
operator|)
operator|-
literal|0.5
operator|)
operator|*
literal|2
expr_stmt|;
name|val
operator|=
name|spotfn
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|val
operator|=
name|CLAMP
argument_list|(
name|val
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* interval is inclusive */
name|order
index|[
name|i
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|order
index|[
name|i
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|balanced
condition|)
block|{
comment|/* now sort array of (point, value) pairs in ascending order */
name|qsort
argument_list|(
name|order
argument_list|,
name|wid2
argument_list|,
sizeof|sizeof
argument_list|(
name|order_t
argument_list|)
argument_list|,
name|order_cmp
argument_list|)
expr_stmt|;
block|}
comment|/* compile threshold matrix in order from darkest to lightest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wid2
condition|;
name|i
operator|++
control|)
block|{
comment|/* thresh[] contains values from 0 .. 254.  The reason for not        * including 255 is so that an image value of 255 remains        * unmolested.  It would be bad to filter a completely white        * image and end up with black speckles.  */
if|if
condition|(
name|balanced
condition|)
name|thresh
index|[
name|order
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
name|order
index|[
name|i
index|]
operator|.
name|value
operator|*
literal|0xfe
expr_stmt|;
else|else
name|thresh
index|[
name|order
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
name|i
operator|*
literal|0xff
operator|/
name|wid2
expr_stmt|;
block|}
name|g_free
argument_list|(
name|order
argument_list|)
expr_stmt|;
comment|/* TODO: this is where the code to apply a transfer or dot gain    * function to the threshold matrix would go. */
return|return
name|thresh
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* Main loop */
end_comment

begin_comment
comment|/* This function operates on the image, striding across it in tiles. */
end_comment

begin_function
specifier|static
name|void
DECL|function|newsprint (GimpDrawable * drawable,GimpPreview * preview)
name|newsprint
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|GimpPixelRgn
name|src_rgn
decl_stmt|,
name|dest_rgn
decl_stmt|;
name|guchar
modifier|*
name|src_row
decl_stmt|,
modifier|*
name|dest_row
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|guchar
modifier|*
name|thresh
index|[
literal|4
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|gdouble
name|r
decl_stmt|;
name|gdouble
name|theta
decl_stmt|;
name|gdouble
name|rot
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|bpp
decl_stmt|,
name|colour_bpp
decl_stmt|;
name|gint
name|has_alpha
decl_stmt|;
name|gint
name|b
decl_stmt|;
name|gint
name|tile_width
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|x_step
decl_stmt|,
name|y_step
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|preview_width
decl_stmt|,
name|preview_height
decl_stmt|;
name|gint
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|gint
name|progress
decl_stmt|,
name|max_progress
decl_stmt|;
name|gint
name|oversample
decl_stmt|;
name|gint
name|colourspace
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|w002
decl_stmt|;
name|guchar
modifier|*
name|preview_buffer
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|TIMINGS
name|GTimer
modifier|*
name|timer
init|=
name|g_timer_new
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|width
operator|=
name|pvals
operator|.
name|cell_width
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
operator|-
name|width
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|1
condition|)
name|width
operator|=
literal|1
expr_stmt|;
name|oversample
operator|=
name|pvals
operator|.
name|oversample
expr_stmt|;
name|width
operator|*=
name|oversample
expr_stmt|;
name|tile_width
operator|=
name|gimp_tile_width
argument_list|()
expr_stmt|;
name|bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_preview_get_position
argument_list|(
name|preview
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|gimp_preview_get_size
argument_list|(
name|preview
argument_list|,
operator|&
name|preview_width
argument_list|,
operator|&
name|preview_height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
name|preview_width
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
name|preview_height
expr_stmt|;
name|preview_buffer
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|preview_width
operator|*
name|preview_height
operator|*
name|bpp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
block|}
name|has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
expr_stmt|;
name|colour_bpp
operator|=
name|has_alpha
condition|?
name|bpp
operator|-
literal|1
else|:
name|bpp
expr_stmt|;
name|colourspace
operator|=
name|pvals
operator|.
name|colourspace
expr_stmt|;
if|if
condition|(
name|colour_bpp
operator|==
literal|1
condition|)
block|{
name|colourspace
operator|=
name|CS_GREY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|colourspace
operator|==
name|CS_GREY
condition|)
name|colourspace
operator|=
name|CS_RGB
expr_stmt|;
block|}
comment|/* Bartlett window matrix optimisation */
name|w002
operator|=
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|*
name|BARTLETT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It turns out to be slightly slower to cache a pre-computed    * bartlett matrix!   I put it down to d-cache pollution *shrug* */
block|wgt = g_new (gint, oversample * oversample);   for (y = -oversample / 2; y<= oversample / 2; y++)     for (x = -oversample / 2; x<=oversample / 2; x++)       WGT (x, y) = BARTLETT (x, y);
endif|#
directive|endif
comment|/* 0 */
DECL|macro|ASRT (_x)
define|#
directive|define
name|ASRT
parameter_list|(
name|_x
parameter_list|)
define|\
value|do {                                                            \     if (!VALID_SPOTFN(_x))                                      \     {                                                           \         printf("newsprint: %d is not a valid spot type\n", _x); \         _x = SPOTFN_DOT;                                        \     }                                                           \ } while(0)
comment|/* calculate the RGB / CMYK rotations and threshold matrices */
if|if
condition|(
name|colour_bpp
operator|==
literal|1
operator|||
name|colourspace
operator|==
name|CS_LUMINANCE
condition|)
block|{
name|rot
index|[
literal|0
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|gry_ang
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|0
index|]
operator|=
name|spot2thresh
argument_list|(
name|pvals
operator|.
name|gry_spotfn
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gint
name|rf
init|=
name|pvals
operator|.
name|red_spotfn
decl_stmt|;
name|gint
name|gf
init|=
name|pvals
operator|.
name|grn_spotfn
decl_stmt|;
name|gint
name|bf
init|=
name|pvals
operator|.
name|blu_spotfn
decl_stmt|;
name|rot
index|[
literal|0
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|red_ang
argument_list|)
expr_stmt|;
name|rot
index|[
literal|1
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|grn_ang
argument_list|)
expr_stmt|;
name|rot
index|[
literal|2
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|blu_ang
argument_list|)
expr_stmt|;
comment|/* always need at least one threshold matrix */
name|ASRT
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|spotfn_list
index|[
name|rf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|rf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|0
index|]
operator|=
name|spotfn_list
index|[
name|rf
index|]
operator|.
name|thresh
expr_stmt|;
name|ASRT
argument_list|(
name|gf
argument_list|)
expr_stmt|;
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|gf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|1
index|]
operator|=
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
expr_stmt|;
name|ASRT
argument_list|(
name|bf
argument_list|)
expr_stmt|;
name|spotfn_list
index|[
name|bf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|bf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|2
index|]
operator|=
name|spotfn_list
index|[
name|bf
index|]
operator|.
name|thresh
expr_stmt|;
if|if
condition|(
name|colourspace
operator|==
name|CS_CMYK
condition|)
block|{
name|rot
index|[
literal|3
index|]
operator|=
name|DEG2RAD
argument_list|(
name|pvals
operator|.
name|gry_ang
argument_list|)
expr_stmt|;
name|gf
operator|=
name|pvals
operator|.
name|gry_spotfn
expr_stmt|;
name|ASRT
argument_list|(
name|gf
argument_list|)
expr_stmt|;
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
operator|=
name|spot2thresh
argument_list|(
name|gf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|thresh
index|[
literal|3
index|]
operator|=
name|spotfn_list
index|[
name|gf
index|]
operator|.
name|thresh
expr_stmt|;
block|}
block|}
comment|/* Initialize progress */
name|progress
operator|=
literal|0
expr_stmt|;
name|max_progress
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<
name|y2
condition|;
name|y
operator|+=
name|tile_width
operator|-
operator|(
name|y
operator|%
name|tile_width
operator|)
control|)
block|{
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<
name|x2
condition|;
name|x
operator|+=
name|tile_width
operator|-
operator|(
name|x
operator|%
name|tile_width
operator|)
control|)
block|{
comment|/* snap to tile boundary */
name|x_step
operator|=
name|tile_width
operator|-
operator|(
name|x
operator|%
name|tile_width
operator|)
expr_stmt|;
name|y_step
operator|=
name|tile_width
operator|-
operator|(
name|y
operator|%
name|tile_width
operator|)
expr_stmt|;
comment|/* don't step off the end of the image */
name|x_step
operator|=
name|MIN
argument_list|(
name|x_step
argument_list|,
name|x2
operator|-
name|x
argument_list|)
expr_stmt|;
name|y_step
operator|=
name|MIN
argument_list|(
name|y_step
argument_list|,
name|y2
operator|-
name|y
argument_list|)
expr_stmt|;
comment|/* set up the source and dest regions */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x_step
argument_list|,
name|y_step
argument_list|,
name|FALSE
comment|/*dirty*/
argument_list|,
name|FALSE
comment|/*shadow*/
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|drawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x_step
argument_list|,
name|y_step
argument_list|,
name|TRUE
comment|/*dirty*/
argument_list|,
name|TRUE
comment|/*shadow*/
argument_list|)
expr_stmt|;
comment|/* page in the image, one tile at a time */
for|for
control|(
name|pr
operator|=
name|gimp_pixel_rgns_register
argument_list|(
literal|2
argument_list|,
operator|&
name|src_rgn
argument_list|,
operator|&
name|dest_rgn
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|gimp_pixel_rgns_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|src_row
operator|=
name|src_rgn
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|preview
condition|)
name|dest_row
operator|=
name|preview_buffer
operator|+
operator|(
operator|(
name|src_rgn
operator|.
name|y
operator|-
name|y1
operator|)
operator|*
name|preview_width
operator|+
name|src_rgn
operator|.
name|x
operator|-
name|x1
operator|)
operator|*
name|bpp
expr_stmt|;
else|else
name|dest_row
operator|=
name|dest_rgn
operator|.
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|src_rgn
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|src
operator|=
name|src_row
expr_stmt|;
name|dest
operator|=
name|dest_row
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|src_rgn
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
name|guchar
name|data
index|[
literal|4
index|]
decl_stmt|;
name|rx
operator|=
operator|(
name|x
operator|+
name|col
operator|)
operator|*
name|oversample
expr_stmt|;
name|ry
operator|=
operator|(
name|y
operator|+
name|row
operator|)
operator|*
name|oversample
expr_stmt|;
comment|/* convert rx and ry to polar (r, theta) */
name|r
operator|=
name|sqrt
argument_list|(
operator|(
operator|(
name|double
operator|)
name|rx
operator|)
operator|*
name|rx
operator|+
operator|(
operator|(
name|double
operator|)
name|ry
operator|)
operator|*
name|ry
argument_list|)
expr_stmt|;
name|theta
operator|=
name|atan2
argument_list|(
operator|(
operator|(
name|gdouble
operator|)
name|ry
operator|)
argument_list|,
operator|(
operator|(
name|gdouble
operator|)
name|rx
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|colour_bpp
condition|;
name|b
operator|++
control|)
name|data
index|[
name|b
index|]
operator|=
name|src
index|[
name|b
index|]
expr_stmt|;
comment|/* do colour space conversion */
switch|switch
condition|(
name|colourspace
condition|)
block|{
case|case
name|CS_CMYK
case|:
block|{
name|gint
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|r
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|g
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
name|b
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|k
operator|=
name|pvals
operator|.
name|k_pullout
expr_stmt|;
name|gimp_rgb_to_cmyk_int
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|k
expr_stmt|;
block|}
break|break;
case|case
name|CS_LUMINANCE
case|:
name|data
index|[
literal|3
index|]
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* save orig for later */
name|data
index|[
literal|0
index|]
operator|=
name|GIMP_RGB_LUMINANCE
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|)
operator|+
literal|0.5
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|cspace_nchans
index|[
name|colourspace
index|]
condition|;
name|b
operator|++
control|)
block|{
name|rx
operator|=
name|RINT
argument_list|(
name|r
operator|*
name|cos
argument_list|(
name|theta
operator|+
name|rot
index|[
name|b
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ry
operator|=
name|RINT
argument_list|(
name|r
operator|*
name|sin
argument_list|(
name|theta
operator|+
name|rot
index|[
name|b
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure rx and ry are positive and within                            * the range 0 .. width-1 (incl).  Can't use %                            * operator, since its definition on negative                            * numbers is not helpful.  Can't use ABS(),                            * since that would cause reflection about the                            * x- and y-axes.  Relies on integer division                            * rounding towards zero. */
name|rx
operator|-=
operator|(
operator|(
name|rx
operator|-
name|ISNEG
argument_list|(
name|rx
argument_list|)
operator|*
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|/
name|width
operator|)
operator|*
name|width
expr_stmt|;
name|ry
operator|-=
operator|(
operator|(
name|ry
operator|-
name|ISNEG
argument_list|(
name|ry
argument_list|)
operator|*
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|/
name|width
operator|)
operator|*
name|width
expr_stmt|;
block|{
name|guint32
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|gint
name|tx
decl_stmt|,
name|ty
decl_stmt|;
for|for
control|(
name|sy
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sy
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sy
operator|++
control|)
for|for
control|(
name|sx
operator|=
operator|-
name|oversample
operator|/
literal|2
init|;
name|sx
operator|<=
name|oversample
operator|/
literal|2
condition|;
name|sx
operator|++
control|)
block|{
name|tx
operator|=
name|rx
operator|+
name|sx
expr_stmt|;
name|ty
operator|=
name|ry
operator|+
name|sy
expr_stmt|;
while|while
condition|(
name|tx
operator|<
literal|0
condition|)
name|tx
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|<
literal|0
condition|)
name|ty
operator|+=
name|width
expr_stmt|;
while|while
condition|(
name|tx
operator|>=
name|width
condition|)
name|tx
operator|-=
name|width
expr_stmt|;
while|while
condition|(
name|ty
operator|>=
name|width
condition|)
name|ty
operator|-=
name|width
expr_stmt|;
if|if
condition|(
name|data
index|[
name|b
index|]
operator|>
name|THRESHn
argument_list|(
name|b
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|)
condition|)
name|sum
operator|+=
literal|0xff
operator|*
name|BARTLETT
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
name|sum
operator|/=
name|w002
expr_stmt|;
name|data
index|[
name|b
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has_alpha
condition|)
name|dest
index|[
name|colour_bpp
index|]
operator|=
name|src
index|[
name|colour_bpp
index|]
expr_stmt|;
comment|/* re-pack the colours into RGB */
switch|switch
condition|(
name|colourspace
condition|)
block|{
case|case
name|CS_CMYK
case|:
name|data
index|[
literal|0
index|]
operator|=
name|CLAMPED_ADD
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|CLAMPED_ADD
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|CLAMPED_ADD
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|1
index|]
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
literal|0xff
operator|-
name|data
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|CS_LUMINANCE
case|:
if|if
condition|(
name|has_alpha
condition|)
block|{
name|dest
index|[
name|colour_bpp
index|]
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
name|data
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|*
name|data
index|[
literal|0
index|]
operator|/
literal|0xff
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|2
index|]
operator|*
name|data
index|[
literal|0
index|]
operator|/
literal|0xff
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|3
index|]
operator|*
name|data
index|[
literal|0
index|]
operator|/
literal|0xff
expr_stmt|;
break|break;
default|default:
comment|/* no other special cases */
break|break;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|colour_bpp
condition|;
name|b
operator|++
control|)
name|dest
index|[
name|b
index|]
operator|=
name|data
index|[
name|b
index|]
expr_stmt|;
name|src
operator|+=
name|src_rgn
operator|.
name|bpp
expr_stmt|;
name|dest
operator|+=
name|dest_rgn
operator|.
name|bpp
expr_stmt|;
block|}
name|src_row
operator|+=
name|src_rgn
operator|.
name|rowstride
expr_stmt|;
if|if
condition|(
name|preview
condition|)
name|dest_row
operator|+=
name|preview_width
operator|*
name|bpp
expr_stmt|;
else|else
name|dest_row
operator|+=
name|dest_rgn
operator|.
name|rowstride
expr_stmt|;
block|}
comment|/* Update progress */
name|progress
operator|+=
name|src_rgn
operator|.
name|w
operator|*
name|src_rgn
operator|.
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|progress
operator|/
operator|(
name|double
operator|)
name|max_progress
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|TIMINGS
name|g_printerr
argument_list|(
literal|"%f seconds\n"
argument_list|,
name|g_timer_elapsed
argument_list|(
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|g_timer_destroy
argument_list|(
name|timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Note: the tresh array should *NOT* be freed.    * Its values will be reused anyway so this is NOT a memory leak.    * Well it is, but only the first time, so it doesn't matter.    */
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_preview_draw_buffer
argument_list|(
name|preview
argument_list|,
name|preview_buffer
argument_list|,
name|preview_width
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|preview_buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* update the affected region */
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

