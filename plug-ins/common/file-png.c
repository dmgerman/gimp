begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  *   Portable Network Graphics (PNG) plug-in  *  *   Copyright 1997-1998 Michael Sweet (mike@easysw.com) and  *   Daniel Skarda (0rfelyus@atrey.karlin.mff.cuni.cz).  *   and 1999-2000 Nick Lamb (njl195@zepler.org.uk)  *  *   This program is free software: you can redistribute it and/or modify  *   it under the terms of the GNU General Public License as published by  *   the Free Software Foundation; either version 3 of the License, or  *   (at your option) any later version.  *  *   This program is distributed in the hope that it will be useful,  *   but WITHOUT ANY WARRANTY; without even the implied warranty of  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *   GNU General Public License for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program.  If not, see<http://www.gnu.org/licenses/>.  *  * Contents:  *  *   main()                      - Main entry - just call gimp_main()...  *   query()                     - Respond to a plug-in query...  *   run()                       - Run the plug-in...  *   load_image()                - Load a PNG image into a new image window.  *   respin_cmap()               - Re-order a Gimp colormap for PNG tRNS  *   save_image()                - Save the specified image to a PNG file.  *   save_compression_callback() - Update the image compression level.  *   save_interlace_update()     - Update the interlacing option.  *   save_dialog()               - Pop up the save dialog.  *  * Revision History:  *  *   see ChangeLog  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|<png.h>
end_include

begin_comment
comment|/* PNG library definitions */
end_comment

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*  * Constants...  */
end_comment

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-png-load"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-png-save"
end_define

begin_define
DECL|macro|SAVE2_PROC
define|#
directive|define
name|SAVE2_PROC
value|"file-png-save2"
end_define

begin_define
DECL|macro|SAVE_DEFAULTS_PROC
define|#
directive|define
name|SAVE_DEFAULTS_PROC
value|"file-png-save-defaults"
end_define

begin_define
DECL|macro|GET_DEFAULTS_PROC
define|#
directive|define
name|GET_DEFAULTS_PROC
value|"file-png-get-defaults"
end_define

begin_define
DECL|macro|SET_DEFAULTS_PROC
define|#
directive|define
name|SET_DEFAULTS_PROC
value|"file-png-set-defaults"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-png"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-file-png"
end_define

begin_define
DECL|macro|PLUG_IN_VERSION
define|#
directive|define
name|PLUG_IN_VERSION
value|"1.3.4 - 03 September 2002"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|DEFAULT_GAMMA
define|#
directive|define
name|DEFAULT_GAMMA
value|2.20
end_define

begin_define
DECL|macro|PNG_DEFAULTS_PARASITE
define|#
directive|define
name|PNG_DEFAULTS_PARASITE
value|"png-save-defaults"
end_define

begin_comment
comment|/*  * Structures...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon273979660108
block|{
DECL|member|interlaced
name|gboolean
name|interlaced
decl_stmt|;
DECL|member|bkgd
name|gboolean
name|bkgd
decl_stmt|;
DECL|member|gama
name|gboolean
name|gama
decl_stmt|;
DECL|member|offs
name|gboolean
name|offs
decl_stmt|;
DECL|member|phys
name|gboolean
name|phys
decl_stmt|;
DECL|member|time
name|gboolean
name|time
decl_stmt|;
DECL|member|comment
name|gboolean
name|comment
decl_stmt|;
DECL|member|save_transp_pixels
name|gboolean
name|save_transp_pixels
decl_stmt|;
DECL|member|compression_level
name|gint
name|compression_level
decl_stmt|;
block|}
DECL|typedef|PngSaveVals
name|PngSaveVals
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon273979660208
block|{
DECL|member|run
name|gboolean
name|run
decl_stmt|;
DECL|member|interlaced
name|GtkWidget
modifier|*
name|interlaced
decl_stmt|;
DECL|member|bkgd
name|GtkWidget
modifier|*
name|bkgd
decl_stmt|;
DECL|member|gama
name|GtkWidget
modifier|*
name|gama
decl_stmt|;
DECL|member|offs
name|GtkWidget
modifier|*
name|offs
decl_stmt|;
DECL|member|phys
name|GtkWidget
modifier|*
name|phys
decl_stmt|;
DECL|member|time
name|GtkWidget
modifier|*
name|time
decl_stmt|;
DECL|member|comment
name|GtkWidget
modifier|*
name|comment
decl_stmt|;
DECL|member|save_transp_pixels
name|GtkWidget
modifier|*
name|save_transp_pixels
decl_stmt|;
DECL|member|compression_level
name|GtkObject
modifier|*
name|compression_level
decl_stmt|;
block|}
DECL|typedef|PngSaveGui
name|PngSaveGui
typedef|;
end_typedef

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gboolean
name|interactive
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|respin_cmap
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|guchar
modifier|*
name|remap
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_dialog_response
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gint
name|response_id
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|ia_has_transparent_pixels
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|find_unused_ia_color
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_defaults
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_defaults
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_gui_defaults
parameter_list|(
name|PngSaveGui
modifier|*
name|pg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Globals...  */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|query
block|,
name|run
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|defaults
specifier|static
specifier|const
name|PngSaveVals
name|defaults
init|=
block|{
name|FALSE
block|,
name|TRUE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pngvals
specifier|static
name|PngSaveVals
name|pngvals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'main()' - Main entry - just call gimp_main()...  */
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_comment
comment|/*  * 'query()' - Respond to a plug-in query...  */
end_comment

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name of the file to load"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|}
decl_stmt|;
DECL|macro|COMMON_SAVE_ARGS
define|#
directive|define
name|COMMON_SAVE_ARGS
define|\
value|{ GIMP_PDB_INT32,    "run-mode",     "The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }" }, \     { GIMP_PDB_IMAGE,    "image",        "Input image"                  }, \     { GIMP_PDB_DRAWABLE, "drawable",     "Drawable to save"             }, \     { GIMP_PDB_STRING,   "filename",     "The name of the file to save the image in"}, \     { GIMP_PDB_STRING,   "raw-filename", "The name of the file to save the image in"}
DECL|macro|OLD_CONFIG_ARGS
define|#
directive|define
name|OLD_CONFIG_ARGS
define|\
value|{ GIMP_PDB_INT32, "interlace",   "Use Adam7 interlacing?"            }, \     { GIMP_PDB_INT32, "compression", "Deflate Compression factor (0--9)" }, \     { GIMP_PDB_INT32, "bkgd",        "Write bKGD chunk?"                 }, \     { GIMP_PDB_INT32, "gama",        "Write gAMA chunk?"                 }, \     { GIMP_PDB_INT32, "offs",        "Write oFFs chunk?"                 }, \     { GIMP_PDB_INT32, "phys",        "Write pHYs chunk?"                 }, \     { GIMP_PDB_INT32, "time",        "Write tIME chunk?"                 }
DECL|macro|FULL_CONFIG_ARGS
define|#
directive|define
name|FULL_CONFIG_ARGS
define|\
value|OLD_CONFIG_ARGS,                                                        \     { GIMP_PDB_INT32, "comment", "Write comment?"                        }, \     { GIMP_PDB_INT32, "svtrans", "Preserve color of transparent pixels?" }
specifier|static
specifier|const
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
name|COMMON_SAVE_ARGS
block|,
name|OLD_CONFIG_ARGS
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_args2
index|[]
init|=
block|{
name|COMMON_SAVE_ARGS
block|,
name|FULL_CONFIG_ARGS
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_args_defaults
index|[]
init|=
block|{
name|COMMON_SAVE_ARGS
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_get_defaults_return_vals
index|[]
init|=
block|{
name|FULL_CONFIG_ARGS
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_args_set_defaults
index|[]
init|=
block|{
name|FULL_CONFIG_ARGS
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"Loads files in PNG file format"
argument_list|,
literal|"This plug-in loads Portable Network Graphics "
literal|"(PNG) files."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|N_
argument_list|(
literal|"PNG image"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_return_vals
argument_list|)
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"image/png"
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"png"
argument_list|,
literal|""
argument_list|,
literal|"0,string,\211PNG\r\n\032\n"
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"Saves files in PNG file format"
argument_list|,
literal|"This plug-in saves Portable Network Graphics "
literal|"(PNG) files."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|N_
argument_list|(
literal|"PNG image"
argument_list|)
argument_list|,
literal|"RGB*,GRAY*,INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE2_PROC
argument_list|,
literal|"Saves files in PNG file format"
argument_list|,
literal|"This plug-in saves Portable Network Graphics "
literal|"(PNG) files. "
literal|"This procedure adds 2 extra parameters to "
literal|"file-png-save that allows to control whether "
literal|"image comments are saved and whether transparent "
literal|"pixels are saved or nullified."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|N_
argument_list|(
literal|"PNG image"
argument_list|)
argument_list|,
literal|"RGB*,GRAY*,INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE_DEFAULTS_PROC
argument_list|,
literal|"Saves files in PNG file format"
argument_list|,
literal|"This plug-in saves Portable Network Graphics (PNG) "
literal|"files, using the default settings stored as "
literal|"a parasite."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|N_
argument_list|(
literal|"PNG image"
argument_list|)
argument_list|,
literal|"RGB*,GRAY*,INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args_defaults
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args_defaults
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|SAVE_DEFAULTS_PROC
argument_list|,
literal|"image/png"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
name|SAVE_DEFAULTS_PROC
argument_list|,
literal|"png"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|GET_DEFAULTS_PROC
argument_list|,
literal|"Get the current set of defaults used by the "
literal|"PNG file save plug-in"
argument_list|,
literal|"This procedure returns the current set of "
literal|"defaults stored as a parasite for the PNG "
literal|"save plug-in. "
literal|"These defaults are used to seed the UI, by the "
literal|"file_png_save_defaults procedure, and by "
literal|"gimp_file_save when it detects to use PNG."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
literal|0
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_get_defaults_return_vals
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|save_get_defaults_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|SET_DEFAULTS_PROC
argument_list|,
literal|"Set the current set of defaults used by the "
literal|"PNG file save plug-in"
argument_list|,
literal|"This procedure set the current set of defaults "
literal|"stored as a parasite for the PNG save plug-in. "
literal|"These defaults are used to seed the UI, by the "
literal|"file_png_save_defaults procedure, and by "
literal|"gimp_file_save when it detects to use PNG."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args_set_defaults
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args_set_defaults
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'run()' - Run the plug-in...  */
end_comment

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|10
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|gint32
name|orig_image_ID
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE2_PROC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_DEFAULTS_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gboolean
name|alpha
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|image_ID
operator|=
name|orig_image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|load_defaults
argument_list|()
expr_stmt|;
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
name|NULL
argument_list|,
operator|(
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*            * Possibly retrieve data...            */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|pngvals
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
comment|/*            * If the image has no transparency, then there is usually            * no need to save a bKGD chunk.  For more information, see:            * http://bugzilla.gnome.org/show_bug.cgi?id=92395            */
if|if
condition|(
operator|!
name|alpha
condition|)
name|pngvals
operator|.
name|bkgd
operator|=
name|FALSE
expr_stmt|;
comment|/*            * Then acquire information with a dialog...            */
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|orig_image_ID
argument_list|,
name|alpha
argument_list|)
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*            * Make sure all the arguments are there!            */
if|if
condition|(
name|nparams
operator|!=
literal|5
condition|)
block|{
if|if
condition|(
name|nparams
operator|!=
literal|12
operator|&&
name|nparams
operator|!=
literal|14
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|pngvals
operator|.
name|interlaced
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|compression_level
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|bkgd
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|gama
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|offs
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|phys
operator|=
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|time
operator|=
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|nparams
operator|==
literal|14
condition|)
block|{
name|pngvals
operator|.
name|comment
operator|=
name|param
index|[
literal|12
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|save_transp_pixels
operator|=
name|param
index|[
literal|13
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
else|else
block|{
name|pngvals
operator|.
name|comment
operator|=
name|TRUE
expr_stmt|;
name|pngvals
operator|.
name|save_transp_pixels
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|compression_level
operator|<
literal|0
operator|||
name|pngvals
operator|.
name|compression_level
operator|>
literal|9
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*            * Possibly retrieve data...            */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|pngvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|,
name|orig_image_ID
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|pngvals
argument_list|,
sizeof|sizeof
argument_list|(
name|pngvals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GET_DEFAULTS_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|load_defaults
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|10
expr_stmt|;
DECL|macro|SET_VALUE (index,field)
define|#
directive|define
name|SET_VALUE
parameter_list|(
name|index
parameter_list|,
name|field
parameter_list|)
value|G_STMT_START { \  values[(index)].type = GIMP_PDB_INT32;        \  values[(index)].data.d_int32 = pngvals.field; \ } G_STMT_END
name|SET_VALUE
argument_list|(
literal|1
argument_list|,
name|interlaced
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|2
argument_list|,
name|compression_level
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|3
argument_list|,
name|bkgd
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|4
argument_list|,
name|gama
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|5
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|6
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|7
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|8
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|SET_VALUE
argument_list|(
literal|9
argument_list|,
name|save_transp_pixels
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET_VALUE
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SET_DEFAULTS_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nparams
operator|==
literal|9
condition|)
block|{
name|pngvals
operator|.
name|interlaced
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|compression_level
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|bkgd
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|gama
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|offs
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|phys
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|time
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|comment
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|save_transp_pixels
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|save_defaults
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|GIMP_PDB_SUCCESS
operator|&&
name|error
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STRING
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|error
operator|->
name|message
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_struct
DECL|struct|read_error_data
struct|struct
name|read_error_data
block|{
DECL|member|pixel_rgn
name|GimpPixelRgn
modifier|*
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
DECL|member|pixel
name|guchar
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
DECL|member|drawable
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
DECL|member|width
name|guint32
name|width
decl_stmt|;
comment|/* png_infop->width */
DECL|member|height
name|guint32
name|height
decl_stmt|;
comment|/* png_infop->height */
DECL|member|bpp
name|gint
name|bpp
decl_stmt|;
comment|/* Bytes per pixel */
DECL|member|tile_height
name|gint
name|tile_height
decl_stmt|;
comment|/* Height of tile in GIMP */
DECL|member|begin
name|gint
name|begin
decl_stmt|;
comment|/* Beginning tile row */
DECL|member|end
name|gint
name|end
decl_stmt|;
comment|/* Ending tile row */
DECL|member|num
name|gint
name|num
decl_stmt|;
comment|/* Number of rows to load */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
DECL|function|on_read_error (png_structp png_ptr,png_const_charp error_msg)
name|on_read_error
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|error_msg
parameter_list|)
block|{
name|struct
name|read_error_data
modifier|*
name|error_data
init|=
name|png_get_error_ptr
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|gint
name|begin
decl_stmt|;
name|gint
name|end
decl_stmt|;
name|gint
name|num
decl_stmt|;
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"Error loading PNG file: %s"
argument_list|)
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
comment|/* Flush the current half-read row of tiles */
name|gimp_pixel_rgn_set_rect
argument_list|(
name|error_data
operator|->
name|pixel_rgn
argument_list|,
name|error_data
operator|->
name|pixel
argument_list|,
literal|0
argument_list|,
name|error_data
operator|->
name|begin
argument_list|,
name|error_data
operator|->
name|drawable
operator|->
name|width
argument_list|,
name|error_data
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* Fill the rest of the rows of tiles with 0s */
name|memset
argument_list|(
name|error_data
operator|->
name|pixel
argument_list|,
literal|0
argument_list|,
name|error_data
operator|->
name|tile_height
operator|*
name|error_data
operator|->
name|width
operator|*
name|error_data
operator|->
name|bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|begin
operator|=
name|error_data
operator|->
name|begin
operator|+
name|error_data
operator|->
name|tile_height
operator|,
name|end
operator|=
name|error_data
operator|->
name|end
operator|+
name|error_data
operator|->
name|tile_height
init|;
name|begin
operator|<
name|error_data
operator|->
name|height
condition|;
name|begin
operator|+=
name|error_data
operator|->
name|tile_height
operator|,
name|end
operator|+=
name|error_data
operator|->
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|error_data
operator|->
name|height
condition|)
name|end
operator|=
name|error_data
operator|->
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
name|error_data
operator|->
name|pixel_rgn
argument_list|,
name|error_data
operator|->
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|error_data
operator|->
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|png_ptr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'load_image()' - Load a PNG image into a new image window.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|get_bit_depth_for_palette (int num_palette)
name|get_bit_depth_for_palette
parameter_list|(
name|int
name|num_palette
parameter_list|)
block|{
if|if
condition|(
name|num_palette
operator|<=
literal|2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|num_palette
operator|<=
literal|4
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|num_palette
operator|<=
literal|16
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (const gchar * filename,gboolean interactive,GError ** error)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gboolean
name|interactive
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
comment|/* Looping var */
name|trns
decl_stmt|,
comment|/* Transparency present */
name|bpp
decl_stmt|,
comment|/* Bytes per pixel */
name|image_type
decl_stmt|,
comment|/* Type of image */
name|layer_type
decl_stmt|,
comment|/* Type of drawable/layer */
name|empty
decl_stmt|,
comment|/* Number of fully transparent indices */
name|num_passes
decl_stmt|,
comment|/* Number of interlace passes in file */
name|pass
decl_stmt|,
comment|/* Current pass in file */
name|tile_height
decl_stmt|,
comment|/* Height of tile in GIMP */
name|begin
decl_stmt|,
comment|/* Beginning tile row */
name|end
decl_stmt|,
comment|/* Ending tile row */
name|num
decl_stmt|;
comment|/* Number of rows to load */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
specifier|volatile
name|gint32
name|image
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Image -- preserved against setjmp() */
name|gint32
name|layer
decl_stmt|;
comment|/* Layer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|png_structp
name|pp
decl_stmt|;
comment|/* PNG read pointer */
name|png_infop
name|info
decl_stmt|;
comment|/* PNG info pointers */
name|guchar
modifier|*
modifier|*
name|pixels
decl_stmt|,
comment|/* Pixel rows */
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
name|guchar
name|alpha
index|[
literal|256
index|]
decl_stmt|,
comment|/* Index -> Alpha */
modifier|*
name|alpha_ptr
decl_stmt|;
comment|/* Temporary pointer */
name|struct
name|read_error_data
name|error_data
decl_stmt|;
name|png_textp
name|text
decl_stmt|;
name|gint
name|num_texts
decl_stmt|;
name|pp
operator|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|pp
argument_list|)
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error while reading '%s'. File corrupted?"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
comment|/* initialise image here, thus avoiding compiler warnings */
name|image
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*    * Open the file and initialize the PNG read "engine"...    */
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|png_init_io
argument_list|(
name|pp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Get the image dimensions and create the image...    */
name|png_read_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/*    * Latest attempt, this should be my best yet :)    */
if|if
condition|(
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
literal|16
condition|)
block|{
name|png_set_strip_16
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|&&
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|<
literal|8
condition|)
block|{
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|<
literal|8
condition|)
block|{
name|png_set_packing
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Expand G+tRNS to GA, RGB+tRNS to RGBA    */
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|!=
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
block|{
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Turn on interlace handling... libpng returns just 1 (ie single pass)    * if the image is not interlaced    */
name|num_passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Special handling for INDEXED + tRNS (transparency palette)    */
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
operator|&&
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_get_tRNS
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|alpha_ptr
argument_list|,
operator|&
name|num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy the existing alpha values from the tRNS chunk */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|alpha
index|[
name|i
index|]
operator|=
name|alpha_ptr
index|[
name|i
index|]
expr_stmt|;
comment|/* And set any others to fully opaque (255)  */
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|alpha
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
name|trns
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trns
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    * Update the info structures after the transformations take effect    */
name|png_read_update_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_RGB
case|:
comment|/* RGB */
name|bpp
operator|=
literal|3
expr_stmt|;
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|layer_type
operator|=
name|GIMP_RGB_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
comment|/* RGBA */
name|bpp
operator|=
literal|4
expr_stmt|;
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|layer_type
operator|=
name|GIMP_RGBA_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
comment|/* Grayscale */
name|bpp
operator|=
literal|1
expr_stmt|;
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
name|layer_type
operator|=
name|GIMP_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
comment|/* Grayscale + alpha */
name|bpp
operator|=
literal|2
expr_stmt|;
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
name|layer_type
operator|=
name|GIMP_GRAYA_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
comment|/* Indexed */
name|bpp
operator|=
literal|1
expr_stmt|;
name|image_type
operator|=
name|GIMP_INDEXED
expr_stmt|;
name|layer_type
operator|=
name|GIMP_INDEXED_IMAGE
expr_stmt|;
break|break;
default|default:
comment|/* Aie! Unknown type */
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Unknown color model in PNG file '%s'."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|image
operator|=
name|gimp_image_new
argument_list|(
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
argument_list|,
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
argument_list|,
name|image_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|==
operator|-
literal|1
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Could not create new image for '%s': %s"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|gimp_get_pdb_error
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*    * Create the "background" layer to hold the image...    */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
argument_list|,
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
argument_list|,
name|layer_type
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Find out everything we can about the image resolution    * This is only practical with the new 1.0 APIs, I'm afraid    * due to a bug in libpng-1.0.6, see png-implement for details    */
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_gAMA
argument_list|)
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gchar
name|buf
index|[
name|G_ASCII_DTOSTR_BUF_SIZE
index|]
decl_stmt|;
name|gdouble
name|gamma
decl_stmt|;
name|png_get_gAMA
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|gamma
argument_list|)
expr_stmt|;
name|g_ascii_dtostr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gamma"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_oFFs
argument_list|)
condition|)
block|{
name|gint
name|offset_x
init|=
name|png_get_x_offset_pixels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|gint
name|offset_y
init|=
name|png_get_y_offset_pixels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|gimp_layer_set_offsets
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abs
argument_list|(
name|offset_x
argument_list|)
operator|>
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|)
operator|||
operator|(
name|abs
argument_list|(
name|offset_y
argument_list|)
operator|>
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The PNG file specifies an offset that caused "
literal|"the layer to be positioned outside the image."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_pHYs
argument_list|)
condition|)
block|{
name|png_uint_32
name|xres
decl_stmt|;
name|png_uint_32
name|yres
decl_stmt|;
name|gint
name|unit_type
decl_stmt|;
if|if
condition|(
name|png_get_pHYs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|,
operator|&
name|unit_type
argument_list|)
operator|&&
name|xres
operator|>
literal|0
operator|&&
name|yres
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|unit_type
condition|)
block|{
case|case
name|PNG_RESOLUTION_UNKNOWN
case|:
block|{
name|gdouble
name|image_xres
decl_stmt|,
name|image_yres
decl_stmt|;
name|gimp_image_get_resolution
argument_list|(
name|image
argument_list|,
operator|&
name|image_xres
argument_list|,
operator|&
name|image_yres
argument_list|)
expr_stmt|;
if|if
condition|(
name|xres
operator|>
name|yres
condition|)
name|image_xres
operator|=
name|image_yres
operator|*
operator|(
name|gdouble
operator|)
name|xres
operator|/
operator|(
name|gdouble
operator|)
name|yres
expr_stmt|;
else|else
name|image_yres
operator|=
name|image_xres
operator|*
operator|(
name|gdouble
operator|)
name|yres
operator|/
operator|(
name|gdouble
operator|)
name|xres
expr_stmt|;
name|gimp_image_set_resolution
argument_list|(
name|image
argument_list|,
name|image_xres
argument_list|,
name|image_yres
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PNG_RESOLUTION_METER
case|:
name|gimp_image_set_resolution
argument_list|(
name|image
argument_list|,
operator|(
name|gdouble
operator|)
name|xres
operator|*
literal|0.0254
argument_list|,
operator|(
name|gdouble
operator|)
name|yres
operator|*
literal|0.0254
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|gimp_image_set_filename
argument_list|(
name|image
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/*    * Load the colormap as necessary...    */
name|empty
operator|=
literal|0
expr_stmt|;
comment|/* by default assume no full transparent palette entries */
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|&
name|PNG_COLOR_MASK_PALETTE
condition|)
block|{
name|png_colorp
name|palette
decl_stmt|;
name|int
name|num_palette
decl_stmt|;
name|png_get_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|palette
argument_list|,
operator|&
name|num_palette
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
block|{
for|for
control|(
name|empty
operator|=
literal|0
init|;
name|empty
operator|<
literal|256
operator|&&
name|alpha
index|[
name|empty
index|]
operator|==
literal|0
condition|;
operator|++
name|empty
control|)
comment|/* Calculates number of fully transparent "empty" entries */
empty_stmt|;
comment|/*  keep at least one entry  */
name|empty
operator|=
name|MIN
argument_list|(
name|empty
argument_list|,
name|num_palette
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_image_set_colormap
argument_list|(
name|image
argument_list|,
operator|(
name|guchar
operator|*
operator|)
operator|(
name|palette
operator|+
name|empty
operator|)
argument_list|,
name|num_palette
operator|-
name|empty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_set_colormap
argument_list|(
name|image
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|palette
argument_list|,
name|num_palette
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Get the drawable and set the pixel region for our load...    */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*    * Temporary buffer...    */
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pixel
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|tile_height
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixel
operator|+
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|*
name|png_get_channels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|*
name|i
expr_stmt|;
comment|/* Install our own error handler to handle incomplete PNG files better */
name|error_data
operator|.
name|drawable
operator|=
name|drawable
expr_stmt|;
name|error_data
operator|.
name|pixel
operator|=
name|pixel
expr_stmt|;
name|error_data
operator|.
name|tile_height
operator|=
name|tile_height
expr_stmt|;
name|error_data
operator|.
name|width
operator|=
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|error_data
operator|.
name|height
operator|=
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|error_data
operator|.
name|bpp
operator|=
name|bpp
expr_stmt|;
name|error_data
operator|.
name|pixel_rgn
operator|=
operator|&
name|pixel_rgn
expr_stmt|;
name|png_set_error_fn
argument_list|(
name|pp
argument_list|,
operator|&
name|error_data
argument_list|,
name|on_read_error
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_passes
condition|;
name|pass
operator|++
control|)
block|{
comment|/*        * This works if you are only reading one row at a time...        */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
condition|)
name|end
operator|=
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
comment|/* to handle interlaced PiNGs */
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|error_data
operator|.
name|begin
operator|=
name|begin
expr_stmt|;
name|error_data
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|error_data
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|png_read_rows
argument_list|(
name|pp
argument_list|,
name|pixels
argument_list|,
name|NULL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pixel
argument_list|,
literal|0
argument_list|,
name|tile_height
operator|*
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
operator|(
name|gdouble
operator|)
name|pass
operator|+
operator|(
name|gdouble
operator|)
name|end
operator|/
operator|(
name|gdouble
operator|)
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|num_passes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Switch back to default error handler */
name|png_set_error_fn
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_end
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_text
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|text
argument_list|,
operator|&
name|num_texts
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_texts
operator|&&
operator|!
name|comment
condition|;
name|i
operator|++
operator|,
name|text
operator|++
control|)
block|{
if|if
condition|(
name|text
operator|->
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|text
operator|->
name|key
argument_list|,
literal|"Comment"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|text
operator|->
name|text_length
operator|>
literal|0
condition|)
comment|/*  tEXt  */
block|{
name|comment
operator|=
name|g_convert
argument_list|(
name|text
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|,
literal|"UTF-8"
argument_list|,
literal|"ISO-8859-1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g_utf8_validate
argument_list|(
name|text
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/*  iTXt  */
name|comment
operator|=
name|g_strdup
argument_list|(
name|text
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|comment
operator|&&
operator|*
name|comment
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|comment
argument_list|)
operator|+
literal|1
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
comment|/*    * Get the iCCP (colour profile) chunk, if any, and attach it as    * a parasite    */
block|{
name|png_uint_32
name|proflen
decl_stmt|;
name|png_charp
name|profname
decl_stmt|,
name|profile
decl_stmt|;
name|int
name|profcomp
decl_stmt|;
if|if
condition|(
name|png_get_iCCP
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|profname
argument_list|,
operator|&
name|profcomp
argument_list|,
operator|&
name|profile
argument_list|,
operator|&
name|proflen
argument_list|)
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"icc-profile"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
operator||
name|GIMP_PARASITE_UNDOABLE
argument_list|,
name|proflen
argument_list|,
name|profile
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|profname
condition|)
block|{
name|gchar
modifier|*
name|tmp
init|=
name|g_convert
argument_list|(
name|profname
argument_list|,
name|strlen
argument_list|(
name|profname
argument_list|)
argument_list|,
literal|"ISO-8859-1"
argument_list|,
literal|"UTF-8"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"icc-profile-name"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
operator||
name|GIMP_PARASITE_UNDOABLE
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/*    * Done with the file...    */
name|png_destroy_read_struct
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trns
condition|)
block|{
name|gimp_layer_add_alpha
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|drawable
operator|->
name|width
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* bpp == 1 */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|drawable
operator|->
name|height
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|drawable
operator|->
name|height
condition|)
name|end
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
operator|*
name|drawable
operator|->
name|width
condition|;
operator|++
name|i
control|)
block|{
name|pixel
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|alpha
index|[
name|pixel
index|[
name|i
operator|*
literal|2
index|]
index|]
expr_stmt|;
name|pixel
index|[
name|i
operator|*
literal|2
index|]
operator|-=
name|empty
expr_stmt|;
block|}
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
block|}
comment|/*    * Update the display...    */
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function

begin_comment
comment|/*  * 'save_image ()' - Save the specified image to a PNG file.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|save_image (const gchar * filename,gint32 image_ID,gint32 drawable_ID,gint32 orig_image_ID,GError ** error)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|k
decl_stmt|,
comment|/* Looping vars */
name|bpp
init|=
literal|0
decl_stmt|,
comment|/* Bytes per pixel */
name|type
decl_stmt|,
comment|/* Type of drawable/layer */
name|num_passes
decl_stmt|,
comment|/* Number of interlace passes in file */
name|pass
decl_stmt|,
comment|/* Current pass in file */
name|tile_height
decl_stmt|,
comment|/* Height of tile in GIMP */
name|begin
decl_stmt|,
comment|/* Beginning tile row */
name|end
decl_stmt|,
comment|/* Ending tile row */
name|num
decl_stmt|;
comment|/* Number of rows to load */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|png_structp
name|pp
decl_stmt|;
comment|/* PNG read pointer */
name|png_infop
name|info
decl_stmt|;
comment|/* PNG info pointer */
name|gint
name|num_colors
decl_stmt|;
comment|/* Number of colors in colormap */
name|gint
name|offx
decl_stmt|,
name|offy
decl_stmt|;
comment|/* Drawable offsets from origin */
name|guchar
modifier|*
modifier|*
name|pixels
decl_stmt|,
comment|/* Pixel rows */
modifier|*
name|fixed
decl_stmt|,
comment|/* Fixed-up pixel data */
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
name|gdouble
name|xres
decl_stmt|,
name|yres
decl_stmt|;
comment|/* GIMP resolution (dpi) */
name|png_color_16
name|background
decl_stmt|;
comment|/* Background color */
name|png_time
name|mod_time
decl_stmt|;
comment|/* Modification time (ie NOW) */
name|guchar
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
comment|/* Used for palette background */
name|time_t
name|cutime
decl_stmt|;
comment|/* Time since epoch */
name|struct
name|tm
modifier|*
name|gmt
decl_stmt|;
comment|/* GMT broken down */
name|int
name|color_type
decl_stmt|;
name|int
name|bit_depth
decl_stmt|;
name|png_colorp
name|palette
decl_stmt|;
name|guchar
name|remap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Re-mapping for the palette */
name|png_textp
name|text
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pngvals
operator|.
name|comment
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
ifndef|#
directive|ifndef
name|PNG_iTXt_SUPPORTED
name|gsize
name|text_length
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* PNG_iTXt_SUPPORTED */
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|orig_image_ID
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|gchar
modifier|*
name|comment
init|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|)
decl_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|text
operator|=
name|g_new0
argument_list|(
name|png_text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|text
operator|->
name|key
operator|=
literal|"Comment"
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
name|text
operator|->
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
name|text
operator|->
name|text
operator|=
name|comment
expr_stmt|;
name|text
operator|->
name|itxt_length
operator|=
name|strlen
argument_list|(
name|comment
argument_list|)
expr_stmt|;
else|#
directive|else
name|text
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
name|text
operator|->
name|text
operator|=
name|g_convert
argument_list|(
name|comment
argument_list|,
operator|-
literal|1
argument_list|,
literal|"ISO-8859-1"
argument_list|,
literal|"UTF-8"
argument_list|,
name|NULL
argument_list|,
operator|&
name|text_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|text
operator|->
name|text_length
operator|=
name|text_length
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|text
operator|->
name|text
condition|)
block|{
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|pp
operator|=
name|png_create_write_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|pp
argument_list|)
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error while saving '%s'. Could not save image."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|text
condition|)
name|png_set_text
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*    * Open the file and initialize the PNG write "engine"...    */
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|png_init_io
argument_list|(
name|pp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Get the drawable for the current image...    */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|type
operator|=
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
comment|/*    * Initialise remap[]    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|remap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/*    * Set color type and remember bytes per pixel count    */
name|bit_depth
operator|=
literal|8
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
name|bpp
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
name|bpp
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
name|bpp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
name|bpp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|bpp
operator|=
literal|1
expr_stmt|;
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|gimp_image_get_colormap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|num_colors
argument_list|)
expr_stmt|;
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|palette
argument_list|,
name|num_colors
argument_list|)
expr_stmt|;
name|bit_depth
operator|=
name|get_bit_depth_for_palette
argument_list|(
name|num_colors
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|bpp
operator|=
literal|2
expr_stmt|;
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
comment|/* fix up transparency */
name|bit_depth
operator|=
name|respin_cmap
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|remap
argument_list|,
name|image_ID
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Image type can't be saved as PNG"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* All this stuff is optional extras, if the user is aiming for smallest      possible file size she can turn them all off */
if|if
condition|(
name|pngvals
operator|.
name|bkgd
condition|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|gimp_context_get_background
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|background
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|background
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|background
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|background
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|background
operator|.
name|gray
operator|=
name|gimp_rgb_luminance_uchar
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|png_set_bKGD
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|background
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* used to save_transp_pixels */
name|red
operator|=
name|green
operator|=
name|blue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|gama
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gdouble
name|gamma
init|=
literal|1.0
operator|/
name|DEFAULT_GAMMA
decl_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|orig_image_ID
argument_list|,
literal|"gamma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|gamma
operator|=
name|g_ascii_strtod
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|png_set_gAMA
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|offs
condition|)
block|{
name|gimp_drawable_offsets
argument_list|(
name|drawable_ID
argument_list|,
operator|&
name|offx
argument_list|,
operator|&
name|offy
argument_list|)
expr_stmt|;
if|if
condition|(
name|offx
operator|!=
literal|0
operator|||
name|offy
operator|!=
literal|0
condition|)
block|{
name|png_set_oFFs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|,
name|PNG_OFFSET_PIXEL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pngvals
operator|.
name|phys
condition|)
block|{
name|gimp_image_get_resolution
argument_list|(
name|orig_image_ID
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
name|png_set_pHYs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|RINT
argument_list|(
name|xres
operator|/
literal|0.0254
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|yres
operator|/
literal|0.0254
argument_list|)
argument_list|,
name|PNG_RESOLUTION_METER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|time
condition|)
block|{
name|cutime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* time right NOW */
name|gmt
operator|=
name|gmtime
argument_list|(
operator|&
name|cutime
argument_list|)
expr_stmt|;
name|mod_time
operator|.
name|year
operator|=
name|gmt
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|mod_time
operator|.
name|month
operator|=
name|gmt
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|mod_time
operator|.
name|day
operator|=
name|gmt
operator|->
name|tm_mday
expr_stmt|;
name|mod_time
operator|.
name|hour
operator|=
name|gmt
operator|->
name|tm_hour
expr_stmt|;
name|mod_time
operator|.
name|minute
operator|=
name|gmt
operator|->
name|tm_min
expr_stmt|;
name|mod_time
operator|.
name|second
operator|=
name|gmt
operator|->
name|tm_sec
expr_stmt|;
name|png_set_tIME
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|mod_time
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
block|{
name|GimpParasite
modifier|*
name|profile_parasite
decl_stmt|;
name|gchar
modifier|*
name|profile_name
init|=
name|NULL
decl_stmt|;
name|profile_parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|orig_image_ID
argument_list|,
literal|"icc-profile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_parasite
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
init|=
name|gimp_image_get_parasite
argument_list|(
name|orig_image_ID
argument_list|,
literal|"icc-profile-name"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parasite
condition|)
name|profile_name
operator|=
name|g_convert
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|,
literal|"ISO-8859-1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_set_iCCP
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|profile_name
condition|?
name|profile_name
else|:
literal|"ICC profile"
argument_list|,
literal|0
argument_list|,
operator|(
name|gchar
operator|*
operator|)
name|gimp_parasite_data
argument_list|(
name|profile_parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|profile_parasite
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|profile_name
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*    * Set the image dimensions, bit depth, interlacing and compression    */
name|png_set_IHDR
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|bit_depth
argument_list|,
name|color_type
argument_list|,
name|pngvals
operator|.
name|interlaced
condition|?
name|PNG_INTERLACE_ADAM7
else|:
name|PNG_INTERLACE_NONE
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
name|png_set_compression_level
argument_list|(
name|pp
argument_list|,
name|pngvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
name|png_write_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/*    * Turn on interlace handling...    */
if|if
condition|(
name|pngvals
operator|.
name|interlaced
condition|)
name|num_passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|num_passes
operator|=
literal|1
expr_stmt|;
comment|/*    * Convert unpacked pixels to packed if necessary    */
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|bit_depth
operator|<
literal|8
condition|)
name|png_set_packing
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Allocate memory for "tile_height" rows and save the image...    */
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pixel
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|drawable
operator|->
name|width
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|tile_height
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixel
operator|+
name|drawable
operator|->
name|width
operator|*
name|bpp
operator|*
name|i
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_passes
condition|;
name|pass
operator|++
control|)
block|{
comment|/* This works if you are only writing one row at a time... */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|drawable
operator|->
name|height
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|drawable
operator|->
name|height
condition|)
name|end
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/*if we are with a RGBA image and have to pre-multiply the alpha channel */
if|if
condition|(
name|bpp
operator|==
literal|4
operator|&&
operator|!
name|pngvals
operator|.
name|save_transp_pixels
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|drawable
operator|->
name|width
condition|;
operator|++
name|k
control|)
block|{
name|gint
name|aux
init|=
name|k
operator|<<
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|fixed
index|[
name|aux
operator|+
literal|3
index|]
condition|)
block|{
name|fixed
index|[
name|aux
operator|+
literal|0
index|]
operator|=
name|red
expr_stmt|;
name|fixed
index|[
name|aux
operator|+
literal|1
index|]
operator|=
name|green
expr_stmt|;
name|fixed
index|[
name|aux
operator|+
literal|2
index|]
operator|=
name|blue
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we're dealing with a paletted image with            * transparency set, write out the remapped palette */
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
block|{
name|guchar
name|inverse_remap
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|inverse_remap
index|[
name|remap
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|drawable
operator|->
name|width
condition|;
operator|++
name|k
control|)
block|{
name|fixed
index|[
name|k
index|]
operator|=
operator|(
name|fixed
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|>
literal|127
operator|)
condition|?
name|inverse_remap
index|[
name|fixed
index|[
name|k
operator|*
literal|2
index|]
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise if we have a paletted image and transparency            * couldn't be set, we ignore the alpha channel */
elseif|else
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_PLTE
argument_list|)
operator|&&
name|bpp
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|drawable
operator|->
name|width
condition|;
operator|++
name|k
control|)
block|{
name|fixed
index|[
name|k
index|]
operator|=
name|fixed
index|[
name|k
operator|*
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
name|png_write_rows
argument_list|(
name|pp
argument_list|,
name|pixels
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
operator|(
name|double
operator|)
name|pass
operator|+
operator|(
name|double
operator|)
name|end
operator|/
operator|(
name|double
operator|)
name|drawable
operator|->
name|height
operator|)
operator|/
operator|(
name|double
operator|)
name|num_passes
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|png_write_end
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|png_destroy_write_struct
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
comment|/*    * Done with the file...    */
if|if
condition|(
name|text
condition|)
block|{
name|g_free
argument_list|(
name|text
operator|->
name|text
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|ia_has_transparent_pixels (GimpDrawable * drawable)
name|ia_has_transparent_pixels
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|guchar
modifier|*
name|pixel_row
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|guchar
modifier|*
name|pixel
decl_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|gimp_pixel_rgns_register
argument_list|(
literal|1
argument_list|,
operator|&
name|pixel_rgn
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|gimp_pixel_rgns_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|pixel_row
operator|=
name|pixel_rgn
operator|.
name|data
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|pixel_rgn
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
name|pixel
operator|=
name|pixel_row
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|pixel_rgn
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|pixel
index|[
literal|1
index|]
operator|<=
literal|127
condition|)
return|return
name|TRUE
return|;
name|pixel
operator|+=
literal|2
expr_stmt|;
block|}
name|pixel_row
operator|+=
name|pixel_rgn
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Try to find a color in the palette which isn't actually  * used in the image, so that we can use it as the transparency  * index. Taken from gif.c */
end_comment

begin_function
specifier|static
name|gint
DECL|function|find_unused_ia_color (GimpDrawable * drawable,gint * colors)
name|find_unused_ia_color
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
block|{
name|gboolean
name|ix_used
index|[
literal|256
index|]
decl_stmt|;
name|gboolean
name|trans_used
init|=
name|FALSE
decl_stmt|;
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|colors
condition|;
name|i
operator|++
control|)
name|ix_used
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|gimp_pixel_rgns_register
argument_list|(
literal|1
argument_list|,
operator|&
name|pixel_rgn
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|gimp_pixel_rgns_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
specifier|const
name|guchar
modifier|*
name|pixel_row
init|=
name|pixel_rgn
operator|.
name|data
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|pixel_rgn
operator|.
name|h
condition|;
name|row
operator|++
control|)
block|{
specifier|const
name|guchar
modifier|*
name|pixel
init|=
name|pixel_row
decl_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|pixel_rgn
operator|.
name|w
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|pixel
index|[
literal|1
index|]
operator|>
literal|127
condition|)
name|ix_used
index|[
name|pixel
index|[
literal|0
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
else|else
name|trans_used
operator|=
name|TRUE
expr_stmt|;
name|pixel
operator|+=
literal|2
expr_stmt|;
block|}
name|pixel_row
operator|+=
name|pixel_rgn
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
comment|/* If there is no transparency, ignore alpha. */
if|if
condition|(
name|trans_used
operator|==
name|FALSE
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|colors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ix_used
index|[
name|i
index|]
operator|==
name|FALSE
condition|)
return|return
name|i
return|;
block|}
comment|/* Couldn't find an unused color index within the number of      bits per pixel we wanted.  Will have to increment the number      of colors in the image and assign a transparent pixel there. */
if|if
condition|(
operator|(
operator|*
name|colors
operator|)
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|colors
operator|)
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|colors
operator|)
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|respin_cmap (png_structp pp,png_infop info,guchar * remap,gint32 image_ID,GimpDrawable * drawable)
name|respin_cmap
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|guchar
modifier|*
name|remap
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
specifier|static
specifier|const
name|guchar
name|trans
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|gint
name|colors
decl_stmt|;
name|guchar
modifier|*
name|before
decl_stmt|;
name|before
operator|=
name|gimp_image_get_colormap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
comment|/*    * Make sure there is something in the colormap.    */
if|if
condition|(
name|colors
operator|==
literal|0
condition|)
block|{
name|before
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|colors
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Try to find an entry which isn't actually used in the      image, for a transparency index. */
if|if
condition|(
name|ia_has_transparent_pixels
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
name|gint
name|transparent
init|=
name|find_unused_ia_color
argument_list|(
name|drawable
argument_list|,
operator|&
name|colors
argument_list|)
decl_stmt|;
if|if
condition|(
name|transparent
operator|!=
operator|-
literal|1
condition|)
comment|/* we have a winner for a transparent                                      * index - do like gif2png and swap                                      * index 0 and index transparent */
block|{
name|png_color
name|palette
index|[
literal|256
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|png_set_tRNS
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|(
name|png_bytep
operator|)
name|trans
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Transform all pixels with a value = transparent to            * 0 and vice versa to compensate for re-ordering in palette            * due to png_set_tRNS() */
name|remap
index|[
literal|0
index|]
operator|=
name|transparent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|transparent
condition|;
name|i
operator|++
control|)
name|remap
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* Copy from index 0 to index transparent - 1 to index 1 to            * transparent of after, then from transparent+1 to colors-1            * unchanged, and finally from index transparent to index 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
operator|+
literal|1
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
operator|+
literal|2
index|]
expr_stmt|;
block|}
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|palette
argument_list|,
name|colors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Inform the user that we couldn't losslessly save the            * transparency& just use the full palette */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Couldn't losslessly save transparency, "
literal|"saving opacity instead."
argument_list|)
argument_list|)
expr_stmt|;
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|(
name|png_colorp
operator|)
name|before
argument_list|,
name|colors
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|(
name|png_colorp
operator|)
name|before
argument_list|,
name|colors
argument_list|)
expr_stmt|;
block|}
return|return
name|get_bit_depth_for_palette
argument_list|(
name|colors
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GtkWidget
modifier|*
DECL|function|toggle_button_init (GtkBuilder * builder,const gchar * name,gboolean initial_value,gboolean * value_pointer)
name|toggle_button_init
parameter_list|(
name|GtkBuilder
modifier|*
name|builder
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gboolean
name|initial_value
parameter_list|,
name|gboolean
modifier|*
name|value_pointer
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|toggle
init|=
name|NULL
decl_stmt|;
name|toggle
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
name|value_pointer
argument_list|)
expr_stmt|;
return|return
name|toggle
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (gint32 image_ID,gboolean alpha)
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
block|{
name|PngSaveGui
name|pg
decl_stmt|;
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkBuilder
modifier|*
name|builder
decl_stmt|;
name|gchar
modifier|*
name|ui_file
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
comment|/* Dialog init */
name|dialog
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"PNG"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|SAVE_PROC
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|dialog
argument_list|,
literal|"response"
argument_list|,
name|G_CALLBACK
argument_list|(
name|save_dialog_response
argument_list|)
argument_list|,
operator|&
name|pg
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|dialog
argument_list|,
literal|"destroy"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gtk_main_quit
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* GtkBuilder init */
name|builder
operator|=
name|gtk_builder_new
argument_list|()
expr_stmt|;
name|ui_file
operator|=
name|g_build_filename
argument_list|(
name|gimp_data_directory
argument_list|()
argument_list|,
literal|"ui/plug-ins/plug-in-file-png.ui"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gtk_builder_add_from_file
argument_list|(
name|builder
argument_list|,
name|ui_file
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|display_name
init|=
name|g_filename_display_name
argument_list|(
name|ui_file
argument_list|)
decl_stmt|;
name|g_printerr
argument_list|(
name|_
argument_list|(
literal|"Error loading UI file '%s': %s"
argument_list|)
argument_list|,
name|display_name
argument_list|,
name|error
condition|?
name|error
operator|->
name|message
else|:
literal|"???"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|display_name
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|ui_file
argument_list|)
expr_stmt|;
comment|/* Table */
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|,
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"table"
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Toggles */
name|pg
operator|.
name|interlaced
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"interlace"
argument_list|,
name|pngvals
operator|.
name|interlaced
argument_list|,
operator|&
name|pngvals
operator|.
name|interlaced
argument_list|)
expr_stmt|;
name|pg
operator|.
name|bkgd
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-background-color"
argument_list|,
name|pngvals
operator|.
name|bkgd
argument_list|,
operator|&
name|pngvals
operator|.
name|bkgd
argument_list|)
expr_stmt|;
name|pg
operator|.
name|gama
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-gamma"
argument_list|,
name|pngvals
operator|.
name|gama
argument_list|,
operator|&
name|pngvals
operator|.
name|gama
argument_list|)
expr_stmt|;
name|pg
operator|.
name|offs
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-layer-offset"
argument_list|,
name|pngvals
operator|.
name|offs
argument_list|,
operator|&
name|pngvals
operator|.
name|offs
argument_list|)
expr_stmt|;
name|pg
operator|.
name|phys
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-resolution"
argument_list|,
name|pngvals
operator|.
name|phys
argument_list|,
operator|&
name|pngvals
operator|.
name|phys
argument_list|)
expr_stmt|;
name|pg
operator|.
name|time
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-creation-time"
argument_list|,
name|pngvals
operator|.
name|time
argument_list|,
operator|&
name|pngvals
operator|.
name|time
argument_list|)
expr_stmt|;
comment|/* Comment toggle */
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|image_ID
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
name|pg
operator|.
name|comment
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-comment"
argument_list|,
name|pngvals
operator|.
name|comment
operator|&&
name|parasite
operator|!=
name|NULL
argument_list|,
operator|&
name|pngvals
operator|.
name|comment
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|pg
operator|.
name|comment
argument_list|,
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
comment|/* Transparent pixels toggle */
name|pg
operator|.
name|save_transp_pixels
operator|=
name|toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-transparent-pixels"
argument_list|,
name|alpha
operator|&&
name|pngvals
operator|.
name|save_transp_pixels
argument_list|,
operator|&
name|pngvals
operator|.
name|save_transp_pixels
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|pg
operator|.
name|save_transp_pixels
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
comment|/* Compression level scale */
name|pg
operator|.
name|compression_level
operator|=
name|GTK_OBJECT
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"compression-level"
argument_list|)
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|pg
operator|.
name|compression_level
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
comment|/* Load/save defaults buttons */
name|g_signal_connect_swapped
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"load-defaults"
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
name|G_CALLBACK
argument_list|(
name|load_gui_defaults
argument_list|)
argument_list|,
operator|&
name|pg
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"save-defaults"
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
name|G_CALLBACK
argument_list|(
name|save_defaults
argument_list|)
argument_list|,
operator|&
name|pg
argument_list|)
expr_stmt|;
comment|/* Show dialog and run */
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|pg
operator|.
name|run
operator|=
name|FALSE
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
return|return
name|pg
operator|.
name|run
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_dialog_response (GtkWidget * widget,gint response_id,gpointer data)
name|save_dialog_response
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gint
name|response_id
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|PngSaveGui
modifier|*
name|pg
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|response_id
condition|)
block|{
case|case
name|GTK_RESPONSE_OK
case|:
name|pg
operator|->
name|run
operator|=
name|TRUE
expr_stmt|;
default|default:
name|gtk_widget_destroy
argument_list|(
name|widget
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|load_defaults (void)
name|load_defaults
parameter_list|(
name|void
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_get_parasite
argument_list|(
name|PNG_DEFAULTS_PARASITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|gchar
modifier|*
name|def_str
decl_stmt|;
name|PngSaveVals
name|tmpvals
decl_stmt|;
name|gint
name|num_fields
decl_stmt|;
name|def_str
operator|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|num_fields
operator|=
name|sscanf
argument_list|(
name|def_str
argument_list|,
literal|"%d %d %d %d %d %d %d %d %d"
argument_list|,
operator|&
name|tmpvals
operator|.
name|interlaced
argument_list|,
operator|&
name|tmpvals
operator|.
name|bkgd
argument_list|,
operator|&
name|tmpvals
operator|.
name|gama
argument_list|,
operator|&
name|tmpvals
operator|.
name|offs
argument_list|,
operator|&
name|tmpvals
operator|.
name|phys
argument_list|,
operator|&
name|tmpvals
operator|.
name|time
argument_list|,
operator|&
name|tmpvals
operator|.
name|comment
argument_list|,
operator|&
name|tmpvals
operator|.
name|save_transp_pixels
argument_list|,
operator|&
name|tmpvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|def_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_fields
operator|==
literal|9
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pngvals
argument_list|,
operator|&
name|tmpvals
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpvals
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|memcpy
argument_list|(
operator|&
name|pngvals
argument_list|,
operator|&
name|defaults
argument_list|,
sizeof|sizeof
argument_list|(
name|defaults
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_defaults (void)
name|save_defaults
parameter_list|(
name|void
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gchar
modifier|*
name|def_str
decl_stmt|;
name|def_str
operator|=
name|g_strdup_printf
argument_list|(
literal|"%d %d %d %d %d %d %d %d %d"
argument_list|,
name|pngvals
operator|.
name|interlaced
argument_list|,
name|pngvals
operator|.
name|bkgd
argument_list|,
name|pngvals
operator|.
name|gama
argument_list|,
name|pngvals
operator|.
name|offs
argument_list|,
name|pngvals
operator|.
name|phys
argument_list|,
name|pngvals
operator|.
name|time
argument_list|,
name|pngvals
operator|.
name|comment
argument_list|,
name|pngvals
operator|.
name|save_transp_pixels
argument_list|,
name|pngvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|PNG_DEFAULTS_PARASITE
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|def_str
argument_list|)
argument_list|,
name|def_str
argument_list|)
expr_stmt|;
name|gimp_attach_parasite
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|def_str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|load_gui_defaults (PngSaveGui * pg)
name|load_gui_defaults
parameter_list|(
name|PngSaveGui
modifier|*
name|pg
parameter_list|)
block|{
name|load_defaults
argument_list|()
expr_stmt|;
DECL|macro|SET_ACTIVE (field)
define|#
directive|define
name|SET_ACTIVE
parameter_list|(
name|field
parameter_list|)
define|\
value|if (gtk_widget_is_sensitive (pg->field)) \     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (pg->field), pngvals.field)
name|SET_ACTIVE
argument_list|(
name|interlaced
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|bkgd
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|gama
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|time
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|SET_ACTIVE
argument_list|(
name|save_transp_pixels
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET_ACTIVE
name|gtk_adjustment_set_value
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|pg
operator|->
name|compression_level
argument_list|)
argument_list|,
name|pngvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

