begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  *   Portable Network Graphics (PNG) plug-in  *  *   Copyright 1997-1998 Michael Sweet (mike@easysw.com) and  *   Daniel Skarda (0rfelyus@atrey.karlin.mff.cuni.cz).  *   and 1999-2000 Nick Lamb (njl195@zepler.org.uk)  *  *   This program is free software: you can redistribute it and/or modify  *   it under the terms of the GNU General Public License as published by  *   the Free Software Foundation; either version 3 of the License, or  *   (at your option) any later version.  *  *   This program is distributed in the hope that it will be useful,  *   but WITHOUT ANY WARRANTY; without even the implied warranty of  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *   GNU General Public License for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program.  If not, see<https://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|<png.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-png-load"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-png-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-png"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-file-png"
end_define

begin_define
DECL|macro|PLUG_IN_VERSION
define|#
directive|define
name|PLUG_IN_VERSION
value|"1.3.4 - 03 September 2002"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|DEFAULT_GAMMA
define|#
directive|define
name|DEFAULT_GAMMA
value|2.20
end_define

begin_typedef
DECL|enum|_PngExportformat
typedef|typedef
enum|enum
name|_PngExportformat
block|{
DECL|enumerator|PNG_FORMAT_AUTO
name|PNG_FORMAT_AUTO
init|=
literal|0
block|,
DECL|enumerator|PNG_FORMAT_RGB8
name|PNG_FORMAT_RGB8
block|,
DECL|enumerator|PNG_FORMAT_GRAY8
name|PNG_FORMAT_GRAY8
block|,
DECL|enumerator|PNG_FORMAT_RGBA8
name|PNG_FORMAT_RGBA8
block|,
DECL|enumerator|PNG_FORMAT_GRAYA8
name|PNG_FORMAT_GRAYA8
block|,
DECL|enumerator|PNG_FORMAT_RGB16
name|PNG_FORMAT_RGB16
block|,
DECL|enumerator|PNG_FORMAT_GRAY16
name|PNG_FORMAT_GRAY16
block|,
DECL|enumerator|PNG_FORMAT_RGBA16
name|PNG_FORMAT_RGBA16
block|,
DECL|enumerator|PNG_FORMAT_GRAYA16
name|PNG_FORMAT_GRAYA16
DECL|typedef|PngExportFormat
block|}
name|PngExportFormat
typedef|;
end_typedef

begin_typedef
DECL|typedef|Png
typedef|typedef
name|struct
name|_Png
name|Png
typedef|;
end_typedef

begin_typedef
DECL|typedef|PngClass
typedef|typedef
name|struct
name|_PngClass
name|PngClass
typedef|;
end_typedef

begin_struct
DECL|struct|_Png
struct|struct
name|_Png
block|{
DECL|member|parent_instance
name|GimpPlugIn
name|parent_instance
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_PngClass
struct|struct
name|_PngClass
block|{
DECL|member|parent_class
name|GimpPlugInClass
name|parent_class
decl_stmt|;
block|}
struct|;
end_struct

begin_define
DECL|macro|PNG_TYPE
define|#
directive|define
name|PNG_TYPE
value|(png_get_type ())
end_define

begin_define
DECL|macro|PNG
define|#
directive|define
name|PNG
value|(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PNG_TYPE, Png))
end_define

begin_decl_stmt
name|GType
name|png_get_type
argument_list|(
name|void
argument_list|)
name|G_GNUC_CONST
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GList
modifier|*
name|png_query_procedures
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpProcedure
modifier|*
name|png_create_procedure
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|png_load
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|png_save
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImage
modifier|*
name|load_image
parameter_list|(
name|GFile
modifier|*
name|file
parameter_list|,
name|gboolean
name|interactive
parameter_list|,
name|gboolean
modifier|*
name|resolution_loaded
parameter_list|,
name|gboolean
modifier|*
name|profile_loaded
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
name|GFile
modifier|*
name|file
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|orig_image
parameter_list|,
name|GObject
modifier|*
name|config
parameter_list|,
name|gint
modifier|*
name|bits_per_sample
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|respin_cmap
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|guchar
modifier|*
name|remap
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GObject
modifier|*
name|config
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|offsets_dialog
parameter_list|(
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|ia_has_transparent_pixels
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|find_unused_ia_color
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|G_DEFINE_TYPE (Png,png,GIMP_TYPE_PLUG_IN)
name|G_DEFINE_TYPE
argument_list|(
argument|Png
argument_list|,
argument|png
argument_list|,
argument|GIMP_TYPE_PLUG_IN
argument_list|)
end_macro

begin_macro
name|GIMP_MAIN
argument_list|(
argument|PNG_TYPE
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|png_class_init
parameter_list|(
name|PngClass
modifier|*
name|klass
parameter_list|)
block|{
name|GimpPlugInClass
modifier|*
name|plug_in_class
init|=
name|GIMP_PLUG_IN_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|plug_in_class
operator|->
name|query_procedures
operator|=
name|png_query_procedures
expr_stmt|;
name|plug_in_class
operator|->
name|create_procedure
operator|=
name|png_create_procedure
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|png_init (Png * png)
name|png_init
parameter_list|(
name|Png
modifier|*
name|png
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|png_query_procedures (GimpPlugIn * plug_in)
name|png_query_procedures
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|)
block|{
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|LOAD_PROC
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|SAVE_PROC
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|GimpProcedure
modifier|*
DECL|function|png_create_procedure (GimpPlugIn * plug_in,const gchar * name)
name|png_create_procedure
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GimpProcedure
modifier|*
name|procedure
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_load_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|png_load
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_menu_label
argument_list|(
name|procedure
argument_list|,
name|N_
argument_list|(
literal|"PNG image"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Loads files in PNG file format"
argument_list|,
literal|"This plug-in loads Portable Network "
literal|"Graphics (PNG) files."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_mime_types
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"image/png"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_extensions
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"png"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_magics
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"0,string,\211PNG\r\n\032\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_save_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|png_save
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_image_types
argument_list|(
name|procedure
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_menu_label
argument_list|(
name|procedure
argument_list|,
name|N_
argument_list|(
literal|"PNG image"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Exports files in PNG file format"
argument_list|,
literal|"This plug-in exports Portable Network "
literal|"Graphics (PNG) files."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, "
literal|"Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, "
literal|"Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_mime_types
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"image/png"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_extensions
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"png"
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"interlaced"
argument_list|,
literal|"Interlaced"
argument_list|,
literal|"Use Adam7 interlacing?"
argument_list|,
name|FALSE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"compression"
argument_list|,
literal|"Compression"
argument_list|,
literal|"Deflate Compression factor (0..9)"
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
literal|9
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"bkgd"
argument_list|,
literal|"bKGD"
argument_list|,
literal|"Write bKGD chunk?"
argument_list|,
name|TRUE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"gama"
argument_list|,
literal|"gAMA"
argument_list|,
literal|"Write gAMA chunk?"
argument_list|,
name|FALSE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"offs"
argument_list|,
literal|"oFFs"
argument_list|,
literal|"Write oFFs chunk?"
argument_list|,
name|FALSE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"phys"
argument_list|,
literal|"pHYs"
argument_list|,
literal|"Write pHYs chunk?"
argument_list|,
name|TRUE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"time"
argument_list|,
literal|"tIME"
argument_list|,
literal|"Write tIME chunk?"
argument_list|,
name|TRUE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-comment"
argument_list|,
literal|"Save comment"
argument_list|,
literal|"Write comment?"
argument_list|,
name|gimp_export_comment
argument_list|()
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_STRING
argument_list|(
name|procedure
argument_list|,
literal|"comment"
argument_list|,
literal|"Comment"
argument_list|,
literal|"Image comment"
argument_list|,
name|gimp_get_default_comment
argument_list|()
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-transparent"
argument_list|,
literal|"Save transparent"
argument_list|,
literal|"Preserve color of transparent pixels?"
argument_list|,
name|TRUE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"format"
argument_list|,
literal|"Format"
argument_list|,
literal|"PNG export format"
argument_list|,
name|PNG_FORMAT_AUTO
argument_list|,
name|PNG_FORMAT_GRAYA16
argument_list|,
name|PNG_FORMAT_AUTO
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-exif"
argument_list|,
literal|"Save Exif"
argument_list|,
literal|"Save Exif"
argument_list|,
name|gimp_export_exif
argument_list|()
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-xmp"
argument_list|,
literal|"Save XMP"
argument_list|,
literal|"Save XMP"
argument_list|,
name|gimp_export_xmp
argument_list|()
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-iptc"
argument_list|,
literal|"Save IPTC"
argument_list|,
literal|"Save IPTC"
argument_list|,
name|gimp_export_iptc
argument_list|()
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-thumbnail"
argument_list|,
literal|"Save thumbnail"
argument_list|,
literal|"Save thumbnail"
argument_list|,
name|TRUE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_AUX_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"save-color-profile"
argument_list|,
literal|"Save profile"
argument_list|,
literal|"Save color profile"
argument_list|,
name|gimp_export_color_profile
argument_list|()
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
block|}
return|return
name|procedure
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|png_load (GimpProcedure * procedure,GimpRunMode run_mode,GFile * file,const GimpValueArray * args,gpointer run_data)
name|png_load
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpValueArray
modifier|*
name|return_vals
decl_stmt|;
name|gboolean
name|interactive
decl_stmt|;
name|gboolean
name|resolution_loaded
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|profile_loaded
init|=
name|FALSE
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|interactive
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|image
operator|=
name|load_image
argument_list|(
name|file
argument_list|,
name|interactive
argument_list|,
operator|&
name|resolution_loaded
argument_list|,
operator|&
name|profile_loaded
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_EXECUTION_ERROR
argument_list|,
name|error
argument_list|)
return|;
name|metadata
operator|=
name|gimp_image_metadata_load_prepare
argument_list|(
name|image
argument_list|,
literal|"image/png"
argument_list|,
name|file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
condition|)
block|{
name|GimpMetadataLoadFlags
name|flags
init|=
name|GIMP_METADATA_LOAD_ALL
decl_stmt|;
if|if
condition|(
name|resolution_loaded
condition|)
name|flags
operator|&=
operator|~
name|GIMP_METADATA_LOAD_RESOLUTION
expr_stmt|;
if|if
condition|(
name|profile_loaded
condition|)
name|flags
operator|&=
operator|~
name|GIMP_METADATA_LOAD_COLORSPACE
expr_stmt|;
name|gimp_image_metadata_load_finish
argument_list|(
name|image
argument_list|,
literal|"image/png"
argument_list|,
name|metadata
argument_list|,
name|flags
argument_list|,
name|interactive
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
name|return_vals
operator|=
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_SUCCESS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_IMAGE
argument_list|(
name|return_vals
argument_list|,
literal|1
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return
name|return_vals
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|png_save (GimpProcedure * procedure,GimpRunMode run_mode,GimpImage * image,GimpDrawable * drawable,GFile * file,const GimpValueArray * args,gpointer run_data)
name|png_save
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpProcedureConfig
modifier|*
name|config
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GimpMetadata
modifier|*
name|metadata
decl_stmt|;
name|GimpImage
modifier|*
name|orig_image
decl_stmt|;
name|gboolean
name|alpha
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|config
operator|=
name|gimp_procedure_create_config
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|metadata
operator|=
name|gimp_procedure_config_begin_export
argument_list|(
name|config
argument_list|,
name|image
argument_list|,
name|run_mode
argument_list|,
name|args
argument_list|,
literal|"image/png"
argument_list|)
expr_stmt|;
name|orig_image
operator|=
name|image
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image
argument_list|,
operator|&
name|drawable
argument_list|,
literal|"PNG"
argument_list|,
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_CANCEL
argument_list|,
name|NULL
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
name|alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* If the image has no transparency, then there is usually no need    * to save a bKGD chunk. For more information, see:    * http://bugzilla.gnome.org/show_bug.cgi?id=92395    */
if|if
condition|(
operator|!
name|alpha
condition|)
name|g_object_set
argument_list|(
name|config
argument_list|,
literal|"bkgd"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|orig_image
argument_list|,
name|procedure
argument_list|,
name|G_OBJECT
argument_list|(
name|config
argument_list|)
argument_list|,
name|alpha
argument_list|)
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
name|gint
name|bits_per_sample
decl_stmt|;
if|if
condition|(
name|save_image
argument_list|(
name|file
argument_list|,
name|image
argument_list|,
name|drawable
argument_list|,
name|orig_image
argument_list|,
name|G_OBJECT
argument_list|(
name|config
argument_list|)
argument_list|,
operator|&
name|bits_per_sample
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
if|if
condition|(
name|metadata
condition|)
name|gimp_metadata_set_bits_per_sample
argument_list|(
name|metadata
argument_list|,
name|bits_per_sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
name|gimp_procedure_config_end_export
argument_list|(
name|config
argument_list|,
name|image
argument_list|,
name|file
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|status
argument_list|,
name|error
argument_list|)
return|;
block|}
end_function

begin_struct
DECL|struct|read_error_data
struct|struct
name|read_error_data
block|{
DECL|member|pixel
name|guchar
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
DECL|member|buffer
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
comment|/* GEGL buffer for layer */
DECL|member|file_format
specifier|const
name|Babl
modifier|*
name|file_format
decl_stmt|;
DECL|member|width
name|guint32
name|width
decl_stmt|;
comment|/* png_infop->width */
DECL|member|height
name|guint32
name|height
decl_stmt|;
comment|/* png_infop->height */
DECL|member|bpp
name|gint
name|bpp
decl_stmt|;
comment|/* Bytes per pixel */
DECL|member|tile_height
name|gint
name|tile_height
decl_stmt|;
comment|/* Height of tile in GIMP */
DECL|member|begin
name|gint
name|begin
decl_stmt|;
comment|/* Beginning tile row */
DECL|member|end
name|gint
name|end
decl_stmt|;
comment|/* Ending tile row */
DECL|member|num
name|gint
name|num
decl_stmt|;
comment|/* Number of rows to load */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
DECL|function|on_read_error (png_structp png_ptr,png_const_charp error_msg)
name|on_read_error
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|error_msg
parameter_list|)
block|{
name|struct
name|read_error_data
modifier|*
name|error_data
init|=
name|png_get_error_ptr
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|gint
name|begin
decl_stmt|;
name|gint
name|end
decl_stmt|;
name|gint
name|num
decl_stmt|;
name|g_printerr
argument_list|(
name|_
argument_list|(
literal|"Error loading PNG file: %s\n"
argument_list|)
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
comment|/* Flush the current half-read row of tiles */
name|gegl_buffer_set
argument_list|(
name|error_data
operator|->
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|error_data
operator|->
name|begin
argument_list|,
name|error_data
operator|->
name|width
argument_list|,
name|error_data
operator|->
name|num
argument_list|)
argument_list|,
literal|0
argument_list|,
name|error_data
operator|->
name|file_format
argument_list|,
name|error_data
operator|->
name|pixel
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|begin
operator|=
name|error_data
operator|->
name|begin
operator|+
name|error_data
operator|->
name|tile_height
expr_stmt|;
if|if
condition|(
name|begin
operator|<
name|error_data
operator|->
name|height
condition|)
block|{
name|end
operator|=
name|MIN
argument_list|(
name|error_data
operator|->
name|end
operator|+
name|error_data
operator|->
name|tile_height
argument_list|,
name|error_data
operator|->
name|height
argument_list|)
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gegl_buffer_clear
argument_list|(
name|error_data
operator|->
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|begin
argument_list|,
name|error_data
operator|->
name|width
argument_list|,
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_object_unref
argument_list|(
name|error_data
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|png_ptr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|get_bit_depth_for_palette (int num_palette)
name|get_bit_depth_for_palette
parameter_list|(
name|int
name|num_palette
parameter_list|)
block|{
if|if
condition|(
name|num_palette
operator|<=
literal|2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|num_palette
operator|<=
literal|4
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|num_palette
operator|<=
literal|16
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|GimpColorProfile
modifier|*
DECL|function|load_color_profile (png_structp pp,png_infop info,gchar ** profile_name)
name|load_color_profile
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|gchar
modifier|*
modifier|*
name|profile_name
parameter_list|)
block|{
name|GimpColorProfile
modifier|*
name|profile
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
name|png_uint_32
name|proflen
decl_stmt|;
name|png_charp
name|profname
decl_stmt|;
name|png_bytep
name|prof
decl_stmt|;
name|int
name|profcomp
decl_stmt|;
if|if
condition|(
name|png_get_iCCP
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|profname
argument_list|,
operator|&
name|profcomp
argument_list|,
operator|&
name|prof
argument_list|,
operator|&
name|proflen
argument_list|)
condition|)
block|{
name|profile
operator|=
name|gimp_color_profile_new_from_icc_profile
argument_list|(
operator|(
name|guint8
operator|*
operator|)
name|prof
argument_list|,
name|proflen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile
operator|&&
name|profname
condition|)
block|{
operator|*
name|profile_name
operator|=
name|g_convert
argument_list|(
name|profname
argument_list|,
name|strlen
argument_list|(
name|profname
argument_list|)
argument_list|,
literal|"ISO-8859-1"
argument_list|,
literal|"UTF-8"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|profile
return|;
block|}
end_function

begin_comment
comment|/*  * 'load_image()' - Load a PNG image into a new image window.  */
end_comment

begin_function
specifier|static
name|GimpImage
modifier|*
DECL|function|load_image (GFile * file,gboolean interactive,gboolean * resolution_loaded,gboolean * profile_loaded,GError ** error)
name|load_image
parameter_list|(
name|GFile
modifier|*
name|file
parameter_list|,
name|gboolean
name|interactive
parameter_list|,
name|gboolean
modifier|*
name|resolution_loaded
parameter_list|,
name|gboolean
modifier|*
name|profile_loaded
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* Looping var */
name|gint
name|trns
decl_stmt|;
comment|/* Transparency present */
name|gint
name|bpp
decl_stmt|;
comment|/* Bytes per pixel */
name|gint
name|width
decl_stmt|;
comment|/* image width */
name|gint
name|height
decl_stmt|;
comment|/* image height */
name|gint
name|num_passes
decl_stmt|;
comment|/* Number of interlace passes in file */
name|gint
name|pass
decl_stmt|;
comment|/* Current pass in file */
name|gint
name|tile_height
decl_stmt|;
comment|/* Height of tile in GIMP */
name|gint
name|begin
decl_stmt|;
comment|/* Beginning tile row */
name|gint
name|end
decl_stmt|;
comment|/* Ending tile row */
name|gint
name|num
decl_stmt|;
comment|/* Number of rows to load */
name|GimpImageBaseType
name|image_type
decl_stmt|;
comment|/* Type of image */
name|GimpPrecision
name|image_precision
decl_stmt|;
comment|/* Precision of image */
name|GimpImageType
name|layer_type
decl_stmt|;
comment|/* Type of drawable/layer */
name|GimpColorProfile
modifier|*
name|profile
init|=
name|NULL
decl_stmt|;
comment|/* Color profile */
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gchar
modifier|*
name|profile_name
init|=
name|NULL
decl_stmt|;
comment|/* Profile's name */
name|gboolean
name|linear
init|=
name|FALSE
decl_stmt|;
comment|/* Linear RGB */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
specifier|volatile
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
comment|/* Image -- protected for setjmp() */
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
comment|/* Layer */
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
comment|/* GEGL buffer for layer */
specifier|const
name|Babl
modifier|*
name|file_format
decl_stmt|;
comment|/* BABL format for layer */
name|png_structp
name|pp
decl_stmt|;
comment|/* PNG read pointer */
name|png_infop
name|info
decl_stmt|;
comment|/* PNG info pointers */
name|guchar
modifier|*
modifier|*
name|pixels
decl_stmt|;
comment|/* Pixel rows */
name|guchar
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
name|guchar
name|alpha
index|[
literal|256
index|]
decl_stmt|;
comment|/* Index -> Alpha */
name|png_textp
name|text
decl_stmt|;
name|gint
name|num_texts
decl_stmt|;
name|struct
name|read_error_data
name|error_data
decl_stmt|;
name|pp
operator|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pp
condition|)
block|{
comment|/* this could happen if the compile time and run-time libpng          versions do not match. */
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error creating PNG read struct while loading '%s'."
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error while reading '%s'. Could not create PNG header info structure."
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|pp
argument_list|)
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error while reading '%s'. File corrupted?"
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GimpImage
operator|*
operator|)
name|image
return|;
block|}
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
comment|/* Change some libpng errors to warnings (e.g. bug 721135) */
name|png_set_benign_errors
argument_list|(
name|pp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* bug 765850 */
name|png_set_option
argument_list|(
name|pp
argument_list|,
name|PNG_SKIP_sRGB_CHECK_PROFILE
argument_list|,
name|PNG_OPTION_ON
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Open the file and initialize the PNG read "engine"...    */
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|png_init_io
argument_list|(
name|pp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|png_set_compression_buffer_size
argument_list|(
name|pp
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/*    * Get the image info    */
name|png_read_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_BYTE_ORDER
operator|==
name|G_LITTLE_ENDIAN
condition|)
name|png_set_swap
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Get the iCCP (color profile) chunk, if any, and figure if it's    * a linear RGB profile    */
name|profile
operator|=
name|load_color_profile
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|profile_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile
condition|)
block|{
operator|*
name|profile_loaded
operator|=
name|TRUE
expr_stmt|;
name|linear
operator|=
name|gimp_color_profile_is_linear
argument_list|(
name|profile
argument_list|)
expr_stmt|;
block|}
comment|/*    * Get image precision and color model    */
if|if
condition|(
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|linear
condition|)
name|image_precision
operator|=
name|GIMP_PRECISION_U16_LINEAR
expr_stmt|;
else|else
name|image_precision
operator|=
name|GIMP_PRECISION_U16_NON_LINEAR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|linear
condition|)
name|image_precision
operator|=
name|GIMP_PRECISION_U8_LINEAR
expr_stmt|;
else|else
name|image_precision
operator|=
name|GIMP_PRECISION_U8_NON_LINEAR
expr_stmt|;
block|}
if|if
condition|(
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_set_packing
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Expand G+tRNS to GA, RGB+tRNS to RGBA    */
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|!=
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Turn on interlace handling... libpng returns just 1 (ie single pass)    * if the image is not interlaced    */
name|num_passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Special handling for INDEXED + tRNS (transparency palette)    */
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
operator|&&
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|guchar
modifier|*
name|alpha_ptr
decl_stmt|;
name|png_get_tRNS
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|alpha_ptr
argument_list|,
operator|&
name|num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy the existing alpha values from the tRNS chunk */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|alpha
index|[
name|i
index|]
operator|=
name|alpha_ptr
index|[
name|i
index|]
expr_stmt|;
comment|/* And set any others to fully opaque (255)  */
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|alpha
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
name|trns
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trns
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    * Update the info structures after the transformations take effect    */
name|png_read_update_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_RGB
case|:
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|layer_type
operator|=
name|GIMP_RGB_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|layer_type
operator|=
name|GIMP_RGBA_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
name|layer_type
operator|=
name|GIMP_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
name|layer_type
operator|=
name|GIMP_GRAYA_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
name|image_type
operator|=
name|GIMP_INDEXED
expr_stmt|;
name|layer_type
operator|=
name|GIMP_INDEXED_IMAGE
expr_stmt|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Unknown color model in PNG file '%s'."
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|width
operator|=
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|height
operator|=
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_image_new_with_precision
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|image_type
argument_list|,
name|image_precision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Could not create new image for '%s': %s"
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|,
name|gimp_pdb_get_last_error
argument_list|(
name|gimp_get_pdb
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*    * Attach the color profile, if any    */
if|if
condition|(
name|profile
condition|)
block|{
name|gimp_image_set_color_profile
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|profile
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_name
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"icc-profile-name"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
operator||
name|GIMP_PARASITE_UNDOABLE
argument_list|,
name|strlen
argument_list|(
name|profile_name
argument_list|)
argument_list|,
name|profile_name
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|profile_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Create the "background" layer to hold the image...    */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|layer_type
argument_list|,
literal|100
argument_list|,
name|gimp_image_get_default_new_layer_mode
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_format
operator|=
name|gimp_drawable_get_format
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Find out everything we can about the image resolution    * This is only practical with the new 1.0 APIs, I'm afraid    * due to a bug in libpng-1.0.6, see png-implement for details    */
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_gAMA
argument_list|)
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gchar
name|buf
index|[
name|G_ASCII_DTOSTR_BUF_SIZE
index|]
decl_stmt|;
name|gdouble
name|gamma
decl_stmt|;
name|png_get_gAMA
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|gamma
argument_list|)
expr_stmt|;
name|g_ascii_dtostr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gamma"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_oFFs
argument_list|)
condition|)
block|{
name|gint
name|offset_x
init|=
name|png_get_x_offset_pixels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|gint
name|offset_y
init|=
name|png_get_y_offset_pixels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
name|gimp_layer_set_offsets
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsets_dialog
argument_list|(
name|offset_x
argument_list|,
name|offset_y
argument_list|)
condition|)
block|{
name|gimp_layer_set_offsets
argument_list|(
name|layer
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|offset_x
argument_list|)
operator|>
name|width
operator|||
name|abs
argument_list|(
name|offset_y
argument_list|)
operator|>
name|height
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The PNG file specifies an offset that caused "
literal|"the layer to be positioned outside the image."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_pHYs
argument_list|)
condition|)
block|{
name|png_uint_32
name|xres
decl_stmt|;
name|png_uint_32
name|yres
decl_stmt|;
name|gint
name|unit_type
decl_stmt|;
if|if
condition|(
name|png_get_pHYs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|,
operator|&
name|unit_type
argument_list|)
operator|&&
name|xres
operator|>
literal|0
operator|&&
name|yres
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|unit_type
condition|)
block|{
case|case
name|PNG_RESOLUTION_UNKNOWN
case|:
block|{
name|gdouble
name|image_xres
decl_stmt|,
name|image_yres
decl_stmt|;
name|gimp_image_get_resolution
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
operator|&
name|image_xres
argument_list|,
operator|&
name|image_yres
argument_list|)
expr_stmt|;
if|if
condition|(
name|xres
operator|>
name|yres
condition|)
name|image_xres
operator|=
name|image_yres
operator|*
operator|(
name|gdouble
operator|)
name|xres
operator|/
operator|(
name|gdouble
operator|)
name|yres
expr_stmt|;
else|else
name|image_yres
operator|=
name|image_xres
operator|*
operator|(
name|gdouble
operator|)
name|yres
operator|/
operator|(
name|gdouble
operator|)
name|xres
expr_stmt|;
name|gimp_image_set_resolution
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|image_xres
argument_list|,
name|image_yres
argument_list|)
expr_stmt|;
operator|*
name|resolution_loaded
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|PNG_RESOLUTION_METER
case|:
name|gimp_image_set_resolution
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
operator|(
name|gdouble
operator|)
name|xres
operator|*
literal|0.0254
argument_list|,
operator|(
name|gdouble
operator|)
name|yres
operator|*
literal|0.0254
argument_list|)
expr_stmt|;
name|gimp_image_set_unit
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|GIMP_UNIT_MM
argument_list|)
expr_stmt|;
operator|*
name|resolution_loaded
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|gimp_image_set_file
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/*    * Load the colormap as necessary...    */
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|&
name|PNG_COLOR_MASK_PALETTE
condition|)
block|{
name|png_colorp
name|palette
decl_stmt|;
name|int
name|num_palette
decl_stmt|;
name|png_get_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|palette
argument_list|,
operator|&
name|num_palette
argument_list|)
expr_stmt|;
name|gimp_image_set_colormap
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|palette
argument_list|,
name|num_palette
argument_list|)
expr_stmt|;
block|}
name|bpp
operator|=
name|babl_format_get_bytes_per_pixel
argument_list|(
name|file_format
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Temporary buffer...    */
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pixel
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|width
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|tile_height
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixel
operator|+
name|width
operator|*
name|bpp
operator|*
name|i
expr_stmt|;
comment|/* Install our own error handler to handle incomplete PNG files better */
name|error_data
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|error_data
operator|.
name|pixel
operator|=
name|pixel
expr_stmt|;
name|error_data
operator|.
name|file_format
operator|=
name|file_format
expr_stmt|;
name|error_data
operator|.
name|tile_height
operator|=
name|tile_height
expr_stmt|;
name|error_data
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|error_data
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|error_data
operator|.
name|bpp
operator|=
name|bpp
expr_stmt|;
name|png_set_error_fn
argument_list|(
name|pp
argument_list|,
operator|&
name|error_data
argument_list|,
name|on_read_error
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_passes
condition|;
name|pass
operator|++
control|)
block|{
comment|/*        * This works if you are only reading one row at a time...        */
for|for
control|(
name|begin
operator|=
literal|0
init|;
name|begin
operator|<
name|height
condition|;
name|begin
operator|+=
name|tile_height
control|)
block|{
name|end
operator|=
name|MIN
argument_list|(
name|begin
operator|+
name|tile_height
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
comment|/* to handle interlaced PiNGs */
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|begin
argument_list|,
name|width
argument_list|,
name|num
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|file_format
argument_list|,
name|pixel
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|error_data
operator|.
name|begin
operator|=
name|begin
expr_stmt|;
name|error_data
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|error_data
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|png_read_rows
argument_list|(
name|pp
argument_list|,
name|pixels
argument_list|,
name|NULL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|begin
argument_list|,
name|width
argument_list|,
name|num
argument_list|)
argument_list|,
literal|0
argument_list|,
name|file_format
argument_list|,
name|pixel
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
operator|(
name|gdouble
operator|)
name|pass
operator|+
operator|(
name|gdouble
operator|)
name|end
operator|/
operator|(
name|gdouble
operator|)
name|height
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|num_passes
argument_list|)
expr_stmt|;
block|}
block|}
name|png_read_end
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Switch back to default error handler */
name|png_set_error_fn
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_text
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|text
argument_list|,
operator|&
name|num_texts
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_texts
operator|&&
operator|!
name|comment
condition|;
name|i
operator|++
operator|,
name|text
operator|++
control|)
block|{
if|if
condition|(
name|text
operator|->
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|text
operator|->
name|key
argument_list|,
literal|"Comment"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|text
operator|->
name|text_length
operator|>
literal|0
condition|)
comment|/*  tEXt  */
block|{
name|comment
operator|=
name|g_convert
argument_list|(
name|text
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|,
literal|"UTF-8"
argument_list|,
literal|"ISO-8859-1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g_utf8_validate
argument_list|(
name|text
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/*  iTXt  */
name|comment
operator|=
name|g_strdup
argument_list|(
name|text
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|comment
operator|&&
operator|*
name|comment
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|comment
argument_list|)
operator|+
literal|1
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
operator|(
name|GimpImage
operator|*
operator|)
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
block|}
comment|/*    * Done with the file...    */
name|png_destroy_read_struct
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trns
condition|)
block|{
name|GeglBufferIterator
modifier|*
name|iter
decl_stmt|;
name|gint
name|n_components
decl_stmt|;
name|gimp_layer_add_alpha
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|file_format
operator|=
name|gegl_buffer_get_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|iter
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|file_format
argument_list|,
name|GEGL_ACCESS_READWRITE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n_components
operator|=
name|babl_format_get_n_components
argument_list|(
name|file_format
argument_list|)
expr_stmt|;
name|g_warn_if_fail
argument_list|(
name|n_components
operator|==
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|iter
argument_list|)
condition|)
block|{
name|guchar
modifier|*
name|data
init|=
name|iter
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|length
init|=
name|iter
operator|->
name|length
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|data
index|[
literal|1
index|]
operator|=
name|alpha
index|[
name|data
index|[
literal|0
index|]
index|]
expr_stmt|;
name|data
operator|+=
name|n_components
expr_stmt|;
block|}
block|}
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|GimpImage
operator|*
operator|)
name|image
return|;
block|}
end_function

begin_comment
comment|/*  * 'offsets_dialog ()' - Asks the user about offsets when loading.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|offsets_dialog (gint offset_x,gint offset_y)
name|offsets_dialog
parameter_list|(
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|image
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|gchar
modifier|*
name|message
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Apply PNG Offset"
argument_list|)
argument_list|,
name|PLUG_IN_ROLE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|LOAD_PROC
argument_list|,
name|_
argument_list|(
literal|"Ignore PNG offset"
argument_list|)
argument_list|,
name|GTK_RESPONSE_NO
argument_list|,
name|_
argument_list|(
literal|"Apply PNG offset to layer"
argument_list|)
argument_list|,
name|GTK_RESPONSE_YES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_default_response
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_YES
argument_list|)
expr_stmt|;
name|gimp_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_YES
argument_list|,
name|GTK_RESPONSE_NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_window_set_resizable
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_box_new
argument_list|(
name|GTK_ORIENTATION_HORIZONTAL
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|image
operator|=
name|gtk_image_new_from_icon_name
argument_list|(
name|GIMP_ICON_DIALOG_QUESTION
argument_list|,
name|GTK_ICON_SIZE_DIALOG
argument_list|)
expr_stmt|;
name|gtk_widget_set_valign
argument_list|(
name|image
argument_list|,
name|GTK_ALIGN_START
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|image
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|message
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"The PNG image you are importing specifies an "
literal|"offset of %d, %d. Do you want to apply "
literal|"this offset to the layer?"
argument_list|)
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|gtk_label_set_yalign
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gtk_label_set_line_wrap
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_YES
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  * 'save_image ()' - Export the specified image to a PNG file.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon277c6d650108
block|{
DECL|member|has_trns
name|gboolean
name|has_trns
decl_stmt|;
DECL|member|trans
name|png_bytep
name|trans
decl_stmt|;
DECL|member|num_trans
name|int
name|num_trans
decl_stmt|;
DECL|member|has_plte
name|gboolean
name|has_plte
decl_stmt|;
DECL|member|palette
name|png_colorp
name|palette
decl_stmt|;
DECL|member|num_palette
name|int
name|num_palette
decl_stmt|;
block|}
DECL|typedef|PngGlobals
name|PngGlobals
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|pngg
specifier|static
name|PngGlobals
name|pngg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|gboolean
DECL|function|save_image (GFile * file,GimpImage * image,GimpDrawable * drawable,GimpImage * orig_image,GObject * config,gint * bits_per_sample,GError ** error)
name|save_image
parameter_list|(
name|GFile
modifier|*
name|file
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|orig_image
parameter_list|,
name|GObject
modifier|*
name|config
parameter_list|,
name|gint
modifier|*
name|bits_per_sample
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* Looping vars */
name|gint
name|bpp
init|=
literal|0
decl_stmt|;
comment|/* Bytes per pixel */
name|gint
name|type
decl_stmt|;
comment|/* Type of drawable/layer */
name|gint
name|num_passes
decl_stmt|;
comment|/* Number of interlace passes in file */
name|gint
name|pass
decl_stmt|;
comment|/* Current pass in file */
name|gint
name|tile_height
decl_stmt|;
comment|/* Height of tile in GIMP */
name|gint
name|width
decl_stmt|;
comment|/* image width */
name|gint
name|height
decl_stmt|;
comment|/* image height */
name|gint
name|begin
decl_stmt|;
comment|/* Beginning tile row */
name|gint
name|end
decl_stmt|;
comment|/* Ending tile row */
name|gint
name|num
decl_stmt|;
comment|/* Number of rows to load */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
name|GimpColorProfile
modifier|*
name|profile
init|=
name|NULL
decl_stmt|;
comment|/* Color profile */
name|gboolean
name|out_linear
decl_stmt|;
comment|/* Save linear RGB */
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
comment|/* GEGL buffer for layer */
name|gchar
modifier|*
name|filename
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|file_format
init|=
name|NULL
decl_stmt|;
comment|/* BABL format of file */
specifier|const
name|gchar
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|space
decl_stmt|;
name|png_structp
name|pp
decl_stmt|;
comment|/* PNG read pointer */
name|png_infop
name|info
decl_stmt|;
comment|/* PNG info pointer */
name|gint
name|offx
decl_stmt|,
name|offy
decl_stmt|;
comment|/* Drawable offsets from origin */
name|guchar
modifier|*
modifier|*
name|pixels
decl_stmt|;
comment|/* Pixel rows */
name|guchar
modifier|*
name|fixed
decl_stmt|;
comment|/* Fixed-up pixel data */
name|guchar
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
name|gdouble
name|xres
decl_stmt|,
name|yres
decl_stmt|;
comment|/* GIMP resolution (dpi) */
name|png_color_16
name|background
decl_stmt|;
comment|/* Background color */
name|png_time
name|mod_time
decl_stmt|;
comment|/* Modification time (ie NOW) */
name|time_t
name|cutime
decl_stmt|;
comment|/* Time since epoch */
name|struct
name|tm
modifier|*
name|gmt
decl_stmt|;
comment|/* GMT broken down */
name|gint
name|color_type
decl_stmt|;
comment|/* PNG color type */
name|gint
name|bit_depth
decl_stmt|;
comment|/* Default to bit depth 16 */
name|guchar
name|remap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Re-mapping for the palette */
name|png_textp
name|text
init|=
name|NULL
decl_stmt|;
name|gboolean
name|save_interlaced
decl_stmt|;
name|gboolean
name|save_bkgd
decl_stmt|;
name|gboolean
name|save_gama
decl_stmt|;
name|gboolean
name|save_offs
decl_stmt|;
name|gboolean
name|save_phys
decl_stmt|;
name|gboolean
name|save_time
decl_stmt|;
name|gboolean
name|save_comment
decl_stmt|;
name|gchar
modifier|*
name|comment
decl_stmt|;
name|gboolean
name|save_transp_pixels
decl_stmt|;
name|gint
name|compression_level
decl_stmt|;
name|PngExportFormat
name|export_format
decl_stmt|;
name|gboolean
name|save_exif
decl_stmt|;
name|gboolean
name|save_xmp
decl_stmt|;
name|gboolean
name|save_iptc
decl_stmt|;
name|gboolean
name|save_thumbnail
decl_stmt|;
name|gboolean
name|save_profile
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
name|g_object_set
argument_list|(
name|config
argument_list|,
literal|"save-color-profile"
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_object_get
argument_list|(
name|config
argument_list|,
literal|"interlaced"
argument_list|,
operator|&
name|save_interlaced
argument_list|,
literal|"bkgd"
argument_list|,
operator|&
name|save_bkgd
argument_list|,
literal|"gama"
argument_list|,
operator|&
name|save_gama
argument_list|,
literal|"offs"
argument_list|,
operator|&
name|save_offs
argument_list|,
literal|"phys"
argument_list|,
operator|&
name|save_phys
argument_list|,
literal|"time"
argument_list|,
operator|&
name|save_time
argument_list|,
literal|"save-comment"
argument_list|,
operator|&
name|save_comment
argument_list|,
literal|"comment"
argument_list|,
operator|&
name|comment
argument_list|,
literal|"save-transparent"
argument_list|,
operator|&
name|save_transp_pixels
argument_list|,
literal|"compression"
argument_list|,
operator|&
name|compression_level
argument_list|,
literal|"format"
argument_list|,
operator|&
name|export_format
argument_list|,
literal|"save-exif"
argument_list|,
operator|&
name|save_exif
argument_list|,
literal|"save-xmp"
argument_list|,
operator|&
name|save_xmp
argument_list|,
literal|"save-iptc"
argument_list|,
operator|&
name|save_iptc
argument_list|,
literal|"save-thumbnail"
argument_list|,
operator|&
name|save_thumbnail
argument_list|,
literal|"save-color-profile"
argument_list|,
operator|&
name|save_profile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out_linear
operator|=
name|FALSE
expr_stmt|;
name|space
operator|=
name|gimp_drawable_get_format
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
comment|/* If no profile is written: export as sRGB.    * If manually assigned profile written: follow its TRC.    * If default profile written:    *   - when export as auto or 16-bit: follow the storage TRC.    *   - when export from 8-bit storage: follow the storage TRC.    *   - when converting high bit depth to 8-bit: export as sRGB.    */
if|if
condition|(
name|save_profile
condition|)
block|{
name|profile
operator|=
name|gimp_image_get_color_profile
argument_list|(
name|orig_image
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile
operator|||
name|export_format
operator|==
name|PNG_FORMAT_AUTO
operator|||
name|export_format
operator|==
name|PNG_FORMAT_RGB16
operator|||
name|export_format
operator|==
name|PNG_FORMAT_RGBA16
operator|||
name|export_format
operator|==
name|PNG_FORMAT_GRAY16
operator|||
name|export_format
operator|==
name|PNG_FORMAT_GRAYA16
operator|||
name|gimp_image_get_precision
argument_list|(
name|image
argument_list|)
operator|==
name|GIMP_PRECISION_U8_LINEAR
operator|||
name|gimp_image_get_precision
argument_list|(
name|image
argument_list|)
operator|==
name|GIMP_PRECISION_U8_NON_LINEAR
operator|||
name|gimp_image_get_precision
argument_list|(
name|image
argument_list|)
operator|==
name|GIMP_PRECISION_U8_PERCEPTUAL
condition|)
block|{
if|if
condition|(
operator|!
name|profile
condition|)
name|profile
operator|=
name|gimp_image_get_effective_color_profile
argument_list|(
name|orig_image
argument_list|)
expr_stmt|;
name|out_linear
operator|=
operator|(
name|gimp_color_profile_is_linear
argument_list|(
name|profile
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* When converting higher bit depth work image into 8-bit,            * with no manually assigned profile, make sure the result is            * sRGB.            */
name|profile
operator|=
name|gimp_image_get_effective_color_profile
argument_list|(
name|orig_image
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_color_profile_is_linear
argument_list|(
name|profile
argument_list|)
condition|)
block|{
name|GimpColorProfile
modifier|*
name|saved_profile
decl_stmt|;
name|saved_profile
operator|=
name|gimp_color_profile_new_srgb_trc_from_color_profile
argument_list|(
name|profile
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|profile
argument_list|)
expr_stmt|;
name|profile
operator|=
name|saved_profile
expr_stmt|;
block|}
block|}
name|space
operator|=
name|gimp_color_profile_get_space
argument_list|(
name|profile
argument_list|,
name|GIMP_COLOR_RENDERING_INTENT_RELATIVE_COLORIMETRIC
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|*
name|error
condition|)
block|{
comment|/* XXX: the profile space should normally be the same one as            * the drawable's so let's continue with it. We were mostly            * getting the profile space to be complete. Still let's            * display the error to standard error channel because if the            * space could not be extracted, there is a problem somewhere!            */
name|g_printerr
argument_list|(
literal|"%s: error getting the profile space: %s"
argument_list|,
name|G_STRFUNC
argument_list|,
operator|(
operator|*
name|error
operator|)
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_clear_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|space
operator|=
name|gimp_drawable_get_format
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* We save as 8-bit PNG only if:    * (1) Work image is 8-bit linear with linear profile to be saved.    * (2) Work image is 8-bit non-linear or perceptual with or without    * profile.    */
name|bit_depth
operator|=
literal|16
expr_stmt|;
switch|switch
condition|(
name|gimp_image_get_precision
argument_list|(
name|image
argument_list|)
condition|)
block|{
case|case
name|GIMP_PRECISION_U8_LINEAR
case|:
if|if
condition|(
name|out_linear
condition|)
name|bit_depth
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|GIMP_PRECISION_U8_NON_LINEAR
case|:
case|case
name|GIMP_PRECISION_U8_PERCEPTUAL
case|:
if|if
condition|(
operator|!
name|out_linear
condition|)
name|bit_depth
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|pp
operator|=
name|png_create_write_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pp
condition|)
block|{
comment|/* this could happen if the compile time and run-time libpng        * versions do not match.        */
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error creating PNG write struct while exporting '%s'."
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error while exporting '%s'. Could not create PNG header info structure."
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|pp
argument_list|)
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error while exporting '%s'. Could not export image."
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
comment|/* Change some libpng errors to warnings (e.g. bug 721135) */
name|png_set_benign_errors
argument_list|(
name|pp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* bug 765850 */
name|png_set_option
argument_list|(
name|pp
argument_list|,
name|PNG_SKIP_sRGB_CHECK_PROFILE
argument_list|,
name|PNG_OPTION_ON
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Open the file and initialize the PNG write "engine"...    */
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Exporting '%s'"
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_file_get_utf8_name
argument_list|(
name|file
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|png_init_io
argument_list|(
name|pp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Get the buffer for the current image...    */
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|width
operator|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|height
operator|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|type
operator|=
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/*    * Initialise remap[]    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|remap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|export_format
operator|==
name|PNG_FORMAT_AUTO
condition|)
block|{
comment|/*      * Set color type and remember bytes per pixel count      */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
if|if
condition|(
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGB u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B' u8"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGB u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B' u16"
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
if|if
condition|(
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGBA u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B'A u8"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGBA u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B'A u16"
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
if|if
condition|(
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"Y u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y' u8"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"Y u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y' u16"
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
if|if
condition|(
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"YA u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y'A u8"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"YA u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y'A u16"
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|file_format
operator|=
name|gimp_drawable_get_format
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|pngg
operator|.
name|has_plte
operator|=
name|TRUE
expr_stmt|;
name|pngg
operator|.
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|gimp_image_get_colormap
argument_list|(
name|image
argument_list|,
operator|&
name|pngg
operator|.
name|num_palette
argument_list|)
expr_stmt|;
name|bit_depth
operator|=
name|get_bit_depth_for_palette
argument_list|(
name|pngg
operator|.
name|num_palette
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|file_format
operator|=
name|gimp_drawable_get_format
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* fix up transparency */
name|bit_depth
operator|=
name|respin_cmap
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|remap
argument_list|,
name|image
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Image type can't be exported as PNG"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|export_format
condition|)
block|{
case|case
name|PNG_FORMAT_RGB8
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGB u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B' u8"
expr_stmt|;
name|bit_depth
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_GRAY8
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"Y u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y' u8"
expr_stmt|;
name|bit_depth
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_RGBA8
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGBA u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B'A u8"
expr_stmt|;
name|bit_depth
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_GRAYA8
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"YA u8"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y'A u8"
expr_stmt|;
name|bit_depth
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_RGB16
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGB u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B' u16"
expr_stmt|;
name|bit_depth
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_GRAY16
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"Y u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y' u16"
expr_stmt|;
name|bit_depth
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_RGBA16
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"RGBA u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"R'G'B'A u16"
expr_stmt|;
name|bit_depth
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_GRAYA16
case|:
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
if|if
condition|(
name|out_linear
condition|)
name|encoding
operator|=
literal|"YA u16"
expr_stmt|;
else|else
name|encoding
operator|=
literal|"Y'A u16"
expr_stmt|;
name|bit_depth
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|PNG_FORMAT_AUTO
case|:
name|g_return_val_if_reached
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|file_format
condition|)
name|file_format
operator|=
name|babl_format_with_space
argument_list|(
name|encoding
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|bpp
operator|=
name|babl_format_get_bytes_per_pixel
argument_list|(
name|file_format
argument_list|)
expr_stmt|;
comment|/* Note: png_set_IHDR() must be called before any other png_set_*()      functions. */
name|png_set_IHDR
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bit_depth
argument_list|,
name|color_type
argument_list|,
name|save_interlaced
condition|?
name|PNG_INTERLACE_ADAM7
else|:
name|PNG_INTERLACE_NONE
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pngg
operator|.
name|has_trns
condition|)
name|png_set_tRNS
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|pngg
operator|.
name|trans
argument_list|,
name|pngg
operator|.
name|num_trans
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pngg
operator|.
name|has_plte
condition|)
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|pngg
operator|.
name|palette
argument_list|,
name|pngg
operator|.
name|num_palette
argument_list|)
expr_stmt|;
comment|/* Set the compression level */
name|png_set_compression_level
argument_list|(
name|pp
argument_list|,
name|compression_level
argument_list|)
expr_stmt|;
comment|/* All this stuff is optional extras, if the user is aiming for smallest      possible file size she can turn them all off */
if|if
condition|(
name|save_bkgd
condition|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|gimp_context_get_background
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|background
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|background
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|background
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|background
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|background
operator|.
name|gray
operator|=
name|gimp_rgb_luminance_uchar
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|png_set_bKGD
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|background
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|save_gama
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gdouble
name|gamma
init|=
literal|1.0
operator|/
name|DEFAULT_GAMMA
decl_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|orig_image
argument_list|,
literal|"gamma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|gamma
operator|=
name|g_ascii_strtod
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|png_set_gAMA
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|save_offs
condition|)
block|{
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|offx
argument_list|,
operator|&
name|offy
argument_list|)
expr_stmt|;
if|if
condition|(
name|offx
operator|!=
literal|0
operator|||
name|offy
operator|!=
literal|0
condition|)
name|png_set_oFFs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|,
name|PNG_OFFSET_PIXEL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|save_phys
condition|)
block|{
name|gimp_image_get_resolution
argument_list|(
name|orig_image
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
name|png_set_pHYs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|RINT
argument_list|(
name|xres
operator|/
literal|0.0254
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|yres
operator|/
literal|0.0254
argument_list|)
argument_list|,
name|PNG_RESOLUTION_METER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|save_time
condition|)
block|{
name|cutime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* time right NOW */
name|gmt
operator|=
name|gmtime
argument_list|(
operator|&
name|cutime
argument_list|)
expr_stmt|;
name|mod_time
operator|.
name|year
operator|=
name|gmt
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|mod_time
operator|.
name|month
operator|=
name|gmt
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|mod_time
operator|.
name|day
operator|=
name|gmt
operator|->
name|tm_mday
expr_stmt|;
name|mod_time
operator|.
name|hour
operator|=
name|gmt
operator|->
name|tm_hour
expr_stmt|;
name|mod_time
operator|.
name|minute
operator|=
name|gmt
operator|->
name|tm_min
expr_stmt|;
name|mod_time
operator|.
name|second
operator|=
name|gmt
operator|->
name|tm_sec
expr_stmt|;
name|png_set_tIME
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|mod_time
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
if|if
condition|(
name|save_profile
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gchar
modifier|*
name|profile_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|guint8
modifier|*
name|icc_data
decl_stmt|;
name|gsize
name|icc_length
decl_stmt|;
name|icc_data
operator|=
name|gimp_color_profile_get_icc_profile
argument_list|(
name|profile
argument_list|,
operator|&
name|icc_length
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|orig_image
argument_list|,
literal|"icc-profile-name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
name|profile_name
operator|=
name|g_convert
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|,
literal|"ISO-8859-1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_set_iCCP
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|profile_name
condition|?
name|profile_name
else|:
literal|"ICC profile"
argument_list|,
literal|0
argument_list|,
name|icc_data
argument_list|,
name|icc_length
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|profile_name
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|profile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_zTXt_SUPPORTED
comment|/* Small texts are not worth compressing and will be even bigger if compressed.    Empirical length limit of a text being worth compressing. */
DECL|macro|COMPRESSION_WORTHY_LENGTH
define|#
directive|define
name|COMPRESSION_WORTHY_LENGTH
value|200
endif|#
directive|endif
if|if
condition|(
name|save_comment
operator|&&
name|comment
operator|&&
name|strlen
argument_list|(
name|comment
argument_list|)
condition|)
block|{
name|gsize
name|text_length
init|=
literal|0
decl_stmt|;
name|text
operator|=
name|g_new0
argument_list|(
name|png_text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|text
index|[
literal|0
index|]
operator|.
name|key
operator|=
literal|"Comment"
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
name|text
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|g_convert
argument_list|(
name|comment
argument_list|,
operator|-
literal|1
argument_list|,
literal|"ISO-8859-1"
argument_list|,
literal|"UTF-8"
argument_list|,
name|NULL
argument_list|,
operator|&
name|text_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|.
name|text
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We can't convert to ISO-8859-1 without loss.            * Save the comment as iTXt (UTF-8).            */
name|g_free
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|text
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|g_strdup
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|text
index|[
literal|0
index|]
operator|.
name|itxt_length
operator|=
name|strlen
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_zTXt_SUPPORTED
name|text
index|[
literal|0
index|]
operator|.
name|compression
operator|=
name|strlen
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
operator|>
name|COMPRESSION_WORTHY_LENGTH
condition|?
name|PNG_ITXT_COMPRESSION_zTXt
else|:
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
else|#
directive|else
name|text
index|[
literal|0
index|]
operator|.
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_zTXt_SUPPORTED */
block|}
else|else
comment|/* The comment is ISO-8859-1 compatible, so we use tEXt even          * if there is iTXt support for compatibility to more png          * reading programs.          */
endif|#
directive|endif
comment|/* PNG_iTXt_SUPPORTED */
block|{
ifndef|#
directive|ifndef
name|PNG_iTXt_SUPPORTED
comment|/* No iTXt support, so we are forced to use tEXt            * (ISO-8859-1).  A broken comment is better than no comment            * at all, so the conversion does not fail on unknown            * character.  They are simply ignored.            */
name|text
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|g_convert_with_fallback
argument_list|(
name|comment
argument_list|,
operator|-
literal|1
argument_list|,
literal|"ISO-8859-1"
argument_list|,
literal|"UTF-8"
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
operator|&
name|text_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_zTXt_SUPPORTED
name|text
index|[
literal|0
index|]
operator|.
name|compression
operator|=
name|strlen
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
operator|>
name|COMPRESSION_WORTHY_LENGTH
condition|?
name|PNG_TEXT_COMPRESSION_zTXt
else|:
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
else|#
directive|else
name|text
index|[
literal|0
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_zTXt_SUPPORTED */
name|text
index|[
literal|0
index|]
operator|.
name|text_length
operator|=
name|text_length
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|text
index|[
literal|0
index|]
operator|.
name|text
operator|||
name|strlen
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_zTXt_SUPPORTED
undef|#
directive|undef
name|COMPRESSION_WORTHY_LENGTH
endif|#
directive|endif
if|if
condition|(
name|text
condition|)
name|png_set_text
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_write_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_BYTE_ORDER
operator|==
name|G_LITTLE_ENDIAN
condition|)
name|png_set_swap
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Turn on interlace handling...    */
if|if
condition|(
name|save_interlaced
condition|)
name|num_passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|num_passes
operator|=
literal|1
expr_stmt|;
comment|/*    * Convert unpacked pixels to packed if necessary    */
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|bit_depth
operator|<
literal|8
condition|)
name|png_set_packing
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Allocate memory for "tile_height" rows and export the image...    */
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pixel
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|width
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|tile_height
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixel
operator|+
name|width
operator|*
name|bpp
operator|*
name|i
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_passes
condition|;
name|pass
operator|++
control|)
block|{
comment|/* This works if you are only writing one row at a time... */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|height
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|height
condition|)
name|end
operator|=
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|begin
argument_list|,
name|width
argument_list|,
name|num
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|file_format
argument_list|,
name|pixel
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
comment|/* If we are with a RGBA image and have to pre-multiply the              alpha channel */
if|if
condition|(
name|bpp
operator|==
literal|4
operator|&&
operator|!
name|save_transp_pixels
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
operator|!
name|fixed
index|[
literal|3
index|]
condition|)
name|fixed
index|[
literal|0
index|]
operator|=
name|fixed
index|[
literal|1
index|]
operator|=
name|fixed
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fixed
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bpp
operator|==
literal|8
operator|&&
operator|!
name|save_transp_pixels
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
operator|!
name|fixed
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed
index|[
literal|7
index|]
condition|)
name|fixed
index|[
literal|0
index|]
operator|=
name|fixed
index|[
literal|1
index|]
operator|=
name|fixed
index|[
literal|2
index|]
operator|=
name|fixed
index|[
literal|3
index|]
operator|=
name|fixed
index|[
literal|4
index|]
operator|=
name|fixed
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|fixed
operator|+=
name|bpp
expr_stmt|;
block|}
block|}
block|}
comment|/* If we're dealing with a paletted image with            * transparency set, write out the remapped palette */
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
block|{
name|guchar
name|inverse_remap
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|inverse_remap
index|[
name|remap
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
operator|++
name|k
control|)
block|{
name|fixed
index|[
name|k
index|]
operator|=
operator|(
name|fixed
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|>
literal|127
operator|)
condition|?
name|inverse_remap
index|[
name|fixed
index|[
name|k
operator|*
literal|2
index|]
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise if we have a paletted image and transparency            * couldn't be set, we ignore the alpha channel */
elseif|else
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_PLTE
argument_list|)
operator|&&
name|bpp
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
operator|++
name|k
control|)
block|{
name|fixed
index|[
name|k
index|]
operator|=
name|fixed
index|[
name|k
operator|*
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
name|png_write_rows
argument_list|(
name|pp
argument_list|,
name|pixels
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
operator|(
name|double
operator|)
name|pass
operator|+
operator|(
name|double
operator|)
name|end
operator|/
operator|(
name|double
operator|)
name|height
operator|)
operator|/
operator|(
name|double
operator|)
name|num_passes
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|png_write_end
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|png_destroy_write_struct
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
comment|/*    * Done with the file...    */
if|if
condition|(
name|text
condition|)
block|{
name|g_free
argument_list|(
name|text
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
name|bits_per_sample
operator|=
name|bit_depth
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|ia_has_transparent_pixels (GeglBuffer * buffer)
name|ia_has_transparent_pixels
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|GeglBufferIterator
modifier|*
name|iter
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
name|gint
name|n_components
decl_stmt|;
name|format
operator|=
name|gegl_buffer_get_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|iter
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n_components
operator|=
name|babl_format_get_n_components
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_components
operator|==
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|iter
argument_list|)
condition|)
block|{
specifier|const
name|guchar
modifier|*
name|data
init|=
name|iter
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|length
init|=
name|iter
operator|->
name|length
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|<=
literal|127
condition|)
block|{
name|gegl_buffer_iterator_stop
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|data
operator|+=
name|n_components
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Try to find a color in the palette which isn't actually used in the  * image, so that we can use it as the transparency index. Taken from  * gif.c  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|find_unused_ia_color (GeglBuffer * buffer,gint * colors)
name|find_unused_ia_color
parameter_list|(
name|GeglBuffer
modifier|*
name|buffer
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
block|{
name|GeglBufferIterator
modifier|*
name|iter
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
name|gint
name|n_components
decl_stmt|;
name|gboolean
name|ix_used
index|[
literal|256
index|]
decl_stmt|;
name|gboolean
name|trans_used
init|=
name|FALSE
decl_stmt|;
name|gint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|colors
condition|;
name|i
operator|++
control|)
name|ix_used
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|format
operator|=
name|gegl_buffer_get_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|iter
operator|=
name|gegl_buffer_iterator_new
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|GEGL_ACCESS_READ
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n_components
operator|=
name|babl_format_get_n_components
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|n_components
operator|==
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|gegl_buffer_iterator_next
argument_list|(
name|iter
argument_list|)
condition|)
block|{
specifier|const
name|guchar
modifier|*
name|data
init|=
name|iter
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|data
decl_stmt|;
name|gint
name|length
init|=
name|iter
operator|->
name|length
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|>
literal|127
condition|)
name|ix_used
index|[
name|data
index|[
literal|0
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
else|else
name|trans_used
operator|=
name|TRUE
expr_stmt|;
name|data
operator|+=
name|n_components
expr_stmt|;
block|}
block|}
comment|/* If there is no transparency, ignore alpha. */
if|if
condition|(
name|trans_used
operator|==
name|FALSE
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If there is still some room at the end of the palette, increment    * the number of colors in the image and assign a transparent pixel    * there.    */
if|if
condition|(
operator|(
operator|*
name|colors
operator|)
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|colors
operator|)
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|colors
operator|)
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|colors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ix_used
index|[
name|i
index|]
operator|==
name|FALSE
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|respin_cmap (png_structp pp,png_infop info,guchar * remap,GimpImage * image,GimpDrawable * drawable)
name|respin_cmap
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|guchar
modifier|*
name|remap
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
specifier|static
name|guchar
name|trans
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|gint
name|colors
decl_stmt|;
name|guchar
modifier|*
name|before
decl_stmt|;
name|before
operator|=
name|gimp_image_get_colormap
argument_list|(
name|image
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* Make sure there is something in the colormap.    */
if|if
condition|(
name|colors
operator|==
literal|0
condition|)
block|{
name|before
operator|=
name|g_newa
argument_list|(
name|guchar
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|before
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|colors
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Try to find an entry which isn't actually used in the image, for    * a transparency index.    */
if|if
condition|(
name|ia_has_transparent_pixels
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|gint
name|transparent
init|=
name|find_unused_ia_color
argument_list|(
name|buffer
argument_list|,
operator|&
name|colors
argument_list|)
decl_stmt|;
if|if
condition|(
name|transparent
operator|!=
operator|-
literal|1
condition|)
comment|/* we have a winner for a transparent                                      * index - do like gif2png and swap                                      * index 0 and index transparent                                      */
block|{
specifier|static
name|png_color
name|palette
index|[
literal|256
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
comment|/* Set tRNS chunk values for writing later. */
name|pngg
operator|.
name|has_trns
operator|=
name|TRUE
expr_stmt|;
name|pngg
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|pngg
operator|.
name|num_trans
operator|=
literal|1
expr_stmt|;
comment|/* Transform all pixels with a value = transparent to 0 and            * vice versa to compensate for re-ordering in palette due            * to png_set_tRNS()            */
name|remap
index|[
literal|0
index|]
operator|=
name|transparent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|transparent
condition|;
name|i
operator|++
control|)
name|remap
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* Copy from index 0 to index transparent - 1 to index 1 to            * transparent of after, then from transparent+1 to colors-1            * unchanged, and finally from index transparent to index 0.            */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
operator|+
literal|1
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
operator|+
literal|2
index|]
expr_stmt|;
block|}
comment|/* Set PLTE chunk values for writing later. */
name|pngg
operator|.
name|has_plte
operator|=
name|TRUE
expr_stmt|;
name|pngg
operator|.
name|palette
operator|=
name|palette
expr_stmt|;
name|pngg
operator|.
name|num_palette
operator|=
name|colors
expr_stmt|;
block|}
else|else
block|{
comment|/* Inform the user that we couldn't losslessly save the            * transparency& just use the full palette            */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Couldn't losslessly save transparency, "
literal|"saving opacity instead."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set PLTE chunk values for writing later. */
name|pngg
operator|.
name|has_plte
operator|=
name|TRUE
expr_stmt|;
name|pngg
operator|.
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|before
expr_stmt|;
name|pngg
operator|.
name|num_palette
operator|=
name|colors
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Set PLTE chunk values for writing later. */
name|pngg
operator|.
name|has_plte
operator|=
name|TRUE
expr_stmt|;
name|pngg
operator|.
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|before
expr_stmt|;
name|pngg
operator|.
name|num_palette
operator|=
name|colors
expr_stmt|;
block|}
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|get_bit_depth_for_palette
argument_list|(
name|colors
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (GimpImage * image,GimpProcedure * procedure,GObject * config,gboolean alpha)
name|save_dialog
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GObject
modifier|*
name|config
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|main_vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|grid
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|GtkListStore
modifier|*
name|store
decl_stmt|;
name|GtkWidget
modifier|*
name|combo
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|gint
name|col
decl_stmt|;
name|gint
name|row
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|dialog
operator|=
name|gimp_procedure_dialog_new
argument_list|(
name|procedure
argument_list|,
name|GIMP_PROCEDURE_CONFIG
argument_list|(
name|config
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Export Image as PNG"
argument_list|)
argument_list|)
expr_stmt|;
name|main_vbox
operator|=
name|gtk_box_new
argument_list|(
name|GTK_ORIENTATION_VERTICAL
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|main_vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|main_vbox
argument_list|)
expr_stmt|;
name|grid
operator|=
name|gtk_grid_new
argument_list|()
expr_stmt|;
name|gtk_grid_set_column_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_grid_set_row_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|grid
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|grid
argument_list|)
expr_stmt|;
comment|/* Toggles */
name|col
operator|=
literal|0
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"interlaced"
argument_list|,
name|_
argument_list|(
literal|"_Interlacing (Adam7)"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"bkgd"
argument_list|,
name|_
argument_list|(
literal|"Save _background color"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"gama"
argument_list|,
name|_
argument_list|(
literal|"Save _gamma"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"offs"
argument_list|,
name|_
argument_list|(
literal|"Save layer o_ffset"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"phys"
argument_list|,
name|_
argument_list|(
literal|"Save _resolution"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"time"
argument_list|,
name|_
argument_list|(
literal|"Save creation _time"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-transparent"
argument_list|,
name|_
argument_list|(
literal|"Save color _values from "
literal|"transparent pixels"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|button
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-comment"
argument_list|,
name|_
argument_list|(
literal|"Save comme_nt"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|image
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|button
argument_list|,
name|parasite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-exif"
argument_list|,
name|_
argument_list|(
literal|"Save E_xif data"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-xmp"
argument_list|,
name|_
argument_list|(
literal|"Save XMP data"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-iptc"
argument_list|,
name|_
argument_list|(
literal|"Save IPTC data"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-thumbnail"
argument_list|,
name|_
argument_list|(
literal|"Save thumbnail"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|button
operator|=
name|gimp_prop_check_button_new
argument_list|(
name|config
argument_list|,
literal|"save-color-profile"
argument_list|,
name|_
argument_list|(
literal|"Save color profile"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|button
argument_list|,
name|col
argument_list|,
name|row
operator|++
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
name|gtk_widget_hide
argument_list|(
name|button
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|grid
operator|=
name|gtk_grid_new
argument_list|()
expr_stmt|;
name|gtk_grid_set_column_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_grid_set_row_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|grid
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|grid
argument_list|)
expr_stmt|;
comment|/* Pixel format combo */
name|store
operator|=
name|gimp_int_store_new
argument_list|(
name|_
argument_list|(
literal|"Automatic"
argument_list|)
argument_list|,
name|PNG_FORMAT_AUTO
argument_list|,
name|_
argument_list|(
literal|"8 bpc RGB"
argument_list|)
argument_list|,
name|PNG_FORMAT_RGB8
argument_list|,
name|_
argument_list|(
literal|"8 bpc GRAY"
argument_list|)
argument_list|,
name|PNG_FORMAT_GRAY8
argument_list|,
name|_
argument_list|(
literal|"8 bpc RGBA"
argument_list|)
argument_list|,
name|PNG_FORMAT_RGBA8
argument_list|,
name|_
argument_list|(
literal|"8 bpc GRAYA"
argument_list|)
argument_list|,
name|PNG_FORMAT_GRAYA8
argument_list|,
name|_
argument_list|(
literal|"16 bpc RGB"
argument_list|)
argument_list|,
name|PNG_FORMAT_RGB16
argument_list|,
name|_
argument_list|(
literal|"16 bpc GRAY"
argument_list|)
argument_list|,
name|PNG_FORMAT_GRAY16
argument_list|,
name|_
argument_list|(
literal|"16 bpc RGBA"
argument_list|)
argument_list|,
name|PNG_FORMAT_RGBA16
argument_list|,
name|_
argument_list|(
literal|"16 bpc GRAYA"
argument_list|)
argument_list|,
name|PNG_FORMAT_GRAYA16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|combo
operator|=
name|gimp_prop_int_combo_box_new
argument_list|(
name|config
argument_list|,
literal|"format"
argument_list|,
name|GIMP_INT_STORE
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"_Pixel format:"
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|,
name|combo
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Compression level scale */
name|gimp_prop_scale_entry_new
argument_list|(
name|config
argument_list|,
literal|"compression"
argument_list|,
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"Co_mpression level:"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
name|gimp_procedure_dialog_run
argument_list|(
name|GIMP_PROCEDURE_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

end_unit

