begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/*  Mosaic is a filter which transforms an image into  *  what appears to be a mosaic, composed of small primitives,  *  each of constant color and of an approximate size.  *        Copyright (C) 1996  Spencer Kimball  *        Speedups by Elliot Lee  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|PLUG_IN_PROC
define|#
directive|define
name|PLUG_IN_PROC
value|"plug-in-mosaic"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"mosaic"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|150
end_define

begin_define
DECL|macro|HORIZONTAL
define|#
directive|define
name|HORIZONTAL
value|0
end_define

begin_define
DECL|macro|VERTICAL
define|#
directive|define
name|VERTICAL
value|1
end_define

begin_define
DECL|macro|SUPERSAMPLE
define|#
directive|define
name|SUPERSAMPLE
value|3
end_define

begin_define
DECL|macro|MAG_THRESHOLD
define|#
directive|define
name|MAG_THRESHOLD
value|7.5
end_define

begin_define
DECL|macro|COUNT_THRESHOLD
define|#
directive|define
name|COUNT_THRESHOLD
value|0.1
end_define

begin_define
DECL|macro|MAX_POINTS
define|#
directive|define
name|MAX_POINTS
value|12
end_define

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon27d5b4650103
block|{
DECL|enumerator|SQUARES
name|SQUARES
init|=
literal|0
block|,
DECL|enumerator|HEXAGONS
name|HEXAGONS
init|=
literal|1
block|,
DECL|enumerator|OCTAGONS
name|OCTAGONS
init|=
literal|2
block|,
DECL|enumerator|TRIANGLES
name|TRIANGLES
init|=
literal|3
DECL|typedef|TileType
block|}
name|TileType
typedef|;
end_typedef

begin_define
DECL|macro|SMOOTH
define|#
directive|define
name|SMOOTH
value|0
end_define

begin_define
DECL|macro|ROUGH
define|#
directive|define
name|ROUGH
value|1
end_define

begin_define
DECL|macro|BW
define|#
directive|define
name|BW
value|0
end_define

begin_define
DECL|macro|FG_BG
define|#
directive|define
name|FG_BG
value|1
end_define

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27d5b4650208
block|{
DECL|member|x
DECL|member|y
name|gdouble
name|x
decl_stmt|,
name|y
decl_stmt|;
DECL|typedef|Vertex
block|}
name|Vertex
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27d5b4650308
block|{
DECL|member|npts
name|guint
name|npts
decl_stmt|;
DECL|member|pts
name|Vertex
name|pts
index|[
name|MAX_POINTS
index|]
decl_stmt|;
DECL|typedef|Polygon
block|}
name|Polygon
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27d5b4650408
block|{
DECL|member|base_x
DECL|member|base_y
name|gdouble
name|base_x
decl_stmt|,
name|base_y
decl_stmt|;
DECL|member|norm_x
DECL|member|norm_y
name|gdouble
name|norm_x
decl_stmt|,
name|norm_y
decl_stmt|;
DECL|member|light
name|gdouble
name|light
decl_stmt|;
DECL|typedef|SpecVec
block|}
name|SpecVec
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27d5b4650508
block|{
DECL|member|tile_size
name|gdouble
name|tile_size
decl_stmt|;
DECL|member|tile_height
name|gdouble
name|tile_height
decl_stmt|;
DECL|member|tile_spacing
name|gdouble
name|tile_spacing
decl_stmt|;
DECL|member|tile_neatness
name|gdouble
name|tile_neatness
decl_stmt|;
DECL|member|tile_allow_split
name|gboolean
name|tile_allow_split
decl_stmt|;
DECL|member|light_dir
name|gdouble
name|light_dir
decl_stmt|;
DECL|member|color_variation
name|gdouble
name|color_variation
decl_stmt|;
DECL|member|antialiasing
name|gboolean
name|antialiasing
decl_stmt|;
DECL|member|color_averaging
name|gint
name|color_averaging
decl_stmt|;
DECL|member|tile_type
name|TileType
name|tile_type
decl_stmt|;
DECL|member|tile_surface
name|gint
name|tile_surface
decl_stmt|;
DECL|member|grout_color
name|gint
name|grout_color
decl_stmt|;
DECL|typedef|MosaicVals
block|}
name|MosaicVals
typedef|;
end_typedef

begin_comment
comment|/* Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mosaic
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  user interface functions  */
end_comment

begin_function_decl
specifier|static
name|gboolean
name|mosaic_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  gradient finding machinery  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_gradients
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gdouble
name|std_dev
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_max_gradient
parameter_list|(
name|GimpPixelRgn
modifier|*
name|src_rgn
parameter_list|,
name|GimpPixelRgn
modifier|*
name|dest_rgn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  gaussian& 1st derivative  */
end_comment

begin_function_decl
specifier|static
name|void
name|gaussian_deriv
parameter_list|(
name|GimpPixelRgn
modifier|*
name|src_rgn
parameter_list|,
name|GimpPixelRgn
modifier|*
name|dest_rgn
parameter_list|,
name|gint
name|direction
parameter_list|,
name|gdouble
name|std_dev
parameter_list|,
name|gint
modifier|*
name|prog
parameter_list|,
name|gint
name|max_prog
parameter_list|,
name|gint
name|ith_prog
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_curve
parameter_list|(
name|gint
modifier|*
name|curve
parameter_list|,
name|gint
modifier|*
name|sum
parameter_list|,
name|gdouble
name|std_dev
parameter_list|,
name|gint
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_curve_d
parameter_list|(
name|gint
modifier|*
name|curve
parameter_list|,
name|gint
modifier|*
name|sum
parameter_list|,
name|gdouble
name|std_dev
parameter_list|,
name|gint
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  grid creation and localization machinery  */
end_comment

begin_function_decl
specifier|static
name|gdouble
name|fp_rand
parameter_list|(
name|gdouble
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grid_create_squares
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grid_create_hexagons
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grid_create_octagons
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grid_create_triangles
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grid_localize
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grid_render
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|split_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
name|color_vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clip_poly
parameter_list|(
name|gdouble
modifier|*
name|vec
parameter_list|,
name|gdouble
modifier|*
name|pt
parameter_list|,
name|Polygon
modifier|*
name|poly
parameter_list|,
name|Polygon
modifier|*
name|new_poly
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clip_point
parameter_list|(
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
modifier|*
name|pt
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|Polygon
modifier|*
name|poly
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gboolean
name|allow_split
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gboolean
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|render_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gdouble
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_poly_dir
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|guchar
modifier|*
name|m_gr
parameter_list|,
name|guchar
modifier|*
name|h_gr
parameter_list|,
name|guchar
modifier|*
name|v_gr
parameter_list|,
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
modifier|*
name|loc
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_poly_color
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|double
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scale_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|cx
parameter_list|,
name|gdouble
name|cy
parameter_list|,
name|gdouble
name|scale
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_poly_color
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_poly_image
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gdouble
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_spec_vec
parameter_list|(
name|SpecVec
modifier|*
name|vec
parameter_list|,
name|gint
name|xs
parameter_list|,
name|gint
name|ys
parameter_list|,
name|gint
name|xe
parameter_list|,
name|gint
name|ye
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
name|calc_spec_contrib
parameter_list|(
name|SpecVec
modifier|*
name|vec
parameter_list|,
name|gint
name|n
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_segment
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|offset
parameter_list|,
name|gint
modifier|*
name|min
parameter_list|,
name|gint
modifier|*
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|polygon_add_point
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|polygon_find_center
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
modifier|*
name|x
parameter_list|,
name|gdouble
modifier|*
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|polygon_translate
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|tx
parameter_list|,
name|gdouble
name|ty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|polygon_scale
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|scale
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|polygon_extents
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
modifier|*
name|min_x
parameter_list|,
name|gdouble
modifier|*
name|min_y
parameter_list|,
name|gdouble
modifier|*
name|max_x
parameter_list|,
name|gdouble
modifier|*
name|max_y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|polygon_reset
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Some static variables  */
end_comment

begin_decl_stmt
DECL|variable|std_dev
specifier|static
name|gdouble
name|std_dev
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|light_x
specifier|static
name|gdouble
name|light_x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|light_y
specifier|static
name|gdouble
name|light_y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|scale
specifier|static
name|gdouble
name|scale
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|h_grad
specifier|static
name|guchar
modifier|*
name|h_grad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|v_grad
specifier|static
name|guchar
modifier|*
name|v_grad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|m_grad
specifier|static
name|guchar
modifier|*
name|m_grad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid
specifier|static
name|Vertex
modifier|*
name|grid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_rows
specifier|static
name|gint
name|grid_rows
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_cols
specifier|static
name|gint
name|grid_cols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_row_pad
specifier|static
name|gint
name|grid_row_pad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_col_pad
specifier|static
name|gint
name|grid_col_pad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_multiple
specifier|static
name|gint
name|grid_multiple
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_rowstride
specifier|static
name|gint
name|grid_rowstride
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|back
specifier|static
name|guchar
name|back
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|fore
specifier|static
name|guchar
name|fore
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vecs
specifier|static
name|SpecVec
name|vecs
index|[
name|MAX_POINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|mvals
specifier|static
name|MosaicVals
name|mvals
init|=
block|{
literal|15.0
block|,
comment|/* tile_size */
literal|4.0
block|,
comment|/* tile_height */
literal|1.0
block|,
comment|/* tile_spacing */
literal|0.65
block|,
comment|/* tile_neatness */
name|TRUE
block|,
comment|/* tile_allow_split */
literal|135
block|,
comment|/* light_dir */
literal|0.2
block|,
comment|/* color_variation */
name|TRUE
block|,
comment|/* antialiasing */
literal|1
block|,
comment|/* color_averaging  */
name|HEXAGONS
block|,
comment|/* tile_type */
name|SMOOTH
block|,
comment|/* tile_surface */
name|BW
comment|/* grout_color */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Input drawable"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"tile-size"
block|,
literal|"Average diameter of each tile (in pixels)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"tile-height"
block|,
literal|"Apparent height of each tile (in pixels)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"tile-spacing"
block|,
literal|"Inter-tile spacing (in pixels)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"tile-neatness"
block|,
literal|"Deviation from perfectly formed tiles (0.0 - 1.0)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tile-allow-split"
block|,
literal|"Allows splitting tiles at hard edges"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"light-dir"
block|,
literal|"Direction of light-source (in degrees)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"color-variation"
block|,
literal|"Magnitude of random color variations (0.0 - 1.0)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"antialiasing"
block|,
literal|"Enables smoother tile output at the cost of speed"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"color-averaging"
block|,
literal|"Tile color based on average of subsumed pixels"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tile-type"
block|,
literal|"Tile geometry { SQUARES (0), HEXAGONS (1), OCTAGONS (2), TRIANGLES (3) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"tile-surface"
block|,
literal|"Surface characteristics { SMOOTH (0), ROUGH (1) }"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"grout-color"
block|,
literal|"Grout color (black/white or fore/background) { BW (0), FG-BG (1) }"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|PLUG_IN_PROC
argument_list|,
name|N_
argument_list|(
literal|"Convert the image into irregular tiles"
argument_list|)
argument_list|,
literal|"Help not yet written for this plug-in"
argument_list|,
literal|"Spencer Kimball"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1996"
argument_list|,
name|N_
argument_list|(
literal|"_Mosaic..."
argument_list|)
argument_list|,
literal|"RGB*, GRAY*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_plugin_menu_register
argument_list|(
name|PLUG_IN_PROC
argument_list|,
literal|"<Image>/Filters/Distorts"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
comment|/*  Get the active drawable  */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
expr_stmt|;
comment|/*  set the tile cache size so that the gaussian blur works well  */
name|gimp_tile_cache_ntiles
argument_list|(
literal|2
operator|*
operator|(
name|MAX
argument_list|(
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
operator|/
name|gimp_tile_width
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|mvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|mosaic_dialog
argument_list|(
name|drawable
argument_list|)
condition|)
return|return;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|15
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
break|break;
block|}
name|mvals
operator|.
name|tile_size
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|mvals
operator|.
name|tile_height
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|mvals
operator|.
name|tile_spacing
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|mvals
operator|.
name|tile_neatness
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|mvals
operator|.
name|tile_allow_split
operator|=
operator|(
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|mvals
operator|.
name|light_dir
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|mvals
operator|.
name|color_variation
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|mvals
operator|.
name|antialiasing
operator|=
operator|(
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|mvals
operator|.
name|color_averaging
operator|=
operator|(
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|mvals
operator|.
name|tile_type
operator|=
name|param
index|[
literal|12
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|mvals
operator|.
name|tile_surface
operator|=
name|param
index|[
literal|13
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|mvals
operator|.
name|grout_color
operator|=
name|param
index|[
literal|14
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|mvals
operator|.
name|tile_type
operator|<
name|SQUARES
operator|||
name|mvals
operator|.
name|tile_type
operator|>
name|TRIANGLES
operator|||
name|mvals
operator|.
name|tile_surface
operator|<
name|SMOOTH
operator|||
name|mvals
operator|.
name|tile_surface
operator|>
name|ROUGH
operator|||
name|mvals
operator|.
name|grout_color
operator|<
name|BW
operator|||
name|mvals
operator|.
name|grout_color
operator|>
name|FG_BG
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|mvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  Create the mosaic  */
if|if
condition|(
operator|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
operator|)
operator|&&
operator|(
name|gimp_drawable_is_rgb
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
operator|||
name|gimp_drawable_is_gray
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
operator|)
condition|)
block|{
comment|/*  run the effect  */
name|mosaic
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  If the run mode is interactive, flush the displays  */
if|if
condition|(
name|run_mode
operator|!=
name|GIMP_RUN_NONINTERACTIVE
condition|)
name|gimp_displays_flush
argument_list|()
expr_stmt|;
comment|/*  Store mvals data  */
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|mvals
argument_list|,
sizeof|sizeof
argument_list|(
name|MosaicVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
comment|/* gimp_message ("mosaic: cannot operate on indexed color images"); */
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|mosaic (GimpDrawable * drawable,GimpPreview * preview)
name|mosaic
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
comment|/*  Find the mask bounds  */
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_preview_get_position
argument_list|(
name|preview
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
expr_stmt|;
name|gimp_preview_get_size
argument_list|(
name|preview
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
name|width
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
name|height
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|gimp_drawable_mask_intersect
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
condition|)
return|return;
name|x2
operator|=
name|x1
operator|+
name|width
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
name|height
expr_stmt|;
comment|/*  progress bar for gradient finding  */
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Finding edges"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  Find the gradients  */
name|find_gradients
argument_list|(
name|drawable
argument_list|,
name|std_dev
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|preview
argument_list|)
expr_stmt|;
comment|/*  Create the tile geometry grid  */
switch|switch
condition|(
name|mvals
operator|.
name|tile_type
condition|)
block|{
case|case
name|SQUARES
case|:
name|grid_create_squares
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEXAGONS
case|:
name|grid_create_hexagons
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCTAGONS
case|:
name|grid_create_octagons
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRIANGLES
case|:
name|grid_create_triangles
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/*  Deform the tiles based on image content  */
name|grid_localize
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mvals
operator|.
name|grout_color
condition|)
block|{
case|case
name|BW
case|:
name|fore
index|[
literal|0
index|]
operator|=
name|fore
index|[
literal|1
index|]
operator|=
name|fore
index|[
literal|2
index|]
operator|=
literal|255
expr_stmt|;
name|back
index|[
literal|0
index|]
operator|=
name|back
index|[
literal|1
index|]
operator|=
name|back
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FG_BG
case|:
name|gimp_context_get_foreground
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_drawable_get_color_uchar
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|color
argument_list|,
name|fore
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_drawable_get_color_uchar
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|color
argument_list|,
name|back
argument_list|)
expr_stmt|;
break|break;
block|}
name|alpha
operator|=
name|drawable
operator|->
name|bpp
operator|-
literal|1
expr_stmt|;
name|light_x
operator|=
operator|-
name|cos
argument_list|(
name|mvals
operator|.
name|light_dir
operator|*
name|G_PI
operator|/
literal|180.0
argument_list|)
expr_stmt|;
name|light_y
operator|=
name|sin
argument_list|(
name|mvals
operator|.
name|light_dir
operator|*
name|G_PI
operator|/
literal|180.0
argument_list|)
expr_stmt|;
name|scale
operator|=
operator|(
name|mvals
operator|.
name|tile_spacing
operator|>
name|mvals
operator|.
name|tile_size
operator|/
literal|2.0
operator|)
condition|?
literal|0.5
else|:
literal|1.0
operator|-
name|mvals
operator|.
name|tile_spacing
operator|/
name|mvals
operator|.
name|tile_size
expr_stmt|;
if|if
condition|(
operator|!
name|preview
condition|)
block|{
comment|/*  Progress bar for rendering tiles  */
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Rendering tiles"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  Render the tiles  */
name|grid_render
argument_list|(
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|preview
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preview
condition|)
block|{
comment|/*  merge the shadow, update the drawable  */
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|mosaic_dialog (GimpDrawable * drawable)
name|mosaic_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|main_vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|combo
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkObject
modifier|*
name|scale_data
decl_stmt|;
name|gint
name|row
init|=
literal|0
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Mosaic"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|PLUG_IN_PROC
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|main_vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|main_vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|main_vbox
argument_list|)
expr_stmt|;
comment|/* A preview */
name|preview
operator|=
name|gimp_drawable_preview_new
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|preview
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|preview
argument_list|,
literal|"invalidated"
argument_list|,
name|G_CALLBACK
argument_list|(
name|mosaic
argument_list|)
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
comment|/*  The hbox -- splits the scripts and the info vbox  */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|7
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|table
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|combo
operator|=
name|gimp_int_combo_box_new
argument_list|(
name|_
argument_list|(
literal|"Squares"
argument_list|)
argument_list|,
name|SQUARES
argument_list|,
name|_
argument_list|(
literal|"Hexagons"
argument_list|)
argument_list|,
name|HEXAGONS
argument_list|,
name|_
argument_list|(
literal|"Octagons& squares"
argument_list|)
argument_list|,
name|OCTAGONS
argument_list|,
name|_
argument_list|(
literal|"Triangles"
argument_list|)
argument_list|,
name|TRIANGLES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_int_combo_box_connect
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|,
name|mvals
operator|.
name|tile_type
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_combo_box_get_active
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_type
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"_Tiling primitives:"
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|,
name|combo
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|combo
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"Tile _size:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|5
argument_list|,
name|mvals
operator|.
name|tile_size
argument_list|,
literal|5.0
argument_list|,
literal|100.0
argument_list|,
literal|1.0
argument_list|,
literal|10.0
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_size
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"Tile _height:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|5
argument_list|,
name|mvals
operator|.
name|tile_height
argument_list|,
literal|1.0
argument_list|,
literal|50.0
argument_list|,
literal|1.0
argument_list|,
literal|10.0
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_height
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"Til_e spacing:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|5
argument_list|,
name|mvals
operator|.
name|tile_spacing
argument_list|,
literal|1.0
argument_list|,
literal|50.0
argument_list|,
literal|1.0
argument_list|,
literal|10.0
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_spacing
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"Tile _neatness:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|5
argument_list|,
name|mvals
operator|.
name|tile_neatness
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.10
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_neatness
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"Light _direction:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|5
argument_list|,
name|mvals
operator|.
name|light_dir
argument_list|,
literal|0.0
argument_list|,
literal|360.0
argument_list|,
literal|1.0
argument_list|,
literal|15.0
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|light_dir
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
name|row
operator|++
argument_list|,
name|_
argument_list|(
literal|"Color _variation:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|5
argument_list|,
name|mvals
operator|.
name|color_variation
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|color_variation
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
comment|/*  the vertical box and its toggle buttons  */
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|vbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Antialiasing"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|mvals
operator|.
name|antialiasing
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|antialiasing
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Co_lor averaging"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|mvals
operator|.
name|color_averaging
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|color_averaging
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Allo_w tile splitting"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_allow_split
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Pitted surfaces"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|mvals
operator|.
name|tile_surface
operator|==
name|ROUGH
operator|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|tile_surface
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_FG/BG lighting"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
operator|(
name|mvals
operator|.
name|grout_color
operator|==
name|FG_BG
operator|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|mvals
operator|.
name|grout_color
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  *  Gradient finding machinery  */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_gradients (GimpDrawable * drawable,gdouble std_dev,gint x1,gint y1,gint width,gint height,GimpPreview * preview)
name|find_gradients
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gdouble
name|std_dev
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|GimpPixelRgn
name|src_rgn
decl_stmt|;
name|GimpPixelRgn
name|dest_rgn
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guchar
modifier|*
name|gr
decl_stmt|,
modifier|*
name|dh
decl_stmt|,
modifier|*
name|dv
decl_stmt|;
name|gint
name|hmax
decl_stmt|,
name|vmax
decl_stmt|;
name|gint
name|row
decl_stmt|,
name|rows
decl_stmt|;
name|gint
name|ith_row
decl_stmt|;
name|bytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
comment|/*  allocate the gradient maps  */
name|h_grad
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|v_grad
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|m_grad
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/*  Calculate total number of rows to be processed  */
name|rows
operator|=
name|width
operator|*
literal|2
operator|+
name|height
operator|*
literal|2
expr_stmt|;
name|ith_row
operator|=
name|rows
operator|/
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|ith_row
condition|)
name|ith_row
operator|=
literal|1
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
comment|/*  Get the horizontal derivative  */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|preview
operator|==
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gaussian_deriv
argument_list|(
operator|&
name|src_rgn
argument_list|,
operator|&
name|dest_rgn
argument_list|,
name|HORIZONTAL
argument_list|,
name|std_dev
argument_list|,
operator|&
name|row
argument_list|,
name|rows
argument_list|,
name|ith_row
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x1
operator|+
name|width
argument_list|,
name|y1
operator|+
name|height
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dest_rgn
operator|.
name|x
operator|=
name|dest_rgn
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dest_rgn
operator|.
name|w
operator|=
name|width
expr_stmt|;
name|dest_rgn
operator|.
name|h
operator|=
name|height
expr_stmt|;
name|dest_rgn
operator|.
name|bpp
operator|=
literal|1
expr_stmt|;
name|dest_rgn
operator|.
name|rowstride
operator|=
name|width
expr_stmt|;
name|dest_rgn
operator|.
name|data
operator|=
name|h_grad
expr_stmt|;
name|find_max_gradient
argument_list|(
operator|&
name|src_rgn
argument_list|,
operator|&
name|dest_rgn
argument_list|)
expr_stmt|;
comment|/*  Get the vertical derivative  */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|preview
operator|==
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gaussian_deriv
argument_list|(
operator|&
name|src_rgn
argument_list|,
operator|&
name|dest_rgn
argument_list|,
name|VERTICAL
argument_list|,
name|std_dev
argument_list|,
operator|&
name|row
argument_list|,
name|rows
argument_list|,
name|ith_row
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x1
operator|+
name|width
argument_list|,
name|y1
operator|+
name|height
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dest_rgn
operator|.
name|x
operator|=
name|dest_rgn
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dest_rgn
operator|.
name|w
operator|=
name|width
expr_stmt|;
name|dest_rgn
operator|.
name|h
operator|=
name|height
expr_stmt|;
name|dest_rgn
operator|.
name|bpp
operator|=
literal|1
expr_stmt|;
name|dest_rgn
operator|.
name|rowstride
operator|=
name|width
expr_stmt|;
name|dest_rgn
operator|.
name|data
operator|=
name|v_grad
expr_stmt|;
name|find_max_gradient
argument_list|(
operator|&
name|src_rgn
argument_list|,
operator|&
name|dest_rgn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
comment|/*  fill in the gradient map  */
name|gr
operator|=
name|m_grad
expr_stmt|;
name|dh
operator|=
name|h_grad
expr_stmt|;
name|dv
operator|=
name|v_grad
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
operator|,
name|dh
operator|++
operator|,
name|dv
operator|++
operator|,
name|gr
operator|++
control|)
block|{
comment|/*  Find the gradient  */
if|if
condition|(
operator|!
name|j
operator|||
operator|!
name|i
operator|||
operator|(
name|j
operator|==
name|width
operator|-
literal|1
operator|)
operator|||
operator|(
name|i
operator|==
name|height
operator|-
literal|1
operator|)
condition|)
block|{
operator|*
name|gr
operator|=
name|MAG_THRESHOLD
expr_stmt|;
block|}
else|else
block|{
name|hmax
operator|=
operator|*
name|dh
operator|-
literal|128
expr_stmt|;
name|vmax
operator|=
operator|*
name|dv
operator|-
literal|128
expr_stmt|;
operator|*
name|gr
operator|=
operator|(
name|guchar
operator|)
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|hmax
argument_list|)
operator|+
name|SQR
argument_list|(
name|vmax
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_max_gradient (GimpPixelRgn * src_rgn,GimpPixelRgn * dest_rgn)
name|find_max_gradient
parameter_list|(
name|GimpPixelRgn
modifier|*
name|src_rgn
parameter_list|,
name|GimpPixelRgn
modifier|*
name|dest_rgn
parameter_list|)
block|{
name|guchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|s_iter
decl_stmt|,
modifier|*
name|s_end
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|gint
name|max
decl_stmt|;
comment|/*  Find the maximum value amongst intensity channels  */
name|pr
operator|=
name|gimp_pixel_rgns_register
argument_list|(
literal|2
argument_list|,
name|src_rgn
argument_list|,
name|dest_rgn
argument_list|)
expr_stmt|;
while|while
condition|(
name|pr
condition|)
block|{
name|s
operator|=
name|src_rgn
operator|->
name|data
expr_stmt|;
name|d
operator|=
name|dest_rgn
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_rgn
operator|->
name|h
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|src_rgn
operator|->
name|w
condition|;
name|j
operator|++
control|)
block|{
name|max
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SLOW_CODE
DECL|macro|ABSVAL (x)
define|#
directive|define
name|ABSVAL
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : -(x))
for|for
control|(
name|s_iter
operator|=
name|s
operator|,
name|s_end
operator|=
name|s
operator|+
name|src_rgn
operator|->
name|bpp
init|;
name|s_iter
operator|<
name|s_end
condition|;
name|s_iter
operator|++
control|)
block|{
name|val
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|ABSVAL
argument_list|(
name|val
argument_list|)
operator|>
name|ABSVAL
argument_list|(
name|max
argument_list|)
condition|)
name|max
operator|=
name|val
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
name|max
expr_stmt|;
else|#
directive|else
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|src_rgn
operator|->
name|bpp
condition|;
name|b
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|gint
operator|)
name|s
index|[
name|b
index|]
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|val
argument_list|)
operator|>
name|abs
argument_list|(
name|max
argument_list|)
condition|)
name|max
operator|=
name|val
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
operator|(
name|max
operator|+
literal|128
operator|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|src_rgn
operator|->
name|bpp
expr_stmt|;
block|}
name|s
operator|+=
operator|(
name|src_rgn
operator|->
name|rowstride
operator|-
name|src_rgn
operator|->
name|w
operator|*
name|src_rgn
operator|->
name|bpp
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|dest_rgn
operator|->
name|rowstride
operator|-
name|dest_rgn
operator|->
name|w
operator|)
expr_stmt|;
block|}
name|pr
operator|=
name|gimp_pixel_rgns_process
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************/
end_comment

begin_comment
comment|/*   Functions for gaussian convolutions     */
end_comment

begin_comment
comment|/*********************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|gaussian_deriv (GimpPixelRgn * src_rgn,GimpPixelRgn * dest_rgn,gint type,gdouble std_dev,gint * prog,gint max_prog,gint ith_prog,gint x1,gint y1,gint x2,gint y2,GimpPreview * preview)
name|gaussian_deriv
parameter_list|(
name|GimpPixelRgn
modifier|*
name|src_rgn
parameter_list|,
name|GimpPixelRgn
modifier|*
name|dest_rgn
parameter_list|,
name|gint
name|type
parameter_list|,
name|gdouble
name|std_dev
parameter_list|,
name|gint
modifier|*
name|prog
parameter_list|,
name|gint
name|max_prog
parameter_list|,
name|gint
name|ith_prog
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|guchar
modifier|*
name|src
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
modifier|*
name|buf
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|gint
name|chan
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|start
decl_stmt|,
name|end
decl_stmt|;
name|gint
name|curve_array
index|[
literal|9
index|]
decl_stmt|;
name|gint
name|sum_array
index|[
literal|9
index|]
decl_stmt|;
name|gint
modifier|*
name|curve
decl_stmt|;
name|gint
modifier|*
name|sum
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|gint
name|total
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|gint
name|initial_p
index|[
literal|4
index|]
decl_stmt|,
name|initial_m
index|[
literal|4
index|]
decl_stmt|;
name|bytes
operator|=
name|src_rgn
operator|->
name|bpp
expr_stmt|;
comment|/*  allocate buffers for get/set pixel region rows/cols  */
name|length
operator|=
name|MAX
argument_list|(
name|src_rgn
operator|->
name|w
argument_list|,
name|src_rgn
operator|->
name|h
argument_list|)
operator|*
name|bytes
expr_stmt|;
name|data
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|src
operator|=
name|data
expr_stmt|;
name|dest
operator|=
name|data
operator|+
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|UNOPTIMIZED_CODE
name|length
operator|=
literal|3
expr_stmt|;
comment|/*  static for speed  */
else|#
directive|else
comment|/* badhack :) */
DECL|macro|length
define|#
directive|define
name|length
value|3
endif|#
directive|endif
comment|/*  initialize  */
name|curve
operator|=
name|curve_array
operator|+
name|length
expr_stmt|;
name|sum
operator|=
name|sum_array
operator|+
name|length
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|MAX
argument_list|(
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VERTICAL
condition|)
block|{
name|make_curve_d
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
literal|0
index|]
operator|*
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|make_curve
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
expr_stmt|;
block|}
for|for
control|(
name|col
operator|=
name|x1
init|;
name|col
operator|<
name|x2
condition|;
name|col
operator|++
control|)
block|{
name|gimp_pixel_rgn_get_col
argument_list|(
name|src_rgn
argument_list|,
name|src
argument_list|,
name|col
argument_list|,
name|y1
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|src
expr_stmt|;
name|dp
operator|=
name|dest
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|initial_p
index|[
name|chan
index|]
operator|=
name|sp
index|[
name|chan
index|]
expr_stmt|;
name|initial_m
index|[
name|chan
index|]
operator|=
name|sp
index|[
operator|(
name|y2
operator|-
name|y1
operator|-
literal|1
operator|)
operator|*
name|bytes
operator|+
name|chan
index|]
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
name|y1
init|;
name|row
operator|<
name|y2
condition|;
name|row
operator|++
control|)
block|{
name|start
operator|=
operator|(
operator|(
name|row
operator|-
name|y1
operator|)
operator|<
name|length
operator|)
condition|?
operator|(
name|y1
operator|-
name|row
operator|)
else|:
operator|-
name|length
expr_stmt|;
name|end
operator|=
operator|(
operator|(
name|y2
operator|-
name|row
operator|-
literal|1
operator|)
operator|<
name|length
operator|)
condition|?
operator|(
name|y2
operator|-
name|row
operator|-
literal|1
operator|)
else|:
name|length
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|s
operator|=
name|sp
operator|+
operator|(
name|start
operator|*
name|bytes
operator|)
operator|+
name|chan
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
name|length
condition|)
name|val
operator|+=
name|initial_p
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|start
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|end
condition|)
block|{
name|val
operator|+=
operator|*
name|s
operator|*
name|curve
index|[
name|i
operator|++
index|]
expr_stmt|;
name|s
operator|+=
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|length
condition|)
name|val
operator|+=
name|initial_m
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
operator|-
name|sum
index|[
name|end
operator|+
literal|1
index|]
operator|)
expr_stmt|;
operator|*
name|b
operator|++
operator|=
name|val
operator|/
name|total
expr_stmt|;
block|}
name|sp
operator|+=
name|bytes
expr_stmt|;
block|}
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VERTICAL
condition|)
for|for
control|(
name|row
operator|=
name|y1
init|;
name|row
operator|<
name|y2
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|b
index|[
name|chan
index|]
operator|+=
literal|128
expr_stmt|;
name|dp
index|[
name|chan
index|]
operator|=
name|CLAMP0255
argument_list|(
name|b
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|bytes
expr_stmt|;
block|}
else|else
for|for
control|(
name|row
operator|=
name|y1
init|;
name|row
operator|<
name|y2
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|dp
index|[
name|chan
index|]
operator|=
name|CLAMP0255
argument_list|(
name|b
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|bytes
expr_stmt|;
block|}
name|gimp_pixel_rgn_set_col
argument_list|(
name|dest_rgn
argument_list|,
name|dest
argument_list|,
name|col
argument_list|,
name|y1
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|prog
operator|)
operator|++
operator|%
name|ith_prog
operator|)
operator|&&
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
operator|*
name|prog
operator|/
operator|(
name|gdouble
operator|)
name|max_prog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|HORIZONTAL
condition|)
block|{
name|make_curve_d
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
literal|0
index|]
operator|*
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|make_curve
argument_list|(
name|curve
argument_list|,
name|sum
argument_list|,
name|std_dev
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|total
operator|=
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
name|y1
init|;
name|row
operator|<
name|y2
condition|;
name|row
operator|++
control|)
block|{
name|gimp_pixel_rgn_get_row
argument_list|(
name|dest_rgn
argument_list|,
name|src
argument_list|,
name|x1
argument_list|,
name|row
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|src
expr_stmt|;
name|dp
operator|=
name|dest
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|initial_p
index|[
name|chan
index|]
operator|=
name|sp
index|[
name|chan
index|]
expr_stmt|;
name|initial_m
index|[
name|chan
index|]
operator|=
name|sp
index|[
operator|(
name|x2
operator|-
name|x1
operator|-
literal|1
operator|)
operator|*
name|bytes
operator|+
name|chan
index|]
expr_stmt|;
block|}
for|for
control|(
name|col
operator|=
name|x1
init|;
name|col
operator|<
name|x2
condition|;
name|col
operator|++
control|)
block|{
name|start
operator|=
operator|(
operator|(
name|col
operator|-
name|x1
operator|)
operator|<
name|length
operator|)
condition|?
operator|(
name|x1
operator|-
name|col
operator|)
else|:
operator|-
name|length
expr_stmt|;
name|end
operator|=
operator|(
operator|(
name|x2
operator|-
name|col
operator|-
literal|1
operator|)
operator|<
name|length
operator|)
condition|?
operator|(
name|x2
operator|-
name|col
operator|-
literal|1
operator|)
else|:
name|length
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|s
operator|=
name|sp
operator|+
operator|(
name|start
operator|*
name|bytes
operator|)
operator|+
name|chan
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
name|length
condition|)
name|val
operator|+=
name|initial_p
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|start
index|]
operator|-
name|sum
index|[
operator|-
name|length
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|end
condition|)
block|{
name|val
operator|+=
operator|*
name|s
operator|*
name|curve
index|[
name|i
operator|++
index|]
expr_stmt|;
name|s
operator|+=
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|length
condition|)
name|val
operator|+=
name|initial_m
index|[
name|chan
index|]
operator|*
operator|(
name|sum
index|[
name|length
index|]
operator|+
name|curve
index|[
name|length
index|]
operator|-
name|sum
index|[
name|end
operator|+
literal|1
index|]
operator|)
expr_stmt|;
operator|*
name|b
operator|++
operator|=
name|val
operator|/
name|total
expr_stmt|;
block|}
name|sp
operator|+=
name|bytes
expr_stmt|;
block|}
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|HORIZONTAL
condition|)
for|for
control|(
name|col
operator|=
name|x1
init|;
name|col
operator|<
name|x2
condition|;
name|col
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|b
index|[
name|chan
index|]
operator|+=
literal|128
expr_stmt|;
name|dp
index|[
name|chan
index|]
operator|=
name|CLAMP0255
argument_list|(
name|b
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|bytes
expr_stmt|;
block|}
else|else
for|for
control|(
name|col
operator|=
name|x1
init|;
name|col
operator|<
name|x2
condition|;
name|col
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|bytes
condition|;
name|chan
operator|++
control|)
block|{
name|dp
index|[
name|chan
index|]
operator|=
name|CLAMP0255
argument_list|(
name|b
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
name|bytes
expr_stmt|;
name|dp
operator|+=
name|bytes
expr_stmt|;
block|}
name|gimp_pixel_rgn_set_row
argument_list|(
name|dest_rgn
argument_list|,
name|dest
argument_list|,
name|x1
argument_list|,
name|row
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|prog
operator|)
operator|++
operator|%
name|ith_prog
operator|)
operator|&&
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
operator|*
name|prog
operator|/
operator|(
name|gdouble
operator|)
name|max_prog
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNOPTIMIZED_CODE
comment|/* end bad hack */
undef|#
directive|undef
name|length
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The equations: g(r) = exp (- r^2 / (2 * sigma^2))  *                   r = sqrt (x^2 + y ^2)  */
end_comment

begin_function
specifier|static
name|void
DECL|function|make_curve (gint * curve,gint * sum,gdouble sigma,gint length)
name|make_curve
parameter_list|(
name|gint
modifier|*
name|curve
parameter_list|,
name|gint
modifier|*
name|sum
parameter_list|,
name|gdouble
name|sigma
parameter_list|,
name|gint
name|length
parameter_list|)
block|{
name|gdouble
name|sigma2
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|sigma2
operator|=
name|sigma
operator|*
name|sigma
expr_stmt|;
name|curve
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curve
index|[
name|i
index|]
operator|=
call|(
name|gint
call|)
argument_list|(
name|exp
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
operator|(
literal|2
operator|*
name|sigma2
operator|)
argument_list|)
operator|*
literal|255
argument_list|)
expr_stmt|;
name|curve
index|[
operator|-
name|i
index|]
operator|=
name|curve
index|[
name|i
index|]
expr_stmt|;
block|}
name|sum
index|[
operator|-
name|length
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|length
operator|+
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
name|sum
index|[
name|i
index|]
operator|=
name|sum
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|curve
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The equations: d_g(r) = -r * exp (- r^2 / (2 * sigma^2)) / sigma^2  *                   r = sqrt (x^2 + y ^2)  */
end_comment

begin_function
specifier|static
name|void
DECL|function|make_curve_d (gint * curve,gint * sum,gdouble sigma,gint length)
name|make_curve_d
parameter_list|(
name|gint
modifier|*
name|curve
parameter_list|,
name|gint
modifier|*
name|sum
parameter_list|,
name|gdouble
name|sigma
parameter_list|,
name|gint
name|length
parameter_list|)
block|{
name|gdouble
name|sigma2
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|sigma2
operator|=
name|sigma
operator|*
name|sigma
expr_stmt|;
name|curve
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
block|{
name|curve
index|[
name|i
index|]
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|*
name|exp
argument_list|(
operator|-
operator|(
name|i
operator|*
name|i
operator|)
operator|/
operator|(
literal|2
operator|*
name|sigma2
operator|)
argument_list|)
operator|/
name|sigma2
operator|)
operator|*
literal|255
argument_list|)
expr_stmt|;
name|curve
index|[
operator|-
name|i
index|]
operator|=
operator|-
name|curve
index|[
name|i
index|]
expr_stmt|;
block|}
name|sum
index|[
operator|-
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|sum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sum
index|[
operator|-
name|length
operator|+
name|i
index|]
operator|=
name|sum
index|[
operator|-
name|length
operator|+
name|i
operator|-
literal|1
index|]
operator|+
name|curve
index|[
operator|-
name|length
operator|+
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sum
index|[
name|i
index|]
operator|=
name|sum
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|curve
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************/
end_comment

begin_comment
comment|/*   Functions for grid manipulation         */
end_comment

begin_comment
comment|/*********************************************/
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|fp_rand (gdouble val)
name|fp_rand
parameter_list|(
name|gdouble
name|val
parameter_list|)
block|{
return|return
name|g_random_double
argument_list|()
operator|*
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|grid_create_squares (gint x1,gint y1,gint x2,gint y2)
name|grid_create_squares
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|size
init|=
operator|(
name|gint
operator|)
name|mvals
operator|.
name|tile_size
decl_stmt|;
name|Vertex
modifier|*
name|pt
decl_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|rows
operator|=
operator|(
name|height
operator|+
name|size
operator|-
literal|1
operator|)
operator|/
name|size
expr_stmt|;
name|cols
operator|=
operator|(
name|width
operator|+
name|size
operator|-
literal|1
operator|)
operator|/
name|size
expr_stmt|;
name|grid
operator|=
name|g_new
argument_list|(
name|Vertex
argument_list|,
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
operator|(
name|rows
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|grid
operator|+=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|rows
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<=
name|cols
condition|;
name|j
operator|++
control|)
block|{
name|pt
operator|=
name|grid
operator|+
operator|(
name|i
operator|*
operator|(
name|cols
operator|+
literal|2
operator|)
operator|+
name|j
operator|)
expr_stmt|;
name|pt
operator|->
name|x
operator|=
name|x1
operator|+
name|j
operator|*
name|size
operator|+
name|size
operator|/
literal|2
expr_stmt|;
name|pt
operator|->
name|y
operator|=
name|y1
operator|+
name|i
operator|*
name|size
operator|+
name|size
operator|/
literal|2
expr_stmt|;
block|}
name|grid_rows
operator|=
name|rows
expr_stmt|;
name|grid_cols
operator|=
name|cols
expr_stmt|;
name|grid_row_pad
operator|=
literal|1
expr_stmt|;
name|grid_col_pad
operator|=
literal|1
expr_stmt|;
name|grid_multiple
operator|=
literal|1
expr_stmt|;
name|grid_rowstride
operator|=
name|cols
operator|+
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|grid_create_hexagons (gint x1,gint y1,gint x2,gint y2)
name|grid_create_hexagons
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gdouble
name|hex_l1
decl_stmt|,
name|hex_l2
decl_stmt|,
name|hex_l3
decl_stmt|;
name|gdouble
name|hex_width
decl_stmt|;
name|gdouble
name|hex_height
decl_stmt|;
name|Vertex
modifier|*
name|pt
decl_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|hex_l1
operator|=
name|mvals
operator|.
name|tile_size
operator|/
literal|2.0
expr_stmt|;
name|hex_l2
operator|=
name|hex_l1
operator|*
literal|2.0
operator|/
name|sqrt
argument_list|(
literal|3.0
argument_list|)
expr_stmt|;
name|hex_l3
operator|=
name|hex_l1
operator|/
name|sqrt
argument_list|(
literal|3.0
argument_list|)
expr_stmt|;
name|hex_width
operator|=
literal|6
operator|*
name|hex_l1
operator|/
name|sqrt
argument_list|(
literal|3.0
argument_list|)
expr_stmt|;
name|hex_height
operator|=
name|mvals
operator|.
name|tile_size
expr_stmt|;
name|rows
operator|=
operator|(
operator|(
name|height
operator|+
name|hex_height
operator|-
literal|1
operator|)
operator|/
name|hex_height
operator|)
expr_stmt|;
name|cols
operator|=
operator|(
operator|(
name|width
operator|+
name|hex_width
operator|*
literal|2
operator|-
literal|1
operator|)
operator|/
name|hex_width
operator|)
expr_stmt|;
name|grid
operator|=
name|g_new
argument_list|(
name|Vertex
argument_list|,
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|4
operator|*
operator|(
name|rows
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|grid
operator|+=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|rows
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<=
name|cols
condition|;
name|j
operator|++
control|)
block|{
name|pt
operator|=
name|grid
operator|+
operator|(
name|i
operator|*
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|4
operator|+
name|j
operator|*
literal|4
operator|)
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x1
operator|+
name|hex_width
operator|*
name|j
operator|+
name|hex_l3
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y1
operator|+
name|hex_height
operator|*
name|i
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|hex_l2
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|pt
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|1
index|]
operator|.
name|x
operator|+
name|hex_l3
expr_stmt|;
name|pt
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|1
index|]
operator|.
name|y
operator|+
name|hex_l1
expr_stmt|;
name|pt
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|hex_l3
expr_stmt|;
name|pt
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|hex_l1
expr_stmt|;
block|}
name|grid_rows
operator|=
name|rows
expr_stmt|;
name|grid_cols
operator|=
name|cols
expr_stmt|;
name|grid_row_pad
operator|=
literal|1
expr_stmt|;
name|grid_col_pad
operator|=
literal|1
expr_stmt|;
name|grid_multiple
operator|=
literal|4
expr_stmt|;
name|grid_rowstride
operator|=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|grid_create_octagons (gint x1,gint y1,gint x2,gint y2)
name|grid_create_octagons
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gdouble
name|ts
decl_stmt|,
name|side
decl_stmt|,
name|leg
decl_stmt|;
name|gdouble
name|oct_size
decl_stmt|;
name|Vertex
modifier|*
name|pt
decl_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|ts
operator|=
name|mvals
operator|.
name|tile_size
expr_stmt|;
name|side
operator|=
name|ts
operator|/
operator|(
name|sqrt
argument_list|(
literal|2.0
argument_list|)
operator|+
literal|1.0
operator|)
expr_stmt|;
name|leg
operator|=
name|side
operator|*
name|sqrt
argument_list|(
literal|2.0
argument_list|)
operator|*
literal|0.5
expr_stmt|;
name|oct_size
operator|=
name|ts
operator|+
name|side
expr_stmt|;
name|rows
operator|=
operator|(
operator|(
name|height
operator|+
name|oct_size
operator|-
literal|1
operator|)
operator|/
name|oct_size
operator|)
expr_stmt|;
name|cols
operator|=
operator|(
operator|(
name|width
operator|+
name|oct_size
operator|*
literal|2
operator|-
literal|1
operator|)
operator|/
name|oct_size
operator|)
expr_stmt|;
name|grid
operator|=
name|g_new
argument_list|(
name|Vertex
argument_list|,
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|8
operator|*
operator|(
name|rows
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|grid
operator|+=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|8
operator|+
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|rows
operator|+
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<
name|cols
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|pt
operator|=
name|grid
operator|+
operator|(
name|i
operator|*
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|8
operator|+
name|j
operator|*
literal|8
operator|)
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x1
operator|+
name|oct_size
operator|*
name|j
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y1
operator|+
name|oct_size
operator|*
name|i
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|side
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|pt
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|leg
operator|+
name|side
expr_stmt|;
name|pt
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|leg
expr_stmt|;
name|pt
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|pt
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|leg
operator|+
name|side
expr_stmt|;
name|pt
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|pt
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|+
literal|2
operator|*
name|leg
operator|+
name|side
expr_stmt|;
name|pt
index|[
literal|5
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|pt
index|[
literal|5
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|4
index|]
operator|.
name|y
expr_stmt|;
name|pt
index|[
literal|6
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|leg
expr_stmt|;
name|pt
index|[
literal|6
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|pt
index|[
literal|7
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|6
index|]
operator|.
name|x
expr_stmt|;
name|pt
index|[
literal|7
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
block|}
name|grid_rows
operator|=
name|rows
expr_stmt|;
name|grid_cols
operator|=
name|cols
expr_stmt|;
name|grid_row_pad
operator|=
literal|1
expr_stmt|;
name|grid_col_pad
operator|=
literal|1
expr_stmt|;
name|grid_multiple
operator|=
literal|8
expr_stmt|;
name|grid_rowstride
operator|=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|grid_create_triangles (gint x1,gint y1,gint x2,gint y2)
name|grid_create_triangles
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gdouble
name|tri_mid
decl_stmt|,
name|tri_height
decl_stmt|;
name|Vertex
modifier|*
name|pt
decl_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|tri_mid
operator|=
name|mvals
operator|.
name|tile_size
operator|/
literal|2.0
expr_stmt|;
comment|/* cos 60 */
name|tri_height
operator|=
name|mvals
operator|.
name|tile_size
operator|/
literal|2.0
operator|*
name|sqrt
argument_list|(
literal|3.0
argument_list|)
expr_stmt|;
comment|/* sin 60 */
name|rows
operator|=
operator|(
name|height
operator|+
literal|2
operator|*
name|tri_height
operator|-
literal|1
operator|)
operator|/
operator|(
literal|2
operator|*
name|tri_height
operator|)
expr_stmt|;
name|cols
operator|=
operator|(
name|width
operator|+
name|mvals
operator|.
name|tile_size
operator|-
literal|1
operator|)
operator|/
name|mvals
operator|.
name|tile_size
expr_stmt|;
name|grid
operator|=
name|g_new
argument_list|(
name|Vertex
argument_list|,
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|2
operator|*
operator|(
name|rows
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|grid
operator|+=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|rows
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<=
name|cols
condition|;
name|j
operator|++
control|)
block|{
name|pt
operator|=
name|grid
operator|+
operator|(
name|i
operator|*
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|2
operator|+
name|j
operator|*
literal|2
operator|)
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x1
operator|+
name|mvals
operator|.
name|tile_size
operator|*
name|j
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y1
operator|+
operator|(
name|tri_height
operator|*
literal|2
operator|)
operator|*
name|i
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|tri_mid
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|pt
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|tri_height
expr_stmt|;
block|}
name|grid_rows
operator|=
name|rows
expr_stmt|;
name|grid_cols
operator|=
name|cols
expr_stmt|;
name|grid_row_pad
operator|=
literal|1
expr_stmt|;
name|grid_col_pad
operator|=
literal|1
expr_stmt|;
name|grid_multiple
operator|=
literal|2
expr_stmt|;
name|grid_rowstride
operator|=
operator|(
name|cols
operator|+
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|grid_localize (gint x1,gint y1,gint x2,gint y2)
name|grid_localize
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gint
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|k
decl_stmt|,
name|l
decl_stmt|;
name|gint
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gint
name|max_x
decl_stmt|,
name|max_y
decl_stmt|;
name|gint
name|max
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gdouble
name|rand_localize
decl_stmt|;
name|Vertex
modifier|*
name|pt
decl_stmt|;
name|width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|height
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|size
operator|=
operator|(
name|gint
operator|)
name|mvals
operator|.
name|tile_size
expr_stmt|;
name|rand_localize
operator|=
name|size
operator|*
operator|(
literal|1.0
operator|-
name|mvals
operator|.
name|tile_neatness
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|grid_row_pad
init|;
name|i
operator|<
name|grid_rows
operator|+
name|grid_row_pad
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
operator|-
name|grid_col_pad
operator|*
name|grid_multiple
init|;
name|j
operator|<
operator|(
name|grid_cols
operator|+
name|grid_col_pad
operator|)
operator|*
name|grid_multiple
condition|;
name|j
operator|++
control|)
block|{
name|pt
operator|=
name|grid
operator|+
operator|(
name|i
operator|*
name|grid_rowstride
operator|+
name|j
operator|)
expr_stmt|;
name|max_x
operator|=
name|pt
operator|->
name|x
operator|+
call|(
name|gint
call|)
argument_list|(
name|fp_rand
argument_list|(
name|rand_localize
argument_list|)
operator|-
name|rand_localize
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|max_y
operator|=
name|pt
operator|->
name|y
operator|+
call|(
name|gint
call|)
argument_list|(
name|fp_rand
argument_list|(
name|rand_localize
argument_list|)
operator|-
name|rand_localize
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|x3
operator|=
name|pt
operator|->
name|x
operator|-
call|(
name|gint
call|)
argument_list|(
name|rand_localize
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|y3
operator|=
name|pt
operator|->
name|y
operator|-
call|(
name|gint
call|)
argument_list|(
name|rand_localize
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|x4
operator|=
name|x3
operator|+
operator|(
name|gint
operator|)
name|rand_localize
expr_stmt|;
name|y4
operator|=
name|y3
operator|+
operator|(
name|gint
operator|)
name|rand_localize
expr_stmt|;
name|x3
operator|=
name|CLAMP
argument_list|(
name|x3
argument_list|,
name|x1
argument_list|,
name|x2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y3
operator|=
name|CLAMP
argument_list|(
name|y3
argument_list|,
name|y1
argument_list|,
name|y2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|x4
operator|=
name|CLAMP
argument_list|(
name|x4
argument_list|,
name|x1
argument_list|,
name|x2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y4
operator|=
name|CLAMP
argument_list|(
name|y4
argument_list|,
name|y1
argument_list|,
name|y2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
operator|*
operator|(
name|m_grad
operator|+
operator|(
name|y3
operator|-
name|y1
operator|)
operator|*
name|width
operator|+
operator|(
name|x3
operator|-
name|x1
operator|)
operator|)
expr_stmt|;
name|data
operator|=
name|m_grad
operator|+
name|width
operator|*
operator|(
name|y3
operator|-
name|y1
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|y3
init|;
name|k
operator|<=
name|y4
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|l
operator|=
name|x3
init|;
name|l
operator|<=
name|x4
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|l
operator|-
name|x1
index|]
operator|>
name|max
condition|)
block|{
name|max_y
operator|=
name|k
expr_stmt|;
name|max_x
operator|=
name|l
expr_stmt|;
name|max
operator|=
name|data
index|[
name|l
operator|-
name|x1
index|]
expr_stmt|;
block|}
block|}
name|data
operator|+=
name|width
expr_stmt|;
block|}
name|pt
operator|->
name|x
operator|=
name|max_x
expr_stmt|;
name|pt
operator|->
name|y
operator|=
name|max_y
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|grid_render (GimpDrawable * drawable,gint x1,gint y1,gint x2,gint y2,GimpPreview * preview)
name|grid_render
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|GimpPixelRgn
name|src_rgn
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|guchar
modifier|*
name|dest
init|=
name|NULL
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|guchar
name|col
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|gint
name|size
decl_stmt|,
name|frac_size
decl_stmt|;
name|gint
name|count
decl_stmt|;
name|gint
name|index
decl_stmt|;
name|gint
name|vary
decl_stmt|;
name|Polygon
name|poly
decl_stmt|;
name|gpointer
name|pr
decl_stmt|;
name|bytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|preview
condition|)
block|{
name|dest
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|bytes
operator|*
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
condition|;
name|i
operator|++
operator|,
name|d
operator|+=
name|bytes
control|)
name|memcpy
argument_list|(
name|d
argument_list|,
name|back
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Fill the image with the background color  */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|gimp_pixel_rgns_register
argument_list|(
literal|1
argument_list|,
operator|&
name|src_rgn
argument_list|)
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|gimp_pixel_rgns_process
argument_list|(
name|pr
argument_list|)
control|)
block|{
name|size
operator|=
name|src_rgn
operator|.
name|w
operator|*
name|src_rgn
operator|.
name|h
expr_stmt|;
name|dest
operator|=
name|src_rgn
operator|.
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_rgn
operator|.
name|h
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|dest
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|src_rgn
operator|.
name|w
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bytes
condition|;
name|k
operator|++
control|)
name|d
index|[
name|k
index|]
operator|=
name|back
index|[
name|k
index|]
expr_stmt|;
name|d
operator|+=
name|bytes
expr_stmt|;
block|}
name|dest
operator|+=
name|src_rgn
operator|.
name|rowstride
expr_stmt|;
block|}
block|}
name|dest
operator|=
name|NULL
expr_stmt|;
block|}
name|size
operator|=
operator|(
name|grid_rows
operator|+
name|grid_row_pad
operator|)
operator|*
operator|(
name|grid_cols
operator|+
name|grid_col_pad
operator|)
expr_stmt|;
name|frac_size
operator|=
name|size
operator|*
name|mvals
operator|.
name|color_variation
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|grid_row_pad
init|;
name|i
operator|<
name|grid_rows
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
operator|-
name|grid_col_pad
init|;
name|j
operator|<
name|grid_cols
condition|;
name|j
operator|++
control|)
block|{
name|vary
operator|=
operator|(
operator|(
name|g_random_int_range
argument_list|(
literal|0
argument_list|,
name|size
argument_list|)
operator|)
operator|<
name|frac_size
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|index
operator|=
name|i
operator|*
name|grid_rowstride
operator|+
name|j
operator|*
name|grid_multiple
expr_stmt|;
switch|switch
condition|(
name|mvals
operator|.
name|tile_type
condition|)
block|{
case|case
name|SQUARES
case|:
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEXAGONS
case|:
comment|/*  The main hexagon  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  The auxillary hexagon  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
operator|+
literal|3
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
operator|+
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCTAGONS
case|:
comment|/*  The main octagon  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|k
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|k
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  The auxillary octagon  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|3
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|4
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|4
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  The main square  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|2
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|*
literal|2
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|FALSE
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  The auxillary square  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|5
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|5
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|4
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|4
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|FALSE
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRIANGLES
case|:
comment|/*  Lower left  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  lower right  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  upper left  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
name|grid_rowstride
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
name|grid_rowstride
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_rowstride
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/*  upper right  */
name|polygon_reset
argument_list|(
operator|&
name|poly
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
operator|&
name|poly
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
name|grid_rowstride
index|]
operator|.
name|x
argument_list|,
name|grid
index|[
name|index
operator|+
name|grid_multiple
operator|+
name|grid_rowstride
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|process_poly
argument_list|(
operator|&
name|poly
argument_list|,
name|mvals
operator|.
name|tile_allow_split
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|count
operator|++
operator|/
operator|(
name|gdouble
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_preview_draw_buffer
argument_list|(
name|preview
argument_list|,
name|dest
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|process_poly (Polygon * poly,gboolean allow_split,GimpDrawable * drawable,guchar * col,gboolean vary,gint x1,gint y1,gint x2,gint y2,guchar * dest)
name|process_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gboolean
name|allow_split
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gboolean
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
block|{
name|gdouble
name|dir
index|[
literal|2
index|]
decl_stmt|;
name|gdouble
name|loc
index|[
literal|2
index|]
decl_stmt|;
name|gdouble
name|cx
init|=
literal|0.0
decl_stmt|,
name|cy
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|magnitude
decl_stmt|;
name|gdouble
name|distance
decl_stmt|;
name|gdouble
name|color_vary
decl_stmt|;
comment|/*  determine the variation of tile color based on tile number  */
name|color_vary
operator|=
name|vary
condition|?
name|fp_rand
argument_list|(
name|mvals
operator|.
name|color_variation
argument_list|)
else|:
literal|0
expr_stmt|;
name|color_vary
operator|=
operator|(
name|g_random_int_range
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|)
condition|?
name|color_vary
operator|*
literal|127
else|:
operator|-
name|color_vary
operator|*
literal|127
expr_stmt|;
comment|/*  Determine direction of edges inside polygon, if any  */
name|find_poly_dir
argument_list|(
name|poly
argument_list|,
name|m_grad
argument_list|,
name|h_grad
argument_list|,
name|v_grad
argument_list|,
name|dir
argument_list|,
name|loc
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|magnitude
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dir
index|[
literal|0
index|]
operator|-
literal|128
argument_list|)
operator|+
name|SQR
argument_list|(
name|dir
index|[
literal|1
index|]
operator|-
literal|128
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Find the center of the polygon  */
name|polygon_find_center
argument_list|(
name|poly
argument_list|,
operator|&
name|cx
argument_list|,
operator|&
name|cy
argument_list|)
expr_stmt|;
name|distance
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|loc
index|[
literal|0
index|]
operator|-
name|cx
argument_list|)
operator|+
name|SQR
argument_list|(
name|loc
index|[
literal|1
index|]
operator|-
name|cy
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  If the magnitude of direction inside the polygon is greater than    *  THRESHOLD, split the polygon into two new polygons    */
if|if
condition|(
name|magnitude
operator|>
name|MAG_THRESHOLD
operator|&&
operator|(
literal|2
operator|*
name|distance
operator|/
name|mvals
operator|.
name|tile_size
operator|)
operator|<
literal|0.5
operator|&&
name|allow_split
condition|)
block|{
name|split_poly
argument_list|(
name|poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|dir
argument_list|,
name|color_vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Otherwise, render the original polygon  */
name|render_poly
argument_list|(
name|poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|color_vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|render_poly (Polygon * poly,GimpDrawable * drawable,guchar * col,gdouble vary,gint x1,gint y1,gint x2,gint y2,guchar * dest)
name|render_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gdouble
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
block|{
name|gdouble
name|cx
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|cy
init|=
literal|0.0
decl_stmt|;
name|polygon_find_center
argument_list|(
name|poly
argument_list|,
operator|&
name|cx
argument_list|,
operator|&
name|cy
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvals
operator|.
name|color_averaging
condition|)
name|find_poly_color
argument_list|(
name|poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|scale_poly
argument_list|(
name|poly
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvals
operator|.
name|color_averaging
condition|)
name|fill_poly_color
argument_list|(
name|poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|fill_poly_image
argument_list|(
name|poly
argument_list|,
name|drawable
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|split_poly (Polygon * poly,GimpDrawable * drawable,guchar * col,gdouble * dir,gdouble vary,gint x1,gint y1,gint x2,gint y2,guchar * dest)
name|split_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
block|{
name|Polygon
name|new_poly
decl_stmt|;
name|gdouble
name|spacing
decl_stmt|;
name|gdouble
name|cx
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|cy
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|magnitude
decl_stmt|;
name|gdouble
name|vec
index|[
literal|2
index|]
decl_stmt|;
name|gdouble
name|pt
index|[
literal|2
index|]
decl_stmt|;
name|spacing
operator|=
name|mvals
operator|.
name|tile_spacing
operator|/
operator|(
literal|2.0
operator|*
name|scale
operator|)
expr_stmt|;
name|polygon_find_center
argument_list|(
name|poly
argument_list|,
operator|&
name|cx
argument_list|,
operator|&
name|cy
argument_list|)
expr_stmt|;
name|polygon_translate
argument_list|(
name|poly
argument_list|,
operator|-
name|cx
argument_list|,
operator|-
name|cy
argument_list|)
expr_stmt|;
name|magnitude
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|dir
index|[
literal|0
index|]
operator|-
literal|128
argument_list|)
operator|+
name|SQR
argument_list|(
name|dir
index|[
literal|1
index|]
operator|-
literal|128
argument_list|)
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
operator|-
operator|(
name|dir
index|[
literal|1
index|]
operator|-
literal|128
operator|)
operator|/
name|magnitude
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
operator|(
name|dir
index|[
literal|0
index|]
operator|-
literal|128
operator|)
operator|/
name|magnitude
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|=
operator|-
name|vec
index|[
literal|1
index|]
operator|*
name|spacing
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|=
name|vec
index|[
literal|0
index|]
operator|*
name|spacing
expr_stmt|;
name|polygon_reset
argument_list|(
operator|&
name|new_poly
argument_list|)
expr_stmt|;
name|clip_poly
argument_list|(
name|vec
argument_list|,
name|pt
argument_list|,
name|poly
argument_list|,
operator|&
name|new_poly
argument_list|)
expr_stmt|;
name|polygon_translate
argument_list|(
operator|&
name|new_poly
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_poly
operator|.
name|npts
condition|)
block|{
if|if
condition|(
name|mvals
operator|.
name|color_averaging
condition|)
name|find_poly_color
argument_list|(
operator|&
name|new_poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|scale_poly
argument_list|(
operator|&
name|new_poly
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvals
operator|.
name|color_averaging
condition|)
name|fill_poly_color
argument_list|(
operator|&
name|new_poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|fill_poly_image
argument_list|(
operator|&
name|new_poly
argument_list|,
name|drawable
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
operator|-
name|vec
index|[
literal|0
index|]
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
operator|-
name|vec
index|[
literal|1
index|]
expr_stmt|;
name|pt
index|[
literal|0
index|]
operator|=
operator|-
name|pt
index|[
literal|0
index|]
expr_stmt|;
name|pt
index|[
literal|1
index|]
operator|=
operator|-
name|pt
index|[
literal|1
index|]
expr_stmt|;
name|polygon_reset
argument_list|(
operator|&
name|new_poly
argument_list|)
expr_stmt|;
name|clip_poly
argument_list|(
name|vec
argument_list|,
name|pt
argument_list|,
name|poly
argument_list|,
operator|&
name|new_poly
argument_list|)
expr_stmt|;
name|polygon_translate
argument_list|(
operator|&
name|new_poly
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_poly
operator|.
name|npts
condition|)
block|{
if|if
condition|(
name|mvals
operator|.
name|color_averaging
condition|)
name|find_poly_color
argument_list|(
operator|&
name|new_poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|scale_poly
argument_list|(
operator|&
name|new_poly
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvals
operator|.
name|color_averaging
condition|)
name|fill_poly_color
argument_list|(
operator|&
name|new_poly
argument_list|,
name|drawable
argument_list|,
name|col
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|fill_poly_image
argument_list|(
operator|&
name|new_poly
argument_list|,
name|drawable
argument_list|,
name|vary
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clip_poly (gdouble * dir,gdouble * pt,Polygon * poly,Polygon * poly_new)
name|clip_poly
parameter_list|(
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
modifier|*
name|pt
parameter_list|,
name|Polygon
modifier|*
name|poly
parameter_list|,
name|Polygon
modifier|*
name|poly_new
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|x1
operator|=
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|x
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|y1
operator|=
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|y
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|x2
operator|=
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|y2
operator|=
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|clip_point
argument_list|(
name|dir
argument_list|,
name|pt
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|poly_new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clip_point (gdouble * dir,gdouble * pt,gdouble x1,gdouble y1,gdouble x2,gdouble y2,Polygon * poly_new)
name|clip_point
parameter_list|(
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
modifier|*
name|pt
parameter_list|,
name|gdouble
name|x1
parameter_list|,
name|gdouble
name|y1
parameter_list|,
name|gdouble
name|x2
parameter_list|,
name|gdouble
name|y2
parameter_list|,
name|Polygon
modifier|*
name|poly_new
parameter_list|)
block|{
name|gdouble
name|det
decl_stmt|,
name|m11
decl_stmt|,
name|m12
decl_stmt|,
name|m21
decl_stmt|,
name|m22
decl_stmt|;
name|gdouble
name|side1
decl_stmt|,
name|side2
decl_stmt|;
name|gdouble
name|t
decl_stmt|;
name|gdouble
name|vec
index|[
literal|2
index|]
decl_stmt|;
name|x1
operator|-=
name|pt
index|[
literal|0
index|]
expr_stmt|;
name|x2
operator|-=
name|pt
index|[
literal|0
index|]
expr_stmt|;
name|y1
operator|-=
name|pt
index|[
literal|1
index|]
expr_stmt|;
name|y2
operator|-=
name|pt
index|[
literal|1
index|]
expr_stmt|;
name|side1
operator|=
name|x1
operator|*
operator|-
name|dir
index|[
literal|1
index|]
operator|+
name|y1
operator|*
name|dir
index|[
literal|0
index|]
expr_stmt|;
name|side2
operator|=
name|x2
operator|*
operator|-
name|dir
index|[
literal|1
index|]
operator|+
name|y2
operator|*
name|dir
index|[
literal|0
index|]
expr_stmt|;
comment|/*  If both points are to be clipped, ignore  */
if|if
condition|(
name|side1
operator|<
literal|0.0
operator|&&
name|side2
operator|<
literal|0.0
condition|)
block|{
return|return;
block|}
comment|/*  If both points are non-clipped, set point  */
elseif|else
if|if
condition|(
name|side1
operator|>=
literal|0.0
operator|&&
name|side2
operator|>=
literal|0.0
condition|)
block|{
name|polygon_add_point
argument_list|(
name|poly_new
argument_list|,
name|x2
operator|+
name|pt
index|[
literal|0
index|]
argument_list|,
name|y2
operator|+
name|pt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  Otherwise, there is an intersection...  */
else|else
block|{
name|vec
index|[
literal|0
index|]
operator|=
name|x1
operator|-
name|x2
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
name|y1
operator|-
name|y2
expr_stmt|;
name|det
operator|=
name|dir
index|[
literal|0
index|]
operator|*
name|vec
index|[
literal|1
index|]
operator|-
name|dir
index|[
literal|1
index|]
operator|*
name|vec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|det
operator|==
literal|0.0
condition|)
block|{
name|polygon_add_point
argument_list|(
name|poly_new
argument_list|,
name|x2
operator|+
name|pt
index|[
literal|0
index|]
argument_list|,
name|y2
operator|+
name|pt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|m11
operator|=
name|vec
index|[
literal|1
index|]
operator|/
name|det
expr_stmt|;
name|m12
operator|=
operator|-
name|vec
index|[
literal|0
index|]
operator|/
name|det
expr_stmt|;
name|m21
operator|=
operator|-
name|dir
index|[
literal|1
index|]
operator|/
name|det
expr_stmt|;
name|m22
operator|=
name|dir
index|[
literal|0
index|]
operator|/
name|det
expr_stmt|;
name|t
operator|=
name|m11
operator|*
name|x1
operator|+
name|m12
operator|*
name|y1
expr_stmt|;
comment|/*  If the first point is clipped, set intersection and point  */
if|if
condition|(
name|side1
operator|<
literal|0.0
operator|&&
name|side2
operator|>
literal|0.0
condition|)
block|{
name|polygon_add_point
argument_list|(
name|poly_new
argument_list|,
name|dir
index|[
literal|0
index|]
operator|*
name|t
operator|+
name|pt
index|[
literal|0
index|]
argument_list|,
name|dir
index|[
literal|1
index|]
operator|*
name|t
operator|+
name|pt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|polygon_add_point
argument_list|(
name|poly_new
argument_list|,
name|x2
operator|+
name|pt
index|[
literal|0
index|]
argument_list|,
name|y2
operator|+
name|pt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|polygon_add_point
argument_list|(
name|poly_new
argument_list|,
name|dir
index|[
literal|0
index|]
operator|*
name|t
operator|+
name|pt
index|[
literal|0
index|]
argument_list|,
name|dir
index|[
literal|1
index|]
operator|*
name|t
operator|+
name|pt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_poly_dir (Polygon * poly,guchar * m_gr,guchar * h_gr,guchar * v_gr,gdouble * dir,gdouble * loc,gint x1,gint y1,gint x2,gint y2)
name|find_poly_dir
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|guchar
modifier|*
name|m_gr
parameter_list|,
name|guchar
modifier|*
name|h_gr
parameter_list|,
name|guchar
modifier|*
name|v_gr
parameter_list|,
name|gdouble
modifier|*
name|dir
parameter_list|,
name|gdouble
modifier|*
name|loc
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gdouble
name|dmin_x
init|=
literal|0.0
decl_stmt|,
name|dmin_y
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|dmax_x
init|=
literal|0.0
decl_stmt|,
name|dmax_y
init|=
literal|0.0
decl_stmt|;
name|gint
name|xs
decl_stmt|,
name|ys
decl_stmt|;
name|gint
name|xe
decl_stmt|,
name|ye
decl_stmt|;
name|gint
name|min_x
decl_stmt|,
name|min_y
decl_stmt|;
name|gint
name|max_x
decl_stmt|,
name|max_y
decl_stmt|;
name|gint
name|size_x
decl_stmt|,
name|size_y
decl_stmt|;
name|gint
modifier|*
name|max_scanlines
decl_stmt|;
name|gint
modifier|*
name|min_scanlines
decl_stmt|;
name|guchar
modifier|*
name|dm
decl_stmt|,
modifier|*
name|dv
decl_stmt|,
modifier|*
name|dh
decl_stmt|;
name|gint
name|count
decl_stmt|,
name|total
decl_stmt|;
name|gint
name|rowstride
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rowstride
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|dir
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|dir
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|loc
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|loc
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|polygon_extents
argument_list|(
name|poly
argument_list|,
operator|&
name|dmin_x
argument_list|,
operator|&
name|dmin_y
argument_list|,
operator|&
name|dmax_x
argument_list|,
operator|&
name|dmax_y
argument_list|)
expr_stmt|;
name|min_x
operator|=
operator|(
name|gint
operator|)
name|dmin_x
expr_stmt|;
name|min_y
operator|=
operator|(
name|gint
operator|)
name|dmin_y
expr_stmt|;
name|max_x
operator|=
operator|(
name|gint
operator|)
name|dmax_x
expr_stmt|;
name|max_y
operator|=
operator|(
name|gint
operator|)
name|dmax_y
expr_stmt|;
name|size_y
operator|=
name|max_y
operator|-
name|min_y
expr_stmt|;
name|size_x
operator|=
name|max_x
operator|-
name|min_x
expr_stmt|;
name|min_scanlines
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
name|max_scanlines
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
name|min_scanlines
index|[
name|i
index|]
operator|=
name|max_x
expr_stmt|;
name|max_scanlines
index|[
name|i
index|]
operator|=
name|min_x
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|x
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|y
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|convert_segment
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|,
name|min_y
argument_list|,
name|min_scanlines
argument_list|,
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
name|min_y
operator|)
operator|>=
name|y1
operator|&&
operator|(
name|i
operator|+
name|min_y
operator|)
operator|<
name|y2
condition|)
block|{
name|dm
operator|=
name|m_gr
operator|+
operator|(
name|i
operator|+
name|min_y
operator|-
name|y1
operator|)
operator|*
name|rowstride
operator|-
name|x1
expr_stmt|;
name|dh
operator|=
name|h_gr
operator|+
operator|(
name|i
operator|+
name|min_y
operator|-
name|y1
operator|)
operator|*
name|rowstride
operator|-
name|x1
expr_stmt|;
name|dv
operator|=
name|v_gr
operator|+
operator|(
name|i
operator|+
name|min_y
operator|-
name|y1
operator|)
operator|*
name|rowstride
operator|-
name|x1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|min_scanlines
index|[
name|i
index|]
init|;
name|j
operator|<
name|max_scanlines
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|x1
operator|&&
name|j
operator|<
name|x2
condition|)
block|{
if|if
condition|(
name|dm
index|[
name|j
index|]
operator|>
name|MAG_THRESHOLD
condition|)
block|{
name|dir
index|[
literal|0
index|]
operator|+=
name|dh
index|[
name|j
index|]
expr_stmt|;
name|dir
index|[
literal|1
index|]
operator|+=
name|dv
index|[
name|j
index|]
expr_stmt|;
name|loc
index|[
literal|0
index|]
operator|+=
name|j
expr_stmt|;
name|loc
index|[
literal|1
index|]
operator|+=
name|i
operator|+
name|min_y
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|total
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|total
condition|)
return|return;
if|if
condition|(
operator|(
name|gdouble
operator|)
name|count
operator|/
operator|(
name|gdouble
operator|)
name|total
operator|>
name|COUNT_THRESHOLD
condition|)
block|{
name|dir
index|[
literal|0
index|]
operator|/=
name|count
expr_stmt|;
name|dir
index|[
literal|1
index|]
operator|/=
name|count
expr_stmt|;
name|loc
index|[
literal|0
index|]
operator|/=
name|count
expr_stmt|;
name|loc
index|[
literal|1
index|]
operator|/=
name|count
expr_stmt|;
block|}
else|else
block|{
name|dir
index|[
literal|0
index|]
operator|=
literal|128.0
expr_stmt|;
name|dir
index|[
literal|1
index|]
operator|=
literal|128.0
expr_stmt|;
name|loc
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|loc
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
name|g_free
argument_list|(
name|min_scanlines
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|find_poly_color (Polygon * poly,GimpDrawable * drawable,guchar * col,gdouble color_var,gint x1,gint y1,gint x2,gint y2)
name|find_poly_color
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gdouble
name|color_var
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|GimpPixelRgn
name|src_rgn
decl_stmt|;
name|gdouble
name|dmin_x
init|=
literal|0.0
decl_stmt|,
name|dmin_y
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|dmax_x
init|=
literal|0.0
decl_stmt|,
name|dmax_y
init|=
literal|0.0
decl_stmt|;
name|gint
name|xs
decl_stmt|,
name|ys
decl_stmt|;
name|gint
name|xe
decl_stmt|,
name|ye
decl_stmt|;
name|gint
name|min_x
decl_stmt|,
name|min_y
decl_stmt|;
name|gint
name|max_x
decl_stmt|,
name|max_y
decl_stmt|;
name|gint
name|size_x
decl_stmt|,
name|size_y
decl_stmt|;
name|gint
modifier|*
name|max_scanlines
decl_stmt|;
name|gint
modifier|*
name|min_scanlines
decl_stmt|;
name|gint
name|col_sum
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|count
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|y
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
name|polygon_extents
argument_list|(
name|poly
argument_list|,
operator|&
name|dmin_x
argument_list|,
operator|&
name|dmin_y
argument_list|,
operator|&
name|dmax_x
argument_list|,
operator|&
name|dmax_y
argument_list|)
expr_stmt|;
name|min_x
operator|=
operator|(
name|gint
operator|)
name|dmin_x
expr_stmt|;
name|min_y
operator|=
operator|(
name|gint
operator|)
name|dmin_y
expr_stmt|;
name|max_x
operator|=
operator|(
name|gint
operator|)
name|dmax_x
expr_stmt|;
name|max_y
operator|=
operator|(
name|gint
operator|)
name|dmax_y
expr_stmt|;
name|size_y
operator|=
name|max_y
operator|-
name|min_y
expr_stmt|;
name|size_x
operator|=
name|max_x
operator|-
name|min_x
expr_stmt|;
name|min_scanlines
operator|=
name|g_new
argument_list|(
name|int
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
name|max_scanlines
operator|=
name|g_new
argument_list|(
name|int
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
name|min_scanlines
index|[
name|i
index|]
operator|=
name|max_x
expr_stmt|;
name|max_scanlines
index|[
name|i
index|]
operator|=
name|min_x
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|x
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|y
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|convert_segment
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|,
name|min_y
argument_list|,
name|min_scanlines
argument_list|,
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
name|y
operator|=
name|i
operator|+
name|min_y
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|y1
operator|&&
name|y
operator|<
name|y2
condition|)
block|{
for|for
control|(
name|j
operator|=
name|min_scanlines
index|[
name|i
index|]
init|;
name|j
operator|<
name|max_scanlines
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|x1
operator|&&
name|j
operator|<
name|x2
condition|)
block|{
name|gimp_pixel_rgn_get_pixel
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|col
argument_list|,
name|j
argument_list|,
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
name|col_sum
index|[
name|b
index|]
operator|+=
name|col
index|[
name|b
index|]
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|count
condition|)
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
name|col_sum
index|[
name|b
index|]
operator|=
call|(
name|gint
call|)
argument_list|(
name|col_sum
index|[
name|b
index|]
operator|/
name|count
operator|+
name|color_var
argument_list|)
expr_stmt|;
name|col
index|[
name|b
index|]
operator|=
name|CLAMP0255
argument_list|(
name|col_sum
index|[
name|b
index|]
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|min_scanlines
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|scale_poly (Polygon * poly,gdouble tx,gdouble ty,gdouble poly_scale)
name|scale_poly
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|tx
parameter_list|,
name|gdouble
name|ty
parameter_list|,
name|gdouble
name|poly_scale
parameter_list|)
block|{
name|polygon_translate
argument_list|(
name|poly
argument_list|,
operator|-
name|tx
argument_list|,
operator|-
name|ty
argument_list|)
expr_stmt|;
name|polygon_scale
argument_list|(
name|poly
argument_list|,
name|poly_scale
argument_list|)
expr_stmt|;
name|polygon_translate
argument_list|(
name|poly
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|fill_poly_color (Polygon * poly,GimpDrawable * drawable,guchar * col,gint x1,gint y1,gint x2,gint y2,guchar * dest)
name|fill_poly_color
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
block|{
name|GimpPixelRgn
name|src_rgn
decl_stmt|;
name|gdouble
name|dmin_x
init|=
literal|0.0
decl_stmt|,
name|dmin_y
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|dmax_x
init|=
literal|0.0
decl_stmt|,
name|dmax_y
init|=
literal|0.0
decl_stmt|;
name|gint
name|xs
decl_stmt|,
name|ys
decl_stmt|;
name|gint
name|xe
decl_stmt|,
name|ye
decl_stmt|;
name|gint
name|min_x
decl_stmt|,
name|min_y
decl_stmt|;
name|gint
name|max_x
decl_stmt|,
name|max_y
decl_stmt|;
name|gint
name|size_x
decl_stmt|,
name|size_y
decl_stmt|;
name|gint
modifier|*
name|max_scanlines
decl_stmt|,
modifier|*
name|max_scanlines_iter
decl_stmt|;
name|gint
modifier|*
name|min_scanlines
decl_stmt|,
modifier|*
name|min_scanlines_iter
decl_stmt|;
name|gint
modifier|*
name|vals
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|gint
name|pixel
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|guchar
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdouble
name|contrib
decl_stmt|;
name|gdouble
name|xx
decl_stmt|,
name|yy
decl_stmt|;
name|gint
name|supersample
decl_stmt|;
name|gint
name|supersample2
decl_stmt|;
name|Vertex
modifier|*
name|pts_tmp
decl_stmt|;
specifier|const
name|gint
name|poly_npts
init|=
name|poly
operator|->
name|npts
decl_stmt|;
comment|/*  Determine antialiasing  */
if|if
condition|(
name|mvals
operator|.
name|antialiasing
condition|)
block|{
name|supersample
operator|=
name|SUPERSAMPLE
expr_stmt|;
name|supersample2
operator|=
name|SQR
argument_list|(
name|supersample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supersample
operator|=
name|supersample2
operator|=
literal|1
expr_stmt|;
block|}
name|bytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|poly_npts
condition|)
block|{
name|pts_tmp
operator|=
name|poly
operator|->
name|pts
expr_stmt|;
name|xs
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
index|[
name|poly_npts
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|ys
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
index|[
name|poly_npts
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|y
expr_stmt|;
name|calc_spec_vec
argument_list|(
name|vecs
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|poly_npts
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
call|(
name|gint
call|)
argument_list|(
name|pts_tmp
operator|->
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
call|(
name|gint
call|)
argument_list|(
name|pts_tmp
operator|->
name|y
argument_list|)
expr_stmt|;
name|pts_tmp
operator|++
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|y
expr_stmt|;
name|calc_spec_vec
argument_list|(
name|vecs
operator|+
name|i
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
block|}
name|polygon_extents
argument_list|(
name|poly
argument_list|,
operator|&
name|dmin_x
argument_list|,
operator|&
name|dmin_y
argument_list|,
operator|&
name|dmax_x
argument_list|,
operator|&
name|dmax_y
argument_list|)
expr_stmt|;
name|min_x
operator|=
operator|(
name|gint
operator|)
name|dmin_x
expr_stmt|;
name|min_y
operator|=
operator|(
name|gint
operator|)
name|dmin_y
expr_stmt|;
name|max_x
operator|=
operator|(
name|gint
operator|)
name|dmax_x
expr_stmt|;
name|max_y
operator|=
operator|(
name|gint
operator|)
name|dmax_y
expr_stmt|;
name|size_y
operator|=
operator|(
name|max_y
operator|-
name|min_y
operator|)
operator|*
name|supersample
expr_stmt|;
name|size_x
operator|=
operator|(
name|max_x
operator|-
name|min_x
operator|)
operator|*
name|supersample
expr_stmt|;
name|min_scanlines
operator|=
name|min_scanlines_iter
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
name|max_scanlines
operator|=
name|max_scanlines_iter
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
name|min_scanlines
index|[
name|i
index|]
operator|=
name|max_x
operator|*
name|supersample
expr_stmt|;
name|max_scanlines
index|[
name|i
index|]
operator|=
name|min_x
operator|*
name|supersample
expr_stmt|;
block|}
if|if
condition|(
name|poly_npts
condition|)
block|{
name|pts_tmp
operator|=
name|poly
operator|->
name|pts
expr_stmt|;
name|xs
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
index|[
name|poly_npts
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|ys
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
index|[
name|poly_npts
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|y
expr_stmt|;
name|xs
operator|*=
name|supersample
expr_stmt|;
name|ys
operator|*=
name|supersample
expr_stmt|;
name|xe
operator|*=
name|supersample
expr_stmt|;
name|ye
operator|*=
name|supersample
expr_stmt|;
name|convert_segment
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|,
name|min_y
operator|*
name|supersample
argument_list|,
name|min_scanlines
argument_list|,
name|max_scanlines
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|poly_npts
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|x
expr_stmt|;
name|ys
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|y
expr_stmt|;
name|pts_tmp
operator|++
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|pts_tmp
operator|->
name|y
expr_stmt|;
name|xs
operator|*=
name|supersample
expr_stmt|;
name|ys
operator|*=
name|supersample
expr_stmt|;
name|xe
operator|*=
name|supersample
expr_stmt|;
name|ye
operator|*=
name|supersample
expr_stmt|;
name|convert_segment
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|,
name|min_y
operator|*
name|supersample
argument_list|,
name|min_scanlines
argument_list|,
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|dest
operator|==
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|vals
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
operator|,
name|min_scanlines_iter
operator|++
operator|,
name|max_scanlines_iter
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|supersample
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gint
argument_list|)
operator|*
name|size_x
argument_list|)
expr_stmt|;
name|yy
operator|=
operator|(
name|gdouble
operator|)
name|i
operator|/
operator|(
name|gdouble
operator|)
name|supersample
operator|+
name|min_y
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|*
name|min_scanlines_iter
init|;
name|j
operator|<
operator|*
name|max_scanlines_iter
condition|;
name|j
operator|++
control|)
block|{
name|x
operator|=
name|j
operator|-
name|min_x
operator|*
name|supersample
expr_stmt|;
name|vals
index|[
name|x
index|]
operator|+=
literal|255
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|supersample
operator|)
condition|)
block|{
name|y
operator|=
operator|(
name|i
operator|/
name|supersample
operator|)
operator|+
name|min_y
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|y1
operator|&&
name|y
operator|<
name|y2
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size_x
condition|;
name|j
operator|+=
name|supersample
control|)
block|{
name|x
operator|=
operator|(
name|j
operator|/
name|supersample
operator|)
operator|+
name|min_x
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|x1
operator|&&
name|x
operator|<
name|x2
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|supersample
condition|;
name|k
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|k
index|]
expr_stmt|;
name|val
operator|/=
name|supersample2
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
name|xx
operator|=
operator|(
name|gdouble
operator|)
name|j
operator|/
operator|(
name|gdouble
operator|)
name|supersample
operator|+
name|min_x
expr_stmt|;
name|contrib
operator|=
name|calc_spec_contrib
argument_list|(
name|vecs
argument_list|,
name|poly_npts
argument_list|,
name|xx
argument_list|,
name|yy
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
name|pixel
operator|=
name|col
index|[
name|b
index|]
operator|+
call|(
name|gint
call|)
argument_list|(
operator|(
operator|(
name|contrib
operator|<
literal|0.0
operator|)
condition|?
operator|(
name|col
index|[
name|b
index|]
operator|-
name|back
index|[
name|b
index|]
operator|)
else|:
operator|(
name|fore
index|[
name|b
index|]
operator|-
name|col
index|[
name|b
index|]
operator|)
operator|)
operator|*
name|contrib
argument_list|)
expr_stmt|;
name|buf
index|[
name|b
index|]
operator|=
operator|(
operator|(
name|pixel
operator|*
name|val
operator|)
operator|+
operator|(
name|back
index|[
name|b
index|]
operator|*
operator|(
literal|255
operator|-
name|val
operator|)
operator|)
operator|)
operator|/
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|dest
condition|)
name|memcpy
argument_list|(
name|dest
operator|+
operator|(
operator|(
name|y
operator|-
name|y1
operator|)
operator|*
operator|(
name|x2
operator|-
name|x1
operator|)
operator|+
operator|(
name|x
operator|-
name|x1
operator|)
operator|)
operator|*
name|bytes
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
else|else
name|gimp_pixel_rgn_set_pixel
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|buf
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|min_scanlines
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|fill_poly_image (Polygon * poly,GimpDrawable * drawable,gdouble vary,gint x1,gint y1,gint x2,gint y2,guchar * dest)
name|fill_poly_image
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gdouble
name|vary
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|guchar
modifier|*
name|dest
parameter_list|)
block|{
name|GimpPixelRgn
name|src_rgn
decl_stmt|,
name|dest_rgn
decl_stmt|;
name|gdouble
name|dmin_x
init|=
literal|0.0
decl_stmt|,
name|dmin_y
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|dmax_x
init|=
literal|0.0
decl_stmt|,
name|dmax_y
init|=
literal|0.0
decl_stmt|;
name|gint
name|xs
decl_stmt|,
name|ys
decl_stmt|;
name|gint
name|xe
decl_stmt|,
name|ye
decl_stmt|;
name|gint
name|min_x
decl_stmt|,
name|min_y
decl_stmt|;
name|gint
name|max_x
decl_stmt|,
name|max_y
decl_stmt|;
name|gint
name|size_x
decl_stmt|,
name|size_y
decl_stmt|;
name|gint
modifier|*
name|max_scanlines
decl_stmt|;
name|gint
modifier|*
name|min_scanlines
decl_stmt|;
name|gint
modifier|*
name|vals
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|gint
name|pixel
decl_stmt|;
name|gint
name|bytes
decl_stmt|;
name|guchar
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|b
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdouble
name|contrib
decl_stmt|;
name|gdouble
name|xx
decl_stmt|,
name|yy
decl_stmt|;
name|gint
name|supersample
decl_stmt|;
name|gint
name|supersample2
decl_stmt|;
comment|/*  Determine antialiasing  */
if|if
condition|(
name|mvals
operator|.
name|antialiasing
condition|)
block|{
name|supersample
operator|=
name|SUPERSAMPLE
expr_stmt|;
name|supersample2
operator|=
name|SQR
argument_list|(
name|supersample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supersample
operator|=
name|supersample2
operator|=
literal|1
expr_stmt|;
block|}
name|bytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|x
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|y
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|calc_spec_vec
argument_list|(
name|vecs
operator|+
name|i
argument_list|,
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
name|polygon_extents
argument_list|(
name|poly
argument_list|,
operator|&
name|dmin_x
argument_list|,
operator|&
name|dmin_y
argument_list|,
operator|&
name|dmax_x
argument_list|,
operator|&
name|dmax_y
argument_list|)
expr_stmt|;
name|min_x
operator|=
operator|(
name|gint
operator|)
name|dmin_x
expr_stmt|;
name|min_y
operator|=
operator|(
name|gint
operator|)
name|dmin_y
expr_stmt|;
name|max_x
operator|=
operator|(
name|gint
operator|)
name|dmax_x
expr_stmt|;
name|max_y
operator|=
operator|(
name|gint
operator|)
name|dmax_y
expr_stmt|;
name|size_y
operator|=
operator|(
name|max_y
operator|-
name|min_y
operator|)
operator|*
name|supersample
expr_stmt|;
name|size_x
operator|=
operator|(
name|max_x
operator|-
name|min_x
operator|)
operator|*
name|supersample
expr_stmt|;
name|min_scanlines
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
name|max_scanlines
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
name|min_scanlines
index|[
name|i
index|]
operator|=
name|max_x
operator|*
name|supersample
expr_stmt|;
name|max_scanlines
index|[
name|i
index|]
operator|=
name|min_x
operator|*
name|supersample
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|xs
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|x
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|i
operator|)
condition|?
name|poly
operator|->
name|pts
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|y
else|:
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|xe
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|ye
operator|=
operator|(
name|gint
operator|)
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|xs
operator|*=
name|supersample
expr_stmt|;
name|ys
operator|*=
name|supersample
expr_stmt|;
name|xe
operator|*=
name|supersample
expr_stmt|;
name|ye
operator|*=
name|supersample
expr_stmt|;
name|convert_segment
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|,
name|min_y
operator|*
name|supersample
argument_list|,
name|min_scanlines
argument_list|,
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|vals
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
name|size_x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_y
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|supersample
operator|)
condition|)
name|memset
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gint
argument_list|)
operator|*
name|size_x
argument_list|)
expr_stmt|;
name|yy
operator|=
operator|(
name|gdouble
operator|)
name|i
operator|/
operator|(
name|gdouble
operator|)
name|supersample
operator|+
name|min_y
expr_stmt|;
for|for
control|(
name|j
operator|=
name|min_scanlines
index|[
name|i
index|]
init|;
name|j
operator|<
name|max_scanlines
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|x
operator|=
name|j
operator|-
name|min_x
operator|*
name|supersample
expr_stmt|;
name|vals
index|[
name|x
index|]
operator|+=
literal|255
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|supersample
operator|)
condition|)
block|{
name|y
operator|=
operator|(
name|i
operator|/
name|supersample
operator|)
operator|+
name|min_y
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|y1
operator|&&
name|y
operator|<
name|y2
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size_x
condition|;
name|j
operator|+=
name|supersample
control|)
block|{
name|x
operator|=
operator|(
name|j
operator|/
name|supersample
operator|)
operator|+
name|min_x
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|x1
operator|&&
name|x
operator|<
name|x2
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|supersample
condition|;
name|k
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|j
operator|+
name|k
index|]
expr_stmt|;
name|val
operator|/=
name|supersample2
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
name|xx
operator|=
operator|(
name|double
operator|)
name|j
operator|/
operator|(
name|double
operator|)
name|supersample
operator|+
name|min_x
expr_stmt|;
name|contrib
operator|=
name|calc_spec_contrib
argument_list|(
name|vecs
argument_list|,
name|poly
operator|->
name|npts
argument_list|,
name|xx
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_pixel
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|buf
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|contrib
operator|<
literal|0.0
condition|)
name|pixel
operator|=
name|buf
index|[
name|b
index|]
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|buf
index|[
name|b
index|]
operator|-
name|back
index|[
name|b
index|]
operator|)
operator|*
name|contrib
argument_list|)
expr_stmt|;
else|else
name|pixel
operator|=
name|buf
index|[
name|b
index|]
operator|+
call|(
name|int
call|)
argument_list|(
operator|(
name|fore
index|[
name|b
index|]
operator|-
name|buf
index|[
name|b
index|]
operator|)
operator|*
name|contrib
argument_list|)
expr_stmt|;
comment|/*  factor in per-tile intensity variation  */
name|pixel
operator|+=
name|vary
expr_stmt|;
name|pixel
operator|=
name|CLAMP
argument_list|(
name|pixel
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|buf
index|[
name|b
index|]
operator|=
operator|(
operator|(
name|back
index|[
name|b
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|pixel
operator|-
name|back
index|[
name|b
index|]
operator|)
operator|*
name|val
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|dest
condition|)
name|memcpy
argument_list|(
name|dest
operator|+
operator|(
operator|(
name|y
operator|-
name|y1
operator|)
operator|*
operator|(
name|x2
operator|-
name|x1
operator|)
operator|+
operator|(
name|x
operator|-
name|x1
operator|)
operator|)
operator|*
name|bytes
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
else|else
name|gimp_pixel_rgn_set_pixel
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|buf
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|g_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|min_scanlines
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|max_scanlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calc_spec_vec (SpecVec * vec,gint x1,gint y1,gint x2,gint y2)
name|calc_spec_vec
parameter_list|(
name|SpecVec
modifier|*
name|vec
parameter_list|,
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|)
block|{
name|gdouble
name|r
decl_stmt|;
name|vec
operator|->
name|base_x
operator|=
name|x1
expr_stmt|;
name|vec
operator|->
name|base_y
operator|=
name|y1
expr_stmt|;
name|r
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
operator|+
name|SQR
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0.0
condition|)
block|{
name|vec
operator|->
name|norm_x
operator|=
operator|-
operator|(
name|y2
operator|-
name|y1
operator|)
operator|/
name|r
expr_stmt|;
name|vec
operator|->
name|norm_y
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|/
name|r
expr_stmt|;
block|}
else|else
block|{
name|vec
operator|->
name|norm_x
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|norm_y
operator|=
literal|0
expr_stmt|;
block|}
name|vec
operator|->
name|light
operator|=
name|vec
operator|->
name|norm_x
operator|*
name|light_x
operator|+
name|vec
operator|->
name|norm_y
operator|*
name|light_y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|double
DECL|function|calc_spec_contrib (SpecVec * vecs,gint n,gdouble x,gdouble y)
name|calc_spec_contrib
parameter_list|(
name|SpecVec
modifier|*
name|vecs
parameter_list|,
name|gint
name|n
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|contrib
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|gdouble
name|x_p
decl_stmt|,
name|y_p
decl_stmt|;
name|gdouble
name|dist
decl_stmt|;
name|x_p
operator|=
name|x
operator|-
name|vecs
index|[
name|i
index|]
operator|.
name|base_x
expr_stmt|;
name|y_p
operator|=
name|y
operator|-
name|vecs
index|[
name|i
index|]
operator|.
name|base_y
expr_stmt|;
name|dist
operator|=
name|fabs
argument_list|(
name|x_p
operator|*
name|vecs
index|[
name|i
index|]
operator|.
name|norm_x
operator|+
name|y_p
operator|*
name|vecs
index|[
name|i
index|]
operator|.
name|norm_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvals
operator|.
name|tile_surface
operator|==
name|ROUGH
condition|)
block|{
comment|/*  If the surface is rough, randomly perturb the distance  */
name|dist
operator|-=
name|dist
operator|*
name|g_random_double
argument_list|()
expr_stmt|;
block|}
comment|/*  If the distance to an edge is less than the tile_spacing, there        *  will be no highlight as the tile blends to background here        */
if|if
condition|(
name|dist
operator|<
literal|1.0
condition|)
name|contrib
operator|+=
name|vecs
index|[
name|i
index|]
operator|.
name|light
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<=
name|mvals
operator|.
name|tile_height
condition|)
name|contrib
operator|+=
name|vecs
index|[
name|i
index|]
operator|.
name|light
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|dist
operator|/
name|mvals
operator|.
name|tile_height
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|contrib
operator|/
literal|4.0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|convert_segment (gint x1,gint y1,gint x2,gint y2,gint offset,gint * min,gint * max)
name|convert_segment
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|y1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y2
parameter_list|,
name|gint
name|offset
parameter_list|,
name|gint
modifier|*
name|min
parameter_list|,
name|gint
modifier|*
name|max
parameter_list|)
block|{
name|gint
name|ydiff
decl_stmt|,
name|y
decl_stmt|,
name|tmp
decl_stmt|;
name|gdouble
name|xinc
decl_stmt|,
name|xstart
decl_stmt|;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
expr_stmt|;
name|y1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|tmp
expr_stmt|;
block|}
name|ydiff
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
if|if
condition|(
name|ydiff
condition|)
block|{
name|xinc
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|ydiff
expr_stmt|;
name|xstart
operator|=
name|x1
operator|+
literal|0.5
operator|*
name|xinc
expr_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<
name|y2
condition|;
name|y
operator|++
control|)
block|{
name|min
index|[
name|y
operator|-
name|offset
index|]
operator|=
name|MIN
argument_list|(
name|min
index|[
name|y
operator|-
name|offset
index|]
argument_list|,
name|xstart
argument_list|)
expr_stmt|;
name|max
index|[
name|y
operator|-
name|offset
index|]
operator|=
name|MAX
argument_list|(
name|max
index|[
name|y
operator|-
name|offset
index|]
argument_list|,
name|xstart
argument_list|)
expr_stmt|;
name|xstart
operator|+=
name|xinc
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|polygon_add_point (Polygon * poly,gdouble x,gdouble y)
name|polygon_add_point
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
if|if
condition|(
name|poly
operator|->
name|npts
operator|<
literal|12
condition|)
block|{
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|poly
operator|->
name|pts
index|[
name|poly
operator|->
name|npts
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|poly
operator|->
name|npts
operator|++
expr_stmt|;
block|}
else|else
block|{
name|g_warning
argument_list|(
literal|"can't add more points"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|polygon_find_center (Polygon * poly,gdouble * cx,gdouble * cy)
name|polygon_find_center
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
modifier|*
name|cx
parameter_list|,
name|gdouble
modifier|*
name|cy
parameter_list|)
block|{
name|guint
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|poly
operator|->
name|npts
condition|)
return|return
name|FALSE
return|;
operator|*
name|cx
operator|=
literal|0.0
expr_stmt|;
operator|*
name|cy
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cx
operator|+=
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
operator|*
name|cy
operator|+=
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
operator|*
name|cx
operator|/=
name|poly
operator|->
name|npts
expr_stmt|;
operator|*
name|cy
operator|/=
name|poly
operator|->
name|npts
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|polygon_translate (Polygon * poly,gdouble tx,gdouble ty)
name|polygon_translate
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|tx
parameter_list|,
name|gdouble
name|ty
parameter_list|)
block|{
name|guint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|tx
expr_stmt|;
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|+=
name|ty
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|polygon_scale (Polygon * poly,gdouble poly_scale)
name|polygon_scale
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
name|poly_scale
parameter_list|)
block|{
name|guint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
operator|*=
name|poly_scale
expr_stmt|;
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
operator|*=
name|poly_scale
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|polygon_extents (Polygon * poly,gdouble * min_x,gdouble * min_y,gdouble * max_x,gdouble * max_y)
name|polygon_extents
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|,
name|gdouble
modifier|*
name|min_x
parameter_list|,
name|gdouble
modifier|*
name|min_y
parameter_list|,
name|gdouble
modifier|*
name|max_x
parameter_list|,
name|gdouble
modifier|*
name|max_y
parameter_list|)
block|{
name|guint
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|poly
operator|->
name|npts
condition|)
return|return
name|FALSE
return|;
operator|*
name|min_x
operator|=
operator|*
name|max_x
operator|=
name|poly
operator|->
name|pts
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
operator|*
name|min_y
operator|=
operator|*
name|max_y
operator|=
name|poly
operator|->
name|pts
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|poly
operator|->
name|npts
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|min_x
operator|=
name|MIN
argument_list|(
operator|*
name|min_x
argument_list|,
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
operator|*
name|max_x
operator|=
name|MAX
argument_list|(
operator|*
name|max_x
argument_list|,
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
operator|*
name|min_y
operator|=
name|MIN
argument_list|(
operator|*
name|min_y
argument_list|,
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|max_y
operator|=
name|MAX
argument_list|(
operator|*
name|max_y
argument_list|,
name|poly
operator|->
name|pts
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|polygon_reset (Polygon * poly)
name|polygon_reset
parameter_list|(
name|Polygon
modifier|*
name|poly
parameter_list|)
block|{
name|poly
operator|->
name|npts
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

