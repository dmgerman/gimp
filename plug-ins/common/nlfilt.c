begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************  * file: nlfilt/nlfilt.c  *  * Copyright (c) 1997 Eric L. Hernes (erich@rrnet.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id$  */
end_comment

begin_comment
comment|/*  * Algorithm fixes, V2.0 compatibility by David Hodson  hodsond@ozemail.com.au  */
end_comment

begin_comment
comment|/* add any necessary includes  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_warning
warning|#
directive|warning
warning|GTK_DISABLE_DEPRECATED
end_warning

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|GTK_DISABLE_DEPRECATED
end_undef

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_struct
DECL|struct|Grgb
struct|struct
name|Grgb
block|{
DECL|member|red
name|guint8
name|red
decl_stmt|;
DECL|member|green
name|guint8
name|green
decl_stmt|;
DECL|member|blue
name|guint8
name|blue
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|GRegion
struct|struct
name|GRegion
block|{
DECL|member|x
name|gint32
name|x
decl_stmt|;
DECL|member|y
name|gint32
name|y
decl_stmt|;
DECL|member|width
name|gint32
name|width
decl_stmt|;
DECL|member|height
name|gint32
name|height
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|piArgs
struct|struct
name|piArgs
block|{
DECL|member|img
name|gint32
name|img
decl_stmt|;
DECL|member|drw
name|gint32
name|drw
decl_stmt|;
DECL|member|alpha
name|gdouble
name|alpha
decl_stmt|;
DECL|member|radius
name|gdouble
name|radius
decl_stmt|;
DECL|member|filter
name|gint
name|filter
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon29ac6a5d0103
block|{
DECL|enumerator|filter_alpha_trim
name|filter_alpha_trim
block|,
DECL|enumerator|filter_opt_est
name|filter_opt_est
block|,
DECL|enumerator|filter_edge_enhance
name|filter_edge_enhance
DECL|typedef|FilterType
block|}
name|FilterType
typedef|;
end_typedef

begin_comment
comment|/*  preview stuff -- to be removed as soon as we have a real libgimp preview  */
end_comment

begin_struct
DECL|struct|mwPreview
struct|struct
name|mwPreview
block|{
DECL|member|width
name|gint
name|width
decl_stmt|;
DECL|member|height
name|gint
name|height
decl_stmt|;
DECL|member|bpp
name|gint
name|bpp
decl_stmt|;
DECL|member|scale
name|gdouble
name|scale
decl_stmt|;
DECL|member|bits
name|guchar
modifier|*
name|bits
decl_stmt|;
block|}
struct|;
end_struct

begin_define
DECL|macro|PREVIEW_SIZE
define|#
directive|define
name|PREVIEW_SIZE
value|100
end_define

begin_decl_stmt
DECL|variable|do_preview
specifier|static
name|gint
name|do_preview
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|thePreview
specifier|static
name|struct
name|mwPreview
modifier|*
name|thePreview
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GtkWidget
modifier|*
name|mw_preview_new
parameter_list|(
name|GtkWidget
modifier|*
name|parent
parameter_list|,
name|struct
name|mwPreview
modifier|*
name|mwp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mwPreview
modifier|*
name|mw_preview_build
parameter_list|(
name|GimpDrawable
modifier|*
name|drw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* function protos */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|retvals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|pluginCore
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|pluginCoreIA
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlfilt_do_preview
parameter_list|(
name|GtkWidget
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gint
name|nlfiltInit
parameter_list|(
name|gdouble
name|alpha
parameter_list|,
name|gdouble
name|radius
parameter_list|,
name|FilterType
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|nlfiltRow
parameter_list|(
name|guchar
modifier|*
name|srclast
parameter_list|,
name|guchar
modifier|*
name|srcthis
parameter_list|,
name|guchar
modifier|*
name|srcnext
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|Bpp
parameter_list|,
name|gint
name|filtno
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GimpParamDef
name|args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"img"
block|,
literal|"The Image to Filter"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drw"
block|,
literal|"The Drawable"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"alpha"
block|,
literal|"The amount of the filter to apply"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"radius"
block|,
literal|"The filter radius"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"filter"
block|,
literal|"The Filter to Run, 0 - alpha trimmed mean; 1 - optimal estimation (alpha controls noise variance); 2 - edge enhancement"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_nlfilt"
argument_list|,
literal|"Nonlinear swiss army knife filter"
argument_list|,
literal|"This is the pnmnlfilt, in gimp's clothing.  See the pnmnlfilt manpage for details."
argument_list|,
literal|"Graeme W. Gill, gimp 0.99 plugin by Eric L. Hernes"
argument_list|,
literal|"Graeme W. Gill, Eric L. Hernes"
argument_list|,
literal|"1997"
argument_list|,
name|N_
argument_list|(
literal|"<Image>/Filters/Enhance/NL Filter..."
argument_list|)
argument_list|,
literal|"RGB,GRAY"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparam,GimpParam * param,gint * nretvals,GimpParam ** retvals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparam
parameter_list|,
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nretvals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|retvals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|rvals
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|piArgs
name|args
decl_stmt|;
operator|*
name|nretvals
operator|=
literal|1
expr_stmt|;
operator|*
name|retvals
operator|=
name|rvals
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
operator|(
name|int
operator|)
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|piArgs
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|radius
operator|=
operator|-
literal|1.0
expr_stmt|;
name|gimp_get_data
argument_list|(
literal|"plug_in_nlfilt"
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|img
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
expr_stmt|;
name|args
operator|.
name|drw
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
expr_stmt|;
name|rvals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
condition|)
block|{
name|GimpDrawable
modifier|*
name|drw
decl_stmt|;
case|case
name|GIMP_RUN_INTERACTIVE
case|:
name|INIT_I18N_UI
argument_list|()
expr_stmt|;
comment|/* XXX: add code here for interactive running */
if|if
condition|(
name|args
operator|.
name|radius
operator|==
operator|-
literal|1
condition|)
block|{
name|args
operator|.
name|alpha
operator|=
operator|(
name|gdouble
operator|)
literal|0.3
expr_stmt|;
name|args
operator|.
name|radius
operator|=
operator|(
name|gdouble
operator|)
literal|0.3
expr_stmt|;
name|args
operator|.
name|filter
operator|=
literal|0
expr_stmt|;
block|}
name|drw
operator|=
name|gimp_drawable_get
argument_list|(
name|args
operator|.
name|drw
argument_list|)
expr_stmt|;
name|thePreview
operator|=
name|mw_preview_build
argument_list|(
name|drw
argument_list|)
expr_stmt|;
if|if
condition|(
name|pluginCoreIA
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
else|else
block|{
name|gimp_set_data
argument_list|(
literal|"plug_in_nlfilt"
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|piArgs
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
name|INIT_I18N
argument_list|()
expr_stmt|;
comment|/* XXX: add code here for non-interactive running */
if|if
condition|(
name|nparam
operator|!=
literal|6
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|alpha
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|args
operator|.
name|radius
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|args
operator|.
name|filter
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|INIT_I18N
argument_list|()
expr_stmt|;
comment|/* XXX: add code here for last-values running */
if|if
condition|(
name|pluginCore
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|pluginCore (struct piArgs * argp)
name|pluginCore
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
block|{
name|GimpDrawable
modifier|*
name|drw
decl_stmt|;
name|GimpPixelRgn
name|srcPr
decl_stmt|,
name|dstPr
decl_stmt|;
name|guchar
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|dstbuf
decl_stmt|;
name|guchar
modifier|*
name|lastrow
decl_stmt|,
modifier|*
name|thisrow
decl_stmt|,
modifier|*
name|nextrow
decl_stmt|,
modifier|*
name|temprow
decl_stmt|;
name|guint
name|width
decl_stmt|,
name|height
decl_stmt|,
name|Bpp
decl_stmt|;
name|gint
name|filtno
decl_stmt|,
name|y
decl_stmt|,
name|rowsize
decl_stmt|,
name|exrowsize
decl_stmt|,
name|p_update
decl_stmt|;
name|drw
operator|=
name|gimp_drawable_get
argument_list|(
name|argp
operator|->
name|drw
argument_list|)
expr_stmt|;
name|width
operator|=
name|drw
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|drw
operator|->
name|height
expr_stmt|;
name|Bpp
operator|=
name|drw
operator|->
name|bpp
expr_stmt|;
name|rowsize
operator|=
name|width
operator|*
name|Bpp
expr_stmt|;
name|exrowsize
operator|=
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
name|Bpp
expr_stmt|;
name|p_update
operator|=
name|width
operator|/
literal|20
operator|+
literal|1
expr_stmt|;
name|gimp_tile_cache_ntiles
argument_list|(
literal|2
operator|*
operator|(
name|width
operator|/
name|gimp_tile_width
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|srcPr
argument_list|,
name|drw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dstPr
argument_list|,
name|drw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* source buffer gives one pixel margin all around destination buffer */
name|srcbuf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|exrowsize
operator|*
literal|3
argument_list|)
expr_stmt|;
name|dstbuf
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|rowsize
argument_list|)
expr_stmt|;
comment|/* pointers to second pixel in each source row */
name|lastrow
operator|=
name|srcbuf
operator|+
name|Bpp
expr_stmt|;
name|thisrow
operator|=
name|lastrow
operator|+
name|exrowsize
expr_stmt|;
name|nextrow
operator|=
name|thisrow
operator|+
name|exrowsize
expr_stmt|;
name|filtno
operator|=
name|nlfiltInit
argument_list|(
name|argp
operator|->
name|alpha
argument_list|,
name|argp
operator|->
name|radius
argument_list|,
name|argp
operator|->
name|filter
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"NL Filter"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first row */
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|srcPr
argument_list|,
name|thisrow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* copy thisrow[0] to thisrow[-1], thisrow[width-1] to thisrow[width] */
name|memcpy
argument_list|(
name|thisrow
operator|-
name|Bpp
argument_list|,
name|thisrow
argument_list|,
name|Bpp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|thisrow
operator|+
name|rowsize
argument_list|,
name|thisrow
operator|+
name|rowsize
operator|-
name|Bpp
argument_list|,
name|Bpp
argument_list|)
expr_stmt|;
comment|/* copy whole thisrow to lastrow */
name|memcpy
argument_list|(
name|lastrow
operator|-
name|Bpp
argument_list|,
name|thisrow
operator|-
name|Bpp
argument_list|,
name|exrowsize
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|%
name|p_update
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|y
operator|/
operator|(
name|gdouble
operator|)
name|height
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|srcPr
argument_list|,
name|nextrow
argument_list|,
literal|0
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nextrow
operator|-
name|Bpp
argument_list|,
name|nextrow
argument_list|,
name|Bpp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nextrow
operator|+
name|rowsize
argument_list|,
name|nextrow
operator|+
name|rowsize
operator|-
name|Bpp
argument_list|,
name|Bpp
argument_list|)
expr_stmt|;
name|nlfiltRow
argument_list|(
name|lastrow
argument_list|,
name|thisrow
argument_list|,
name|nextrow
argument_list|,
name|dstbuf
argument_list|,
name|width
argument_list|,
name|Bpp
argument_list|,
name|filtno
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_row
argument_list|(
operator|&
name|dstPr
argument_list|,
name|dstbuf
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* rotate row buffers */
name|temprow
operator|=
name|lastrow
expr_stmt|;
name|lastrow
operator|=
name|thisrow
expr_stmt|;
name|thisrow
operator|=
name|nextrow
expr_stmt|;
name|nextrow
operator|=
name|temprow
expr_stmt|;
block|}
comment|/* last row */
name|memcpy
argument_list|(
name|nextrow
operator|-
name|Bpp
argument_list|,
name|thisrow
operator|-
name|Bpp
argument_list|,
name|exrowsize
argument_list|)
expr_stmt|;
name|nlfiltRow
argument_list|(
name|lastrow
argument_list|,
name|thisrow
argument_list|,
name|nextrow
argument_list|,
name|dstbuf
argument_list|,
name|width
argument_list|,
name|Bpp
argument_list|,
name|filtno
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_row
argument_list|(
operator|&
name|dstPr
argument_list|,
name|dstbuf
argument_list|,
literal|0
argument_list|,
name|height
operator|-
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|srcbuf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dstbuf
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drw
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drw
operator|->
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drw
operator|->
name|drawable_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimp_displays_flush
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|run_flag
name|gboolean
name|run_flag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|nlfilt_ok_callback (GtkWidget * widget,gpointer data)
name|nlfilt_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|run_flag
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|nlfilt_radio_button_update (GtkWidget * widget,gpointer data)
name|nlfilt_radio_button_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gimp_radio_button_update
argument_list|(
name|widget
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_preview
operator|&&
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
condition|)
name|nlfilt_do_preview
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|nlfilt_double_adjustment_update (GtkAdjustment * adjustment,gpointer data)
name|nlfilt_double_adjustment_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gimp_double_adjustment_update
argument_list|(
name|adjustment
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_preview
condition|)
name|nlfilt_do_preview
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|pluginCoreIA (struct piArgs * argp)
name|pluginCoreIA
parameter_list|(
name|struct
name|piArgs
modifier|*
name|argp
parameter_list|)
block|{
name|gint
name|retval
init|=
operator|-
literal|1
decl_stmt|;
comment|/* default to error return */
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|main_vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkObject
modifier|*
name|adj
decl_stmt|;
name|gimp_ui_init
argument_list|(
literal|"nlfilt"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"NL Filter"
argument_list|)
argument_list|,
literal|"nlfilt"
argument_list|,
name|gimp_standard_help_func
argument_list|,
literal|"filters/nlfilt.html"
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|gtk_widget_destroy
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|nlfilt_ok_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|G_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gtk_main_quit
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|main_vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|main_vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|main_vbox
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|preview
operator|=
name|mw_preview_new
argument_list|(
name|hbox
argument_list|,
name|thePreview
argument_list|)
expr_stmt|;
name|g_object_set_data
argument_list|(
name|G_OBJECT
argument_list|(
name|preview
argument_list|)
argument_list|,
literal|"piArgs"
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|nlfilt_do_preview
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gimp_radio_group_new2
argument_list|(
name|TRUE
argument_list|,
name|_
argument_list|(
literal|"Filter"
argument_list|)
argument_list|,
name|G_CALLBACK
argument_list|(
name|nlfilt_radio_button_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|filter
argument_list|,
operator|(
name|gpointer
operator|)
name|argp
operator|->
name|filter
argument_list|,
name|_
argument_list|(
literal|"Alpha Trimmed Mean"
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|filter_alpha_trim
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Optimal Estimation"
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|filter_opt_est
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Edge Enhancement"
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|filter_edge_enhance
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|_
argument_list|(
literal|"Parameter Settings"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Alpha:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|alpha
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.05
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|G_OBJECT
argument_list|(
name|adj
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|nlfilt_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"Radius:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|radius
argument_list|,
literal|1.0
operator|/
literal|3.0
argument_list|,
literal|1.0
argument_list|,
literal|0.05
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|G_OBJECT
argument_list|(
name|adj
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|nlfilt_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|argp
operator|->
name|radius
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|run_flag
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (stderr, "running:\n");       fprintf (stderr, "\t(image %d)\n", argp->img);       fprintf (stderr, "\t(drawable %d)\n", argp->drw);       fprintf (stderr, "\t(alpha %f)\n", argp->alpha);       fprintf (stderr, "\t(radius %f)\n", argp->radius);
endif|#
directive|endif
return|return
name|pluginCore
argument_list|(
name|argp
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|retval
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|nlfilt_do_preview (GtkWidget * w)
name|nlfilt_do_preview
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|)
block|{
specifier|static
name|GtkWidget
modifier|*
name|theWidget
init|=
name|NULL
decl_stmt|;
name|struct
name|piArgs
modifier|*
name|ap
decl_stmt|;
name|guchar
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src0
decl_stmt|,
modifier|*
name|src1
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|gint
name|y
decl_stmt|,
name|rowsize
decl_stmt|,
name|filtno
decl_stmt|;
if|if
condition|(
name|theWidget
operator|==
name|NULL
condition|)
block|{
name|theWidget
operator|=
name|w
expr_stmt|;
block|}
name|ap
operator|=
name|g_object_get_data
argument_list|(
name|G_OBJECT
argument_list|(
name|theWidget
argument_list|)
argument_list|,
literal|"piArgs"
argument_list|)
expr_stmt|;
name|rowsize
operator|=
name|thePreview
operator|->
name|width
operator|*
name|thePreview
operator|->
name|bpp
expr_stmt|;
name|filtno
operator|=
name|nlfiltInit
argument_list|(
name|ap
operator|->
name|alpha
argument_list|,
name|ap
operator|->
name|radius
argument_list|,
name|ap
operator|->
name|filter
argument_list|)
expr_stmt|;
name|src0
operator|=
name|thePreview
operator|->
name|bits
operator|+
name|thePreview
operator|->
name|bpp
expr_stmt|;
name|src1
operator|=
name|src0
operator|+
name|rowsize
expr_stmt|;
name|src2
operator|=
name|src1
operator|+
name|rowsize
expr_stmt|;
name|dst
operator|=
name|g_malloc
argument_list|(
name|rowsize
argument_list|)
expr_stmt|;
comment|/* for preview, don't worry about edge effects */
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<
name|thePreview
operator|->
name|height
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
name|nlfiltRow
argument_list|(
name|src0
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|,
name|dst
operator|+
name|thePreview
operator|->
name|bpp
argument_list|,
name|thePreview
operator|->
name|width
operator|-
literal|2
argument_list|,
name|thePreview
operator|->
name|bpp
argument_list|,
name|filtno
argument_list|)
expr_stmt|;
name|gtk_preview_draw_row
argument_list|(
name|GTK_PREVIEW
argument_list|(
name|theWidget
argument_list|)
argument_list|,
name|dst
operator|+
name|thePreview
operator|->
name|bpp
argument_list|,
literal|1
argument_list|,
name|y
argument_list|,
name|thePreview
operator|->
name|width
operator|-
literal|2
argument_list|)
expr_stmt|;
name|src0
operator|=
name|src1
expr_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src2
operator|+=
name|rowsize
expr_stmt|;
block|}
name|gtk_widget_queue_draw
argument_list|(
name|theWidget
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|mw_preview_toggle_callback (GtkWidget * widget,gpointer data)
name|mw_preview_toggle_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gimp_toggle_button_update
argument_list|(
name|widget
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_preview
condition|)
name|nlfilt_do_preview
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mwPreview
modifier|*
DECL|function|mw_preview_build_virgin (GimpDrawable * drw)
name|mw_preview_build_virgin
parameter_list|(
name|GimpDrawable
modifier|*
name|drw
parameter_list|)
block|{
name|struct
name|mwPreview
modifier|*
name|mwp
decl_stmt|;
name|mwp
operator|=
name|g_new
argument_list|(
expr|struct
name|mwPreview
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|drw
operator|->
name|width
operator|>
name|drw
operator|->
name|height
condition|)
block|{
name|mwp
operator|->
name|scale
operator|=
operator|(
name|gdouble
operator|)
name|drw
operator|->
name|width
operator|/
operator|(
name|gdouble
operator|)
name|PREVIEW_SIZE
expr_stmt|;
name|mwp
operator|->
name|width
operator|=
name|PREVIEW_SIZE
expr_stmt|;
name|mwp
operator|->
name|height
operator|=
name|drw
operator|->
name|height
operator|/
name|mwp
operator|->
name|scale
expr_stmt|;
block|}
else|else
block|{
name|mwp
operator|->
name|scale
operator|=
operator|(
name|gdouble
operator|)
name|drw
operator|->
name|height
operator|/
operator|(
name|gdouble
operator|)
name|PREVIEW_SIZE
expr_stmt|;
name|mwp
operator|->
name|height
operator|=
name|PREVIEW_SIZE
expr_stmt|;
name|mwp
operator|->
name|width
operator|=
name|drw
operator|->
name|width
operator|/
name|mwp
operator|->
name|scale
expr_stmt|;
block|}
name|mwp
operator|->
name|bpp
operator|=
literal|3
expr_stmt|;
name|mwp
operator|->
name|bits
operator|=
name|NULL
expr_stmt|;
return|return
name|mwp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mwPreview
modifier|*
DECL|function|mw_preview_build (GimpDrawable * drw)
name|mw_preview_build
parameter_list|(
name|GimpDrawable
modifier|*
name|drw
parameter_list|)
block|{
name|struct
name|mwPreview
modifier|*
name|mwp
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|b
decl_stmt|;
name|guchar
modifier|*
name|bc
decl_stmt|;
name|guchar
modifier|*
name|drwBits
decl_stmt|;
name|GimpPixelRgn
name|pr
decl_stmt|;
name|mwp
operator|=
name|mw_preview_build_virgin
argument_list|(
name|drw
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pr
argument_list|,
name|drw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drw
operator|->
name|width
argument_list|,
name|drw
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|drwBits
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|drw
operator|->
name|width
operator|*
name|drw
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|bc
operator|=
name|mwp
operator|->
name|bits
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|mwp
operator|->
name|width
operator|*
name|mwp
operator|->
name|height
operator|*
name|mwp
operator|->
name|bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|mwp
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|pr
argument_list|,
name|drwBits
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|y
operator|*
name|mwp
operator|->
name|scale
argument_list|)
argument_list|,
name|drw
operator|->
name|width
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mwp
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|mwp
operator|->
name|bpp
condition|;
name|b
operator|++
control|)
operator|*
name|bc
operator|++
operator|=
operator|*
operator|(
name|drwBits
operator|+
operator|(
call|(
name|gint
call|)
argument_list|(
name|x
operator|*
name|mwp
operator|->
name|scale
argument_list|)
operator|*
name|drw
operator|->
name|bpp
operator|)
operator|+
name|b
operator|%
name|drw
operator|->
name|bpp
operator|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|drwBits
argument_list|)
expr_stmt|;
return|return
name|mwp
return|;
block|}
end_function

begin_function
specifier|static
name|GtkWidget
modifier|*
DECL|function|mw_preview_new (GtkWidget * parent,struct mwPreview * mwp)
name|mw_preview_new
parameter_list|(
name|GtkWidget
modifier|*
name|parent
parameter_list|,
name|struct
name|mwPreview
modifier|*
name|mwp
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|pframe
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|_
argument_list|(
literal|"Preview"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|parent
argument_list|)
argument_list|,
name|frame
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|pframe
operator|=
name|gtk_frame_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|pframe
argument_list|)
argument_list|,
name|GTK_SHADOW_IN
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|pframe
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|pframe
argument_list|)
expr_stmt|;
name|preview
operator|=
name|gtk_preview_new
argument_list|(
name|GTK_PREVIEW_COLOR
argument_list|)
expr_stmt|;
name|gtk_preview_size
argument_list|(
name|GTK_PREVIEW
argument_list|(
name|preview
argument_list|)
argument_list|,
name|mwp
operator|->
name|width
argument_list|,
name|mwp
operator|->
name|height
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|pframe
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"Do Preview"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|button
argument_list|)
argument_list|,
name|do_preview
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|button
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|G_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|mw_preview_toggle_callback
argument_list|)
argument_list|,
operator|&
name|do_preview
argument_list|)
expr_stmt|;
return|return
name|preview
return|;
block|}
end_function

begin_comment
comment|/* pnmnlfilt.c - 4 in 1 (2 non-linear) filter **             - smooth an anyimage **             - do alpha trimmed mean filtering on an anyimage **             - do optimal estimation smoothing on an anyimage **             - do edge enhancement on an anyimage ** ** Version 1.0 ** ** The implementation of an alpha-trimmed mean filter ** is based on the description in IEEE CG&A May 1990 ** Page 23 by Mark E. Lee and Richard A. Redner. ** ** The paper recommends using a hexagon sampling region around each ** pixel being processed, allowing an effective sub pixel radius to be ** specified. The hexagon values are sythesised by area sampling the ** rectangular pixels with a hexagon grid. The seven hexagon values ** obtained from the 3x3 pixel grid are used to compute the alpha ** trimmed mean. Note that an alpha value of 0.0 gives a conventional ** mean filter (where the radius controls the contribution of ** surrounding pixels), while a value of 0.5 gives a median filter. ** Although there are only seven values to trim from before finding ** the mean, the algorithm has been extended from that described in ** CG&A by using interpolation, to allow a continuous selection of ** alpha value between and including 0.0 to 0.5  The useful values ** for radius are between 0.3333333 (where the filter will have no ** effect because only one pixel is sampled), to 1.0, where all ** pixels in the 3x3 grid are sampled. ** ** The optimal estimation filter is taken from an article "Converting Dithered ** Images Back to Gray Scale" by Allen Stenger, Dr Dobb's Journal, November ** 1992, and this article references "Digital Image Enhancement andNoise Filtering by ** Use of Local Statistics", Jong-Sen Lee, IEEE Transactions on Pattern Analysis and ** Machine Intelligence, March 1980. ** ** Also borrow the  technique used in pgmenhance(1) to allow edge ** enhancement if the alpha value is negative. ** ** Author: **         Graeme W. Gill, 30th Jan 1993 **         graeme@labtam.oz.au ** ** Permission to use, copy, modify, and distribute this software and its ** documentation for any purpose and without fee is hereby granted, provided ** that the above copyright notice appear in all copies and that both that ** copyright notice and this permission notice appear in supporting ** documentation.  This software is provided "as is" without express or ** implied warranty. */
end_comment

begin_comment
comment|/* ************************************************** */
end_comment

begin_comment
comment|/* Hexagon intersecting square area functions */
end_comment

begin_comment
comment|/* Compute the area of the intersection of a triangle */
end_comment

begin_comment
comment|/* and a rectangle */
end_comment

begin_function_decl
name|gdouble
name|triang_area
parameter_list|(
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdouble
name|rectang_area
parameter_list|(
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdouble
name|hex_area
parameter_list|(
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|,
name|gdouble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gint
name|atfilt0
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gint
name|atfilt1
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gint
name|atfilt2
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gint
name|atfilt3
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gint
name|atfilt4
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gint
name|atfilt5
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
DECL|variable|atfuncs
name|gint
function_decl|(
modifier|*
name|atfuncs
index|[
literal|6
index|]
function_decl|)
parameter_list|(
name|gint
modifier|*
parameter_list|)
init|=
block|{
name|atfilt0
operator|,
function_decl|atfilt1
operator|,
function_decl|atfilt2
operator|,
function_decl|atfilt3
operator|,
function_decl|atfilt4
operator|,
function_decl|atfilt5
end_function_decl

begin_decl_stmt
unit|};
DECL|variable|noisevariance
name|gint
name|noisevariance
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|noisevariance
comment|/* global so that pixel processing code can get at it quickly */
end_comment

begin_define
DECL|macro|MXIVAL
define|#
directive|define
name|MXIVAL
value|255
end_define

begin_comment
DECL|macro|MXIVAL
comment|/* maximum input value */
end_comment

begin_define
DECL|macro|NOIVAL
define|#
directive|define
name|NOIVAL
value|(MXIVAL + 1)
end_define

begin_comment
DECL|macro|NOIVAL
comment|/* number of possible input values */
end_comment

begin_define
DECL|macro|SCALEB
define|#
directive|define
name|SCALEB
value|8
end_define

begin_comment
DECL|macro|SCALEB
comment|/* scale bits */
end_comment

begin_define
DECL|macro|SCALE
define|#
directive|define
name|SCALE
value|(1<< SCALEB)
end_define

begin_comment
DECL|macro|SCALE
comment|/* scale factor */
end_comment

begin_define
DECL|macro|MXSVAL
define|#
directive|define
name|MXSVAL
value|(MXIVAL * SCALE)
end_define

begin_comment
DECL|macro|MXSVAL
comment|/* maximum scaled values */
end_comment

begin_define
DECL|macro|CSCALEB
define|#
directive|define
name|CSCALEB
value|2
end_define

begin_comment
DECL|macro|CSCALEB
comment|/* coarse scale bits */
end_comment

begin_define
DECL|macro|CSCALE
define|#
directive|define
name|CSCALE
value|(1<< CSCALEB)
end_define

begin_comment
DECL|macro|CSCALE
comment|/* coarse scale factor */
end_comment

begin_define
DECL|macro|MXCSVAL
define|#
directive|define
name|MXCSVAL
value|(MXIVAL * CSCALE)
end_define

begin_comment
DECL|macro|MXCSVAL
comment|/* maximum coarse scaled values */
end_comment

begin_define
DECL|macro|NOCSVAL
define|#
directive|define
name|NOCSVAL
value|(MXCSVAL + 1)
end_define

begin_comment
DECL|macro|NOCSVAL
comment|/* number of coarse scaled values */
end_comment

begin_define
DECL|macro|SCTOCSC (x)
define|#
directive|define
name|SCTOCSC
parameter_list|(
name|x
parameter_list|)
value|((x)>> (SCALEB - CSCALEB))
end_define

begin_comment
DECL|macro|SCTOCSC (x)
comment|/* convert from scaled to coarse scaled */
end_comment

begin_define
DECL|macro|CSCTOSC (x)
define|#
directive|define
name|CSCTOSC
parameter_list|(
name|x
parameter_list|)
value|((x)<< (SCALEB - CSCALEB))
end_define

begin_comment
DECL|macro|CSCTOSC (x)
comment|/* convert from course scaled to scaled */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXINT
end_ifndef

begin_define
DECL|macro|MAXINT
define|#
directive|define
name|MAXINT
value|0x7fffffff
end_define

begin_comment
DECL|macro|MAXINT
comment|/* assume this is a 32 bit machine */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* round and scale floating point to scaled integer */
end_comment

begin_define
DECL|macro|SROUND (x)
define|#
directive|define
name|SROUND
parameter_list|(
name|x
parameter_list|)
value|((gint)(((x) * (gdouble)SCALE) + 0.5))
end_define

begin_comment
comment|/* round and un-scale scaled integer value */
end_comment

begin_define
DECL|macro|RUNSCALE (x)
define|#
directive|define
name|RUNSCALE
parameter_list|(
name|x
parameter_list|)
value|(((x) + (1<< (SCALEB-1)))>> SCALEB)
end_define

begin_comment
DECL|macro|RUNSCALE (x)
comment|/* rounded un-scale */
end_comment

begin_define
DECL|macro|UNSCALE (x)
define|#
directive|define
name|UNSCALE
parameter_list|(
name|x
parameter_list|)
value|((x)>> SCALEB)
end_define

begin_comment
comment|/* Note: modified by David Hodson, nlfiltRow now accesses  * srclast, srcthis, and srcnext from [-Bpp] to [width*Bpp-1].  * Beware if you use this code anywhere else!  */
end_comment

begin_function
specifier|static
name|void
DECL|function|nlfiltRow (guchar * srclast,guchar * srcthis,guchar * srcnext,guchar * dst,gint width,gint Bpp,gint filtno)
name|nlfiltRow
parameter_list|(
name|guchar
modifier|*
name|srclast
parameter_list|,
name|guchar
modifier|*
name|srcthis
parameter_list|,
name|guchar
modifier|*
name|srcnext
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|Bpp
parameter_list|,
name|gint
name|filtno
parameter_list|)
block|{
name|gint
name|pf
index|[
literal|9
index|]
decl_stmt|;
name|guchar
modifier|*
name|ip0
decl_stmt|,
modifier|*
name|ip1
decl_stmt|,
modifier|*
name|ip2
decl_stmt|,
modifier|*
name|or
decl_stmt|,
modifier|*
name|orend
decl_stmt|;
name|or
operator|=
name|dst
expr_stmt|;
name|orend
operator|=
name|dst
operator|+
name|width
operator|*
name|Bpp
expr_stmt|;
name|ip0
operator|=
name|srclast
expr_stmt|;
name|ip1
operator|=
name|srcthis
expr_stmt|;
name|ip2
operator|=
name|srcnext
expr_stmt|;
for|for
control|(
name|or
operator|=
name|dst
init|;
name|or
operator|<
name|orend
condition|;
name|ip0
operator|++
operator|,
name|ip1
operator|++
operator|,
name|ip2
operator|++
operator|,
name|or
operator|++
control|)
block|{
name|pf
index|[
literal|0
index|]
operator|=
operator|*
name|ip1
expr_stmt|;
name|pf
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|ip1
operator|-
name|Bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|2
index|]
operator|=
operator|*
operator|(
name|ip2
operator|-
name|Bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|3
index|]
operator|=
operator|*
operator|(
name|ip2
operator|)
expr_stmt|;
name|pf
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|ip2
operator|+
name|Bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|5
index|]
operator|=
operator|*
operator|(
name|ip1
operator|+
name|Bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|6
index|]
operator|=
operator|*
operator|(
name|ip0
operator|+
name|Bpp
operator|)
expr_stmt|;
name|pf
index|[
literal|7
index|]
operator|=
operator|*
operator|(
name|ip0
operator|)
expr_stmt|;
name|pf
index|[
literal|8
index|]
operator|=
operator|*
operator|(
name|ip0
operator|-
name|Bpp
operator|)
expr_stmt|;
operator|*
name|or
operator|=
operator|(
name|atfuncs
index|[
name|filtno
index|]
operator|)
operator|(
name|pf
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We restrict radius to the values: 0.333333<= radius<= 1.0 */
end_comment

begin_comment
comment|/* so that no fewer and no more than a 3x3 grid of pixels around */
end_comment

begin_comment
comment|/* the pixel in question needs to be read. Given this, we only */
end_comment

begin_comment
comment|/* need 3 or 4 weightings per hexagon, as follows: */
end_comment

begin_comment
comment|/*                  _ _                         */
end_comment

begin_comment
comment|/* Virtical hex:   |_|_|  1 2                   */
end_comment

begin_comment
comment|/*                 |X|_|  0 3                   */
end_comment

begin_comment
comment|/*                                       _      */
end_comment

begin_comment
comment|/*              _                      _|_|   1 */
end_comment

begin_comment
comment|/* Middle hex: |_| 1  Horizontal hex: |X|_| 0 2 */
end_comment

begin_comment
comment|/*             |X| 0                    |_|   3 */
end_comment

begin_comment
comment|/*             |_| 2                            */
end_comment

begin_comment
comment|/* all filters */
end_comment

begin_decl_stmt
DECL|variable|V0
DECL|variable|V1
DECL|variable|V2
DECL|variable|V3
name|gint
name|V0
index|[
name|NOIVAL
index|]
decl_stmt|,
name|V1
index|[
name|NOIVAL
index|]
decl_stmt|,
name|V2
index|[
name|NOIVAL
index|]
decl_stmt|,
name|V3
index|[
name|NOIVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|V0
DECL|variable|V1
DECL|variable|V2
DECL|variable|V3
comment|/* vertical hex */
end_comment

begin_decl_stmt
DECL|variable|M0
DECL|variable|M1
DECL|variable|M2
name|gint
name|M0
index|[
name|NOIVAL
index|]
decl_stmt|,
name|M1
index|[
name|NOIVAL
index|]
decl_stmt|,
name|M2
index|[
name|NOIVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|M0
DECL|variable|M1
DECL|variable|M2
comment|/* middle hex */
end_comment

begin_decl_stmt
DECL|variable|H0
DECL|variable|H1
DECL|variable|H2
DECL|variable|H3
name|gint
name|H0
index|[
name|NOIVAL
index|]
decl_stmt|,
name|H1
index|[
name|NOIVAL
index|]
decl_stmt|,
name|H2
index|[
name|NOIVAL
index|]
decl_stmt|,
name|H3
index|[
name|NOIVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|H0
DECL|variable|H1
DECL|variable|H2
DECL|variable|H3
comment|/* horizontal hex */
end_comment

begin_comment
comment|/* alpha trimmed and edge enhancement only */
end_comment

begin_decl_stmt
DECL|variable|ALFRAC
name|gint
name|ALFRAC
index|[
name|NOIVAL
operator|*
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|ALFRAC
comment|/* fractional alpha divider table */
end_comment

begin_comment
comment|/* optimal estimation only */
end_comment

begin_decl_stmt
DECL|variable|AVEDIV
name|gint
name|AVEDIV
index|[
literal|7
operator|*
name|NOCSVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|AVEDIV
comment|/* divide by 7 to give average value */
end_comment

begin_decl_stmt
DECL|variable|SQUARE
name|gint
name|SQUARE
index|[
literal|2
operator|*
name|NOCSVAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|SQUARE
comment|/* scaled square lookup table */
end_comment

begin_comment
comment|/* Table initialisation function - return alpha range */
end_comment

begin_function
specifier|static
specifier|inline
name|gint
DECL|function|nlfiltInit (gdouble alpha,gdouble radius,FilterType filter)
name|nlfiltInit
parameter_list|(
name|gdouble
name|alpha
parameter_list|,
name|gdouble
name|radius
parameter_list|,
name|FilterType
name|filter
parameter_list|)
block|{
name|gint
name|alpharange
decl_stmt|;
comment|/* alpha range value 0 - 3 */
name|gdouble
name|meanscale
decl_stmt|;
comment|/* scale for finding mean */
name|gdouble
name|mmeanscale
decl_stmt|;
comment|/* scale for finding mean - midle hex */
name|gdouble
name|alphafraction
decl_stmt|;
comment|/* fraction of next largest/smallest                              *  to subtract from sum                              */
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|filter_alpha_trim
case|:
block|{
name|gdouble
name|noinmean
decl_stmt|;
comment|/* alpha only makes sense in range 0.0 - 0.5 */
name|alpha
operator|/=
literal|2.0
expr_stmt|;
comment|/* number of elements (out of a possible 7) used in the mean */
name|noinmean
operator|=
operator|(
operator|(
literal|0.5
operator|-
name|alpha
operator|)
operator|*
literal|12.0
operator|)
operator|+
literal|1.0
expr_stmt|;
name|mmeanscale
operator|=
name|meanscale
operator|=
literal|1.0
operator|/
name|noinmean
expr_stmt|;
if|if
condition|(
name|alpha
operator|==
literal|0.0
condition|)
block|{
comment|/* mean filter */
name|alpharange
operator|=
literal|0
expr_stmt|;
name|alphafraction
operator|=
literal|0.0
expr_stmt|;
comment|/* not used */
block|}
elseif|else
if|if
condition|(
name|alpha
operator|<
operator|(
literal|1.0
operator|/
literal|6.0
operator|)
condition|)
block|{
comment|/* mean of 5 to 7 middle values */
name|alpharange
operator|=
literal|1
expr_stmt|;
name|alphafraction
operator|=
operator|(
literal|7.0
operator|-
name|noinmean
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alpha
operator|<
operator|(
literal|1.0
operator|/
literal|3.0
operator|)
condition|)
block|{
comment|/* mean of 3 to 5 middle values */
name|alpharange
operator|=
literal|2
expr_stmt|;
name|alphafraction
operator|=
operator|(
literal|5.0
operator|-
name|noinmean
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
else|else
block|{
comment|/* mean of 1 to 3 middle values */
comment|/* alpha==0.5  => median filter */
name|alpharange
operator|=
literal|3
expr_stmt|;
name|alphafraction
operator|=
operator|(
literal|3.0
operator|-
name|noinmean
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|filter_opt_est
case|:
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|noinmean
init|=
literal|7.0
decl_stmt|;
comment|/* edge enhancement function */
name|alpharange
operator|=
literal|5
expr_stmt|;
comment|/* compute scaled hex values */
name|mmeanscale
operator|=
name|meanscale
operator|=
literal|1.0
expr_stmt|;
comment|/* Set up 1:1 division lookup - not used */
name|alphafraction
operator|=
literal|1.0
operator|/
name|noinmean
expr_stmt|;
comment|/* estimate of noise variance */
name|noisevariance
operator|=
name|alpha
operator|*
operator|(
name|gdouble
operator|)
literal|255
expr_stmt|;
name|noisevariance
operator|=
name|noisevariance
operator|*
name|noisevariance
operator|/
literal|8.0
expr_stmt|;
comment|/* set yp optimal estimation specific stuff */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|7
operator|*
name|NOCSVAL
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* divide scaled value by 7 lookup */
name|AVEDIV
index|[
name|i
index|]
operator|=
name|CSCTOSC
argument_list|(
name|i
argument_list|)
operator|/
literal|7
expr_stmt|;
comment|/* scaled divide by 7 */
block|}
comment|/* compute square and rescale by                * (val>> (2 * SCALEB + 2)) table                */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|2
operator|*
name|NOCSVAL
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|val
decl_stmt|;
comment|/* NOCSVAL offset to cope with -ve input values */
name|val
operator|=
name|CSCTOSC
argument_list|(
name|i
operator|-
name|NOCSVAL
argument_list|)
expr_stmt|;
name|SQUARE
index|[
name|i
index|]
operator|=
operator|(
name|val
operator|*
name|val
operator|)
operator|>>
operator|(
literal|2
operator|*
name|SCALEB
operator|+
literal|2
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|filter_edge_enhance
case|:
block|{
if|if
condition|(
name|alpha
operator|==
literal|1.0
condition|)
name|alpha
operator|=
literal|0.99
expr_stmt|;
name|alpharange
operator|=
literal|4
expr_stmt|;
comment|/* mean of 7 and scaled by -alpha/(1-alpha) */
name|meanscale
operator|=
literal|1.0
operator|*
operator|(
operator|-
name|alpha
operator|/
operator|(
operator|(
literal|1.0
operator|-
name|alpha
operator|)
operator|*
literal|7.0
operator|)
operator|)
expr_stmt|;
comment|/* middle pixel has 1/(1-alpha) as well */
name|mmeanscale
operator|=
literal|1.0
operator|*
operator|(
literal|1.0
operator|/
operator|(
literal|1.0
operator|-
name|alpha
operator|)
operator|+
name|meanscale
operator|)
expr_stmt|;
name|alphafraction
operator|=
literal|0.0
expr_stmt|;
comment|/* not used */
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown filter %d\n"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*         * Setup pixel weighting tables -         * note we pre-compute mean division here too.         */
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|hexhoff
decl_stmt|,
name|hexvoff
decl_stmt|;
name|gdouble
name|tabscale
decl_stmt|,
name|mtabscale
decl_stmt|;
name|gdouble
name|v0
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|,
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|;
comment|/* horizontal offset of virtical hex centers */
name|hexhoff
operator|=
name|radius
operator|/
literal|2
expr_stmt|;
comment|/* vertical offset of virtical hex centers */
name|hexvoff
operator|=
literal|3.0
operator|*
name|radius
operator|/
name|sqrt
argument_list|(
literal|12.0
argument_list|)
expr_stmt|;
comment|/*            * scale tables to normalise by hexagon            * area, and number of hexes used in mean            */
name|tabscale
operator|=
name|meanscale
operator|/
operator|(
name|radius
operator|*
name|hexvoff
operator|)
expr_stmt|;
name|mtabscale
operator|=
name|mmeanscale
operator|/
operator|(
name|radius
operator|*
name|hexvoff
operator|)
expr_stmt|;
name|v0
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|v1
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|v2
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|v3
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|hexhoff
argument_list|,
name|hexvoff
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|m0
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|mtabscale
expr_stmt|;
name|m1
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|mtabscale
expr_stmt|;
name|m2
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|mtabscale
expr_stmt|;
name|h0
operator|=
name|hex_area
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|h1
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|h2
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
name|h3
operator|=
name|hex_area
argument_list|(
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|,
name|radius
argument_list|,
literal|0.0
argument_list|,
name|radius
argument_list|)
operator|*
name|tabscale
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MXIVAL
condition|;
name|i
operator|++
control|)
block|{
name|gdouble
name|fi
decl_stmt|;
name|fi
operator|=
operator|(
name|gdouble
operator|)
name|i
expr_stmt|;
name|V0
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v0
argument_list|)
expr_stmt|;
name|V1
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v1
argument_list|)
expr_stmt|;
name|V2
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v2
argument_list|)
expr_stmt|;
name|V3
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|v3
argument_list|)
expr_stmt|;
name|M0
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|m0
argument_list|)
expr_stmt|;
name|M1
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|m1
argument_list|)
expr_stmt|;
name|M2
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|m2
argument_list|)
expr_stmt|;
name|H0
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h0
argument_list|)
expr_stmt|;
name|H1
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h1
argument_list|)
expr_stmt|;
name|H2
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h2
argument_list|)
expr_stmt|;
name|H3
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
name|fi
operator|*
name|h3
argument_list|)
expr_stmt|;
block|}
comment|/* set up alpha fraction lookup table used on big/small */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|NOIVAL
operator|*
literal|8
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ALFRAC
index|[
name|i
index|]
operator|=
name|SROUND
argument_list|(
operator|(
name|gdouble
operator|)
name|i
operator|*
name|alphafraction
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|alpharange
return|;
block|}
end_function

begin_comment
comment|/* Core pixel processing function - hand it 3x3 pixels and return result. */
end_comment

begin_comment
comment|/* Mean filter */
end_comment

begin_function
name|gint
DECL|function|atfilt0 (gint32 * p)
name|atfilt0
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|retv
decl_stmt|;
comment|/* map to scaled hexagon values */
name|retv
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|retv
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
return|return
name|UNSCALE
argument_list|(
name|retv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mean of 5 - 7 middle values */
end_comment

begin_function
name|gint
DECL|function|atfilt1 (gint32 * p)
name|atfilt1
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
name|gint
name|big
decl_stmt|,
name|small
decl_stmt|;
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* sum values and also discover the largest and smallest */
name|big
operator|=
name|small
operator|=
name|h0
expr_stmt|;
DECL|macro|CHECK (xx)
define|#
directive|define
name|CHECK
parameter_list|(
name|xx
parameter_list|)
define|\
value|h0 += xx; \         if (xx> big) \                 big = xx; \         else if (xx< small) \                 small = xx;
name|CHECK
argument_list|(
argument|h1
argument_list|)
name|CHECK
argument_list|(
argument|h2
argument_list|)
name|CHECK
argument_list|(
argument|h3
argument_list|)
name|CHECK
argument_list|(
argument|h4
argument_list|)
name|CHECK
argument_list|(
argument|h5
argument_list|)
name|CHECK
argument_list|(
argument|h6
argument_list|)
undef|#
directive|undef
name|CHECK
comment|/* Compute mean of middle 5-7 values */
return|return
name|UNSCALE
argument_list|(
name|h0
operator|-
name|ALFRAC
index|[
operator|(
name|big
operator|+
name|small
operator|)
operator|>>
name|SCALEB
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mean of 3 - 5 middle values */
end_comment

begin_function
name|gint
DECL|function|atfilt2 (gint32 * p)
name|atfilt2
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
name|gint
name|big0
decl_stmt|,
name|big1
decl_stmt|,
name|small0
decl_stmt|,
name|small1
decl_stmt|;
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* sum values and also discover the 2 largest and 2 smallest */
name|big0
operator|=
name|small0
operator|=
name|h0
expr_stmt|;
name|small1
operator|=
name|MAXINT
expr_stmt|;
name|big1
operator|=
literal|0
expr_stmt|;
DECL|macro|CHECK (xx)
define|#
directive|define
name|CHECK
parameter_list|(
name|xx
parameter_list|)
define|\
value|h0 += xx; \         if (xx> big1) \                 { \                 if (xx> big0) \                         { \                         big1 = big0; \                         big0 = xx; \                         } \                 else \                         big1 = xx; \                 } \         if (xx< small1) \                 { \                 if (xx< small0) \                         { \                         small1 = small0; \                         small0 = xx; \                         } \                 else \                         small1 = xx; \                 }
name|CHECK
argument_list|(
argument|h1
argument_list|)
name|CHECK
argument_list|(
argument|h2
argument_list|)
name|CHECK
argument_list|(
argument|h3
argument_list|)
name|CHECK
argument_list|(
argument|h4
argument_list|)
name|CHECK
argument_list|(
argument|h5
argument_list|)
name|CHECK
argument_list|(
argument|h6
argument_list|)
undef|#
directive|undef
name|CHECK
comment|/* Compute mean of middle 3-5 values */
return|return
name|UNSCALE
argument_list|(
name|h0
operator|-
name|big0
operator|-
name|small0
operator|-
name|ALFRAC
index|[
operator|(
name|big1
operator|+
name|small1
operator|)
operator|>>
name|SCALEB
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mean of 1 - 3 middle values.  * If only 1 value, then this is a median filter.  */
end_comment

begin_function
name|gint32
DECL|function|atfilt3 (gint32 * p)
name|atfilt3
parameter_list|(
name|gint32
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
name|gint
name|big0
decl_stmt|,
name|big1
decl_stmt|,
name|big2
decl_stmt|,
name|small0
decl_stmt|,
name|small1
decl_stmt|,
name|small2
decl_stmt|;
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* sum values and also discover the 3 largest and 3 smallest */
name|big0
operator|=
name|small0
operator|=
name|h0
expr_stmt|;
name|small1
operator|=
name|small2
operator|=
name|MAXINT
expr_stmt|;
name|big1
operator|=
name|big2
operator|=
literal|0
expr_stmt|;
DECL|macro|CHECK (xx)
define|#
directive|define
name|CHECK
parameter_list|(
name|xx
parameter_list|)
define|\
value|h0 += xx; \         if (xx> big2) \                 { \                 if (xx> big1) \                         { \                         if (xx> big0) \                                 { \                                 big2 = big1; \                                 big1 = big0; \                                 big0 = xx; \                                 } \                         else \                                 { \                                 big2 = big1; \                                 big1 = xx; \                                 } \                         } \                 else \                         big2 = xx; \                 } \         if (xx< small2) \                 { \                 if (xx< small1) \                         { \                         if (xx< small0) \                                 { \                                 small2 = small1; \                                 small1 = small0; \                                 small0 = xx; \                                 } \                         else \                                 { \                                 small2 = small1; \                                 small1 = xx; \                                 } \                         } \                 else \                         small2 = xx; \                 }
name|CHECK
argument_list|(
argument|h1
argument_list|)
name|CHECK
argument_list|(
argument|h2
argument_list|)
name|CHECK
argument_list|(
argument|h3
argument_list|)
name|CHECK
argument_list|(
argument|h4
argument_list|)
name|CHECK
argument_list|(
argument|h5
argument_list|)
name|CHECK
argument_list|(
argument|h6
argument_list|)
undef|#
directive|undef
name|CHECK
comment|/* Compute mean of middle 1-3 values */
return|return
name|UNSCALE
argument_list|(
name|h0
operator|-
name|big0
operator|-
name|big1
operator|-
name|small0
operator|-
name|small1
operator|-
name|ALFRAC
index|[
operator|(
name|big2
operator|+
name|small2
operator|)
operator|>>
name|SCALEB
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Edge enhancement */
end_comment

begin_function
name|gint
DECL|function|atfilt4 (gint * p)
name|atfilt4
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|hav
decl_stmt|;
comment|/* map to scaled hexagon values and compute enhance value */
name|hav
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|hav
operator|+=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|hav
operator|<
literal|0
condition|)
name|hav
operator|=
literal|0
expr_stmt|;
name|hav
operator|=
name|UNSCALE
argument_list|(
name|hav
argument_list|)
expr_stmt|;
if|if
condition|(
name|hav
operator|>
operator|(
name|gdouble
operator|)
literal|255
condition|)
name|hav
operator|=
operator|(
name|gdouble
operator|)
literal|255
expr_stmt|;
return|return
name|hav
return|;
block|}
end_function

begin_comment
comment|/* Optimal estimation - do smoothing in inverse proportion */
end_comment

begin_comment
comment|/* to the local variance. */
end_comment

begin_comment
comment|/* notice we use the globals noisevariance */
end_comment

begin_function
name|gint
DECL|function|atfilt5 (gint * p)
name|atfilt5
parameter_list|(
name|gint
modifier|*
name|p
parameter_list|)
block|{
name|gint
name|mean
decl_stmt|,
name|variance
decl_stmt|,
name|temp
decl_stmt|;
name|gint
name|h0
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|h5
decl_stmt|,
name|h6
decl_stmt|;
comment|/* hexagon values    2 3   */
comment|/*                  1 0 4  */
comment|/*                   6 5   */
comment|/* map to scaled hexagon values */
name|h0
operator|=
name|M0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|M1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|M2
index|[
name|p
index|[
literal|7
index|]
index|]
expr_stmt|;
name|h1
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|1
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|8
index|]
index|]
expr_stmt|;
name|h2
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|2
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|h3
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|3
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h4
operator|=
name|H0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|H1
index|[
name|p
index|[
literal|4
index|]
index|]
operator|+
name|H2
index|[
name|p
index|[
literal|5
index|]
index|]
operator|+
name|H3
index|[
name|p
index|[
literal|6
index|]
index|]
expr_stmt|;
name|h5
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|6
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|5
index|]
index|]
expr_stmt|;
name|h6
operator|=
name|V0
index|[
name|p
index|[
literal|0
index|]
index|]
operator|+
name|V1
index|[
name|p
index|[
literal|7
index|]
index|]
operator|+
name|V2
index|[
name|p
index|[
literal|8
index|]
index|]
operator|+
name|V3
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|mean
operator|=
name|h0
operator|+
name|h1
operator|+
name|h2
operator|+
name|h3
operator|+
name|h4
operator|+
name|h5
operator|+
name|h6
expr_stmt|;
comment|/* compute scaled mean by dividing by 7 */
name|mean
operator|=
name|AVEDIV
index|[
name|SCTOCSC
argument_list|(
name|mean
argument_list|)
index|]
expr_stmt|;
comment|/* compute scaled variance */
name|temp
operator|=
operator|(
name|h1
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
comment|/* and rescale to keep */
name|temp
operator|=
operator|(
name|h2
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
comment|/* within 32 bit limits */
name|temp
operator|=
operator|(
name|h3
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
operator|(
name|h4
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
operator|(
name|h5
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
name|temp
operator|=
operator|(
name|h6
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
comment|/* (temp = h0 - mean) */
name|temp
operator|=
operator|(
name|h0
operator|-
name|mean
operator|)
expr_stmt|;
name|variance
operator|+=
name|SQUARE
index|[
name|NOCSVAL
operator|+
name|SCTOCSC
argument_list|(
name|temp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|variance
operator|!=
literal|0
condition|)
comment|/* avoid possible divide by 0 */
comment|/* optimal estimate */
name|temp
operator|=
name|mean
operator|+
operator|(
name|variance
operator|*
name|temp
operator|)
operator|/
operator|(
name|variance
operator|+
name|noisevariance
operator|)
expr_stmt|;
else|else
name|temp
operator|=
name|h0
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|RUNSCALE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
operator|(
name|gdouble
operator|)
literal|255
condition|)
name|temp
operator|=
operator|(
name|gdouble
operator|)
literal|255
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Triangle orientation is per geometric axes (not graphical axies) */
end_comment

begin_define
DECL|macro|NW
define|#
directive|define
name|NW
value|0
end_define

begin_comment
DECL|macro|NW
comment|/* North west triangle /| */
end_comment

begin_define
DECL|macro|NE
define|#
directive|define
name|NE
value|1
end_define

begin_comment
DECL|macro|NE
comment|/* North east triangle |\ */
end_comment

begin_define
DECL|macro|SW
define|#
directive|define
name|SW
value|2
end_define

begin_comment
DECL|macro|SW
comment|/* South west triangle \| */
end_comment

begin_define
DECL|macro|SE
define|#
directive|define
name|SE
value|3
end_define

begin_comment
DECL|macro|SE
comment|/* South east triangle |/ */
end_comment

begin_define
DECL|macro|STH
define|#
directive|define
name|STH
value|2
end_define

begin_define
DECL|macro|EST
define|#
directive|define
name|EST
value|1
end_define

begin_define
DECL|macro|SWAPI (a,b)
define|#
directive|define
name|SWAPI
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(t = a, a = -b, b = -t)
end_define

begin_comment
comment|/* compute the area of overlap of a hexagon diameter d, */
end_comment

begin_comment
comment|/* centered at hx,hy, with a unit square of center sx,sy. */
end_comment

begin_function
name|gdouble
DECL|function|hex_area (gdouble sx,gdouble sy,gdouble hx,gdouble hy,gdouble d)
name|hex_area
parameter_list|(
name|gdouble
name|sx
parameter_list|,
name|gdouble
name|sy
parameter_list|,
name|gdouble
name|hx
parameter_list|,
name|gdouble
name|hy
parameter_list|,
name|gdouble
name|d
parameter_list|)
block|{
name|gdouble
name|hx0
decl_stmt|,
name|hx1
decl_stmt|,
name|hx2
decl_stmt|,
name|hy0
decl_stmt|,
name|hy1
decl_stmt|,
name|hy2
decl_stmt|,
name|hy3
decl_stmt|;
name|gdouble
name|sx0
decl_stmt|,
name|sx1
decl_stmt|,
name|sy0
decl_stmt|,
name|sy1
decl_stmt|;
comment|/* compute square co-ordinates */
name|sx0
operator|=
name|sx
operator|-
literal|0.5
expr_stmt|;
name|sy0
operator|=
name|sy
operator|-
literal|0.5
expr_stmt|;
name|sx1
operator|=
name|sx
operator|+
literal|0.5
expr_stmt|;
name|sy1
operator|=
name|sy
operator|+
literal|0.5
expr_stmt|;
comment|/* compute hexagon co-ordinates */
name|hx0
operator|=
name|hx
operator|-
name|d
operator|/
literal|2.0
expr_stmt|;
name|hx1
operator|=
name|hx
expr_stmt|;
name|hx2
operator|=
name|hx
operator|+
name|d
operator|/
literal|2.0
expr_stmt|;
name|hy0
operator|=
name|hy
operator|-
literal|0.5773502692
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(3) */
name|hy1
operator|=
name|hy
operator|-
literal|0.2886751346
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(12) */
name|hy2
operator|=
name|hy
operator|+
literal|0.2886751346
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(12) */
name|hy3
operator|=
name|hy
operator|+
literal|0.5773502692
operator|*
name|d
expr_stmt|;
comment|/* d / sqrt(3) */
return|return
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx0
argument_list|,
name|hy2
argument_list|,
name|hx1
argument_list|,
name|hy3
argument_list|,
name|NW
argument_list|)
operator|+
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx1
argument_list|,
name|hy2
argument_list|,
name|hx2
argument_list|,
name|hy3
argument_list|,
name|NE
argument_list|)
operator|+
name|rectang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx0
argument_list|,
name|hy1
argument_list|,
name|hx2
argument_list|,
name|hy2
argument_list|)
operator|+
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx0
argument_list|,
name|hy0
argument_list|,
name|hx1
argument_list|,
name|hy1
argument_list|,
name|SW
argument_list|)
operator|+
name|triang_area
argument_list|(
name|sx0
argument_list|,
name|sy0
argument_list|,
name|sx1
argument_list|,
name|sy1
argument_list|,
name|hx1
argument_list|,
name|hy0
argument_list|,
name|hx2
argument_list|,
name|hy1
argument_list|,
name|SE
argument_list|)
return|;
block|}
end_function

begin_function
name|gdouble
DECL|function|triang_area (gdouble rx0,gdouble ry0,gdouble rx1,gdouble ry1,gdouble tx0,gdouble ty0,gdouble tx1,gdouble ty1,gint tt)
name|triang_area
parameter_list|(
name|gdouble
name|rx0
parameter_list|,
name|gdouble
name|ry0
parameter_list|,
name|gdouble
name|rx1
parameter_list|,
name|gdouble
name|ry1
parameter_list|,
name|gdouble
name|tx0
parameter_list|,
name|gdouble
name|ty0
parameter_list|,
name|gdouble
name|tx1
parameter_list|,
name|gdouble
name|ty1
parameter_list|,
name|gint
name|tt
parameter_list|)
block|{
name|gdouble
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|gdouble
name|lx0
decl_stmt|,
name|ly0
decl_stmt|,
name|lx1
decl_stmt|,
name|ly1
decl_stmt|;
comment|/* Convert everything to a NW triangle */
if|if
condition|(
name|tt
operator|&
name|STH
condition|)
block|{
name|gdouble
name|t
decl_stmt|;
name|SWAPI
argument_list|(
name|ry0
argument_list|,
name|ry1
argument_list|)
expr_stmt|;
name|SWAPI
argument_list|(
name|ty0
argument_list|,
name|ty1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tt
operator|&
name|EST
condition|)
block|{
name|gdouble
name|t
decl_stmt|;
name|SWAPI
argument_list|(
name|rx0
argument_list|,
name|rx1
argument_list|)
expr_stmt|;
name|SWAPI
argument_list|(
name|tx0
argument_list|,
name|tx1
argument_list|)
expr_stmt|;
block|}
comment|/* Compute overlapping box */
if|if
condition|(
name|tx0
operator|>
name|rx0
condition|)
name|rx0
operator|=
name|tx0
expr_stmt|;
if|if
condition|(
name|ty0
operator|>
name|ry0
condition|)
name|ry0
operator|=
name|ty0
expr_stmt|;
if|if
condition|(
name|tx1
operator|<
name|rx1
condition|)
name|rx1
operator|=
name|tx1
expr_stmt|;
if|if
condition|(
name|ty1
operator|<
name|ry1
condition|)
name|ry1
operator|=
name|ty1
expr_stmt|;
if|if
condition|(
name|rx1
operator|<=
name|rx0
operator|||
name|ry1
operator|<=
name|ry0
condition|)
return|return
literal|0.0
return|;
comment|/* Need to compute diagonal line intersection with the box */
comment|/* First compute co-efficients to formulas x = a + by and y = c + dx */
name|b
operator|=
operator|(
name|tx1
operator|-
name|tx0
operator|)
operator|/
operator|(
name|ty1
operator|-
name|ty0
operator|)
expr_stmt|;
name|a
operator|=
name|tx0
operator|-
name|b
operator|*
name|ty0
expr_stmt|;
name|d
operator|=
operator|(
name|ty1
operator|-
name|ty0
operator|)
operator|/
operator|(
name|tx1
operator|-
name|tx0
operator|)
expr_stmt|;
name|c
operator|=
name|ty0
operator|-
name|d
operator|*
name|tx0
expr_stmt|;
comment|/* compute top or right intersection */
name|tt
operator|=
literal|0
expr_stmt|;
name|ly1
operator|=
name|ry1
expr_stmt|;
name|lx1
operator|=
name|a
operator|+
name|b
operator|*
name|ly1
expr_stmt|;
if|if
condition|(
name|lx1
operator|<=
name|rx0
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
elseif|else
if|if
condition|(
name|lx1
operator|>
name|rx1
condition|)
block|{
comment|/* could be right hand side */
name|lx1
operator|=
name|rx1
expr_stmt|;
name|ly1
operator|=
name|c
operator|+
name|d
operator|*
name|lx1
expr_stmt|;
if|if
condition|(
name|ly1
operator|<=
name|ry0
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
name|tt
operator|=
literal|1
expr_stmt|;
comment|/* right hand side intersection */
block|}
comment|/* compute left or bottom intersection */
name|lx0
operator|=
name|rx0
expr_stmt|;
name|ly0
operator|=
name|c
operator|+
name|d
operator|*
name|lx0
expr_stmt|;
if|if
condition|(
name|ly0
operator|>=
name|ry1
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
elseif|else
if|if
condition|(
name|ly0
operator|<
name|ry0
condition|)
block|{
comment|/* could be right hand side */
name|ly0
operator|=
name|ry0
expr_stmt|;
name|lx0
operator|=
name|a
operator|+
name|b
operator|*
name|ly0
expr_stmt|;
if|if
condition|(
name|lx0
operator|>=
name|rx1
condition|)
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
name|tt
operator||=
literal|2
expr_stmt|;
comment|/* bottom intersection */
block|}
if|if
condition|(
name|tt
operator|==
literal|0
condition|)
block|{
comment|/* top and left intersection */
comment|/* rectangle minus triangle */
return|return
operator|(
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
operator|)
operator|-
operator|(
literal|0.5
operator|*
operator|(
name|lx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ly0
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|==
literal|1
condition|)
block|{
comment|/* right and left intersection */
return|return
operator|(
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ly0
operator|-
name|ry0
operator|)
operator|)
operator|+
operator|(
literal|0.5
operator|*
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ly1
operator|-
name|ly0
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|==
literal|2
condition|)
block|{
comment|/* top and bottom intersection */
return|return
operator|(
operator|(
name|rx1
operator|-
name|lx1
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
operator|)
operator|+
operator|(
literal|0.5
operator|*
operator|(
name|lx1
operator|-
name|lx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
operator|)
return|;
block|}
else|else
block|{
comment|/* tt == 3 */
comment|/* right and bottom intersection */
comment|/* triangle */
return|return
operator|(
literal|0.5
operator|*
operator|(
name|rx1
operator|-
name|lx0
operator|)
operator|*
operator|(
name|ly1
operator|-
name|ry0
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute rectangle area */
end_comment

begin_function
name|gdouble
DECL|function|rectang_area (gdouble rx0,gdouble ry0,gdouble rx1,gdouble ry1,gdouble tx0,gdouble ty0,gdouble tx1,gdouble ty1)
name|rectang_area
parameter_list|(
name|gdouble
name|rx0
parameter_list|,
name|gdouble
name|ry0
parameter_list|,
name|gdouble
name|rx1
parameter_list|,
name|gdouble
name|ry1
parameter_list|,
name|gdouble
name|tx0
parameter_list|,
name|gdouble
name|ty0
parameter_list|,
name|gdouble
name|tx1
parameter_list|,
name|gdouble
name|ty1
parameter_list|)
block|{
comment|/* Compute overlapping box */
if|if
condition|(
name|tx0
operator|>
name|rx0
condition|)
name|rx0
operator|=
name|tx0
expr_stmt|;
if|if
condition|(
name|ty0
operator|>
name|ry0
condition|)
name|ry0
operator|=
name|ty0
expr_stmt|;
if|if
condition|(
name|tx1
operator|<
name|rx1
condition|)
name|rx1
operator|=
name|tx1
expr_stmt|;
if|if
condition|(
name|ty1
operator|<
name|ry1
condition|)
name|ry1
operator|=
name|ty1
expr_stmt|;
if|if
condition|(
name|rx1
operator|<=
name|rx0
operator|||
name|ry1
operator|<=
name|ry0
condition|)
return|return
literal|0.0
return|;
return|return
operator|(
name|rx1
operator|-
name|rx0
operator|)
operator|*
operator|(
name|ry1
operator|-
name|ry0
operator|)
return|;
block|}
end_function

end_unit

