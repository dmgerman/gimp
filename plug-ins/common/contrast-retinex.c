begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|PLUG_IN_PROC
define|#
directive|define
name|PLUG_IN_PROC
value|"plug-in-retinex"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"contrast-retinex"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-contrast-retinex"
end_define

begin_define
DECL|macro|MAX_RETINEX_SCALES
define|#
directive|define
name|MAX_RETINEX_SCALES
value|8
end_define

begin_define
DECL|macro|MIN_GAUSSIAN_SCALE
define|#
directive|define
name|MIN_GAUSSIAN_SCALE
value|16
end_define

begin_define
DECL|macro|MAX_GAUSSIAN_SCALE
define|#
directive|define
name|MAX_GAUSSIAN_SCALE
value|250
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|150
end_define

begin_define
DECL|macro|ENTRY_WIDTH
define|#
directive|define
name|ENTRY_WIDTH
value|4
end_define

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2bec876a0108
block|{
DECL|member|scale
name|gint
name|scale
decl_stmt|;
DECL|member|nscales
name|gint
name|nscales
decl_stmt|;
DECL|member|scales_mode
name|gint
name|scales_mode
decl_stmt|;
DECL|member|cvar
name|gfloat
name|cvar
decl_stmt|;
DECL|typedef|RetinexParams
block|}
name|RetinexParams
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2bec876a0203
block|{
DECL|enumerator|filter_uniform
name|filter_uniform
block|,
DECL|enumerator|filter_low
name|filter_low
block|,
DECL|enumerator|filter_high
name|filter_high
DECL|typedef|FilterMode
block|}
name|FilterMode
typedef|;
end_typedef

begin_comment
comment|/*   Definit comment sont repartis les   differents filtres en fonction de   l'echelle (~= ecart type de la gaussienne)  */
end_comment

begin_define
DECL|macro|RETINEX_UNIFORM
define|#
directive|define
name|RETINEX_UNIFORM
value|0
end_define

begin_define
DECL|macro|RETINEX_LOW
define|#
directive|define
name|RETINEX_LOW
value|1
end_define

begin_define
DECL|macro|RETINEX_HIGH
define|#
directive|define
name|RETINEX_HIGH
value|2
end_define

begin_decl_stmt
DECL|variable|RetinexScales
specifier|static
name|gfloat
name|RetinexScales
index|[
name|MAX_RETINEX_SCALES
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2bec876a0308
block|{
DECL|member|N
name|gint
name|N
decl_stmt|;
DECL|member|sigma
name|gfloat
name|sigma
decl_stmt|;
DECL|member|B
name|gdouble
name|B
decl_stmt|;
DECL|member|b
name|gdouble
name|b
index|[
literal|4
index|]
decl_stmt|;
DECL|typedef|gauss3_coefs
block|}
name|gauss3_coefs
typedef|;
end_typedef

begin_comment
comment|/*  * Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Gimp */
end_comment

begin_function_decl
specifier|static
name|gboolean
name|retinex_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|retinex
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|retinex_scales_distribution
parameter_list|(
name|gfloat
modifier|*
name|scales
parameter_list|,
name|gint
name|nscales
parameter_list|,
name|gint
name|mode
parameter_list|,
name|gint
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_mean_var
parameter_list|(
name|gfloat
modifier|*
name|src
parameter_list|,
name|gfloat
modifier|*
name|mean
parameter_list|,
name|gfloat
modifier|*
name|var
parameter_list|,
name|gint
name|size
parameter_list|,
name|gint
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Gauss  */
end_comment

begin_function_decl
specifier|static
name|void
name|compute_coefs3
parameter_list|(
name|gauss3_coefs
modifier|*
name|c
parameter_list|,
name|gfloat
name|sigma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gausssmooth
parameter_list|(
name|gfloat
modifier|*
name|in
parameter_list|,
name|gfloat
modifier|*
name|out
parameter_list|,
name|gint
name|size
parameter_list|,
name|gint
name|rowtride
parameter_list|,
name|gauss3_coefs
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MSRCR = MultiScale Retinex with Color Restoration  */
end_comment

begin_function_decl
specifier|static
name|void
name|MSRCR
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gboolean
name|preview_mode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
DECL|variable|rvals
specifier|static
name|RetinexParams
name|rvals
init|=
block|{
literal|240
block|,
comment|/* Scale */
literal|3
block|,
comment|/* Scales */
name|RETINEX_UNIFORM
block|,
comment|/* Echelles reparties uniformement */
literal|1.2
comment|/* A voir */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|static
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image (unused)"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Input drawable"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"scale"
block|,
literal|"Biggest scale value"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"nscales"
block|,
literal|"Number of scales"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"scales-mode"
block|,
literal|"Retinex distribution through scales"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"cvar"
block|,
literal|"Variance value"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|PLUG_IN_PROC
argument_list|,
name|N_
argument_list|(
literal|"Enhance contrast using the Retinex method"
argument_list|)
argument_list|,
literal|"The Retinex Image Enhancement Algorithm is an "
literal|"automatic image enhancement method that enhances "
literal|"a digital image in terms of dynamic range "
literal|"compression, color independence from the spectral "
literal|"distribution of the scene illuminant, and "
literal|"color/lightness rendition."
argument_list|,
literal|"Fabien Pelisson"
argument_list|,
literal|"Fabien Pelisson"
argument_list|,
literal|"2003"
argument_list|,
name|N_
argument_list|(
literal|"Retine_x..."
argument_list|)
argument_list|,
literal|"RGB*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_plugin_menu_register
argument_list|(
name|PLUG_IN_PROC
argument_list|,
literal|"<Image>/Colors/Modify"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_drawable_mask_intersect
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
operator|||
name|width
operator|<
name|MIN_GAUSSIAN_SCALE
operator|||
name|height
operator|<
name|MIN_GAUSSIAN_SCALE
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
return|return;
block|}
name|gimp_tile_cache_ntiles
argument_list|(
literal|2
operator|*
operator|(
name|drawable
operator|->
name|width
operator|/
name|gimp_tile_width
argument_list|()
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|rvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|retinex_dialog
argument_list|(
name|drawable
argument_list|)
condition|)
return|return;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|7
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|rvals
operator|.
name|scale
operator|=
operator|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
expr_stmt|;
name|rvals
operator|.
name|nscales
operator|=
operator|(
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
expr_stmt|;
name|rvals
operator|.
name|scales_mode
operator|=
operator|(
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
expr_stmt|;
name|rvals
operator|.
name|cvar
operator|=
operator|(
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_get_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|rvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
operator|)
operator|&&
operator|(
name|gimp_drawable_is_rgb
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|)
operator|)
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Retinex"
argument_list|)
argument_list|)
expr_stmt|;
name|retinex
argument_list|(
name|drawable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|!=
name|GIMP_RUN_NONINTERACTIVE
condition|)
name|gimp_displays_flush
argument_list|()
expr_stmt|;
comment|/*  Store data  */
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
name|gimp_set_data
argument_list|(
name|PLUG_IN_PROC
argument_list|,
operator|&
name|rvals
argument_list|,
sizeof|sizeof
argument_list|(
name|RetinexParams
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|retinex_dialog (GimpDrawable * drawable)
name|retinex_dialog
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|main_vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|preview
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|combo
decl_stmt|;
name|GtkObject
modifier|*
name|adj
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Retinex Image Enhancement"
argument_list|)
argument_list|,
name|PLUG_IN_ROLE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gimp_standard_help_func
argument_list|,
name|PLUG_IN_PROC
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|main_vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gtk_dialog_get_content_area
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|main_vbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|main_vbox
argument_list|)
expr_stmt|;
name|preview
operator|=
name|gimp_zoom_preview_new
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|preview
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|preview
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|preview
argument_list|,
literal|"invalidated"
argument_list|,
name|G_CALLBACK
argument_list|(
name|retinex
argument_list|)
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|main_vbox
argument_list|)
argument_list|,
name|table
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|combo
operator|=
name|gimp_int_combo_box_new
argument_list|(
name|_
argument_list|(
literal|"Uniform"
argument_list|)
argument_list|,
name|filter_uniform
argument_list|,
name|_
argument_list|(
literal|"Low"
argument_list|)
argument_list|,
name|filter_low
argument_list|,
name|_
argument_list|(
literal|"High"
argument_list|)
argument_list|,
name|filter_high
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_int_combo_box_connect
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|,
name|rvals
operator|.
name|scales_mode
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_combo_box_get_active
argument_list|)
argument_list|,
operator|&
name|rvals
operator|.
name|scales_mode
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|combo
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"_Level:"
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|,
name|combo
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|combo
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"_Scale:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
name|ENTRY_WIDTH
argument_list|,
name|rvals
operator|.
name|scale
argument_list|,
name|MIN_GAUSSIAN_SCALE
argument_list|,
name|MAX_GAUSSIAN_SCALE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|rvals
operator|.
name|scale
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"Scale _division:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
name|ENTRY_WIDTH
argument_list|,
name|rvals
operator|.
name|nscales
argument_list|,
literal|0
argument_list|,
name|MAX_RETINEX_SCALES
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|rvals
operator|.
name|nscales
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|adj
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|_
argument_list|(
literal|"Dy_namic:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
name|ENTRY_WIDTH
argument_list|,
name|rvals
operator|.
name|cvar
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0.1
argument_list|,
literal|0.1
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_float_adjustment_update
argument_list|)
argument_list|,
operator|&
name|rvals
operator|.
name|cvar
argument_list|)
expr_stmt|;
name|g_signal_connect_swapped
argument_list|(
name|adj
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_preview_invalidate
argument_list|)
argument_list|,
name|preview
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  * Applies the algorithm  */
end_comment

begin_function
specifier|static
name|void
DECL|function|retinex (GimpDrawable * drawable,GimpPreview * preview)
name|retinex
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpPreview
modifier|*
name|preview
parameter_list|)
block|{
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|gint
name|size
decl_stmt|,
name|bytes
decl_stmt|;
name|guchar
modifier|*
name|src
init|=
name|NULL
decl_stmt|;
name|guchar
modifier|*
name|psrc
init|=
name|NULL
decl_stmt|;
name|GimpPixelRgn
name|dst_rgn
decl_stmt|,
name|src_rgn
decl_stmt|;
name|bytes
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
comment|/*    * Get the size of the current image or its selection.    */
if|if
condition|(
name|preview
condition|)
block|{
name|src
operator|=
name|gimp_zoom_preview_get_source
argument_list|(
name|GIMP_ZOOM_PREVIEW
argument_list|(
name|preview
argument_list|)
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|gimp_drawable_mask_intersect
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
condition|)
return|return;
comment|/* Allocate memory */
name|size
operator|=
name|width
operator|*
name|height
operator|*
name|bytes
expr_stmt|;
name|src
operator|=
name|g_try_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|g_warning
argument_list|(
literal|"Failed to allocate memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
comment|/* Fill allocated memory with pixel data */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
comment|/*     Algorithm for Multi-scale Retinex with color Restoration (MSRCR).    */
name|psrc
operator|=
name|src
expr_stmt|;
name|MSRCR
argument_list|(
name|psrc
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bytes
argument_list|,
name|preview
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|preview
condition|)
block|{
name|gimp_preview_draw_buffer
argument_list|(
name|preview
argument_list|,
name|psrc
argument_list|,
name|width
operator|*
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dst_rgn
argument_list|,
name|drawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|dst_rgn
argument_list|,
name|psrc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * calculate scale values for desired distribution.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|retinex_scales_distribution (gfloat * scales,gint nscales,gint mode,gint s)
name|retinex_scales_distribution
parameter_list|(
name|gfloat
modifier|*
name|scales
parameter_list|,
name|gint
name|nscales
parameter_list|,
name|gint
name|mode
parameter_list|,
name|gint
name|s
parameter_list|)
block|{
if|if
condition|(
name|nscales
operator|==
literal|1
condition|)
block|{
comment|/* For one filter we choose the median scale */
name|scales
index|[
literal|0
index|]
operator|=
operator|(
name|gint
operator|)
name|s
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nscales
operator|==
literal|2
condition|)
block|{
comment|/* For two filters whe choose the median and maximum scale */
name|scales
index|[
literal|0
index|]
operator|=
operator|(
name|gint
operator|)
name|s
operator|/
literal|2
expr_stmt|;
name|scales
index|[
literal|1
index|]
operator|=
operator|(
name|gint
operator|)
name|s
expr_stmt|;
block|}
else|else
block|{
name|gfloat
name|size_step
init|=
operator|(
name|gfloat
operator|)
name|s
operator|/
operator|(
name|gfloat
operator|)
name|nscales
decl_stmt|;
name|gint
name|i
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|RETINEX_UNIFORM
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscales
condition|;
operator|++
name|i
control|)
name|scales
index|[
name|i
index|]
operator|=
literal|2.
operator|+
operator|(
name|gfloat
operator|)
name|i
operator|*
name|size_step
expr_stmt|;
break|break;
case|case
name|RETINEX_LOW
case|:
name|size_step
operator|=
operator|(
name|gfloat
operator|)
name|log
argument_list|(
name|s
operator|-
literal|2.0
argument_list|)
operator|/
operator|(
name|gfloat
operator|)
name|nscales
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscales
condition|;
operator|++
name|i
control|)
name|scales
index|[
name|i
index|]
operator|=
literal|2.
operator|+
name|pow
argument_list|(
literal|10
argument_list|,
operator|(
name|i
operator|*
name|size_step
operator|)
operator|/
name|log
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETINEX_HIGH
case|:
name|size_step
operator|=
operator|(
name|gfloat
operator|)
name|log
argument_list|(
name|s
operator|-
literal|2.0
argument_list|)
operator|/
operator|(
name|gfloat
operator|)
name|nscales
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscales
condition|;
operator|++
name|i
control|)
name|scales
index|[
name|i
index|]
operator|=
name|s
operator|-
name|pow
argument_list|(
literal|10
argument_list|,
operator|(
name|i
operator|*
name|size_step
operator|)
operator|/
name|log
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Calculate the coefficients for the recursive filter algorithm  * Fast Computation of gaussian blurring.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|compute_coefs3 (gauss3_coefs * c,gfloat sigma)
name|compute_coefs3
parameter_list|(
name|gauss3_coefs
modifier|*
name|c
parameter_list|,
name|gfloat
name|sigma
parameter_list|)
block|{
comment|/*    * Papers:  "Recursive Implementation of the gaussian filter.",    *          Ian T. Young , Lucas J. Van Vliet, Signal Processing 44, Elsevier 1995.    * formula: 11b       computation of q    *          8c        computation of b0..b1    *          10        alpha is normalization constant B    */
name|gfloat
name|q
decl_stmt|,
name|q2
decl_stmt|,
name|q3
decl_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigma
operator|>=
literal|2.5
condition|)
block|{
name|q
operator|=
literal|0.98711
operator|*
name|sigma
operator|-
literal|0.96330
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sigma
operator|>=
literal|0.5
operator|)
operator|&&
operator|(
name|sigma
operator|<
literal|2.5
operator|)
condition|)
block|{
name|q
operator|=
literal|3.97156
operator|-
literal|4.14554
operator|*
operator|(
name|gfloat
operator|)
name|sqrt
argument_list|(
operator|(
name|double
operator|)
literal|1
operator|-
literal|0.26891
operator|*
name|sigma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
literal|0.1147705018520355224609375
expr_stmt|;
block|}
name|q2
operator|=
name|q
operator|*
name|q
expr_stmt|;
name|q3
operator|=
name|q
operator|*
name|q2
expr_stmt|;
name|c
operator|->
name|b
index|[
literal|0
index|]
operator|=
operator|(
literal|1.57825
operator|+
operator|(
literal|2.44413
operator|*
name|q
operator|)
operator|+
operator|(
literal|1.4281
operator|*
name|q2
operator|)
operator|+
operator|(
literal|0.422205
operator|*
name|q3
operator|)
operator|)
expr_stmt|;
name|c
operator|->
name|b
index|[
literal|1
index|]
operator|=
operator|(
operator|(
literal|2.44413
operator|*
name|q
operator|)
operator|+
operator|(
literal|2.85619
operator|*
name|q2
operator|)
operator|+
operator|(
literal|1.26661
operator|*
name|q3
operator|)
operator|)
expr_stmt|;
name|c
operator|->
name|b
index|[
literal|2
index|]
operator|=
operator|(
operator|-
operator|(
operator|(
literal|1.4281
operator|*
name|q2
operator|)
operator|+
operator|(
literal|1.26661
operator|*
name|q3
operator|)
operator|)
operator|)
expr_stmt|;
name|c
operator|->
name|b
index|[
literal|3
index|]
operator|=
operator|(
operator|(
literal|0.422205
operator|*
name|q3
operator|)
operator|)
expr_stmt|;
name|c
operator|->
name|B
operator|=
literal|1.0
operator|-
operator|(
operator|(
name|c
operator|->
name|b
index|[
literal|1
index|]
operator|+
name|c
operator|->
name|b
index|[
literal|2
index|]
operator|+
name|c
operator|->
name|b
index|[
literal|3
index|]
operator|)
operator|/
name|c
operator|->
name|b
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|c
operator|->
name|sigma
operator|=
name|sigma
expr_stmt|;
name|c
operator|->
name|N
operator|=
literal|3
expr_stmt|;
comment|/*   g_printerr ("q %f\n", q);   g_printerr ("q2 %f\n", q2);   g_printerr ("q3 %f\n", q3);   g_printerr ("c->b[0] %f\n", c->b[0]);   g_printerr ("c->b[1] %f\n", c->b[1]);   g_printerr ("c->b[2] %f\n", c->b[2]);   g_printerr ("c->b[3] %f\n", c->b[3]);   g_printerr ("c->B %f\n", c->B);   g_printerr ("c->sigma %f\n", c->sigma);   g_printerr ("c->N %d\n", c->N); */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gausssmooth (gfloat * in,gfloat * out,gint size,gint rowstride,gauss3_coefs * c)
name|gausssmooth
parameter_list|(
name|gfloat
modifier|*
name|in
parameter_list|,
name|gfloat
modifier|*
name|out
parameter_list|,
name|gint
name|size
parameter_list|,
name|gint
name|rowstride
parameter_list|,
name|gauss3_coefs
modifier|*
name|c
parameter_list|)
block|{
comment|/*    * Papers:  "Recursive Implementation of the gaussian filter.",    *          Ian T. Young , Lucas J. Van Vliet, Signal Processing 44, Elsevier 1995.    * formula: 9a        forward filter    *          9b        backward filter    *          fig7      algorithm    */
name|gint
name|i
decl_stmt|,
name|n
decl_stmt|,
name|bufsize
decl_stmt|;
name|gfloat
modifier|*
name|w1
decl_stmt|,
modifier|*
name|w2
decl_stmt|;
comment|/* forward pass */
name|bufsize
operator|=
name|size
operator|+
literal|3
expr_stmt|;
name|size
operator|-=
literal|1
expr_stmt|;
name|w1
operator|=
operator|(
name|gfloat
operator|*
operator|)
name|g_try_malloc
argument_list|(
name|bufsize
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
name|w2
operator|=
operator|(
name|gfloat
operator|*
operator|)
name|g_try_malloc
argument_list|(
name|bufsize
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
name|w1
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|w1
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|w1
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|3
init|;
name|i
operator|<=
name|size
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|w1
index|[
name|n
index|]
operator|=
call|(
name|gfloat
call|)
argument_list|(
name|c
operator|->
name|B
operator|*
name|in
index|[
name|i
operator|*
name|rowstride
index|]
operator|+
operator|(
operator|(
name|c
operator|->
name|b
index|[
literal|1
index|]
operator|*
name|w1
index|[
name|n
operator|-
literal|1
index|]
operator|+
name|c
operator|->
name|b
index|[
literal|2
index|]
operator|*
name|w1
index|[
name|n
operator|-
literal|2
index|]
operator|+
name|c
operator|->
name|b
index|[
literal|3
index|]
operator|*
name|w1
index|[
name|n
operator|-
literal|3
index|]
operator|)
operator|/
name|c
operator|->
name|b
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* backward pass */
name|w2
index|[
name|size
operator|+
literal|1
index|]
operator|=
name|w1
index|[
name|size
operator|+
literal|3
index|]
expr_stmt|;
name|w2
index|[
name|size
operator|+
literal|2
index|]
operator|=
name|w1
index|[
name|size
operator|+
literal|3
index|]
expr_stmt|;
name|w2
index|[
name|size
operator|+
literal|3
index|]
operator|=
name|w1
index|[
name|size
operator|+
literal|3
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|,
name|n
operator|=
name|i
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|n
operator|--
control|)
block|{
name|w2
index|[
name|n
index|]
operator|=
name|out
index|[
name|i
operator|*
name|rowstride
index|]
operator|=
call|(
name|gfloat
call|)
argument_list|(
name|c
operator|->
name|B
operator|*
name|w1
index|[
name|n
operator|+
literal|3
index|]
operator|+
operator|(
operator|(
name|c
operator|->
name|b
index|[
literal|1
index|]
operator|*
name|w2
index|[
name|n
operator|+
literal|1
index|]
operator|+
name|c
operator|->
name|b
index|[
literal|2
index|]
operator|*
name|w2
index|[
name|n
operator|+
literal|2
index|]
operator|+
name|c
operator|->
name|b
index|[
literal|3
index|]
operator|*
name|w2
index|[
name|n
operator|+
literal|3
index|]
operator|)
operator|/
name|c
operator|->
name|b
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|w1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|w2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is the heart of the algo.  * (a)  Filterings at several scales and sumarize the results.  * (b)  Calculation of the final values.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|MSRCR (guchar * src,gint width,gint height,gint bytes,gboolean preview_mode)
name|MSRCR
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|bytes
parameter_list|,
name|gboolean
name|preview_mode
parameter_list|)
block|{
name|gint
name|scale
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|size
decl_stmt|;
name|gint
name|pos
decl_stmt|;
name|gint
name|channel
decl_stmt|;
name|guchar
modifier|*
name|psrc
init|=
name|NULL
decl_stmt|;
comment|/* backup pointer for src buffer */
name|gfloat
modifier|*
name|dst
init|=
name|NULL
decl_stmt|;
comment|/* float buffer for algorithm */
name|gfloat
modifier|*
name|pdst
init|=
name|NULL
decl_stmt|;
comment|/* backup pointer for float buffer */
name|gfloat
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|gint
name|channelsize
decl_stmt|;
comment|/* Float memory cache for one channel */
name|gfloat
name|weight
decl_stmt|;
name|gauss3_coefs
name|coef
decl_stmt|;
name|gfloat
name|mean
decl_stmt|,
name|var
decl_stmt|;
name|gfloat
name|mini
decl_stmt|,
name|range
decl_stmt|,
name|maxi
decl_stmt|;
name|gfloat
name|alpha
decl_stmt|;
name|gfloat
name|gain
decl_stmt|;
name|gfloat
name|offset
decl_stmt|;
name|gdouble
name|max_preview
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
operator|!
name|preview_mode
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Retinex: filtering"
argument_list|)
argument_list|)
expr_stmt|;
name|max_preview
operator|=
literal|3
operator|*
name|rvals
operator|.
name|nscales
expr_stmt|;
block|}
comment|/* Allocate all the memory needed for algorithm*/
name|size
operator|=
name|width
operator|*
name|height
operator|*
name|bytes
expr_stmt|;
name|dst
operator|=
name|g_try_malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|g_warning
argument_list|(
literal|"Failed to allocate memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
name|channelsize
operator|=
operator|(
name|width
operator|*
name|height
operator|)
expr_stmt|;
name|in
operator|=
operator|(
name|gfloat
operator|*
operator|)
name|g_try_malloc
argument_list|(
name|channelsize
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|g_warning
argument_list|(
literal|"Failed to allocate memory"
argument_list|)
expr_stmt|;
return|return;
comment|/* do some clever stuff */
block|}
name|out
operator|=
operator|(
name|gfloat
operator|*
operator|)
name|g_try_malloc
argument_list|(
name|channelsize
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|g_warning
argument_list|(
literal|"Failed to allocate memory"
argument_list|)
expr_stmt|;
return|return;
comment|/* do some clever stuff */
block|}
comment|/*      Calculate the scales of filtering according to the      number of filter and their distribution.    */
name|retinex_scales_distribution
argument_list|(
name|RetinexScales
argument_list|,
name|rvals
operator|.
name|nscales
argument_list|,
name|rvals
operator|.
name|scales_mode
argument_list|,
name|rvals
operator|.
name|scale
argument_list|)
expr_stmt|;
comment|/*       Filtering according to the various scales.       Summerize the results of the various filters according to a       specific weight(here equivalent for all).   */
name|weight
operator|=
literal|1.
operator|/
operator|(
name|gfloat
operator|)
name|rvals
operator|.
name|nscales
expr_stmt|;
comment|/*     The recursive filtering algorithm needs different coefficients according     to the selected scale (~ = standard deviation of Gaussian).    */
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
literal|3
condition|;
name|channel
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
name|channel
init|;
name|i
operator|<
name|channelsize
condition|;
name|i
operator|++
operator|,
name|pos
operator|+=
name|bytes
control|)
block|{
comment|/* 0-255 => 1-256 */
name|in
index|[
name|i
index|]
operator|=
call|(
name|gfloat
call|)
argument_list|(
name|src
index|[
name|pos
index|]
operator|+
literal|1.0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|scale
operator|=
literal|0
init|;
name|scale
operator|<
name|rvals
operator|.
name|nscales
condition|;
name|scale
operator|++
control|)
block|{
name|compute_coefs3
argument_list|(
operator|&
name|coef
argument_list|,
name|RetinexScales
index|[
name|scale
index|]
argument_list|)
expr_stmt|;
comment|/*            *  Filtering (smoothing) Gaussian recursive.            *            *  Filter rows first            */
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
control|)
block|{
name|pos
operator|=
name|row
operator|*
name|width
expr_stmt|;
name|gausssmooth
argument_list|(
name|in
operator|+
name|pos
argument_list|,
name|out
operator|+
name|pos
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
operator|&
name|coef
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|channelsize
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|channelsize
operator|*
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
argument_list|)
expr_stmt|;
comment|/*            *  Filtering (smoothing) Gaussian recursive.            *            *  Second columns            */
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
name|col
operator|++
control|)
block|{
name|pos
operator|=
name|col
expr_stmt|;
name|gausssmooth
argument_list|(
name|in
operator|+
name|pos
argument_list|,
name|out
operator|+
name|pos
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
operator|&
name|coef
argument_list|)
expr_stmt|;
block|}
comment|/*              Summarize the filtered values.              In fact one calculates a ratio between the original values and the filtered values.            */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
name|channel
init|;
name|i
operator|<
name|channelsize
condition|;
name|i
operator|++
operator|,
name|pos
operator|+=
name|bytes
control|)
block|{
name|dst
index|[
name|pos
index|]
operator|+=
name|weight
operator|*
operator|(
name|log
argument_list|(
name|src
index|[
name|pos
index|]
operator|+
literal|1.
argument_list|)
operator|-
name|log
argument_list|(
name|out
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|preview_mode
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|channel
operator|*
name|rvals
operator|.
name|nscales
operator|+
name|scale
operator|)
operator|/
name|max_preview
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/*       Final calculation with original value and cumulated filter values.       The parameters gain, alpha and offset are constants.   */
comment|/* Ci(x,y)=log[a Ii(x,y)]-log[ Ei=1-s Ii(x,y)] */
name|alpha
operator|=
literal|128.
expr_stmt|;
name|gain
operator|=
literal|1.
expr_stmt|;
name|offset
operator|=
literal|0.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|bytes
control|)
block|{
name|gfloat
name|logl
decl_stmt|;
name|psrc
operator|=
name|src
operator|+
name|i
expr_stmt|;
name|pdst
operator|=
name|dst
operator|+
name|i
expr_stmt|;
name|logl
operator|=
name|log
argument_list|(
operator|(
name|gfloat
operator|)
name|psrc
index|[
literal|0
index|]
operator|+
operator|(
name|gfloat
operator|)
name|psrc
index|[
literal|1
index|]
operator|+
operator|(
name|gfloat
operator|)
name|psrc
index|[
literal|2
index|]
operator|+
literal|3.
argument_list|)
expr_stmt|;
name|pdst
index|[
literal|0
index|]
operator|=
name|gain
operator|*
operator|(
operator|(
name|log
argument_list|(
name|alpha
operator|*
operator|(
name|psrc
index|[
literal|0
index|]
operator|+
literal|1.
operator|)
argument_list|)
operator|-
name|logl
operator|)
operator|*
name|pdst
index|[
literal|0
index|]
operator|)
operator|+
name|offset
expr_stmt|;
name|pdst
index|[
literal|1
index|]
operator|=
name|gain
operator|*
operator|(
operator|(
name|log
argument_list|(
name|alpha
operator|*
operator|(
name|psrc
index|[
literal|1
index|]
operator|+
literal|1.
operator|)
argument_list|)
operator|-
name|logl
operator|)
operator|*
name|pdst
index|[
literal|1
index|]
operator|)
operator|+
name|offset
expr_stmt|;
name|pdst
index|[
literal|2
index|]
operator|=
name|gain
operator|*
operator|(
operator|(
name|log
argument_list|(
name|alpha
operator|*
operator|(
name|psrc
index|[
literal|2
index|]
operator|+
literal|1.
operator|)
argument_list|)
operator|-
name|logl
operator|)
operator|*
name|pdst
index|[
literal|2
index|]
operator|)
operator|+
name|offset
expr_stmt|;
block|}
comment|/*  if (!preview_mode)     gimp_progress_update ((2.0 + (rvals.nscales * 3)) /                           ((rvals.nscales * 3) + 3));*/
comment|/*       Adapt the dynamics of the colors according to the statistics of the first and second order.       The use of the variance makes it possible to control the degree of saturation of the colors.   */
name|pdst
operator|=
name|dst
expr_stmt|;
name|compute_mean_var
argument_list|(
name|pdst
argument_list|,
operator|&
name|mean
argument_list|,
operator|&
name|var
argument_list|,
name|size
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|mini
operator|=
name|mean
operator|-
name|rvals
operator|.
name|cvar
operator|*
name|var
expr_stmt|;
name|maxi
operator|=
name|mean
operator|+
name|rvals
operator|.
name|cvar
operator|*
name|var
expr_stmt|;
name|range
operator|=
name|maxi
operator|-
name|mini
expr_stmt|;
if|if
condition|(
operator|!
name|range
condition|)
name|range
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|bytes
control|)
block|{
name|psrc
operator|=
name|src
operator|+
name|i
expr_stmt|;
name|pdst
operator|=
name|dst
operator|+
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|gfloat
name|c
init|=
literal|255
operator|*
operator|(
name|pdst
index|[
name|j
index|]
operator|-
name|mini
operator|)
operator|/
name|range
decl_stmt|;
name|psrc
index|[
name|j
index|]
operator|=
operator|(
name|guchar
operator|)
name|CLAMP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the average and variance in one go.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|compute_mean_var (gfloat * src,gfloat * mean,gfloat * var,gint size,gint bytes)
name|compute_mean_var
parameter_list|(
name|gfloat
modifier|*
name|src
parameter_list|,
name|gfloat
modifier|*
name|mean
parameter_list|,
name|gfloat
modifier|*
name|var
parameter_list|,
name|gint
name|size
parameter_list|,
name|gint
name|bytes
parameter_list|)
block|{
name|gfloat
name|vsquared
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gfloat
modifier|*
name|psrc
decl_stmt|;
name|vsquared
operator|=
literal|0
expr_stmt|;
operator|*
name|mean
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|bytes
control|)
block|{
name|psrc
operator|=
name|src
operator|+
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|mean
operator|+=
name|psrc
index|[
name|j
index|]
expr_stmt|;
name|vsquared
operator|+=
name|psrc
index|[
name|j
index|]
operator|*
name|psrc
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
operator|*
name|mean
operator|/=
operator|(
name|gfloat
operator|)
name|size
expr_stmt|;
comment|/* mean */
name|vsquared
operator|/=
operator|(
name|gfloat
operator|)
name|size
expr_stmt|;
comment|/* mean (x^2) */
operator|*
name|var
operator|=
operator|(
name|vsquared
operator|-
operator|(
operator|*
name|mean
operator|*
operator|*
name|mean
operator|)
operator|)
expr_stmt|;
operator|*
name|var
operator|=
name|sqrt
argument_list|(
operator|*
name|var
argument_list|)
expr_stmt|;
comment|/* var */
block|}
end_function

end_unit

