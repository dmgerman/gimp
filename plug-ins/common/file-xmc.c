begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   X11 Mouse Cursor (XMC) plug-in for GIMP  *  *   Copyright 2008-2009 Takeshi Matsuyama<tksmashiw@gmail.com>  *  *   Special thanks: Alexia Death, Sven Neumann, Martin Nordholts  *                   and all community members.  */
end_comment

begin_comment
comment|/*  *   This program is free software: you can redistribute it and/or modify  *   it under the terms of the GNU General Public License as published by  *   the Free Software Foundation, either version 3 of the License, or  *   (at your option) any later version.  *  *   This program is distributed in the hope that it will be useful,  *   but WITHOUT ANY WARRANTY; without even the implied warranty of  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *   GNU General Public License for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/*  * Todo: if drawable->bpp != 4 in save_image for GIMP-2.8?  * Todo: support for "gimp-metadata" parasite.  *       "xmc-copyright" and "xmc-license" may be deprecated in future?  */
end_comment

begin_comment
comment|/*  * This plug-in use these four parasites.  * "hot-spot"       common with file-xbm plug-in  * "xmc-copyright"  original, store contents of type1 comment chunk of Xcursor  * "xmc-license"    original, store contents of type2 comment chunk of Xcursor  * "gimp-comment"   common, store contents of type3 comment chunk of Xcursor  */
end_comment

begin_comment
comment|/* *** Caution: Size vs Dimension ***  *  * In this file, "size" and "dimension" are used in definitely  * different contexts.  "Size" means nominal size of Xcursor which is  * used to determine which frame depends on which animation sequence  * and which sequence is really used. (for more detail, please read  * Xcursor(3).)  On the other hand, "Dimension" simply means width  * and/or height.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<glib/gprintf.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xcursor/Xcursor.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* For debug */
end_comment

begin_comment
comment|/* #define XMC_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XMC_DEBUG
end_ifdef

begin_define
DECL|macro|DM_XMC (...)
define|#
directive|define
name|DM_XMC
parameter_list|(
modifier|...
parameter_list|)
value|g_fprintf(stderr, __VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|DM_XMC (...)
define|#
directive|define
name|DM_XMC
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Constants...  */
end_comment

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-xmc-load"
end_define

begin_define
DECL|macro|LOAD_THUMB_PROC
define|#
directive|define
name|LOAD_THUMB_PROC
value|"file-xmc-load-thumb"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-xmc-save"
end_define

begin_comment
comment|/* save without file extension "xmc" */
end_comment

begin_define
DECL|macro|SAVE_PROC2
define|#
directive|define
name|SAVE_PROC2
value|"file-xmc-save2"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-xmc"
end_define

begin_comment
comment|/* We use "xmc" as the file extension of X cursor for convenience */
end_comment

begin_define
DECL|macro|XCURSOR_EXTENSION
define|#
directive|define
name|XCURSOR_EXTENSION
value|"xmc"
end_define

begin_define
DECL|macro|XCURSOR_MIME_TYPE
define|#
directive|define
name|XCURSOR_MIME_TYPE
value|"image/x-xcursor"
end_define

begin_comment
comment|/* The maximum dimension of Xcursor which is fully supported in any  * environments. This is defined on line 59 of xcursorint.h in  * libXcursor source code. Make sure this is about dimensions(width  * and height) not about nominal size despite of it's name.  */
end_comment

begin_define
DECL|macro|MAX_BITMAP_CURSOR_SIZE
define|#
directive|define
name|MAX_BITMAP_CURSOR_SIZE
value|64
end_define

begin_comment
comment|/* The maximum dimension of each frame of X cursor we want to save  * should be MAX_BITMAP_CURSOR_SIZE but about loading, xhot(& yhot) of  * each frame varies from 0 to MAX_BITMAP_CURSOR_SIZE-1, so we need to  * set the maximum dimension of image no less than  * MAX_BITMAP_CURSOR_SIZE * 2( -1 to be precise) to remain hotspots on  * the same coordinates.  *  * We use four times value (256 for saving, 512 for loading) as a  * limitation because some cursors generated by CursorXP/FX to X11  * Mouse Theme Converter is very large.  *  * The biggest cursor I found is "watch" of OuterLimits which size is  * 213x208.  If you found bigger one, please tell me ;-)  */
end_comment

begin_define
DECL|macro|MAX_LOAD_DIMENSION
define|#
directive|define
name|MAX_LOAD_DIMENSION
value|512
end_define

begin_define
DECL|macro|MAX_SAVE_DIMENSION
define|#
directive|define
name|MAX_SAVE_DIMENSION
value|256
end_define

begin_comment
comment|/* The maximum number of different nominal sizes in one cursor this  * plug-in can treat. This is based on the number of cursor size which  * gnome-appearance-properties supports.(12,16,24,32,36,40,48,64)  * ref. capplets/common/gnome-theme-info.c in source of  * gnome-control-center  */
end_comment

begin_define
DECL|macro|MAX_SIZE_NUM
define|#
directive|define
name|MAX_SIZE_NUM
value|8
end_define

begin_comment
comment|/* cursor delay is guint32 defined in Xcursor.h */
end_comment

begin_define
DECL|macro|CURSOR_MAX_DELAY
define|#
directive|define
name|CURSOR_MAX_DELAY
value|100000000
end_define

begin_define
DECL|macro|CURSOR_DEFAULT_DELAY
define|#
directive|define
name|CURSOR_DEFAULT_DELAY
value|50
end_define

begin_define
DECL|macro|CURSOR_MINIMUM_DELAY
define|#
directive|define
name|CURSOR_MINIMUM_DELAY
value|5
end_define

begin_define
DECL|macro|div_255 (x)
define|#
directive|define
name|div_255
parameter_list|(
name|x
parameter_list|)
value|(((x) + 0x80 + (((x) + 0x80)>> 8))>> 8)
end_define

begin_define
DECL|macro|READ32 (f,e)
define|#
directive|define
name|READ32
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
value|read32 ((f), (e)); if (*(e)) return -1;
end_define

begin_define
DECL|macro|DISPLAY_DIGIT (x)
define|#
directive|define
name|DISPLAY_DIGIT
parameter_list|(
name|x
parameter_list|)
value|((x)> 100) ? 3 : ((x)> 10) ? 2 : 1
end_define

begin_comment
comment|/*  * Structures...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2b8abdda0108
block|{
DECL|member|crop
name|gboolean
name|crop
decl_stmt|;
DECL|member|size
name|gint
name|size
decl_stmt|;
DECL|member|size_replace
name|gboolean
name|size_replace
decl_stmt|;
DECL|member|delay
name|gint32
name|delay
decl_stmt|;
DECL|member|delay_replace
name|gboolean
name|delay_replace
decl_stmt|;
DECL|typedef|XmcSaveVals
block|}
name|XmcSaveVals
typedef|;
end_typedef

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_thumbnail
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|thumb_size
parameter_list|,
name|gint32
modifier|*
name|width
parameter_list|,
name|gint32
modifier|*
name|height
parameter_list|,
name|gint32
modifier|*
name|num_layers
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint32
name|read32
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
name|GimpParamRegion
modifier|*
name|hotspotRange
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comment_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|text_view_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|load_default_hotspot
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
name|GimpParamRegion
modifier|*
name|hotspotRange
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|guint32
name|separate_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|guint32
name|premultiply_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XcursorComments
modifier|*
name|set_cursor_comments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_comments
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|set_comment_to_pname
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
specifier|const
name|gchar
modifier|*
name|content
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|get_comment_from_pname
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|set_hotspot_to_parasite
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|get_hotspot_from_parasite
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_size_and_delay
parameter_list|(
specifier|const
name|gchar
modifier|*
name|framename
parameter_list|,
name|guint32
modifier|*
name|sizep
parameter_list|,
name|guint32
modifier|*
name|delayp
parameter_list|,
name|GRegex
modifier|*
name|re
parameter_list|,
name|gboolean
modifier|*
name|size_warnp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|make_framename
parameter_list|(
name|guint32
name|size
parameter_list|,
name|guint32
name|delay
parameter_list|,
name|guint
name|indent
parameter_list|,
name|GError
modifier|*
modifier|*
name|errorp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_cropped_region
parameter_list|(
name|GimpParamRegion
modifier|*
name|retrun_rgn
parameter_list|,
name|GimpPixelRgn
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gboolean
name|pix_is_opaque
parameter_list|(
name|guint32
name|pix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpParamRegion
modifier|*
name|get_intersection_of_frames
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|pix_in_region
parameter_list|(
name|gint32
name|x
parameter_list|,
name|gint32
name|y
parameter_list|,
name|GimpParamRegion
modifier|*
name|xmcrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_hotspots_and_dimensions
parameter_list|(
name|XcursorImages
modifier|*
name|xcIs
parameter_list|,
name|gint32
modifier|*
name|xhot
parameter_list|,
name|gint32
modifier|*
name|yhot
parameter_list|,
name|gint32
modifier|*
name|width
parameter_list|,
name|gint32
modifier|*
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Globals...  */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|query
block|,
name|run
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmcvals
specifier|static
name|XmcSaveVals
name|xmcvals
init|=
block|{
comment|/* saved in pdb after this plug-in's process has gone. */
name|FALSE
block|,
comment|/* crop */
literal|32
block|,
comment|/* size */
name|FALSE
block|,
comment|/* size_replace */
name|CURSOR_DEFAULT_DELAY
block|,
comment|/* delay */
name|FALSE
comment|/* delay_replace */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2b8abdda0208
block|{
comment|/* saved as parasites of original image after this plug-in's process has gone.*/
DECL|member|x
name|gint32
name|x
decl_stmt|;
comment|/* hotspot x */
DECL|member|y
name|gint32
name|y
decl_stmt|;
comment|/* hotspot y */
DECL|member|comments
name|gchar
modifier|*
name|comments
index|[
literal|3
index|]
decl_stmt|;
comment|/* copyright, license, other */
DECL|variable|xmcparas
block|}
name|xmcparas
init|=
block|{
literal|0
block|,}
struct|;
end_struct

begin_comment
comment|/* parasites correspond to XcursorComment type */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|gchar
modifier|*
DECL|variable|parasiteName
name|parasiteName
index|[
literal|3
index|]
init|=
block|{
literal|"xmc-copyright"
block|,
literal|"xmc-license"
block|,
literal|"gimp-comment"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'main()' - Main entry - just call gimp_main()...  */
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_comment
comment|/*  * 'query()' - Respond to a plug-in query...  */
end_comment

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name of the file to load"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|thumb_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"thumb-size"
block|,
literal|"Preferred thumbnail size"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|thumb_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Thumbnail image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"image-width"
block|,
literal|"The width of image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"image-height"
block|,
literal|"The height of image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"image-type"
block|,
literal|"The color type of image"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"image-num-layers"
block|,
literal|"The number of layeres"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name entered"
block|}
block|,
comment|/* following elements are XMC specific options */
block|{
name|GIMP_PDB_INT32
block|,
literal|"x_hot"
block|,
literal|"X-coordinate of hot spot"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"y_hot"
block|,
literal|"Y-coordinate of hot spot\n"
literal|"Use (-1, -1) to keep original hot spot."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"crop"
block|,
literal|"Auto-crop or not"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"size"
block|,
literal|"Default nominal size"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"size_replace"
block|,
literal|"Replace existent size or not."
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"delay"
block|,
literal|"Default delay"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"delay_replace"
block|,
literal|"Replace existent delay or not."
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"copyright"
block|,
literal|"Copyright information."
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"license"
block|,
literal|"License information."
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"other"
block|,
literal|"Other comment.(taken from "
literal|"\"gimp-comment\" parasite)"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"Loads files of X11 Mouse Cursor file format"
argument_list|,
literal|"This plug-in loads X11 Mouse Cursor (XMC) files."
argument_list|,
literal|"Takeshi Matsuyama<tksmashiw@gmail.com>"
argument_list|,
literal|"Takeshi Matsuyama"
argument_list|,
literal|"26 May 2009"
argument_list|,
name|N_
argument_list|(
literal|"X11 Mouse Cursor"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_return_vals
argument_list|)
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|LOAD_PROC
argument_list|,
name|XCURSOR_MIME_TYPE
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
name|LOAD_PROC
argument_list|,
name|XCURSOR_EXTENSION
argument_list|,
literal|""
argument_list|,
literal|"0,string,Xcur"
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|LOAD_THUMB_PROC
argument_list|,
literal|"Loads only first frame of X11 Mouse Cursor's "
literal|"animation sequence which nominal size is the closest "
literal|"of thumb-size to be used as a thumbnail"
argument_list|,
literal|""
argument_list|,
literal|"Takeshi Matsuyama<tksmashiw@gmail.com>"
argument_list|,
literal|"Takeshi Matsuyama"
argument_list|,
literal|"26 May 2009"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|thumb_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|thumb_return_vals
argument_list|)
argument_list|,
name|thumb_args
argument_list|,
name|thumb_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_thumbnail_loader
argument_list|(
name|LOAD_PROC
argument_list|,
name|LOAD_THUMB_PROC
argument_list|)
expr_stmt|;
DECL|macro|GIMP_INSTALL_SAVE_PROC (mProc,mAdd)
define|#
directive|define
name|GIMP_INSTALL_SAVE_PROC
parameter_list|(
name|mProc
parameter_list|,
name|mAdd
parameter_list|)
define|\
value|gimp_install_procedure ((mProc),\         "Saves files of X11 cursor file",\         "This plug-in saves X11 Mouse Cursor (XMC) files"\         #mAdd,\         "Takeshi Matsuyama<tksmashiw@gmail.com>",\         "Takeshi Matsuyama",\         "26 May 2009",\         N_("X11 Mouse Cursor"),\         "RGBA",\         GIMP_PLUGIN,\         G_N_ELEMENTS (save_args), 0,\         save_args, NULL)
name|GIMP_INSTALL_SAVE_PROC
argument_list|(
name|SAVE_PROC
argument_list|,
operator|.
argument_list|)
expr_stmt|;
name|GIMP_INSTALL_SAVE_PROC
argument_list|(
argument|SAVE_PROC2
argument_list|,
argument|\nwithout file extension.
argument_list|)
empty_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|SAVE_PROC
argument_list|,
name|XCURSOR_MIME_TYPE
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
name|SAVE_PROC
argument_list|,
name|XCURSOR_EXTENSION
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|SAVE_PROC2
argument_list|,
name|XCURSOR_MIME_TYPE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'run()' - Run the plug-in...  */
end_comment

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|gint32
name|orig_image_ID
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GimpParamRegion
modifier|*
name|hotspotRange
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint32
name|width
decl_stmt|,
name|height
decl_stmt|,
name|num_layers
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"run: start.\n"
argument_list|)
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Starting to load file.\tparam.data=%s\n"
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"LOAD_PROC successfully load image. image_ID=%i\n"
argument_list|,
name|image_ID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_THUMB_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Starting to load thumbnail.\tfilename=%s\tthumb-size=%d\n"
argument_list|,
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|)
expr_stmt|;
name|image_ID
operator|=
name|load_thumbnail
argument_list|(
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|num_layers
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|6
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_INT32
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
operator|=
name|width
expr_stmt|;
comment|/* width */
name|values
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_INT32
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
operator|=
name|height
expr_stmt|;
comment|/* height */
comment|/* This will not work on GIMP 2.6, but not harmful. */
name|values
index|[
literal|4
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_INT32
expr_stmt|;
name|values
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
operator|=
name|GIMP_RGBA_IMAGE
expr_stmt|;
comment|/* type */
name|values
index|[
literal|5
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_INT32
expr_stmt|;
name|values
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
operator|=
name|num_layers
expr_stmt|;
comment|/* num_layers */
name|DM_XMC
argument_list|(
literal|"LOAD_THUMB_PROC successfully load image. image_ID=%i\n"
argument_list|,
name|image_ID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"run: save %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|image_ID
operator|=
name|orig_image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|hotspotRange
operator|=
name|get_intersection_of_frames
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hotspotRange
condition|)
block|{
name|g_set_error
argument_list|(
operator|&
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Cannot set the hot spot!\n"
literal|"You must arrange layers so that all of them have an intersection."
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STRING
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|error
operator|->
name|message
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
return|return;
block|}
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
name|NULL
argument_list|,
operator|(
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator||
name|GIMP_EXPORT_CAN_HANDLE_LAYERS
operator||
name|GIMP_EXPORT_NEEDS_ALPHA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*            * Possibly retrieve data...            */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xmcvals
argument_list|)
expr_stmt|;
comment|/* load xmcparas.comments from parasite. */
name|load_comments
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|load_default_hotspot
argument_list|(
name|image_ID
argument_list|,
name|hotspotRange
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|image_ID
argument_list|,
name|hotspotRange
argument_list|)
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*            * Make sure all the arguments are there!            */
if|if
condition|(
name|nparams
operator|!=
literal|15
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pix_in_region
argument_list|(
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
name|hotspotRange
argument_list|)
condition|)
block|{
comment|/* if passed hotspot is acceptable, use that ones. */
name|xmcparas
operator|.
name|x
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|xmcparas
operator|.
name|y
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
else|else
block|{
name|load_default_hotspot
argument_list|(
name|image_ID
argument_list|,
name|hotspotRange
argument_list|)
expr_stmt|;
comment|/* you can purposely choose non acceptable values for hotspot                      to use cursor's original values. */
block|}
name|xmcvals
operator|.
name|crop
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|xmcvals
operator|.
name|size
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|xmcvals
operator|.
name|size_replace
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/* load delay */
if|if
condition|(
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_int32
operator|<
name|CURSOR_MINIMUM_DELAY
condition|)
block|{
name|xmcvals
operator|.
name|delay
operator|=
name|CURSOR_DEFAULT_DELAY
expr_stmt|;
block|}
else|else
block|{
name|xmcvals
operator|.
name|delay
operator|=
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
name|xmcvals
operator|.
name|delay_replace
operator|=
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/* load xmcparas.comments from parasites.*/
name|load_comments
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|param
index|[
name|i
operator|+
literal|12
index|]
operator|.
name|data
operator|.
name|d_string
operator|&&
name|g_utf8_validate
argument_list|(
name|param
index|[
name|i
operator|+
literal|12
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
operator|=
name|g_strdup
argument_list|(
name|param
index|[
name|i
operator|+
literal|12
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*            * Possibly retrieve data...            */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xmcvals
argument_list|)
expr_stmt|;
comment|/* load xmcparas.comments from parasite. */
name|load_comments
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
comment|/* load hotspot from parasite */
name|load_default_hotspot
argument_list|(
name|image_ID
argument_list|,
name|hotspotRange
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|,
name|orig_image_ID
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xmcvals
argument_list|,
sizeof|sizeof
argument_list|(
name|XmcSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
comment|/* free hotspotRange */
name|g_free
argument_list|(
name|hotspotRange
argument_list|)
expr_stmt|;
comment|/* free xmcparas.comments */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|g_free
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|DM_XMC
argument_list|(
literal|"name=%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|GIMP_PDB_SUCCESS
operator|&&
name|error
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STRING
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|error
operator|->
name|message
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"run: finish\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'load_image()' - Load a X cursor image into a new image window.  */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|load_image (const gchar * filename,GError ** error)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Looping var */
name|gint
name|img_width
decl_stmt|,
name|img_height
decl_stmt|;
comment|/* dimensions of the image */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
name|gint32
name|image_ID
decl_stmt|;
comment|/* Image */
name|gint32
name|layer_ID
decl_stmt|;
comment|/* Layer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|XcursorComments
modifier|*
name|commentsp
decl_stmt|;
comment|/* pointer to comments */
name|XcursorImages
modifier|*
name|imagesp
decl_stmt|;
comment|/* pointer to images*/
name|guint32
name|delay
decl_stmt|;
comment|/* use guint32 instead CARD32(defined in X11/Xmd.h)*/
name|gchar
modifier|*
name|framename
decl_stmt|;
comment|/* name of layer */
name|guint32
modifier|*
name|tmppixel
decl_stmt|;
comment|/* pixel data (guchar * bpp = guint32) */
comment|/* initialize image here, thus avoiding compiler warnings */
name|image_ID
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*    * Open the file and check it is a valid X cursor    */
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|XcursorFileLoad
argument_list|(
name|fp
argument_list|,
operator|&
name|commentsp
argument_list|,
operator|&
name|imagesp
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid X cursor."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   ** check dimension is valid.   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|imagesp
operator|->
name|nimage
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The width of frame %d of '%s' is too big for X cursor."
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The height of frame %d of '%s' is too big for X cursor."
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|find_hotspots_and_dimensions
argument_list|(
name|imagesp
argument_list|,
operator|&
name|xmcparas
operator|.
name|x
argument_list|,
operator|&
name|xmcparas
operator|.
name|y
argument_list|,
operator|&
name|img_width
argument_list|,
operator|&
name|img_height
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"xhot=%i,\tyhot=%i,\timg_width=%i,\timg_height=%i\n"
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|img_width
argument_list|,
name|img_height
argument_list|)
expr_stmt|;
comment|/* create new image! */
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|img_width
argument_list|,
name|img_height
argument_list|,
name|GIMP_RGB
argument_list|)
expr_stmt|;
comment|/* set filename */
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_hotspot_to_parasite
argument_list|(
name|image_ID
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Temporary buffer */
name|tmppixel
operator|=
name|g_new
argument_list|(
name|guint32
argument_list|,
name|img_width
operator|*
name|img_height
argument_list|)
expr_stmt|;
comment|/* load each frame to each layer one by one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|imagesp
operator|->
name|nimage
condition|;
name|i
operator|++
control|)
block|{
name|delay
operator|=
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|delay
operator|<
name|CURSOR_MINIMUM_DELAY
condition|)
block|{
name|delay
operator|=
name|CURSOR_DEFAULT_DELAY
expr_stmt|;
block|}
name|DM_XMC
argument_list|(
literal|"images[%i]->delay=%i\twidth=%d\theight=%d\n"
argument_list|,
name|i
argument_list|,
name|delay
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
argument_list|)
expr_stmt|;
name|framename
operator|=
name|make_framename
argument_list|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|delay
argument_list|,
name|DISPLAY_DIGIT
argument_list|(
name|imagesp
operator|->
name|nimage
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|framename
condition|)
return|return
operator|-
literal|1
return|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|framename
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Adjust layer position to let hotspot sit on the same point. */
name|gimp_layer_translate
argument_list|(
name|layer_ID
argument_list|,
name|xmcparas
operator|.
name|x
operator|-
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|xmcparas
operator|.
name|y
operator|-
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
comment|/*        * Get the drawable and set the pixel region for our load...        */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* set color to each pixel */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
condition|;
name|j
operator|++
control|)
block|{
name|tmppixel
index|[
name|j
index|]
operator|=
name|separate_alpha
argument_list|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* set pixel */
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|tmppixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
name|imagesp
operator|->
name|nimage
argument_list|)
expr_stmt|;
block|}
comment|/* free temporary buffer */
name|g_free
argument_list|(
name|tmppixel
argument_list|)
expr_stmt|;
comment|/*    * Comment parsing    */
if|if
condition|(
name|commentsp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commentsp
operator|->
name|ncomment
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"comment type=%d\tcomment=%s\n"
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment_type
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_comment_to_pname
argument_list|(
name|image_ID
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment
argument_list|,
name|parasiteName
index|[
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment_type
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to write %ith comment.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|DM_XMC
argument_list|(
literal|"Comment parsing done.\n"
argument_list|)
expr_stmt|;
name|XcursorImagesDestroy
argument_list|(
name|imagesp
argument_list|)
expr_stmt|;
name|XcursorCommentsDestroy
argument_list|(
name|commentsp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Update the display...    */
name|gimp_progress_end
argument_list|()
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_comment
comment|/*  * load_thumbnail  */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|load_thumbnail (const gchar * filename,gint32 thumb_size,gint32 * thumb_width,gint32 * thumb_height,gint32 * thumb_num_layers,GError ** error)
name|load_thumbnail
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|thumb_size
parameter_list|,
name|gint32
modifier|*
name|thumb_width
parameter_list|,
name|gint32
modifier|*
name|thumb_height
parameter_list|,
name|gint32
modifier|*
name|thumb_num_layers
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/* Return only one frame for thumbnail.    * We select first frame of an animation sequence which nominal size is the    * closest of thumb_size. */
name|gint
name|i
decl_stmt|;
comment|/* Looping var */
name|guint32
name|ntoc
init|=
literal|0
decl_stmt|;
comment|/* the number of table of contents */
name|gint
name|sel_num
init|=
operator|-
literal|1
decl_stmt|;
comment|/* the index of selected image chunk */
name|XcursorImages
modifier|*
name|xcIs
init|=
name|NULL
decl_stmt|;
comment|/* use to find the dimensions of thumbnail */
name|XcursorImage
modifier|*
name|xcI
decl_stmt|;
comment|/* temporary pointer to XcursorImage */
name|guint32
modifier|*
name|positions
decl_stmt|;
comment|/* array of the offsets of image chunks */
name|guint32
name|size
decl_stmt|;
comment|/* nominal size */
name|guint32
name|diff
decl_stmt|;
comment|/* difference between thumb_size and current size */
name|guint32
name|min_diff
init|=
name|XCURSOR_IMAGE_MAX_SIZE
decl_stmt|;
comment|/* minimum value of diff */
name|guint32
name|type
decl_stmt|;
comment|/* chunk type */
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
comment|/* File pointer */
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Image */
name|gint32
name|layer_ID
decl_stmt|;
comment|/* Layer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|guint32
modifier|*
name|tmppixel
decl_stmt|;
comment|/* pixel data (guchar * bpp = guint32) */
name|g_return_val_if_fail
argument_list|(
name|thumb_width
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|thumb_height
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|thumb_num_layers
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|thumb_width
operator|=
literal|0
expr_stmt|;
operator|*
name|thumb_height
operator|=
literal|0
expr_stmt|;
operator|*
name|thumb_num_layers
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*    * From this line, we make a XcursorImages struct so that we can find out the    * width and height of entire image.    * We can use XcursorFileLoadImages (fp, thumb_size) from libXcursor instead    * of this ugly code but XcursorFileLoadImages loads all pixel data of the    * image chunks on memory thus we should not use it.    */
comment|/*    * find which image chunk is preferred to load.    */
comment|/* skip magic, headersize, version */
name|fseek
argument_list|(
name|fp
argument_list|,
literal|12
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* read the number of chunks */
name|ntoc
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|positions
operator|=
name|g_malloc
argument_list|(
name|ntoc
operator|*
sizeof|sizeof
argument_list|(
name|guint32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enter list of toc(table of contents) */
for|for
control|(
init|;
name|ntoc
operator|>
literal|0
condition|;
operator|--
name|ntoc
control|)
block|{
comment|/* read entry type */
name|type
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
if|if
condition|(
name|type
operator|!=
name|XCURSOR_IMAGE_TYPE
condition|)
comment|/* not a image */
comment|/* skip rest of this content */
name|fseek
argument_list|(
name|fp
argument_list|,
literal|8
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* this content is image */
name|size
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|positions
index|[
operator|*
name|thumb_num_layers
index|]
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
comment|/* is this image is more preferred than selected before? */
name|diff
operator|=
name|ABS
argument_list|(
name|thumb_size
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|min_diff
condition|)
block|{
comment|/* the image size is closer than current selected image */
name|min_diff
operator|=
name|diff
expr_stmt|;
name|sel_num
operator|=
operator|*
name|thumb_num_layers
expr_stmt|;
block|}
operator|++
operator|*
name|thumb_num_layers
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sel_num
operator|<
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"there is no image chunk in \"%s\"."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*    * get width and height of entire image    */
comment|/* Let's make XcursorImages */
name|xcIs
operator|=
name|XcursorImagesCreate
argument_list|(
operator|*
name|thumb_num_layers
argument_list|)
expr_stmt|;
name|xcIs
operator|->
name|nimage
operator|=
operator|*
name|thumb_num_layers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcIs
operator|->
name|nimage
condition|;
operator|++
name|i
control|)
block|{
comment|/* make XcursorImage with no pixel buffer */
name|xcI
operator|=
name|XcursorImageCreate
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* go to the image chunk header */
name|fseek
argument_list|(
name|fp
argument_list|,
name|positions
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* skip chunk header */
name|fseek
argument_list|(
name|fp
argument_list|,
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* read properties of this image to determine entire image dimensions */
name|xcI
operator|->
name|width
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcI
operator|->
name|height
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcI
operator|->
name|xhot
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcI
operator|->
name|yhot
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|=
name|xcI
expr_stmt|;
block|}
name|DM_XMC
argument_list|(
literal|"selected size is %i or %i\n"
argument_list|,
name|thumb_size
operator|-
name|min_diff
argument_list|,
name|thumb_size
operator|+
name|min_diff
argument_list|)
expr_stmt|;
comment|/* get entire image dimensions */
name|find_hotspots_and_dimensions
argument_list|(
name|xcIs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|thumb_width
argument_list|,
name|thumb_height
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"width=%i\theight=%i\tnum-layers=%i\n"
argument_list|,
operator|*
name|thumb_width
argument_list|,
operator|*
name|thumb_height
argument_list|,
name|xcIs
operator|->
name|nimage
argument_list|)
expr_stmt|;
comment|/* dimension check */
if|if
condition|(
operator|*
name|thumb_width
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The width of '%s' is too big for X cursor."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|thumb_height
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The height of '%s' is too big for X cursor."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*    *  create new image!    */
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|width
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|height
argument_list|,
name|GIMP_RGB
argument_list|)
expr_stmt|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|NULL
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|width
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Get the drawable and set the pixel region for our load...    */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|width
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Temporary buffer */
name|tmppixel
operator|=
name|g_new
argument_list|(
name|guint32
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|width
operator|*
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* copy the chunk data to tmppixel */
name|fseek
argument_list|(
name|fp
argument_list|,
name|positions
index|[
name|sel_num
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
literal|36
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* skip chunk header(16bytes), xhot, yhot, width, height, delay */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|width
operator|*
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|tmppixel
index|[
name|i
index|]
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
comment|/* get back separate alpha */
name|tmppixel
index|[
name|i
index|]
operator|=
name|separate_alpha
argument_list|(
name|tmppixel
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* set pixel */
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|tmppixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* free tmppixel */
name|g_free
argument_list|(
name|tmppixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|positions
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_comment
comment|/* read guint32 value from f despite of host's byte order. */
end_comment

begin_function
specifier|static
name|guint32
DECL|function|read32 (FILE * f,GError ** error)
name|read32
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guchar
name|p
index|[
literal|4
index|]
decl_stmt|;
name|guint32
name|ret
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|f
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"A read error occurred."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|G_BYTE_ORDER
operator|==
name|G_LITTLE_ENDIAN
name|ret
operator|=
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
elif|#
directive|elif
name|G_BYTE_ORDER
operator|==
name|G_BIG_ENDIAN
name|ret
operator|=
name|p
index|[
literal|3
index|]
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
elif|#
directive|elif
name|G_BYTE_ORDER
operator|==
name|G_PDP_ENDIAN
name|ret
operator|=
name|p
index|[
literal|2
index|]
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
else|#
directive|else
name|g_return_val_if_rearched
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * 'save_dialog ()'  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (const gint32 image_ID,GimpParamRegion * hotspotRange)
name|save_dialog
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
name|GimpParamRegion
modifier|*
name|hotspotRange
parameter_list|)
block|{
name|gint
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|box
decl_stmt|;
name|GtkObject
modifier|*
name|adjustment
decl_stmt|;
name|GtkWidget
modifier|*
name|alignment
decl_stmt|;
name|GtkWidget
modifier|*
name|tmpwidget
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkTextBuffer
modifier|*
name|textbuffer
decl_stmt|;
name|GValue
name|val
init|=
block|{
literal|0
block|,}
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_DOUBLE
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"X11 Mouse Cursor"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|SAVE_PROC
argument_list|)
expr_stmt|;
comment|/*    * parameter settings    */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"XMC Options"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|9
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
comment|/*    *  Hotspot    */
comment|/* label "Hot spot  _X:" + spinbox */
name|x1
operator|=
name|hotspotRange
operator|->
name|x
expr_stmt|;
name|x2
operator|=
name|hotspotRange
operator|->
name|width
operator|+
name|hotspotRange
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|tmpwidget
operator|=
name|gimp_spin_button_new
argument_list|(
operator|&
name|adjustment
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_value_set_double
argument_list|(
operator|&
name|val
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_set_property
argument_list|(
name|G_OBJECT
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|"xalign"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* align right*/
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xmcparas
operator|.
name|x
argument_list|)
expr_stmt|;
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter the X coordinate of the hot spot."
literal|"The origin is top left corner."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Hot spot _X:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* label "Y:" + spinbox */
name|y1
operator|=
name|hotspotRange
operator|->
name|y
expr_stmt|;
name|y2
operator|=
name|hotspotRange
operator|->
name|height
operator|+
name|hotspotRange
operator|->
name|y
operator|-
literal|1
expr_stmt|;
name|tmpwidget
operator|=
name|gimp_spin_button_new
argument_list|(
operator|&
name|adjustment
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_value_set_double
argument_list|(
operator|&
name|val
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_set_property
argument_list|(
name|G_OBJECT
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|"xalign"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* align right*/
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xmcparas
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter the Y coordinate of the hot spot."
literal|"The origin is top left corner."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"_Y:"
argument_list|,
literal|1.0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*    *  Auto-crop    */
comment|/* check button */
name|tmpwidget
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Auto-Crop all frames."
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|xmcvals
operator|.
name|crop
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|tmpwidget
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|crop
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Remove the empty borders of all frames.\n"
literal|"This reduces the file size and may fix "
literal|"the problem that some large cursors disorder "
literal|"the screen.\n"
literal|"Uncheck if you plan to edit the exported "
literal|"cursor using other programs."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*    *  size    */
name|tmpwidget
operator|=
name|gimp_int_combo_box_new
argument_list|(
literal|"12px"
argument_list|,
literal|12
argument_list|,
literal|"16px"
argument_list|,
literal|16
argument_list|,
literal|"24px"
argument_list|,
literal|24
argument_list|,
literal|"32px"
argument_list|,
literal|32
argument_list|,
literal|"36px"
argument_list|,
literal|36
argument_list|,
literal|"40px"
argument_list|,
literal|40
argument_list|,
literal|"48px"
argument_list|,
literal|48
argument_list|,
literal|"64px"
argument_list|,
literal|64
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_int_combo_box_connect
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|32
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_combo_box_get_active
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|size
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Choose the nominal size of frames.\n"
literal|"If you don't have plans to make multi-sized "
literal|"cursor, or you have no idea, leave it \"32px\".\n"
literal|"Nominal size has no relation with the actual "
literal|"size (width or height).\n"
literal|"It is only used to determine which frame depends "
literal|"on which animation sequence, and which sequence "
literal|"is used based on the value of "
literal|"\"gtk-cursor-theme-size\"."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"_Size:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Replace size ? */
name|tmpwidget
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|size_replace
argument_list|,
name|xmcvals
operator|.
name|size_replace
argument_list|,
name|_
argument_list|(
literal|"_Use this value only for a frame which size "
literal|"is not specified."
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"_Replace the size of all frames even if it "
literal|"is specified."
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|gtk_alignment_new
argument_list|(
literal|0.5
argument_list|,
literal|0.5
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_alignment_set_padding
argument_list|(
name|GTK_ALIGNMENT
argument_list|(
name|alignment
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*padding left*/
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|alignment
argument_list|)
argument_list|,
name|tmpwidget
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/*    * delay    */
comment|/* spin button */
name|box
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|box
argument_list|)
expr_stmt|;
name|tmpwidget
operator|=
name|gimp_spin_button_new
argument_list|(
operator|&
name|adjustment
argument_list|,
name|xmcvals
operator|.
name|delay
argument_list|,
name|CURSOR_MINIMUM_DELAY
argument_list|,
name|CURSOR_MAX_DELAY
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_value_set_double
argument_list|(
operator|&
name|val
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_set_property
argument_list|(
name|G_OBJECT
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|"xalign"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* align right*/
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|box
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|delay
argument_list|)
expr_stmt|;
comment|/* appended "ms" */
name|tmpwidget
operator|=
name|gtk_label_new
argument_list|(
literal|"ms"
argument_list|)
expr_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
comment|/*align left*/
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|box
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|box
argument_list|,
name|_
argument_list|(
literal|"Enter time span in milliseconds in which "
literal|"each frame is rendered."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|_
argument_list|(
literal|"_Delay:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|box
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Replace delay? */
name|tmpwidget
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|delay_replace
argument_list|,
name|xmcvals
operator|.
name|delay_replace
argument_list|,
name|_
argument_list|(
literal|"_Use this value only for a frame which delay "
literal|"is not specified."
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"_Replace the delay of all frames even if it "
literal|"is specified."
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|gtk_alignment_new
argument_list|(
literal|0.5
argument_list|,
literal|0.5
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_alignment_set_padding
argument_list|(
name|GTK_ALIGNMENT
argument_list|(
name|alignment
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*padding left*/
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|alignment
argument_list|)
argument_list|,
name|tmpwidget
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/*    *  Copyright    */
name|tmpwidget
operator|=
name|gtk_entry_new
argument_list|()
expr_stmt|;
comment|/* Maximum length will be clamped to 65536 */
name|gtk_entry_set_max_length
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
literal|0
index|]
condition|)
block|{
name|gtk_entry_set_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* show warning if comment is over 65535 characters        * because gtk_entry can hold only that. */
if|if
condition|(
name|strlen
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|65535
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The part of copyright information "
literal|"that exceeded 65535 characters was removed."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_signal_connect
argument_list|(
name|tmpwidget
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|comment_entry_callback
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|comments
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter copyright information."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|_
argument_list|(
literal|"_Copyright:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*    *  License    */
name|tmpwidget
operator|=
name|gtk_entry_new
argument_list|()
expr_stmt|;
comment|/* Maximum length will be clamped to 65536 */
name|gtk_entry_set_max_length
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
literal|1
index|]
condition|)
block|{
name|gtk_entry_set_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* show warning if comment is over 65535 characters        * because gtk_entry can hold only that. */
if|if
condition|(
name|strlen
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|65535
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The part of license information "
literal|"that exceeded 65535 characters was removed."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_signal_connect
argument_list|(
name|tmpwidget
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|comment_entry_callback
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|comments
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter license information."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
name|_
argument_list|(
literal|"_License:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*    *  Other    */
comment|/* We use gtk_text_view for "Other" while "Copyright"& "License" is entered    * in gtk_entry because We want allow '\n' for "Other". */
name|label
operator|=
name|gtk_label_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Other:"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*align top-left*/
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* content of Other */
comment|/* scrolled window */
name|box
operator|=
name|gtk_scrolled_window_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_scrolled_window_set_shadow_type
argument_list|(
name|GTK_SCROLLED_WINDOW
argument_list|(
name|box
argument_list|)
argument_list|,
name|GTK_SHADOW_IN
argument_list|)
expr_stmt|;
name|gtk_scrolled_window_set_policy
argument_list|(
name|GTK_SCROLLED_WINDOW
argument_list|(
name|box
argument_list|)
argument_list|,
name|GTK_POLICY_AUTOMATIC
argument_list|,
name|GTK_POLICY_AUTOMATIC
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|box
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|box
argument_list|)
expr_stmt|;
comment|/* textbuffer */
name|textbuffer
operator|=
name|gtk_text_buffer_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
literal|2
index|]
condition|)
name|gtk_text_buffer_set_text
argument_list|(
name|textbuffer
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
literal|2
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|textbuffer
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|text_view_callback
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|comments
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* textview */
name|tmpwidget
operator|=
name|gtk_text_view_new_with_buffer
argument_list|(
name|GTK_TEXT_BUFFER
argument_list|(
name|textbuffer
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_text_view_set_accepts_tab
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_text_view_set_wrap_mode
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|GTK_WRAP_WORD
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|textbuffer
argument_list|)
expr_stmt|;
name|gtk_text_view_set_wrap_mode
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|GTK_WRAP_WORD
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|box
argument_list|)
argument_list|,
name|tmpwidget
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter other comment if you want."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_label_set_mnemonic_widget
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/*    *  all widget is prepared. Let's show dialog.    */
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  * callback function of gtk_entry for "copyright" and "license".  * "other" is processed by text_view_callback  */
end_comment

begin_function
specifier|static
name|void
DECL|function|comment_entry_callback (GtkWidget * widget,gchar ** commentp)
name|comment_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|text
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|commentp
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This will not happen because sizeof(gtk_entry)< XCURSOR_COMMENT_MAX_LEN */
name|g_return_if_fail
argument_list|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|<=
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
operator|*
name|commentp
argument_list|)
expr_stmt|;
operator|*
name|commentp
operator|=
name|g_strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|text_view_callback (GtkTextBuffer * buffer,gchar ** commentp)
name|text_view_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
name|GtkTextIter
name|start_iter
decl_stmt|;
name|GtkTextIter
name|end_iter
decl_stmt|;
name|gchar
modifier|*
name|text
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|commentp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_bounds
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_text_buffer_get_text
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|>
name|XCURSOR_COMMENT_MAX_LEN
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Comment is limited to %d characters."
argument_list|)
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_iter_at_offset
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_end_iter
argument_list|(
name|buffer
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
name|gtk_text_buffer_delete
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_free
argument_list|(
operator|*
name|commentp
argument_list|)
expr_stmt|;
operator|*
name|commentp
operator|=
name|g_strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Set default hotspot based on hotspotRange. **/
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|load_default_hotspot (const gint32 image_ID,GimpParamRegion * hotspotRange)
name|load_default_hotspot
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
name|GimpParamRegion
modifier|*
name|hotspotRange
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|hotspotRange
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* if we cannot load hotspot correctly */
operator|!
name|get_hotspot_from_parasite
argument_list|(
name|image_ID
argument_list|)
operator|||
comment|/* ,or hostspot is out of range */
operator|!
name|pix_in_region
argument_list|(
name|xmcparas
operator|.
name|x
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|hotspotRange
argument_list|)
condition|)
block|{
comment|/* then use top left point of hotspotRange as fallback. */
name|xmcparas
operator|.
name|x
operator|=
name|hotspotRange
operator|->
name|x
expr_stmt|;
name|xmcparas
operator|.
name|y
operator|=
name|hotspotRange
operator|->
name|y
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * 'save_image ()' - Save the specified image to X cursor file.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|save_image (const gchar * filename,gint32 image_ID,gint32 drawable_ID,gint32 orig_image_ID,GError ** error)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Looping vars */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
name|gboolean
name|dimension_warn
init|=
name|FALSE
decl_stmt|;
comment|/* become TRUE if even one of the   dimensions of the frames of the cursor is over MAX_BITMAP_CURSOR_SIZE */
name|gboolean
name|size_warn
init|=
name|FALSE
decl_stmt|;
comment|/* become TRUE if even one of the nominal   size of the frames is not supported by gnome-appearance-properties */
name|GRegex
modifier|*
name|re
decl_stmt|;
comment|/* used to get size and delay from framename */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|XcursorComments
modifier|*
name|commentsp
decl_stmt|;
comment|/* pointer to comments */
name|XcursorImages
modifier|*
name|imagesp
decl_stmt|;
comment|/* pointer to images */
name|gint32
modifier|*
name|layers
decl_stmt|;
comment|/* Array of layer */
name|gint32
modifier|*
name|orig_layers
decl_stmt|;
comment|/* Array of layer of orig_image */
name|gint
name|nlayers
decl_stmt|;
comment|/* Number of layers */
name|gchar
modifier|*
name|framename
decl_stmt|;
comment|/* framename of a layer */
name|GimpParamRegion
name|save_rgn
decl_stmt|;
comment|/* region to save */
name|gint
name|layer_xoffset
decl_stmt|,
name|layer_yoffset
decl_stmt|;
comment|/* temporary buffer which store pixel data (guchar * bpp = guint32) */
name|guint32
name|pixelbuf
index|[
name|SQR
argument_list|(
name|MAX_SAVE_DIMENSION
argument_list|)
index|]
decl_stmt|;
comment|/* This will be used in set_size_and_delay fucntion later.      To define this in that function is easy to read but place here to      reduce overheads. */
name|re
operator|=
name|g_regex_new
argument_list|(
literal|"[(][ ]*(\\d+)[ ]*(px|ms)[ ]*[)]"
argument_list|,
name|G_REGEX_CASELESS
operator||
name|G_REGEX_OPTIMIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*    * Open the file pointer.    */
name|DM_XMC
argument_list|(
literal|"Open the file pointer.\n"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get layers */
name|orig_layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|orig_image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
comment|/* create new XcursorImages. */
name|imagesp
operator|=
name|XcursorImagesCreate
argument_list|(
name|nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imagesp
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorImagesCreate!\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|imagesp
operator|->
name|nimage
operator|=
name|nlayers
expr_stmt|;
comment|/* XcursorImages also have `name' member but it is not used as long as I know.      We leave it NULL here. */
comment|/*    *  Now we start to convert each layer to a XcurosrImage one by one.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlayers
condition|;
name|i
operator|++
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|nlayers
operator|-
literal|1
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* this plugin only treat 8bit color depth RGBA image. */
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|!=
literal|4
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"This plug-in can only handle RGBA image format with 8bit color depth."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* get framename of this layer */
name|framename
operator|=
name|gimp_drawable_get_name
argument_list|(
name|layers
index|[
name|nlayers
operator|-
literal|1
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* get offset of this layer. */
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|nlayers
operator|-
literal|1
operator|-
name|i
index|]
argument_list|,
operator|&
name|layer_xoffset
argument_list|,
operator|&
name|layer_yoffset
argument_list|)
expr_stmt|;
comment|/*        * layer dimension check.        */
name|DM_XMC
argument_list|(
literal|"layer size check.\n"
argument_list|)
expr_stmt|;
comment|/* We allow to save a cursor which dimensions are no more than        * MAX_SAVE_DIMENSION but after auto-cropping, we warn (only warn, don't        * stop) if dimension is over MAX_BITMAP_CURSOR_SIZE. */
if|if
condition|(
name|drawable
operator|->
name|width
operator|>
name|MAX_SAVE_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Width of '%s' is too large. Please reduce more than %dpx)"
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|MAX_SAVE_DIMENSION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|drawable
operator|->
name|height
operator|>
name|MAX_SAVE_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Height of '%s' is too large. Please reduce more than %dpx)"
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|MAX_SAVE_DIMENSION
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|drawable
operator|->
name|height
operator|==
literal|0
operator|||
name|drawable
operator|->
name|width
operator|==
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The size of '%s' is zero!"
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcvals
operator|.
name|crop
condition|)
comment|/* with auto-cropping */
block|{
comment|/* get the region of auto-cropped area. */
name|DM_XMC
argument_list|(
literal|"get_cropped_region\n"
argument_list|)
expr_stmt|;
name|get_cropped_region
argument_list|(
operator|&
name|save_rgn
argument_list|,
operator|&
name|pixel_rgn
argument_list|)
expr_stmt|;
comment|/* don't forget save_rgn's origin is not a entire image               but a layer which we are doing on.*/
if|if
condition|(
name|save_rgn
operator|.
name|width
operator|==
literal|0
operator|||
name|save_rgn
operator|.
name|height
operator|==
literal|0
condition|)
block|{
comment|/* perfectly transparent frames become 1x1px transparent pixel. */
name|DM_XMC
argument_list|(
literal|"get_cropped_region return 0.\n"
argument_list|)
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|=
name|XcursorImageCreate
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imagesp
operator|->
name|images
index|[
name|i
index|]
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorImageCreate.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
operator|=
literal|0
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
operator|=
literal|0
expr_stmt|;
name|set_size_and_delay
argument_list|(
name|framename
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
operator|)
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
operator|)
argument_list|,
name|re
argument_list|,
operator|&
name|size_warn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* OK save_rgn is not 0x0 */
comment|/* is hotspot in save_rgn ? */
if|if
condition|(
operator|!
name|pix_in_region
argument_list|(
name|xmcparas
operator|.
name|x
operator|-
name|layer_xoffset
argument_list|,
name|xmcparas
operator|.
name|y
operator|-
name|layer_yoffset
argument_list|,
operator|&
name|save_rgn
argument_list|)
condition|)
block|{
comment|/* if hotspot is not on save_rgn */
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Cannot save the cursor because the hot spot is not on '%s'.\n"
literal|"Try to change the hot spot position, layer geometry or "
literal|"save without auto-crop."
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
comment|/* if without auto-cropping... */
block|{
comment|/* set save_rgn for the case not to auto-crop */
name|save_rgn
operator|.
name|width
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|save_rgn
operator|.
name|height
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|save_rgn
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|save_rgn
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We warn if the dimension of the layer is over MAX_BITMAP_CURSOR_SIZE. */
if|if
condition|(
operator|!
name|dimension_warn
condition|)
block|{
if|if
condition|(
name|save_rgn
operator|.
name|width
operator|>
name|MAX_BITMAP_CURSOR_SIZE
operator|||
name|save_rgn
operator|.
name|height
operator|>
name|MAX_BITMAP_CURSOR_SIZE
condition|)
block|{
name|dimension_warn
operator|=
name|TRUE
expr_stmt|;
comment|/* actual warning is done after the cursor is successfully saved.*/
block|}
block|}
comment|/*        * Create new XcursorImage.        */
name|DM_XMC
argument_list|(
literal|"create new xcursorimage.\twidth=%i\theight=%i\n"
argument_list|,
name|save_rgn
operator|.
name|width
argument_list|,
name|save_rgn
operator|.
name|height
argument_list|)
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|=
name|XcursorImageCreate
argument_list|(
name|save_rgn
operator|.
name|width
argument_list|,
name|save_rgn
operator|.
name|height
argument_list|)
expr_stmt|;
comment|/* Cursor width& height is automatically set by function */
comment|/* XcursorImageCreate, so no need to set manually. */
if|if
condition|(
operator|!
name|imagesp
operator|->
name|images
index|[
name|i
index|]
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorImageCreate.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*        ** set images[i]'s xhot& yhot.        */
comment|/* [Cropped layer's hotspot] =                    [image's hotspot] - [layer's offset] - [save_rgn's offset]. */
name|DM_XMC
argument_list|(
literal|"xhot=%i\tsave_rgn->xoffset=%i\tlayer_xoffset=%i\n"
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|layer_xoffset
argument_list|,
name|save_rgn
operator|.
name|x
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"yhot=%i\tsave_rgn->yoffset=%i\tlayer_yoffset=%i\n"
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|layer_yoffset
argument_list|,
name|save_rgn
operator|.
name|y
argument_list|)
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
operator|=
name|xmcparas
operator|.
name|x
operator|-
name|layer_xoffset
operator|-
name|save_rgn
operator|.
name|x
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
operator|=
name|xmcparas
operator|.
name|y
operator|-
name|layer_yoffset
operator|-
name|save_rgn
operator|.
name|y
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"images[%i]->xhot=%i\tyhot=%i\n"
argument_list|,
name|i
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|)
expr_stmt|;
comment|/*        * set images[i]->pixels        */
comment|/* get image data to pixelbuf. */
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|pixelbuf
argument_list|,
name|save_rgn
operator|.
name|x
argument_list|,
name|save_rgn
operator|.
name|y
argument_list|,
name|save_rgn
operator|.
name|width
argument_list|,
name|save_rgn
operator|.
name|height
argument_list|)
expr_stmt|;
comment|/*convert pixel date to XcursorPixel. */
name|g_assert
argument_list|(
name|save_rgn
operator|.
name|width
operator|*
name|save_rgn
operator|.
name|height
operator|<
name|SQR
argument_list|(
name|MAX_SAVE_DIMENSION
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|save_rgn
operator|.
name|width
operator|*
name|save_rgn
operator|.
name|height
condition|;
name|j
operator|++
control|)
block|{
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
index|[
name|j
index|]
operator|=
name|premultiply_alpha
argument_list|(
name|pixelbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*        * get back size& delay from framename.        */
name|set_size_and_delay
argument_list|(
name|framename
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
operator|)
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
operator|)
argument_list|,
name|re
argument_list|,
operator|&
name|size_warn
argument_list|)
expr_stmt|;
comment|/*        * All property of this XcursorImage is loaded.        */
comment|/* set the layer name of original image with the saved value */
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|framename
operator|=
name|make_framename
argument_list|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
argument_list|,
name|DISPLAY_DIGIT
argument_list|(
name|imagesp
operator|->
name|nimage
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|framename
condition|)
return|return
name|FALSE
return|;
name|gimp_drawable_set_name
argument_list|(
name|orig_layers
index|[
name|nlayers
operator|-
literal|1
operator|-
name|i
index|]
argument_list|,
name|framename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
name|imagesp
operator|->
name|nimage
argument_list|)
expr_stmt|;
block|}
comment|/*    * comment parsing    */
name|commentsp
operator|=
name|set_cursor_comments
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XMC_DEBUG
name|DM_XMC
argument_list|(
literal|"imagesp->nimage=%i\tname=%s\n"
argument_list|,
name|imagesp
operator|->
name|nimage
argument_list|,
name|imagesp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|imagesp
operator|->
name|nimage
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"\timages[%i]->size=%i\n\                \twidth=%i\n\                \theight=%i\n\                \txhot=%i\n\                \tyhot=%i\n\                \tdelay=%i\n\                \t*pixels=%p\n"
argument_list|,
name|i
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commentsp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commentsp
operator|->
name|ncomment
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"comment type=%d\tcomment=%s\n"
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment_type
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*    *  save cursor to file *fp.    */
if|if
condition|(
name|commentsp
condition|)
block|{
if|if
condition|(
operator|!
name|XcursorFileSave
argument_list|(
name|fp
argument_list|,
name|commentsp
argument_list|,
name|imagesp
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorFileSave.\t%p\t%p\t%p\n"
argument_list|,
name|fp
argument_list|,
name|commentsp
argument_list|,
name|imagesp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
comment|/* if no comments exist */
block|{
if|if
condition|(
operator|!
name|XcursorFileSaveImages
argument_list|(
name|fp
argument_list|,
name|imagesp
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorFileSaveImages.\t%p\t%p\n"
argument_list|,
name|fp
argument_list|,
name|imagesp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* actual warning about dimensions */
if|if
condition|(
name|dimension_warn
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Your cursor was successfully saved but it contains one "
literal|"or more frames which width or height is more than %ipx.\n"
literal|"It will clutter the screen in some environments."
argument_list|)
argument_list|,
name|MAX_BITMAP_CURSOR_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_warn
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Your cursor was successfully saved but it contains one "
literal|"or more frames which nominal size is not "
literal|"supported by gnome-appearance-properties.\n"
literal|"You can satisfy it by checking \"Replace the size of all "
literal|"frame...\" in save dialog, or Your cursor may not appear "
literal|"in gnome-appearance-properties."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * Done with the file...    */
name|g_regex_unref
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"fp=%p\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"%i frames written.\n"
argument_list|,
name|imagesp
operator|->
name|nimage
argument_list|)
expr_stmt|;
name|XcursorImagesDestroy
argument_list|(
name|imagesp
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"Xcursor destroyed.\n"
argument_list|)
expr_stmt|;
name|XcursorCommentsDestroy
argument_list|(
name|commentsp
argument_list|)
expr_stmt|;
comment|/* this is safe even if commentsp is NULL. */
name|gimp_progress_end
argument_list|()
expr_stmt|;
comment|/* Save the comment back to the original image */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|gimp_image_parasite_detach
argument_list|(
name|orig_image_ID
argument_list|,
name|parasiteName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|set_comment_to_pname
argument_list|(
name|orig_image_ID
argument_list|,
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|,
name|parasiteName
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to write back %ith comment to orig_image.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Save hotspot back to the original image */
name|set_hotspot_to_parasite
argument_list|(
name|orig_image_ID
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|guint32
DECL|function|separate_alpha (guint32 pixel)
name|separate_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
block|{
name|guint
name|alpha
decl_stmt|,
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|guint32
name|retval
decl_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_TO_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blue
operator|=
name|pixel
operator|&
literal|0xff
expr_stmt|;
name|green
operator|=
operator|(
name|pixel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|red
operator|=
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|alpha
operator|=
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|alpha
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* resume separate alpha data. */
name|red
operator|=
name|CLAMP0255
argument_list|(
name|red
operator|*
literal|255
operator|/
name|alpha
argument_list|)
expr_stmt|;
name|blue
operator|=
name|CLAMP0255
argument_list|(
name|blue
operator|*
literal|255
operator|/
name|alpha
argument_list|)
expr_stmt|;
name|green
operator|=
name|CLAMP0255
argument_list|(
name|green
operator|*
literal|255
operator|/
name|alpha
argument_list|)
expr_stmt|;
name|retval
operator|=
name|red
operator|+
operator|(
name|green
operator|<<
literal|8
operator|)
operator|+
operator|(
name|blue
operator|<<
literal|16
operator|)
operator|+
operator|(
name|alpha
operator|<<
literal|24
operator|)
expr_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_FROM_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|guint32
DECL|function|premultiply_alpha (guint32 pixel)
name|premultiply_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
block|{
name|guint
name|alpha
decl_stmt|,
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|guint32
name|retval
decl_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_TO_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|red
operator|=
name|pixel
operator|&
literal|0xff
expr_stmt|;
name|green
operator|=
operator|(
name|pixel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|blue
operator|=
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|alpha
operator|=
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* premultiply alpha      (see "premultiply_data" function at line 154 of xcursorgen.c) */
name|red
operator|=
name|div_255
argument_list|(
name|red
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|green
operator|=
name|div_255
argument_list|(
name|green
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|blue
operator|=
name|div_255
argument_list|(
name|blue
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|retval
operator|=
name|blue
operator|+
operator|(
name|green
operator|<<
literal|8
operator|)
operator|+
operator|(
name|red
operator|<<
literal|16
operator|)
operator|+
operator|(
name|alpha
operator|<<
literal|24
operator|)
expr_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_FROM_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* set comments to cursor from xmcparas.comments. */
end_comment

begin_comment
comment|/* don't forget to XcursorCommentsDestory returned pointer later. */
end_comment

begin_function
specifier|static
name|XcursorComments
modifier|*
DECL|function|set_cursor_comments (void)
name|set_cursor_comments
parameter_list|(
name|void
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|guint
name|gcomlen
decl_stmt|,
name|arraylen
decl_stmt|;
name|GArray
modifier|*
name|xcCommentsArray
decl_stmt|;
name|XcursorComment
argument_list|*
operator|(
name|xcCommentp
index|[
literal|3
index|]
operator|)
operator|=
block|{
name|NULL
block|,}
argument_list|;
name|XcursorComments
operator|*
name|xcCommentsp
argument_list|;
name|xcCommentsArray
operator|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|,
sizeof|sizeof
argument_list|(
name|XcursorComment
operator|*
argument_list|)
argument_list|)
argument_list|;    for
operator|(
name|i
operator|=
literal|0
expr|;
name|i
operator|<
literal|3
expr|;
operator|++
name|i
operator|)
block|{
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
condition|)
block|{
name|gcomlen
operator|=
name|strlen
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcomlen
operator|>
literal|0
condition|)
block|{
name|xcCommentp
index|[
name|i
index|]
operator|=
name|XcursorCommentCreate
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|gcomlen
argument_list|)
expr_stmt|;
comment|/* first argument of XcursorCommentCreate is comment_type                  defined in Xcursor.h as enumerator.                  i + 1 is appropriate when we dispose parasiteName before MAIN(). */
if|if
condition|(
operator|!
name|xcCommentp
index|[
name|i
index|]
condition|)
block|{
name|g_warning
argument_list|(
literal|"Cannot create xcCommentp[%i]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|g_stpcpy
argument_list|(
name|xcCommentp
index|[
name|i
index|]
operator|->
name|comment
argument_list|,
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_array_append_val
argument_list|(
name|xcCommentsArray
argument_list|,
name|xcCommentp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
unit|}     }
name|arraylen
operator|=
name|xcCommentsArray
operator|->
name|len
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|arraylen
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
end_if

begin_expr_stmt
name|xcCommentsp
operator|=
name|XcursorCommentsCreate
argument_list|(
name|arraylen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xcCommentsp
operator|->
name|ncomment
operator|=
name|arraylen
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arraylen
condition|;
operator|++
name|i
control|)
block|{
name|xcCommentsp
operator|->
name|comments
index|[
name|i
index|]
operator|=
name|g_array_index
argument_list|(
name|xcCommentsArray
argument_list|,
name|XcursorComment
operator|*
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|xcCommentsp
return|;
end_return

begin_comment
unit|}
comment|/*  * Load xmcparas.comments from three parasites named as "xmc-copyright",  * "xmc-license","gimp-comment".  * This alignment sequence is depends on the definition of comment_type  * in Xcursor.h .  * Don't forget to g_free each element of xmcparas.comments later.  */
end_comment

begin_function
unit|static
name|void
DECL|function|load_comments (const gint32 image_ID)
name|load_comments
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|image_ID
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
operator|=
name|get_comment_from_pname
argument_list|(
name|image_ID
argument_list|,
name|parasiteName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set content to a parasite named as pname. if parasite  * is already exist, append the new one to the old one with "\n" **/
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|set_comment_to_pname (const gint32 image_ID,const gchar * content,const gchar * pname)
name|set_comment_to_pname
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
specifier|const
name|gchar
modifier|*
name|content
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
block|{
name|gboolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|gchar
modifier|*
name|tmpstring
decl_stmt|,
modifier|*
name|joind
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|image_ID
operator|!=
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|content
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image_ID
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parasite
condition|)
block|{
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|pname
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|content
argument_list|)
operator|+
literal|1
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpstring
operator|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|joind
operator|=
name|g_strjoin
argument_list|(
literal|"\n"
argument_list|,
name|tmpstring
argument_list|,
name|content
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpstring
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|pname
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|joind
argument_list|)
operator|+
literal|1
argument_list|,
name|joind
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|joind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parasite
condition|)
block|{
name|ret
operator|=
name|gimp_image_parasite_attach
argument_list|(
name|image_ID
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * get back comment from parasite name  * don't forget to call g_free(returned pointer) later **/
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|get_comment_from_pname (const gint32 image_ID,const gchar * pname)
name|get_comment_from_pname
parameter_list|(
specifier|const
name|gint32
name|image_ID
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
block|{
name|gchar
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|glong
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|image_ID
operator|!=
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image_ID
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
if|if
condition|(
name|length
operator|>
name|XCURSOR_COMMENT_MAX_LEN
condition|)
block|{
name|length
operator|=
name|XCURSOR_COMMENT_MAX_LEN
expr_stmt|;
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The parasite \"%s\" is too long for X cursor.\n"
literal|"The overflowed string was dropped."
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|pname
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/**  * Set hotspot to "hot-spot" parasite which format is common with that  * of file-xbm.  **/
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|set_hotspot_to_parasite (gint32 image_ID)
name|set_hotspot_to_parasite
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|gboolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|gchar
modifier|*
name|tmpstr
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|image_ID
operator|!=
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|g_strdup_printf
argument_list|(
literal|"%d %d"
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"hot-spot"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|+
literal|1
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|ret
operator|=
name|gimp_image_parasite_attach
argument_list|(
name|image_ID
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Get back xhot& yhot from "hot-spot" parasite.  * If succeed, hotspot coordinate is set to xmcparas.x, xmcparas.y and  * return TRUE.  * If "hot-spot" is not found or broken, return FALSE. **/
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|get_hotspot_from_parasite (gint32 image_ID)
name|get_hotspot_from_parasite
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
init|=
name|NULL
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|image_ID
operator|!=
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"function: getHotsopt\n"
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image_ID
argument_list|,
literal|"hot-spot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parasite
condition|)
comment|/* cannot find a parasite named "hot-spot". */
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
literal|"%i %i"
argument_list|,
operator|&
name|xmcparas
operator|.
name|x
argument_list|,
operator|&
name|xmcparas
operator|.
name|y
argument_list|)
operator|<
literal|2
condition|)
block|{
comment|/*cannot load hotspot.(parasite is broken?) */
return|return
name|FALSE
return|;
block|}
comment|/*OK, hotspot is set to *xhotp& *yhotp. */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * Set size to sizep, delay to delayp from drawable's framename. **/
end_comment

begin_function
specifier|static
name|void
DECL|function|set_size_and_delay (const gchar * framename,guint32 * sizep,guint32 * delayp,GRegex * re,gboolean * size_warnp)
name|set_size_and_delay
parameter_list|(
specifier|const
name|gchar
modifier|*
name|framename
parameter_list|,
name|guint32
modifier|*
name|sizep
parameter_list|,
name|guint32
modifier|*
name|delayp
parameter_list|,
name|GRegex
modifier|*
name|re
parameter_list|,
name|gboolean
modifier|*
name|size_warnp
parameter_list|)
block|{
name|guint32
name|size
init|=
literal|0
decl_stmt|;
name|guint32
name|delay
init|=
literal|0
decl_stmt|;
name|gchar
modifier|*
name|digits
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
name|GMatchInfo
modifier|*
name|info
init|=
name|NULL
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|sizep
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|delayp
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"function: set_size_and_delay\tframename=%s\n"
argument_list|,
name|framename
argument_list|)
expr_stmt|;
comment|/* re is defined at the start of save_image() as         [(]                : open parenthesis         [ ]*               : ignore zero or more spaces         (\\d+)             : the number we want to get out         [ ]*               : ignore zero or more spaces         (px|ms)            : whether "px"(size) or "ms"(delay)         [ ]*               : ignore zero or more spaces         [)]                : close parenthesis      This is intended to match for the animation-play plug-in. */
name|g_regex_match
argument_list|(
name|re
argument_list|,
name|framename
argument_list|,
literal|0
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
while|while
condition|(
name|g_match_info_matches
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|digits
operator|=
name|g_match_info_fetch
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|g_match_info_fetch
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_ascii_strcasecmp
argument_list|(
name|suffix
argument_list|,
literal|"px"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
comment|/* substitute it only for the first time */
block|{
if|if
condition|(
name|strlen
argument_list|(
name|digits
argument_list|)
operator|>
literal|8
condition|)
comment|/* too large number should be clamped */
name|size
operator|=
name|MAX_BITMAP_CURSOR_SIZE
expr_stmt|;
else|else
name|size
operator|=
name|MIN
argument_list|(
name|MAX_BITMAP_CURSOR_SIZE
argument_list|,
name|atoi
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* suffix is "ms" */
block|{
if|if
condition|(
operator|!
name|delay
condition|)
comment|/* substitute it only for the first time */
block|{
if|if
condition|(
name|strlen
argument_list|(
name|digits
argument_list|)
operator|>
literal|8
condition|)
comment|/* too large number should be clamped */
name|delay
operator|=
name|CURSOR_MAX_DELAY
expr_stmt|;
else|else
name|delay
operator|=
name|MIN
argument_list|(
name|CURSOR_MAX_DELAY
argument_list|,
name|atoi
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|g_match_info_next
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|g_match_info_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* if size is not set, or size_replace is TRUE, set default size    * (which was chosen in save dialog) */
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|xmcvals
operator|.
name|size_replace
operator|==
name|TRUE
condition|)
block|{
name|size
operator|=
name|xmcvals
operator|.
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|size_warnp
operator|&&
name|size
operator|!=
literal|12
operator|&&
name|size
operator|!=
literal|16
operator|&&
name|size
operator|!=
literal|24
operator|&&
name|size
operator|!=
literal|32
operator|&&
name|size
operator|!=
literal|36
operator|&&
name|size
operator|!=
literal|40
operator|&&
name|size
operator|!=
literal|48
operator|&&
name|size
operator|!=
literal|64
condition|)
block|{
comment|/* if the size is different from these values, we warn about it after          successfully saving because gnome-appearance-properties only support          them. */
operator|*
name|size_warnp
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
comment|/* if delay is not set, or delay_replace is TRUE, set default delay    * (which was chosen in save dialog) */
if|if
condition|(
name|delay
operator|==
literal|0
operator|||
name|xmcvals
operator|.
name|delay_replace
operator|==
name|TRUE
condition|)
block|{
name|delay
operator|=
name|xmcvals
operator|.
name|delay
expr_stmt|;
block|}
operator|*
name|delayp
operator|=
name|delay
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"set_size_and_delay return\tsize=%i\tdelay=%i\n"
argument_list|,
name|size
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return framename as format: "([x]px)_[i] ([t]ms) (replace)"  * where [x] is nominal size, [t] is delay passed as argument respectively,  * and [i] is an index separately counted by [x].  * This format is compatible with "animation-play" plug-in.  * Don't forget to g_free returned framename later.  **/
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|make_framename (guint32 size,guint32 delay,guint indent,GError ** errorp)
name|make_framename
parameter_list|(
name|guint32
name|size
parameter_list|,
name|guint32
name|delay
parameter_list|,
name|guint
name|indent
parameter_list|,
name|GError
modifier|*
modifier|*
name|errorp
parameter_list|)
block|{
specifier|static
struct|struct
DECL|struct|__anon2b8abdda0308
block|{
DECL|member|size
name|guint32
name|size
decl_stmt|;
DECL|member|count
name|guint
name|count
decl_stmt|;
block|}
name|Counter
index|[
name|MAX_SIZE_NUM
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|0
block|,}
block|}
struct|;
name|int
name|i
decl_stmt|;
comment|/* loop index */
comment|/* don't pass 0 for size. */
name|g_return_val_if_fail
argument_list|(
name|size
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "count" member of Counter's element means how many time corresponding      "size" is passed to this function. The size member of the last element      of Counter must be 0, so Counter can have MAX_SIZE_NUM elements at most.      This is not a smart way but rather simple than using dynamic method. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Counter
index|[
name|i
index|]
operator|.
name|size
operator|!=
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Counter
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
comment|/* the end of Counter elements */
block|{
if|if
condition|(
name|i
operator|>
name|MAX_SIZE_NUM
condition|)
block|{
comment|/* the number of different nominal size is over MAX_SIZE_NUM! */
name|g_set_error
argument_list|(
name|errorp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Sorry, this plug-in cannot handle a cursor "
literal|"which contains over %i different nominal sizes."
argument_list|)
argument_list|,
name|MAX_SIZE_NUM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
comment|/* append new element which "size" is given value. */
block|{
name|Counter
index|[
name|i
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
break|break;
block|}
block|}
block|}
name|Counter
index|[
name|i
index|]
operator|.
name|count
operator|+=
literal|1
expr_stmt|;
return|return
name|g_strdup_printf
argument_list|(
literal|"(%dpx)_%0*d (%dms) (replace)"
argument_list|,
name|size
argument_list|,
name|indent
argument_list|,
name|Counter
index|[
name|i
index|]
operator|.
name|count
argument_list|,
name|delay
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Get the region which is maintained when auto-crop.  **/
end_comment

begin_function
specifier|static
name|void
DECL|function|get_cropped_region (GimpParamRegion * return_rgn,GimpPixelRgn * pr)
name|get_cropped_region
parameter_list|(
name|GimpParamRegion
modifier|*
name|return_rgn
parameter_list|,
name|GimpPixelRgn
modifier|*
name|pr
parameter_list|)
block|{
name|guint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guint32
modifier|*
name|buf
init|=
name|g_malloc
argument_list|(
name|MAX
argument_list|(
name|pr
operator|->
name|w
argument_list|,
name|pr
operator|->
name|h
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|guint32
argument_list|)
argument_list|)
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"function:get_cropped_region\n"
argument_list|)
expr_stmt|;
name|gimp_tile_cache_ntiles
argument_list|(
name|MAX
argument_list|(
name|pr
operator|->
name|w
operator|/
name|gimp_tile_width
argument_list|()
argument_list|,
name|pr
operator|->
name|h
operator|/
name|gimp_tile_height
argument_list|()
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"getTrim:\tMAX=%i\tpr->w=%i\tpr->h=%i\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
literal|4
argument_list|,
name|pr
operator|->
name|w
argument_list|,
name|pr
operator|->
name|h
argument_list|)
expr_stmt|;
comment|/* find left border. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pr
operator|->
name|w
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"pr->x+i=%i\tpr->w=%i\n"
argument_list|,
name|pr
operator|->
name|x
operator|+
name|i
argument_list|,
name|pr
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_col
argument_list|(
name|pr
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|buf
argument_list|,
name|pr
operator|->
name|x
operator|+
name|i
argument_list|,
name|pr
operator|->
name|y
argument_list|,
name|pr
operator|->
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pr
operator|->
name|h
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|j
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|x
operator|=
name|pr
operator|->
name|x
operator|+
name|i
expr_stmt|;
goto|goto
name|find_right
goto|;
block|}
block|}
block|}
comment|/* pr has no opaque pixel. */
name|return_rgn
operator|->
name|width
operator|=
literal|0
expr_stmt|;
return|return;
comment|/* find right border. */
name|find_right
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pr
operator|->
name|w
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"pr->x+pr->w-1=%i\tpr->y+j=%i\tpr->h=%i\n"
argument_list|,
name|pr
operator|->
name|x
operator|+
name|pr
operator|->
name|w
operator|-
literal|1
operator|-
name|i
argument_list|,
name|pr
operator|->
name|y
argument_list|,
name|pr
operator|->
name|h
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_col
argument_list|(
name|pr
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|buf
argument_list|,
name|pr
operator|->
name|x
operator|+
name|pr
operator|->
name|w
operator|-
literal|1
operator|-
name|i
argument_list|,
name|pr
operator|->
name|y
argument_list|,
name|pr
operator|->
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pr
operator|->
name|h
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|j
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|width
operator|=
name|pr
operator|->
name|x
operator|+
name|pr
operator|->
name|w
operator|-
name|i
operator|-
name|return_rgn
operator|->
name|x
expr_stmt|;
goto|goto
name|find_top
goto|;
block|}
block|}
block|}
name|g_return_if_reached
argument_list|()
expr_stmt|;
comment|/* find top border. */
name|find_top
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pr
operator|->
name|h
condition|;
operator|++
name|j
control|)
block|{
name|DM_XMC
argument_list|(
literal|"pr->x=%i\tpr->y+j=%i\tpr->w=%i\n"
argument_list|,
name|pr
operator|->
name|x
argument_list|,
name|pr
operator|->
name|y
operator|+
name|j
argument_list|,
name|pr
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
name|pr
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|buf
argument_list|,
name|pr
operator|->
name|x
argument_list|,
name|pr
operator|->
name|y
operator|+
name|j
argument_list|,
name|pr
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pr
operator|->
name|w
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|y
operator|=
name|pr
operator|->
name|y
operator|+
name|j
expr_stmt|;
goto|goto
name|find_bottom
goto|;
block|}
block|}
block|}
name|g_return_if_reached
argument_list|()
expr_stmt|;
comment|/* find bottom border. */
name|find_bottom
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pr
operator|->
name|h
condition|;
operator|++
name|j
control|)
block|{
name|DM_XMC
argument_list|(
literal|"pr->x=%i\tpr->y+pr->h-1-j=%i\tpr->w=%i\n"
argument_list|,
name|pr
operator|->
name|x
argument_list|,
name|pr
operator|->
name|y
operator|+
name|pr
operator|->
name|h
operator|-
literal|1
operator|-
name|j
argument_list|,
name|pr
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
name|pr
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|buf
argument_list|,
name|pr
operator|->
name|x
argument_list|,
name|pr
operator|->
name|y
operator|+
name|pr
operator|->
name|h
operator|-
literal|1
operator|-
name|j
argument_list|,
name|pr
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pr
operator|->
name|w
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|height
operator|=
name|pr
operator|->
name|y
operator|+
name|pr
operator|->
name|h
operator|-
name|j
operator|-
name|return_rgn
operator|->
name|y
expr_stmt|;
goto|goto
name|end_trim
goto|;
block|}
block|}
block|}
name|g_return_if_reached
argument_list|()
expr_stmt|;
name|end_trim
label|:
name|DM_XMC
argument_list|(
literal|"width=%i\theight=%i\txoffset=%i\tyoffset=%i\n"
argument_list|,
name|return_rgn
operator|->
name|width
argument_list|,
name|return_rgn
operator|->
name|height
argument_list|,
name|return_rgn
operator|->
name|x
argument_list|,
name|return_rgn
operator|->
name|y
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return true if alpha of pix is not 0.  **/
end_comment

begin_function
specifier|static
specifier|inline
name|gboolean
DECL|function|pix_is_opaque (guint32 pix)
name|pix_is_opaque
parameter_list|(
name|guint32
name|pix
parameter_list|)
block|{
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pix
operator|=
name|GUINT32_TO_LE
argument_list|(
name|pix
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|pix
operator|>>
literal|24
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Get the intersection of the all layers of the image specified by image_ID.  * if the intersection is empty return NULL.  * don't forget to g_free returned pointer later. **/
end_comment

begin_function
specifier|static
name|GimpParamRegion
modifier|*
DECL|function|get_intersection_of_frames (gint32 image_ID)
name|get_intersection_of_frames
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GimpParamRegion
modifier|*
name|iregion
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint32
name|x1
init|=
name|G_MININT32
decl_stmt|,
name|x2
init|=
name|G_MAXINT32
decl_stmt|;
name|gint32
name|y1
init|=
name|G_MININT32
decl_stmt|,
name|y2
init|=
name|G_MAXINT32
decl_stmt|;
name|gint32
name|x_off
decl_stmt|,
name|y_off
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gint
modifier|*
name|layers
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|image_ID
operator|!=
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlayers
condition|;
operator|++
name|i
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|x_off
argument_list|,
operator|&
name|y_off
argument_list|)
condition|)
return|return
name|NULL
return|;
name|x1
operator|=
name|MAX
argument_list|(
name|x1
argument_list|,
name|x_off
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MAX
argument_list|(
name|y1
argument_list|,
name|y_off
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MIN
argument_list|(
name|x2
argument_list|,
name|x_off
operator|+
name|drawable
operator|->
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MIN
argument_list|(
name|y2
argument_list|,
name|y_off
operator|+
name|drawable
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x1
operator|>
name|x2
operator|||
name|y1
operator|>
name|y2
condition|)
return|return
name|NULL
return|;
comment|/* OK intersection exists. */
name|iregion
operator|=
name|g_new
argument_list|(
name|GimpParamRegion
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iregion
operator|->
name|x
operator|=
name|x1
expr_stmt|;
name|iregion
operator|->
name|y
operator|=
name|y1
expr_stmt|;
name|iregion
operator|->
name|width
operator|=
name|x2
operator|-
name|x1
operator|+
literal|1
expr_stmt|;
name|iregion
operator|->
name|height
operator|=
name|y2
operator|-
name|y1
operator|+
literal|1
expr_stmt|;
return|return
name|iregion
return|;
block|}
end_function

begin_comment
comment|/**  * If (x,y) is in xmcrp, return TRUE.  **/
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|pix_in_region (gint32 x,gint32 y,GimpParamRegion * xmcrp)
name|pix_in_region
parameter_list|(
name|gint32
name|x
parameter_list|,
name|gint32
name|y
parameter_list|,
name|GimpParamRegion
modifier|*
name|xmcrp
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|xmcrp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|xmcrp
operator|->
name|x
operator|||
name|y
operator|<
name|xmcrp
operator|->
name|y
operator|||
name|x
operator|>=
name|xmcrp
operator|->
name|x
operator|+
name|xmcrp
operator|->
name|width
operator|||
name|y
operator|>=
name|xmcrp
operator|->
name|y
operator|+
name|xmcrp
operator|->
name|height
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * Find out xhot, yhot, width and height of the Xcursor specified by xcIs.  * Use NULL for the value you don't want to return. **/
end_comment

begin_function
specifier|static
name|void
DECL|function|find_hotspots_and_dimensions (XcursorImages * xcIs,gint32 * xhotp,gint32 * yhotp,gint32 * widthp,gint32 * heightp)
name|find_hotspots_and_dimensions
parameter_list|(
name|XcursorImages
modifier|*
name|xcIs
parameter_list|,
name|gint32
modifier|*
name|xhotp
parameter_list|,
name|gint32
modifier|*
name|yhotp
parameter_list|,
name|gint32
modifier|*
name|widthp
parameter_list|,
name|gint32
modifier|*
name|heightp
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* loop value */
name|gint32
name|dw
decl_stmt|,
name|dh
decl_stmt|;
comment|/* the distance between hotspot and right(bottom) border */
name|gint32
name|max_xhot
decl_stmt|,
name|max_yhot
decl_stmt|;
comment|/* the maximum value of xhot(yhot) */
name|g_return_if_fail
argument_list|(
name|xcIs
argument_list|)
expr_stmt|;
name|max_xhot
operator|=
name|max_yhot
operator|=
name|dw
operator|=
name|dh
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcIs
operator|->
name|nimage
condition|;
operator|++
name|i
control|)
block|{
comment|/* xhot of entire image is the maximum value of xhot of all frames */
name|max_xhot
operator|=
name|MAX
argument_list|(
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|max_xhot
argument_list|)
expr_stmt|;
comment|/* same for yhot */
name|max_yhot
operator|=
name|MAX
argument_list|(
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|,
name|max_yhot
argument_list|)
expr_stmt|;
comment|/* the maximum distance between right border and xhot */
name|dw
operator|=
name|MAX
argument_list|(
name|dw
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
operator|-
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|)
expr_stmt|;
comment|/* the maximum distance between bottom border and yhot */
name|dh
operator|=
name|MAX
argument_list|(
name|dh
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
operator|-
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xhotp
condition|)
operator|*
name|xhotp
operator|=
name|max_xhot
expr_stmt|;
if|if
condition|(
name|yhotp
condition|)
operator|*
name|yhotp
operator|=
name|max_yhot
expr_stmt|;
if|if
condition|(
name|widthp
condition|)
operator|*
name|widthp
operator|=
name|dw
operator|+
name|max_xhot
expr_stmt|;
if|if
condition|(
name|heightp
condition|)
operator|*
name|heightp
operator|=
name|dh
operator|+
name|max_yhot
expr_stmt|;
block|}
end_function

end_unit

