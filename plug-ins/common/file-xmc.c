begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   X11 Mouse Cursor (XMC) plug-in for GIMP  *  *   Copyright 2008-2009 Takeshi Matsuyama<tksmashiw@gmail.com>  *  *   Special thanks: Alexia Death, Sven Neumann, Martin Nordholts  *                   and all community members.  */
end_comment

begin_comment
comment|/*  *   This program is free software: you can redistribute it and/or modify  *   it under the terms of the GNU General Public License as published by  *   the Free Software Foundation, either version 3 of the License, or  *   (at your option) any later version.  *  *   This program is distributed in the hope that it will be useful,  *   but WITHOUT ANY WARRANTY; without even the implied warranty of  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *   GNU General Public License for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program.  If not, see<https://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/*  * Todo: if drawable->bpp != 4 in save_image for GIMP-2.8?  * Todo: support for "gimp-metadata" parasite.  *       "xmc-copyright" and "xmc-license" may be deprecated in future?  */
end_comment

begin_comment
comment|/*  * This plug-in use these four parasites.  * "hot-spot"       common with file-xbm plug-in  * "xmc-copyright"  original, store contents of type1 comment chunk of Xcursor  * "xmc-license"    original, store contents of type2 comment chunk of Xcursor  * "gimp-comment"   common, store contents of type3 comment chunk of Xcursor  */
end_comment

begin_comment
comment|/* *** Caution: Size vs Dimension ***  *  * In this file, "size" and "dimension" are used in definitely  * different contexts.  "Size" means nominal size of Xcursor which is  * used to determine which frame depends on which animation sequence  * and which sequence is really used. (for more detail, please read  * Xcursor(3).)  On the other hand, "Dimension" simply means width  * and/or height.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<glib/gprintf.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xcursor/Xcursor.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* For debug */
end_comment

begin_comment
comment|/* #define XMC_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XMC_DEBUG
end_ifdef

begin_define
DECL|macro|DM_XMC (...)
define|#
directive|define
name|DM_XMC
parameter_list|(
modifier|...
parameter_list|)
value|g_fprintf(stderr, __VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|DM_XMC (...)
define|#
directive|define
name|DM_XMC
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Constants...  */
end_comment

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-xmc-load"
end_define

begin_define
DECL|macro|LOAD_THUMB_PROC
define|#
directive|define
name|LOAD_THUMB_PROC
value|"file-xmc-load-thumb"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-xmc-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-xmc"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-file-xmc"
end_define

begin_comment
comment|/* We use "xmc" as the file extension of X cursor for convenience */
end_comment

begin_define
DECL|macro|XCURSOR_EXTENSION
define|#
directive|define
name|XCURSOR_EXTENSION
value|"xmc"
end_define

begin_define
DECL|macro|XCURSOR_MIME_TYPE
define|#
directive|define
name|XCURSOR_MIME_TYPE
value|"image/x-xcursor"
end_define

begin_comment
comment|/* The maximum dimension of Xcursor which is fully supported in any  * environments. This is defined on line 59 of xcursorint.h in  * libXcursor source code. Make sure this is about dimensions (width  * and height) not about nominal size despite of it's name.  *  * As of 2018, this macro still exists in libXCursor codebase, but I am  * unsure how far this restriction is enforced since this is a very low  * max dimension for today's displays. Therefore our code will not  * enforce this value anymore, but only warn about possible  * incompatibilities when using higher values.  */
end_comment

begin_define
DECL|macro|MAX_BITMAP_CURSOR_SIZE
define|#
directive|define
name|MAX_BITMAP_CURSOR_SIZE
value|64
end_define

begin_comment
comment|/* The maximum dimension of each frame of X cursor we want to save  * should be MAX_BITMAP_CURSOR_SIZE but about loading, xhot(& yhot) of  * each frame varies from 0 to MAX_BITMAP_CURSOR_SIZE-1, so we need to  * set the maximum dimension of image no less than  * MAX_BITMAP_CURSOR_SIZE * 2( -1 to be precise) to remain hotspots on  * the same coordinates.  *  * We use four times value (256 for saving, 512 for loading) as a  * limitation because some cursors generated by CursorXP/FX to X11  * Mouse Theme Converter is very large.  *  * The biggest cursor I found is "watch" of OuterLimits which size is  * 213x208.  If you found bigger one, please tell me ;-)  */
end_comment

begin_define
DECL|macro|MAX_LOAD_DIMENSION
define|#
directive|define
name|MAX_LOAD_DIMENSION
value|512
end_define

begin_define
DECL|macro|MAX_SAVE_DIMENSION
define|#
directive|define
name|MAX_SAVE_DIMENSION
value|256
end_define

begin_comment
comment|/* The maximum number of different nominal sizes in one cursor this  * plug-in can treat. This is based on the number of cursor size which  * gnome-appearance-properties supports.(12,16,24,32,36,40,48,64)  * ref. capplets/common/gnome-theme-info.c in source of  * gnome-control-center  */
end_comment

begin_define
DECL|macro|MAX_SIZE_NUM
define|#
directive|define
name|MAX_SIZE_NUM
value|8
end_define

begin_comment
comment|/* cursor delay is guint32 defined in Xcursor.h */
end_comment

begin_define
DECL|macro|CURSOR_MAX_DELAY
define|#
directive|define
name|CURSOR_MAX_DELAY
value|100000000
end_define

begin_define
DECL|macro|CURSOR_DEFAULT_DELAY
define|#
directive|define
name|CURSOR_DEFAULT_DELAY
value|50
end_define

begin_define
DECL|macro|CURSOR_MINIMUM_DELAY
define|#
directive|define
name|CURSOR_MINIMUM_DELAY
value|5
end_define

begin_define
DECL|macro|div_255 (x)
define|#
directive|define
name|div_255
parameter_list|(
name|x
parameter_list|)
value|(((x) + 0x80 + (((x) + 0x80)>> 8))>> 8)
end_define

begin_define
DECL|macro|READ32 (f,e)
define|#
directive|define
name|READ32
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
value|read32 ((f), (e)); if (*(e)) return NULL;
end_define

begin_define
DECL|macro|DISPLAY_DIGIT (x)
define|#
directive|define
name|DISPLAY_DIGIT
parameter_list|(
name|x
parameter_list|)
value|((x)> 100) ? 3 : ((x)> 10) ? 2 : 1
end_define

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2bc260f00108
block|{
DECL|member|crop
name|gboolean
name|crop
decl_stmt|;
DECL|member|size
name|gint
name|size
decl_stmt|;
DECL|member|size_replace
name|gboolean
name|size_replace
decl_stmt|;
DECL|member|delay
name|gint32
name|delay
decl_stmt|;
DECL|member|delay_replace
name|gboolean
name|delay_replace
decl_stmt|;
DECL|typedef|XmcSaveVals
block|}
name|XmcSaveVals
typedef|;
end_typedef

begin_typedef
DECL|typedef|Xmc
typedef|typedef
name|struct
name|_Xmc
name|Xmc
typedef|;
end_typedef

begin_typedef
DECL|typedef|XmcClass
typedef|typedef
name|struct
name|_XmcClass
name|XmcClass
typedef|;
end_typedef

begin_struct
DECL|struct|_Xmc
struct|struct
name|_Xmc
block|{
DECL|member|parent_instance
name|GimpPlugIn
name|parent_instance
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_XmcClass
struct|struct
name|_XmcClass
block|{
DECL|member|parent_class
name|GimpPlugInClass
name|parent_class
decl_stmt|;
block|}
struct|;
end_struct

begin_define
DECL|macro|XMC_TYPE
define|#
directive|define
name|XMC_TYPE
value|(xmc_get_type ())
end_define

begin_define
DECL|macro|XMC
define|#
directive|define
name|XMC
value|(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XMC_TYPE, Xmc))
end_define

begin_decl_stmt
name|GType
name|xmc_get_type
argument_list|(
name|void
argument_list|)
name|G_GNUC_CONST
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GList
modifier|*
name|xmc_query_procedures
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpProcedure
modifier|*
name|xmc_create_procedure
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|xmc_load
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|xmc_load_thumb
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
name|gint
name|size
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|xmc_save
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImage
modifier|*
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImage
modifier|*
name|load_thumbnail
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|thumb_size
parameter_list|,
name|gint32
modifier|*
name|width
parameter_list|,
name|gint32
modifier|*
name|height
parameter_list|,
name|gint32
modifier|*
name|num_layers
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guint32
name|read32
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|orig_image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GeglRectangle
modifier|*
name|hotspotRange
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comment_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|text_view_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|load_default_hotspot
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GeglRectangle
modifier|*
name|hotspotRange
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|guint32
name|separate_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|guint32
name|premultiply_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XcursorComments
modifier|*
name|set_cursor_comments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_comments
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|set_comment_to_pname
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|content
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|get_comment_from_pname
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|set_hotspot_to_parasite
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|get_hotspot_from_parasite
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_size_and_delay
parameter_list|(
specifier|const
name|gchar
modifier|*
name|framename
parameter_list|,
name|guint32
modifier|*
name|sizep
parameter_list|,
name|guint32
modifier|*
name|delayp
parameter_list|,
name|GRegex
modifier|*
name|re
parameter_list|,
name|gboolean
modifier|*
name|size_warnp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gchar
modifier|*
name|make_framename
parameter_list|(
name|guint32
name|size
parameter_list|,
name|guint32
name|delay
parameter_list|,
name|guint
name|indent
parameter_list|,
name|GError
modifier|*
modifier|*
name|errorp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_cropped_region
parameter_list|(
name|GeglRectangle
modifier|*
name|retrun_rgn
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|gboolean
name|pix_is_opaque
parameter_list|(
name|guint32
name|pix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GeglRectangle
modifier|*
name|get_intersection_of_frames
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|pix_in_region
parameter_list|(
name|gint32
name|x
parameter_list|,
name|gint32
name|y
parameter_list|,
name|GeglRectangle
modifier|*
name|xmcrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_hotspots_and_dimensions
parameter_list|(
name|XcursorImages
modifier|*
name|xcIs
parameter_list|,
name|gint32
modifier|*
name|xhot
parameter_list|,
name|gint32
modifier|*
name|yhot
parameter_list|,
name|gint32
modifier|*
name|width
parameter_list|,
name|gint32
modifier|*
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|G_DEFINE_TYPE
argument_list|(
argument|Xmc
argument_list|,
argument|xmc
argument_list|,
argument|GIMP_TYPE_PLUG_IN
argument_list|)
end_macro

begin_macro
name|GIMP_MAIN
argument_list|(
argument|XMC_TYPE
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|XmcSaveVals
name|xmcvals
init|=
block|{
comment|/* saved in pdb after this plug-in's process has gone. */
name|FALSE
block|,
comment|/* crop */
literal|32
block|,
comment|/* size */
name|FALSE
block|,
comment|/* size_replace */
name|CURSOR_DEFAULT_DELAY
block|,
comment|/* delay */
name|FALSE
comment|/* delay_replace */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2bc260f00208
block|{
comment|/* saved as parasites of original image after this plug-in's process has gone.*/
DECL|member|x
name|gint32
name|x
decl_stmt|;
comment|/* hotspot x */
DECL|member|y
name|gint32
name|y
decl_stmt|;
comment|/* hotspot y */
DECL|member|comments
name|gchar
modifier|*
name|comments
index|[
literal|3
index|]
decl_stmt|;
comment|/* copyright, license, other */
DECL|variable|xmcparas
block|}
name|xmcparas
init|=
block|{
literal|0
block|,}
struct|;
end_struct

begin_comment
comment|/* parasites correspond to XcursorComment type */
end_comment

begin_decl_stmt
DECL|variable|parasiteName
specifier|static
specifier|const
name|gchar
modifier|*
name|parasiteName
index|[
literal|3
index|]
init|=
block|{
literal|"xmc-copyright"
block|,
literal|"xmc-license"
block|,
literal|"gimp-comment"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|xmc_class_init (XmcClass * klass)
name|xmc_class_init
parameter_list|(
name|XmcClass
modifier|*
name|klass
parameter_list|)
block|{
name|GimpPlugInClass
modifier|*
name|plug_in_class
init|=
name|GIMP_PLUG_IN_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|plug_in_class
operator|->
name|query_procedures
operator|=
name|xmc_query_procedures
expr_stmt|;
name|plug_in_class
operator|->
name|create_procedure
operator|=
name|xmc_create_procedure
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xmc_init (Xmc * xmc)
name|xmc_init
parameter_list|(
name|Xmc
modifier|*
name|xmc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|xmc_query_procedures (GimpPlugIn * plug_in)
name|xmc_query_procedures
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|)
block|{
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|LOAD_THUMB_PROC
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|LOAD_PROC
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|SAVE_PROC
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|GimpProcedure
modifier|*
DECL|function|xmc_create_procedure (GimpPlugIn * plug_in,const gchar * name)
name|xmc_create_procedure
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GimpProcedure
modifier|*
name|procedure
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_load_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|xmc_load
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_menu_label
argument_list|(
name|procedure
argument_list|,
name|N_
argument_list|(
literal|"X11 Mouse Cursor"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Loads files of X11 Mouse Cursor "
literal|"file format"
argument_list|,
literal|"This plug-in loads X11 Mouse Cursor "
literal|"(XMC) files."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Takeshi Matsuyama<tksmashiw@gmail.com>"
argument_list|,
literal|"Takeshi Matsuyama"
argument_list|,
literal|"26 May 2009"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_mime_types
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
name|XCURSOR_MIME_TYPE
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_extensions
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
name|XCURSOR_EXTENSION
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_magics
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"0,string,Xcur"
argument_list|)
expr_stmt|;
name|gimp_load_procedure_set_thumbnail_loader
argument_list|(
name|GIMP_LOAD_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
name|LOAD_THUMB_PROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_THUMB_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_thumbnail_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|xmc_load_thumb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Loads only first frame of X11 Mouse "
literal|"Cursor's animation sequence which "
literal|"nominal size is the closest of "
literal|"thumb-size to be used as a thumbnail"
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Takeshi Matsuyama<tksmashiw@gmail.com>"
argument_list|,
literal|"Takeshi Matsuyama"
argument_list|,
literal|"26 May 2009"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_save_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|xmc_save
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_image_types
argument_list|(
name|procedure
argument_list|,
literal|"RGBA"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_menu_label
argument_list|(
name|procedure
argument_list|,
name|N_
argument_list|(
literal|"X11 Mouse Cursor"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Exports files of X11 cursor file"
argument_list|,
literal|"This plug-in exports X11 Mouse Cursor "
literal|"(XMC) files"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Takeshi Matsuyama<tksmashiw@gmail.com>"
argument_list|,
literal|"Takeshi Matsuyama"
argument_list|,
literal|"26 May 2009"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_mime_types
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
name|XCURSOR_MIME_TYPE
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_extensions
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
name|XCURSOR_EXTENSION
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"x-hot"
argument_list|,
literal|"X hot"
argument_list|,
literal|"X-coordinate of hot spot"
argument_list|,
operator|-
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
operator|-
literal|1
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"y-hot"
argument_list|,
literal|"Y hot"
argument_list|,
literal|"Y-coordinate of hot spot "
literal|"(use -1, -1 to keep original hot spot"
argument_list|,
operator|-
literal|1
argument_list|,
name|GIMP_MAX_IMAGE_SIZE
argument_list|,
operator|-
literal|1
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"crop"
argument_list|,
literal|"Crop"
argument_list|,
literal|"Auto-crop or not"
argument_list|,
name|FALSE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"size"
argument_list|,
literal|"Size"
argument_list|,
literal|"Default nominal size"
argument_list|,
literal|1
argument_list|,
name|G_MAXINT
argument_list|,
literal|32
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"size-replace"
argument_list|,
literal|"Size replace"
argument_list|,
literal|"Replace existent size or not"
argument_list|,
name|FALSE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"delay"
argument_list|,
literal|"Delay"
argument_list|,
literal|"Default delay"
argument_list|,
literal|0
argument_list|,
name|G_MAXINT
argument_list|,
name|CURSOR_DEFAULT_DELAY
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_BOOLEAN
argument_list|(
name|procedure
argument_list|,
literal|"delay-replace"
argument_list|,
literal|"Delay replace"
argument_list|,
literal|"Replace existent delay or not"
argument_list|,
name|FALSE
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_STRING
argument_list|(
name|procedure
argument_list|,
literal|"copyright"
argument_list|,
literal|"Copyright"
argument_list|,
literal|"Copyright information"
argument_list|,
name|NULL
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_STRING
argument_list|(
name|procedure
argument_list|,
literal|"license"
argument_list|,
literal|"License"
argument_list|,
literal|"License information"
argument_list|,
name|NULL
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_STRING
argument_list|(
name|procedure
argument_list|,
literal|"other"
argument_list|,
literal|"Other"
argument_list|,
literal|"Other comment (taken from 'gimp-comment' parasite"
argument_list|,
name|NULL
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
block|}
return|return
name|procedure
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|xmc_load (GimpProcedure * procedure,GimpRunMode run_mode,GFile * file,const GimpValueArray * args,gpointer run_data)
name|xmc_load
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpValueArray
modifier|*
name|return_vals
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filename
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|image
operator|=
name|load_image
argument_list|(
name|filename
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_EXECUTION_ERROR
argument_list|,
name|error
argument_list|)
return|;
name|return_vals
operator|=
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_SUCCESS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_IMAGE
argument_list|(
name|return_vals
argument_list|,
literal|1
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return
name|return_vals
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|xmc_load_thumb (GimpProcedure * procedure,GFile * file,gint size,const GimpValueArray * args,gpointer run_data)
name|xmc_load_thumb
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
name|gint
name|size
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpValueArray
modifier|*
name|return_vals
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|num_layers
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filename
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|image
operator|=
name|load_thumbnail
argument_list|(
name|filename
argument_list|,
name|size
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|num_layers
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_EXECUTION_ERROR
argument_list|,
name|error
argument_list|)
return|;
name|return_vals
operator|=
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_SUCCESS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_IMAGE
argument_list|(
name|return_vals
argument_list|,
literal|1
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_INT
argument_list|(
name|return_vals
argument_list|,
literal|2
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_INT
argument_list|(
name|return_vals
argument_list|,
literal|3
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_ENUM
argument_list|(
name|return_vals
argument_list|,
literal|4
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_INT
argument_list|(
name|return_vals
argument_list|,
literal|5
argument_list|,
name|num_layers
argument_list|)
expr_stmt|;
return|return
name|return_vals
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|xmc_save (GimpProcedure * procedure,GimpRunMode run_mode,GimpImage * image,GimpDrawable * drawable,GFile * file,const GimpValueArray * args,gpointer run_data)
name|xmc_save
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gchar
modifier|*
name|filename
decl_stmt|;
name|GimpImage
modifier|*
name|orig_image
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GeglRectangle
modifier|*
name|hotspotRange
init|=
name|NULL
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|orig_image
operator|=
name|image
expr_stmt|;
name|filename
operator|=
name|g_file_get_path
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|hotspotRange
operator|=
name|get_intersection_of_frames
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hotspotRange
condition|)
block|{
name|g_set_error
argument_list|(
operator|&
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Cannot set the hot spot!\n"
literal|"You must arrange layers so that all of them have "
literal|"an intersection."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_EXECUTION_ERROR
argument_list|,
name|error
argument_list|)
return|;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image
argument_list|,
operator|&
name|drawable
argument_list|,
literal|"XMC"
argument_list|,
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator||
name|GIMP_EXPORT_CAN_HANDLE_LAYERS
operator||
name|GIMP_EXPORT_NEEDS_ALPHA
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_CANCEL
argument_list|,
name|NULL
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xmcvals
argument_list|)
expr_stmt|;
name|load_comments
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|load_default_hotspot
argument_list|(
name|image
argument_list|,
name|hotspotRange
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|image
argument_list|,
name|hotspotRange
argument_list|)
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_CANCEL
argument_list|,
name|NULL
argument_list|)
return|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
if|if
condition|(
name|pix_in_region
argument_list|(
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
argument_list|,
name|hotspotRange
argument_list|)
condition|)
block|{
comment|/* if passed hotspot is acceptable, use that ones. */
name|xmcparas
operator|.
name|x
operator|=
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xmcparas
operator|.
name|y
operator|=
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* you can purposely choose non acceptable values for hotspot            * to use cursor's original values.            */
name|load_default_hotspot
argument_list|(
name|image
argument_list|,
name|hotspotRange
argument_list|)
expr_stmt|;
block|}
name|xmcvals
operator|.
name|crop
operator|=
name|GIMP_VALUES_GET_BOOLEAN
argument_list|(
name|args
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xmcvals
operator|.
name|size
operator|=
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|xmcvals
operator|.
name|size_replace
operator|=
name|GIMP_VALUES_GET_BOOLEAN
argument_list|(
name|args
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
operator|<
name|CURSOR_MINIMUM_DELAY
condition|)
block|{
name|xmcvals
operator|.
name|delay
operator|=
name|CURSOR_DEFAULT_DELAY
expr_stmt|;
block|}
else|else
block|{
name|xmcvals
operator|.
name|delay
operator|=
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|xmcvals
operator|.
name|delay_replace
operator|=
name|GIMP_VALUES_GET_BOOLEAN
argument_list|(
name|args
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|load_comments
argument_list|(
name|image
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|GIMP_VALUES_GET_STRING
argument_list|(
name|args
argument_list|,
literal|7
operator|+
name|i
argument_list|)
condition|)
block|{
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
operator|=
name|GIMP_VALUES_DUP_STRING
argument_list|(
name|args
argument_list|,
literal|7
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xmcvals
argument_list|)
expr_stmt|;
name|load_comments
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|load_default_hotspot
argument_list|(
name|image
argument_list|,
name|hotspotRange
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|save_image
argument_list|(
name|g_file_get_path
argument_list|(
name|file
argument_list|)
argument_list|,
name|image
argument_list|,
name|drawable
argument_list|,
name|orig_image
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xmcvals
argument_list|,
sizeof|sizeof
argument_list|(
name|XmcSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|hotspotRange
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|g_free
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|g_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|status
argument_list|,
name|error
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'load_image()' - Load a X cursor image into a new image window.  */
end_comment

begin_function
specifier|static
name|GimpImage
modifier|*
DECL|function|load_image (const gchar * filename,GError ** error)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|XcursorComments
modifier|*
name|commentsp
decl_stmt|;
comment|/* pointer to comments */
name|XcursorImages
modifier|*
name|imagesp
decl_stmt|;
comment|/* pointer to images*/
name|guint32
name|delay
decl_stmt|;
comment|/* use guint32 instead CARD32(in X11/Xmd.h) */
name|gchar
modifier|*
name|framename
decl_stmt|;
comment|/* name of layer */
name|guint32
modifier|*
name|tmppixel
decl_stmt|;
comment|/* pixel data (guchar * bpp = guint32) */
name|gint
name|img_width
decl_stmt|;
name|gint
name|img_height
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the file and check it is a valid X cursor */
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|XcursorFileLoad
argument_list|(
name|fp
argument_list|,
operator|&
name|commentsp
argument_list|,
operator|&
name|imagesp
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid X cursor."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check dimension is valid. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|imagesp
operator|->
name|nimage
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Frame %d of '%s' is too wide for an X cursor."
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Frame %d of '%s' is too high for an X cursor."
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|find_hotspots_and_dimensions
argument_list|(
name|imagesp
argument_list|,
operator|&
name|xmcparas
operator|.
name|x
argument_list|,
operator|&
name|xmcparas
operator|.
name|y
argument_list|,
operator|&
name|img_width
argument_list|,
operator|&
name|img_height
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"xhot=%i,\tyhot=%i,\timg_width=%i,\timg_height=%i\n"
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|img_width
argument_list|,
name|img_height
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_image_new
argument_list|(
name|img_width
argument_list|,
name|img_height
argument_list|,
name|GIMP_RGB
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_hotspot_to_parasite
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Temporary buffer */
name|tmppixel
operator|=
name|g_new
argument_list|(
name|guint32
argument_list|,
name|img_width
operator|*
name|img_height
argument_list|)
expr_stmt|;
comment|/* load each frame to each layer one by one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|imagesp
operator|->
name|nimage
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|width
init|=
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
decl_stmt|;
name|gint
name|height
init|=
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
decl_stmt|;
name|delay
operator|=
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|delay
operator|<
name|CURSOR_MINIMUM_DELAY
condition|)
block|{
name|delay
operator|=
name|CURSOR_DEFAULT_DELAY
expr_stmt|;
block|}
name|DM_XMC
argument_list|(
literal|"images[%i]->delay=%i\twidth=%d\theight=%d\n"
argument_list|,
name|i
argument_list|,
name|delay
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
argument_list|)
expr_stmt|;
name|framename
operator|=
name|make_framename
argument_list|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|delay
argument_list|,
name|DISPLAY_DIGIT
argument_list|(
name|imagesp
operator|->
name|nimage
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|framename
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|framename
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|gimp_image_get_default_new_layer_mode
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Adjust layer position to let hotspot sit on the same point. */
name|gimp_item_transform_translate
argument_list|(
name|GIMP_ITEM
argument_list|(
name|layer
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|x
operator|-
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|xmcparas
operator|.
name|y
operator|-
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
comment|/* Get the buffer for our load... */
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set color to each pixel */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
operator|*
name|height
condition|;
name|j
operator|++
control|)
block|{
name|tmppixel
index|[
name|j
index|]
operator|=
name|separate_alpha
argument_list|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* set pixel */
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|tmppixel
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
name|imagesp
operator|->
name|nimage
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|tmppixel
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
comment|/* Comment parsing */
if|if
condition|(
name|commentsp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commentsp
operator|->
name|ncomment
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"comment type=%d\tcomment=%s\n"
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment_type
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_comment_to_pname
argument_list|(
name|image
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment
argument_list|,
name|parasiteName
index|[
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment_type
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to write %ith comment.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
name|DM_XMC
argument_list|(
literal|"Comment parsing done.\n"
argument_list|)
expr_stmt|;
name|XcursorImagesDestroy
argument_list|(
name|imagesp
argument_list|)
expr_stmt|;
name|XcursorCommentsDestroy
argument_list|(
name|commentsp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gimp_progress_end
argument_list|()
expr_stmt|;
return|return
name|image
return|;
block|}
end_function

begin_comment
comment|/*  * load_thumbnail  */
end_comment

begin_function
specifier|static
name|GimpImage
modifier|*
DECL|function|load_thumbnail (const gchar * filename,gint32 thumb_size,gint32 * thumb_width,gint32 * thumb_height,gint32 * thumb_num_layers,GError ** error)
name|load_thumbnail
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|thumb_size
parameter_list|,
name|gint32
modifier|*
name|thumb_width
parameter_list|,
name|gint32
modifier|*
name|thumb_height
parameter_list|,
name|gint32
modifier|*
name|thumb_num_layers
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/* Return only one frame for thumbnail.    * We select first frame of an animation sequence which nominal size is the    * closest of thumb_size.    */
name|XcursorImages
modifier|*
name|xcIs
init|=
name|NULL
decl_stmt|;
comment|/* use to find the dimensions of thumbnail */
name|XcursorImage
modifier|*
name|xcI
decl_stmt|;
comment|/* temporary pointer to XcursorImage */
name|guint32
modifier|*
name|positions
decl_stmt|;
comment|/* array of the offsets of image chunks */
name|guint32
name|size
decl_stmt|;
comment|/* nominal size */
name|guint32
name|diff
decl_stmt|;
comment|/* difference between thumb_size and current size */
name|guint32
name|min_diff
init|=
name|XCURSOR_IMAGE_MAX_SIZE
decl_stmt|;
comment|/* minimum value of diff */
name|guint32
name|type
decl_stmt|;
comment|/* chunk type */
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|GimpImage
modifier|*
name|image
init|=
name|NULL
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|guint32
modifier|*
name|tmppixel
decl_stmt|;
comment|/* pixel data (guchar * bpp = guint32) */
name|guint32
name|ntoc
init|=
literal|0
decl_stmt|;
comment|/* the number of table of contents */
name|gint
name|sel_num
init|=
operator|-
literal|1
decl_stmt|;
comment|/* the index of selected image chunk */
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|thumb_width
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|thumb_height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|thumb_num_layers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|thumb_width
operator|=
literal|0
expr_stmt|;
operator|*
name|thumb_height
operator|=
literal|0
expr_stmt|;
operator|*
name|thumb_num_layers
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* From this line, we make a XcursorImages struct so that we can find out the    * width and height of entire image.    * We can use XcursorFileLoadImages (fp, thumb_size) from libXcursor instead    * of this ugly code but XcursorFileLoadImages loads all pixel data of the    * image chunks on memory thus we should not use it.    */
comment|/* find which image chunk is preferred to load. */
comment|/* skip magic, headersize, version */
name|fseek
argument_list|(
name|fp
argument_list|,
literal|12
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* read the number of chunks */
name|ntoc
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
if|if
condition|(
name|ntoc
operator|>
operator|(
name|G_MAXUINT32
operator|/
sizeof|sizeof
argument_list|(
name|guint32
argument_list|)
operator|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"'%s' seems to have an incorrect toc size."
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|positions
operator|=
name|g_malloc
argument_list|(
name|ntoc
operator|*
sizeof|sizeof
argument_list|(
name|guint32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enter list of toc(table of contents) */
for|for
control|(
init|;
name|ntoc
operator|>
literal|0
condition|;
operator|--
name|ntoc
control|)
block|{
comment|/* read entry type */
name|type
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
if|if
condition|(
name|type
operator|!=
name|XCURSOR_IMAGE_TYPE
condition|)
block|{
comment|/* not a image */
comment|/* skip rest of this content */
name|fseek
argument_list|(
name|fp
argument_list|,
literal|8
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this content is image */
name|size
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|positions
index|[
operator|*
name|thumb_num_layers
index|]
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
comment|/* is this image is more preferred than selected before? */
name|diff
operator|=
name|MAX
argument_list|(
name|thumb_size
argument_list|,
name|size
argument_list|)
operator|-
name|MIN
argument_list|(
name|thumb_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|min_diff
condition|)
block|{
comment|/* the image size is closer than current selected image */
name|min_diff
operator|=
name|diff
expr_stmt|;
name|sel_num
operator|=
operator|*
name|thumb_num_layers
expr_stmt|;
block|}
operator|++
operator|*
name|thumb_num_layers
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sel_num
operator|<
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"there is no image chunk in \"%s\"."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get width and height of entire image */
comment|/* Let's make XcursorImages */
name|xcIs
operator|=
name|XcursorImagesCreate
argument_list|(
operator|*
name|thumb_num_layers
argument_list|)
expr_stmt|;
name|xcIs
operator|->
name|nimage
operator|=
operator|*
name|thumb_num_layers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcIs
operator|->
name|nimage
condition|;
operator|++
name|i
control|)
block|{
comment|/* make XcursorImage with no pixel buffer */
name|xcI
operator|=
name|XcursorImageCreate
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* go to the image chunk header */
name|fseek
argument_list|(
name|fp
argument_list|,
name|positions
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* skip chunk header */
name|fseek
argument_list|(
name|fp
argument_list|,
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* read properties of this image to determine entire image dimensions */
name|xcI
operator|->
name|width
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcI
operator|->
name|height
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcI
operator|->
name|xhot
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcI
operator|->
name|yhot
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|=
name|xcI
expr_stmt|;
block|}
name|DM_XMC
argument_list|(
literal|"selected size is %i or %i\n"
argument_list|,
name|thumb_size
operator|-
name|min_diff
argument_list|,
name|thumb_size
operator|+
name|min_diff
argument_list|)
expr_stmt|;
comment|/* get entire image dimensions */
name|find_hotspots_and_dimensions
argument_list|(
name|xcIs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|thumb_width
argument_list|,
name|thumb_height
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"width=%i\theight=%i\tnum-layers=%i\n"
argument_list|,
operator|*
name|thumb_width
argument_list|,
operator|*
name|thumb_height
argument_list|,
name|xcIs
operator|->
name|nimage
argument_list|)
expr_stmt|;
comment|/* dimension check */
if|if
condition|(
operator|*
name|thumb_width
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"'%s' is too wide for an X cursor."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|thumb_height
operator|>
name|MAX_LOAD_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"'%s' is too high for an X cursor."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  create new image! */
name|width
operator|=
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|xcIs
operator|->
name|images
index|[
name|sel_num
index|]
operator|->
name|height
expr_stmt|;
name|image
operator|=
name|gimp_image_new
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|GIMP_RGB
argument_list|)
expr_stmt|;
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|NULL
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|gimp_image_get_default_new_layer_mode
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Get the drawable and set the pixel region for our load...    */
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Temporary buffer */
name|tmppixel
operator|=
name|g_new
argument_list|(
name|guint32
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
comment|/* copy the chunk data to tmppixel */
name|fseek
argument_list|(
name|fp
argument_list|,
name|positions
index|[
name|sel_num
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
literal|36
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* skip chunk header(16bytes), xhot, yhot, width, height, delay */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|*
name|height
condition|;
name|i
operator|++
control|)
block|{
name|tmppixel
index|[
name|i
index|]
operator|=
name|READ32
argument_list|(
argument|fp
argument_list|,
argument|error
argument_list|)
comment|/* get back separate alpha */
name|tmppixel
index|[
name|i
index|]
operator|=
name|separate_alpha
argument_list|(
name|tmppixel
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* set pixel */
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|tmppixel
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
comment|/* free tmppixel */
name|g_free
argument_list|(
name|tmppixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|positions
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function

begin_comment
comment|/* read guint32 value from f despite of host's byte order. */
end_comment

begin_function
specifier|static
name|guint32
DECL|function|read32 (FILE * f,GError ** error)
name|read32
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guchar
name|p
index|[
literal|4
index|]
decl_stmt|;
name|guint32
name|ret
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|f
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"A read error occurred."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|G_BYTE_ORDER
operator|==
name|G_LITTLE_ENDIAN
name|ret
operator|=
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
elif|#
directive|elif
name|G_BYTE_ORDER
operator|==
name|G_BIG_ENDIAN
name|ret
operator|=
name|p
index|[
literal|3
index|]
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
elif|#
directive|elif
name|G_BYTE_ORDER
operator|==
name|G_PDP_ENDIAN
name|ret
operator|=
name|p
index|[
literal|2
index|]
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
else|#
directive|else
name|g_return_val_if_rearched
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* 'save_dialog ()'  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (GimpImage * image,GeglRectangle * hotspotRange)
name|save_dialog
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GeglRectangle
modifier|*
name|hotspotRange
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|grid
decl_stmt|;
name|GtkWidget
modifier|*
name|box
decl_stmt|;
name|GtkAdjustment
modifier|*
name|adjustment
decl_stmt|;
name|GtkWidget
modifier|*
name|tmpwidget
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkTextBuffer
modifier|*
name|textbuffer
decl_stmt|;
name|GValue
name|val
init|=
name|G_VALUE_INIT
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|g_value_init
argument_list|(
operator|&
name|val
argument_list|,
name|G_TYPE_DOUBLE
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"X11 Mouse Cursor"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|SAVE_PROC
argument_list|)
expr_stmt|;
comment|/*    * parameter settings    */
name|frame
operator|=
name|gimp_frame_new
argument_list|(
name|_
argument_list|(
literal|"XMC Options"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|grid
operator|=
name|gtk_grid_new
argument_list|()
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|grid
argument_list|)
expr_stmt|;
name|gtk_grid_set_row_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_grid_set_column_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|grid
argument_list|)
expr_stmt|;
comment|/*    *  Hotspot    */
comment|/* label "Hot spot  _X:" + spinbox */
name|x1
operator|=
name|hotspotRange
operator|->
name|x
expr_stmt|;
name|x2
operator|=
name|hotspotRange
operator|->
name|width
operator|+
name|hotspotRange
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|adjustment
operator|=
name|gtk_adjustment_new
argument_list|(
name|xmcparas
operator|.
name|x
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpwidget
operator|=
name|gimp_spin_button_new
argument_list|(
name|adjustment
argument_list|,
literal|1.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_spin_button_set_numeric
argument_list|(
name|GTK_SPIN_BUTTON
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_value_set_double
argument_list|(
operator|&
name|val
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_set_property
argument_list|(
name|G_OBJECT
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|"xalign"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* align right*/
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Hot spot _X:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xmcparas
operator|.
name|x
argument_list|)
expr_stmt|;
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter the X coordinate of the hot spot. "
literal|"The origin is top left corner."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* label "Y:" + spinbox */
name|y1
operator|=
name|hotspotRange
operator|->
name|y
expr_stmt|;
name|y2
operator|=
name|hotspotRange
operator|->
name|height
operator|+
name|hotspotRange
operator|->
name|y
operator|-
literal|1
expr_stmt|;
name|adjustment
operator|=
name|gtk_adjustment_new
argument_list|(
name|xmcparas
operator|.
name|y
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpwidget
operator|=
name|gimp_spin_button_new
argument_list|(
name|adjustment
argument_list|,
literal|1.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_spin_button_set_numeric
argument_list|(
name|GTK_SPIN_BUTTON
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_value_set_double
argument_list|(
operator|&
name|val
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_set_property
argument_list|(
name|G_OBJECT
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|"xalign"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* align right*/
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"_Y:"
argument_list|,
literal|1.0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xmcparas
operator|.
name|y
argument_list|)
expr_stmt|;
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter the Y coordinate of the hot spot. "
literal|"The origin is top left corner."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*    *  Auto-crop    */
comment|/* check button */
name|tmpwidget
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Auto-Crop all frames."
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|xmcvals
operator|.
name|crop
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|tmpwidget
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|crop
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Remove the empty borders of all frames.\n"
literal|"This reduces the file size and may fix "
literal|"the problem that some large cursors disorder "
literal|"the screen.\n"
literal|"Uncheck if you plan to edit the exported "
literal|"cursor using other programs."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*    *  size    */
name|tmpwidget
operator|=
name|gimp_int_combo_box_new
argument_list|(
literal|"12px"
argument_list|,
literal|12
argument_list|,
literal|"16px"
argument_list|,
literal|16
argument_list|,
literal|"24px"
argument_list|,
literal|24
argument_list|,
literal|"32px"
argument_list|,
literal|32
argument_list|,
literal|"36px"
argument_list|,
literal|36
argument_list|,
literal|"40px"
argument_list|,
literal|40
argument_list|,
literal|"48px"
argument_list|,
literal|48
argument_list|,
literal|"64px"
argument_list|,
literal|64
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_int_combo_box_connect
argument_list|(
name|GIMP_INT_COMBO_BOX
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|32
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_combo_box_get_active
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Choose the nominal size of frames.\n"
literal|"If you don't have plans to make multi-sized "
literal|"cursor, or you have no idea, leave it \"32px\".\n"
literal|"Nominal size has no relation with the actual "
literal|"size (width or height).\n"
literal|"It is only used to determine which frame depends "
literal|"on which animation sequence, and which sequence "
literal|"is used based on the value of "
literal|"\"gtk-cursor-theme-size\"."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"_Size:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Replace size ? */
name|tmpwidget
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|size_replace
argument_list|,
name|xmcvals
operator|.
name|size_replace
argument_list|,
name|_
argument_list|(
literal|"_Use this value only for a frame which size "
literal|"is not specified."
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"_Replace the size of all frames even if it "
literal|"is specified."
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_set
argument_list|(
name|tmpwidget
argument_list|,
literal|"margin-start"
argument_list|,
literal|20
argument_list|,
literal|"margin-bottom"
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/*    * delay    */
comment|/* spin button */
name|box
operator|=
name|gtk_box_new
argument_list|(
name|GTK_ORIENTATION_HORIZONTAL
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|_
argument_list|(
literal|"_Delay:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|box
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|box
argument_list|)
expr_stmt|;
name|gimp_help_set_help_data
argument_list|(
name|box
argument_list|,
name|_
argument_list|(
literal|"Enter time span in milliseconds in which "
literal|"each frame is rendered."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|adjustment
operator|=
name|gtk_adjustment_new
argument_list|(
name|xmcvals
operator|.
name|delay
argument_list|,
name|CURSOR_MINIMUM_DELAY
argument_list|,
name|CURSOR_MAX_DELAY
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpwidget
operator|=
name|gimp_spin_button_new
argument_list|(
name|adjustment
argument_list|,
literal|1.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_spin_button_set_numeric
argument_list|(
name|GTK_SPIN_BUTTON
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_value_set_double
argument_list|(
operator|&
name|val
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_set_property
argument_list|(
name|G_OBJECT
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|"xalign"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* align right*/
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|box
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|delay
argument_list|)
expr_stmt|;
comment|/* appended "ms" */
name|tmpwidget
operator|=
name|gtk_label_new
argument_list|(
literal|"ms"
argument_list|)
expr_stmt|;
name|gtk_label_set_xalign
argument_list|(
name|GTK_LABEL
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/*align left*/
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|box
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* Replace delay? */
name|tmpwidget
operator|=
name|gimp_int_radio_group_new
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_radio_button_update
argument_list|)
argument_list|,
operator|&
name|xmcvals
operator|.
name|delay_replace
argument_list|,
name|xmcvals
operator|.
name|delay_replace
argument_list|,
name|_
argument_list|(
literal|"_Use this value only for a frame which delay "
literal|"is not specified."
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"_Replace the delay of all frames even if it "
literal|"is specified."
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_set
argument_list|(
name|tmpwidget
argument_list|,
literal|"margin-start"
argument_list|,
literal|20
argument_list|,
literal|"margin-bottom"
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|tmpwidget
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/*    *  Copyright    */
name|tmpwidget
operator|=
name|gtk_entry_new
argument_list|()
expr_stmt|;
comment|/* Maximum length will be clamped to 65536 */
name|gtk_entry_set_max_length
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
literal|0
index|]
condition|)
block|{
name|gtk_entry_set_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* show warning if comment is over 65535 characters        * because gtk_entry can hold only that. */
if|if
condition|(
name|strlen
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|65535
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The part of copyright information "
literal|"that exceeded 65535 characters was removed."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_signal_connect
argument_list|(
name|tmpwidget
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|comment_entry_callback
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|comments
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter copyright information."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|_
argument_list|(
literal|"_Copyright:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/*    *  License    */
name|tmpwidget
operator|=
name|gtk_entry_new
argument_list|()
expr_stmt|;
comment|/* Maximum length will be clamped to 65536 */
name|gtk_entry_set_max_length
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
literal|1
index|]
condition|)
block|{
name|gtk_entry_set_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* show warning if comment is over 65535 characters        * because gtk_entry can hold only that. */
if|if
condition|(
name|strlen
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|tmpwidget
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|65535
condition|)
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The part of license information "
literal|"that exceeded 65535 characters was removed."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_signal_connect
argument_list|(
name|tmpwidget
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|comment_entry_callback
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|comments
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter license information."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_grid_attach_aligned
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
name|_
argument_list|(
literal|"_License:"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
name|tmpwidget
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/*    *  Other    */
comment|/* We use gtk_text_view for "Other" while "Copyright"& "License" is entered    * in gtk_entry because We want allow '\n' for "Other". */
name|label
operator|=
name|gtk_label_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Other:"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_label_set_xalign
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/*align top-left*/
name|gtk_label_set_yalign
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/*align top-left*/
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* content of Other */
comment|/* scrolled window */
name|box
operator|=
name|gtk_scrolled_window_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_scrolled_window_set_shadow_type
argument_list|(
name|GTK_SCROLLED_WINDOW
argument_list|(
name|box
argument_list|)
argument_list|,
name|GTK_SHADOW_IN
argument_list|)
expr_stmt|;
name|gtk_scrolled_window_set_policy
argument_list|(
name|GTK_SCROLLED_WINDOW
argument_list|(
name|box
argument_list|)
argument_list|,
name|GTK_POLICY_AUTOMATIC
argument_list|,
name|GTK_POLICY_AUTOMATIC
argument_list|)
expr_stmt|;
name|gtk_grid_attach
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
name|box
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|box
argument_list|)
expr_stmt|;
comment|/* textbuffer */
name|textbuffer
operator|=
name|gtk_text_buffer_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
literal|2
index|]
condition|)
name|gtk_text_buffer_set_text
argument_list|(
name|textbuffer
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
literal|2
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|textbuffer
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|text_view_callback
argument_list|)
argument_list|,
name|xmcparas
operator|.
name|comments
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* textview */
name|tmpwidget
operator|=
name|gtk_text_view_new_with_buffer
argument_list|(
name|GTK_TEXT_BUFFER
argument_list|(
name|textbuffer
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_text_view_set_accepts_tab
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_text_view_set_wrap_mode
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|GTK_WRAP_WORD
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|textbuffer
argument_list|)
expr_stmt|;
name|gtk_text_view_set_wrap_mode
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|tmpwidget
argument_list|)
argument_list|,
name|GTK_WRAP_WORD
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|box
argument_list|)
argument_list|,
name|tmpwidget
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/* tooltip */
name|gimp_help_set_help_data
argument_list|(
name|tmpwidget
argument_list|,
name|_
argument_list|(
literal|"Enter other comment if you want."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_label_set_mnemonic_widget
argument_list|(
name|GTK_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
name|tmpwidget
argument_list|)
expr_stmt|;
comment|/*    *  all widget is prepared. Let's show dialog.    */
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/*  * callback function of gtk_entry for "copyright" and "license".  * "other" is processed by text_view_callback  */
end_comment

begin_function
specifier|static
name|void
DECL|function|comment_entry_callback (GtkWidget * widget,gchar ** commentp)
name|comment_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|text
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|commentp
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This will not happen because sizeof(gtk_entry)< XCURSOR_COMMENT_MAX_LEN */
name|g_return_if_fail
argument_list|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|<=
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
operator|*
name|commentp
argument_list|)
expr_stmt|;
operator|*
name|commentp
operator|=
name|g_strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|text_view_callback (GtkTextBuffer * buffer,gchar ** commentp)
name|text_view_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|,
name|gchar
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
name|GtkTextIter
name|start_iter
decl_stmt|;
name|GtkTextIter
name|end_iter
decl_stmt|;
name|gchar
modifier|*
name|text
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|commentp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_bounds
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_text_buffer_get_text
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|>
name|XCURSOR_COMMENT_MAX_LEN
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Comment is limited to %d characters."
argument_list|)
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_iter_at_offset
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
name|XCURSOR_COMMENT_MAX_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_end_iter
argument_list|(
name|buffer
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
name|gtk_text_buffer_delete
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_free
argument_list|(
operator|*
name|commentp
argument_list|)
expr_stmt|;
operator|*
name|commentp
operator|=
name|g_strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Set default hotspot based on hotspotRange. **/
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|load_default_hotspot (GimpImage * image,GeglRectangle * hotspotRange)
name|load_default_hotspot
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GeglRectangle
modifier|*
name|hotspotRange
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|hotspotRange
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* if we cannot load hotspot correctly */
operator|!
name|get_hotspot_from_parasite
argument_list|(
name|image
argument_list|)
operator|||
comment|/* ,or hostspot is out of range */
operator|!
name|pix_in_region
argument_list|(
name|xmcparas
operator|.
name|x
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|hotspotRange
argument_list|)
condition|)
block|{
comment|/* then use top left point of hotspotRange as fallback. */
name|xmcparas
operator|.
name|x
operator|=
name|hotspotRange
operator|->
name|x
expr_stmt|;
name|xmcparas
operator|.
name|y
operator|=
name|hotspotRange
operator|->
name|y
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * 'save_image ()' - Save the specified image to X cursor file.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|save_image (const gchar * filename,GimpImage * image,GimpDrawable * drawable,GimpImage * orig_image,GError ** error)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GimpImage
modifier|*
name|orig_image
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
name|gboolean
name|dimension_warn
init|=
name|FALSE
decl_stmt|;
comment|/* become TRUE if even one                                             * of the dimensions of the                                             * frames of the cursor is                                             * over                                             * MAX_BITMAP_CURSOR_SIZE */
name|gboolean
name|size_warn
init|=
name|FALSE
decl_stmt|;
comment|/* become TRUE if even one                                             * of the nominal size of                                             * the frames is not                                             * supported by                                             * gnome-appearance-properties */
name|GRegex
modifier|*
name|re
decl_stmt|;
comment|/* used to get size and delay from                                             * framename */
name|XcursorComments
modifier|*
name|commentsp
decl_stmt|;
comment|/* pointer to comments */
name|XcursorImages
modifier|*
name|imagesp
decl_stmt|;
comment|/* pointer to images */
name|GList
modifier|*
name|layers
decl_stmt|;
comment|/* Array of layer */
name|GList
modifier|*
name|orig_layers
decl_stmt|;
comment|/* Array of layer of orig_image */
name|GList
modifier|*
name|list
decl_stmt|;
name|GList
modifier|*
name|orig_list
decl_stmt|;
name|gchar
modifier|*
name|framename
decl_stmt|;
comment|/* framename of a layer */
name|GeglRectangle
name|save_rgn
decl_stmt|;
comment|/* region to save */
name|gint
name|layer_xoffset
decl_stmt|,
name|layer_yoffset
decl_stmt|;
comment|/* temporary buffer which store pixel data (guchar * bpp = guint32) */
name|guint32
name|pixelbuf
index|[
name|SQR
argument_list|(
name|MAX_SAVE_DIMENSION
argument_list|)
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Looping vars */
comment|/* This will be used in set_size_and_delay function later.  To    * define this in that function is easy to read but place here to    * reduce overheads.    */
name|re
operator|=
name|g_regex_new
argument_list|(
literal|"[(][ 0]*(\\d+)[ ]*(px|ms)[ ]*[)]"
argument_list|,
name|G_REGEX_CASELESS
operator||
name|G_REGEX_OPTIMIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Open the file pointer.    */
name|DM_XMC
argument_list|(
literal|"Open the file pointer.\n"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* get layers, in bottom-to-top order */
name|orig_layers
operator|=
name|gimp_image_list_layers
argument_list|(
name|orig_image
argument_list|)
expr_stmt|;
name|layers
operator|=
name|gimp_image_list_layers
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|orig_layers
operator|=
name|g_list_reverse
argument_list|(
name|orig_layers
argument_list|)
expr_stmt|;
name|layers
operator|=
name|g_list_reverse
argument_list|(
name|layers
argument_list|)
expr_stmt|;
comment|/* create new XcursorImages. */
name|imagesp
operator|=
name|XcursorImagesCreate
argument_list|(
name|g_list_length
argument_list|(
name|layers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imagesp
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorImagesCreate!\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|imagesp
operator|->
name|nimage
operator|=
name|g_list_length
argument_list|(
name|layers
argument_list|)
expr_stmt|;
comment|/* XcursorImages also have `name' member but it is not used as long as I know.      We leave it NULL here. */
comment|/*    *  Now we start to convert each layer to a XcurosrImage one by one.    */
for|for
control|(
name|list
operator|=
name|layers
operator|,
name|orig_list
operator|=
name|orig_layers
operator|,
name|i
operator|=
literal|0
init|;
name|list
operator|&&
name|orig_list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|layers
argument_list|)
operator|,
name|orig_list
operator|=
name|g_list_next
argument_list|(
name|orig_list
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|GimpDrawable
modifier|*
name|drawable
init|=
name|list
operator|->
name|data
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|width
operator|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|height
operator|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A u8"
argument_list|)
expr_stmt|;
comment|/* get framename of this layer */
name|framename
operator|=
name|gimp_item_get_name
argument_list|(
name|GIMP_ITEM
argument_list|(
name|drawable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get offset of this layer. */
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|layer_xoffset
argument_list|,
operator|&
name|layer_yoffset
argument_list|)
expr_stmt|;
comment|/*        * layer dimension check.        */
name|DM_XMC
argument_list|(
literal|"layer size check.\n"
argument_list|)
expr_stmt|;
comment|/* We allow to save a cursor which dimensions are no more than        * MAX_SAVE_DIMENSION but after auto-cropping, we warn (only        * warn, don't stop) if dimension is over        * MAX_BITMAP_CURSOR_SIZE.        */
if|if
condition|(
name|width
operator|>
name|MAX_SAVE_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Frame '%s' is too wide. Please reduce to no more than %dpx."
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|MAX_SAVE_DIMENSION
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|height
operator|>
name|MAX_SAVE_DIMENSION
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Frame '%s' is too high. Please reduce to no more than %dpx."
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|MAX_SAVE_DIMENSION
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|height
operator|==
literal|0
operator|||
name|width
operator|==
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Width and/or height of frame '%s' is zero!"
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|xmcvals
operator|.
name|crop
condition|)
comment|/* with auto-cropping */
block|{
comment|/* get the region of auto-cropped area. */
name|DM_XMC
argument_list|(
literal|"get_cropped_region\n"
argument_list|)
expr_stmt|;
name|get_cropped_region
argument_list|(
operator|&
name|save_rgn
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* don't forget save_rgn's origin is not a entire image            * but a layer which we are doing on.           */
if|if
condition|(
name|save_rgn
operator|.
name|width
operator|==
literal|0
operator|||
name|save_rgn
operator|.
name|height
operator|==
literal|0
condition|)
block|{
comment|/* perfectly transparent frames become 1x1px transparent pixel. */
name|DM_XMC
argument_list|(
literal|"get_cropped_region return 0.\n"
argument_list|)
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|=
name|XcursorImageCreate
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imagesp
operator|->
name|images
index|[
name|i
index|]
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorImageCreate.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
operator|=
literal|0
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
operator|=
literal|0
expr_stmt|;
name|set_size_and_delay
argument_list|(
name|framename
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
operator|)
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
operator|)
argument_list|,
name|re
argument_list|,
operator|&
name|size_warn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* OK save_rgn is not 0x0 */
comment|/* is hotspot in save_rgn ? */
if|if
condition|(
operator|!
name|pix_in_region
argument_list|(
name|xmcparas
operator|.
name|x
operator|-
name|layer_xoffset
argument_list|,
name|xmcparas
operator|.
name|y
operator|-
name|layer_yoffset
argument_list|,
operator|&
name|save_rgn
argument_list|)
condition|)
block|{
comment|/* if hotspot is not on save_rgn */
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Cannot export the cursor because the hot spot "
literal|"is not on frame '%s'.\n"
literal|"Try to change the hot spot position, "
literal|"layer geometry or export without auto-crop."
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|framename
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
comment|/* if without auto-cropping... */
block|{
comment|/* set save_rgn for the case not to auto-crop */
name|save_rgn
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|save_rgn
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|save_rgn
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|save_rgn
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We warn if the dimension of the layer is over MAX_BITMAP_CURSOR_SIZE. */
if|if
condition|(
operator|!
name|dimension_warn
condition|)
block|{
if|if
condition|(
name|save_rgn
operator|.
name|width
operator|>
name|MAX_BITMAP_CURSOR_SIZE
operator|||
name|save_rgn
operator|.
name|height
operator|>
name|MAX_BITMAP_CURSOR_SIZE
condition|)
block|{
name|dimension_warn
operator|=
name|TRUE
expr_stmt|;
comment|/* actual warning is done after the cursor is successfully saved.*/
block|}
block|}
comment|/*        * Create new XcursorImage.        */
name|DM_XMC
argument_list|(
literal|"create new xcursorimage.\twidth=%i\theight=%i\n"
argument_list|,
name|save_rgn
operator|.
name|width
argument_list|,
name|save_rgn
operator|.
name|height
argument_list|)
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|=
name|XcursorImageCreate
argument_list|(
name|save_rgn
operator|.
name|width
argument_list|,
name|save_rgn
operator|.
name|height
argument_list|)
expr_stmt|;
comment|/* Cursor width& height is automatically set by function */
comment|/* XcursorImageCreate, so no need to set manually. */
if|if
condition|(
operator|!
name|imagesp
operator|->
name|images
index|[
name|i
index|]
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorImageCreate.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*        ** set images[i]'s xhot& yhot.        */
comment|/* [Cropped layer's hotspot] =                    [image's hotspot] - [layer's offset] - [save_rgn's offset]. */
name|DM_XMC
argument_list|(
literal|"xhot=%i\tsave_rgn->xoffset=%i\tlayer_xoffset=%i\n"
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|layer_xoffset
argument_list|,
name|save_rgn
operator|.
name|x
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"yhot=%i\tsave_rgn->yoffset=%i\tlayer_yoffset=%i\n"
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|,
name|layer_yoffset
argument_list|,
name|save_rgn
operator|.
name|y
argument_list|)
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
operator|=
name|xmcparas
operator|.
name|x
operator|-
name|layer_xoffset
operator|-
name|save_rgn
operator|.
name|x
expr_stmt|;
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
operator|=
name|xmcparas
operator|.
name|y
operator|-
name|layer_yoffset
operator|-
name|save_rgn
operator|.
name|y
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"images[%i]->xhot=%i\tyhot=%i\n"
argument_list|,
name|i
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|)
expr_stmt|;
comment|/*        * set images[i]->pixels        */
comment|/* get image data to pixelbuf. */
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|save_rgn
operator|.
name|x
argument_list|,
name|save_rgn
operator|.
name|y
argument_list|,
name|save_rgn
operator|.
name|width
argument_list|,
name|save_rgn
operator|.
name|height
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|pixelbuf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
comment|/*convert pixel date to XcursorPixel. */
name|g_assert
argument_list|(
name|save_rgn
operator|.
name|width
operator|*
name|save_rgn
operator|.
name|height
operator|<
name|SQR
argument_list|(
name|MAX_SAVE_DIMENSION
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|save_rgn
operator|.
name|width
operator|*
name|save_rgn
operator|.
name|height
condition|;
name|j
operator|++
control|)
block|{
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
index|[
name|j
index|]
operator|=
name|premultiply_alpha
argument_list|(
name|pixelbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*        * get back size& delay from framename.        */
name|set_size_and_delay
argument_list|(
name|framename
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
operator|)
argument_list|,
operator|&
operator|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
operator|)
argument_list|,
name|re
argument_list|,
operator|&
name|size_warn
argument_list|)
expr_stmt|;
comment|/*        * All property of this XcursorImage is loaded.        */
comment|/* set the layer name of original image with the saved value */
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|framename
operator|=
name|make_framename
argument_list|(
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
argument_list|,
name|DISPLAY_DIGIT
argument_list|(
name|imagesp
operator|->
name|nimage
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|framename
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gimp_item_set_name
argument_list|(
name|orig_list
operator|->
name|data
argument_list|,
name|framename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
name|imagesp
operator|->
name|nimage
argument_list|)
expr_stmt|;
block|}
name|g_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|g_list_free
argument_list|(
name|orig_list
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
comment|/*    * comment parsing    */
name|commentsp
operator|=
name|set_cursor_comments
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XMC_DEBUG
name|DM_XMC
argument_list|(
literal|"imagesp->nimage=%i\tname=%s\n"
argument_list|,
name|imagesp
operator|->
name|nimage
argument_list|,
name|imagesp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|imagesp
operator|->
name|nimage
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"\timages[%i]->size=%i\n\                \twidth=%i\n\                \theight=%i\n\                \txhot=%i\n\                \tyhot=%i\n\                \tdelay=%i\n\                \t*pixels=%p\n"
argument_list|,
name|i
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|delay
argument_list|,
name|imagesp
operator|->
name|images
index|[
name|i
index|]
operator|->
name|pixels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commentsp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commentsp
operator|->
name|ncomment
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"comment type=%d\tcomment=%s\n"
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment_type
argument_list|,
name|commentsp
operator|->
name|comments
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*    *  save cursor to file *fp.    */
if|if
condition|(
name|commentsp
condition|)
block|{
if|if
condition|(
operator|!
name|XcursorFileSave
argument_list|(
name|fp
argument_list|,
name|commentsp
argument_list|,
name|imagesp
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorFileSave.\t%p\t%p\t%p\n"
argument_list|,
name|fp
argument_list|,
name|commentsp
argument_list|,
name|imagesp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
comment|/* if no comments exist */
block|{
if|if
condition|(
operator|!
name|XcursorFileSaveImages
argument_list|(
name|fp
argument_list|,
name|imagesp
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to XcursorFileSaveImages.\t%p\t%p\n"
argument_list|,
name|fp
argument_list|,
name|imagesp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* actual warning about dimensions */
if|if
condition|(
name|dimension_warn
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Your cursor was successfully exported but it contains one or "
literal|"more frames whose width or height is more than %ipx, "
literal|"a historical max dimension value for X bitmap cursors.\n"
literal|"It might be unsupported by some environments."
argument_list|)
argument_list|,
name|MAX_BITMAP_CURSOR_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_warn
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Your cursor was successfully exported but it contains one "
literal|"or more frames whose nominal size is not supported by "
literal|"GNOME settings.\n"
literal|"You can satisfy it by checking \"Replace the size of all "
literal|"frames...\" in the export dialog, or your cursor may not "
literal|"appear in GNOME settings."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * Done with the file...    */
name|g_regex_unref
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"fp=%p\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"%i frames written.\n"
argument_list|,
name|imagesp
operator|->
name|nimage
argument_list|)
expr_stmt|;
name|XcursorImagesDestroy
argument_list|(
name|imagesp
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"Xcursor destroyed.\n"
argument_list|)
expr_stmt|;
name|XcursorCommentsDestroy
argument_list|(
name|commentsp
argument_list|)
expr_stmt|;
comment|/* this is safe even if commentsp is NULL. */
name|gimp_progress_end
argument_list|()
expr_stmt|;
comment|/* Save the comment back to the original image */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|gimp_image_detach_parasite
argument_list|(
name|orig_image
argument_list|,
name|parasiteName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|set_comment_to_pname
argument_list|(
name|orig_image
argument_list|,
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|,
name|parasiteName
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|DM_XMC
argument_list|(
literal|"Failed to write back %ith comment to orig_image.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Save hotspot back to the original image */
name|set_hotspot_to_parasite
argument_list|(
name|orig_image
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|guint32
DECL|function|separate_alpha (guint32 pixel)
name|separate_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
block|{
name|guint
name|alpha
decl_stmt|,
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|guint32
name|retval
decl_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_TO_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blue
operator|=
name|pixel
operator|&
literal|0xff
expr_stmt|;
name|green
operator|=
operator|(
name|pixel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|red
operator|=
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|alpha
operator|=
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|alpha
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* resume separate alpha data. */
name|red
operator|=
name|MIN
argument_list|(
name|red
operator|*
literal|255
operator|/
name|alpha
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|blue
operator|=
name|MIN
argument_list|(
name|blue
operator|*
literal|255
operator|/
name|alpha
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|green
operator|=
name|MIN
argument_list|(
name|green
operator|*
literal|255
operator|/
name|alpha
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|retval
operator|=
name|red
operator|+
operator|(
name|green
operator|<<
literal|8
operator|)
operator|+
operator|(
name|blue
operator|<<
literal|16
operator|)
operator|+
operator|(
name|alpha
operator|<<
literal|24
operator|)
expr_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_FROM_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|guint32
DECL|function|premultiply_alpha (guint32 pixel)
name|premultiply_alpha
parameter_list|(
name|guint32
name|pixel
parameter_list|)
block|{
name|guint
name|alpha
decl_stmt|,
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|guint32
name|retval
decl_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_TO_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|red
operator|=
name|pixel
operator|&
literal|0xff
expr_stmt|;
name|green
operator|=
operator|(
name|pixel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|blue
operator|=
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|alpha
operator|=
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* premultiply alpha      (see "premultiply_data" function at line 154 of xcursorgen.c) */
name|red
operator|=
name|div_255
argument_list|(
name|red
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|green
operator|=
name|div_255
argument_list|(
name|green
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|blue
operator|=
name|div_255
argument_list|(
name|blue
operator|*
name|alpha
argument_list|)
expr_stmt|;
name|retval
operator|=
name|blue
operator|+
operator|(
name|green
operator|<<
literal|8
operator|)
operator|+
operator|(
name|red
operator|<<
literal|16
operator|)
operator|+
operator|(
name|alpha
operator|<<
literal|24
operator|)
expr_stmt|;
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pixel
operator|=
name|GUINT32_FROM_LE
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* set comments to cursor from xmcparas.comments.  * don't forget to XcursorCommentsDestroy returned pointer later.  */
end_comment

begin_function
specifier|static
name|XcursorComments
modifier|*
DECL|function|set_cursor_comments (void)
name|set_cursor_comments
parameter_list|(
name|void
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|guint
name|gcomlen
decl_stmt|,
name|arraylen
decl_stmt|;
name|GArray
modifier|*
name|xcCommentsArray
decl_stmt|;
name|XcursorComment
argument_list|*
operator|(
name|xcCommentp
index|[
literal|3
index|]
operator|)
operator|=
block|{
name|NULL
block|,}
argument_list|;
name|XcursorComments
operator|*
name|xcCommentsp
argument_list|;
name|xcCommentsArray
operator|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|,
sizeof|sizeof
argument_list|(
name|XcursorComment
operator|*
argument_list|)
argument_list|)
argument_list|;    for
operator|(
name|i
operator|=
literal|0
expr|;
name|i
operator|<
literal|3
expr|;
operator|++
name|i
operator|)
block|{
if|if
condition|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
condition|)
block|{
name|gcomlen
operator|=
name|strlen
argument_list|(
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcomlen
operator|>
literal|0
condition|)
block|{
name|xcCommentp
index|[
name|i
index|]
operator|=
name|XcursorCommentCreate
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|gcomlen
argument_list|)
expr_stmt|;
comment|/* first argument of XcursorCommentCreate is comment_type                  defined in Xcursor.h as enumerator.                  i + 1 is appropriate when we dispose parasiteName before MAIN(). */
if|if
condition|(
operator|!
name|xcCommentp
index|[
name|i
index|]
condition|)
block|{
name|g_warning
argument_list|(
literal|"Cannot create xcCommentp[%i]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|g_stpcpy
argument_list|(
name|xcCommentp
index|[
name|i
index|]
operator|->
name|comment
argument_list|,
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_array_append_val
argument_list|(
name|xcCommentsArray
argument_list|,
name|xcCommentp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
unit|}     }
name|arraylen
operator|=
name|xcCommentsArray
operator|->
name|len
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|arraylen
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
end_if

begin_expr_stmt
name|xcCommentsp
operator|=
name|XcursorCommentsCreate
argument_list|(
name|arraylen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xcCommentsp
operator|->
name|ncomment
operator|=
name|arraylen
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arraylen
condition|;
operator|++
name|i
control|)
block|{
name|xcCommentsp
operator|->
name|comments
index|[
name|i
index|]
operator|=
name|g_array_index
argument_list|(
name|xcCommentsArray
argument_list|,
name|XcursorComment
operator|*
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|xcCommentsp
return|;
end_return

begin_comment
unit|}
comment|/* Load xmcparas.comments from three parasites named as "xmc-copyright",  * "xmc-license","gimp-comment".  * This alignment sequence is depends on the definition of comment_type  * in Xcursor.h .  * Don't forget to g_free each element of xmcparas.comments later.  */
end_comment

begin_function
unit|static
name|void
DECL|function|load_comments (GimpImage * image)
name|load_comments
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|xmcparas
operator|.
name|comments
index|[
name|i
index|]
operator|=
name|get_comment_from_pname
argument_list|(
name|image
argument_list|,
name|parasiteName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set content to a parasite named as pname. if parasite already  * exists, append the new one to the old one with "\n"  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|set_comment_to_pname (GimpImage * image,const gchar * content,const gchar * pname)
name|set_comment_to_pname
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|content
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
block|{
name|gboolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|gchar
modifier|*
name|tmpstring
decl_stmt|,
modifier|*
name|joind
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|content
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|image
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parasite
condition|)
block|{
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|pname
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|content
argument_list|)
operator|+
literal|1
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpstring
operator|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|joind
operator|=
name|g_strjoin
argument_list|(
literal|"\n"
argument_list|,
name|tmpstring
argument_list|,
name|content
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpstring
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|pname
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|joind
argument_list|)
operator|+
literal|1
argument_list|,
name|joind
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|joind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parasite
condition|)
block|{
name|ret
operator|=
name|gimp_image_attach_parasite
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* get back comment from parasite name, don't forget to call  * g_free(returned pointer) later  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|get_comment_from_pname (GimpImage * image,const gchar * pname)
name|get_comment_from_pname
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
specifier|const
name|gchar
modifier|*
name|pname
parameter_list|)
block|{
name|gchar
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|glong
name|length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|image
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|length
operator|=
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
if|if
condition|(
name|length
operator|>
name|XCURSOR_COMMENT_MAX_LEN
condition|)
block|{
name|length
operator|=
name|XCURSOR_COMMENT_MAX_LEN
expr_stmt|;
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The parasite \"%s\" is too long for an X cursor "
literal|"comment. It was cut off to fit."
argument_list|)
argument_list|,
name|gimp_any_to_utf8
argument_list|(
name|pname
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Set hotspot to "hot-spot" parasite which format is common with that  * of file-xbm.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|set_hotspot_to_parasite (GimpImage * image)
name|set_hotspot_to_parasite
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|gboolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|gchar
modifier|*
name|tmpstr
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|g_strdup_printf
argument_list|(
literal|"%d %d"
argument_list|,
name|xmcparas
operator|.
name|x
argument_list|,
name|xmcparas
operator|.
name|y
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"hot-spot"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|+
literal|1
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|ret
operator|=
name|gimp_image_attach_parasite
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get back xhot& yhot from "hot-spot" parasite.  * If succeed, hotspot coordinate is set to xmcparas.x, xmcparas.y and  * return TRUE.  * If "hot-spot" is not found or broken, return FALSE.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|get_hotspot_from_parasite (GimpImage * image)
name|get_hotspot_from_parasite
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"function: getHotsopt\n"
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_image_get_parasite
argument_list|(
name|image
argument_list|,
literal|"hot-spot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parasite
condition|)
comment|/* cannot find a parasite named "hot-spot". */
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
literal|"%i %i"
argument_list|,
operator|&
name|xmcparas
operator|.
name|x
argument_list|,
operator|&
name|xmcparas
operator|.
name|y
argument_list|)
operator|<
literal|2
condition|)
block|{
comment|/*cannot load hotspot.(parasite is broken?) */
return|return
name|FALSE
return|;
block|}
comment|/*OK, hotspot is set to *xhotp& *yhotp. */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set size to sizep, delay to delayp from drawable's framename.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|set_size_and_delay (const gchar * framename,guint32 * sizep,guint32 * delayp,GRegex * re,gboolean * size_warnp)
name|set_size_and_delay
parameter_list|(
specifier|const
name|gchar
modifier|*
name|framename
parameter_list|,
name|guint32
modifier|*
name|sizep
parameter_list|,
name|guint32
modifier|*
name|delayp
parameter_list|,
name|GRegex
modifier|*
name|re
parameter_list|,
name|gboolean
modifier|*
name|size_warnp
parameter_list|)
block|{
name|guint32
name|size
init|=
literal|0
decl_stmt|;
name|guint32
name|delay
init|=
literal|0
decl_stmt|;
name|gchar
modifier|*
name|digits
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
name|GMatchInfo
modifier|*
name|info
init|=
name|NULL
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|sizep
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|delayp
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"function: set_size_and_delay\tframename=%s\n"
argument_list|,
name|framename
argument_list|)
expr_stmt|;
comment|/* re is defined at the start of save_image() as         [(]                : open parenthesis         [ ]*               : ignore zero or more spaces         (\\d+)             : the number we want to get out         [ ]*               : ignore zero or more spaces         (px|ms)            : whether "px"(size) or "ms"(delay)         [ ]*               : ignore zero or more spaces         [)]                : close parenthesis      This is intended to match for the animation-play plug-in. */
name|g_regex_match
argument_list|(
name|re
argument_list|,
name|framename
argument_list|,
literal|0
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
while|while
condition|(
name|g_match_info_matches
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|digits
operator|=
name|g_match_info_fetch
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|g_match_info_fetch
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_ascii_strcasecmp
argument_list|(
name|suffix
argument_list|,
literal|"px"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
comment|/* substitute it only for the first time */
block|{
if|if
condition|(
name|strlen
argument_list|(
name|digits
argument_list|)
operator|>
literal|8
condition|)
comment|/* too large number should be clamped */
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Your cursor was successfully exported but it contains one or "
literal|"more frames whose size is over 8 digits.\n"
literal|"We clamped it to %dpx. You should check the exported cursor."
argument_list|)
argument_list|,
name|MAX_BITMAP_CURSOR_SIZE
argument_list|)
expr_stmt|;
name|size
operator|=
name|MAX_BITMAP_CURSOR_SIZE
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|atoi
argument_list|(
name|digits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* suffix is "ms" */
block|{
if|if
condition|(
operator|!
name|delay
condition|)
comment|/* substitute it only for the first time */
block|{
if|if
condition|(
name|strlen
argument_list|(
name|digits
argument_list|)
operator|>
literal|8
condition|)
comment|/* too large number should be clamped */
name|delay
operator|=
name|CURSOR_MAX_DELAY
expr_stmt|;
else|else
name|delay
operator|=
name|MIN
argument_list|(
name|CURSOR_MAX_DELAY
argument_list|,
name|atoi
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|g_match_info_next
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|g_match_info_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* if size is not set, or size_replace is TRUE, set default size    * (which was chosen in save dialog) */
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|xmcvals
operator|.
name|size_replace
operator|==
name|TRUE
condition|)
block|{
name|size
operator|=
name|xmcvals
operator|.
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|size_warnp
operator|&&
name|size
operator|!=
literal|12
operator|&&
name|size
operator|!=
literal|16
operator|&&
name|size
operator|!=
literal|24
operator|&&
name|size
operator|!=
literal|32
operator|&&
name|size
operator|!=
literal|36
operator|&&
name|size
operator|!=
literal|40
operator|&&
name|size
operator|!=
literal|48
operator|&&
name|size
operator|!=
literal|64
operator|&&
name|size
operator|!=
literal|96
condition|)
block|{
comment|/* if the size is different from these values, we warn about it after          successfully saving because gnome-appearance-properties only support          them. */
operator|*
name|size_warnp
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
comment|/* if delay is not set, or delay_replace is TRUE, set default delay    * (which was chosen in save dialog) */
if|if
condition|(
name|delay
operator|==
literal|0
operator|||
name|xmcvals
operator|.
name|delay_replace
operator|==
name|TRUE
condition|)
block|{
name|delay
operator|=
name|xmcvals
operator|.
name|delay
expr_stmt|;
block|}
operator|*
name|delayp
operator|=
name|delay
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"set_size_and_delay return\tsize=%i\tdelay=%i\n"
argument_list|,
name|size
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return framename as format: "([x]px)_[i] ([t]ms) (replace)"  * where [x] is nominal size, [t] is delay passed as argument respectively,  * and [i] is an index separately counted by [x].  * This format is compatible with "animation-play" plug-in.  * Don't forget to g_free returned framename later.  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|make_framename (guint32 size,guint32 delay,guint indent,GError ** errorp)
name|make_framename
parameter_list|(
name|guint32
name|size
parameter_list|,
name|guint32
name|delay
parameter_list|,
name|guint
name|indent
parameter_list|,
name|GError
modifier|*
modifier|*
name|errorp
parameter_list|)
block|{
specifier|static
struct|struct
DECL|struct|__anon2bc260f00308
block|{
DECL|member|size
name|guint32
name|size
decl_stmt|;
DECL|member|count
name|guint
name|count
decl_stmt|;
block|}
name|Counter
index|[
name|MAX_SIZE_NUM
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|0
block|,}
block|}
struct|;
name|int
name|i
decl_stmt|;
comment|/* loop index */
comment|/* don't pass 0 for size. */
name|g_return_val_if_fail
argument_list|(
name|size
operator|>
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "count" member of Counter's element means how many time corresponding      "size" is passed to this function. The size member of the last element      of Counter must be 0, so Counter can have MAX_SIZE_NUM elements at most.      This is not a smart way but rather simple than using dynamic method. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Counter
index|[
name|i
index|]
operator|.
name|size
operator|!=
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Counter
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
comment|/* the end of Counter elements */
block|{
if|if
condition|(
name|i
operator|>
name|MAX_SIZE_NUM
condition|)
block|{
name|g_set_error
argument_list|(
name|errorp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* translators: the %i is *always* 8 here */
name|_
argument_list|(
literal|"Sorry, this plug-in cannot handle a cursor "
literal|"which contains over %i different nominal sizes."
argument_list|)
argument_list|,
name|MAX_SIZE_NUM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
comment|/* append new element which "size" is given value. */
block|{
name|Counter
index|[
name|i
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
break|break;
block|}
block|}
block|}
name|Counter
index|[
name|i
index|]
operator|.
name|count
operator|+=
literal|1
expr_stmt|;
return|return
name|g_strdup_printf
argument_list|(
literal|"(%dpx)_%0*d (%dms) (replace)"
argument_list|,
name|size
argument_list|,
name|indent
argument_list|,
name|Counter
index|[
name|i
index|]
operator|.
name|count
argument_list|,
name|delay
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the region which is maintained when auto-crop.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|get_cropped_region (GeglRectangle * return_rgn,GeglBuffer * buffer)
name|get_cropped_region
parameter_list|(
name|GeglRectangle
modifier|*
name|return_rgn
parameter_list|,
name|GeglBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|gint
name|width
init|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|gint
name|height
init|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|guint32
modifier|*
name|buf
init|=
name|g_malloc
argument_list|(
name|MAX
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|guint32
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
init|=
name|babl_format
argument_list|(
literal|"R'G'B'A u8"
argument_list|)
decl_stmt|;
name|guint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|GEGL_IS_BUFFER
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"function:get_cropped_region\n"
argument_list|)
expr_stmt|;
name|DM_XMC
argument_list|(
literal|"getTrim:\tMAX=%i\tpr->w=%i\tpr->h=%i\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
literal|4
argument_list|,
name|pr
operator|->
name|w
argument_list|,
name|pr
operator|->
name|h
argument_list|)
expr_stmt|;
comment|/* find left border. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"i=%i  width=%i\n"
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|height
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|j
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|x
operator|=
name|i
expr_stmt|;
goto|goto
name|find_right
goto|;
block|}
block|}
block|}
comment|/* pr has no opaque pixel. */
name|return_rgn
operator|->
name|width
operator|=
literal|0
expr_stmt|;
return|return;
comment|/* find right border. */
name|find_right
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
block|{
name|DM_XMC
argument_list|(
literal|"width-1-i=%i  height=%i\n"
argument_list|,
name|width
operator|-
literal|1
operator|-
name|i
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|width
operator|-
literal|1
operator|-
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|height
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|j
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|width
operator|=
name|width
operator|-
name|i
operator|-
name|return_rgn
operator|->
name|x
expr_stmt|;
goto|goto
name|find_top
goto|;
block|}
block|}
block|}
name|g_return_if_reached
argument_list|()
expr_stmt|;
comment|/* find top border. */
name|find_top
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
name|DM_XMC
argument_list|(
literal|"j=%i  width=%i\n"
argument_list|,
name|j
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|j
argument_list|,
name|width
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|y
operator|=
name|j
expr_stmt|;
goto|goto
name|find_bottom
goto|;
block|}
block|}
block|}
name|g_return_if_reached
argument_list|()
expr_stmt|;
comment|/* find bottom border. */
name|find_bottom
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
operator|++
name|j
control|)
block|{
name|DM_XMC
argument_list|(
literal|"height-1-j=%i  width=%i\n"
argument_list|,
name|height
operator|-
literal|1
operator|-
name|j
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|height
operator|-
literal|1
operator|-
name|j
argument_list|,
name|width
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pix_is_opaque
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* if a opaque pixel exist. */
block|{
name|return_rgn
operator|->
name|height
operator|=
name|height
operator|-
name|j
operator|-
name|return_rgn
operator|->
name|y
expr_stmt|;
goto|goto
name|end_trim
goto|;
block|}
block|}
block|}
name|g_return_if_reached
argument_list|()
expr_stmt|;
name|end_trim
label|:
name|DM_XMC
argument_list|(
literal|"width=%i\theight=%i\txoffset=%i\tyoffset=%i\n"
argument_list|,
name|return_rgn
operator|->
name|width
argument_list|,
name|return_rgn
operator|->
name|height
argument_list|,
name|return_rgn
operator|->
name|x
argument_list|,
name|return_rgn
operator|->
name|y
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if alpha of pix is not 0.  */
end_comment

begin_function
specifier|static
specifier|inline
name|gboolean
DECL|function|pix_is_opaque (guint32 pix)
name|pix_is_opaque
parameter_list|(
name|guint32
name|pix
parameter_list|)
block|{
if|#
directive|if
name|G_BYTE_ORDER
operator|!=
name|G_LITTLE_ENDIAN
name|pix
operator|=
name|GUINT32_TO_LE
argument_list|(
name|pix
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|pix
operator|>>
literal|24
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the intersection of the all layers of the image specified by image.  * if the intersection is empty return NULL.  * don't forget to g_free returned pointer later.  */
end_comment

begin_function
specifier|static
name|GeglRectangle
modifier|*
DECL|function|get_intersection_of_frames (GimpImage * image)
name|get_intersection_of_frames
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|)
block|{
name|GeglRectangle
modifier|*
name|iregion
decl_stmt|;
name|gint32
name|x1
init|=
name|G_MININT32
decl_stmt|,
name|x2
init|=
name|G_MAXINT32
decl_stmt|;
name|gint32
name|y1
init|=
name|G_MININT32
decl_stmt|,
name|y2
init|=
name|G_MAXINT32
decl_stmt|;
name|gint32
name|x_off
decl_stmt|,
name|y_off
decl_stmt|;
name|GList
modifier|*
name|layers
decl_stmt|;
name|GList
modifier|*
name|list
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|GIMP_IS_IMAGE
argument_list|(
name|image
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|layers
operator|=
name|gimp_image_list_layers
argument_list|(
name|image
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|layers
init|;
name|list
condition|;
name|list
operator|=
name|g_list_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|GimpDrawable
modifier|*
name|drawable
init|=
name|list
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|gimp_drawable_offsets
argument_list|(
name|drawable
argument_list|,
operator|&
name|x_off
argument_list|,
operator|&
name|y_off
argument_list|)
condition|)
block|{
name|g_list_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|x1
operator|=
name|MAX
argument_list|(
name|x1
argument_list|,
name|x_off
argument_list|)
expr_stmt|;
name|y1
operator|=
name|MAX
argument_list|(
name|y1
argument_list|,
name|y_off
argument_list|)
expr_stmt|;
name|x2
operator|=
name|MIN
argument_list|(
name|x2
argument_list|,
name|x_off
operator|+
name|gimp_drawable_width
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y2
operator|=
name|MIN
argument_list|(
name|y2
argument_list|,
name|y_off
operator|+
name|gimp_drawable_height
argument_list|(
name|drawable
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|g_list_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|x2
operator|||
name|y1
operator|>
name|y2
condition|)
return|return
name|NULL
return|;
comment|/* OK intersection exists. */
name|iregion
operator|=
name|g_new
argument_list|(
name|GeglRectangle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iregion
operator|->
name|x
operator|=
name|x1
expr_stmt|;
name|iregion
operator|->
name|y
operator|=
name|y1
expr_stmt|;
name|iregion
operator|->
name|width
operator|=
name|x2
operator|-
name|x1
operator|+
literal|1
expr_stmt|;
name|iregion
operator|->
name|height
operator|=
name|y2
operator|-
name|y1
operator|+
literal|1
expr_stmt|;
return|return
name|iregion
return|;
block|}
end_function

begin_comment
comment|/* If (x,y) is in xmcrp, return TRUE.  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|pix_in_region (gint32 x,gint32 y,GeglRectangle * xmcrp)
name|pix_in_region
parameter_list|(
name|gint32
name|x
parameter_list|,
name|gint32
name|y
parameter_list|,
name|GeglRectangle
modifier|*
name|xmcrp
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|xmcrp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|xmcrp
operator|->
name|x
operator|||
name|y
operator|<
name|xmcrp
operator|->
name|y
operator|||
name|x
operator|>=
name|xmcrp
operator|->
name|x
operator|+
name|xmcrp
operator|->
name|width
operator|||
name|y
operator|>=
name|xmcrp
operator|->
name|y
operator|+
name|xmcrp
operator|->
name|height
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * Find out xhot, yhot, width and height of the Xcursor specified by xcIs.  * Use NULL for the value you don't want to return. **/
end_comment

begin_function
specifier|static
name|void
DECL|function|find_hotspots_and_dimensions (XcursorImages * xcIs,gint32 * xhotp,gint32 * yhotp,gint32 * widthp,gint32 * heightp)
name|find_hotspots_and_dimensions
parameter_list|(
name|XcursorImages
modifier|*
name|xcIs
parameter_list|,
name|gint32
modifier|*
name|xhotp
parameter_list|,
name|gint32
modifier|*
name|yhotp
parameter_list|,
name|gint32
modifier|*
name|widthp
parameter_list|,
name|gint32
modifier|*
name|heightp
parameter_list|)
block|{
name|gint32
name|dw
decl_stmt|,
name|dh
decl_stmt|;
comment|/* the distance between hotspot and right(bottom) border */
name|gint32
name|max_xhot
decl_stmt|;
name|gint32
name|max_yhot
decl_stmt|;
comment|/* the maximum value of xhot(yhot) */
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xcIs
argument_list|)
expr_stmt|;
name|max_xhot
operator|=
name|max_yhot
operator|=
name|dw
operator|=
name|dh
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcIs
operator|->
name|nimage
condition|;
operator|++
name|i
control|)
block|{
comment|/* xhot of entire image is the maximum value of xhot of all frames */
name|max_xhot
operator|=
name|MAX
argument_list|(
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|,
name|max_xhot
argument_list|)
expr_stmt|;
comment|/* same for yhot */
name|max_yhot
operator|=
name|MAX
argument_list|(
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|,
name|max_yhot
argument_list|)
expr_stmt|;
comment|/* the maximum distance between right border and xhot */
name|dw
operator|=
name|MAX
argument_list|(
name|dw
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|width
operator|-
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|xhot
argument_list|)
expr_stmt|;
comment|/* the maximum distance between bottom border and yhot */
name|dh
operator|=
name|MAX
argument_list|(
name|dh
argument_list|,
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|height
operator|-
name|xcIs
operator|->
name|images
index|[
name|i
index|]
operator|->
name|yhot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xhotp
condition|)
operator|*
name|xhotp
operator|=
name|max_xhot
expr_stmt|;
if|if
condition|(
name|yhotp
condition|)
operator|*
name|yhotp
operator|=
name|max_yhot
expr_stmt|;
if|if
condition|(
name|widthp
condition|)
operator|*
name|widthp
operator|=
name|dw
operator|+
name|max_xhot
expr_stmt|;
if|if
condition|(
name|heightp
condition|)
operator|*
name|heightp
operator|=
name|dh
operator|+
name|max_yhot
expr_stmt|;
block|}
end_function

end_unit

