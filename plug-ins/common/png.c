begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Portable Network Graphics (PNG) plug-in for The GIMP -- an image  *   manipulation program  *  *   Copyright 1997-1998 Michael Sweet (mike@easysw.com) and  *   Daniel Skarda (0rfelyus@atrey.karlin.mff.cuni.cz).  *   and 1999-2000 Nick Lamb (njl195@zepler.org.uk)  *  *   This program is free software; you can redistribute it and/or modify  *   it under the terms of the GNU General Public License as published by  *   the Free Software Foundation; either version 2 of the License, or  *   (at your option) any later version.  *  *   This program is distributed in the hope that it will be useful,  *   but WITHOUT ANY WARRANTY; without even the implied warranty of  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *   GNU General Public License for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   main()                      - Main entry - just call gimp_main()...  *   query()                     - Respond to a plug-in query...  *   run()                       - Run the plug-in...  *   load_image()                - Load a PNG image into a new image window.  *   respin_cmap()               - Re-order a Gimp colormap for PNG tRNS  *   save_image()                - Save the specified image to a PNG file.  *   save_ok_callback()          - Destroy the save dialog and save the image.  *   save_compression_callback() - Update the image compression level.  *   save_interlace_update()     - Update the interlacing option.  *   save_dialog()               - Pop up the save dialog.  *  * Revision History:  *  *   see ChangeLog  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|<png.h>
end_include

begin_comment
comment|/* PNG library definitions */
end_comment

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*  * Constants...  */
end_comment

begin_define
DECL|macro|PLUG_IN_VERSION
define|#
directive|define
name|PLUG_IN_VERSION
value|"1.3.4 - 03 September 2002"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|DEFAULT_GAMMA
define|#
directive|define
name|DEFAULT_GAMMA
value|2.20
end_define

begin_comment
comment|/*  * Structures...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon29691d5b0108
block|{
DECL|member|interlaced
name|gint
name|interlaced
decl_stmt|;
DECL|member|compression_level
name|gint
name|compression_level
decl_stmt|;
DECL|member|bkgd
name|gint
name|bkgd
decl_stmt|;
DECL|member|gama
name|gint
name|gama
decl_stmt|;
DECL|member|offs
name|gint
name|offs
decl_stmt|;
DECL|member|phys
name|gint
name|phys
decl_stmt|;
DECL|member|time
name|gint
name|time
decl_stmt|;
block|}
DECL|typedef|PngSaveVals
name|PngSaveVals
typedef|;
end_typedef

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|respin_cmap
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|guchar
modifier|*
name|remap
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_unused_ia_colour
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
name|numpixels
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Globals...  */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pngvals
name|PngSaveVals
name|pngvals
init|=
block|{
name|FALSE
block|,
literal|6
block|,
name|TRUE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|TRUE
block|,
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|runme
specifier|static
name|gboolean
name|runme
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'main()' - Main entry - just call gimp_main()...  */
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_comment
comment|/* Try to find a colour in the palette which isn't actually   * used in the image, so that we can use it as the transparency   * index. Taken from gif.c */
end_comment

begin_function
specifier|static
name|int
name|find_unused_ia_colour
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
name|numpixels
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gboolean
name|ix_used
index|[
literal|256
index|]
decl_stmt|;
comment|// max of 256 palette entries
name|gboolean
name|trans_used
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|ix_used
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
comment|/* If alpha is over a threshold, the colour index in the         * palette is taken. Otherwise, this pixel is transparent. */
if|if
condition|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|>
literal|127
condition|)
name|ix_used
index|[
name|pixels
index|[
name|i
operator|*
literal|2
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
else|else
name|trans_used
operator|=
name|TRUE
expr_stmt|;
block|}
comment|// If there is no transparency, ignore alpha.
if|if
condition|(
name|trans_used
operator|==
name|FALSE
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|colors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ix_used
index|[
name|i
index|]
operator|==
name|FALSE
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
comment|/* Couldn't find an unused colour index within the number of      bits per pixel we wanted.  Will have to increment the number      of colours in the image and assign a transparent pixel there. */
if|if
condition|(
operator|(
operator|*
name|colors
operator|)
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|colors
operator|)
operator|++
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|colors
operator|)
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'query()' - Respond to a plug-in query...  */
end_comment

begin_function
specifier|static
name|void
DECL|function|query (void)
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|}
decl_stmt|;
specifier|static
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|}
decl_stmt|;
specifier|static
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"interlace"
block|,
literal|"Use Adam7 interlacing?"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"compression"
block|,
literal|"Deflate Compression factor (0--9)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"bkgd"
block|,
literal|"Write bKGD chunk?"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"gama"
block|,
literal|"Write gAMA chunk?"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"offs"
block|,
literal|"Write oFFs chunk?"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"phys"
block|,
literal|"Write tIME chunk?"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"time"
block|,
literal|"Write pHYs chunk?"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_png_load"
argument_list|,
literal|"Loads files in PNG file format"
argument_list|,
literal|"This plug-in loads Portable Network Graphics (PNG) files."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
literal|"<Load>/PNG"
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_return_vals
argument_list|)
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_png_save"
argument_list|,
literal|"Saves files in PNG file format"
argument_list|,
literal|"This plug-in saves Portable Network Graphics (PNG) files."
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>"
argument_list|,
literal|"Michael Sweet<mike@easysw.com>, Daniel Skarda<0rfelyus@atrey.karlin.mff.cuni.cz>, Nick Lamb<njl195@zepler.org.uk>"
argument_list|,
name|PLUG_IN_VERSION
argument_list|,
literal|"<Save>/PNG"
argument_list|,
literal|"RGB*,GRAY*,INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
literal|"file_png_load"
argument_list|,
literal|"png"
argument_list|,
literal|""
argument_list|,
literal|"0,string,\211PNG\r\n\032\n"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_png_save"
argument_list|,
literal|"png"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'run()' - Run the plug-in...  */
end_comment

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|gint32
name|orig_image_ID
decl_stmt|;
name|GimpExportReturnType
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_png_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_png_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|image_ID
operator|=
name|orig_image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
literal|"png"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
literal|"PNG"
argument_list|,
operator|(
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*            * Possibly retrieve data...            */
name|gimp_get_data
argument_list|(
literal|"file_png_save"
argument_list|,
operator|&
name|pngvals
argument_list|)
expr_stmt|;
comment|/* 	   * If the image has no transparency, then there is usually 	   * no need to save a bKGD chunk.  For more information, see: 	   * http://bugzilla.gnome.org/show_bug.cgi?id=92395 	   */
if|if
condition|(
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ID
argument_list|)
condition|)
name|pngvals
operator|.
name|bkgd
operator|=
name|FALSE
expr_stmt|;
comment|/*            * Then acquire information with a dialog...            */
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*            * Make sure all the arguments are there!            */
if|if
condition|(
name|nparams
operator|!=
literal|12
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|pngvals
operator|.
name|interlaced
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|compression_level
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|bkgd
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|gama
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|phys
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|offs
operator|=
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|pngvals
operator|.
name|time
operator|=
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|pngvals
operator|.
name|compression_level
operator|<
literal|0
operator|||
name|pngvals
operator|.
name|compression_level
operator|>
literal|9
condition|)
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*            * Possibly retrieve data...            */
name|gimp_get_data
argument_list|(
literal|"file_png_save"
argument_list|,
operator|&
name|pngvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|,
name|orig_image_ID
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
literal|"file_png_save"
argument_list|,
operator|&
name|pngvals
argument_list|,
sizeof|sizeof
argument_list|(
name|pngvals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'load_image()' - Load a PNG image into a new image window.  */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|load_image (const gchar * filename)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
comment|/* Looping var */
name|trns
decl_stmt|,
comment|/* Transparency present */
name|bpp
decl_stmt|,
comment|/* Bytes per pixel */
name|image_type
decl_stmt|,
comment|/* Type of image */
name|layer_type
decl_stmt|,
comment|/* Type of drawable/layer */
name|empty
decl_stmt|,
comment|/* Number of fully transparent indices */
name|num_passes
decl_stmt|,
comment|/* Number of interlace passes in file */
name|pass
decl_stmt|,
comment|/* Current pass in file */
name|tile_height
decl_stmt|,
comment|/* Height of tile in GIMP */
name|begin
decl_stmt|,
comment|/* Beginning tile row */
name|end
decl_stmt|,
comment|/* Ending tile row */
name|num
decl_stmt|;
comment|/* Number of rows to load */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
specifier|volatile
name|gint32
name|image
decl_stmt|;
comment|/* Image -- preserved against setjmp() */
name|gint32
name|layer
decl_stmt|;
comment|/* Layer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|png_structp
name|pp
decl_stmt|;
comment|/* PNG read pointer */
name|png_infop
name|info
decl_stmt|;
comment|/* PNG info pointers */
name|guchar
modifier|*
modifier|*
name|pixels
decl_stmt|,
comment|/* Pixel rows */
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
name|gchar
modifier|*
name|progress
decl_stmt|;
comment|/* Title for progress display... */
name|guchar
name|alpha
index|[
literal|256
index|]
decl_stmt|,
comment|/* Index -> Alpha */
modifier|*
name|alpha_ptr
decl_stmt|;
comment|/* Temporary pointer */
name|png_textp
name|text
decl_stmt|;
name|gint
name|num_texts
decl_stmt|;
comment|/*    * PNG 0.89 and newer have a sane, forwards compatible constructor.    * Some SGI IRIX users will not have a new enough version though    */
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|88
name|pp
operator|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|#
directive|else
name|pp
operator|=
operator|(
name|png_structp
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|png_struct
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_read_init
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|info
operator|=
operator|(
name|png_infop
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 88 */
if|if
condition|(
name|setjmp
argument_list|(
name|pp
operator|->
name|jmpbuf
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"'%s':\nPNG error. File corrupted?"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
comment|/* initialise image here, thus avoiding compiler warnings */
name|image
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*    * Open the file and initialize the PNG read "engine"...    */
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Can't open '%s':\n%s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|png_init_io
argument_list|(
name|pp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|progress
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'..."
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|progress
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|progress
argument_list|)
expr_stmt|;
comment|/*    * Get the image dimensions and create the image...    */
name|png_read_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/*    * Latest attempt, this should be my best yet :)    */
if|if
condition|(
name|info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|png_set_strip_16
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|&&
name|info
operator|->
name|bit_depth
operator|<
literal|8
condition|)
block|{
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|info
operator|->
name|bit_depth
operator|<
literal|8
condition|)
block|{
name|png_set_packing
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Expand G+tRNS to GA, RGB+tRNS to RGBA    */
if|if
condition|(
name|info
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|(
name|info
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
operator|)
condition|)
block|{
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Turn on interlace handling... libpng returns just 1 (ie single pass)    * if the image is not interlaced    */
name|num_passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Special handling for INDEXED + tRNS (transparency palette)    */
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|99
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
operator|&&
name|info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_get_tRNS
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|alpha_ptr
argument_list|,
operator|&
name|num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy the existing alpha values from the tRNS chunk */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|alpha
index|[
name|i
index|]
operator|=
name|alpha_ptr
index|[
name|i
index|]
expr_stmt|;
comment|/* And set any others to fully opaque (255)  */
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|alpha
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
name|trns
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trns
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|trns
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 99 */
comment|/*    * Update the info structures after the transformations take effect    */
name|png_read_update_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_RGB
case|:
comment|/* RGB */
name|bpp
operator|=
literal|3
expr_stmt|;
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|layer_type
operator|=
name|GIMP_RGB_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
comment|/* RGBA */
name|bpp
operator|=
literal|4
expr_stmt|;
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
name|layer_type
operator|=
name|GIMP_RGBA_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
comment|/* Grayscale */
name|bpp
operator|=
literal|1
expr_stmt|;
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
name|layer_type
operator|=
name|GIMP_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
comment|/* Grayscale + alpha */
name|bpp
operator|=
literal|2
expr_stmt|;
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
name|layer_type
operator|=
name|GIMP_GRAYA_IMAGE
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
comment|/* Indexed */
name|bpp
operator|=
literal|1
expr_stmt|;
name|image_type
operator|=
name|GIMP_INDEXED
expr_stmt|;
name|layer_type
operator|=
name|GIMP_INDEXED_IMAGE
expr_stmt|;
break|break;
default|default:
comment|/* Aie! Unknown type */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"'%s':\nUnknown PNG color model"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
empty_stmt|;
name|image
operator|=
name|gimp_image_new
argument_list|(
name|info
operator|->
name|width
argument_list|,
name|info
operator|->
name|height
argument_list|,
name|image_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|==
operator|-
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"'%s'\nCan't allocate new image"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
comment|/*    * Create the "background" layer to hold the image...    */
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|info
operator|->
name|width
argument_list|,
name|info
operator|->
name|height
argument_list|,
name|layer_type
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Find out everything we can about the image resolution    * This is only practical with the new 1.0 APIs, I'm afraid    * due to a bug in libpng-1.0.6, see png-implement for details    */
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|99
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_gAMA
argument_list|)
condition|)
block|{
comment|/* I sure would like to handle this, but there's no mechanism to          do so in Gimp :( */
block|}
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_oFFs
argument_list|)
condition|)
block|{
name|gimp_layer_set_offsets
argument_list|(
name|layer
argument_list|,
name|png_get_x_offset_pixels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
argument_list|,
name|png_get_y_offset_pixels
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_pHYs
argument_list|)
condition|)
block|{
name|gimp_image_set_resolution
argument_list|(
name|image
argument_list|,
operator|(
operator|(
name|double
operator|)
name|png_get_x_pixels_per_meter
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|)
operator|*
literal|0.0254
argument_list|,
operator|(
operator|(
name|double
operator|)
name|png_get_y_pixels_per_meter
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
operator|)
operator|*
literal|0.0254
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 99 */
name|gimp_image_set_filename
argument_list|(
name|image
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/*    * Load the colormap as necessary...    */
name|empty
operator|=
literal|0
expr_stmt|;
comment|/* by default assume no full transparent palette entries */
if|if
condition|(
name|info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_PALETTE
condition|)
block|{
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|99
if|if
condition|(
name|png_get_valid
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
block|{
for|for
control|(
name|empty
operator|=
literal|0
init|;
name|empty
operator|<
literal|256
operator|&&
name|alpha
index|[
name|empty
index|]
operator|==
literal|0
condition|;
operator|++
name|empty
control|)
empty_stmt|;
comment|/* Calculates number of fully transparent "empty" entries */
name|gimp_image_set_cmap
argument_list|(
name|image
argument_list|,
operator|(
name|guchar
operator|*
operator|)
operator|(
name|info
operator|->
name|palette
operator|+
name|empty
operator|)
argument_list|,
name|info
operator|->
name|num_palette
operator|-
name|empty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_image_set_cmap
argument_list|(
name|image
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|info
operator|->
name|palette
argument_list|,
name|info
operator|->
name|num_palette
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gimp_image_set_cmap
argument_list|(
name|image
argument_list|,
operator|(
name|guchar
operator|*
operator|)
name|info
operator|->
name|palette
argument_list|,
name|info
operator|->
name|num_palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 99 */
block|}
comment|/*    * Get the drawable and set the pixel region for our load...    */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*    * Temporary buffer...    */
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pixel
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|info
operator|->
name|width
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|tile_height
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixel
operator|+
name|info
operator|->
name|width
operator|*
name|info
operator|->
name|channels
operator|*
name|i
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_passes
condition|;
name|pass
operator|++
control|)
block|{
comment|/*        * This works if you are only reading one row at a time...        */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|info
operator|->
name|height
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|info
operator|->
name|height
condition|)
name|end
operator|=
name|info
operator|->
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
comment|/* to handle interlaced PiNGs */
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|png_read_rows
argument_list|(
name|pp
argument_list|,
name|pixels
argument_list|,
name|NULL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
operator|(
name|double
operator|)
name|pass
operator|+
operator|(
name|double
operator|)
name|end
operator|/
operator|(
name|double
operator|)
name|info
operator|->
name|height
operator|)
operator|/
operator|(
name|double
operator|)
name|num_passes
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|png_read_end
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_text
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|text
argument_list|,
operator|&
name|num_texts
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_texts
operator|&&
operator|!
name|comment
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|text
operator|->
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|text
operator|->
name|key
argument_list|,
literal|"Comment"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|text
operator|->
name|text_length
operator|>
literal|0
condition|)
comment|/*  tEXt  */
block|{
name|comment
operator|=
name|g_convert
argument_list|(
name|text
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|,
literal|"UTF-8"
argument_list|,
literal|"ISO-8859-1"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  iTXt  */
name|comment
operator|=
name|g_strdup
argument_list|(
name|text
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|comment
operator|&&
operator|*
name|comment
condition|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|comment
argument_list|)
operator|+
literal|1
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|image
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
block|}
comment|/*    * Done with the file...    */
name|png_read_destroy
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trns
condition|)
block|{
name|gimp_layer_add_alpha
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixel
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|drawable
operator|->
name|width
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* bpp == 1 */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|drawable
operator|->
name|height
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|drawable
operator|->
name|height
condition|)
name|end
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
operator|*
name|drawable
operator|->
name|width
condition|;
operator|++
name|i
control|)
block|{
name|pixel
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|alpha
index|[
name|pixel
index|[
name|i
operator|*
literal|2
index|]
index|]
expr_stmt|;
name|pixel
index|[
name|i
operator|*
literal|2
index|]
operator|-=
name|empty
expr_stmt|;
block|}
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
block|}
comment|/*    * Update the display...    */
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
operator|(
name|image
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'save_image ()' - Save the specified image to a PNG file.  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|save_image (const gchar * filename,gint32 image_ID,gint32 drawable_ID,gint32 orig_image_ID)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
comment|/* Looping vars */
name|bpp
init|=
literal|0
decl_stmt|,
comment|/* Bytes per pixel */
name|type
decl_stmt|,
comment|/* Type of drawable/layer */
name|num_passes
decl_stmt|,
comment|/* Number of interlace passes in file */
name|pass
decl_stmt|,
comment|/* Current pass in file */
name|tile_height
decl_stmt|,
comment|/* Height of tile in GIMP */
name|begin
decl_stmt|,
comment|/* Beginning tile row */
name|end
decl_stmt|,
comment|/* Ending tile row */
name|num
decl_stmt|;
comment|/* Number of rows to load */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File pointer */
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
comment|/* Drawable for layer */
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
comment|/* Pixel region for layer */
name|png_structp
name|pp
decl_stmt|;
comment|/* PNG read pointer */
name|png_infop
name|info
decl_stmt|;
comment|/* PNG info pointer */
name|gint
name|num_colors
decl_stmt|;
comment|/* Number of colors in colormap */
name|gint
name|offx
decl_stmt|,
name|offy
decl_stmt|;
comment|/* Drawable offsets from origin */
name|guchar
modifier|*
modifier|*
name|pixels
decl_stmt|,
comment|/* Pixel rows */
modifier|*
name|fixed
decl_stmt|,
comment|/* Fixed-up pixel data */
modifier|*
name|pixel
decl_stmt|;
comment|/* Pixel data */
name|gchar
modifier|*
name|progress
decl_stmt|;
comment|/* Title for progress display... */
name|gdouble
name|xres
decl_stmt|,
name|yres
decl_stmt|;
comment|/* GIMP resolution (dpi) */
name|gdouble
name|gamma
decl_stmt|;
comment|/* GIMP gamma e.g. 2.20 */
name|png_color_16
name|background
decl_stmt|;
comment|/* Background color */
name|png_time
name|mod_time
decl_stmt|;
comment|/* Modification time (ie NOW) */
name|guchar
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
comment|/* Used for palette background */
name|time_t
name|cutime
decl_stmt|;
comment|/* Time since epoch */
name|struct
name|tm
modifier|*
name|gmt
decl_stmt|;
comment|/* GMT broken down */
name|guchar
name|remap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Re-mapping for the palette */
name|png_textp
name|text
init|=
name|NULL
decl_stmt|;
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
name|parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|orig_image_ID
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parasite
condition|)
block|{
name|gchar
modifier|*
name|comment
init|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|parasite
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|parasite
argument_list|)
argument_list|)
decl_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
name|text
operator|=
name|g_new0
argument_list|(
name|png_text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|text
operator|->
name|key
operator|=
literal|"Comment"
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
name|text
operator|->
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
name|text
operator|->
name|text
operator|=
name|comment
name|text
operator|->
name|itxt_length
operator|=
name|strlen
argument_list|(
name|comment
argument_list|)
expr_stmt|;
else|#
directive|else
name|text
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
name|text
operator|->
name|text
operator|=
name|g_convert
argument_list|(
name|comment
argument_list|,
operator|-
literal|1
argument_list|,
literal|"ISO-8859-1"
argument_list|,
literal|"UTF-8"
argument_list|,
name|NULL
argument_list|,
operator|&
name|text
operator|->
name|text_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|text
operator|->
name|text
condition|)
block|{
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*    * PNG 0.89 and newer have a sane, forwards compatible constructor.    * Some SGI IRIX users will not have a new enough version though    */
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|88
name|pp
operator|=
name|png_create_write_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|#
directive|else
name|pp
operator|=
operator|(
name|png_structp
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|png_struct
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_write_init
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|info
operator|=
operator|(
name|png_infop
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 88 */
if|if
condition|(
name|setjmp
argument_list|(
name|pp
operator|->
name|jmpbuf
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"'%s':\nPNG error. Couldn't save image"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|text
condition|)
name|png_set_text
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*    * Open the file and initialize the PNG write "engine"...    */
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Can't open '%s' for writing:\n%s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|png_init_io
argument_list|(
name|pp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|progress
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'..."
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|progress
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|progress
argument_list|)
expr_stmt|;
comment|/*    * Get the drawable for the current image...    */
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|type
operator|=
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
comment|/*    * Set the image dimensions, bit depth, interlacing and compression    */
name|png_set_compression_level
argument_list|(
name|pp
argument_list|,
name|pngvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
name|info
operator|->
name|width
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|info
operator|->
name|height
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|info
operator|->
name|interlace_type
operator|=
name|pngvals
operator|.
name|interlaced
expr_stmt|;
comment|/*     * Initialise remap[]    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|remap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/*    * Set color type and remember bytes per pixel count     */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
name|bpp
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
name|info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
name|bpp
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
name|bpp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
name|bpp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|bpp
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|info
operator|->
name|valid
operator||=
name|PNG_INFO_PLTE
expr_stmt|;
name|info
operator|->
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|gimp_image_get_cmap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|num_colors
argument_list|)
expr_stmt|;
name|info
operator|->
name|num_palette
operator|=
name|num_colors
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|bpp
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|respin_cmap
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|remap
argument_list|,
name|image_ID
argument_list|,
name|drawable
argument_list|)
expr_stmt|;
comment|/* fix up transparency */
break|break;
default|default:
name|g_message
argument_list|(
literal|"'%s':\nImage type can't be saved as PNG"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
empty_stmt|;
comment|/*    * Fix bit depths for (possibly) smaller colormap images    */
if|if
condition|(
name|info
operator|->
name|valid
operator|&
name|PNG_INFO_PLTE
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|num_palette
operator|<=
literal|2
condition|)
name|info
operator|->
name|bit_depth
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|num_palette
operator|<=
literal|4
condition|)
name|info
operator|->
name|bit_depth
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|num_palette
operator|<=
literal|16
condition|)
name|info
operator|->
name|bit_depth
operator|=
literal|4
expr_stmt|;
comment|/* otherwise the default is fine */
block|}
comment|/* All this stuff is optional extras, if the user is aiming for smallest      possible file size she can turn them all off */
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|99
if|if
condition|(
name|pngvals
operator|.
name|bkgd
condition|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|gimp_palette_get_background
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|background
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|background
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|background
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|background
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|background
operator|.
name|gray
operator|=
name|gimp_rgb_intensity_uchar
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|png_set_bKGD
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|background
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|gama
condition|)
block|{
name|gamma
operator|=
name|gimp_gamma
argument_list|()
expr_stmt|;
name|png_set_gAMA
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
literal|1.0
operator|/
operator|(
name|gamma
operator|!=
literal|1.00
condition|?
name|gamma
else|:
name|DEFAULT_GAMMA
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|offs
condition|)
block|{
name|gimp_drawable_offsets
argument_list|(
name|drawable_ID
argument_list|,
operator|&
name|offx
argument_list|,
operator|&
name|offy
argument_list|)
expr_stmt|;
if|if
condition|(
name|offx
operator|!=
literal|0
operator|||
name|offy
operator|!=
literal|0
condition|)
block|{
name|png_set_oFFs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|offx
argument_list|,
name|offy
argument_list|,
name|PNG_OFFSET_PIXEL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pngvals
operator|.
name|phys
condition|)
block|{
name|gimp_image_get_resolution
argument_list|(
name|orig_image_ID
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
expr_stmt|;
name|png_set_pHYs
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|xres
operator|*
literal|39.37
argument_list|,
name|yres
operator|*
literal|39.37
argument_list|,
name|PNG_RESOLUTION_METER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pngvals
operator|.
name|time
condition|)
block|{
name|cutime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* time right NOW */
name|gmt
operator|=
name|gmtime
argument_list|(
operator|&
name|cutime
argument_list|)
expr_stmt|;
name|mod_time
operator|.
name|year
operator|=
name|gmt
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|mod_time
operator|.
name|month
operator|=
name|gmt
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|mod_time
operator|.
name|day
operator|=
name|gmt
operator|->
name|tm_mday
expr_stmt|;
name|mod_time
operator|.
name|hour
operator|=
name|gmt
operator|->
name|tm_hour
expr_stmt|;
name|mod_time
operator|.
name|minute
operator|=
name|gmt
operator|->
name|tm_min
expr_stmt|;
name|mod_time
operator|.
name|second
operator|=
name|gmt
operator|->
name|tm_sec
expr_stmt|;
name|png_set_tIME
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|&
name|mod_time
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 99 */
name|png_write_info
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/*    * Turn on interlace handling...    */
if|if
condition|(
name|pngvals
operator|.
name|interlaced
condition|)
name|num_passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|num_passes
operator|=
literal|1
expr_stmt|;
comment|/*    * Convert unpacked pixels to packed if necessary    */
if|if
condition|(
name|info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|info
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|png_set_packing
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/*    * Allocate memory for "tile_height" rows and save the image...    */
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pixel
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|drawable
operator|->
name|width
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
operator|*
argument_list|,
name|tile_height
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile_height
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixel
operator|+
name|drawable
operator|->
name|width
operator|*
name|bpp
operator|*
name|i
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_passes
condition|;
name|pass
operator|++
control|)
block|{
comment|/* This works if you are only writing one row at a time... */
for|for
control|(
name|begin
operator|=
literal|0
operator|,
name|end
operator|=
name|tile_height
init|;
name|begin
operator|<
name|drawable
operator|->
name|height
condition|;
name|begin
operator|+=
name|tile_height
operator|,
name|end
operator|+=
name|tile_height
control|)
block|{
if|if
condition|(
name|end
operator|>
name|drawable
operator|->
name|height
condition|)
name|end
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|begin
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
name|begin
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* If we're dealing with a paletted image with             * transparency set, write out the remapped palette */
if|if
condition|(
name|info
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|drawable
operator|->
name|width
condition|;
operator|++
name|k
control|)
block|{
name|fixed
index|[
name|k
index|]
operator|=
operator|(
name|fixed
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|>
literal|127
operator|)
condition|?
name|remap
index|[
name|fixed
index|[
name|k
operator|*
literal|2
index|]
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise if we have a paletted image and transparency             * couldn't be set, we ignore the alpha channel */
elseif|else
if|if
condition|(
name|info
operator|->
name|valid
operator|&
name|PNG_INFO_PLTE
operator|&&
name|bpp
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|fixed
operator|=
name|pixels
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|drawable
operator|->
name|width
condition|;
operator|++
name|k
control|)
block|{
name|fixed
index|[
name|k
index|]
operator|=
name|fixed
index|[
name|k
operator|*
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
name|png_write_rows
argument_list|(
name|pp
argument_list|,
name|pixels
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
operator|(
name|double
operator|)
name|pass
operator|+
operator|(
name|double
operator|)
name|end
operator|/
operator|(
name|double
operator|)
name|info
operator|->
name|height
operator|)
operator|/
operator|(
name|double
operator|)
name|num_passes
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|png_write_end
argument_list|(
name|pp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|png_write_destroy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
comment|/*    * Done with the file...    */
if|if
condition|(
name|text
condition|)
block|{
name|g_free
argument_list|(
name|text
operator|->
name|text
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_ok_callback (GtkWidget * widget,gpointer data)
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|runme
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|respin_cmap (png_structp pp,png_infop info,guchar * remap,gint32 image_ID,GimpDrawable * drawable)
name|respin_cmap
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|info
parameter_list|,
name|guchar
modifier|*
name|remap
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
specifier|static
specifier|const
name|guchar
name|trans
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|gint
name|colors
decl_stmt|;
name|guchar
modifier|*
name|before
decl_stmt|;
name|gint
name|transparent
decl_stmt|;
name|gint
name|cols
decl_stmt|,
name|rows
decl_stmt|;
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|guchar
modifier|*
name|pixels
decl_stmt|;
name|before
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|cols
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|rows
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pixels
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
operator|*
literal|2
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* Try to find an entry which isn't actually used in the      image, for a transparency index. */
name|transparent
operator|=
name|find_unused_ia_colour
argument_list|(
name|pixels
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>
literal|99
if|if
condition|(
name|transparent
operator|!=
operator|-
literal|1
condition|)
comment|/* we have a winner for a transparent                                   * index - do like gif2png and swap                                   * index 0 and index transparent */
block|{
name|png_color
name|palette
index|[
literal|256
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|png_set_tRNS
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|(
name|png_bytep
operator|)
name|trans
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Transform all pixels with a value = transparent to         * 0 and vice versa to compensate for re-ordering in palette         * due to png_set_tRNS() */
name|remap
index|[
literal|0
index|]
operator|=
name|transparent
expr_stmt|;
name|remap
index|[
name|transparent
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Copy from index 0 to index transparent - 1 to index 1 to         * transparent of after, then from transparent+1 to colors-1         * unchanged, and finally from index transparent to index 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
operator|+
literal|1
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|before
index|[
literal|3
operator|*
name|remap
index|[
name|i
index|]
operator|+
literal|2
index|]
expr_stmt|;
block|}
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
name|palette
argument_list|,
name|colors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Inform the user that we couldn't losslessly save the         * transparency& just use the full palette */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Couldn't losslessly save transparency,\n"
literal|"saving opacity instead."
argument_list|)
argument_list|)
expr_stmt|;
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|info
argument_list|,
operator|(
name|png_colorp
operator|)
name|before
argument_list|,
name|colors
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|info
operator|->
name|valid
operator||=
name|PNG_INFO_PLTE
expr_stmt|;
name|info
operator|->
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|before
expr_stmt|;
name|info
operator|->
name|num_palette
operator|=
name|colors
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_LIBPNG_VER> 99 */
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_dialog (void)
name|save_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|scale
decl_stmt|;
name|GtkObject
modifier|*
name|scale_data
decl_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Save as PNG"
argument_list|)
argument_list|,
literal|"png"
argument_list|,
name|gimp_standard_help_func
argument_list|,
literal|"filters/png.html"
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|gtk_widget_destroy
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|GTK_STOCK_OK
argument_list|,
name|save_ok_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|dlg
argument_list|,
literal|"destroy"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gtk_main_quit
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|_
argument_list|(
literal|"Parameter Settings"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|2
argument_list|,
literal|7
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"_Interlacing (Adam7)"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pngvals
operator|.
name|interlaced
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|interlaced
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Save _background color"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pngvals
operator|.
name|bkgd
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|bkgd
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Save _gamma"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pngvals
operator|.
name|gama
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|gama
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Save _layer offset"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pngvals
operator|.
name|offs
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|offs
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Save _resolution"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pngvals
operator|.
name|phys
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|phys
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_mnemonic
argument_list|(
name|_
argument_list|(
literal|"Save creation _time"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|pngvals
operator|.
name|time
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|time
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
name|pngvals
operator|.
name|compression_level
argument_list|,
literal|0.0
argument_list|,
literal|9.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_set_size_request
argument_list|(
name|scale
argument_list|,
name|SCALE_WIDTH
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_scale_set_digits
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gimp_table_attach_aligned
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
name|_
argument_list|(
literal|"Co_mpression Level:"
argument_list|)
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|scale
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|gimp_help_set_help_data
argument_list|(
name|scale
argument_list|,
name|_
argument_list|(
literal|"Choose a high compression level "
literal|"for small file size"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value_changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|pngvals
operator|.
name|compression_level
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|runme
return|;
block|}
end_function

end_unit

