begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* XPM plugin version 1.2.2 */
end_comment

begin_comment
comment|/* 1.2.2 fixes bug that generated bad digits on images with more than 20000 colors. (thanks, yanele) parses gtkrc (thanks, yosh) doesn't load parameter screen on images that don't have alpha  1.2.1 fixes some minor bugs -- spaces in #XXXXXX strings, small typos in code.  1.2 compute color indexes so that we don't have to use XpmSaveXImage*  Previous...Inherited code from Ray Lehtiniemi, who inherited it from S& P. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X11/xpm.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_decl_stmt
DECL|variable|linenoise
specifier|static
specifier|const
name|gchar
name|linenoise
index|[]
init|=
literal|" .+@#$%&*=-;>,')!~{]^/(_:<[}|1234567890abcdefghijklmnopqrstuvwxyz\ ABCDEFGHIJKLMNOPQRSTUVWXYZ`"
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_comment
comment|/* Structs for the save dialog */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon275d69aa0108
block|{
DECL|member|threshold
name|gdouble
name|threshold
decl_stmt|;
DECL|typedef|XpmSaveVals
block|}
name|XpmSaveVals
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon275d69aa0208
block|{
DECL|member|run
name|gint
name|run
decl_stmt|;
DECL|typedef|XpmSaveInterface
block|}
name|XpmSaveInterface
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon275d69aa0308
block|{
DECL|member|r
name|guchar
name|r
decl_stmt|;
DECL|member|g
name|guchar
name|g
decl_stmt|;
DECL|member|b
name|guchar
name|b
decl_stmt|;
DECL|typedef|rgbkey
block|}
name|rgbkey
typedef|;
end_typedef

begin_comment
comment|/*  whether the image is color or not.  global so I only have to pass  *  one user value to the GHFunc  */
end_comment

begin_decl_stmt
DECL|variable|color
name|gint
name|color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  bytes per pixel.  global so I only have to pass one user value  *  to the GHFunc  */
end_comment

begin_decl_stmt
DECL|variable|cpp
name|gint
name|cpp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_colors
parameter_list|(
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
modifier|*
name|cmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_image
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_gtk
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xpmvals
specifier|static
name|XpmSaveVals
name|xpmvals
init|=
block|{
literal|0.50
comment|/* alpha threshold */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xpmint
specifier|static
name|XpmSaveInterface
name|xpmint
init|=
block|{
name|FALSE
comment|/*  run  */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|gint
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|gint
name|nload_return_vals
init|=
operator|(
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
specifier|static
name|GParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,   }
decl_stmt|;
specifier|static
name|gint
name|nsave_args
init|=
sizeof|sizeof
argument_list|(
name|save_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|save_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_xpm_load"
argument_list|,
literal|"loads files of the xpm file format"
argument_list|,
literal|"FIXME: write help for xpm_load"
argument_list|,
literal|"Spencer Kimball& Peter Mattis& Ray Lehtiniemi"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
literal|"<Load>/Xpm"
argument_list|,
name|NULL
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_xpm_save"
argument_list|,
literal|"saves files in the xpm file format (if you're on a 16 bit display...)"
argument_list|,
literal|"FIXME: write help for xpm"
argument_list|,
literal|"Spencer Kimball& Peter Mattis& Ray Lehtiniemi& Nathan Summers"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
literal|"<Save>/Xpm"
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nsave_args
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
literal|"file_xpm_load"
argument_list|,
literal|"xpm"
argument_list|,
literal|"<Load>/Xpm"
argument_list|,
literal|"0, string,/*\\040XPM\\040*/"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_xpm_save"
argument_list|,
literal|"xpm"
argument_list|,
literal|"<Save>/Xpm"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparams,GParam * param,gint * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|GimpExportReturnType
name|export
init|=
name|EXPORT_CANCEL
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_xpm_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INIT_I18N
argument_list|()
expr_stmt|;
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PARAM_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_xpm_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INIT_I18N_UI
argument_list|()
expr_stmt|;
name|init_gtk
argument_list|()
expr_stmt|;
name|image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
case|case
name|RUN_WITH_LAST_VALS
case|:
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
literal|"XPM"
argument_list|,
operator|(
name|CAN_HANDLE_RGB
operator||
name|CAN_HANDLE_GRAY
operator||
name|CAN_HANDLE_INDEXED
operator||
name|CAN_HANDLE_ALPHA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_xpm_save"
argument_list|,
operator|&
name|xpmvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ID
argument_list|)
condition|)
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
name|status
operator|=
name|STATUS_CANCEL
expr_stmt|;
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|4
condition|)
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|xpmvals
operator|.
name|threshold
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
if|if
condition|(
name|xpmvals
operator|.
name|threshold
operator|<
literal|0.0
operator|||
name|xpmvals
operator|.
name|threshold
operator|>
literal|1.0
condition|)
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_xpm_save"
argument_list|,
operator|&
name|xpmvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
literal|"file_xpm_save"
argument_list|,
operator|&
name|xpmvals
argument_list|,
sizeof|sizeof
argument_list|(
name|XpmSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (gchar * filename)
name|load_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|XpmImage
name|xpm_image
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gchar
modifier|*
name|name
decl_stmt|;
comment|/* put up a progress bar */
name|name
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Loading %s:"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* read the raw file */
name|XpmReadFileToXpmImage
argument_list|(
name|filename
argument_list|,
operator|&
name|xpm_image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* parse out the colors into a cmap */
name|parse_colors
argument_list|(
operator|&
name|xpm_image
argument_list|,
operator|&
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
comment|/* create the new image */
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|xpm_image
operator|.
name|width
argument_list|,
name|xpm_image
operator|.
name|height
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
comment|/* name it */
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* fill it */
name|parse_image
argument_list|(
name|image_ID
argument_list|,
operator|&
name|xpm_image
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
comment|/* clean up and exit */
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_colors (XpmImage * xpm_image,guchar ** cmap)
name|parse_colors
parameter_list|(
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
modifier|*
name|cmap
parameter_list|)
block|{
name|Display
modifier|*
name|display
decl_stmt|;
name|Colormap
name|colormap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* open the display and get the default color map */
name|display
operator|=
name|XOpenDisplay
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|colormap
operator|=
name|DefaultColormap
argument_list|(
name|display
argument_list|,
name|DefaultScreen
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
comment|/* alloc a buffer to hold the parsed colors */
operator|*
name|cmap
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
literal|4
operator|*
name|xpm_image
operator|->
name|ncolors
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cmap
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* default to black transparent */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
name|cmap
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
operator|*
literal|4
operator|*
name|xpm_image
operator|->
name|ncolors
argument_list|)
expr_stmt|;
comment|/* parse each color in the file */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|xpm_image
operator|->
name|ncolors
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|colorspec
init|=
literal|"None"
decl_stmt|;
name|XpmColor
modifier|*
name|xpm_color
decl_stmt|;
name|XColor
name|xcolor
decl_stmt|;
name|xpm_color
operator|=
operator|&
operator|(
name|xpm_image
operator|->
name|colorTable
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* pick the best spec available */
if|if
condition|(
name|xpm_color
operator|->
name|c_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|c_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|g_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|g_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|g4_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|g4_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|m_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|m_color
expr_stmt|;
comment|/* parse if it's not transparent.  the assumption is that              g_new will memset the buffer to zeros */
if|if
condition|(
name|strcmp
argument_list|(
name|colorspec
argument_list|,
literal|"None"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XParseColor
argument_list|(
name|display
argument_list|,
name|colormap
argument_list|,
name|colorspec
argument_list|,
operator|&
name|xcolor
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cmap
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|red
operator|>>
literal|8
expr_stmt|;
operator|(
operator|*
name|cmap
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|green
operator|>>
literal|8
expr_stmt|;
operator|(
operator|*
name|cmap
operator|)
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|blue
operator|>>
literal|8
expr_stmt|;
operator|(
operator|*
name|cmap
operator|)
index|[
name|j
operator|++
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|j
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
name|XCloseDisplay
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_image (gint32 image_ID,XpmImage * xpm_image,guchar * cmap)
name|parse_image
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|)
block|{
name|int
name|tile_height
decl_stmt|;
name|int
name|scanlines
decl_stmt|;
name|int
name|val
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|int
modifier|*
name|src
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|layer_ID
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|_
argument_list|(
literal|"Color"
argument_list|)
argument_list|,
name|xpm_image
operator|->
name|width
argument_list|,
name|xpm_image
operator|->
name|height
argument_list|,
name|RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|xpm_image
operator|->
name|width
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|src
operator|=
name|xpm_image
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xpm_image
operator|->
name|height
condition|;
name|i
operator|+=
name|tile_height
control|)
block|{
name|dest
operator|=
name|buf
expr_stmt|;
name|scanlines
operator|=
name|MIN
argument_list|(
name|tile_height
argument_list|,
name|xpm_image
operator|->
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|scanlines
operator|*
name|xpm_image
operator|->
name|width
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
block|{
name|val
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
operator|*
literal|4
expr_stmt|;
operator|*
operator|(
name|dest
operator|)
operator|=
name|cmap
index|[
name|val
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|1
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|2
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|2
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|3
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|3
index|]
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|i
operator|/
operator|(
name|double
operator|)
name|xpm_image
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|scanlines
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|guint
DECL|function|rgbhash (rgbkey * c)
name|rgbhash
parameter_list|(
name|rgbkey
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|r
operator|)
operator|^
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|g
operator|)
operator|^
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|b
operator|)
return|;
block|}
end_function

begin_function
name|guint
DECL|function|compare (rgbkey * c1,rgbkey * c2)
name|compare
parameter_list|(
name|rgbkey
modifier|*
name|c1
parameter_list|,
name|rgbkey
modifier|*
name|c2
parameter_list|)
block|{
return|return
operator|(
name|c1
operator|->
name|r
operator|==
name|c2
operator|->
name|r
operator|)
operator|&&
operator|(
name|c1
operator|->
name|g
operator|==
name|c2
operator|->
name|g
operator|)
operator|&&
operator|(
name|c1
operator|->
name|b
operator|==
name|c2
operator|->
name|b
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|set_XpmImage (XpmColor * array,guint index,gchar * colorstring)
name|set_XpmImage
parameter_list|(
name|XpmColor
modifier|*
name|array
parameter_list|,
name|guint
name|index
parameter_list|,
name|gchar
modifier|*
name|colorstring
parameter_list|)
block|{
name|gchar
modifier|*
name|p
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|charnum
decl_stmt|,
name|indtemp
decl_stmt|;
name|indtemp
operator|=
name|index
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|string
operator|=
name|p
operator|=
name|g_new
argument_list|(
name|char
argument_list|,
name|cpp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*convert the index number to base sizeof(linenoise)-1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpp
condition|;
operator|++
name|i
control|)
block|{
name|charnum
operator|=
name|indtemp
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|indtemp
operator|=
name|indtemp
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|linenoise
index|[
name|charnum
index|]
expr_stmt|;
block|}
comment|/* *p++=linenoise[indtemp]; */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* C and its stupid null-terminated strings...*/
name|array
index|[
name|index
index|]
operator|.
name|symbolic
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|m_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|g4_color
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|color
condition|)
block|{
name|array
index|[
name|index
index|]
operator|.
name|g_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|c_color
operator|=
name|colorstring
expr_stmt|;
block|}
else|else
block|{
name|array
index|[
name|index
index|]
operator|.
name|c_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|g_color
operator|=
name|colorstring
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|create_colormap_from_hash (gpointer gkey,gpointer value,gpointer user_data)
name|create_colormap_from_hash
parameter_list|(
name|gpointer
name|gkey
parameter_list|,
name|gpointer
name|value
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|rgbkey
modifier|*
name|key
init|=
name|gkey
decl_stmt|;
name|gchar
modifier|*
name|string
init|=
name|g_new
argument_list|(
name|char
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"#%02X%02X%02X"
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|r
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|g
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|b
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|user_data
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|value
operator|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_image (gchar * filename,gint32 image_ID,gint32 drawable_ID)
name|save_image
parameter_list|(
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
block|{
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|alpha
decl_stmt|;
name|gint
name|ncolors
init|=
literal|1
decl_stmt|;
name|gint
modifier|*
name|indexno
decl_stmt|;
name|gint
name|indexed
decl_stmt|;
name|XpmColor
modifier|*
name|colormap
decl_stmt|;
name|XpmImage
modifier|*
name|image
decl_stmt|;
name|guint
modifier|*
name|ibuff
init|=
name|NULL
decl_stmt|;
comment|/*guint   *mbuff   = NULL;*/
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|guchar
modifier|*
name|buffer
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|GHashTable
modifier|*
name|hash
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|threshold
init|=
literal|255
operator|*
name|xpmvals
operator|.
name|threshold
decl_stmt|;
name|gint
name|rc
init|=
name|FALSE
decl_stmt|;
comment|/* get some basic stats about the image */
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
condition|)
block|{
case|case
name|RGBA_IMAGE
case|:
case|case
name|INDEXEDA_IMAGE
case|:
case|case
name|GRAYA_IMAGE
case|:
name|alpha
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RGB_IMAGE
case|:
case|case
name|INDEXED_IMAGE
case|:
case|case
name|GRAY_IMAGE
case|:
name|alpha
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
condition|)
block|{
case|case
name|GRAYA_IMAGE
case|:
case|case
name|GRAY_IMAGE
case|:
name|color
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RGBA_IMAGE
case|:
case|case
name|RGB_IMAGE
case|:
case|case
name|INDEXED_IMAGE
case|:
case|case
name|INDEXEDA_IMAGE
case|:
name|color
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
condition|)
block|{
case|case
name|GRAYA_IMAGE
case|:
case|case
name|GRAY_IMAGE
case|:
case|case
name|RGBA_IMAGE
case|:
case|case
name|RGB_IMAGE
case|:
name|indexed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|INDEXED_IMAGE
case|:
case|case
name|INDEXEDA_IMAGE
case|:
name|indexed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|width
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
comment|/* allocate buffers making the assumption that ibuff and mbuff      are 32 bit aligned... */
if|if
condition|(
operator|(
name|ibuff
operator|=
name|g_new
argument_list|(
name|guint
argument_list|,
name|width
operator|*
name|height
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/*if ((mbuff = g_new(guint, width*height)) == NULL)     goto cleanup;*/
if|if
condition|(
operator|(
name|hash
operator|=
name|g_hash_table_new
argument_list|(
operator|(
name|GHashFunc
operator|)
name|rgbhash
argument_list|,
operator|(
name|GCompareFunc
operator|)
name|compare
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* put up a progress bar */
block|{
name|gchar
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Saving %s:"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* allocate a pixel region to work with */
if|if
condition|(
operator|(
name|buffer
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimp_tile_height
argument_list|()
operator|*
name|width
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* process each row of tiles */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|+=
name|gimp_tile_height
argument_list|()
control|)
block|{
name|int
name|scanlines
decl_stmt|;
comment|/* read the next row of tiles */
name|scanlines
operator|=
name|MIN
argument_list|(
name|gimp_tile_height
argument_list|()
argument_list|,
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|scanlines
argument_list|)
expr_stmt|;
name|data
operator|=
name|buffer
expr_stmt|;
comment|/* process each pixel row */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scanlines
condition|;
name|j
operator|++
control|)
block|{
comment|/* go to the start of this row in each image */
name|guint
modifier|*
name|idata
init|=
name|ibuff
operator|+
operator|(
name|i
operator|+
name|j
operator|)
operator|*
name|width
decl_stmt|;
comment|/*guint *mdata = mbuff + (i+j) * width;*/
comment|/* do each pixel in the row */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
name|k
operator|++
control|)
block|{
name|rgbkey
modifier|*
name|key
init|=
name|g_new
argument_list|(
name|rgbkey
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|guchar
name|a
decl_stmt|;
comment|/* get pixel data */
name|key
operator|->
name|r
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|key
operator|->
name|g
operator|=
name|color
operator|&&
operator|!
name|indexed
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
name|key
operator|->
name|r
expr_stmt|;
name|key
operator|->
name|b
operator|=
name|color
operator|&&
operator|!
name|indexed
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
name|key
operator|->
name|r
expr_stmt|;
name|a
operator|=
name|alpha
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
literal|255
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|threshold
condition|)
block|{
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|indexed
condition|)
block|{
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
operator|(
name|key
operator|->
name|r
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|indexno
operator|=
name|g_hash_table_lookup
argument_list|(
name|hash
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexno
condition|)
block|{
name|indexno
operator|=
name|g_new
argument_list|(
name|int
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|indexno
operator|=
name|ncolors
operator|++
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|indexno
argument_list|)
expr_stmt|;
name|key
operator|=
name|g_new
argument_list|(
name|rgbkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
operator|*
name|indexno
expr_stmt|;
block|}
block|}
block|}
comment|/* kick the progress bar */
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|/
operator|(
name|double
operator|)
name|height
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexed
condition|)
block|{
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|ncolors
argument_list|)
expr_stmt|;
name|ncolors
operator|++
expr_stmt|;
comment|/* for transparency */
name|colormap
operator|=
name|g_new
argument_list|(
name|XpmColor
argument_list|,
name|ncolors
argument_list|)
expr_stmt|;
name|cpp
operator|=
operator|(
name|double
operator|)
literal|1.0
operator|+
operator|(
name|double
operator|)
name|log
argument_list|(
name|ncolors
argument_list|)
operator|/
operator|(
name|double
operator|)
name|log
argument_list|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
literal|0
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncolors
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|guchar
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|r
operator|=
operator|*
operator|(
name|cmap
operator|++
operator|)
expr_stmt|;
name|g
operator|=
operator|*
operator|(
name|cmap
operator|++
operator|)
expr_stmt|;
name|b
operator|=
operator|*
operator|(
name|cmap
operator|++
operator|)
expr_stmt|;
name|string
operator|=
name|g_new
argument_list|(
name|char
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"#%02X%02X%02X"
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|,
operator|(
name|int
operator|)
name|g
argument_list|,
operator|(
name|int
operator|)
name|b
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|colormap
operator|=
name|g_new
argument_list|(
name|XpmColor
argument_list|,
name|ncolors
argument_list|)
expr_stmt|;
name|cpp
operator|=
operator|(
name|double
operator|)
literal|1.0
operator|+
operator|(
name|double
operator|)
name|log
argument_list|(
name|ncolors
argument_list|)
operator|/
operator|(
name|double
operator|)
name|log
argument_list|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
literal|0
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
name|g_hash_table_foreach
argument_list|(
name|hash
argument_list|,
name|create_colormap_from_hash
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
block|}
name|image
operator|=
name|g_new
argument_list|(
name|XpmImage
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|image
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|image
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|image
operator|->
name|ncolors
operator|=
name|ncolors
expr_stmt|;
name|image
operator|->
name|cpp
operator|=
name|cpp
expr_stmt|;
name|image
operator|->
name|colorTable
operator|=
name|colormap
expr_stmt|;
name|image
operator|->
name|data
operator|=
name|ibuff
expr_stmt|;
comment|/* do the save */
name|XpmWriteFileFromXpmImage
argument_list|(
name|filename
argument_list|,
name|image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TRUE
expr_stmt|;
name|cleanup
label|:
comment|/* clean up resources */
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibuff
condition|)
name|g_free
argument_list|(
name|ibuff
argument_list|)
expr_stmt|;
comment|/*if (mbuff) g_free(mbuff);*/
if|if
condition|(
name|hash
condition|)
name|g_hash_table_destroy
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|init_gtk (void)
name|init_gtk
parameter_list|(
name|void
parameter_list|)
block|{
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|gint
name|argc
decl_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"xpm"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gtk_rc_parse
argument_list|(
name|gimp_gtkrc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_dialog (void)
name|save_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkObject
modifier|*
name|scale_data
decl_stmt|;
name|dlg
operator|=
name|gimp_dialog_new
argument_list|(
name|_
argument_list|(
literal|"Save as XPM"
argument_list|)
argument_list|,
literal|"xpm"
argument_list|,
name|gimp_plugin_help_func
argument_list|,
literal|"filters/xpm.html"
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|_
argument_list|(
literal|"OK"
argument_list|)
argument_list|,
name|save_ok_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|_
argument_list|(
literal|"Cancel"
argument_list|)
argument_list|,
name|gtk_widget_destroy
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gtk_main_quit
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  parameter settings  */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|_
argument_list|(
literal|"Parameter Settings"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Alpha Threshold:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|xpmvals
operator|.
name|threshold
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xpmvals
operator|.
name|threshold
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|xpmint
operator|.
name|run
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_ok_callback (GtkWidget * widget,gpointer data)
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|xpmint
operator|.
name|run
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

