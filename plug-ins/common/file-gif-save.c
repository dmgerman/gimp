begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIF saving file filter for GIMP  *  *    Copyright  *    - Adam D. Moss  *    - Peter Mattis  *    - Spencer Kimball  *  *      Based around original GIF code by David Koblas.  *  *  * Version 4.1.0 - 2003-06-16  *                        Adam D. Moss -<adam@gimp.org><adam@foxbox.org>  */
end_comment

begin_comment
comment|/*  * This filter uses code taken from the "giftopnm" and "ppmtogif" programs  *    which are part of the "netpbm" package.  */
end_comment

begin_comment
comment|/*  *  "The Graphics Interchange Format(c) is the Copyright property of  *  CompuServe Incorporated.  GIF(sm) is a Service Mark property of  *  CompuServe Incorporated."  */
end_comment

begin_comment
comment|/* Copyright notice for GIF code from which this plugin was long ago     */
end_comment

begin_comment
comment|/* derived (David Koblas has granted permission to relicense):           */
end_comment

begin_comment
comment|/* +-------------------------------------------------------------------+ */
end_comment

begin_comment
comment|/* | Copyright 1990, 1991, 1993, David Koblas.  (koblas@extra.com)     | */
end_comment

begin_comment
comment|/* +-------------------------------------------------------------------+ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-gif-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-gif-save"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-file-gif-save"
end_define

begin_comment
comment|/* Define only one of these to determine which kind of gif's you would like.  * GIF_UN means use uncompressed gifs.  These will be large, but no  * patent problems.  * GIF_RLE uses Run-length-encoding, which should not be covered by the  * patent, but this is not legal advice.  */
end_comment

begin_comment
comment|/* #define GIF_UN */
end_comment

begin_comment
comment|/* #define GIF_RLE */
end_comment

begin_comment
comment|/* uncomment the line below for a little debugging info */
end_comment

begin_comment
comment|/* #define GIFDEBUG yesplease */
end_comment

begin_enum
enum|enum
DECL|enum|__anon286dead00103
block|{
DECL|enumerator|DISPOSE_STORE_VALUE_COLUMN
name|DISPOSE_STORE_VALUE_COLUMN
block|,
DECL|enumerator|DISPOSE_STORE_LABEL_COLUMN
name|DISPOSE_STORE_LABEL_COLUMN
block|}
enum|;
end_enum

begin_enum
enum|enum
DECL|enum|__anon286dead00203
block|{
DECL|enumerator|DISPOSE_UNSPECIFIED
name|DISPOSE_UNSPECIFIED
block|,
DECL|enumerator|DISPOSE_COMBINE
name|DISPOSE_COMBINE
block|,
DECL|enumerator|DISPOSE_REPLACE
name|DISPOSE_REPLACE
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon286dead00308
block|{
DECL|member|interlace
name|gint
name|interlace
decl_stmt|;
DECL|member|save_comment
name|gint
name|save_comment
decl_stmt|;
DECL|member|loop
name|gint
name|loop
decl_stmt|;
DECL|member|default_delay
name|gint
name|default_delay
decl_stmt|;
DECL|member|default_dispose
name|gint
name|default_dispose
decl_stmt|;
DECL|member|always_use_default_delay
name|gboolean
name|always_use_default_delay
decl_stmt|;
DECL|member|always_use_default_dispose
name|gboolean
name|always_use_default_dispose
decl_stmt|;
DECL|member|as_animation
name|gboolean
name|as_animation
decl_stmt|;
DECL|typedef|GIFSaveVals
block|}
name|GIFSaveVals
typedef|;
end_typedef

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpPDBStatusType
name|sanity_check
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
modifier|*
name|image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|bad_bounds_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comment_entry_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|run_mode
specifier|static
name|GimpRunMode
name|run_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|comment_parasite
specifier|static
name|GimpParasite
modifier|*
name|comment_parasite
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|comment_was_edited
specifier|static
name|gboolean
name|comment_was_edited
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For compression code */
end_comment

begin_decl_stmt
DECL|variable|Interlace
specifier|static
name|gint
name|Interlace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gsvals
specifier|static
name|GIFSaveVals
name|gsvals
init|=
block|{
name|FALSE
block|,
comment|/* interlace                            */
name|TRUE
block|,
comment|/* save comment                         */
name|TRUE
block|,
comment|/* loop infinitely                      */
literal|100
block|,
comment|/* default_delay between frames (100ms) */
literal|0
block|,
comment|/* default_dispose = "don't care"       */
name|FALSE
block|,
comment|/* don't always use default_delay       */
name|FALSE
block|,
comment|/* don't always use default_dispose     */
name|FALSE
comment|/* as_animation                         */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Image to save"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name entered"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"interlace"
block|,
literal|"Try to save as interlaced"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"loop"
block|,
literal|"(animated gif) loop infinitely"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"default-delay"
block|,
literal|"(animated gif) Default delay between framese in milliseconds"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"default-dispose"
block|,
literal|"(animated gif) Default disposal type (0=`don't care`, 1=combine, 2=replace)"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"saves files in Compuserve GIF file format"
argument_list|,
literal|"Save a file in Compuserve GIF format, with "
literal|"possible animation, transparency, and comment.  "
literal|"To save an animation, operate on a multi-layer "
literal|"file.  The plug-in will intrepret<50% alpha as "
literal|"transparent.  When run non-interactively, the "
literal|"value for the comment is taken from the "
literal|"'gimp-comment' parasite.  "
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"1995-1997"
argument_list|,
name|N_
argument_list|(
literal|"GIF image"
argument_list|)
argument_list|,
literal|"INDEXED*, GRAY*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"image/gif"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"gif"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|filename
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|,
name|sanitized_image_ID
init|=
literal|0
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|gint32
name|orig_image_ID
decl_stmt|;
name|image_ID
operator|=
name|orig_image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|filename
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
operator|||
name|run_mode
operator|==
name|GIMP_RUN_WITH_LAST_VALS
condition|)
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|sanity_check
argument_list|(
name|filename
argument_list|,
operator|&
name|image_ID
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
comment|/* Get the export options */
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
comment|/* If the sanity check succeeded, the image_ID will point to            * a duplicate image to delete later. */
name|sanitized_image_ID
operator|=
name|image_ID
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|gsvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|image_ID
argument_list|)
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|9
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|gsvals
operator|.
name|interlace
operator|=
operator|(
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|gsvals
operator|.
name|save_comment
operator|=
name|TRUE
expr_stmt|;
comment|/*  no way to to specify that through the PDB  */
name|gsvals
operator|.
name|loop
operator|=
operator|(
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|gsvals
operator|.
name|default_delay
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gsvals
operator|.
name|default_dispose
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|gsvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Create an exportable image based on the export options */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
block|{
name|GimpExportCapabilities
name|capabilities
init|=
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
decl_stmt|;
if|if
condition|(
name|gsvals
operator|.
name|as_animation
condition|)
name|capabilities
operator||=
name|GIMP_EXPORT_CAN_HANDLE_LAYERS
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
name|NULL
argument_list|,
name|capabilities
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
if|if
condition|(
name|sanitized_image_ID
condition|)
name|gimp_image_delete
argument_list|(
name|sanitized_image_ID
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Write the image to file */
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|,
name|orig_image_ID
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
comment|/*  Store psvals data  */
name|gimp_set_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|gsvals
argument_list|,
sizeof|sizeof
argument_list|(
name|GIFSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
name|gimp_image_delete
argument_list|(
name|sanitized_image_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|GIMP_PDB_SUCCESS
operator|&&
name|error
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STRING
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|error
operator|->
name|message
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|globalcomment
specifier|static
name|gchar
modifier|*
name|globalcomment
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ppmtogif.c - read a portable pixmap and produce a GIF file ** ** Based on GIFENCOD by David Rowley<mgardi@watdscu.waterloo.edu>. A ** Lempel-Ziv compression based on "compress". ** ** Modified by Marcel Wijkstra<wijkstra@fwi.uva.nl> ** ** ** Copyright (C) 1989 by Jef Poskanzer. ** ** Permission to use, copy, modify, and distribute this software and its ** documentation for any purpose and without fee is hereby granted, provided ** that the above copyright notice appear in all copies and that both that ** copyright notice and this permission notice appear in supporting ** documentation.  This software is provided "as is" without express or ** implied warranty. ** ** The Graphics Interchange Format(c) is the Copyright property of ** CompuServe Incorporated.  GIF(sm) is a Service Mark property of ** CompuServe Incorporated. */
end_comment

begin_define
DECL|macro|MAXCOLORS
define|#
directive|define
name|MAXCOLORS
value|256
end_define

begin_comment
comment|/*  * Pointer to function returning an int  */
end_comment

begin_typedef
DECL|typedef|ifunptr
typedef|typedef
name|int
function_decl|(
modifier|*
name|ifunptr
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * a code_int must be able to hold 2**BITS values of type int, and also -1  */
end_comment

begin_typedef
DECL|typedef|code_int
typedef|typedef
name|int
name|code_int
typedef|;
end_typedef

begin_typedef
DECL|typedef|count_int
typedef|typedef
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_function_decl
specifier|static
name|gint
name|find_unused_ia_colour
parameter_list|(
specifier|const
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
name|numpixels
parameter_list|,
name|gint
name|num_indices
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|special_flatten_indexed_alpha
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
name|transparent
parameter_list|,
name|gint
name|numpixels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|colors_to_bpp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpp_to_colors
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_pixel
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gif_next_pixel
parameter_list|(
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bump_pixel
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gif_encode_header
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|gboolean
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gif_encode_graphic_control_ext
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gif_encode_image_data
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|ifunptr
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gif_encode_close
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gif_encode_loop_ext
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gif_encode_comment_ext
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|gchar
modifier|*
name|comment
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|rowstride
specifier|static
name|gint
name|rowstride
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pixels
specifier|static
name|guchar
modifier|*
name|pixels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_progress
specifier|static
name|gint
name|cur_progress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_progress
specifier|static
name|gint
name|max_progress
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|compress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|no_compress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rle_compress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|normal_compress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|put_word
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output
parameter_list|(
name|code_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cl_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cl_hash
parameter_list|(
name|count_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_err
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|char_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|char_out
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_char
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|gint
DECL|function|find_unused_ia_colour (const guchar * pixels,gint numpixels,gint num_indices,gint * colors)
name|find_unused_ia_colour
parameter_list|(
specifier|const
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
name|numpixels
parameter_list|,
name|gint
name|num_indices
parameter_list|,
name|gint
modifier|*
name|colors
parameter_list|)
block|{
name|gboolean
name|ix_used
index|[
literal|256
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_printerr
argument_list|(
literal|"GIF: fuiac: Image claims to use %d/%d indices - finding free "
literal|"index...\n"
argument_list|,
operator|*
name|colors
argument_list|,
name|num_indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|ix_used
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
condition|)
name|ix_used
index|[
name|pixels
index|[
name|i
operator|*
literal|2
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|num_indices
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|ix_used
index|[
name|i
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_printerr
argument_list|(
literal|"GIF: Found unused colour index %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|i
return|;
block|}
block|}
comment|/* Couldn't find an unused colour index within the number of      bits per pixel we wanted.  Will have to increment the number      of colours in the image and assign a transparent pixel there. */
if|if
condition|(
operator|*
name|colors
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|colors
operator|)
operator|++
expr_stmt|;
name|g_printerr
argument_list|(
literal|"GIF: 2nd pass "
literal|"- Increasing bounds and using colour index %d.\n"
argument_list|,
operator|*
name|colors
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|colors
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Couldn't simply reduce colors further. Saving as opaque."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|special_flatten_indexed_alpha (guchar * pixels,gint transparent,gint numpixels)
name|special_flatten_indexed_alpha
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|gint
name|transparent
parameter_list|,
name|gint
name|numpixels
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
comment|/* Each transparent pixel in the image is mapped to a uniform value for      encoding, if image already has<=255 colours */
if|if
condition|(
name|transparent
operator|==
operator|-
literal|1
condition|)
comment|/* tough, no indices left for the trans. index */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixels
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
else|else
comment|/* make transparent */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|&
literal|128
operator|)
condition|)
block|{
name|pixels
index|[
name|i
index|]
operator|=
operator|(
name|guchar
operator|)
name|transparent
expr_stmt|;
block|}
else|else
block|{
name|pixels
index|[
name|i
index|]
operator|=
name|pixels
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|parse_ms_tag (const gchar * str)
name|parse_ms_tag
parameter_list|(
specifier|const
name|gchar
modifier|*
name|str
parameter_list|)
block|{
name|gint
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|offset
init|=
literal|0
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|find_another_bra
label|:
while|while
condition|(
operator|(
name|offset
operator|<
name|length
operator|)
operator|&&
operator|(
name|str
index|[
name|offset
index|]
operator|!=
literal|'('
operator|)
condition|)
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|length
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|g_ascii_isdigit
argument_list|(
name|str
index|[
operator|++
name|offset
index|]
argument_list|)
condition|)
goto|goto
name|find_another_bra
goto|;
do|do
block|{
name|sum
operator|*=
literal|10
expr_stmt|;
name|sum
operator|+=
name|str
index|[
name|offset
index|]
operator|-
literal|'0'
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|offset
operator|<
name|length
operator|)
operator|&&
operator|(
name|g_ascii_isdigit
argument_list|(
name|str
index|[
name|offset
index|]
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|length
operator|-
name|offset
operator|<=
literal|2
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
if|if
condition|(
operator|(
name|g_ascii_toupper
argument_list|(
name|str
index|[
name|offset
index|]
argument_list|)
operator|!=
literal|'M'
operator|)
operator|||
operator|(
name|g_ascii_toupper
argument_list|(
name|str
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|'S'
operator|)
condition|)
return|return
operator|-
literal|4
return|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|parse_disposal_tag (const gchar * str)
name|parse_disposal_tag
parameter_list|(
specifier|const
name|gchar
modifier|*
name|str
parameter_list|)
block|{
name|gint
name|offset
init|=
literal|0
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|offset
operator|+
literal|9
operator|)
operator|<=
name|length
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|offset
index|]
argument_list|,
literal|"(combine)"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0x01
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|offset
index|]
argument_list|,
literal|"(replace)"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0x02
operator|)
return|;
name|offset
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|gsvals
operator|.
name|default_dispose
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpPDBStatusType
DECL|function|sanity_check (const gchar * filename,gint32 * image_ID,GError ** error)
name|sanity_check
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
modifier|*
name|image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint32
modifier|*
name|layers
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gint
name|image_width
decl_stmt|;
name|gint
name|image_height
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|image_width
operator|=
name|gimp_image_width
argument_list|(
operator|*
name|image_ID
argument_list|)
expr_stmt|;
name|image_height
operator|=
name|gimp_image_height
argument_list|(
operator|*
name|image_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_width
operator|>
name|G_MAXUSHORT
operator|||
name|image_height
operator|>
name|G_MAXUSHORT
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Unable to save '%s'.  "
literal|"The GIF file format does not support images that are "
literal|"more than %d pixels wide or tall."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|G_MAXUSHORT
argument_list|)
expr_stmt|;
return|return
name|GIMP_PDB_EXECUTION_ERROR
return|;
block|}
comment|/*** Iterate through the layers to make sure they're all ***/
comment|/*** within the bounds of the image                      ***/
operator|*
name|image_ID
operator|=
name|gimp_image_duplicate
argument_list|(
operator|*
name|image_ID
argument_list|)
expr_stmt|;
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
operator|*
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlayers
condition|;
name|i
operator|++
control|)
block|{
name|gint
name|offset_x
decl_stmt|;
name|gint
name|offset_y
decl_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_x
operator|<
literal|0
operator|||
name|offset_y
operator|<
literal|0
operator|||
name|offset_x
operator|+
name|gimp_drawable_width
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
operator|>
name|image_width
operator|||
name|offset_y
operator|+
name|gimp_drawable_height
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
operator|>
name|image_height
condition|)
block|{
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
comment|/* Image has illegal bounds - ask the user what it wants to do */
comment|/* Do the crop if we can't talk to the user, or if we asked            * the user and they said yes.            */
if|if
condition|(
operator|(
name|run_mode
operator|==
name|GIMP_RUN_NONINTERACTIVE
operator|)
operator|||
name|bad_bounds_dialog
argument_list|()
condition|)
block|{
name|gimp_image_crop
argument_list|(
operator|*
name|image_ID
argument_list|,
name|image_width
argument_list|,
name|image_height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|GIMP_PDB_SUCCESS
return|;
block|}
else|else
block|{
name|gimp_image_delete
argument_list|(
operator|*
name|image_ID
argument_list|)
expr_stmt|;
return|return
name|GIMP_PDB_CANCEL
return|;
block|}
block|}
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
return|return
name|GIMP_PDB_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_image (const gchar * filename,gint32 image_ID,gint32 drawable_ID,gint32 orig_image_ID,GError ** error)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|gint32
name|orig_image_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|GimpImageType
name|drawable_type
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|gint
name|Red
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|gint
name|Green
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|gint
name|Blue
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|guint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|gint
name|BitsPerPixel
decl_stmt|,
name|liberalBPP
init|=
literal|0
decl_stmt|,
name|useBPP
init|=
literal|0
decl_stmt|;
name|gint
name|colors
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|transparent
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|gint32
modifier|*
name|layers
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gboolean
name|is_gif89
init|=
name|FALSE
decl_stmt|;
name|gint
name|Delay89
decl_stmt|;
name|gint
name|Disposal
decl_stmt|;
name|gchar
modifier|*
name|layer_name
decl_stmt|;
name|GimpRGB
name|background
decl_stmt|;
name|guchar
name|bgred
decl_stmt|,
name|bggreen
decl_stmt|,
name|bgblue
decl_stmt|;
name|guchar
name|bgindex
init|=
literal|0
decl_stmt|;
name|guint
name|best_error
init|=
literal|0xFFFFFFFF
decl_stmt|;
comment|/* Save the comment back to the ImageID, if appropriate */
if|if
condition|(
name|globalcomment
operator|!=
name|NULL
operator|&&
name|comment_was_edited
condition|)
block|{
name|comment_parasite
operator|=
name|gimp_parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|GIMP_PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|globalcomment
argument_list|)
operator|+
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|globalcomment
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|orig_image_ID
argument_list|,
name|comment_parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|comment_parasite
argument_list|)
expr_stmt|;
name|comment_parasite
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The GIF spec says 7bit ASCII for the comment block. */
if|if
condition|(
name|gsvals
operator|.
name|save_comment
operator|&&
name|globalcomment
condition|)
block|{
specifier|const
name|gchar
modifier|*
name|c
init|=
name|globalcomment
decl_stmt|;
name|gint
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
name|strlen
argument_list|(
name|c
argument_list|)
init|;
name|len
condition|;
name|c
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|guchar
operator|)
operator|*
name|c
operator|>
literal|127
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The GIF format only supports comments in "
literal|"7bit ASCII encoding. No comment is saved."
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
name|globalcomment
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* get a list of layers for this image_ID */
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|layers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If the image has multiple layers (i.e. will be animated), a comment,      or transparency, then it must be encoded as a GIF89a file, not a vanilla      GIF87a. */
if|if
condition|(
name|nlayers
operator|>
literal|1
condition|)
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|gsvals
operator|.
name|save_comment
condition|)
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|drawable_type
condition|)
block|{
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_image_get_colormap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|gimp_context_get_background
argument_list|(
operator|&
name|background
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|background
argument_list|,
operator|&
name|bgred
argument_list|,
operator|&
name|bggreen
argument_list|,
operator|&
name|bgblue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
name|Green
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
name|Blue
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
name|bgred
expr_stmt|;
name|Green
index|[
name|i
index|]
operator|=
name|bggreen
expr_stmt|;
name|Blue
index|[
name|i
index|]
operator|=
name|bgblue
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|colors
operator|=
literal|256
expr_stmt|;
comment|/* FIXME: Not ideal. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
name|Green
index|[
name|i
index|]
operator|=
name|Blue
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|drawable_type
operator|==
name|GIMP_GRAYA_IMAGE
condition|)
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y'A u8"
argument_list|)
expr_stmt|;
else|else
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot save RGB color images. Convert to "
literal|"indexed color or grayscale first."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* find earliest index in palette which is closest to the background      colour, and ATTEMPT to use that as the GIF's default background colour. */
for|for
control|(
name|i
operator|=
literal|255
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|guint
name|local_error
init|=
literal|0
decl_stmt|;
name|local_error
operator|+=
operator|(
name|Red
index|[
name|i
index|]
operator|-
name|bgred
operator|)
operator|*
operator|(
name|Red
index|[
name|i
index|]
operator|-
name|bgred
operator|)
expr_stmt|;
name|local_error
operator|+=
operator|(
name|Green
index|[
name|i
index|]
operator|-
name|bggreen
operator|)
operator|*
operator|(
name|Green
index|[
name|i
index|]
operator|-
name|bggreen
operator|)
expr_stmt|;
name|local_error
operator|+=
operator|(
name|Blue
index|[
name|i
index|]
operator|-
name|bgblue
operator|)
operator|*
operator|(
name|Blue
index|[
name|i
index|]
operator|-
name|bgblue
operator|)
expr_stmt|;
if|if
condition|(
name|local_error
operator|<=
name|best_error
condition|)
block|{
name|bgindex
operator|=
name|i
expr_stmt|;
name|best_error
operator|=
name|local_error
expr_stmt|;
block|}
block|}
comment|/* open the destination file for writing */
name|outfile
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* init the progress meter */
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the GIFheader */
if|if
condition|(
name|colors
operator|<
literal|256
condition|)
block|{
comment|/* we keep track of how many bits we promised to have in liberalBPP,          so that we don't accidentally come under this when doing          clever transparency stuff where we can re-use wasted indices. */
name|liberalBPP
operator|=
name|BitsPerPixel
operator|=
name|colors_to_bpp
argument_list|(
name|colors
operator|+
operator|(
operator|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|liberalBPP
operator|=
name|BitsPerPixel
operator|=
name|colors_to_bpp
argument_list|(
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
condition|)
block|{
name|g_printerr
argument_list|(
literal|"GIF: Too many colours?\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cols
operator|=
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|rows
operator|=
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|Interlace
operator|=
name|gsvals
operator|.
name|interlace
expr_stmt|;
name|gif_encode_header
argument_list|(
name|outfile
argument_list|,
name|is_gif89
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|bgindex
argument_list|,
name|BitsPerPixel
argument_list|,
name|Red
argument_list|,
name|Green
argument_list|,
name|Blue
argument_list|,
name|get_pixel
argument_list|)
expr_stmt|;
comment|/* If the image has multiple layers it'll be made into an      animated GIF, so write out the infinite-looping extension */
if|if
condition|(
operator|(
name|nlayers
operator|>
literal|1
operator|)
operator|&&
operator|(
name|gsvals
operator|.
name|loop
operator|)
condition|)
name|gif_encode_loop_ext
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write comment extension - mustn't be written before the looping ext. */
if|if
condition|(
name|gsvals
operator|.
name|save_comment
operator|&&
name|globalcomment
condition|)
block|{
name|gif_encode_comment_ext
argument_list|(
name|outfile
argument_list|,
name|globalcomment
argument_list|)
expr_stmt|;
block|}
comment|/*** Now for each layer in the image, save an image in a compound GIF ***/
comment|/************************************************************************/
name|cur_progress
operator|=
literal|0
expr_stmt|;
name|max_progress
operator|=
name|nlayers
operator|*
name|rows
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nlayers
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|cur_progress
operator|=
operator|(
name|nlayers
operator|-
name|i
operator|)
operator|*
name|rows
control|)
block|{
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|cols
operator|=
name|gimp_drawable_width
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rows
operator|=
name|gimp_drawable_height
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rowstride
operator|=
name|cols
expr_stmt|;
name|pixels
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
operator|(
name|cols
operator|*
name|rows
operator|*
operator|(
operator|(
operator|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
operator|)
operator|||
operator|(
name|drawable_type
operator|==
name|GIMP_GRAYA_IMAGE
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|pixels
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
comment|/* sort out whether we need to do transparency jiggery-pokery */
if|if
condition|(
operator|(
name|drawable_type
operator|==
name|GIMP_INDEXEDA_IMAGE
operator|)
operator|||
operator|(
name|drawable_type
operator|==
name|GIMP_GRAYA_IMAGE
operator|)
condition|)
block|{
comment|/* Try to find an entry which isn't actually used in the              image, for a transparency index. */
name|transparent
operator|=
name|find_unused_ia_colour
argument_list|(
name|pixels
argument_list|,
name|cols
operator|*
name|rows
argument_list|,
name|bpp_to_colors
argument_list|(
name|colors_to_bpp
argument_list|(
name|colors
argument_list|)
argument_list|)
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|special_flatten_indexed_alpha
argument_list|(
name|pixels
argument_list|,
name|transparent
argument_list|,
name|cols
operator|*
name|rows
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|transparent
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|BitsPerPixel
operator|=
name|colors_to_bpp
argument_list|(
name|colors
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitsPerPixel
operator|!=
name|liberalBPP
condition|)
block|{
comment|/* We were able to re-use an index within the existing bitspace,              whereas the estimate in the header was pessimistic but still              needs to be upheld... */
ifdef|#
directive|ifdef
name|GIFDEBUG
specifier|static
name|gboolean
name|onceonly
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|onceonly
condition|)
block|{
name|g_warning
argument_list|(
literal|"Promised %d bpp, pondered writing chunk with %d bpp!"
argument_list|,
name|liberalBPP
argument_list|,
name|BitsPerPixel
argument_list|)
expr_stmt|;
name|onceonly
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|useBPP
operator|=
operator|(
name|BitsPerPixel
operator|>
name|liberalBPP
operator|)
condition|?
name|BitsPerPixel
else|:
name|liberalBPP
expr_stmt|;
if|if
condition|(
name|is_gif89
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
name|gsvals
operator|.
name|always_use_default_dispose
condition|)
block|{
name|layer_name
operator|=
name|gimp_item_get_name
argument_list|(
name|layers
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|Disposal
operator|=
name|parse_disposal_tag
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Disposal
operator|=
name|gsvals
operator|.
name|default_dispose
expr_stmt|;
block|}
name|layer_name
operator|=
name|gimp_item_get_name
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Delay89
operator|=
name|parse_ms_tag
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delay89
operator|<
literal|0
operator|||
name|gsvals
operator|.
name|always_use_default_delay
condition|)
name|Delay89
operator|=
operator|(
name|gsvals
operator|.
name|default_delay
operator|+
literal|5
operator|)
operator|/
literal|10
expr_stmt|;
else|else
name|Delay89
operator|=
operator|(
name|Delay89
operator|+
literal|5
operator|)
operator|/
literal|10
expr_stmt|;
comment|/* don't allow a CPU-sucking completely 0-delay looping anim */
if|if
condition|(
operator|(
name|nlayers
operator|>
literal|1
operator|)
operator|&&
name|gsvals
operator|.
name|loop
operator|&&
operator|(
name|Delay89
operator|==
literal|0
operator|)
condition|)
block|{
specifier|static
name|gboolean
name|onceonly
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|onceonly
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Delay inserted to prevent evil "
literal|"CPU-sucking animation."
argument_list|)
argument_list|)
expr_stmt|;
name|onceonly
operator|=
name|TRUE
expr_stmt|;
block|}
name|Delay89
operator|=
literal|1
expr_stmt|;
block|}
name|gif_encode_graphic_control_ext
argument_list|(
name|outfile
argument_list|,
name|Disposal
argument_list|,
name|Delay89
argument_list|,
name|nlayers
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|transparent
argument_list|,
name|useBPP
argument_list|,
name|get_pixel
argument_list|)
expr_stmt|;
block|}
name|gif_encode_image_data
argument_list|(
name|outfile
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
operator|(
name|rows
operator|>
literal|4
operator|)
condition|?
name|gsvals
operator|.
name|interlace
else|:
literal|0
argument_list|,
name|useBPP
argument_list|,
name|get_pixel
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
name|gif_encode_close
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|bad_bounds_dialog (void)
name|bad_bounds_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|gboolean
name|crop
decl_stmt|;
name|dialog
operator|=
name|gtk_message_dialog_new
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|GTK_MESSAGE_WARNING
argument_list|,
name|GTK_BUTTONS_NONE
argument_list|,
name|_
argument_list|(
literal|"The image you are trying to save as a "
literal|"GIF contains layers which extend beyond "
literal|"the actual borders of the image."
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_dialog_add_buttons
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_STOCK_CANCEL
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
name|GIMP_STOCK_TOOL_CROP
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_dialog_set_alternative_button_order
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|GTK_RESPONSE_OK
argument_list|,
name|GTK_RESPONSE_CANCEL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_window_set_transient
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dialog
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_message_dialog_format_secondary_text
argument_list|(
name|GTK_MESSAGE_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"The GIF file format does not "
literal|"allow this.  You may choose "
literal|"whether to crop all of the "
literal|"layers to the image borders, "
literal|"or cancel this save."
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|crop
operator|=
operator|(
name|gtk_dialog_run
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|crop
return|;
block|}
end_function

begin_function
specifier|static
name|GtkWidget
modifier|*
DECL|function|file_gif_toggle_button_init (GtkBuilder * builder,const gchar * name,gboolean initial_value,gboolean * value_pointer)
name|file_gif_toggle_button_init
parameter_list|(
name|GtkBuilder
modifier|*
name|builder
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gboolean
name|initial_value
parameter_list|,
name|gboolean
modifier|*
name|value_pointer
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|toggle
init|=
name|NULL
decl_stmt|;
name|toggle
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
name|value_pointer
argument_list|)
expr_stmt|;
return|return
name|toggle
return|;
block|}
end_function

begin_function
specifier|static
name|GtkWidget
modifier|*
DECL|function|file_gif_spin_button_int_init (GtkBuilder * builder,const gchar * name,int initial_value,int * value_pointer)
name|file_gif_spin_button_int_init
parameter_list|(
name|GtkBuilder
modifier|*
name|builder
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|int
name|initial_value
parameter_list|,
name|int
modifier|*
name|value_pointer
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|spin_button
init|=
name|NULL
decl_stmt|;
name|GtkAdjustment
modifier|*
name|adjustment
init|=
name|NULL
decl_stmt|;
name|spin_button
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|adjustment
operator|=
name|gtk_spin_button_get_adjustment
argument_list|(
name|GTK_SPIN_BUTTON
argument_list|(
name|spin_button
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_adjustment_set_value
argument_list|(
name|adjustment
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|adjustment
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|gsvals
operator|.
name|default_delay
argument_list|)
expr_stmt|;
return|return
name|spin_button
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|file_gif_combo_box_int_update_value (GtkComboBox * combo,gint * value)
name|file_gif_combo_box_int_update_value
parameter_list|(
name|GtkComboBox
modifier|*
name|combo
parameter_list|,
name|gint
modifier|*
name|value
parameter_list|)
block|{
name|GtkTreeIter
name|iter
decl_stmt|;
if|if
condition|(
name|gtk_combo_box_get_active_iter
argument_list|(
name|GTK_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
name|gtk_tree_model_get
argument_list|(
name|gtk_combo_box_get_model
argument_list|(
name|GTK_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|,
name|DISPOSE_STORE_VALUE_COLUMN
argument_list|,
name|value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|GtkWidget
modifier|*
DECL|function|file_gif_combo_box_int_init (GtkBuilder * builder,const gchar * name,int initial_value,int * value_pointer,const gchar * first_label,gint first_value,...)
name|file_gif_combo_box_int_init
parameter_list|(
name|GtkBuilder
modifier|*
name|builder
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|int
name|initial_value
parameter_list|,
name|int
modifier|*
name|value_pointer
parameter_list|,
specifier|const
name|gchar
modifier|*
name|first_label
parameter_list|,
name|gint
name|first_value
parameter_list|,
modifier|...
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|combo
init|=
name|NULL
decl_stmt|;
name|GtkListStore
modifier|*
name|store
init|=
name|NULL
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
name|gint
name|value
init|=
literal|0
decl_stmt|;
name|GtkTreeIter
name|iter
init|=
block|{
literal|0
block|, }
decl_stmt|;
name|va_list
name|values
decl_stmt|;
name|combo
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|=
name|GTK_LIST_STORE
argument_list|(
name|gtk_combo_box_get_model
argument_list|(
name|GTK_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate */
name|va_start
argument_list|(
name|values
argument_list|,
name|first_value
argument_list|)
expr_stmt|;
for|for
control|(
name|label
operator|=
name|first_label
operator|,
name|value
operator|=
name|first_value
init|;
name|label
condition|;
name|label
operator|=
name|va_arg
argument_list|(
name|values
argument_list|,
specifier|const
name|gchar
operator|*
argument_list|)
operator|,
name|value
operator|=
name|va_arg
argument_list|(
name|values
argument_list|,
name|gint
argument_list|)
control|)
block|{
name|gtk_list_store_append
argument_list|(
name|store
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_list_store_set
argument_list|(
name|store
argument_list|,
operator|&
name|iter
argument_list|,
name|DISPOSE_STORE_VALUE_COLUMN
argument_list|,
name|value
argument_list|,
name|DISPOSE_STORE_LABEL_COLUMN
argument_list|,
name|label
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|/* Set initial value */
name|gtk_tree_model_iter_nth_child
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|store
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|,
name|NULL
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|gtk_combo_box_set_active_iter
argument_list|(
name|GTK_COMBO_BOX
argument_list|(
name|combo
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
comment|/* Arrange update of value */
name|g_signal_connect
argument_list|(
name|combo
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|file_gif_combo_box_int_update_value
argument_list|)
argument_list|,
name|value_pointer
argument_list|)
expr_stmt|;
return|return
name|combo
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_dialog (gint32 image_ID)
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GtkBuilder
modifier|*
name|builder
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|ui_file
init|=
name|NULL
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|text_view
decl_stmt|;
name|GtkTextBuffer
modifier|*
name|text_buffer
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GimpParasite
modifier|*
name|GIF2_CMNT
decl_stmt|;
name|gint32
name|nlayers
decl_stmt|;
name|gboolean
name|animation_supported
init|=
name|FALSE
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|animation_supported
operator|=
name|nlayers
operator|>
literal|1
expr_stmt|;
name|dialog
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"GIF"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|SAVE_PROC
argument_list|)
expr_stmt|;
comment|/* GtkBuilder init */
name|builder
operator|=
name|gtk_builder_new
argument_list|()
expr_stmt|;
name|ui_file
operator|=
name|g_build_filename
argument_list|(
name|gimp_data_directory
argument_list|()
argument_list|,
literal|"ui/plug-ins/plug-in-file-gif.ui"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gtk_builder_add_from_file
argument_list|(
name|builder
argument_list|,
name|ui_file
argument_list|,
operator|&
name|error
argument_list|)
condition|)
name|g_printerr
argument_list|(
name|_
argument_list|(
literal|"Error loading UI file '%s':\n%s"
argument_list|)
argument_list|,
name|ui_file
argument_list|,
name|error
condition|?
name|error
operator|->
name|message
else|:
literal|"???"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ui_file
argument_list|)
expr_stmt|;
comment|/* Main vbox */
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|,
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"main-vbox"
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  regular gif parameter settings  */
name|file_gif_toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"interlace"
argument_list|,
name|gsvals
operator|.
name|interlace
argument_list|,
operator|&
name|gsvals
operator|.
name|interlace
argument_list|)
expr_stmt|;
name|file_gif_toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"save-comment"
argument_list|,
name|gsvals
operator|.
name|save_comment
argument_list|,
operator|&
name|gsvals
operator|.
name|save_comment
argument_list|)
expr_stmt|;
name|file_gif_toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"as-animation"
argument_list|,
name|gsvals
operator|.
name|as_animation
argument_list|,
operator|&
name|gsvals
operator|.
name|as_animation
argument_list|)
expr_stmt|;
name|text_view
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"comment"
argument_list|)
argument_list|)
expr_stmt|;
name|text_buffer
operator|=
name|gtk_text_view_get_buffer
argument_list|(
name|GTK_TEXT_VIEW
argument_list|(
name|text_view
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|globalcomment
condition|)
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
name|GIF2_CMNT
operator|=
name|gimp_image_get_parasite
argument_list|(
name|image_ID
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIF2_CMNT
condition|)
block|{
name|globalcomment
operator|=
name|g_strndup
argument_list|(
name|gimp_parasite_data
argument_list|(
name|GIF2_CMNT
argument_list|)
argument_list|,
name|gimp_parasite_data_size
argument_list|(
name|GIF2_CMNT
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|GIF2_CMNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|globalcomment
operator|=
name|gimp_get_default_comment
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|globalcomment
condition|)
name|gtk_text_buffer_set_text
argument_list|(
name|text_buffer
argument_list|,
name|globalcomment
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|text_buffer
argument_list|,
literal|"changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|comment_entry_callback
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  additional animated gif parameter settings  */
name|file_gif_toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"loop-forever"
argument_list|,
name|gsvals
operator|.
name|loop
argument_list|,
operator|&
name|gsvals
operator|.
name|loop
argument_list|)
expr_stmt|;
comment|/* default_delay entry field */
name|file_gif_spin_button_int_init
argument_list|(
name|builder
argument_list|,
literal|"delay-spin"
argument_list|,
name|gsvals
operator|.
name|default_delay
argument_list|,
operator|&
name|gsvals
operator|.
name|default_delay
argument_list|)
expr_stmt|;
comment|/* Disposal selector */
name|file_gif_combo_box_int_init
argument_list|(
name|builder
argument_list|,
literal|"dispose-combo"
argument_list|,
name|gsvals
operator|.
name|default_dispose
argument_list|,
operator|&
name|gsvals
operator|.
name|default_dispose
argument_list|,
name|_
argument_list|(
literal|"I don't care"
argument_list|)
argument_list|,
name|DISPOSE_UNSPECIFIED
argument_list|,
name|_
argument_list|(
literal|"Cumulative layers (combine)"
argument_list|)
argument_list|,
name|DISPOSE_COMBINE
argument_list|,
name|_
argument_list|(
literal|"One frame per layer (replace)"
argument_list|)
argument_list|,
name|DISPOSE_REPLACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The "Always use default values" toggles */
name|file_gif_toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"use-default-delay"
argument_list|,
name|gsvals
operator|.
name|always_use_default_delay
argument_list|,
operator|&
name|gsvals
operator|.
name|always_use_default_delay
argument_list|)
expr_stmt|;
name|file_gif_toggle_button_init
argument_list|(
name|builder
argument_list|,
literal|"use-default-dispose"
argument_list|,
name|gsvals
operator|.
name|always_use_default_dispose
argument_list|,
operator|&
name|gsvals
operator|.
name|always_use_default_dispose
argument_list|)
expr_stmt|;
name|frame
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"animation-frame"
argument_list|)
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|GTK_WIDGET
argument_list|(
name|gtk_builder_get_object
argument_list|(
name|builder
argument_list|,
literal|"as-animation"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_set_sensitive
argument_list|(
name|toggle
argument_list|,
name|animation_supported
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|animation_supported
condition|)
name|gimp_help_set_help_data
argument_list|(
name|toggle
argument_list|,
name|_
argument_list|(
literal|"You can only export as animation when the "
literal|"image has more than one layer. The image "
literal|"you are trying to export only has one "
literal|"layer."
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_object_bind_property
argument_list|(
name|toggle
argument_list|,
literal|"active"
argument_list|,
name|frame
argument_list|,
literal|"sensitive"
argument_list|,
name|G_BINDING_SYNC_CREATE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|colors_to_bpp (int colors)
name|colors_to_bpp
parameter_list|(
name|int
name|colors
parameter_list|)
block|{
name|int
name|bpp
decl_stmt|;
if|if
condition|(
name|colors
operator|<=
literal|2
condition|)
name|bpp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|4
condition|)
name|bpp
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|8
condition|)
name|bpp
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|16
condition|)
name|bpp
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|32
condition|)
name|bpp
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|64
condition|)
name|bpp
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|128
condition|)
name|bpp
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|256
condition|)
name|bpp
operator|=
literal|8
expr_stmt|;
else|else
block|{
name|g_warning
argument_list|(
literal|"GIF: colors_to_bpp - Eep! too many colours: %d\n"
argument_list|,
name|colors
argument_list|)
expr_stmt|;
return|return
literal|8
return|;
block|}
return|return
name|bpp
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bpp_to_colors (int bpp)
name|bpp_to_colors
parameter_list|(
name|int
name|bpp
parameter_list|)
block|{
name|int
name|colors
decl_stmt|;
if|if
condition|(
name|bpp
operator|>
literal|8
condition|)
block|{
name|g_warning
argument_list|(
literal|"GIF: bpp_to_colors - Eep! bpp==%d !\n"
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
literal|256
return|;
block|}
name|colors
operator|=
literal|1
operator|<<
name|bpp
expr_stmt|;
return|return
operator|(
name|colors
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|get_pixel (int x,int y)
name|get_pixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
operator|*
operator|(
name|pixels
operator|+
operator|(
name|rowstride
operator|*
operator|(
name|long
operator|)
name|y
operator|)
operator|+
operator|(
name|long
operator|)
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * GIFENCODE.C    - GIF Image compression interface  *  * GIFEncode( FName, GHeight, GWidth, GInterlace, Background, Transparent,  *            BitsPerPixel, Red, Green, Blue, get_pixel )  *  *****************************************************************************/
end_comment

begin_decl_stmt
DECL|variable|Width
DECL|variable|Height
specifier|static
name|gint
name|Width
decl_stmt|,
name|Height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curx
DECL|variable|cury
specifier|static
name|gint
name|curx
decl_stmt|,
name|cury
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|CountDown
specifier|static
name|glong
name|CountDown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|Pass
specifier|static
name|gint
name|Pass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Bump the 'curx' and 'cury' to point to the next pixel  */
end_comment

begin_function
specifier|static
name|void
DECL|function|bump_pixel (void)
name|bump_pixel
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * Bump the current X position    */
name|curx
operator|++
expr_stmt|;
comment|/*    * If we are at the end of a scan line, set curx back to the beginning    * If we are interlaced, bump the cury to the appropriate spot,    * otherwise, just increment it.    */
if|if
condition|(
name|curx
operator|==
name|Width
condition|)
block|{
name|cur_progress
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cur_progress
operator|%
literal|20
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|cur_progress
operator|/
operator|(
name|gdouble
operator|)
name|max_progress
argument_list|)
expr_stmt|;
name|curx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Interlace
condition|)
operator|++
name|cury
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|Pass
condition|)
block|{
case|case
literal|0
case|:
name|cury
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|cury
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|cury
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|cury
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the next pixel from the image  */
end_comment

begin_function
specifier|static
name|int
DECL|function|gif_next_pixel (ifunptr getpixel)
name|gif_next_pixel
parameter_list|(
name|ifunptr
name|getpixel
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|CountDown
operator|==
literal|0
condition|)
return|return
name|EOF
return|;
operator|--
name|CountDown
expr_stmt|;
name|r
operator|=
call|(
modifier|*
name|getpixel
call|)
argument_list|(
name|curx
argument_list|,
name|cury
argument_list|)
expr_stmt|;
name|bump_pixel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* public */
end_comment

begin_function
specifier|static
name|void
DECL|function|gif_encode_header (FILE * fp,gboolean gif89,int GWidth,int GHeight,int Background,int BitsPerPixel,int Red[],int Green[],int Blue[],ifunptr get_pixel)
name|gif_encode_header
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gboolean
name|gif89
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|Background
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|int
name|Red
index|[]
parameter_list|,
name|int
name|Green
index|[]
parameter_list|,
name|int
name|Blue
index|[]
parameter_list|,
name|ifunptr
name|get_pixel
parameter_list|)
block|{
name|int
name|B
decl_stmt|;
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write the Magic header    */
name|fwrite
argument_list|(
name|gif89
condition|?
literal|"GIF89a"
else|:
literal|"GIF87a"
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the screen width and height    */
name|put_word
argument_list|(
name|RWidth
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|RHeight
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Indicate that there is a global colour map    */
name|B
operator|=
literal|0x80
expr_stmt|;
comment|/* Yes, there is a color map */
comment|/*    * OR in the resolution    */
name|B
operator||=
operator|(
name|Resolution
operator|-
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
comment|/*    * OR in the Bits per Pixel    */
name|B
operator||=
operator|(
name|BitsPerPixel
operator|-
literal|1
operator|)
expr_stmt|;
comment|/*    * Write it out    */
name|fputc
argument_list|(
name|B
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the Background colour    */
name|fputc
argument_list|(
name|Background
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Byte of 0's (future expansion)    */
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the Global Colour Map    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ColorMapSize
condition|;
name|i
operator|++
control|)
block|{
name|fputc
argument_list|(
name|Red
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Green
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Blue
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gif_encode_graphic_control_ext (FILE * fp,int Disposal,int Delay89,int NumFramesInImage,int GWidth,int GHeight,int Transparent,int BitsPerPixel,ifunptr get_pixel)
name|gif_encode_graphic_control_ext
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|Disposal
parameter_list|,
name|int
name|Delay89
parameter_list|,
name|int
name|NumFramesInImage
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|Transparent
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|ifunptr
name|get_pixel
parameter_list|)
block|{
name|Width
operator|=
name|GWidth
expr_stmt|;
name|Height
operator|=
name|GHeight
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write out extension for transparent colour index, if necessary.    */
if|if
condition|(
operator|(
name|Transparent
operator|>=
literal|0
operator|)
operator|||
operator|(
name|NumFramesInImage
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* Extension Introducer - fixed. */
name|fputc
argument_list|(
literal|'!'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Graphic Control Label - fixed. */
name|fputc
argument_list|(
literal|0xf9
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Block Size - fixed. */
name|fputc
argument_list|(
literal|4
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Packed Fields - XXXdddut (d=disposal, u=userInput, t=transFlag) */
comment|/*                    s8421                                        */
name|fputc
argument_list|(
operator|(
operator|(
name|Transparent
operator|>=
literal|0
operator|)
condition|?
literal|0x01
else|:
literal|0x00
operator|)
comment|/* TRANSPARENCY */
comment|/* DISPOSAL */
operator||
operator|(
operator|(
name|NumFramesInImage
operator|>
literal|1
operator|)
condition|?
operator|(
name|Disposal
operator|<<
literal|2
operator|)
else|:
literal|0x00
operator|)
argument_list|,
comment|/* 0x03 or 0x01 build frames cumulatively */
comment|/* 0x02 clears frame before drawing */
comment|/* 0x00 'don't care' */
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Delay89
operator|&
literal|255
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|Delay89
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Transparent
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gif_encode_image_data (FILE * fp,int GWidth,int GHeight,int GInterlace,int BitsPerPixel,ifunptr get_pixel,gint offset_x,gint offset_y)
name|gif_encode_image_data
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|GInterlace
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|ifunptr
name|get_pixel
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|Interlace
operator|=
name|GInterlace
expr_stmt|;
name|Width
operator|=
name|GWidth
expr_stmt|;
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
operator|(
name|int
operator|)
name|offset_x
expr_stmt|;
name|TopOfs
operator|=
operator|(
name|int
operator|)
name|offset_y
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write an Image separator    */
name|fputc
argument_list|(
literal|','
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write the Image header    */
name|put_word
argument_list|(
name|LeftOfs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|TopOfs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|Width
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|Height
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out whether or not the image is interlaced    */
if|if
condition|(
name|Interlace
condition|)
name|fputc
argument_list|(
literal|0x40
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the initial code size    */
name|fputc
argument_list|(
name|InitCodeSize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Go and actually compress the data    */
name|compress
argument_list|(
name|InitCodeSize
operator|+
literal|1
argument_list|,
name|fp
argument_list|,
name|get_pixel
argument_list|)
expr_stmt|;
comment|/*    * Write out a Zero-length packet (to end the series)    */
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/***************************/
block|Interlace = GInterlace;   Width = GWidth;   Height = GHeight;   LeftOfs = TopOfs = 0;    CountDown = (long) Width *(long) Height;   Pass = 0;
comment|/*    * The initial code size    */
block|if (BitsPerPixel<= 1)     InitCodeSize = 2;   else     InitCodeSize = BitsPerPixel;
comment|/*    * Set up the current x and y position    */
block|curx = cury = 0;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gif_encode_close (FILE * fp)
name|gif_encode_close
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
comment|/*    * Write the GIF file terminator    */
name|fputc
argument_list|(
literal|';'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * And close the file    */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gif_encode_loop_ext (FILE * fp,guint num_loops)
name|gif_encode_loop_ext
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
name|num_loops
parameter_list|)
block|{
name|fputc
argument_list|(
literal|0x21
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x0b
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"NETSCAPE2.0"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x03
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x01
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|num_loops
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* NOTE: num_loops == 0 means 'loop infinitely' */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|gif_encode_comment_ext (FILE * fp,const gchar * comment)
name|gif_encode_comment_ext
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|gchar
modifier|*
name|comment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|comment
operator|||
operator|!
operator|*
name|comment
condition|)
return|return;
if|if
condition|(
name|strlen
argument_list|(
name|comment
argument_list|)
operator|>
literal|240
condition|)
block|{
name|g_printerr
argument_list|(
literal|"GIF: warning:"
literal|"comment too large - comment block not written.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputc
argument_list|(
literal|0x21
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0xfe
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|strlen
argument_list|(
name|comment
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|comment
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out a word to the GIF file  */
end_comment

begin_function
specifier|static
name|void
DECL|function|put_word (int w,FILE * fp)
name|put_word
parameter_list|(
name|int
name|w
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fputc
argument_list|(
name|w
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|w
operator|/
literal|256
operator|)
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  *  GIFCOMPR.C       - GIF Image compression routines  *  *  Lempel-Ziv compression based on 'compress'.  GIF modifications by  *  David Rowley (mgardi@watdcsu.waterloo.edu)  *  ***************************************************************************/
end_comment

begin_comment
comment|/*  * General DEFINEs  */
end_comment

begin_define
DECL|macro|GIF_BITS
define|#
directive|define
name|GIF_BITS
value|12
end_define

begin_define
DECL|macro|HSIZE
define|#
directive|define
name|HSIZE
value|5003
end_define

begin_comment
DECL|macro|HSIZE
comment|/* 80% occupancy */
end_comment

begin_typedef
DECL|typedef|char_type
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_comment
comment|/*   * GIF Image compression - modified 'compress'  *  * Based on: compress.c - File compression ala IEEE Computer, June 1984.  *  * By Authors:  Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)  *              Jim McKie               (decvax!mcvax!jim)  *              Steve Davies            (decvax!vax135!petsd!peora!srd)  *              Ken Turkowski           (decvax!decwrl!turtlevax!ken)  *              James A. Woods          (decvax!ihnp4!ames!jaw)  *              Joe Orost               (decvax!vax135!petsd!joe)  *  */
end_comment

begin_decl_stmt
DECL|variable|n_bits
specifier|static
name|int
name|n_bits
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|n_bits
comment|/* number of bits/code */
end_comment

begin_decl_stmt
DECL|variable|maxbits
specifier|static
name|int
name|maxbits
init|=
name|GIF_BITS
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxbits
comment|/* user settable max # bits/code */
end_comment

begin_decl_stmt
DECL|variable|maxcode
specifier|static
name|code_int
name|maxcode
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxcode
comment|/* maximum code, given n_bits */
end_comment

begin_decl_stmt
DECL|variable|maxmaxcode
specifier|static
name|code_int
name|maxmaxcode
init|=
operator|(
name|code_int
operator|)
literal|1
operator|<<
name|GIF_BITS
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxmaxcode
comment|/* should NEVER generate this code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_comment
comment|/* But wrong! */
end_comment

begin_define
DECL|macro|MAXCODE (Mn_bits)
define|#
directive|define
name|MAXCODE
parameter_list|(
name|Mn_bits
parameter_list|)
value|((code_int) 1<< (Mn_bits) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*COMPATIBLE */
end_comment

begin_define
DECL|macro|MAXCODE (Mn_bits)
define|#
directive|define
name|MAXCODE
parameter_list|(
name|Mn_bits
parameter_list|)
value|(((code_int) 1<< (Mn_bits)) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*COMPATIBLE */
end_comment

begin_decl_stmt
DECL|variable|htab
specifier|static
name|count_int
name|htab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|codetab
specifier|static
name|unsigned
name|short
name|codetab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|HashTabOf (i)
define|#
directive|define
name|HashTabOf
parameter_list|(
name|i
parameter_list|)
value|htab[i]
end_define

begin_define
DECL|macro|CodeTabOf (i)
define|#
directive|define
name|CodeTabOf
parameter_list|(
name|i
parameter_list|)
value|codetab[i]
end_define

begin_decl_stmt
DECL|variable|hsize
specifier|static
specifier|const
name|code_int
name|hsize
init|=
name|HSIZE
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|hsize
comment|/* the original reason for this being                                         variable was "for dynamic table sizing",                                         but since it was never actually changed                                         I made it const   --Adam. */
end_comment

begin_decl_stmt
DECL|variable|free_ent
specifier|static
name|code_int
name|free_ent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|free_ent
comment|/* first unused entry */
end_comment

begin_comment
comment|/*  * block compression parameters -- after all codes are used up,  * and compression rate changes, start over.  */
end_comment

begin_decl_stmt
DECL|variable|clear_flg
specifier|static
name|int
name|clear_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|offset
specifier|static
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|in_count
specifier|static
name|long
name|int
name|in_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|in_count
comment|/* length of input */
end_comment

begin_decl_stmt
DECL|variable|out_count
specifier|static
name|long
name|int
name|out_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|out_count
comment|/* # of codes output (for debugging) */
end_comment

begin_comment
comment|/*  * compress stdin to stdout  *  * Algorithm:  use open addressing double hashing (no chaining) on the  * prefix code / next character combination.  We do a variant of Knuth's  * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime  * secondary probe.  Here, the modular division first probe is gives way  * to a faster exclusive-or manipulation.  Also do block compression with  * an adaptive reset, whereby the code table is cleared when the compression  * ratio decreases, but after the table fills.  The variable-length output  * codes are re-sized at this point, and a special CLEAR code is generated  * for the decompressor.  Late addition:  construct the table according to  * file size for noticeable speed improvement on small files.  Please direct  * questions about this implementation to ames!jaw.  */
end_comment

begin_decl_stmt
DECL|variable|g_init_bits
specifier|static
name|int
name|g_init_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|g_outfile
specifier|static
name|FILE
modifier|*
name|g_outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ClearCode
specifier|static
name|int
name|ClearCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|EOFCode
specifier|static
name|int
name|EOFCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_accum
specifier|static
name|unsigned
name|long
name|cur_accum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_bits
specifier|static
name|int
name|cur_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|masks
specifier|static
name|unsigned
name|long
name|masks
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000F
block|,
literal|0x001F
block|,
literal|0x003F
block|,
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x01FF
block|,
literal|0x03FF
block|,
literal|0x07FF
block|,
literal|0x0FFF
block|,
literal|0x1FFF
block|,
literal|0x3FFF
block|,
literal|0x7FFF
block|,
literal|0xFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|compress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|compress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
if|if
condition|(
name|FALSE
condition|)
name|no_compress
argument_list|(
name|init_bits
argument_list|,
name|outfile
argument_list|,
name|ReadValue
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FALSE
condition|)
name|rle_compress
argument_list|(
name|init_bits
argument_list|,
name|outfile
argument_list|,
name|ReadValue
argument_list|)
expr_stmt|;
else|else
name|normal_compress
argument_list|(
name|init_bits
argument_list|,
name|outfile
argument_list|,
name|ReadValue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|no_compress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|no_compress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|ent
operator|=
name|gif_next_pixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gif_next_pixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|rle_compress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|rle_compress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|last
operator|=
name|ent
operator|=
name|gif_next_pixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gif_next_pixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|last
operator|==
name|c
condition|)
block|{
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
block|}
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|last
operator|=
name|ent
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|normal_compress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|normal_compress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|ent
operator|=
name|gif_next_pixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gif_next_pixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * TAG( output )  *  * Output the given code.  * Inputs:  *      code:   A n_bits-bit integer.  If == -1, then EOF.  This assumes  *              that n_bits =< (long)wordsize - 1.  * Outputs:  *      Outputs code to the file.  * Assumptions:  *      Chars are 8 bits long.  * Algorithm:  *      Maintain a GIF_BITS character long buffer (so that 8 codes will  * fit in it exactly).  Use the VAX insv instruction to insert each  * code in turn.  When the buffer fills up empty it and start over.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|output (code_int code)
name|output
parameter_list|(
name|code_int
name|code
parameter_list|)
block|{
name|cur_accum
operator|&=
name|masks
index|[
name|cur_bits
index|]
expr_stmt|;
if|if
condition|(
name|cur_bits
operator|>
literal|0
condition|)
name|cur_accum
operator||=
operator|(
operator|(
name|long
operator|)
name|code
operator|<<
name|cur_bits
operator|)
expr_stmt|;
else|else
name|cur_accum
operator|=
name|code
expr_stmt|;
name|cur_bits
operator|+=
name|n_bits
expr_stmt|;
while|while
condition|(
name|cur_bits
operator|>=
literal|8
condition|)
block|{
name|char_out
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cur_accum
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|cur_accum
operator|>>=
literal|8
expr_stmt|;
name|cur_bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/*    * If the next entry is going to be too big for the code size,    * then increase it, if possible.    */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
operator|||
name|clear_flg
condition|)
block|{
if|if
condition|(
name|clear_flg
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|g_init_bits
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|n_bits
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|EOFCode
condition|)
block|{
comment|/*        * At EOF, write the rest of the buffer.        */
while|while
condition|(
name|cur_bits
operator|>
literal|0
condition|)
block|{
name|char_out
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cur_accum
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|cur_accum
operator|>>=
literal|8
expr_stmt|;
name|cur_bits
operator|-=
literal|8
expr_stmt|;
block|}
name|flush_char
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|g_outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|g_outfile
argument_list|)
condition|)
name|write_err
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear out the hash table  */
end_comment

begin_function
specifier|static
name|void
DECL|function|cl_block (void)
name|cl_block
parameter_list|(
name|void
parameter_list|)
comment|/* table clear for block compress */
block|{
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|)
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cl_hash (count_int hsize)
name|cl_hash
parameter_list|(
name|count_int
name|hsize
parameter_list|)
comment|/* reset code table */
block|{
specifier|register
name|count_int
modifier|*
name|htab_p
init|=
name|htab
operator|+
name|hsize
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|long
name|m1
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
name|hsize
operator|-
literal|16
expr_stmt|;
do|do
block|{
comment|/* might use Sys V memset(3) here */
operator|*
operator|(
name|htab_p
operator|-
literal|16
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|15
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|14
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|13
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|12
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|11
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|10
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|9
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|8
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|7
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|6
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|5
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|4
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|3
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|2
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|1
operator|)
operator|=
name|m1
expr_stmt|;
name|htab_p
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|-=
literal|16
operator|)
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|+=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
operator|--
name|htab_p
operator|=
name|m1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|write_err (void)
name|write_err
parameter_list|(
name|void
parameter_list|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Error writing output file."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * GIF Specific routines  *  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Number of characters so far in this 'packet'  */
end_comment

begin_decl_stmt
DECL|variable|a_count
specifier|static
name|int
name|a_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up the 'byte output' routine  */
end_comment

begin_function
specifier|static
name|void
DECL|function|char_init (void)
name|char_init
parameter_list|(
name|void
parameter_list|)
block|{
name|a_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define the storage for the packet accumulator  */
end_comment

begin_decl_stmt
DECL|variable|accum
specifier|static
name|char
name|accum
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add a character to the end of the current packet, and if it is 254  * characters, flush the packet to disk.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|char_out (int c)
name|char_out
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|accum
index|[
name|a_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|a_count
operator|>=
literal|254
condition|)
name|flush_char
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the packet to disk, and reset the accumulator  */
end_comment

begin_function
specifier|static
name|void
DECL|function|flush_char (void)
name|flush_char
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|a_count
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
name|a_count
argument_list|,
name|g_outfile
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|accum
argument_list|,
literal|1
argument_list|,
name|a_count
argument_list|,
name|g_outfile
argument_list|)
expr_stmt|;
name|a_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Save interface functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|comment_entry_callback (GtkTextBuffer * buffer)
name|comment_entry_callback
parameter_list|(
name|GtkTextBuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|GtkTextIter
name|start_iter
decl_stmt|;
name|GtkTextIter
name|end_iter
decl_stmt|;
name|gchar
modifier|*
name|text
decl_stmt|;
name|gtk_text_buffer_get_bounds
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_text_buffer_get_text
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
DECL|macro|MAX_COMMENT
define|#
directive|define
name|MAX_COMMENT
value|240
if|if
condition|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|>
name|MAX_COMMENT
condition|)
block|{
comment|/* translators: the %d is *always* 240 here */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"The default comment is limited to %d characters."
argument_list|)
argument_list|,
name|MAX_COMMENT
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_iter_at_offset
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
name|MAX_COMMENT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_text_buffer_get_end_iter
argument_list|(
name|buffer
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
comment|/*  this calls us recursivaly, but in the else branch        */
name|gtk_text_buffer_delete
argument_list|(
name|buffer
argument_list|,
operator|&
name|start_iter
argument_list|,
operator|&
name|end_iter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
name|globalcomment
operator|=
name|g_strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|comment_was_edited
operator|=
name|TRUE
expr_stmt|;
block|}
name|g_free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

