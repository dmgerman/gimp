begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/* XPM plugin version 1.2.6 */
end_comment

begin_comment
comment|/* 1.2.6 fixes crash when saving indexed images (bug #109567)  1.2.5 only creates a "None" color entry if the image has alpha (bug #108034)  1.2.4 displays an error message if saving fails (bug #87588)  1.2.3 fixes bug when running in noninteractive mode changes alpha_threshold range from [0, 1] to [0,255] for consistency with the threshold_alpha plugin  1.2.2 fixes bug that generated bad digits on images with more than 20000 colors. (thanks, yanele) parses gtkrc (thanks, yosh) doesn't load parameter screen on images that don't have alpha  1.2.1 fixes some minor bugs -- spaces in #XXXXXX strings, small typos in code.  1.2 compute color indexes so that we don't have to use XpmSaveXImage*  Previous...Inherited code from Ray Lehtiniemi, who inherited it from S& P. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdk.h>
end_include

begin_comment
comment|/* For GDK_WINDOWING_WIN32 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDK_WINDOWING_X11
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|XPM_NO_X
end_ifndef

begin_define
DECL|macro|XPM_NO_X
define|#
directive|define
name|XPM_NO_X
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<X11/xpm.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_decl_stmt
DECL|variable|linenoise
specifier|static
specifier|const
name|gchar
name|linenoise
index|[]
init|=
literal|" .+@#$%&*=-;>,')!~{]^/(_:<[}|1234567890abcdefghijklmnopqrstuvwxyz\ ABCDEFGHIJKLMNOPQRSTUVWXYZ`"
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-xpm-load"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-xpm-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-xpm"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-file-xpm"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_comment
comment|/* Structs for the save dialog */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2878ab580108
block|{
DECL|member|threshold
name|gint
name|threshold
decl_stmt|;
DECL|typedef|XpmSaveVals
block|}
name|XpmSaveVals
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2878ab580208
block|{
DECL|member|r
name|guchar
name|r
decl_stmt|;
DECL|member|g
name|guchar
name|g
decl_stmt|;
DECL|member|b
name|guchar
name|b
decl_stmt|;
DECL|typedef|rgbkey
block|}
name|rgbkey
typedef|;
end_typedef

begin_comment
comment|/*  whether the image is color or not.  global so I only have to pass  *  one user value to the GHFunc  */
end_comment

begin_decl_stmt
DECL|variable|color
specifier|static
name|gboolean
name|color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  bytes per pixel.  global so I only have to pass one user value  *  to the GHFunc  */
end_comment

begin_decl_stmt
DECL|variable|cpp
specifier|static
name|gint
name|cpp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|parse_colors
parameter_list|(
name|XpmImage
modifier|*
name|xpm_image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_image
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xpmvals
specifier|static
name|XpmSaveVals
name|xpmvals
init|=
block|{
literal|127
comment|/* alpha threshold */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name entered"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to export"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to export the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name of the file to export the image in"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"threshold"
block|,
literal|"Alpha threshold (0-255)"
block|}
block|}
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"Load files in XPM (X11 Pixmap) format."
argument_list|,
literal|"Load files in XPM (X11 Pixmap) format. "
literal|"XPM is a portable image format designed to be "
literal|"included in C source code. XLib provides utility "
literal|"functions to read this format. Newer code should "
literal|"however be using gdk-pixbuf-csource instead. "
literal|"XPM supports colored images, unlike the XBM "
literal|"format which XPM was designed to replace."
argument_list|,
literal|"Spencer Kimball& Peter Mattis& Ray Lehtiniemi"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|N_
argument_list|(
literal|"X PixMap image"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_return_vals
argument_list|)
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"image/x-xpixmap"
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"xpm"
argument_list|,
literal|""
argument_list|,
literal|"0, string,/*\\040XPM\\040*/"
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"Export files in XPM (X11 Pixmap) format."
argument_list|,
literal|"Export files in XPM (X11 Pixmap) format. "
literal|"XPM is a portable image format designed to be "
literal|"included in C source code. XLib provides utility "
literal|"functions to read this format. Newer code should "
literal|"however be using gdk-pixbuf-csource instead. "
literal|"XPM supports colored images, unlike the XBM "
literal|"format which XPM was designed to replace."
argument_list|,
literal|"Spencer Kimball& Peter Mattis& Ray Lehtiniemi& Nathan Summers"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|,
name|N_
argument_list|(
literal|"X PixMap image"
argument_list|)
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_file_handler_mime
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"image/x-xpixmap"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"xpm"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|drawable_ID
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|image_ID
operator|=
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|drawable_ID
operator|=
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
comment|/*  eventually export the image */
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image_ID
argument_list|,
operator|&
name|drawable_ID
argument_list|,
literal|"XPM"
argument_list|,
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_xpm_save"
argument_list|,
operator|&
name|xpmvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ID
argument_list|)
condition|)
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|6
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|xpmvals
operator|.
name|threshold
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|xpmvals
operator|.
name|threshold
operator|<
literal|0
operator|||
name|xpmvals
operator|.
name|threshold
operator|>
literal|255
condition|)
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_xpm_save"
argument_list|,
operator|&
name|xpmvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|image_ID
argument_list|,
name|drawable_ID
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
literal|"file_xpm_save"
argument_list|,
operator|&
name|xpmvals
argument_list|,
sizeof|sizeof
argument_list|(
name|XpmSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|GIMP_PDB_SUCCESS
operator|&&
name|error
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STRING
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|error
operator|->
name|message
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (const gchar * filename,GError ** error)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XpmImage
name|xpm_image
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read the raw file */
switch|switch
condition|(
name|XpmReadFileToXpmImage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filename
argument_list|,
operator|&
name|xpm_image
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|XpmSuccess
case|:
break|break;
case|case
name|XpmOpenFailed
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error opening file '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|XpmFileInvalid
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"XPM file invalid"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* parse out the colors into a cmap */
name|cmap
operator|=
name|parse_colors
argument_list|(
operator|&
name|xpm_image
argument_list|)
expr_stmt|;
comment|/* create the new image */
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|xpm_image
operator|.
name|width
argument_list|,
name|xpm_image
operator|.
name|height
argument_list|,
name|GIMP_RGB
argument_list|)
expr_stmt|;
comment|/* name it */
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* fill it */
name|parse_image
argument_list|(
name|image_ID
argument_list|,
operator|&
name|xpm_image
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
comment|/* clean up and exit */
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|parse_colors (XpmImage * xpm_image)
name|parse_colors
parameter_list|(
name|XpmImage
modifier|*
name|xpm_image
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|XPM_NO_X
name|Display
modifier|*
name|display
decl_stmt|;
name|Colormap
name|colormap
decl_stmt|;
endif|#
directive|endif
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
ifndef|#
directive|ifndef
name|XPM_NO_X
comment|/* open the display and get the default color map */
name|display
operator|=
name|XOpenDisplay
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|colormap
operator|=
name|DefaultColormap
argument_list|(
name|display
argument_list|,
name|DefaultScreen
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* alloc a buffer to hold the parsed colors */
name|cmap
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
literal|4
operator|*
name|xpm_image
operator|->
name|ncolors
argument_list|)
expr_stmt|;
comment|/* parse each color in the file */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|xpm_image
operator|->
name|ncolors
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|colorspec
init|=
literal|"None"
decl_stmt|;
name|XpmColor
modifier|*
name|xpm_color
decl_stmt|;
ifndef|#
directive|ifndef
name|XPM_NO_X
name|XColor
name|xcolor
decl_stmt|;
else|#
directive|else
name|GdkColor
name|xcolor
decl_stmt|;
endif|#
directive|endif
name|xpm_color
operator|=
operator|&
operator|(
name|xpm_image
operator|->
name|colorTable
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* pick the best spec available */
if|if
condition|(
name|xpm_color
operator|->
name|c_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|c_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|g_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|g_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|g4_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|g4_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|m_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|m_color
expr_stmt|;
comment|/* parse if it's not transparent */
if|if
condition|(
name|strcmp
argument_list|(
name|colorspec
argument_list|,
literal|"None"
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|XPM_NO_X
name|XParseColor
argument_list|(
name|display
argument_list|,
name|colormap
argument_list|,
name|colorspec
argument_list|,
operator|&
name|xcolor
argument_list|)
expr_stmt|;
else|#
directive|else
name|gdk_color_parse
argument_list|(
name|colorspec
argument_list|,
operator|&
name|xcolor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|red
operator|>>
literal|8
expr_stmt|;
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|green
operator|>>
literal|8
expr_stmt|;
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|blue
operator|>>
literal|8
expr_stmt|;
name|cmap
index|[
name|j
operator|++
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|j
operator|+=
literal|4
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|XPM_NO_X
name|XCloseDisplay
argument_list|(
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cmap
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_image (gint32 image_ID,XpmImage * xpm_image,guchar * cmap)
name|parse_image
parameter_list|(
name|gint32
name|image_ID
parameter_list|,
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|gint
name|tile_height
decl_stmt|;
name|gint
name|scanlines
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|guint
modifier|*
name|src
decl_stmt|;
name|gint32
name|layer_ID
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|_
argument_list|(
literal|"Color"
argument_list|)
argument_list|,
name|xpm_image
operator|->
name|width
argument_list|,
name|xpm_image
operator|->
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|xpm_image
operator|->
name|width
operator|*
literal|4
argument_list|)
expr_stmt|;
name|src
operator|=
name|xpm_image
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xpm_image
operator|->
name|height
condition|;
name|i
operator|+=
name|tile_height
control|)
block|{
name|gint
name|j
decl_stmt|;
name|dest
operator|=
name|buf
expr_stmt|;
name|scanlines
operator|=
name|MIN
argument_list|(
name|tile_height
argument_list|,
name|xpm_image
operator|->
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|scanlines
operator|*
name|xpm_image
operator|->
name|width
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
block|{
name|val
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
operator|*
literal|4
expr_stmt|;
operator|*
operator|(
name|dest
operator|)
operator|=
name|cmap
index|[
name|val
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|1
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|2
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|2
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|3
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|3
index|]
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|i
operator|/
operator|(
name|double
operator|)
name|xpm_image
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
name|xpm_image
operator|->
name|width
argument_list|,
name|scanlines
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|rgbhash (rgbkey * c)
name|rgbhash
parameter_list|(
name|rgbkey
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|r
operator|)
operator|^
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|g
operator|)
operator|^
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|compare (rgbkey * c1,rgbkey * c2)
name|compare
parameter_list|(
name|rgbkey
modifier|*
name|c1
parameter_list|,
name|rgbkey
modifier|*
name|c2
parameter_list|)
block|{
return|return
operator|(
name|c1
operator|->
name|r
operator|==
name|c2
operator|->
name|r
operator|)
operator|&&
operator|(
name|c1
operator|->
name|g
operator|==
name|c2
operator|->
name|g
operator|)
operator|&&
operator|(
name|c1
operator|->
name|b
operator|==
name|c2
operator|->
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|set_XpmImage (XpmColor * array,guint index,gchar * colorstring)
name|set_XpmImage
parameter_list|(
name|XpmColor
modifier|*
name|array
parameter_list|,
name|guint
name|index
parameter_list|,
name|gchar
modifier|*
name|colorstring
parameter_list|)
block|{
name|gchar
modifier|*
name|p
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|charnum
decl_stmt|,
name|indtemp
decl_stmt|;
name|indtemp
operator|=
name|index
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|string
operator|=
name|p
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
name|cpp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*convert the index number to base sizeof(linenoise)-1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpp
condition|;
operator|++
name|i
control|)
block|{
name|charnum
operator|=
name|indtemp
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|indtemp
operator|=
name|indtemp
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|linenoise
index|[
name|charnum
index|]
expr_stmt|;
block|}
comment|/* *p++=linenoise[indtemp]; */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* C and its stupid null-terminated strings... */
name|array
index|[
name|index
index|]
operator|.
name|symbolic
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|m_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|g4_color
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|color
condition|)
block|{
name|array
index|[
name|index
index|]
operator|.
name|g_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|c_color
operator|=
name|colorstring
expr_stmt|;
block|}
else|else
block|{
name|array
index|[
name|index
index|]
operator|.
name|c_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|g_color
operator|=
name|colorstring
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|create_colormap_from_hash (gpointer gkey,gpointer value,gpointer user_data)
name|create_colormap_from_hash
parameter_list|(
name|gpointer
name|gkey
parameter_list|,
name|gpointer
name|value
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|rgbkey
modifier|*
name|key
init|=
name|gkey
decl_stmt|;
name|gchar
modifier|*
name|string
init|=
name|g_new
argument_list|(
name|gchar
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"#%02X%02X%02X"
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|r
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|g
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|b
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|user_data
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|value
operator|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_image (const gchar * filename,gint32 image_ID,gint32 drawable_ID,GError ** error)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|ncolors
init|=
literal|1
decl_stmt|;
name|gint
modifier|*
name|indexno
decl_stmt|;
name|gboolean
name|indexed
decl_stmt|;
name|gboolean
name|alpha
decl_stmt|;
name|XpmColor
modifier|*
name|colormap
decl_stmt|;
name|XpmImage
modifier|*
name|image
decl_stmt|;
name|guint
modifier|*
name|ibuff
init|=
name|NULL
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|GHashTable
modifier|*
name|hash
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|threshold
init|=
name|xpmvals
operator|.
name|threshold
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|width
operator|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|height
operator|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|color
operator|=
operator|!
name|gimp_drawable_is_gray
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
name|indexed
operator|=
name|gimp_drawable_is_indexed
argument_list|(
name|drawable_ID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|drawable_ID
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B' u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y'A u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|format
operator|=
name|gegl_buffer_get_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported drawable type"
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* allocate buffer making the assumption that ibuff is 32 bit aligned... */
name|ibuff
operator|=
name|g_new
argument_list|(
name|guint
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|hash
operator|=
name|g_hash_table_new
argument_list|(
operator|(
name|GHashFunc
operator|)
name|rgbhash
argument_list|,
operator|(
name|GCompareFunc
operator|)
name|compare
argument_list|)
expr_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Exporting '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|ncolors
operator|=
name|alpha
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* allocate a pixel region to work with */
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimp_tile_height
argument_list|()
operator|*
name|width
operator|*
name|babl_format_get_bytes_per_pixel
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process each row of tiles */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|+=
name|gimp_tile_height
argument_list|()
control|)
block|{
name|gint
name|scanlines
decl_stmt|;
comment|/* read the next row of tiles */
name|scanlines
operator|=
name|MIN
argument_list|(
name|gimp_tile_height
argument_list|()
argument_list|,
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|scanlines
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|data
operator|=
name|buf
expr_stmt|;
comment|/* process each pixel row */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scanlines
condition|;
name|j
operator|++
control|)
block|{
comment|/* go to the start of this row in each image */
name|guint
modifier|*
name|idata
init|=
name|ibuff
operator|+
operator|(
name|i
operator|+
name|j
operator|)
operator|*
name|width
decl_stmt|;
comment|/* do each pixel in the row */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
name|k
operator|++
control|)
block|{
name|rgbkey
modifier|*
name|key
init|=
name|g_new
argument_list|(
name|rgbkey
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|guchar
name|a
decl_stmt|;
comment|/* get pixel data */
name|key
operator|->
name|r
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|key
operator|->
name|g
operator|=
name|color
operator|&&
operator|!
name|indexed
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
name|key
operator|->
name|r
expr_stmt|;
name|key
operator|->
name|b
operator|=
name|color
operator|&&
operator|!
name|indexed
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
name|key
operator|->
name|r
expr_stmt|;
name|a
operator|=
name|alpha
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
literal|255
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|threshold
condition|)
block|{
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|indexed
condition|)
block|{
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
operator|(
name|key
operator|->
name|r
operator|)
operator|+
operator|(
name|alpha
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|indexno
operator|=
name|g_hash_table_lookup
argument_list|(
name|hash
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexno
condition|)
block|{
name|indexno
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|indexno
operator|=
name|ncolors
operator|++
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|indexno
argument_list|)
expr_stmt|;
name|key
operator|=
name|g_new
argument_list|(
name|rgbkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
operator|*
name|indexno
expr_stmt|;
block|}
block|}
block|}
comment|/* kick the progress bar */
name|gimp_progress_update
argument_list|(
call|(
name|gdouble
call|)
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|height
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexed
condition|)
block|{
name|guchar
modifier|*
name|cmap
init|=
name|gimp_image_get_colormap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|ncolors
argument_list|)
decl_stmt|;
name|guchar
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|cmap
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
name|ncolors
operator|++
expr_stmt|;
name|colormap
operator|=
name|g_new
argument_list|(
name|XpmColor
argument_list|,
name|ncolors
argument_list|)
expr_stmt|;
name|cpp
operator|=
literal|1
operator|+
operator|(
name|gdouble
operator|)
name|log
argument_list|(
name|ncolors
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|log
argument_list|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
literal|0
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|alpha
condition|?
literal|1
else|:
literal|0
init|;
name|i
operator|<
name|ncolors
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|string
decl_stmt|;
name|guchar
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|r
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|string
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"#%02X%02X%02X"
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|,
operator|(
name|int
operator|)
name|g
argument_list|,
operator|(
name|int
operator|)
name|b
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
name|i
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colormap
operator|=
name|g_new
argument_list|(
name|XpmColor
argument_list|,
name|ncolors
argument_list|)
expr_stmt|;
name|cpp
operator|=
literal|1
operator|+
operator|(
name|gdouble
operator|)
name|log
argument_list|(
name|ncolors
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|log
argument_list|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
literal|0
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
name|g_hash_table_foreach
argument_list|(
name|hash
argument_list|,
name|create_colormap_from_hash
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
block|}
name|image
operator|=
name|g_new
argument_list|(
name|XpmImage
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|image
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|image
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|image
operator|->
name|ncolors
operator|=
name|ncolors
expr_stmt|;
name|image
operator|->
name|cpp
operator|=
name|cpp
expr_stmt|;
name|image
operator|->
name|colorTable
operator|=
name|colormap
expr_stmt|;
name|image
operator|->
name|data
operator|=
name|ibuff
expr_stmt|;
comment|/* do the save */
switch|switch
condition|(
name|XpmWriteFileFromXpmImage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filename
argument_list|,
name|image
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|XpmSuccess
case|:
name|success
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|XpmOpenFailed
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error opening file '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XpmFileInvalid
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"XPM file invalid"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ibuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
name|g_hash_table_destroy
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (void)
name|save_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkObject
modifier|*
name|scale_data
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|dialog
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"XPM"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|SAVE_PROC
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|,
name|table
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"_Alpha threshold:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|xpmvals
operator|.
name|threshold
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xpmvals
operator|.
name|threshold
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

end_unit

