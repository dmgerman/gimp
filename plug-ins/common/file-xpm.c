begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<https://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/* XPM plugin version 1.2.6 */
end_comment

begin_comment
comment|/* 1.2.6 fixes crash when saving indexed images (bug #109567)  1.2.5 only creates a "None" color entry if the image has alpha (bug #108034)  1.2.4 displays an error message if saving fails (bug #87588)  1.2.3 fixes bug when running in noninteractive mode changes alpha_threshold range from [0, 1] to [0,255] for consistency with the threshold_alpha plugin  1.2.2 fixes bug that generated bad digits on images with more than 20000 colors. (thanks, yanele) parses gtkrc (thanks, yosh) doesn't load parameter screen on images that don't have alpha  1.2.1 fixes some minor bugs -- spaces in #XXXXXX strings, small typos in code.  1.2 compute color indexes so that we don't have to use XpmSaveXImage*  Previous...Inherited code from Ray Lehtiniemi, who inherited it from S& P. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdk.h>
end_include

begin_comment
comment|/* For GDK_WINDOWING_WIN32 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDK_WINDOWING_X11
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|XPM_NO_X
end_ifndef

begin_define
DECL|macro|XPM_NO_X
define|#
directive|define
name|XPM_NO_X
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<X11/xpm.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-xpm-load"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-xpm-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"file-xpm"
end_define

begin_define
DECL|macro|PLUG_IN_ROLE
define|#
directive|define
name|PLUG_IN_ROLE
value|"gimp-file-xpm"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_comment
comment|/* Structs for the save dialog */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2a43ddbe0108
block|{
DECL|member|threshold
name|gint
name|threshold
decl_stmt|;
DECL|typedef|XpmSaveVals
block|}
name|XpmSaveVals
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2a43ddbe0208
block|{
DECL|member|r
name|guchar
name|r
decl_stmt|;
DECL|member|g
name|guchar
name|g
decl_stmt|;
DECL|member|b
name|guchar
name|b
decl_stmt|;
DECL|typedef|rgbkey
block|}
name|rgbkey
typedef|;
end_typedef

begin_typedef
DECL|typedef|Xpm
typedef|typedef
name|struct
name|_Xpm
name|Xpm
typedef|;
end_typedef

begin_typedef
DECL|typedef|XpmClass
typedef|typedef
name|struct
name|_XpmClass
name|XpmClass
typedef|;
end_typedef

begin_struct
DECL|struct|_Xpm
struct|struct
name|_Xpm
block|{
DECL|member|parent_instance
name|GimpPlugIn
name|parent_instance
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
DECL|struct|_XpmClass
struct|struct
name|_XpmClass
block|{
DECL|member|parent_class
name|GimpPlugInClass
name|parent_class
decl_stmt|;
block|}
struct|;
end_struct

begin_define
DECL|macro|XPM_TYPE
define|#
directive|define
name|XPM_TYPE
value|(xpm_get_type ())
end_define

begin_define
DECL|macro|XPM
define|#
directive|define
name|XPM
value|(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XPM_TYPE, Xpm))
end_define

begin_decl_stmt
name|GType
name|xpm_get_type
argument_list|(
name|void
argument_list|)
name|G_GNUC_CONST
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GList
modifier|*
name|xpm_query_procedures
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpProcedure
modifier|*
name|xpm_create_procedure
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|xpm_load
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpValueArray
modifier|*
name|xpm_save
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImage
modifier|*
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|parse_colors
parameter_list|(
name|XpmImage
modifier|*
name|xpm_image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_image
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|G_DEFINE_TYPE
argument_list|(
argument|Xpm
argument_list|,
argument|xpm
argument_list|,
argument|GIMP_TYPE_PLUG_IN
argument_list|)
end_macro

begin_macro
name|GIMP_MAIN
argument_list|(
argument|XPM_TYPE
argument_list|)
end_macro

begin_decl_stmt
specifier|static
specifier|const
name|gchar
name|linenoise
index|[]
init|=
literal|" .+@#$%&*=-;>,')!~{]^/(_:<[}|1234567890abcdefghijklmnopqrstuvwxyz\ ABCDEFGHIJKLMNOPQRSTUVWXYZ`"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  whether the image is color or not.  global so I only have to pass  *  one user value to the GHFunc  */
end_comment

begin_decl_stmt
DECL|variable|color
specifier|static
name|gboolean
name|color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  bytes per pixel.  global so I only have to pass one user value  *  to the GHFunc  */
end_comment

begin_decl_stmt
DECL|variable|cpp
specifier|static
name|gint
name|cpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xpmvals
specifier|static
name|XpmSaveVals
name|xpmvals
init|=
block|{
literal|127
comment|/* alpha threshold */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|xpm_class_init (XpmClass * klass)
name|xpm_class_init
parameter_list|(
name|XpmClass
modifier|*
name|klass
parameter_list|)
block|{
name|GimpPlugInClass
modifier|*
name|plug_in_class
init|=
name|GIMP_PLUG_IN_CLASS
argument_list|(
name|klass
argument_list|)
decl_stmt|;
name|plug_in_class
operator|->
name|query_procedures
operator|=
name|xpm_query_procedures
expr_stmt|;
name|plug_in_class
operator|->
name|create_procedure
operator|=
name|xpm_create_procedure
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xpm_init (Xpm * xpm)
name|xpm_init
parameter_list|(
name|Xpm
modifier|*
name|xpm
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|GList
modifier|*
DECL|function|xpm_query_procedures (GimpPlugIn * plug_in)
name|xpm_query_procedures
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|)
block|{
name|GList
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|LOAD_PROC
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|g_list_append
argument_list|(
name|list
argument_list|,
name|g_strdup
argument_list|(
name|SAVE_PROC
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|GimpProcedure
modifier|*
DECL|function|xpm_create_procedure (GimpPlugIn * plug_in,const gchar * name)
name|xpm_create_procedure
parameter_list|(
name|GimpPlugIn
modifier|*
name|plug_in
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
name|GimpProcedure
modifier|*
name|procedure
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_load_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|xpm_load
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_menu_label
argument_list|(
name|procedure
argument_list|,
name|N_
argument_list|(
literal|"X PixMap image"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Load files in XPM (X11 Pixmap) format."
argument_list|,
literal|"Load files in XPM (X11 Pixmap) format. "
literal|"XPM is a portable image format "
literal|"designed to be included in C source "
literal|"code. XLib provides utility functions "
literal|"to read this format. Newer code should "
literal|"however be using gdk-pixbuf-csource "
literal|"instead. XPM supports colored images, "
literal|"unlike the XBM format which XPM was "
literal|"designed to replace."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Spencer Kimball& Peter Mattis& "
literal|"Ray Lehtiniemi"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_mime_types
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"image/x-pixmap"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_extensions
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"xpm"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_magics
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"0, string,/*\\040XPM\\040*/"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
condition|)
block|{
name|procedure
operator|=
name|gimp_save_procedure_new
argument_list|(
name|plug_in
argument_list|,
name|name
argument_list|,
name|GIMP_PDB_PROC_TYPE_PLUGIN
argument_list|,
name|xpm_save
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_procedure_set_image_types
argument_list|(
name|procedure
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|gimp_procedure_set_menu_label
argument_list|(
name|procedure
argument_list|,
name|N_
argument_list|(
literal|"X PixMap image"
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_procedure_set_documentation
argument_list|(
name|procedure
argument_list|,
literal|"Export files in XPM (X11 Pixmap) format."
argument_list|,
literal|"Export files in XPM (X11 Pixmap) format. "
literal|"XPM is a portable image format "
literal|"designed to be included in C source "
literal|"code. XLib provides utility functions "
literal|"to read this format. Newer code should "
literal|"however be using gdk-pixbuf-csource "
literal|"instead. XPM supports colored images, "
literal|"unlike the XBM format which XPM was "
literal|"designed to replace."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_procedure_set_attribution
argument_list|(
name|procedure
argument_list|,
literal|"Spencer Kimball& Peter Mattis& "
literal|"Ray Lehtiniemi& Nathan Summers"
argument_list|,
literal|"Spencer Kimball& Peter Mattis"
argument_list|,
literal|"1997"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_mime_types
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"image/x-pixmap"
argument_list|)
expr_stmt|;
name|gimp_file_procedure_set_extensions
argument_list|(
name|GIMP_FILE_PROCEDURE
argument_list|(
name|procedure
argument_list|)
argument_list|,
literal|"xpm"
argument_list|)
expr_stmt|;
name|GIMP_PROC_ARG_INT
argument_list|(
name|procedure
argument_list|,
literal|"threshold"
argument_list|,
literal|"Threshold"
argument_list|,
literal|"Alpha threshold"
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|127
argument_list|,
name|G_PARAM_READWRITE
argument_list|)
expr_stmt|;
block|}
return|return
name|procedure
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|xpm_load (GimpProcedure * procedure,GimpRunMode run_mode,GFile * file,const GimpValueArray * args,gpointer run_data)
name|xpm_load
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpValueArray
modifier|*
name|return_vals
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|=
name|load_image
argument_list|(
name|g_file_get_path
argument_list|(
name|file
argument_list|)
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_EXECUTION_ERROR
argument_list|,
name|error
argument_list|)
return|;
name|return_vals
operator|=
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_SUCCESS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GIMP_VALUES_SET_IMAGE
argument_list|(
name|return_vals
argument_list|,
literal|1
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return
name|return_vals
return|;
block|}
end_function

begin_function
specifier|static
name|GimpValueArray
modifier|*
DECL|function|xpm_save (GimpProcedure * procedure,GimpRunMode run_mode,GimpImage * image,GimpDrawable * drawable,GFile * file,const GimpValueArray * args,gpointer run_data)
name|xpm_save
parameter_list|(
name|GimpProcedure
modifier|*
name|procedure
parameter_list|,
name|GimpRunMode
name|run_mode
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GFile
modifier|*
name|file
parameter_list|,
specifier|const
name|GimpValueArray
modifier|*
name|args
parameter_list|,
name|gpointer
name|run_data
parameter_list|)
block|{
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|GimpExportReturn
name|export
init|=
name|GIMP_EXPORT_CANCEL
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gegl_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|export
operator|=
name|gimp_export_image
argument_list|(
operator|&
name|image
argument_list|,
operator|&
name|drawable
argument_list|,
literal|"XPM"
argument_list|,
name|GIMP_EXPORT_CAN_HANDLE_RGB
operator||
name|GIMP_EXPORT_CAN_HANDLE_GRAY
operator||
name|GIMP_EXPORT_CAN_HANDLE_INDEXED
operator||
name|GIMP_EXPORT_CAN_HANDLE_ALPHA
argument_list|)
expr_stmt|;
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_CANCEL
condition|)
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|GIMP_PDB_CANCEL
argument_list|,
name|NULL
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xpmvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
condition|)
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
name|xpmvals
operator|.
name|threshold
operator|=
name|GIMP_VALUES_GET_INT
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xpmvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_image
argument_list|(
name|g_file_get_path
argument_list|(
name|file
argument_list|)
argument_list|,
name|image
argument_list|,
name|drawable
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|gimp_set_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|xpmvals
argument_list|,
sizeof|sizeof
argument_list|(
name|XpmSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
operator|==
name|GIMP_EXPORT_EXPORT
condition|)
name|gimp_image_delete
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|gimp_procedure_new_return_values
argument_list|(
name|procedure
argument_list|,
name|status
argument_list|,
name|error
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpImage
modifier|*
DECL|function|load_image (const gchar * filename,GError ** error)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XpmImage
name|xpm_image
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|GimpImage
modifier|*
name|image
decl_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read the raw file */
switch|switch
condition|(
name|XpmReadFileToXpmImage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filename
argument_list|,
operator|&
name|xpm_image
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|XpmSuccess
case|:
break|break;
case|case
name|XpmOpenFailed
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error opening file '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|XpmFileInvalid
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"XPM file invalid"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
return|return
name|NULL
return|;
block|}
name|cmap
operator|=
name|parse_colors
argument_list|(
operator|&
name|xpm_image
argument_list|)
expr_stmt|;
name|image
operator|=
name|gimp_image_new
argument_list|(
name|xpm_image
operator|.
name|width
argument_list|,
name|xpm_image
operator|.
name|height
argument_list|,
name|GIMP_RGB
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* fill it */
name|parse_image
argument_list|(
name|image
argument_list|,
operator|&
name|xpm_image
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|parse_colors (XpmImage * xpm_image)
name|parse_colors
parameter_list|(
name|XpmImage
modifier|*
name|xpm_image
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|XPM_NO_X
name|Display
modifier|*
name|display
decl_stmt|;
name|Colormap
name|colormap
decl_stmt|;
endif|#
directive|endif
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
ifndef|#
directive|ifndef
name|XPM_NO_X
comment|/* open the display and get the default color map */
name|display
operator|=
name|XOpenDisplay
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|display
operator|==
name|NULL
condition|)
name|g_printerr
argument_list|(
literal|"Could not open display\n"
argument_list|)
expr_stmt|;
name|colormap
operator|=
name|DefaultColormap
argument_list|(
name|display
argument_list|,
name|DefaultScreen
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* alloc a buffer to hold the parsed colors */
name|cmap
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
literal|4
operator|*
name|xpm_image
operator|->
name|ncolors
argument_list|)
expr_stmt|;
comment|/* parse each color in the file */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|xpm_image
operator|->
name|ncolors
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|colorspec
init|=
literal|"None"
decl_stmt|;
name|XpmColor
modifier|*
name|xpm_color
decl_stmt|;
ifndef|#
directive|ifndef
name|XPM_NO_X
name|XColor
name|xcolor
decl_stmt|;
else|#
directive|else
name|GdkColor
name|xcolor
decl_stmt|;
endif|#
directive|endif
name|xpm_color
operator|=
operator|&
operator|(
name|xpm_image
operator|->
name|colorTable
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* pick the best spec available */
if|if
condition|(
name|xpm_color
operator|->
name|c_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|c_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|g_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|g_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|g4_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|g4_color
expr_stmt|;
elseif|else
if|if
condition|(
name|xpm_color
operator|->
name|m_color
condition|)
name|colorspec
operator|=
name|xpm_color
operator|->
name|m_color
expr_stmt|;
comment|/* parse if it's not transparent */
if|if
condition|(
name|strcmp
argument_list|(
name|colorspec
argument_list|,
literal|"None"
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|XPM_NO_X
name|XParseColor
argument_list|(
name|display
argument_list|,
name|colormap
argument_list|,
name|colorspec
argument_list|,
operator|&
name|xcolor
argument_list|)
expr_stmt|;
else|#
directive|else
name|gdk_color_parse
argument_list|(
name|colorspec
argument_list|,
operator|&
name|xcolor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|red
operator|>>
literal|8
expr_stmt|;
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|green
operator|>>
literal|8
expr_stmt|;
name|cmap
index|[
name|j
operator|++
index|]
operator|=
name|xcolor
operator|.
name|blue
operator|>>
literal|8
expr_stmt|;
name|cmap
index|[
name|j
operator|++
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|j
operator|+=
literal|4
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|XPM_NO_X
name|XCloseDisplay
argument_list|(
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cmap
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|parse_image (GimpImage * image,XpmImage * xpm_image,guchar * cmap)
name|parse_image
parameter_list|(
name|GimpImage
modifier|*
name|image
parameter_list|,
name|XpmImage
modifier|*
name|xpm_image
parameter_list|,
name|guchar
modifier|*
name|cmap
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|gint
name|tile_height
decl_stmt|;
name|gint
name|scanlines
decl_stmt|;
name|gint
name|val
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|;
name|guint
modifier|*
name|src
decl_stmt|;
name|GimpLayer
modifier|*
name|layer
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|layer
operator|=
name|gimp_layer_new
argument_list|(
name|image
argument_list|,
name|_
argument_list|(
literal|"Color"
argument_list|)
argument_list|,
name|xpm_image
operator|->
name|width
argument_list|,
name|xpm_image
operator|->
name|height
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|gimp_image_get_default_new_layer_mode
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image
argument_list|,
name|layer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|GIMP_DRAWABLE
argument_list|(
name|layer
argument_list|)
argument_list|)
expr_stmt|;
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|tile_height
operator|*
name|xpm_image
operator|->
name|width
operator|*
literal|4
argument_list|)
expr_stmt|;
name|src
operator|=
name|xpm_image
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xpm_image
operator|->
name|height
condition|;
name|i
operator|+=
name|tile_height
control|)
block|{
name|gint
name|j
decl_stmt|;
name|dest
operator|=
name|buf
expr_stmt|;
name|scanlines
operator|=
name|MIN
argument_list|(
name|tile_height
argument_list|,
name|xpm_image
operator|->
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|scanlines
operator|*
name|xpm_image
operator|->
name|width
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
block|{
name|val
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
operator|*
literal|4
expr_stmt|;
operator|*
operator|(
name|dest
operator|)
operator|=
name|cmap
index|[
name|val
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|1
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|2
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|2
index|]
expr_stmt|;
operator|*
operator|(
name|dest
operator|+
literal|3
operator|)
operator|=
name|cmap
index|[
name|val
operator|+
literal|3
index|]
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|i
operator|/
operator|(
name|double
operator|)
name|xpm_image
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
name|xpm_image
operator|->
name|width
argument_list|,
name|scanlines
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|rgbhash (rgbkey * c)
name|rgbhash
parameter_list|(
name|rgbkey
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|r
operator|)
operator|^
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|g
operator|)
operator|^
operator|(
operator|(
name|guint
operator|)
name|c
operator|->
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|guint
DECL|function|compare (rgbkey * c1,rgbkey * c2)
name|compare
parameter_list|(
name|rgbkey
modifier|*
name|c1
parameter_list|,
name|rgbkey
modifier|*
name|c2
parameter_list|)
block|{
return|return
operator|(
name|c1
operator|->
name|r
operator|==
name|c2
operator|->
name|r
operator|)
operator|&&
operator|(
name|c1
operator|->
name|g
operator|==
name|c2
operator|->
name|g
operator|)
operator|&&
operator|(
name|c1
operator|->
name|b
operator|==
name|c2
operator|->
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|set_XpmImage (XpmColor * array,guint index,gchar * colorstring)
name|set_XpmImage
parameter_list|(
name|XpmColor
modifier|*
name|array
parameter_list|,
name|guint
name|index
parameter_list|,
name|gchar
modifier|*
name|colorstring
parameter_list|)
block|{
name|gchar
modifier|*
name|p
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|charnum
decl_stmt|,
name|indtemp
decl_stmt|;
name|indtemp
operator|=
name|index
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|string
operator|=
name|p
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
name|cpp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*convert the index number to base sizeof(linenoise)-1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpp
condition|;
operator|++
name|i
control|)
block|{
name|charnum
operator|=
name|indtemp
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|indtemp
operator|=
name|indtemp
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|linenoise
index|[
name|charnum
index|]
expr_stmt|;
block|}
comment|/* *p++=linenoise[indtemp]; */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* C and its stupid null-terminated strings... */
name|array
index|[
name|index
index|]
operator|.
name|symbolic
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|m_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|g4_color
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|color
condition|)
block|{
name|array
index|[
name|index
index|]
operator|.
name|g_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|c_color
operator|=
name|colorstring
expr_stmt|;
block|}
else|else
block|{
name|array
index|[
name|index
index|]
operator|.
name|c_color
operator|=
name|NULL
expr_stmt|;
name|array
index|[
name|index
index|]
operator|.
name|g_color
operator|=
name|colorstring
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|create_colormap_from_hash (gpointer gkey,gpointer value,gpointer user_data)
name|create_colormap_from_hash
parameter_list|(
name|gpointer
name|gkey
parameter_list|,
name|gpointer
name|value
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|rgbkey
modifier|*
name|key
init|=
name|gkey
decl_stmt|;
name|gchar
modifier|*
name|string
init|=
name|g_new
argument_list|(
name|gchar
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"#%02X%02X%02X"
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|r
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|g
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|b
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|user_data
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|value
operator|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_image (const gchar * filename,GimpImage * image,GimpDrawable * drawable,GError ** error)
name|save_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GimpImage
modifier|*
name|image
parameter_list|,
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|Babl
modifier|*
name|format
decl_stmt|;
name|gint
name|width
decl_stmt|;
name|gint
name|height
decl_stmt|;
name|gint
name|ncolors
init|=
literal|1
decl_stmt|;
name|gint
modifier|*
name|indexno
decl_stmt|;
name|gboolean
name|indexed
decl_stmt|;
name|gboolean
name|alpha
decl_stmt|;
name|XpmColor
modifier|*
name|colormap
decl_stmt|;
name|XpmImage
modifier|*
name|xpm_image
decl_stmt|;
name|guint
modifier|*
name|ibuff
init|=
name|NULL
decl_stmt|;
name|guchar
modifier|*
name|buf
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|GHashTable
modifier|*
name|hash
init|=
name|NULL
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gint
name|threshold
init|=
name|xpmvals
operator|.
name|threshold
decl_stmt|;
name|gboolean
name|success
init|=
name|FALSE
decl_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|width
operator|=
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|height
operator|=
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|color
operator|=
operator|!
name|gimp_drawable_is_gray
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|indexed
operator|=
name|gimp_drawable_is_indexed
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gimp_drawable_type
argument_list|(
name|drawable
argument_list|)
condition|)
block|{
case|case
name|GIMP_RGB_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B' u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y'A u8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED_IMAGE
case|:
case|case
name|GIMP_INDEXEDA_IMAGE
case|:
name|format
operator|=
name|gegl_buffer_get_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported drawable type"
argument_list|)
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* allocate buffer making the assumption that ibuff is 32 bit aligned... */
name|ibuff
operator|=
name|g_new
argument_list|(
name|guint
argument_list|,
name|width
operator|*
name|height
argument_list|)
expr_stmt|;
name|hash
operator|=
name|g_hash_table_new
argument_list|(
operator|(
name|GHashFunc
operator|)
name|rgbhash
argument_list|,
operator|(
name|GCompareFunc
operator|)
name|compare
argument_list|)
expr_stmt|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Exporting '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|ncolors
operator|=
name|alpha
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* allocate a pixel region to work with */
name|buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimp_tile_height
argument_list|()
operator|*
name|width
operator|*
name|babl_format_get_bytes_per_pixel
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process each row of tiles */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|+=
name|gimp_tile_height
argument_list|()
control|)
block|{
name|gint
name|scanlines
decl_stmt|;
comment|/* read the next row of tiles */
name|scanlines
operator|=
name|MIN
argument_list|(
name|gimp_tile_height
argument_list|()
argument_list|,
name|height
operator|-
name|i
argument_list|)
expr_stmt|;
name|gegl_buffer_get
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|scanlines
argument_list|)
argument_list|,
literal|1.0
argument_list|,
name|format
argument_list|,
name|buf
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|,
name|GEGL_ABYSS_NONE
argument_list|)
expr_stmt|;
name|data
operator|=
name|buf
expr_stmt|;
comment|/* process each pixel row */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scanlines
condition|;
name|j
operator|++
control|)
block|{
comment|/* go to the start of this row in each image */
name|guint
modifier|*
name|idata
init|=
name|ibuff
operator|+
operator|(
name|i
operator|+
name|j
operator|)
operator|*
name|width
decl_stmt|;
comment|/* do each pixel in the row */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|width
condition|;
name|k
operator|++
control|)
block|{
name|rgbkey
modifier|*
name|key
init|=
name|g_new
argument_list|(
name|rgbkey
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|guchar
name|a
decl_stmt|;
comment|/* get pixel data */
name|key
operator|->
name|r
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|key
operator|->
name|g
operator|=
name|color
operator|&&
operator|!
name|indexed
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
name|key
operator|->
name|r
expr_stmt|;
name|key
operator|->
name|b
operator|=
name|color
operator|&&
operator|!
name|indexed
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
name|key
operator|->
name|r
expr_stmt|;
name|a
operator|=
name|alpha
condition|?
operator|*
operator|(
name|data
operator|++
operator|)
else|:
literal|255
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|threshold
condition|)
block|{
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|indexed
condition|)
block|{
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
operator|(
name|key
operator|->
name|r
operator|)
operator|+
operator|(
name|alpha
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|indexno
operator|=
name|g_hash_table_lookup
argument_list|(
name|hash
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexno
condition|)
block|{
name|indexno
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|indexno
operator|=
name|ncolors
operator|++
expr_stmt|;
name|g_hash_table_insert
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|indexno
argument_list|)
expr_stmt|;
name|key
operator|=
name|g_new
argument_list|(
name|rgbkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|idata
operator|++
operator|)
operator|=
operator|*
name|indexno
expr_stmt|;
block|}
block|}
block|}
comment|/* kick the progress bar */
name|gimp_progress_update
argument_list|(
call|(
name|gdouble
call|)
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|height
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexed
condition|)
block|{
name|guchar
modifier|*
name|cmap
init|=
name|gimp_image_get_colormap
argument_list|(
name|image
argument_list|,
operator|&
name|ncolors
argument_list|)
decl_stmt|;
name|guchar
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|cmap
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
name|ncolors
operator|++
expr_stmt|;
name|colormap
operator|=
name|g_new
argument_list|(
name|XpmColor
argument_list|,
name|ncolors
argument_list|)
expr_stmt|;
name|cpp
operator|=
literal|1
operator|+
operator|(
name|gdouble
operator|)
name|log
argument_list|(
name|ncolors
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|log
argument_list|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
literal|0
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|alpha
condition|?
literal|1
else|:
literal|0
init|;
name|i
operator|<
name|ncolors
condition|;
name|i
operator|++
control|)
block|{
name|gchar
modifier|*
name|string
decl_stmt|;
name|guchar
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|r
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|c
operator|++
expr_stmt|;
name|string
operator|=
name|g_new
argument_list|(
name|gchar
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"#%02X%02X%02X"
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|,
operator|(
name|int
operator|)
name|g
argument_list|,
operator|(
name|int
operator|)
name|b
argument_list|)
expr_stmt|;
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
name|i
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colormap
operator|=
name|g_new
argument_list|(
name|XpmColor
argument_list|,
name|ncolors
argument_list|)
expr_stmt|;
name|cpp
operator|=
literal|1
operator|+
operator|(
name|gdouble
operator|)
name|log
argument_list|(
name|ncolors
argument_list|)
operator|/
operator|(
name|gdouble
operator|)
name|log
argument_list|(
sizeof|sizeof
argument_list|(
name|linenoise
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
name|set_XpmImage
argument_list|(
name|colormap
argument_list|,
literal|0
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
name|g_hash_table_foreach
argument_list|(
name|hash
argument_list|,
name|create_colormap_from_hash
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
block|}
name|xpm_image
operator|=
name|g_new
argument_list|(
name|XpmImage
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpm_image
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|xpm_image
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|xpm_image
operator|->
name|ncolors
operator|=
name|ncolors
expr_stmt|;
name|xpm_image
operator|->
name|cpp
operator|=
name|cpp
expr_stmt|;
name|xpm_image
operator|->
name|colorTable
operator|=
name|colormap
expr_stmt|;
name|xpm_image
operator|->
name|data
operator|=
name|ibuff
expr_stmt|;
comment|/* do the save */
switch|switch
condition|(
name|XpmWriteFileFromXpmImage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filename
argument_list|,
name|xpm_image
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|XpmSuccess
case|:
name|success
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|XpmOpenFailed
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error opening file '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XpmFileInvalid
case|:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"XPM file invalid"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ibuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
name|g_hash_table_destroy
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (void)
name|save_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dialog
decl_stmt|;
name|GtkWidget
modifier|*
name|grid
decl_stmt|;
name|GtkAdjustment
modifier|*
name|scale_data
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|dialog
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"XPM"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
name|SAVE_PROC
argument_list|)
expr_stmt|;
name|grid
operator|=
name|gtk_grid_new
argument_list|()
expr_stmt|;
name|gtk_grid_set_column_spacing
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dialog
argument_list|)
argument_list|)
argument_list|,
name|grid
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|grid
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_GRID
argument_list|(
name|grid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"_Alpha threshold:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|xpmvals
operator|.
name|threshold
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_int_adjustment_update
argument_list|)
argument_list|,
operator|&
name|xpmvals
operator|.
name|threshold
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dialog
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

end_unit

