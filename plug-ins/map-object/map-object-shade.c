begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Shading stuff */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"map-object-apply.h"
end_include

begin_include
include|#
directive|include
file|"map-object-main.h"
end_include

begin_include
include|#
directive|include
file|"map-object-image.h"
end_include

begin_include
include|#
directive|include
file|"map-object-shade.h"
end_include

begin_decl_stmt
DECL|variable|bx1
DECL|variable|by1
DECL|variable|bx2
DECL|variable|by2
specifier|static
name|gdouble
name|bx1
decl_stmt|,
name|by1
decl_stmt|,
name|bx2
decl_stmt|,
name|by2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_ray_color
name|get_ray_color_func
name|get_ray_color
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2acbaa0f0108
block|{
DECL|member|u
DECL|member|v
name|gdouble
name|u
decl_stmt|,
name|v
decl_stmt|;
DECL|member|t
name|gdouble
name|t
decl_stmt|;
DECL|member|s
name|GimpVector3
name|s
decl_stmt|;
DECL|member|n
name|GimpVector3
name|n
decl_stmt|;
DECL|member|face
name|gint
name|face
decl_stmt|;
DECL|typedef|FaceIntersectInfo
block|}
name|FaceIntersectInfo
typedef|;
end_typedef

begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Phong shading */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_function
specifier|static
name|GimpRGB
DECL|function|phong_shade (GimpVector3 * pos,GimpVector3 * viewpoint,GimpVector3 * normal,GimpRGB * diff_col,GimpRGB * spec_col,LightType type)
name|phong_shade
parameter_list|(
name|GimpVector3
modifier|*
name|pos
parameter_list|,
name|GimpVector3
modifier|*
name|viewpoint
parameter_list|,
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|GimpRGB
modifier|*
name|diff_col
parameter_list|,
name|GimpRGB
modifier|*
name|spec_col
parameter_list|,
name|LightType
name|type
parameter_list|)
block|{
name|GimpRGB
name|ambientcolor
decl_stmt|,
name|diffusecolor
decl_stmt|,
name|specularcolor
decl_stmt|;
name|gdouble
name|NL
decl_stmt|,
name|RV
decl_stmt|,
name|dist
decl_stmt|;
name|GimpVector3
name|L
decl_stmt|,
name|NN
decl_stmt|,
name|V
decl_stmt|,
name|N
decl_stmt|;
name|GimpVector3
modifier|*
name|light
decl_stmt|;
name|light
operator|=
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|==
name|DIRECTIONAL_LIGHT
condition|?
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|direction
else|:
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
operator|,
comment|/* Compute ambient intensity */
comment|/* ========================= */
name|N
operator|=
operator|*
name|normal
expr_stmt|;
name|ambientcolor
operator|=
operator|*
name|diff_col
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|ambientcolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
comment|/* Compute (N*L) term of Phong's equation */
comment|/* ====================================== */
if|if
condition|(
name|type
operator|==
name|POINT_LIGHT
condition|)
name|gimp_vector3_sub
argument_list|(
operator|&
name|L
argument_list|,
name|light
argument_list|,
name|pos
argument_list|)
expr_stmt|;
else|else
name|L
operator|=
operator|*
name|light
expr_stmt|;
name|dist
operator|=
name|gimp_vector3_length
argument_list|(
operator|&
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|!=
literal|0.0
condition|)
name|gimp_vector3_mul
argument_list|(
operator|&
name|L
argument_list|,
literal|1.0
operator|/
name|dist
argument_list|)
expr_stmt|;
name|NL
operator|=
literal|2.0
operator|*
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|N
argument_list|,
operator|&
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|NL
operator|>=
literal|0.0
condition|)
block|{
comment|/* Compute (R*V)^alpha term of Phong's equation */
comment|/* ============================================ */
name|gimp_vector3_sub
argument_list|(
operator|&
name|V
argument_list|,
name|viewpoint
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|V
argument_list|)
expr_stmt|;
name|gimp_vector3_mul
argument_list|(
operator|&
name|N
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|NN
argument_list|,
operator|&
name|N
argument_list|,
operator|&
name|L
argument_list|)
expr_stmt|;
name|RV
operator|=
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|NN
argument_list|,
operator|&
name|V
argument_list|)
expr_stmt|;
name|RV
operator|=
literal|0.0
operator|<
name|RV
condition|?
name|pow
argument_list|(
name|RV
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|highlight
argument_list|)
else|:
literal|0.0
expr_stmt|;
comment|/* Compute diffuse and specular intensity contribution */
comment|/* =================================================== */
name|diffusecolor
operator|=
operator|*
name|diff_col
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|diffusecolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_ref
argument_list|)
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|diffusecolor
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|specularcolor
operator|=
operator|*
name|spec_col
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|specularcolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|specular_ref
argument_list|)
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|specularcolor
argument_list|,
name|RV
argument_list|)
expr_stmt|;
name|gimp_rgb_add
argument_list|(
operator|&
name|diffusecolor
argument_list|,
operator|&
name|specularcolor
argument_list|)
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|diffusecolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|diffusecolor
argument_list|)
expr_stmt|;
name|gimp_rgb_add
argument_list|(
operator|&
name|ambientcolor
argument_list|,
operator|&
name|diffusecolor
argument_list|)
expr_stmt|;
block|}
return|return
name|ambientcolor
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|plane_intersect (GimpVector3 * dir,GimpVector3 * viewp,GimpVector3 * ipos,gdouble * u,gdouble * v)
name|plane_intersect
parameter_list|(
name|GimpVector3
modifier|*
name|dir
parameter_list|,
name|GimpVector3
modifier|*
name|viewp
parameter_list|,
name|GimpVector3
modifier|*
name|ipos
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
specifier|static
name|gdouble
name|det
decl_stmt|,
name|det1
decl_stmt|,
name|det2
decl_stmt|,
name|det3
decl_stmt|,
name|t
decl_stmt|;
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|x
expr_stmt|;
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|y
expr_stmt|;
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|z
expr_stmt|;
comment|/* Compute determinant of the first 3x3 sub matrix (denominator) */
comment|/* ============================================================= */
name|det
operator|=
operator|(
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* If the determinant is non-zero, a intersection point exists */
comment|/* =========================================================== */
if|if
condition|(
name|det
operator|!=
literal|0.0
condition|)
block|{
comment|/* Now, lets compute the numerator determinants (wow ;) */
comment|/* ==================================================== */
name|det1
operator|=
operator|(
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|-
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|det2
operator|=
operator|(
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|det3
operator|=
operator|(
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* Now we have the simultanous solutions. Lets compute the unknowns */
comment|/* (skip u&v if t is<0, this means the intersection is behind us)  */
comment|/* ================================================================ */
name|t
operator|=
name|det1
operator|/
name|det
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0.0
condition|)
block|{
operator|*
name|u
operator|=
literal|1.0
operator|+
operator|(
operator|(
name|det2
operator|/
name|det
operator|)
operator|-
literal|0.5
operator|)
expr_stmt|;
operator|*
name|v
operator|=
literal|1.0
operator|+
operator|(
operator|(
name|det3
operator|/
name|det
operator|)
operator|-
literal|0.5
operator|)
expr_stmt|;
name|ipos
operator|->
name|x
operator|=
name|viewp
operator|->
name|x
operator|+
name|t
operator|*
name|dir
operator|->
name|x
expr_stmt|;
name|ipos
operator|->
name|y
operator|=
name|viewp
operator|->
name|y
operator|+
name|t
operator|*
name|dir
operator|->
name|y
expr_stmt|;
name|ipos
operator|->
name|z
operator|=
name|viewp
operator|->
name|z
operator|+
name|t
operator|*
name|dir
operator|->
name|z
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * These routines computes the color of the surface  * of the plane at a given point  *****************************************************************************/
end_comment

begin_function
name|GimpRGB
DECL|function|get_ray_color_plane (GimpVector3 * pos)
name|get_ray_color_plane
parameter_list|(
name|GimpVector3
modifier|*
name|pos
parameter_list|)
block|{
name|GimpRGB
name|color
init|=
name|background
decl_stmt|;
specifier|static
name|gint
name|inside
init|=
name|FALSE
decl_stmt|;
specifier|static
name|GimpVector3
name|ray
decl_stmt|,
name|spos
decl_stmt|;
specifier|static
name|gdouble
name|vx
decl_stmt|,
name|vy
decl_stmt|;
comment|/* Construct a line from our VP to the point */
comment|/* ========================================= */
name|gimp_vector3_sub
argument_list|(
operator|&
name|ray
argument_list|,
name|pos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|ray
argument_list|)
expr_stmt|;
comment|/* Check for intersection. This is a quasi ray-tracer. */
comment|/* =================================================== */
if|if
condition|(
name|plane_intersect
argument_list|(
operator|&
name|ray
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|spos
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|color
operator|=
name|get_image_color
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
operator|.
name|a
operator|!=
literal|0.0
operator|&&
name|inside
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|!=
name|NO_LIGHT
condition|)
block|{
comment|/* Compute shading at this point */
comment|/* ============================= */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|spos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|normal
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|==
name|FALSE
operator|&&
name|color
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
name|gimp_rgb_composite
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|background
argument_list|,
name|GIMP_RGB_COMPOSITE_BEHIND
argument_list|)
expr_stmt|;
block|}
return|return
name|color
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Given the NorthPole, Equator and a third vector (normal) compute    */
end_comment

begin_comment
comment|/* the conversion from spherical oordinates to image space coordinates */
end_comment

begin_comment
comment|/***********************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|sphere_to_image (GimpVector3 * normal,gdouble * u,gdouble * v)
name|sphere_to_image
parameter_list|(
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
specifier|static
name|gdouble
name|alpha
decl_stmt|,
name|fac
decl_stmt|;
specifier|static
name|GimpVector3
name|cross_prod
decl_stmt|;
name|alpha
operator|=
name|acos
argument_list|(
operator|-
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|mapvals
operator|.
name|secondaxis
argument_list|,
name|normal
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|alpha
operator|/
name|G_PI
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0.0
operator|||
operator|*
name|v
operator|==
literal|1.0
condition|)
block|{
operator|*
name|u
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|fac
operator|=
operator|(
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|mapvals
operator|.
name|firstaxis
argument_list|,
name|normal
argument_list|)
operator|/
name|sin
argument_list|(
name|alpha
argument_list|)
operator|)
expr_stmt|;
comment|/* Make sure that we map to -1.0..1.0 (take care of rounding errors) */
comment|/* ================================================================= */
name|fac
operator|=
name|CLAMP
argument_list|(
name|fac
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
operator|*
name|u
operator|=
name|acos
argument_list|(
name|fac
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|G_PI
operator|)
expr_stmt|;
name|cross_prod
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|mapvals
operator|.
name|secondaxis
argument_list|,
operator|&
name|mapvals
operator|.
name|firstaxis
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|cross_prod
argument_list|,
name|normal
argument_list|)
operator|<
literal|0.0
condition|)
operator|*
name|u
operator|=
literal|1.0
operator|-
operator|*
name|u
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/* Compute intersection point with sphere (if any) */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|gint
DECL|function|sphere_intersect (GimpVector3 * dir,GimpVector3 * viewp,GimpVector3 * spos1,GimpVector3 * spos2)
name|sphere_intersect
parameter_list|(
name|GimpVector3
modifier|*
name|dir
parameter_list|,
name|GimpVector3
modifier|*
name|viewp
parameter_list|,
name|GimpVector3
modifier|*
name|spos1
parameter_list|,
name|GimpVector3
modifier|*
name|spos2
parameter_list|)
block|{
specifier|static
name|gdouble
name|alpha
decl_stmt|,
name|beta
decl_stmt|,
name|tau
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|GimpVector3
name|t
decl_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|mapvals
operator|.
name|position
argument_list|,
name|viewp
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|gimp_vector3_inner_product
argument_list|(
name|dir
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|beta
operator|=
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|tau
operator|=
name|alpha
operator|*
name|alpha
operator|-
name|beta
operator|+
name|mapvals
operator|.
name|radius
operator|*
name|mapvals
operator|.
name|radius
expr_stmt|;
if|if
condition|(
name|tau
operator|>=
literal|0.0
condition|)
block|{
name|tau
operator|=
name|sqrt
argument_list|(
name|tau
argument_list|)
expr_stmt|;
name|s1
operator|=
name|alpha
operator|+
name|tau
expr_stmt|;
name|s2
operator|=
name|alpha
operator|-
name|tau
expr_stmt|;
if|if
condition|(
name|s2
operator|<
name|s1
condition|)
block|{
name|tmp
operator|=
name|s1
expr_stmt|;
name|s1
operator|=
name|s2
expr_stmt|;
name|s2
operator|=
name|tmp
expr_stmt|;
block|}
name|spos1
operator|->
name|x
operator|=
name|viewp
operator|->
name|x
operator|+
name|s1
operator|*
name|dir
operator|->
name|x
expr_stmt|;
name|spos1
operator|->
name|y
operator|=
name|viewp
operator|->
name|y
operator|+
name|s1
operator|*
name|dir
operator|->
name|y
expr_stmt|;
name|spos1
operator|->
name|z
operator|=
name|viewp
operator|->
name|z
operator|+
name|s1
operator|*
name|dir
operator|->
name|z
expr_stmt|;
name|spos2
operator|->
name|x
operator|=
name|viewp
operator|->
name|x
operator|+
name|s2
operator|*
name|dir
operator|->
name|x
expr_stmt|;
name|spos2
operator|->
name|y
operator|=
name|viewp
operator|->
name|y
operator|+
name|s2
operator|*
name|dir
operator|->
name|y
expr_stmt|;
name|spos2
operator|->
name|z
operator|=
name|viewp
operator|->
name|z
operator|+
name|s2
operator|*
name|dir
operator|->
name|z
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * These routines computes the color of the surface  * of the sphere at a given point  *****************************************************************************/
end_comment

begin_function
name|GimpRGB
DECL|function|get_ray_color_sphere (GimpVector3 * pos)
name|get_ray_color_sphere
parameter_list|(
name|GimpVector3
modifier|*
name|pos
parameter_list|)
block|{
name|GimpRGB
name|color
init|=
name|background
decl_stmt|;
specifier|static
name|GimpRGB
name|color2
decl_stmt|;
specifier|static
name|gint
name|inside
init|=
name|FALSE
decl_stmt|;
specifier|static
name|GimpVector3
name|normal
decl_stmt|,
name|ray
decl_stmt|,
name|spos1
decl_stmt|,
name|spos2
decl_stmt|;
specifier|static
name|gdouble
name|vx
decl_stmt|,
name|vy
decl_stmt|;
comment|/* Check if ray is within the bounding box */
comment|/* ======================================= */
if|if
condition|(
name|pos
operator|->
name|x
operator|<
name|bx1
operator|||
name|pos
operator|->
name|x
operator|>
name|bx2
operator|||
name|pos
operator|->
name|y
operator|<
name|by1
operator|||
name|pos
operator|->
name|y
operator|>
name|by2
condition|)
return|return
name|color
return|;
comment|/* Construct a line from our VP to the point */
comment|/* ========================================= */
name|gimp_vector3_sub
argument_list|(
operator|&
name|ray
argument_list|,
name|pos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|ray
argument_list|)
expr_stmt|;
comment|/* Check for intersection. This is a quasi ray-tracer. */
comment|/* =================================================== */
if|if
condition|(
name|sphere_intersect
argument_list|(
operator|&
name|ray
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|spos1
argument_list|,
operator|&
name|spos2
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|/* Compute spherical to rectangular mapping */
comment|/* ======================================== */
name|gimp_vector3_sub
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|spos1
argument_list|,
operator|&
name|mapvals
operator|.
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|sphere_to_image
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
expr_stmt|;
name|color
operator|=
name|get_image_color
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
comment|/* Check for total transparency... */
comment|/* =============================== */
if|if
condition|(
name|color
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
comment|/* Hey, we can see  through here!      */
comment|/* Lets see what's on the other side.. */
comment|/* =================================== */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|spos1
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|spos2
argument_list|,
operator|&
name|mapvals
operator|.
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|sphere_to_image
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
expr_stmt|;
name|color2
operator|=
name|get_image_color
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
comment|/* Make the normal point inwards */
comment|/* ============================= */
name|gimp_vector3_mul
argument_list|(
operator|&
name|normal
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|color2
operator|=
name|phong_shade
argument_list|(
operator|&
name|spos2
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|color2
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color2
argument_list|)
expr_stmt|;
comment|/* Compute a mix of the first and second colors */
comment|/* ============================================ */
name|gimp_rgb_composite
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|color2
argument_list|,
name|GIMP_RGB_COMPOSITE_NORMAL
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
operator|.
name|a
operator|!=
literal|0.0
operator|&&
name|inside
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|!=
name|NO_LIGHT
condition|)
block|{
comment|/* Compute shading at this point */
comment|/* ============================= */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|spos1
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|==
name|FALSE
operator|&&
name|color
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
name|gimp_rgb_composite
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|background
argument_list|,
name|GIMP_RGB_COMPOSITE_BEHIND
argument_list|)
expr_stmt|;
block|}
return|return
name|color
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/* Transform the corners of the bounding box to 2D */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
name|void
DECL|function|compute_bounding_box (void)
name|compute_bounding_box
parameter_list|(
name|void
parameter_list|)
block|{
name|GimpVector3
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|gdouble
name|t
decl_stmt|;
name|GimpVector3
name|dir
decl_stmt|;
name|p1
operator|=
name|mapvals
operator|.
name|position
expr_stmt|;
name|p1
operator|.
name|x
operator|-=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|p1
operator|.
name|y
operator|-=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|p2
operator|=
name|mapvals
operator|.
name|position
expr_stmt|;
name|p2
operator|.
name|x
operator|+=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|p2
operator|.
name|y
operator|+=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|z
operator|!=
literal|0.0
condition|)
block|{
name|t
operator|=
operator|(
operator|-
literal|1.0
operator|*
name|mapvals
operator|.
name|viewpoint
operator|.
name|z
operator|)
operator|/
name|dir
operator|.
name|z
expr_stmt|;
name|p1
operator|.
name|x
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|x
operator|+
name|t
operator|*
name|dir
operator|.
name|x
operator|)
expr_stmt|;
name|p1
operator|.
name|y
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|y
operator|+
name|t
operator|*
name|dir
operator|.
name|y
operator|)
expr_stmt|;
block|}
name|gimp_vector3_sub
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|p2
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|z
operator|!=
literal|0.0
condition|)
block|{
name|t
operator|=
operator|(
operator|-
literal|1.0
operator|*
name|mapvals
operator|.
name|viewpoint
operator|.
name|z
operator|)
operator|/
name|dir
operator|.
name|z
expr_stmt|;
name|p2
operator|.
name|x
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|x
operator|+
name|t
operator|*
name|dir
operator|.
name|x
operator|)
expr_stmt|;
name|p2
operator|.
name|y
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|y
operator|+
name|t
operator|*
name|dir
operator|.
name|y
operator|)
expr_stmt|;
block|}
name|bx1
operator|=
name|p1
operator|.
name|x
expr_stmt|;
name|by1
operator|=
name|p1
operator|.
name|y
expr_stmt|;
name|bx2
operator|=
name|p2
operator|.
name|x
expr_stmt|;
name|by2
operator|=
name|p2
operator|.
name|y
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These two were taken from the Mesa source. Mesa is written   */
end_comment

begin_comment
comment|/* and is (C) by Brian Paul. vecmulmat() performs a post-mul by */
end_comment

begin_comment
comment|/* a 4x4 matrix to a 1x4(3) vector. rotmat() creates a matrix   */
end_comment

begin_comment
comment|/* that by post-mul will rotate a 1x4(3) vector the given angle */
end_comment

begin_comment
comment|/* about the given axis.                                        */
end_comment

begin_comment
comment|/* ============================================================ */
end_comment

begin_function
name|void
DECL|function|vecmulmat (GimpVector3 * u,GimpVector3 * v,gfloat m[16])
name|vecmulmat
parameter_list|(
name|GimpVector3
modifier|*
name|u
parameter_list|,
name|GimpVector3
modifier|*
name|v
parameter_list|,
name|gfloat
name|m
index|[
literal|16
index|]
parameter_list|)
block|{
name|gfloat
name|v0
init|=
name|v
operator|->
name|x
decl_stmt|,
name|v1
init|=
name|v
operator|->
name|y
decl_stmt|,
name|v2
init|=
name|v
operator|->
name|z
decl_stmt|;
DECL|macro|M (row,col)
define|#
directive|define
name|M
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|m[col*4+row]
name|u
operator|->
name|x
operator|=
name|v0
operator|*
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|v1
operator|*
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|+
name|v2
operator|*
name|M
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|+
name|M
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|->
name|y
operator|=
name|v0
operator|*
name|M
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|+
name|v1
operator|*
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|+
name|v2
operator|*
name|M
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|+
name|M
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|u
operator|->
name|z
operator|=
name|v0
operator|*
name|M
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|+
name|v1
operator|*
name|M
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|+
name|v2
operator|*
name|M
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
operator|+
name|M
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|M
block|}
end_function

begin_function
name|void
DECL|function|rotatemat (gfloat angle,GimpVector3 * v,gfloat m[16])
name|rotatemat
parameter_list|(
name|gfloat
name|angle
parameter_list|,
name|GimpVector3
modifier|*
name|v
parameter_list|,
name|gfloat
name|m
index|[
literal|16
index|]
parameter_list|)
block|{
comment|/* This function contributed by Erich Boleyn (erich@uruk.org) */
name|gfloat
name|mag
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|;
name|gfloat
name|xx
decl_stmt|,
name|yy
decl_stmt|,
name|zz
decl_stmt|,
name|xy
decl_stmt|,
name|yz
decl_stmt|,
name|zx
decl_stmt|,
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|zs
decl_stmt|,
name|one_c
decl_stmt|;
name|gfloat
name|IdentityMat
index|[
literal|16
index|]
decl_stmt|;
name|gint
name|cnt
decl_stmt|;
name|s
operator|=
name|sin
argument_list|(
name|angle
operator|*
operator|(
name|G_PI
operator|/
literal|180.0
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|angle
operator|*
operator|(
name|G_PI
operator|/
literal|180.0
operator|)
argument_list|)
expr_stmt|;
name|mag
operator|=
name|sqrt
argument_list|(
name|v
operator|->
name|x
operator|*
name|v
operator|->
name|x
operator|+
name|v
operator|->
name|y
operator|*
name|v
operator|->
name|y
operator|+
name|v
operator|->
name|z
operator|*
name|v
operator|->
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|==
literal|0.0
condition|)
block|{
comment|/* generate an identity matrix and return */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|16
condition|;
name|cnt
operator|++
control|)
name|IdentityMat
index|[
name|cnt
index|]
operator|=
literal|0.0
expr_stmt|;
name|IdentityMat
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
name|IdentityMat
index|[
literal|5
index|]
operator|=
literal|1.0
expr_stmt|;
name|IdentityMat
index|[
literal|10
index|]
operator|=
literal|1.0
expr_stmt|;
name|IdentityMat
index|[
literal|15
index|]
operator|=
literal|1.0
expr_stmt|;
name|memcpy
argument_list|(
name|m
argument_list|,
name|IdentityMat
argument_list|,
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|x
operator|/=
name|mag
expr_stmt|;
name|v
operator|->
name|y
operator|/=
name|mag
expr_stmt|;
name|v
operator|->
name|z
operator|/=
name|mag
expr_stmt|;
DECL|macro|M (row,col)
define|#
directive|define
name|M
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|m[col*4+row]
name|xx
operator|=
name|v
operator|->
name|x
operator|*
name|v
operator|->
name|x
expr_stmt|;
name|yy
operator|=
name|v
operator|->
name|y
operator|*
name|v
operator|->
name|y
expr_stmt|;
name|zz
operator|=
name|v
operator|->
name|z
operator|*
name|v
operator|->
name|z
expr_stmt|;
name|xy
operator|=
name|v
operator|->
name|x
operator|*
name|v
operator|->
name|y
expr_stmt|;
name|yz
operator|=
name|v
operator|->
name|y
operator|*
name|v
operator|->
name|z
expr_stmt|;
name|zx
operator|=
name|v
operator|->
name|z
operator|*
name|v
operator|->
name|x
expr_stmt|;
name|xs
operator|=
name|v
operator|->
name|x
operator|*
name|s
expr_stmt|;
name|ys
operator|=
name|v
operator|->
name|y
operator|*
name|s
expr_stmt|;
name|zs
operator|=
name|v
operator|->
name|z
operator|*
name|s
expr_stmt|;
name|one_c
operator|=
literal|1.0F
operator|-
name|c
expr_stmt|;
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|xx
operator|)
operator|+
name|c
expr_stmt|;
name|M
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|xy
operator|)
operator|-
name|zs
expr_stmt|;
name|M
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|zx
operator|)
operator|+
name|ys
expr_stmt|;
name|M
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|=
literal|0.0F
expr_stmt|;
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|xy
operator|)
operator|+
name|zs
expr_stmt|;
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|yy
operator|)
operator|+
name|c
expr_stmt|;
name|M
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|yz
operator|)
operator|-
name|xs
expr_stmt|;
name|M
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
operator|=
literal|0.0F
expr_stmt|;
name|M
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|zx
operator|)
operator|-
name|ys
expr_stmt|;
name|M
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|yz
operator|)
operator|+
name|xs
expr_stmt|;
name|M
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
operator|=
operator|(
name|one_c
operator|*
name|zz
operator|)
operator|+
name|c
expr_stmt|;
name|M
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
operator|=
literal|0.0F
expr_stmt|;
name|M
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
operator|=
literal|0.0F
expr_stmt|;
name|M
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
operator|=
literal|0.0F
expr_stmt|;
name|M
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|=
literal|0.0F
expr_stmt|;
name|M
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
operator|=
literal|1.0F
expr_stmt|;
undef|#
directive|undef
name|M
block|}
end_function

begin_comment
comment|/* Transpose the matrix m. If m is orthogonal (like a rotation matrix), */
end_comment

begin_comment
comment|/* this is equal to the inverse of the matrix.                          */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_function
name|void
DECL|function|transpose_mat (gfloat m[16])
name|transpose_mat
parameter_list|(
name|gfloat
name|m
index|[
literal|16
index|]
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gfloat
name|t
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
name|m
index|[
name|j
operator|*
literal|4
operator|+
name|i
index|]
expr_stmt|;
name|m
index|[
name|j
operator|*
literal|4
operator|+
name|i
index|]
operator|=
name|m
index|[
name|i
operator|*
literal|4
operator|+
name|j
index|]
expr_stmt|;
name|m
index|[
name|i
operator|*
literal|4
operator|+
name|j
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the matrix product c=a*b */
end_comment

begin_comment
comment|/* ================================ */
end_comment

begin_function
name|void
DECL|function|matmul (gfloat a[16],gfloat b[16],gfloat c[16])
name|matmul
parameter_list|(
name|gfloat
name|a
index|[
literal|16
index|]
parameter_list|,
name|gfloat
name|b
index|[
literal|16
index|]
parameter_list|,
name|gfloat
name|c
index|[
literal|16
index|]
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gfloat
name|value
decl_stmt|;
DECL|macro|A (row,col)
define|#
directive|define
name|A
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|a[col*4+row]
DECL|macro|B (row,col)
define|#
directive|define
name|B
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|b[col*4+row]
DECL|macro|C (row,col)
define|#
directive|define
name|C
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|c[col*4+row]
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|value
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
name|value
operator|+=
name|A
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
operator|*
name|B
argument_list|(
name|k
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|C
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|A
undef|#
directive|undef
name|B
undef|#
directive|undef
name|C
block|}
end_function

begin_function
name|void
DECL|function|ident_mat (gfloat m[16])
name|ident_mat
parameter_list|(
name|gfloat
name|m
index|[
literal|16
index|]
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
DECL|macro|M (row,col)
define|#
directive|define
name|M
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|m[col*4+row]
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
condition|)
name|M
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|=
literal|1.0
expr_stmt|;
else|else
name|M
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|M
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|intersect_rect (gdouble u,gdouble v,gdouble w,GimpVector3 viewp,GimpVector3 dir,FaceIntersectInfo * face_info)
name|intersect_rect
parameter_list|(
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|gdouble
name|w
parameter_list|,
name|GimpVector3
name|viewp
parameter_list|,
name|GimpVector3
name|dir
parameter_list|,
name|FaceIntersectInfo
modifier|*
name|face_info
parameter_list|)
block|{
name|gboolean
name|result
init|=
name|FALSE
decl_stmt|;
name|gdouble
name|u2
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|z
operator|!=
literal|0.0
condition|)
block|{
name|u2
operator|=
name|u
operator|/
literal|2.0
expr_stmt|;
name|v2
operator|=
name|v
operator|/
literal|2.0
expr_stmt|;
name|face_info
operator|->
name|t
operator|=
operator|(
name|w
operator|-
name|viewp
operator|.
name|z
operator|)
operator|/
name|dir
operator|.
name|z
expr_stmt|;
name|face_info
operator|->
name|s
operator|.
name|x
operator|=
name|viewp
operator|.
name|x
operator|+
name|face_info
operator|->
name|t
operator|*
name|dir
operator|.
name|x
expr_stmt|;
name|face_info
operator|->
name|s
operator|.
name|y
operator|=
name|viewp
operator|.
name|y
operator|+
name|face_info
operator|->
name|t
operator|*
name|dir
operator|.
name|y
expr_stmt|;
name|face_info
operator|->
name|s
operator|.
name|z
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|face_info
operator|->
name|s
operator|.
name|x
operator|>=
operator|-
name|u2
operator|&&
name|face_info
operator|->
name|s
operator|.
name|x
operator|<=
name|u2
operator|&&
name|face_info
operator|->
name|s
operator|.
name|y
operator|>=
operator|-
name|v2
operator|&&
name|face_info
operator|->
name|s
operator|.
name|y
operator|<=
name|v2
condition|)
block|{
name|face_info
operator|->
name|u
operator|=
operator|(
name|face_info
operator|->
name|s
operator|.
name|x
operator|+
name|u2
operator|)
operator|/
name|u
expr_stmt|;
name|face_info
operator|->
name|v
operator|=
operator|(
name|face_info
operator|->
name|s
operator|.
name|y
operator|+
name|v2
operator|)
operator|/
name|v
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|intersect_box (GimpVector3 scale,GimpVector3 viewp,GimpVector3 dir,FaceIntersectInfo * face_intersect)
name|intersect_box
parameter_list|(
name|GimpVector3
name|scale
parameter_list|,
name|GimpVector3
name|viewp
parameter_list|,
name|GimpVector3
name|dir
parameter_list|,
name|FaceIntersectInfo
modifier|*
name|face_intersect
parameter_list|)
block|{
name|GimpVector3
name|v
decl_stmt|,
name|d
decl_stmt|,
name|tmp
decl_stmt|,
name|axis
index|[
literal|3
index|]
decl_stmt|;
name|FaceIntersectInfo
name|face_tmp
decl_stmt|;
name|gboolean
name|result
init|=
name|FALSE
decl_stmt|;
name|gfloat
name|m
index|[
literal|16
index|]
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|axis
index|[
literal|0
index|]
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|axis
index|[
literal|1
index|]
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|axis
index|[
literal|2
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|/* Front side */
comment|/* ========== */
if|if
condition|(
name|intersect_rect
argument_list|(
name|scale
operator|.
name|x
argument_list|,
name|scale
operator|.
name|y
argument_list|,
name|scale
operator|.
name|z
operator|/
literal|2.0
argument_list|,
name|viewp
argument_list|,
name|dir
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|0
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
operator|++
index|]
operator|.
name|n
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Back side */
comment|/* ========= */
if|if
condition|(
name|intersect_rect
argument_list|(
name|scale
operator|.
name|x
argument_list|,
name|scale
operator|.
name|y
argument_list|,
operator|-
name|scale
operator|.
name|z
operator|/
literal|2.0
argument_list|,
name|viewp
argument_list|,
name|dir
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|1
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|u
operator|=
literal|1.0
operator|-
name|face_intersect
index|[
name|i
index|]
operator|.
name|u
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
operator|++
index|]
operator|.
name|n
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Check if we've found the two possible intersection points */
comment|/* ========================================================= */
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
comment|/* Top: Rotate viewpoint and direction into rectangle's local coordinate system */
comment|/* ============================================================================ */
name|rotatemat
argument_list|(
literal|90
argument_list|,
operator|&
name|axis
index|[
literal|0
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|viewp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|dir
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersect_rect
argument_list|(
name|scale
operator|.
name|x
argument_list|,
name|scale
operator|.
name|z
argument_list|,
name|scale
operator|.
name|y
operator|/
literal|2.0
argument_list|,
name|v
argument_list|,
name|d
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|2
expr_stmt|;
name|transpose_mat
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|=
name|tmp
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
operator|++
index|]
operator|.
name|n
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Check if we've found the two possible intersection points */
comment|/* ========================================================= */
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
comment|/* Bottom: Rotate viewpoint and direction into rectangle's local coordinate system */
comment|/* =============================================================================== */
name|rotatemat
argument_list|(
literal|90
argument_list|,
operator|&
name|axis
index|[
literal|0
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|viewp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|dir
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersect_rect
argument_list|(
name|scale
operator|.
name|x
argument_list|,
name|scale
operator|.
name|z
argument_list|,
operator|-
name|scale
operator|.
name|y
operator|/
literal|2.0
argument_list|,
name|v
argument_list|,
name|d
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|3
expr_stmt|;
name|transpose_mat
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|=
name|tmp
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|v
operator|=
literal|1.0
operator|-
name|face_intersect
index|[
name|i
index|]
operator|.
name|v
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
operator|++
index|]
operator|.
name|n
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Check if we've found the two possible intersection points */
comment|/* ========================================================= */
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
comment|/* Left side: Rotate viewpoint and direction into rectangle's local coordinate system */
comment|/* ================================================================================== */
name|rotatemat
argument_list|(
literal|90
argument_list|,
operator|&
name|axis
index|[
literal|1
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|viewp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|dir
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersect_rect
argument_list|(
name|scale
operator|.
name|z
argument_list|,
name|scale
operator|.
name|y
argument_list|,
name|scale
operator|.
name|x
operator|/
literal|2.0
argument_list|,
name|v
argument_list|,
name|d
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|4
expr_stmt|;
name|transpose_mat
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|=
name|tmp
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
operator|++
index|]
operator|.
name|n
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Check if we've found the two possible intersection points */
comment|/* ========================================================= */
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
comment|/* Right side: Rotate viewpoint and direction into rectangle's local coordinate system */
comment|/* =================================================================================== */
name|rotatemat
argument_list|(
literal|90
argument_list|,
operator|&
name|axis
index|[
literal|1
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|viewp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|dir
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersect_rect
argument_list|(
name|scale
operator|.
name|z
argument_list|,
name|scale
operator|.
name|y
argument_list|,
operator|-
name|scale
operator|.
name|x
operator|/
literal|2.0
argument_list|,
name|v
argument_list|,
name|d
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|5
expr_stmt|;
name|transpose_mat
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|u
operator|=
literal|1.0
operator|-
name|face_intersect
index|[
name|i
index|]
operator|.
name|u
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
operator|++
index|]
operator|.
name|n
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Sort intersection points */
comment|/* ======================== */
if|if
condition|(
name|face_intersect
index|[
literal|0
index|]
operator|.
name|t
operator|>
name|face_intersect
index|[
literal|1
index|]
operator|.
name|t
condition|)
block|{
name|face_tmp
operator|=
name|face_intersect
index|[
literal|0
index|]
expr_stmt|;
name|face_intersect
index|[
literal|0
index|]
operator|=
name|face_intersect
index|[
literal|1
index|]
expr_stmt|;
name|face_intersect
index|[
literal|1
index|]
operator|=
name|face_tmp
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|get_ray_color_box (GimpVector3 * pos)
name|get_ray_color_box
parameter_list|(
name|GimpVector3
modifier|*
name|pos
parameter_list|)
block|{
name|GimpVector3
name|lvp
decl_stmt|,
name|ldir
decl_stmt|,
name|vp
decl_stmt|,
name|p
decl_stmt|,
name|dir
decl_stmt|,
name|ns
decl_stmt|,
name|nn
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|,
name|color2
decl_stmt|;
name|gfloat
name|m
index|[
literal|16
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|FaceIntersectInfo
name|face_intersect
index|[
literal|2
index|]
decl_stmt|;
name|color
operator|=
name|background
expr_stmt|;
name|vp
operator|=
name|mapvals
operator|.
name|viewpoint
expr_stmt|;
name|p
operator|=
operator|*
name|pos
expr_stmt|;
comment|/* Translate viewpoint so that the box has its origin */
comment|/* at its lower left corner.                          */
comment|/* ================================================== */
name|vp
operator|.
name|x
operator|=
name|vp
operator|.
name|x
operator|-
name|mapvals
operator|.
name|position
operator|.
name|x
expr_stmt|;
name|vp
operator|.
name|y
operator|=
name|vp
operator|.
name|y
operator|-
name|mapvals
operator|.
name|position
operator|.
name|y
expr_stmt|;
name|vp
operator|.
name|z
operator|=
name|vp
operator|.
name|z
operator|-
name|mapvals
operator|.
name|position
operator|.
name|z
expr_stmt|;
name|p
operator|.
name|x
operator|=
name|p
operator|.
name|x
operator|-
name|mapvals
operator|.
name|position
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|=
name|p
operator|.
name|y
operator|-
name|mapvals
operator|.
name|position
operator|.
name|y
expr_stmt|;
name|p
operator|.
name|z
operator|=
name|p
operator|.
name|z
operator|-
name|mapvals
operator|.
name|position
operator|.
name|z
expr_stmt|;
comment|/* Compute direction */
comment|/* ================= */
name|gimp_vector3_sub
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
comment|/* Compute inverse of rotation matrix and apply it to   */
comment|/* the viewpoint and direction. This transforms the     */
comment|/* observer into the local coordinate system of the box */
comment|/* ==================================================== */
name|memcpy
argument_list|(
name|m
argument_list|,
name|rotmat
argument_list|,
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
name|transpose_mat
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|lvp
argument_list|,
operator|&
name|vp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|ldir
argument_list|,
operator|&
name|dir
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Ok. Now the observer is in the space where the box is located */
comment|/* with its lower left corner at the origin and its axis aligned */
comment|/* to the cartesian basis. Check if the transformed ray hits it. */
comment|/* ============================================================= */
name|face_intersect
index|[
literal|0
index|]
operator|.
name|t
operator|=
literal|1000000.0
expr_stmt|;
name|face_intersect
index|[
literal|1
index|]
operator|.
name|t
operator|=
literal|1000000.0
expr_stmt|;
if|if
condition|(
name|intersect_box
argument_list|(
name|mapvals
operator|.
name|scale
argument_list|,
name|lvp
argument_list|,
name|ldir
argument_list|,
name|face_intersect
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|/* We've hit the box. Transform the hit points and */
comment|/* normals back into the world coordinate system   */
comment|/* =============================================== */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|vecmulmat
argument_list|(
operator|&
name|ns
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|rotmat
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|nn
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
argument_list|,
name|rotmat
argument_list|)
expr_stmt|;
name|ns
operator|.
name|x
operator|=
name|ns
operator|.
name|x
operator|+
name|mapvals
operator|.
name|position
operator|.
name|x
expr_stmt|;
name|ns
operator|.
name|y
operator|=
name|ns
operator|.
name|y
operator|+
name|mapvals
operator|.
name|position
operator|.
name|y
expr_stmt|;
name|ns
operator|.
name|z
operator|=
name|ns
operator|.
name|z
operator|+
name|mapvals
operator|.
name|position
operator|.
name|z
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|=
name|ns
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
operator|=
name|nn
expr_stmt|;
block|}
name|color
operator|=
name|get_box_image_color
argument_list|(
name|face_intersect
index|[
literal|0
index|]
operator|.
name|face
argument_list|,
name|face_intersect
index|[
literal|0
index|]
operator|.
name|u
argument_list|,
name|face_intersect
index|[
literal|0
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* Check for total transparency... */
comment|/* =============================== */
if|if
condition|(
name|color
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
comment|/* Hey, we can see  through here!      */
comment|/* Lets see what's on the other side.. */
comment|/* =================================== */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|color2
operator|=
name|get_box_image_color
argument_list|(
name|face_intersect
index|[
literal|1
index|]
operator|.
name|face
argument_list|,
name|face_intersect
index|[
literal|1
index|]
operator|.
name|u
argument_list|,
name|face_intersect
index|[
literal|1
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* Make the normal point inwards */
comment|/* ============================= */
name|gimp_vector3_mul
argument_list|(
operator|&
name|face_intersect
index|[
literal|1
index|]
operator|.
name|n
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|color2
operator|=
name|phong_shade
argument_list|(
operator|&
name|face_intersect
index|[
literal|1
index|]
operator|.
name|s
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|face_intersect
index|[
literal|1
index|]
operator|.
name|n
argument_list|,
operator|&
name|color2
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|==
name|FALSE
operator|&&
name|color2
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
name|gimp_rgb_composite
argument_list|(
operator|&
name|color2
argument_list|,
operator|&
name|background
argument_list|,
name|GIMP_RGB_COMPOSITE_BEHIND
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a mix of the first and second colors */
comment|/* ============================================ */
name|gimp_rgb_composite
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|color2
argument_list|,
name|GIMP_RGB_COMPOSITE_NORMAL
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
operator|.
name|a
operator|!=
literal|0.0
operator|&&
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|!=
name|NO_LIGHT
condition|)
block|{
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|==
name|TRUE
condition|)
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
return|return
name|color
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|intersect_circle (GimpVector3 vp,GimpVector3 dir,gdouble w,FaceIntersectInfo * face_info)
name|intersect_circle
parameter_list|(
name|GimpVector3
name|vp
parameter_list|,
name|GimpVector3
name|dir
parameter_list|,
name|gdouble
name|w
parameter_list|,
name|FaceIntersectInfo
modifier|*
name|face_info
parameter_list|)
block|{
name|gboolean
name|result
init|=
name|FALSE
decl_stmt|;
name|gdouble
name|r
decl_stmt|,
name|d
decl_stmt|;
DECL|macro|sqr (a)
define|#
directive|define
name|sqr
parameter_list|(
name|a
parameter_list|)
value|(a*a)
if|if
condition|(
name|dir
operator|.
name|y
operator|!=
literal|0.0
condition|)
block|{
name|face_info
operator|->
name|t
operator|=
operator|(
name|w
operator|-
name|vp
operator|.
name|y
operator|)
operator|/
name|dir
operator|.
name|y
expr_stmt|;
name|face_info
operator|->
name|s
operator|.
name|x
operator|=
name|vp
operator|.
name|x
operator|+
name|face_info
operator|->
name|t
operator|*
name|dir
operator|.
name|x
expr_stmt|;
name|face_info
operator|->
name|s
operator|.
name|y
operator|=
name|w
expr_stmt|;
name|face_info
operator|->
name|s
operator|.
name|z
operator|=
name|vp
operator|.
name|z
operator|+
name|face_info
operator|->
name|t
operator|*
name|dir
operator|.
name|z
expr_stmt|;
name|r
operator|=
name|sqrt
argument_list|(
name|sqr
argument_list|(
name|face_info
operator|->
name|s
operator|.
name|x
argument_list|)
operator|+
name|sqr
argument_list|(
name|face_info
operator|->
name|s
operator|.
name|z
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
name|mapvals
operator|.
name|cylinder_radius
condition|)
block|{
name|d
operator|=
literal|2.0
operator|*
name|mapvals
operator|.
name|cylinder_radius
expr_stmt|;
name|face_info
operator|->
name|u
operator|=
operator|(
name|face_info
operator|->
name|s
operator|.
name|x
operator|+
name|mapvals
operator|.
name|cylinder_radius
operator|)
operator|/
name|d
expr_stmt|;
name|face_info
operator|->
name|v
operator|=
operator|(
name|face_info
operator|->
name|s
operator|.
name|z
operator|+
name|mapvals
operator|.
name|cylinder_radius
operator|)
operator|/
name|d
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|sqr
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|intersect_cylinder (GimpVector3 vp,GimpVector3 dir,FaceIntersectInfo * face_intersect)
name|intersect_cylinder
parameter_list|(
name|GimpVector3
name|vp
parameter_list|,
name|GimpVector3
name|dir
parameter_list|,
name|FaceIntersectInfo
modifier|*
name|face_intersect
parameter_list|)
block|{
name|gdouble
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|tmp
decl_stmt|,
name|l
decl_stmt|;
name|gboolean
name|result
init|=
name|FALSE
decl_stmt|;
name|gint
name|i
decl_stmt|;
DECL|macro|sqr (a)
define|#
directive|define
name|sqr
parameter_list|(
name|a
parameter_list|)
value|(a*a)
name|a
operator|=
name|sqr
argument_list|(
name|dir
operator|.
name|x
argument_list|)
operator|+
name|sqr
argument_list|(
name|dir
operator|.
name|z
argument_list|)
expr_stmt|;
name|b
operator|=
literal|2.0
operator|*
operator|(
name|vp
operator|.
name|x
operator|*
name|dir
operator|.
name|x
operator|+
name|vp
operator|.
name|z
operator|*
name|dir
operator|.
name|z
operator|)
expr_stmt|;
name|c
operator|=
name|sqr
argument_list|(
name|vp
operator|.
name|x
argument_list|)
operator|+
name|sqr
argument_list|(
name|vp
operator|.
name|z
argument_list|)
operator|-
name|sqr
argument_list|(
name|mapvals
operator|.
name|cylinder_radius
argument_list|)
expr_stmt|;
name|d
operator|=
name|sqr
argument_list|(
name|b
argument_list|)
operator|-
literal|4.0
operator|*
name|a
operator|*
name|c
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|0.0
condition|)
block|{
name|e
operator|=
name|sqrt
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|f
operator|=
literal|2.0
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|0.0
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
name|face_intersect
index|[
literal|0
index|]
operator|.
name|t
operator|=
operator|(
operator|-
name|b
operator|+
name|e
operator|)
operator|/
name|f
expr_stmt|;
name|face_intersect
index|[
literal|1
index|]
operator|.
name|t
operator|=
operator|(
operator|-
name|b
operator|-
name|e
operator|)
operator|/
name|f
expr_stmt|;
if|if
condition|(
name|face_intersect
index|[
literal|0
index|]
operator|.
name|t
operator|>
name|face_intersect
index|[
literal|1
index|]
operator|.
name|t
condition|)
block|{
name|tmp
operator|=
name|face_intersect
index|[
literal|0
index|]
operator|.
name|t
expr_stmt|;
name|face_intersect
index|[
literal|0
index|]
operator|.
name|t
operator|=
name|face_intersect
index|[
literal|1
index|]
operator|.
name|t
expr_stmt|;
name|face_intersect
index|[
literal|1
index|]
operator|.
name|t
operator|=
name|tmp
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|x
operator|=
name|vp
operator|.
name|x
operator|+
name|face_intersect
index|[
name|i
index|]
operator|.
name|t
operator|*
name|dir
operator|.
name|x
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|y
operator|=
name|vp
operator|.
name|y
operator|+
name|face_intersect
index|[
name|i
index|]
operator|.
name|t
operator|*
name|dir
operator|.
name|y
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|z
operator|=
name|vp
operator|.
name|z
operator|+
name|face_intersect
index|[
name|i
index|]
operator|.
name|t
operator|*
name|dir
operator|.
name|z
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
operator|=
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
operator|.
name|y
operator|=
literal|0.0
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
argument_list|)
expr_stmt|;
name|l
operator|=
name|mapvals
operator|.
name|cylinder_length
operator|/
literal|2.0
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|u
operator|=
operator|(
name|atan2
argument_list|(
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|x
argument_list|,
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|z
argument_list|)
operator|+
name|G_PI
operator|)
operator|/
operator|(
literal|2.0
operator|*
name|G_PI
operator|)
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|v
operator|=
operator|(
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|y
operator|+
name|l
operator|)
operator|/
name|mapvals
operator|.
name|cylinder_length
expr_stmt|;
comment|/* Mark hitpoint as on the cylinder hull */
comment|/* ===================================== */
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|0
expr_stmt|;
comment|/* Check if we're completely off the cylinder axis */
comment|/* =============================================== */
if|if
condition|(
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|y
operator|>
name|l
operator|||
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|y
operator|<
operator|-
name|l
condition|)
block|{
comment|/* Check if we've hit a cap */
comment|/* ======================== */
if|if
condition|(
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|.
name|y
operator|>
name|l
condition|)
block|{
if|if
condition|(
name|intersect_circle
argument_list|(
name|vp
argument_list|,
name|dir
argument_list|,
name|l
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|FALSE
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|2
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|v
operator|=
literal|1
operator|-
name|face_intersect
index|[
name|i
index|]
operator|.
name|v
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|intersect_circle
argument_list|(
name|vp
argument_list|,
name|dir
argument_list|,
operator|-
name|l
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
argument_list|)
operator|==
name|FALSE
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|face_intersect
index|[
name|i
index|]
operator|.
name|face
operator|=
literal|1
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
undef|#
directive|undef
name|sqr
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|GimpRGB
DECL|function|get_cylinder_color (gint face,gdouble u,gdouble v)
name|get_cylinder_color
parameter_list|(
name|gint
name|face
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|gint
name|inside
decl_stmt|;
if|if
condition|(
name|face
operator|==
literal|0
condition|)
name|color
operator|=
name|get_image_color
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
else|else
name|color
operator|=
name|get_cylinder_image_color
argument_list|(
name|face
operator|-
literal|1
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|color
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|get_ray_color_cylinder (GimpVector3 * pos)
name|get_ray_color_cylinder
parameter_list|(
name|GimpVector3
modifier|*
name|pos
parameter_list|)
block|{
name|GimpVector3
name|lvp
decl_stmt|,
name|ldir
decl_stmt|,
name|vp
decl_stmt|,
name|p
decl_stmt|,
name|dir
decl_stmt|,
name|ns
decl_stmt|,
name|nn
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|,
name|color2
decl_stmt|;
name|gfloat
name|m
index|[
literal|16
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|FaceIntersectInfo
name|face_intersect
index|[
literal|2
index|]
decl_stmt|;
name|color
operator|=
name|background
expr_stmt|;
name|vp
operator|=
name|mapvals
operator|.
name|viewpoint
expr_stmt|;
name|p
operator|=
operator|*
name|pos
expr_stmt|;
name|vp
operator|.
name|x
operator|=
name|vp
operator|.
name|x
operator|-
name|mapvals
operator|.
name|position
operator|.
name|x
expr_stmt|;
name|vp
operator|.
name|y
operator|=
name|vp
operator|.
name|y
operator|-
name|mapvals
operator|.
name|position
operator|.
name|y
expr_stmt|;
name|vp
operator|.
name|z
operator|=
name|vp
operator|.
name|z
operator|-
name|mapvals
operator|.
name|position
operator|.
name|z
expr_stmt|;
name|p
operator|.
name|x
operator|=
name|p
operator|.
name|x
operator|-
name|mapvals
operator|.
name|position
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|=
name|p
operator|.
name|y
operator|-
name|mapvals
operator|.
name|position
operator|.
name|y
expr_stmt|;
name|p
operator|.
name|z
operator|=
name|p
operator|.
name|z
operator|-
name|mapvals
operator|.
name|position
operator|.
name|z
expr_stmt|;
comment|/* Compute direction */
comment|/* ================= */
name|gimp_vector3_sub
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
comment|/* Compute inverse of rotation matrix and apply it to   */
comment|/* the viewpoint and direction. This transforms the     */
comment|/* observer into the local coordinate system of the box */
comment|/* ==================================================== */
name|memcpy
argument_list|(
name|m
argument_list|,
name|rotmat
argument_list|,
sizeof|sizeof
argument_list|(
name|gfloat
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
name|transpose_mat
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|lvp
argument_list|,
operator|&
name|vp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|ldir
argument_list|,
operator|&
name|dir
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersect_cylinder
argument_list|(
name|lvp
argument_list|,
name|ldir
argument_list|,
name|face_intersect
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|/* We've hit the cylinder. Transform the hit points and */
comment|/* normals back into the world coordinate system        */
comment|/* ==================================================== */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|vecmulmat
argument_list|(
operator|&
name|ns
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|rotmat
argument_list|)
expr_stmt|;
name|vecmulmat
argument_list|(
operator|&
name|nn
argument_list|,
operator|&
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
argument_list|,
name|rotmat
argument_list|)
expr_stmt|;
name|ns
operator|.
name|x
operator|=
name|ns
operator|.
name|x
operator|+
name|mapvals
operator|.
name|position
operator|.
name|x
expr_stmt|;
name|ns
operator|.
name|y
operator|=
name|ns
operator|.
name|y
operator|+
name|mapvals
operator|.
name|position
operator|.
name|y
expr_stmt|;
name|ns
operator|.
name|z
operator|=
name|ns
operator|.
name|z
operator|+
name|mapvals
operator|.
name|position
operator|.
name|z
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|s
operator|=
name|ns
expr_stmt|;
name|face_intersect
index|[
name|i
index|]
operator|.
name|n
operator|=
name|nn
expr_stmt|;
block|}
name|color
operator|=
name|get_cylinder_color
argument_list|(
name|face_intersect
index|[
literal|0
index|]
operator|.
name|face
argument_list|,
name|face_intersect
index|[
literal|0
index|]
operator|.
name|u
argument_list|,
name|face_intersect
index|[
literal|0
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* Check for transparency... */
comment|/* ========================= */
if|if
condition|(
name|color
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
comment|/* Hey, we can see  through here!      */
comment|/* Lets see what's on the other side.. */
comment|/* =================================== */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
name|color2
operator|=
name|get_cylinder_color
argument_list|(
name|face_intersect
index|[
literal|1
index|]
operator|.
name|face
argument_list|,
name|face_intersect
index|[
literal|1
index|]
operator|.
name|u
argument_list|,
name|face_intersect
index|[
literal|1
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* Make the normal point inwards */
comment|/* ============================= */
name|gimp_vector3_mul
argument_list|(
operator|&
name|face_intersect
index|[
literal|1
index|]
operator|.
name|n
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|color2
operator|=
name|phong_shade
argument_list|(
operator|&
name|face_intersect
index|[
literal|1
index|]
operator|.
name|s
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|face_intersect
index|[
literal|1
index|]
operator|.
name|n
argument_list|,
operator|&
name|color2
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|==
name|FALSE
operator|&&
name|color2
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
name|gimp_rgb_composite
argument_list|(
operator|&
name|color2
argument_list|,
operator|&
name|background
argument_list|,
name|GIMP_RGB_COMPOSITE_BEHIND
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a mix of the first and second colors */
comment|/* ============================================ */
name|gimp_rgb_composite
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|color2
argument_list|,
name|GIMP_RGB_COMPOSITE_NORMAL
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
operator|.
name|a
operator|!=
literal|0.0
operator|&&
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|!=
name|NO_LIGHT
condition|)
block|{
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|face_intersect
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|==
name|TRUE
condition|)
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
return|return
name|color
return|;
block|}
end_function

end_unit

