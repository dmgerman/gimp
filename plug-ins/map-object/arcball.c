begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************/
end_comment

begin_comment
comment|/* ArcBall.c (c) Ken Shoemake, 1993 */
end_comment

begin_comment
comment|/* Modified by Tom Bech, 1996       */
end_comment

begin_comment
comment|/************************************/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"arcball.h"
end_include

begin_comment
comment|/* Gloval variables */
end_comment

begin_comment
comment|/* ================ */
end_comment

begin_decl_stmt
DECL|variable|qOne
name|Quat
name|qOne
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|center
specifier|static
name|HVect
name|center
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|radius
specifier|static
name|double
name|radius
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|qNow
DECL|variable|qDown
DECL|variable|qDrag
specifier|static
name|Quat
name|qNow
decl_stmt|,
name|qDown
decl_stmt|,
name|qDrag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vNow
DECL|variable|vDown
DECL|variable|vFrom
DECL|variable|vTo
DECL|variable|vrFrom
DECL|variable|vrTo
specifier|static
name|HVect
name|vNow
decl_stmt|,
name|vDown
decl_stmt|,
name|vFrom
decl_stmt|,
name|vTo
decl_stmt|,
name|vrFrom
decl_stmt|,
name|vrTo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|mNow
DECL|variable|mDown
specifier|static
name|HMatrix
name|mNow
decl_stmt|,
name|mDown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|showResult
DECL|variable|dragging
specifier|static
name|unsigned
name|int
name|showResult
decl_stmt|,
name|dragging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sets
specifier|static
name|ConstraintSet
name|sets
index|[
name|NSets
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|setSizes
specifier|static
name|int
name|setSizes
index|[
name|NSets
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|axisSet
specifier|static
name|AxisSet
name|axisSet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|axisIndex
specifier|static
name|int
name|axisIndex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|mId
specifier|static
name|HMatrix
name|mId
init|=
block|{
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|otherAxis
specifier|static
name|double
name|otherAxis
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
operator|-
literal|0.48
block|,
literal|0.80
block|,
literal|0.36
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal methods */
end_comment

begin_comment
comment|/* ================ */
end_comment

begin_function_decl
specifier|static
name|void
name|Qt_ToMatrix
parameter_list|(
name|Quat
name|q
parameter_list|,
name|HMatrix
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Quat
name|Qt_Conj
parameter_list|(
name|Quat
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Quat
name|Qt_Mul
parameter_list|(
name|Quat
name|qL
parameter_list|,
name|Quat
name|qR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Quat
name|Qt_FromBallPoints
parameter_list|(
name|HVect
name|from
parameter_list|,
name|HVect
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Qt_ToBallPoints
parameter_list|(
name|Quat
name|q
parameter_list|,
name|HVect
modifier|*
name|arcFrom
parameter_list|,
name|HVect
modifier|*
name|arcTo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HVect
name|V3_
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|V3_Norm
parameter_list|(
name|HVect
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HVect
name|V3_Unit
parameter_list|(
name|HVect
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HVect
name|V3_Scale
parameter_list|(
name|HVect
name|v
parameter_list|,
name|double
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HVect
name|V3_Negate
parameter_list|(
name|HVect
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static HVect    V3_Add(HVect v1, HVect v2); */
end_comment

begin_function_decl
specifier|static
name|HVect
name|V3_Sub
parameter_list|(
name|HVect
name|v1
parameter_list|,
name|HVect
name|v2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|V3_Dot
parameter_list|(
name|HVect
name|v1
parameter_list|,
name|HVect
name|v2
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static HVect    V3_Cross(HVect v1, HVect v2); static HVect    V3_Bisect(HVect v0, HVect v1); */
end_comment

begin_function_decl
specifier|static
name|HVect
name|MouseOnSphere
parameter_list|(
name|HVect
name|mouse
parameter_list|,
name|HVect
name|ballCenter
parameter_list|,
name|double
name|ballRadius
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HVect
name|ConstrainToAxis
parameter_list|(
name|HVect
name|loose
parameter_list|,
name|HVect
name|axis
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|NearestConstraintAxis
parameter_list|(
name|HVect
name|loose
parameter_list|,
name|HVect
modifier|*
name|axes
parameter_list|,
name|int
name|nAxes
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Establish reasonable initial values for controller. */
end_comment

begin_comment
comment|/* =================================================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_Init (void)
name|ArcBall_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|center
operator|=
name|qOne
expr_stmt|;
name|radius
operator|=
literal|1.0
expr_stmt|;
name|vDown
operator|=
name|vNow
operator|=
name|qOne
expr_stmt|;
name|qDown
operator|=
name|qNow
operator|=
name|qOne
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|double
operator|*
operator|)
name|mNow
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|double
operator|*
operator|)
name|mDown
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|double
operator|*
operator|)
name|mId
operator|)
index|[
name|i
index|]
expr_stmt|;
name|showResult
operator|=
name|dragging
operator|=
name|FALSE
expr_stmt|;
name|axisSet
operator|=
name|NoAxes
expr_stmt|;
name|sets
index|[
name|CameraAxes
index|]
operator|=
name|mId
index|[
name|X
index|]
expr_stmt|;
name|setSizes
index|[
name|CameraAxes
index|]
operator|=
literal|3
expr_stmt|;
name|sets
index|[
name|BodyAxes
index|]
operator|=
name|mDown
index|[
name|X
index|]
expr_stmt|;
name|setSizes
index|[
name|BodyAxes
index|]
operator|=
literal|3
expr_stmt|;
name|sets
index|[
name|OtherAxes
index|]
operator|=
name|otherAxis
index|[
name|X
index|]
expr_stmt|;
name|setSizes
index|[
name|OtherAxes
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the center and size of the controller. */
end_comment

begin_comment
comment|/* ========================================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_Place (HVect Center,double Radius)
name|ArcBall_Place
parameter_list|(
name|HVect
name|Center
parameter_list|,
name|double
name|Radius
parameter_list|)
block|{
name|center
operator|=
name|Center
expr_stmt|;
name|radius
operator|=
name|Radius
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Incorporate new mouse position. */
end_comment

begin_comment
comment|/* =============================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_Mouse (HVect v_Now)
name|ArcBall_Mouse
parameter_list|(
name|HVect
name|v_Now
parameter_list|)
block|{
name|vNow
operator|=
name|v_Now
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Choose a constraint set, or none. */
end_comment

begin_comment
comment|/* ================================= */
end_comment

begin_function
name|void
DECL|function|ArcBall_UseSet (AxisSet axis_Set)
name|ArcBall_UseSet
parameter_list|(
name|AxisSet
name|axis_Set
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dragging
condition|)
name|axisSet
operator|=
name|axis_Set
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Using vDown, vNow, dragging, and axisSet, compute rotation etc. */
end_comment

begin_comment
comment|/* =============================================================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_Update (void)
name|ArcBall_Update
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|setSize
init|=
name|setSizes
index|[
name|axisSet
index|]
decl_stmt|;
name|HVect
modifier|*
name|set
init|=
operator|(
name|HVect
operator|*
operator|)
operator|(
name|sets
index|[
name|axisSet
index|]
operator|)
decl_stmt|;
name|vFrom
operator|=
name|MouseOnSphere
argument_list|(
name|vDown
argument_list|,
name|center
argument_list|,
name|radius
argument_list|)
expr_stmt|;
name|vTo
operator|=
name|MouseOnSphere
argument_list|(
name|vNow
argument_list|,
name|center
argument_list|,
name|radius
argument_list|)
expr_stmt|;
if|if
condition|(
name|dragging
condition|)
block|{
if|if
condition|(
name|axisSet
operator|!=
name|NoAxes
condition|)
block|{
name|vFrom
operator|=
name|ConstrainToAxis
argument_list|(
name|vFrom
argument_list|,
name|set
index|[
name|axisIndex
index|]
argument_list|)
expr_stmt|;
name|vTo
operator|=
name|ConstrainToAxis
argument_list|(
name|vTo
argument_list|,
name|set
index|[
name|axisIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|qDrag
operator|=
name|Qt_FromBallPoints
argument_list|(
name|vFrom
argument_list|,
name|vTo
argument_list|)
expr_stmt|;
name|qNow
operator|=
name|Qt_Mul
argument_list|(
name|qDrag
argument_list|,
name|qDown
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|axisSet
operator|!=
name|NoAxes
condition|)
name|axisIndex
operator|=
name|NearestConstraintAxis
argument_list|(
name|vTo
argument_list|,
name|set
argument_list|,
name|setSize
argument_list|)
expr_stmt|;
block|}
name|Qt_ToBallPoints
argument_list|(
name|qDown
argument_list|,
operator|&
name|vrFrom
argument_list|,
operator|&
name|vrTo
argument_list|)
expr_stmt|;
name|Qt_ToMatrix
argument_list|(
name|Qt_Conj
argument_list|(
name|qNow
argument_list|)
argument_list|,
name|mNow
argument_list|)
expr_stmt|;
comment|/* Gives transpose for GL. */
block|}
end_function

begin_comment
comment|/* Return rotation matrix defined by controller use. */
end_comment

begin_comment
comment|/* ================================================= */
end_comment

begin_function
name|void
DECL|function|ArcBall_Value (HMatrix m_Now)
name|ArcBall_Value
parameter_list|(
name|HMatrix
name|m_Now
parameter_list|)
block|{
name|ArcBall_CopyMat
argument_list|(
name|mNow
argument_list|,
name|m_Now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract rotation angles from matrix */
end_comment

begin_comment
comment|/* =================================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_Values (double * alpha,double * beta,double * gamma)
name|ArcBall_Values
parameter_list|(
name|double
modifier|*
name|alpha
parameter_list|,
name|double
modifier|*
name|beta
parameter_list|,
name|double
modifier|*
name|gamma
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|beta
operator|=
name|asin
argument_list|(
operator|-
name|mNow
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
operator|!=
literal|0.0
condition|)
block|{
operator|*
name|gamma
operator|=
name|atan2
argument_list|(
name|mNow
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|mNow
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|*
name|alpha
operator|=
name|atan2
argument_list|(
name|mNow
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|mNow
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|gamma
operator|=
name|atan2
argument_list|(
name|mNow
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|mNow
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|alpha
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin drag sequence. */
end_comment

begin_comment
comment|/* ==================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_BeginDrag (void)
name|ArcBall_BeginDrag
parameter_list|(
name|void
parameter_list|)
block|{
name|dragging
operator|=
name|TRUE
expr_stmt|;
name|vDown
operator|=
name|vNow
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop drag sequence. */
end_comment

begin_comment
comment|/* =================== */
end_comment

begin_function
name|void
DECL|function|ArcBall_EndDrag (void)
name|ArcBall_EndDrag
parameter_list|(
name|void
parameter_list|)
block|{
name|dragging
operator|=
name|FALSE
expr_stmt|;
name|qDown
operator|=
name|qNow
expr_stmt|;
name|ArcBall_CopyMat
argument_list|(
name|mNow
argument_list|,
name|mDown
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*===================*/
end_comment

begin_comment
comment|/***** BallAux.c *****/
end_comment

begin_comment
comment|/*===================*/
end_comment

begin_comment
comment|/* Return quaternion product qL * qR.  Note: order is important! */
end_comment

begin_comment
comment|/* To combine rotations, use the product Mul(qSecond, qFirst),   */
end_comment

begin_comment
comment|/* which gives the effect of rotating by qFirst then qSecond.    */
end_comment

begin_comment
comment|/* ============================================================= */
end_comment

begin_function
specifier|static
name|Quat
DECL|function|Qt_Mul (Quat qL,Quat qR)
name|Qt_Mul
parameter_list|(
name|Quat
name|qL
parameter_list|,
name|Quat
name|qR
parameter_list|)
block|{
name|Quat
name|qq
decl_stmt|;
name|qq
operator|.
name|w
operator|=
name|qL
operator|.
name|w
operator|*
name|qR
operator|.
name|w
operator|-
name|qL
operator|.
name|x
operator|*
name|qR
operator|.
name|x
operator|-
name|qL
operator|.
name|y
operator|*
name|qR
operator|.
name|y
operator|-
name|qL
operator|.
name|z
operator|*
name|qR
operator|.
name|z
expr_stmt|;
name|qq
operator|.
name|x
operator|=
name|qL
operator|.
name|w
operator|*
name|qR
operator|.
name|x
operator|+
name|qL
operator|.
name|x
operator|*
name|qR
operator|.
name|w
operator|+
name|qL
operator|.
name|y
operator|*
name|qR
operator|.
name|z
operator|-
name|qL
operator|.
name|z
operator|*
name|qR
operator|.
name|y
expr_stmt|;
name|qq
operator|.
name|y
operator|=
name|qL
operator|.
name|w
operator|*
name|qR
operator|.
name|y
operator|+
name|qL
operator|.
name|y
operator|*
name|qR
operator|.
name|w
operator|+
name|qL
operator|.
name|z
operator|*
name|qR
operator|.
name|x
operator|-
name|qL
operator|.
name|x
operator|*
name|qR
operator|.
name|z
expr_stmt|;
name|qq
operator|.
name|z
operator|=
name|qL
operator|.
name|w
operator|*
name|qR
operator|.
name|z
operator|+
name|qL
operator|.
name|z
operator|*
name|qR
operator|.
name|w
operator|+
name|qL
operator|.
name|x
operator|*
name|qR
operator|.
name|y
operator|-
name|qL
operator|.
name|y
operator|*
name|qR
operator|.
name|x
expr_stmt|;
return|return
operator|(
name|qq
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Construct rotation matrix from (possibly non-unit) quaternion. */
end_comment

begin_comment
comment|/* Assumes matrix is used to multiply column vector on the left:  */
end_comment

begin_comment
comment|/* vnew = mat vold.  Works correctly for right-handed coordinate  */
end_comment

begin_comment
comment|/* system and right-handed rotations.                             */
end_comment

begin_comment
comment|/* ============================================================== */
end_comment

begin_function
specifier|static
name|void
DECL|function|Qt_ToMatrix (Quat q,HMatrix out)
name|Qt_ToMatrix
parameter_list|(
name|Quat
name|q
parameter_list|,
name|HMatrix
name|out
parameter_list|)
block|{
name|double
name|Nq
init|=
name|q
operator|.
name|x
operator|*
name|q
operator|.
name|x
operator|+
name|q
operator|.
name|y
operator|*
name|q
operator|.
name|y
operator|+
name|q
operator|.
name|z
operator|*
name|q
operator|.
name|z
operator|+
name|q
operator|.
name|w
operator|*
name|q
operator|.
name|w
decl_stmt|;
name|double
name|s
init|=
operator|(
name|Nq
operator|>
literal|0.0
operator|)
condition|?
operator|(
literal|2.0
operator|/
name|Nq
operator|)
else|:
literal|0.0
decl_stmt|;
name|double
name|xs
init|=
name|q
operator|.
name|x
operator|*
name|s
decl_stmt|,
name|ys
init|=
name|q
operator|.
name|y
operator|*
name|s
decl_stmt|,
name|zs
init|=
name|q
operator|.
name|z
operator|*
name|s
decl_stmt|;
name|double
name|wx
init|=
name|q
operator|.
name|w
operator|*
name|xs
decl_stmt|,
name|wy
init|=
name|q
operator|.
name|w
operator|*
name|ys
decl_stmt|,
name|wz
init|=
name|q
operator|.
name|w
operator|*
name|zs
decl_stmt|;
name|double
name|xx
init|=
name|q
operator|.
name|x
operator|*
name|xs
decl_stmt|,
name|xy
init|=
name|q
operator|.
name|x
operator|*
name|ys
decl_stmt|,
name|xz
init|=
name|q
operator|.
name|x
operator|*
name|zs
decl_stmt|;
name|double
name|yy
init|=
name|q
operator|.
name|y
operator|*
name|ys
decl_stmt|,
name|yz
init|=
name|q
operator|.
name|y
operator|*
name|zs
decl_stmt|,
name|zz
init|=
name|q
operator|.
name|z
operator|*
name|zs
decl_stmt|;
name|out
index|[
name|X
index|]
index|[
name|X
index|]
operator|=
literal|1.0
operator|-
operator|(
name|yy
operator|+
name|zz
operator|)
expr_stmt|;
name|out
index|[
name|Y
index|]
index|[
name|X
index|]
operator|=
name|xy
operator|+
name|wz
expr_stmt|;
name|out
index|[
name|Z
index|]
index|[
name|X
index|]
operator|=
name|xz
operator|-
name|wy
expr_stmt|;
name|out
index|[
name|X
index|]
index|[
name|Y
index|]
operator|=
name|xy
operator|-
name|wz
expr_stmt|;
name|out
index|[
name|Y
index|]
index|[
name|Y
index|]
operator|=
literal|1.0
operator|-
operator|(
name|xx
operator|+
name|zz
operator|)
expr_stmt|;
name|out
index|[
name|Z
index|]
index|[
name|Y
index|]
operator|=
name|yz
operator|+
name|wx
expr_stmt|;
name|out
index|[
name|X
index|]
index|[
name|Z
index|]
operator|=
name|xz
operator|+
name|wy
expr_stmt|;
name|out
index|[
name|Y
index|]
index|[
name|Z
index|]
operator|=
name|yz
operator|-
name|wx
expr_stmt|;
name|out
index|[
name|Z
index|]
index|[
name|Z
index|]
operator|=
literal|1.0
operator|-
operator|(
name|xx
operator|+
name|yy
operator|)
expr_stmt|;
name|out
index|[
name|X
index|]
index|[
name|W
index|]
operator|=
name|out
index|[
name|Y
index|]
index|[
name|W
index|]
operator|=
name|out
index|[
name|Z
index|]
index|[
name|W
index|]
operator|=
name|out
index|[
name|W
index|]
index|[
name|X
index|]
operator|=
name|out
index|[
name|W
index|]
index|[
name|Y
index|]
operator|=
name|out
index|[
name|W
index|]
index|[
name|Z
index|]
operator|=
literal|0.0
expr_stmt|;
name|out
index|[
name|W
index|]
index|[
name|W
index|]
operator|=
literal|1.0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return conjugate of quaternion. */
end_comment

begin_comment
comment|/* =============================== */
end_comment

begin_function
specifier|static
name|Quat
DECL|function|Qt_Conj (Quat q)
name|Qt_Conj
parameter_list|(
name|Quat
name|q
parameter_list|)
block|{
name|Quat
name|qq
decl_stmt|;
name|qq
operator|.
name|x
operator|=
operator|-
name|q
operator|.
name|x
expr_stmt|;
name|qq
operator|.
name|y
operator|=
operator|-
name|q
operator|.
name|y
expr_stmt|;
name|qq
operator|.
name|z
operator|=
operator|-
name|q
operator|.
name|z
expr_stmt|;
name|qq
operator|.
name|w
operator|=
name|q
operator|.
name|w
expr_stmt|;
return|return
operator|(
name|qq
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return vector formed from components */
end_comment

begin_comment
comment|/* ==================================== */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|V3_ (double x,double y,double z)
name|V3_
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|z
parameter_list|)
block|{
name|HVect
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|v
operator|.
name|z
operator|=
name|z
expr_stmt|;
name|v
operator|.
name|w
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return norm of v, defined as sum of squares of components */
end_comment

begin_comment
comment|/* ========================================================= */
end_comment

begin_function
specifier|static
name|double
DECL|function|V3_Norm (HVect v)
name|V3_Norm
parameter_list|(
name|HVect
name|v
parameter_list|)
block|{
return|return
operator|(
name|v
operator|.
name|x
operator|*
name|v
operator|.
name|x
operator|+
name|v
operator|.
name|y
operator|*
name|v
operator|.
name|y
operator|+
name|v
operator|.
name|z
operator|*
name|v
operator|.
name|z
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return unit magnitude vector in direction of v */
end_comment

begin_comment
comment|/* ============================================== */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|V3_Unit (HVect v)
name|V3_Unit
parameter_list|(
name|HVect
name|v
parameter_list|)
block|{
specifier|static
name|HVect
name|u
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|double
name|vlen
init|=
name|sqrt
argument_list|(
name|V3_Norm
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|vlen
operator|!=
literal|0.0
condition|)
name|u
operator|.
name|x
operator|=
name|v
operator|.
name|x
operator|/
name|vlen
expr_stmt|;
name|u
operator|.
name|y
operator|=
name|v
operator|.
name|y
operator|/
name|vlen
expr_stmt|;
name|u
operator|.
name|z
operator|=
name|v
operator|.
name|z
operator|/
name|vlen
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return version of v scaled by s */
end_comment

begin_comment
comment|/* =============================== */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|V3_Scale (HVect v,double s)
name|V3_Scale
parameter_list|(
name|HVect
name|v
parameter_list|,
name|double
name|s
parameter_list|)
block|{
name|HVect
name|u
decl_stmt|;
name|u
operator|.
name|x
operator|=
name|s
operator|*
name|v
operator|.
name|x
expr_stmt|;
name|u
operator|.
name|y
operator|=
name|s
operator|*
name|v
operator|.
name|y
expr_stmt|;
name|u
operator|.
name|z
operator|=
name|s
operator|*
name|v
operator|.
name|z
expr_stmt|;
name|u
operator|.
name|w
operator|=
name|v
operator|.
name|w
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return negative of v */
end_comment

begin_comment
comment|/* ==================== */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|V3_Negate (HVect v)
name|V3_Negate
parameter_list|(
name|HVect
name|v
parameter_list|)
block|{
specifier|static
name|HVect
name|u
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u
operator|.
name|x
operator|=
operator|-
name|v
operator|.
name|x
expr_stmt|;
name|u
operator|.
name|y
operator|=
operator|-
name|v
operator|.
name|y
expr_stmt|;
name|u
operator|.
name|z
operator|=
operator|-
name|v
operator|.
name|z
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return sum of v1 and v2 */
end_comment

begin_comment
comment|/* ======================= */
end_comment

begin_comment
comment|/* static HVect V3_Add (HVect v1,         HVect v2) {   static HVect v = {0, 0, 0, 0};   v.x = v1.x+v2.x; v.y = v1.y+v2.y; v.z = v1.z+v2.z;   return (v); } */
end_comment

begin_comment
comment|/* Return difference of v1 minus v2 */
end_comment

begin_comment
comment|/* ================================ */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|V3_Sub (HVect v1,HVect v2)
name|V3_Sub
parameter_list|(
name|HVect
name|v1
parameter_list|,
name|HVect
name|v2
parameter_list|)
block|{
specifier|static
name|HVect
name|v
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|v1
operator|.
name|x
operator|-
name|v2
operator|.
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|v1
operator|.
name|y
operator|-
name|v2
operator|.
name|y
expr_stmt|;
name|v
operator|.
name|z
operator|=
name|v1
operator|.
name|z
operator|-
name|v2
operator|.
name|z
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Halve arc between unit vectors v0 and v1. */
end_comment

begin_comment
comment|/* ========================================= */
end_comment

begin_comment
comment|/* static HVect V3_Bisect (HVect v0,            HVect v1) {   HVect v = {0, 0, 0, 0};   double Nv;    v = V3_Add(v0, v1);   Nv = V3_Norm(v);   if (Nv< 1.0e-5) v = V3_(0, 0, 1);   else v = V3_Scale(v, 1/sqrt(Nv));   return (v); } */
end_comment

begin_comment
comment|/* Return dot product of v1 and v2 */
end_comment

begin_comment
comment|/* =============================== */
end_comment

begin_function
specifier|static
name|double
DECL|function|V3_Dot (HVect v1,HVect v2)
name|V3_Dot
parameter_list|(
name|HVect
name|v1
parameter_list|,
name|HVect
name|v2
parameter_list|)
block|{
return|return
operator|(
name|v1
operator|.
name|x
operator|*
name|v2
operator|.
name|x
operator|+
name|v1
operator|.
name|y
operator|*
name|v2
operator|.
name|y
operator|+
name|v1
operator|.
name|z
operator|*
name|v2
operator|.
name|z
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return cross product, v1 x v2 */
end_comment

begin_comment
comment|/* ============================= */
end_comment

begin_comment
comment|/* static HVect V3_Cross (HVect v1,           HVect v2) {   static HVect v = {0, 0, 0, 0};   v.x = v1.y*v2.z-v1.z*v2.y;   v.y = v1.z*v2.x-v1.x*v2.z;   v.z = v1.x*v2.y-v1.y*v2.x;   return (v); } */
end_comment

begin_function
name|void
DECL|function|ArcBall_CopyMat (HMatrix inm,HMatrix outm)
name|ArcBall_CopyMat
parameter_list|(
name|HMatrix
name|inm
parameter_list|,
name|HMatrix
name|outm
parameter_list|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|4
condition|;
name|y
operator|++
control|)
block|{
name|outm
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|inm
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*=====================================================*/
end_comment

begin_comment
comment|/**** BallMath.c - Essential routines for ArcBall.  ****/
end_comment

begin_comment
comment|/*=====================================================*/
end_comment

begin_comment
comment|/* Convert window coordinates to sphere coordinates. */
end_comment

begin_comment
comment|/* ================================================= */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|MouseOnSphere (HVect mouse,HVect ballCenter,double ballRadius)
name|MouseOnSphere
parameter_list|(
name|HVect
name|mouse
parameter_list|,
name|HVect
name|ballCenter
parameter_list|,
name|double
name|ballRadius
parameter_list|)
block|{
name|HVect
name|ballMouse
decl_stmt|;
specifier|register
name|double
name|mag
decl_stmt|;
name|ballMouse
operator|.
name|x
operator|=
operator|(
name|mouse
operator|.
name|x
operator|-
name|ballCenter
operator|.
name|x
operator|)
operator|/
name|ballRadius
expr_stmt|;
name|ballMouse
operator|.
name|y
operator|=
operator|(
name|mouse
operator|.
name|y
operator|-
name|ballCenter
operator|.
name|y
operator|)
operator|/
name|ballRadius
expr_stmt|;
name|mag
operator|=
name|ballMouse
operator|.
name|x
operator|*
name|ballMouse
operator|.
name|x
operator|+
name|ballMouse
operator|.
name|y
operator|*
name|ballMouse
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|mag
operator|>
literal|1.0
condition|)
block|{
specifier|register
name|double
name|scale
init|=
literal|1.0
operator|/
name|sqrt
argument_list|(
name|mag
argument_list|)
decl_stmt|;
name|ballMouse
operator|.
name|x
operator|*=
name|scale
expr_stmt|;
name|ballMouse
operator|.
name|y
operator|*=
name|scale
expr_stmt|;
name|ballMouse
operator|.
name|z
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
name|ballMouse
operator|.
name|z
operator|=
name|sqrt
argument_list|(
literal|1
operator|-
name|mag
argument_list|)
expr_stmt|;
name|ballMouse
operator|.
name|w
operator|=
literal|0.0
expr_stmt|;
return|return
operator|(
name|ballMouse
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Construct a unit quaternion from two points on unit sphere */
end_comment

begin_comment
comment|/* ========================================================== */
end_comment

begin_function
specifier|static
name|Quat
DECL|function|Qt_FromBallPoints (HVect from,HVect to)
name|Qt_FromBallPoints
parameter_list|(
name|HVect
name|from
parameter_list|,
name|HVect
name|to
parameter_list|)
block|{
name|Quat
name|qu
decl_stmt|;
name|qu
operator|.
name|x
operator|=
name|from
operator|.
name|y
operator|*
name|to
operator|.
name|z
operator|-
name|from
operator|.
name|z
operator|*
name|to
operator|.
name|y
expr_stmt|;
name|qu
operator|.
name|y
operator|=
name|from
operator|.
name|z
operator|*
name|to
operator|.
name|x
operator|-
name|from
operator|.
name|x
operator|*
name|to
operator|.
name|z
expr_stmt|;
name|qu
operator|.
name|z
operator|=
name|from
operator|.
name|x
operator|*
name|to
operator|.
name|y
operator|-
name|from
operator|.
name|y
operator|*
name|to
operator|.
name|x
expr_stmt|;
name|qu
operator|.
name|w
operator|=
name|from
operator|.
name|x
operator|*
name|to
operator|.
name|x
operator|+
name|from
operator|.
name|y
operator|*
name|to
operator|.
name|y
operator|+
name|from
operator|.
name|z
operator|*
name|to
operator|.
name|z
expr_stmt|;
return|return
operator|(
name|qu
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a unit quaternion to two points on unit sphere */
end_comment

begin_comment
comment|/* ====================================================== */
end_comment

begin_function
specifier|static
name|void
DECL|function|Qt_ToBallPoints (Quat q,HVect * arcFrom,HVect * arcTo)
name|Qt_ToBallPoints
parameter_list|(
name|Quat
name|q
parameter_list|,
name|HVect
modifier|*
name|arcFrom
parameter_list|,
name|HVect
modifier|*
name|arcTo
parameter_list|)
block|{
name|double
name|s
decl_stmt|;
name|s
operator|=
name|sqrt
argument_list|(
name|q
operator|.
name|x
operator|*
name|q
operator|.
name|x
operator|+
name|q
operator|.
name|y
operator|*
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0.0
condition|)
operator|*
name|arcFrom
operator|=
name|V3_
argument_list|(
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
else|else
operator|*
name|arcFrom
operator|=
name|V3_
argument_list|(
operator|-
name|q
operator|.
name|y
operator|/
name|s
argument_list|,
name|q
operator|.
name|x
operator|/
name|s
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|arcTo
operator|->
name|x
operator|=
name|q
operator|.
name|w
operator|*
name|arcFrom
operator|->
name|x
operator|-
name|q
operator|.
name|z
operator|*
name|arcFrom
operator|->
name|y
expr_stmt|;
name|arcTo
operator|->
name|y
operator|=
name|q
operator|.
name|w
operator|*
name|arcFrom
operator|->
name|y
operator|+
name|q
operator|.
name|z
operator|*
name|arcFrom
operator|->
name|x
expr_stmt|;
name|arcTo
operator|->
name|z
operator|=
name|q
operator|.
name|x
operator|*
name|arcFrom
operator|->
name|y
operator|-
name|q
operator|.
name|y
operator|*
name|arcFrom
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|w
operator|<
literal|0.0
condition|)
operator|*
name|arcFrom
operator|=
name|V3_
argument_list|(
operator|-
name|arcFrom
operator|->
name|x
argument_list|,
operator|-
name|arcFrom
operator|->
name|y
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force sphere point to be perpendicular to axis. */
end_comment

begin_comment
comment|/* =============================================== */
end_comment

begin_function
specifier|static
name|HVect
DECL|function|ConstrainToAxis (HVect loose,HVect axis)
name|ConstrainToAxis
parameter_list|(
name|HVect
name|loose
parameter_list|,
name|HVect
name|axis
parameter_list|)
block|{
name|HVect
name|onPlane
decl_stmt|;
specifier|register
name|double
name|norm
decl_stmt|;
name|onPlane
operator|=
name|V3_Sub
argument_list|(
name|loose
argument_list|,
name|V3_Scale
argument_list|(
name|axis
argument_list|,
name|V3_Dot
argument_list|(
name|axis
argument_list|,
name|loose
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|norm
operator|=
name|V3_Norm
argument_list|(
name|onPlane
argument_list|)
expr_stmt|;
if|if
condition|(
name|norm
operator|>
literal|0.0
condition|)
block|{
if|if
condition|(
name|onPlane
operator|.
name|z
operator|<
literal|0.0
condition|)
name|onPlane
operator|=
name|V3_Negate
argument_list|(
name|onPlane
argument_list|)
expr_stmt|;
return|return
operator|(
name|V3_Scale
argument_list|(
name|onPlane
argument_list|,
literal|1
operator|/
name|sqrt
argument_list|(
name|norm
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/* else drop through */
comment|/* ================= */
if|if
condition|(
name|axis
operator|.
name|z
operator|==
literal|1
condition|)
name|onPlane
operator|=
name|V3_
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
else|else
name|onPlane
operator|=
name|V3_Unit
argument_list|(
name|V3_
argument_list|(
operator|-
name|axis
operator|.
name|y
argument_list|,
name|axis
operator|.
name|x
argument_list|,
literal|0.0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|onPlane
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the index of nearest arc of axis set. */
end_comment

begin_comment
comment|/* ========================================== */
end_comment

begin_function
specifier|static
name|int
DECL|function|NearestConstraintAxis (HVect loose,HVect * axes,int nAxes)
name|NearestConstraintAxis
parameter_list|(
name|HVect
name|loose
parameter_list|,
name|HVect
modifier|*
name|axes
parameter_list|,
name|int
name|nAxes
parameter_list|)
block|{
name|HVect
name|onPlane
decl_stmt|;
specifier|register
name|double
name|max
decl_stmt|,
name|dot
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nearest
decl_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
name|nearest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAxes
condition|;
name|i
operator|++
control|)
block|{
name|onPlane
operator|=
name|ConstrainToAxis
argument_list|(
name|loose
argument_list|,
name|axes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dot
operator|=
name|V3_Dot
argument_list|(
name|onPlane
argument_list|,
name|loose
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|dot
expr_stmt|;
name|nearest
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nearest
operator|)
return|;
block|}
end_function

end_unit

