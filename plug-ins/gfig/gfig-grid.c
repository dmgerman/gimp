begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This is a plug-in for the GIMP.  *  * Generates images containing vector type drawings.  *  * Copyright (C) 1997 Andy Thomas  alt@picnic.demon.co.uk  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"gfig.h"
end_include

begin_include
include|#
directive|include
file|"gfig-grid.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/* For the isometric grid */
end_comment

begin_define
DECL|macro|SQRT3
define|#
directive|define
name|SQRT3
value|1.73205080756887729353
end_define

begin_comment
DECL|macro|SQRT3
comment|/* Square root of 3 */
end_comment

begin_define
DECL|macro|SIN_1o6PI_RAD
define|#
directive|define
name|SIN_1o6PI_RAD
value|0.5
end_define

begin_comment
DECL|macro|SIN_1o6PI_RAD
comment|/* Sine    1/6 Pi Radians */
end_comment

begin_define
DECL|macro|COS_1o6PI_RAD
define|#
directive|define
name|COS_1o6PI_RAD
value|SQRT3 / 2
end_define

begin_comment
DECL|macro|COS_1o6PI_RAD
comment|/* Cosine  1/6 Pi Radians */
end_comment

begin_define
DECL|macro|TAN_1o6PI_RAD
define|#
directive|define
name|TAN_1o6PI_RAD
value|1 / SQRT3
end_define

begin_comment
DECL|macro|TAN_1o6PI_RAD
comment|/* Tangent 1/6 Pi Radians == SIN / COS */
end_comment

begin_define
DECL|macro|RECIP_TAN_1o6PI_RAD
define|#
directive|define
name|RECIP_TAN_1o6PI_RAD
value|SQRT3
end_define

begin_comment
DECL|macro|RECIP_TAN_1o6PI_RAD
comment|/* Reciprocal of Tangent 1/6 Pi Radians */
end_comment

begin_decl_stmt
DECL|variable|grid_hightlight_drawgc
specifier|static
name|GdkGC
modifier|*
name|grid_hightlight_drawgc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|grid_gc_type
name|gint
name|grid_gc_type
init|=
name|GTK_STATE_NORMAL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|GdkGC
modifier|*
name|gfig_get_grid_gc
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gint
name|gctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|get_num_radials
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* find_grid_pos - Given an x, y point return the grid position of it */
end_comment

begin_comment
comment|/* return the new position in the passed point */
end_comment

begin_function
name|void
DECL|function|gfig_grid_colours (GtkWidget * widget)
name|gfig_grid_colours
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|)
block|{
name|GdkColormap
modifier|*
name|colormap
decl_stmt|;
name|GdkGCValues
name|values
decl_stmt|;
name|GdkColor
name|col1
decl_stmt|;
name|GdkColor
name|col2
decl_stmt|;
name|guchar
name|stipple
index|[
literal|8
index|]
init|=
block|{
literal|0xAA
block|,
comment|/*  ####----  */
literal|0x55
block|,
comment|/*  ###----#  */
literal|0xAA
block|,
comment|/*  ##----##  */
literal|0x55
block|,
comment|/*  #----###  */
literal|0xAA
block|,
comment|/*  ----####  */
literal|0x55
block|,
comment|/*  ---####-  */
literal|0xAA
block|,
comment|/*  --####--  */
literal|0x55
block|,
comment|/*  -####---  */
block|}
decl_stmt|;
name|colormap
operator|=
name|gdk_screen_get_rgb_colormap
argument_list|(
name|gtk_widget_get_screen
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|gdk_color_parse
argument_list|(
literal|"gray50"
argument_list|,
operator|&
name|col1
argument_list|)
expr_stmt|;
name|gdk_colormap_alloc_color
argument_list|(
name|colormap
argument_list|,
operator|&
name|col1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gdk_color_parse
argument_list|(
literal|"gray80"
argument_list|,
operator|&
name|col2
argument_list|)
expr_stmt|;
name|gdk_colormap_alloc_color
argument_list|(
name|colormap
argument_list|,
operator|&
name|col2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|values
operator|.
name|background
operator|.
name|pixel
operator|=
name|col1
operator|.
name|pixel
expr_stmt|;
name|values
operator|.
name|foreground
operator|.
name|pixel
operator|=
name|col2
operator|.
name|pixel
expr_stmt|;
name|values
operator|.
name|fill
operator|=
name|GDK_OPAQUE_STIPPLED
expr_stmt|;
name|values
operator|.
name|stipple
operator|=
name|gdk_bitmap_create_from_data
argument_list|(
name|widget
operator|->
name|window
argument_list|,
operator|(
name|gchar
operator|*
operator|)
name|stipple
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|grid_hightlight_drawgc
operator|=
name|gdk_gc_new_with_values
argument_list|(
name|widget
operator|->
name|window
argument_list|,
operator|&
name|values
argument_list|,
name|GDK_GC_FOREGROUND
operator||
name|GDK_GC_BACKGROUND
operator||
name|GDK_GC_FILL
operator||
name|GDK_GC_STIPPLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|find_grid_pos (GdkPoint * p,GdkPoint * gp,guint is_butt3)
name|find_grid_pos
parameter_list|(
name|GdkPoint
modifier|*
name|p
parameter_list|,
name|GdkPoint
modifier|*
name|gp
parameter_list|,
name|guint
name|is_butt3
parameter_list|)
block|{
name|gint16
name|x
init|=
name|p
operator|->
name|x
decl_stmt|;
name|gint16
name|y
init|=
name|p
operator|->
name|y
decl_stmt|;
specifier|static
name|GdkPoint
name|cons_pnt
decl_stmt|;
specifier|static
name|gdouble
name|cons_radius
decl_stmt|;
specifier|static
name|gdouble
name|cons_ang
decl_stmt|;
specifier|static
name|gboolean
name|cons_center
decl_stmt|;
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|gridtype
operator|==
name|RECT_GRID
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|x
operator|%
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|>
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|/
literal|2
condition|)
name|x
operator|+=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|y
operator|%
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|>
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|/
literal|2
condition|)
name|y
operator|+=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
name|gp
operator|->
name|x
operator|=
operator|(
name|x
operator|/
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|)
operator|*
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
name|gp
operator|->
name|y
operator|=
operator|(
name|y
operator|/
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|)
operator|*
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
if|if
condition|(
name|is_butt3
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|gp
operator|->
name|x
operator|-
name|cons_pnt
operator|.
name|x
argument_list|)
operator|<
name|abs
argument_list|(
name|gp
operator|->
name|y
operator|-
name|cons_pnt
operator|.
name|y
argument_list|)
condition|)
name|gp
operator|->
name|x
operator|=
name|cons_pnt
operator|.
name|x
expr_stmt|;
else|else
name|gp
operator|->
name|y
operator|=
name|cons_pnt
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* Store the point since might be used later */
name|cons_pnt
operator|=
operator|*
name|gp
expr_stmt|;
comment|/* Structure copy */
block|}
block|}
elseif|else
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|gridtype
operator|==
name|POLAR_GRID
condition|)
block|{
name|gdouble
name|ang_grid
decl_stmt|;
name|gdouble
name|ang_radius
decl_stmt|;
name|gdouble
name|real_radius
decl_stmt|;
name|gdouble
name|real_angle
decl_stmt|;
name|gdouble
name|rounded_angle
decl_stmt|;
name|gint
name|rounded_radius
decl_stmt|;
name|gint16
name|shift_x
init|=
name|x
operator|-
name|preview_width
operator|/
literal|2
decl_stmt|;
name|gint16
name|shift_y
init|=
operator|-
name|y
operator|+
name|preview_height
operator|/
literal|2
decl_stmt|;
name|real_radius
operator|=
name|ang_radius
operator|=
name|sqrt
argument_list|(
operator|(
name|shift_y
operator|*
name|shift_y
operator|)
operator|+
operator|(
name|shift_x
operator|*
name|shift_x
operator|)
argument_list|)
expr_stmt|;
comment|/* round radius */
name|rounded_radius
operator|=
call|(
name|gint
call|)
argument_list|(
name|RINT
argument_list|(
name|ang_radius
operator|/
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
argument_list|)
argument_list|)
operator|*
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
if|if
condition|(
name|rounded_radius
operator|<=
literal|0
operator|||
name|real_radius
operator|<=
literal|0
condition|)
block|{
comment|/* DEAD CENTER */
name|gp
operator|->
name|x
operator|=
name|preview_width
operator|/
literal|2
expr_stmt|;
name|gp
operator|->
name|y
operator|=
name|preview_height
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|is_butt3
condition|)
name|cons_center
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Dead center\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
name|ang_grid
operator|=
literal|2
operator|*
name|G_PI
operator|/
name|get_num_radials
argument_list|()
expr_stmt|;
name|real_angle
operator|=
name|atan2
argument_list|(
name|shift_y
argument_list|,
name|shift_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_angle
operator|<
literal|0
condition|)
name|real_angle
operator|+=
literal|2
operator|*
name|G_PI
expr_stmt|;
name|rounded_angle
operator|=
operator|(
name|RINT
argument_list|(
operator|(
name|real_angle
operator|/
name|ang_grid
operator|)
argument_list|)
operator|)
operator|*
name|ang_grid
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"real_ang = %f ang_gid = %f rounded_angle = %f rounded radius = %d\n"
argument_list|,
name|real_angle
argument_list|,
name|ang_grid
argument_list|,
name|rounded_angle
argument_list|,
name|rounded_radius
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"preview_width = %d preview_height = %d\n"
argument_list|,
name|preview_width
argument_list|,
name|preview_height
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|gp
operator|->
name|x
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
operator|(
name|rounded_radius
operator|*
name|cos
argument_list|(
name|rounded_angle
argument_list|)
operator|)
argument_list|)
operator|+
name|preview_width
operator|/
literal|2
expr_stmt|;
name|gp
operator|->
name|y
operator|=
operator|-
operator|(
name|gint
operator|)
name|RINT
argument_list|(
operator|(
name|rounded_radius
operator|*
name|sin
argument_list|(
name|rounded_angle
argument_list|)
operator|)
argument_list|)
operator|+
name|preview_height
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|is_butt3
condition|)
block|{
if|if
condition|(
operator|!
name|cons_center
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|rounded_angle
operator|-
name|cons_ang
argument_list|)
operator|>
name|ang_grid
operator|/
literal|2
condition|)
block|{
name|gp
operator|->
name|x
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
operator|(
name|cons_radius
operator|*
name|cos
argument_list|(
name|rounded_angle
argument_list|)
operator|)
argument_list|)
operator|+
name|preview_width
operator|/
literal|2
expr_stmt|;
name|gp
operator|->
name|y
operator|=
operator|-
operator|(
name|gint
operator|)
name|RINT
argument_list|(
operator|(
name|cons_radius
operator|*
name|sin
argument_list|(
name|rounded_angle
argument_list|)
operator|)
argument_list|)
operator|+
name|preview_height
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|gp
operator|->
name|x
operator|=
operator|(
name|gint
operator|)
name|RINT
argument_list|(
operator|(
name|rounded_radius
operator|*
name|cos
argument_list|(
name|cons_ang
argument_list|)
operator|)
argument_list|)
operator|+
name|preview_width
operator|/
literal|2
expr_stmt|;
name|gp
operator|->
name|y
operator|=
operator|-
operator|(
name|gint
operator|)
name|RINT
argument_list|(
operator|(
name|rounded_radius
operator|*
name|sin
argument_list|(
name|cons_ang
argument_list|)
operator|)
argument_list|)
operator|+
name|preview_height
operator|/
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cons_radius
operator|=
name|rounded_radius
expr_stmt|;
name|cons_ang
operator|=
name|rounded_angle
expr_stmt|;
name|cons_center
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|gridtype
operator|==
name|ISO_GRID
condition|)
block|{
comment|/*        * This really needs a picture to show the math...        *        * Consider an isometric grid with one of the sets of lines parallel to the         * y axis (vertical alignment). Further define that the origin of a Cartesian         * grid is at a isometric vertex.  For simplicity consider the first quadrant only.        *         *  - Let one line segment between vertices be r        *  - Define the value of r as the grid spacing        *  - Assign an integer n identifier to each vertical grid line along the x axis.        *    with n=0 being the y axis. n can be any integer        *  - Let m to be any integer        *  - Let h be the spacing between vertical grid lines measured along the x axis.        *    It follows from the isometric grid that h has a value of r * COS(1/6 Pi Rad)        *         *  Consider a Vertex V at the Cartesian location [Xv, Yv]        *        *   It follows that vertices belong to the set...        *   V[Xv, Yv] = [ [ n * h ] ,        *                 [ m * r + ( 0.5 * r (n % 2) ) ] ]        *   for all integers n and m        *        * Who cares? Me. It's useful in solving this problem:        * Consider an arbitrary point P[Xp,Yp], find the closest vertex in the set V.        *        * Restated this problem is "find values for m and n that are drive V closest to P"        *         * A Solution method (there may be a better one?):        *         * Step 1) bound n to the two closest values for Xp        *         n_lo = (int) (Xp / h)         *         n_hi = n_lo + 1        *         * Step 2) Consider the two closes vertices for each n_lo and n_hi. The further of        *         the vertices in each pair can readily be discarded.        *         m_lo_n_lo = (int) ( (Yp / r) - 0.5 (n_lo % 2) )        *         m_hi_n_lo = m_lo_n_lo + 1        *        *         m_lo_n_hi = (int) ( (Yp / r) - 0.5 (n_hi % 2) )        *         m_hi_n_hi = m_hi_n_hi        *         * Step 3) compute the distance from P to V1 and V2. Snap to the closer point.        */
name|gint
name|n_lo
decl_stmt|;
name|gint
name|n_hi
decl_stmt|;
name|gint
name|m_lo_n_lo
decl_stmt|;
name|gint
name|m_hi_n_lo
decl_stmt|;
name|gint
name|m_lo_n_hi
decl_stmt|;
name|gint
name|m_hi_n_hi
decl_stmt|;
name|gint
name|m_n_lo
decl_stmt|;
name|gint
name|m_n_hi
decl_stmt|;
name|gdouble
name|r
decl_stmt|;
name|gdouble
name|h
decl_stmt|;
name|gint
name|x1
decl_stmt|;
name|gint
name|x2
decl_stmt|;
name|gint
name|y1
decl_stmt|;
name|gint
name|y2
decl_stmt|;
name|r
operator|=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
name|h
operator|=
name|COS_1o6PI_RAD
operator|*
name|r
expr_stmt|;
name|n_lo
operator|=
operator|(
name|gint
operator|)
name|x
operator|/
name|h
expr_stmt|;
name|n_hi
operator|=
name|n_lo
operator|+
literal|1
expr_stmt|;
comment|/* evaluate m candidates for n_lo */
name|m_lo_n_lo
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|y
operator|/
name|r
operator|)
operator|-
literal|0.5
operator|*
operator|(
name|n_lo
operator|%
literal|2
operator|)
argument_list|)
expr_stmt|;
name|m_hi_n_lo
operator|=
name|m_lo_n_lo
operator|+
literal|1
expr_stmt|;
comment|/* figure out which is the better candidate */
if|if
condition|(
name|abs
argument_list|(
operator|(
name|m_lo_n_lo
operator|*
name|r
operator|+
operator|(
literal|0.5
operator|*
name|r
operator|*
operator|(
name|n_lo
operator|%
literal|2
operator|)
operator|)
operator|)
operator|-
name|y
argument_list|)
operator|<
name|abs
argument_list|(
operator|(
name|m_hi_n_lo
operator|*
name|r
operator|+
operator|(
literal|0.5
operator|*
name|r
operator|*
operator|(
name|n_lo
operator|%
literal|2
operator|)
operator|)
operator|)
operator|-
name|y
argument_list|)
condition|)
block|{
name|m_n_lo
operator|=
name|m_lo_n_lo
expr_stmt|;
block|}
else|else
block|{
name|m_n_lo
operator|=
name|m_hi_n_lo
expr_stmt|;
block|}
comment|/* evaluate m candidates for n_hi */
name|m_lo_n_hi
operator|=
call|(
name|gint
call|)
argument_list|(
operator|(
name|y
operator|/
name|r
operator|)
operator|-
literal|0.5
operator|*
operator|(
name|n_hi
operator|%
literal|2
operator|)
argument_list|)
expr_stmt|;
name|m_hi_n_hi
operator|=
name|m_lo_n_hi
operator|+
literal|1
expr_stmt|;
comment|/* figure out which is the better candidate */
if|if
condition|(
name|abs
argument_list|(
operator|(
name|m_lo_n_hi
operator|*
name|r
operator|+
operator|(
literal|0.5
operator|*
name|r
operator|*
operator|(
name|n_hi
operator|%
literal|2
operator|)
operator|)
operator|)
operator|-
name|y
argument_list|)
operator|<
name|abs
argument_list|(
operator|(
name|m_hi_n_hi
operator|*
name|r
operator|+
operator|(
literal|0.5
operator|*
name|r
operator|*
operator|(
name|n_hi
operator|%
literal|2
operator|)
operator|)
operator|)
operator|-
name|y
argument_list|)
condition|)
block|{
name|m_n_hi
operator|=
name|m_lo_n_hi
expr_stmt|;
block|}
else|else
block|{
name|m_n_hi
operator|=
name|m_hi_n_hi
expr_stmt|;
block|}
comment|/* Now, which is closer to [x,y]? we can use a somewhat abbreviated form of the         * distance formula since we only care about relative values. */
name|x1
operator|=
call|(
name|gint
call|)
argument_list|(
name|n_lo
operator|*
name|h
argument_list|)
expr_stmt|;
name|y1
operator|=
call|(
name|gint
call|)
argument_list|(
name|m_n_lo
operator|*
name|r
operator|+
operator|(
literal|0.5
operator|*
name|r
operator|*
operator|(
name|n_lo
operator|%
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|x2
operator|=
call|(
name|gint
call|)
argument_list|(
name|n_hi
operator|*
name|h
argument_list|)
expr_stmt|;
name|y2
operator|=
call|(
name|gint
call|)
argument_list|(
name|m_n_hi
operator|*
name|r
operator|+
operator|(
literal|0.5
operator|*
name|r
operator|*
operator|(
name|n_hi
operator|%
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|-
name|x1
operator|)
operator|*
operator|(
name|x
operator|-
name|x1
operator|)
operator|+
operator|(
name|y
operator|-
name|y1
operator|)
operator|*
operator|(
name|y
operator|-
name|y1
operator|)
operator|)
operator|<
operator|(
operator|(
name|x
operator|-
name|x2
operator|)
operator|*
operator|(
name|x
operator|-
name|x2
operator|)
operator|+
operator|(
name|y
operator|-
name|y2
operator|)
operator|*
operator|(
name|y
operator|-
name|y2
operator|)
operator|)
condition|)
block|{
name|gp
operator|->
name|x
operator|=
name|x1
expr_stmt|;
name|gp
operator|->
name|y
operator|=
name|y1
expr_stmt|;
block|}
else|else
block|{
name|gp
operator|->
name|x
operator|=
name|x2
expr_stmt|;
name|gp
operator|->
name|y
operator|=
name|y2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|draw_grid_polar (GdkGC * drawgc)
name|draw_grid_polar
parameter_list|(
name|GdkGC
modifier|*
name|drawgc
parameter_list|)
block|{
name|gint
name|step
decl_stmt|;
name|gint
name|loop
decl_stmt|;
name|gint
name|radius
decl_stmt|;
name|gint
name|max_rad
decl_stmt|;
name|gdouble
name|ang_grid
decl_stmt|;
name|gdouble
name|ang_loop
decl_stmt|;
name|gdouble
name|ang_radius
decl_stmt|;
comment|/* Pick center and draw concentric circles */
name|gint
name|grid_x_center
init|=
name|preview_width
operator|/
literal|2
decl_stmt|;
name|gint
name|grid_y_center
init|=
name|preview_height
operator|/
literal|2
decl_stmt|;
name|step
operator|=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
name|max_rad
operator|=
name|sqrt
argument_list|(
name|preview_width
operator|*
name|preview_width
operator|+
name|preview_height
operator|*
name|preview_height
argument_list|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|max_rad
condition|;
name|loop
operator|+=
name|step
control|)
block|{
name|radius
operator|=
name|loop
expr_stmt|;
name|gdk_draw_arc
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
literal|0
argument_list|,
name|grid_x_center
operator|-
name|radius
argument_list|,
name|grid_y_center
operator|-
name|radius
argument_list|,
name|radius
operator|*
literal|2
argument_list|,
name|radius
operator|*
literal|2
argument_list|,
literal|0
argument_list|,
literal|360
operator|*
literal|64
argument_list|)
expr_stmt|;
block|}
comment|/* Lines */
name|ang_grid
operator|=
literal|2
operator|*
name|G_PI
operator|/
name|get_num_radials
argument_list|()
expr_stmt|;
name|ang_radius
operator|=
name|sqrt
argument_list|(
operator|(
name|preview_width
operator|*
name|preview_width
operator|)
operator|+
operator|(
name|preview_height
operator|*
name|preview_height
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<=
name|get_num_radials
argument_list|()
condition|;
name|loop
operator|++
control|)
block|{
name|gint
name|lx
decl_stmt|,
name|ly
decl_stmt|;
name|ang_loop
operator|=
name|loop
operator|*
name|ang_grid
expr_stmt|;
name|lx
operator|=
name|RINT
argument_list|(
name|ang_radius
operator|*
name|cos
argument_list|(
name|ang_loop
argument_list|)
argument_list|)
expr_stmt|;
name|ly
operator|=
name|RINT
argument_list|(
name|ang_radius
operator|*
name|sin
argument_list|(
name|ang_loop
argument_list|)
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
name|lx
operator|+
operator|(
name|preview_width
operator|)
operator|/
literal|2
argument_list|,
operator|-
name|ly
operator|+
operator|(
name|preview_height
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|preview_width
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|preview_height
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|draw_grid_sq (GdkGC * drawgc)
name|draw_grid_sq
parameter_list|(
name|GdkGC
modifier|*
name|drawgc
parameter_list|)
block|{
name|gint
name|step
decl_stmt|;
name|gint
name|loop
decl_stmt|;
comment|/* Draw the horizontal lines */
name|step
operator|=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|preview_height
condition|;
name|loop
operator|+=
name|step
control|)
block|{
name|gdk_draw_line
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
literal|0
argument_list|,
name|loop
argument_list|,
name|preview_width
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
comment|/* Draw the vertical lines */
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|preview_width
condition|;
name|loop
operator|+=
name|step
control|)
block|{
name|gdk_draw_line
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
name|loop
argument_list|,
literal|0
argument_list|,
name|loop
argument_list|,
name|preview_height
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|draw_grid_iso (GdkGC * drawgc)
name|draw_grid_iso
parameter_list|(
name|GdkGC
modifier|*
name|drawgc
parameter_list|)
block|{
comment|/* vstep is an int since it's defined from grid size */
name|gint
name|vstep
decl_stmt|;
name|gdouble
name|loop
decl_stmt|;
name|gdouble
name|hstep
decl_stmt|;
name|gdouble
name|diagonal_start
decl_stmt|;
name|gdouble
name|diagonal_end
decl_stmt|;
name|gdouble
name|diagonal_width
decl_stmt|;
name|gdouble
name|diagonal_height
decl_stmt|;
name|vstep
operator|=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
expr_stmt|;
name|hstep
operator|=
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|*
name|COS_1o6PI_RAD
expr_stmt|;
comment|/* Draw the vertical lines - These are easy */
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|preview_width
condition|;
name|loop
operator|+=
name|hstep
control|)
block|{
name|gdk_draw_line
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
operator|(
name|gint
operator|)
name|loop
argument_list|,
operator|(
name|gint
operator|)
literal|0
argument_list|,
operator|(
name|gint
operator|)
name|loop
argument_list|,
operator|(
name|gint
operator|)
name|preview_height
argument_list|)
expr_stmt|;
block|}
comment|/* draw diag lines at a Theta of +/- 1/6 Pi Rad */
name|diagonal_start
operator|=
operator|-
operator|(
operator|(
operator|(
name|int
operator|)
name|preview_width
operator|*
name|TAN_1o6PI_RAD
operator|)
operator|-
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|preview_width
operator|*
name|TAN_1o6PI_RAD
argument_list|)
operator|)
operator|%
name|vstep
operator|)
operator|)
expr_stmt|;
name|diagonal_end
operator|=
name|preview_height
operator|+
operator|(
name|preview_width
operator|*
name|TAN_1o6PI_RAD
operator|)
expr_stmt|;
name|diagonal_end
operator|-=
operator|(
operator|(
name|int
operator|)
name|diagonal_end
operator|)
operator|%
name|vstep
expr_stmt|;
name|diagonal_width
operator|=
name|preview_width
expr_stmt|;
name|diagonal_height
operator|=
name|preview_width
operator|*
name|TAN_1o6PI_RAD
expr_stmt|;
comment|/* Draw diag lines */
for|for
control|(
name|loop
operator|=
name|diagonal_start
init|;
name|loop
operator|<
name|diagonal_end
condition|;
name|loop
operator|+=
name|vstep
control|)
block|{
name|gdk_draw_line
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
operator|(
name|gint
operator|)
literal|0
argument_list|,
operator|(
name|gint
operator|)
name|loop
argument_list|,
operator|(
name|gint
operator|)
name|diagonal_width
argument_list|,
operator|(
name|gint
operator|)
name|loop
operator|+
name|diagonal_height
argument_list|)
expr_stmt|;
name|gdk_draw_line
argument_list|(
name|gfig_preview
operator|->
name|window
argument_list|,
name|drawgc
argument_list|,
operator|(
name|gint
operator|)
literal|0
argument_list|,
operator|(
name|gint
operator|)
name|loop
argument_list|,
operator|(
name|gint
operator|)
name|diagonal_width
argument_list|,
operator|(
name|gint
operator|)
name|loop
operator|-
name|diagonal_height
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|GdkGC
modifier|*
DECL|function|gfig_get_grid_gc (GtkWidget * w,gint gctype)
name|gfig_get_grid_gc
parameter_list|(
name|GtkWidget
modifier|*
name|w
parameter_list|,
name|gint
name|gctype
parameter_list|)
block|{
switch|switch
condition|(
name|gctype
condition|)
block|{
case|case
name|GFIG_BLACK_GC
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|black_gc
operator|)
return|;
case|case
name|GFIG_WHITE_GC
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|white_gc
operator|)
return|;
case|case
name|GFIG_GREY_GC
case|:
return|return
operator|(
name|grid_hightlight_drawgc
operator|)
return|;
case|case
name|GTK_STATE_NORMAL
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_NORMAL
index|]
operator|)
return|;
case|case
name|GTK_STATE_ACTIVE
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_ACTIVE
index|]
operator|)
return|;
case|case
name|GTK_STATE_PRELIGHT
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_PRELIGHT
index|]
operator|)
return|;
case|case
name|GTK_STATE_SELECTED
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_SELECTED
index|]
operator|)
return|;
case|case
name|GTK_STATE_INSENSITIVE
case|:
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_INSENSITIVE
index|]
operator|)
return|;
default|default:
name|g_warning
argument_list|(
literal|"Unknown type for grid colouring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|->
name|style
operator|->
name|bg_gc
index|[
name|GTK_STATE_PRELIGHT
index|]
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|draw_grid (void)
name|draw_grid
parameter_list|(
name|void
parameter_list|)
block|{
name|GdkGC
modifier|*
name|drawgc
decl_stmt|;
comment|/* Get the size of the preview and calc where the lines go */
comment|/* Draw in prelight to start with... */
comment|/* Always start in the upper left corner for rect.    */
if|if
condition|(
operator|(
name|preview_width
operator|<
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|&&
name|preview_height
operator|<
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
operator|)
operator|||
name|drawing_pic
condition|)
block|{
comment|/* Don't draw if they don't fit */
return|return;
block|}
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|drawgrid
condition|)
name|drawgc
operator|=
name|gfig_get_grid_gc
argument_list|(
name|gfig_preview
argument_list|,
name|grid_gc_type
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|gridtype
operator|==
name|RECT_GRID
condition|)
name|draw_grid_sq
argument_list|(
name|drawgc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|gridtype
operator|==
name|POLAR_GRID
condition|)
name|draw_grid_polar
argument_list|(
name|drawgc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|selvals
operator|.
name|opts
operator|.
name|gridtype
operator|==
name|ISO_GRID
condition|)
name|draw_grid_iso
argument_list|(
name|drawgc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|get_num_radials (void)
name|get_num_radials
parameter_list|(
name|void
parameter_list|)
block|{
name|gint
name|gridsp
init|=
name|MAX_GRID
operator|+
name|MIN_GRID
decl_stmt|;
comment|/* select number of radials to draw */
comment|/* Either have 16 32 or 48 */
comment|/* correspond to GRID_MAX, midway and GRID_MIN */
return|return
name|gridsp
operator|-
name|selvals
operator|.
name|opts
operator|.
name|gridspacing
return|;
block|}
end_function

end_unit

