begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This is a plug-in for the GIMP.  *  * Generates images containing vector type drawings.  *  * Copyright (C) 1997 Andy Thomas  alt@picnic.demon.co.uk  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"gfig.h"
end_include

begin_include
include|#
directive|include
file|"gfig-dialog.h"
end_include

begin_include
include|#
directive|include
file|"gfig-style.h"
end_include

begin_include
include|#
directive|include
file|"gfig-arc.h"
end_include

begin_include
include|#
directive|include
file|"gfig-bezier.h"
end_include

begin_include
include|#
directive|include
file|"gfig-circle.h"
end_include

begin_include
include|#
directive|include
file|"gfig-dobject.h"
end_include

begin_include
include|#
directive|include
file|"gfig-ellipse.h"
end_include

begin_include
include|#
directive|include
file|"gfig-line.h"
end_include

begin_include
include|#
directive|include
file|"gfig-poly.h"
end_include

begin_include
include|#
directive|include
file|"gfig-spiral.h"
end_include

begin_include
include|#
directive|include
file|"gfig-star.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_decl_stmt
DECL|variable|operation_obj
specifier|static
name|Dobject
modifier|*
name|operation_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|move_all_pnt
specifier|static
name|GdkPoint
modifier|*
name|move_all_pnt
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|move_all_pnt
comment|/* Point moving all from */
end_comment

begin_function_decl
specifier|static
name|void
name|draw_one_obj
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_move_obj
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_move_all_obj
parameter_list|(
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_move_obj_pnt
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_obj_from_list
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|,
name|Dobject
modifier|*
name|del_obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|scan_obj_points
parameter_list|(
name|DobjPoints
modifier|*
name|opnt
parameter_list|,
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
DECL|function|gfig_init_object_classes ()
name|gfig_init_object_classes
parameter_list|()
block|{
name|d_arc_object_class_init
argument_list|()
expr_stmt|;
name|d_line_object_class_init
argument_list|()
expr_stmt|;
name|d_circle_object_class_init
argument_list|()
expr_stmt|;
name|d_ellipse_object_class_init
argument_list|()
expr_stmt|;
name|d_poly_object_class_init
argument_list|()
expr_stmt|;
name|d_spiral_object_class_init
argument_list|()
expr_stmt|;
name|d_star_object_class_init
argument_list|()
expr_stmt|;
name|d_bezier_object_class_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a list of points */
end_comment

begin_function
name|void
DECL|function|d_delete_dobjpoints (DobjPoints * pnts)
name|d_delete_dobjpoints
parameter_list|(
name|DobjPoints
modifier|*
name|pnts
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|next
decl_stmt|;
name|DobjPoints
modifier|*
name|pnt2del
init|=
name|pnts
decl_stmt|;
while|while
condition|(
name|pnt2del
condition|)
block|{
name|next
operator|=
name|pnt2del
operator|->
name|next
expr_stmt|;
name|g_free
argument_list|(
name|pnt2del
argument_list|)
expr_stmt|;
name|pnt2del
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|DobjPoints
modifier|*
DECL|function|new_dobjpoint (gint x,gint y)
name|new_dobjpoint
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|npnt
init|=
name|g_new0
argument_list|(
name|DobjPoints
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|npnt
operator|->
name|pnt
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|npnt
operator|->
name|pnt
operator|.
name|y
operator|=
name|y
expr_stmt|;
return|return
name|npnt
return|;
block|}
end_function

begin_function
name|DobjPoints
modifier|*
DECL|function|d_copy_dobjpoints (DobjPoints * pnts)
name|d_copy_dobjpoints
parameter_list|(
name|DobjPoints
modifier|*
name|pnts
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|DobjPoints
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|DobjPoints
modifier|*
name|newpnt
decl_stmt|;
name|DobjPoints
modifier|*
name|pnt2copy
decl_stmt|;
for|for
control|(
name|pnt2copy
operator|=
name|pnts
init|;
name|pnt2copy
condition|;
name|pnt2copy
operator|=
name|pnt2copy
operator|->
name|next
control|)
block|{
name|newpnt
operator|=
name|new_dobjpoint
argument_list|(
name|pnt2copy
operator|->
name|pnt
operator|.
name|x
argument_list|,
name|pnt2copy
operator|->
name|pnt
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|head
operator|=
name|ret
operator|=
name|newpnt
expr_stmt|;
block|}
else|else
block|{
name|head
operator|->
name|next
operator|=
name|newpnt
expr_stmt|;
name|head
operator|=
name|newpnt
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|DobjPoints
modifier|*
DECL|function|get_diffs (Dobject * obj,gint * xdiff,gint * ydiff,GdkPoint * to_pnt)
name|get_diffs
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|gint
modifier|*
name|xdiff
parameter_list|,
name|gint
modifier|*
name|ydiff
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
name|g_assert
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|spnt
operator|=
name|obj
operator|->
name|points
init|;
name|spnt
condition|;
name|spnt
operator|=
name|spnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|spnt
operator|->
name|found_me
condition|)
block|{
operator|*
name|xdiff
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|-
name|to_pnt
operator|->
name|x
expr_stmt|;
operator|*
name|ydiff
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|-
name|to_pnt
operator|->
name|y
expr_stmt|;
return|return
name|spnt
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|inside_sqr (GdkPoint * cpnt,GdkPoint * testpnt)
name|inside_sqr
parameter_list|(
name|GdkPoint
modifier|*
name|cpnt
parameter_list|,
name|GdkPoint
modifier|*
name|testpnt
parameter_list|)
block|{
comment|/* Return TRUE if testpnt is near cpnt */
name|gint
name|x
init|=
name|cpnt
operator|->
name|x
decl_stmt|;
name|gint
name|y
init|=
name|cpnt
operator|->
name|y
decl_stmt|;
name|gint
name|tx
init|=
name|testpnt
operator|->
name|x
decl_stmt|;
name|gint
name|ty
init|=
name|testpnt
operator|->
name|y
decl_stmt|;
return|return
operator|(
name|abs
argument_list|(
name|x
operator|-
name|tx
argument_list|)
operator|<=
name|SQ_SIZE
operator|&&
name|abs
argument_list|(
name|y
operator|-
name|ty
argument_list|)
operator|<
name|SQ_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|scan_obj_points (DobjPoints * opnt,GdkPoint * pnt)
name|scan_obj_points
parameter_list|(
name|DobjPoints
modifier|*
name|opnt
parameter_list|,
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
block|{
while|while
condition|(
name|opnt
condition|)
block|{
if|if
condition|(
name|inside_sqr
argument_list|(
operator|&
name|opnt
operator|->
name|pnt
argument_list|,
name|pnt
argument_list|)
condition|)
block|{
name|opnt
operator|->
name|found_me
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|opnt
operator|->
name|found_me
operator|=
name|FALSE
expr_stmt|;
name|opnt
operator|=
name|opnt
operator|->
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|Dobject
modifier|*
DECL|function|get_nearest_objs (GFigObj * obj,GdkPoint * pnt)
name|get_nearest_objs
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
block|{
comment|/* Nearest object to given point or NULL */
name|DAllObjs
modifier|*
name|all
decl_stmt|;
name|Dobject
modifier|*
name|test_obj
decl_stmt|;
name|gint
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|all
operator|=
name|obj
operator|->
name|obj_list
init|;
name|all
condition|;
name|all
operator|=
name|all
operator|->
name|next
control|)
block|{
name|test_obj
operator|=
name|all
operator|->
name|obj
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|obj_show_single
operator|||
name|obj_show_single
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|scan_obj_points
argument_list|(
name|test_obj
operator|->
name|points
argument_list|,
name|pnt
argument_list|)
condition|)
block|{
return|return
name|test_obj
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|object_operation_start (GdkPoint * pnt,gint shift_down)
name|object_operation_start
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gint
name|shift_down
parameter_list|)
block|{
name|Dobject
modifier|*
name|new_obj
decl_stmt|;
comment|/* Find point in given object list */
name|operation_obj
operator|=
name|get_nearest_objs
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|,
name|pnt
argument_list|)
expr_stmt|;
comment|/* Special case if shift down&& move obj then moving all objs */
if|if
condition|(
name|shift_down
operator|&&
name|selvals
operator|.
name|otype
operator|==
name|MOVE_OBJ
condition|)
block|{
name|move_all_pnt
operator|=
name|g_malloc0
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|move_all_pnt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|move_all_pnt
operator|=
operator|*
name|pnt
expr_stmt|;
comment|/* Structure copy */
name|setup_undo
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|operation_obj
condition|)
return|return;
comment|/* None to work on */
name|setup_undo
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|MOVE_OBJ
case|:
if|if
condition|(
name|operation_obj
operator|->
name|type
operator|==
name|BEZIER
condition|)
block|{
name|d_draw_bezier
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
name|tmp_bezier
operator|=
name|operation_obj
expr_stmt|;
name|d_draw_bezier
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOVE_POINT
case|:
if|if
condition|(
name|operation_obj
operator|->
name|type
operator|==
name|BEZIER
condition|)
block|{
name|d_draw_bezier
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
name|tmp_bezier
operator|=
name|operation_obj
expr_stmt|;
name|d_draw_bezier
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
block|}
comment|/* If shift is down the break into sep lines */
if|if
condition|(
operator|(
name|operation_obj
operator|->
name|type
operator|==
name|POLY
operator|||
name|operation_obj
operator|->
name|type
operator|==
name|STAR
operator|)
operator|&&
name|shift_down
condition|)
block|{
switch|switch
condition|(
name|operation_obj
operator|->
name|type
condition|)
block|{
case|case
name|POLY
case|:
name|d_poly2lines
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|d_star2lines
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Re calc which object point we are lookin at */
name|scan_obj_points
argument_list|(
name|operation_obj
operator|->
name|points
argument_list|,
name|pnt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COPY_OBJ
case|:
comment|/* Copy the "operation object" */
comment|/* Then bung us into "copy/move" mode */
name|new_obj
operator|=
operator|(
name|Dobject
operator|*
operator|)
name|operation_obj
operator|->
name|class
operator|->
name|copyfunc
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_obj
condition|)
block|{
name|gfig_style_copy
argument_list|(
operator|&
name|new_obj
operator|->
name|style
argument_list|,
operator|&
name|operation_obj
operator|->
name|style
argument_list|,
literal|"Object"
argument_list|)
expr_stmt|;
name|scan_obj_points
argument_list|(
name|new_obj
operator|->
name|points
argument_list|,
name|pnt
argument_list|)
expr_stmt|;
name|add_to_all_obj
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|,
name|new_obj
argument_list|)
expr_stmt|;
name|operation_obj
operator|=
name|new_obj
expr_stmt|;
name|selvals
operator|.
name|otype
operator|=
name|MOVE_COPY_OBJ
expr_stmt|;
name|new_obj
operator|->
name|class
operator|->
name|drawfunc
argument_list|(
name|new_obj
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEL_OBJ
case|:
name|remove_obj_from_list
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|,
name|operation_obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOVE_COPY_OBJ
case|:
comment|/* Never when button down */
default|default:
name|g_warning
argument_list|(
literal|"Internal error selvals.otype object operation start"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|object_operation_end (GdkPoint * pnt,gint shift_down)
name|object_operation_end
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gint
name|shift_down
parameter_list|)
block|{
if|if
condition|(
name|selvals
operator|.
name|otype
operator|!=
name|DEL_OBJ
operator|&&
name|operation_obj
operator|&&
name|operation_obj
operator|->
name|type
operator|==
name|BEZIER
condition|)
block|{
name|d_draw_bezier
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
name|tmp_bezier
operator|=
name|NULL
expr_stmt|;
comment|/* use as switch */
name|d_draw_bezier
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operation_obj
condition|)
block|{
name|gfig_style_set_context_from_style
argument_list|(
operator|&
name|operation_obj
operator|->
name|style
argument_list|)
expr_stmt|;
name|gfig_paint_callback
argument_list|()
expr_stmt|;
block|}
name|operation_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|move_all_pnt
condition|)
block|{
name|g_free
argument_list|(
name|move_all_pnt
argument_list|)
expr_stmt|;
name|move_all_pnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Special case - if copying mode MUST be copy when button up received */
if|if
condition|(
name|selvals
operator|.
name|otype
operator|==
name|MOVE_COPY_OBJ
condition|)
name|selvals
operator|.
name|otype
operator|=
name|COPY_OBJ
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move object around */
end_comment

begin_function
name|void
DECL|function|object_operation (GdkPoint * to_pnt,gint shift_down)
name|object_operation
parameter_list|(
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|,
name|gint
name|shift_down
parameter_list|)
block|{
comment|/* Must do diffent things depending on object type */
comment|/* but must have object to operate on! */
comment|/* Special case - if shift own and move_obj then move ALL objects */
if|if
condition|(
name|move_all_pnt
operator|&&
name|shift_down
operator|&&
name|selvals
operator|.
name|otype
operator|==
name|MOVE_OBJ
condition|)
block|{
name|do_move_all_obj
argument_list|(
name|to_pnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|operation_obj
condition|)
return|return;
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|MOVE_OBJ
case|:
case|case
name|MOVE_COPY_OBJ
case|:
switch|switch
condition|(
name|operation_obj
operator|->
name|type
condition|)
block|{
case|case
name|LINE
case|:
case|case
name|CIRCLE
case|:
case|case
name|ELLIPSE
case|:
case|case
name|POLY
case|:
case|case
name|ARC
case|:
case|case
name|STAR
case|:
case|case
name|SPIRAL
case|:
case|case
name|BEZIER
case|:
name|do_move_obj
argument_list|(
name|operation_obj
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
name|g_warning
argument_list|(
literal|"Internal error in operation_obj->type"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOVE_POINT
case|:
switch|switch
condition|(
name|operation_obj
operator|->
name|type
condition|)
block|{
case|case
name|LINE
case|:
case|case
name|CIRCLE
case|:
case|case
name|ELLIPSE
case|:
case|case
name|POLY
case|:
case|case
name|ARC
case|:
case|case
name|STAR
case|:
case|case
name|SPIRAL
case|:
case|case
name|BEZIER
case|:
name|do_move_obj_pnt
argument_list|(
name|operation_obj
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
name|g_warning
argument_list|(
literal|"Internal error in operation_obj->type"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DEL_OBJ
case|:
break|break;
case|case
name|COPY_OBJ
case|:
comment|/* Should have been changed to MOVE_COPY_OBJ */
default|default:
name|g_warning
argument_list|(
literal|"Internal error selvals.otype"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|update_pnts (Dobject * obj,gint xdiff,gint ydiff)
name|update_pnts
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|gint
name|xdiff
parameter_list|,
name|gint
name|ydiff
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
name|g_assert
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Update all pnts */
for|for
control|(
name|spnt
operator|=
name|obj
operator|->
name|points
init|;
name|spnt
condition|;
name|spnt
operator|=
name|spnt
operator|->
name|next
control|)
block|{
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|-=
name|xdiff
expr_stmt|;
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|-=
name|ydiff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|remove_obj_from_list (GFigObj * obj,Dobject * del_obj)
name|remove_obj_from_list
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|,
name|Dobject
modifier|*
name|del_obj
parameter_list|)
block|{
comment|/* Nearest object to given point or NULL */
name|DAllObjs
modifier|*
name|all
decl_stmt|;
name|DAllObjs
modifier|*
name|prev_all
init|=
name|NULL
decl_stmt|;
name|g_assert
argument_list|(
name|del_obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|all
operator|=
name|obj
operator|->
name|obj_list
expr_stmt|;
while|while
condition|(
name|all
condition|)
block|{
if|if
condition|(
name|all
operator|->
name|obj
operator|==
name|del_obj
condition|)
block|{
comment|/* Found the one to delete */
if|if
condition|(
name|prev_all
condition|)
name|prev_all
operator|->
name|next
operator|=
name|all
operator|->
name|next
expr_stmt|;
else|else
name|obj
operator|->
name|obj_list
operator|=
name|all
operator|->
name|next
expr_stmt|;
comment|/* Draw obj (which will actually undraw it! */
name|del_obj
operator|->
name|class
operator|->
name|drawfunc
argument_list|(
name|del_obj
argument_list|)
expr_stmt|;
name|free_one_obj
argument_list|(
name|del_obj
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|all
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_show_single
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We've just deleted the only visible one */
name|draw_grid_clear
argument_list|()
expr_stmt|;
name|obj_show_single
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Show all again */
block|}
return|return;
block|}
name|prev_all
operator|=
name|all
expr_stmt|;
name|all
operator|=
name|all
operator|->
name|next
expr_stmt|;
block|}
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"Hey where has the object gone ?"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_move_all_obj (GdkPoint * to_pnt)
name|do_move_all_obj
parameter_list|(
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
comment|/* Move all objects in one go */
comment|/* Undraw/then draw in new pos */
name|gint
name|xdiff
init|=
name|move_all_pnt
operator|->
name|x
operator|-
name|to_pnt
operator|->
name|x
decl_stmt|;
name|gint
name|ydiff
init|=
name|move_all_pnt
operator|->
name|y
operator|-
name|to_pnt
operator|->
name|y
decl_stmt|;
if|if
condition|(
name|xdiff
operator|||
name|ydiff
condition|)
block|{
name|DAllObjs
modifier|*
name|all
decl_stmt|;
for|for
control|(
name|all
operator|=
name|gfig_context
operator|->
name|current_obj
operator|->
name|obj_list
init|;
name|all
condition|;
name|all
operator|=
name|all
operator|->
name|next
control|)
block|{
name|Dobject
modifier|*
name|obj
init|=
name|all
operator|->
name|obj
decl_stmt|;
comment|/* undraw ! */
name|draw_one_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|update_pnts
argument_list|(
name|obj
argument_list|,
name|xdiff
argument_list|,
name|ydiff
argument_list|)
expr_stmt|;
comment|/* Draw in new pos */
name|draw_one_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
operator|*
name|move_all_pnt
operator|=
operator|*
name|to_pnt
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|do_save_obj (Dobject * obj,GString * string)
name|do_save_obj
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|GString
modifier|*
name|string
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
for|for
control|(
name|spnt
operator|=
name|obj
operator|->
name|points
init|;
name|spnt
condition|;
name|spnt
operator|=
name|spnt
operator|->
name|next
control|)
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%d %d\n"
argument_list|,
name|spnt
operator|->
name|pnt
operator|.
name|x
argument_list|,
name|spnt
operator|->
name|pnt
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_move_obj (Dobject * obj,GdkPoint * to_pnt)
name|do_move_obj
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
comment|/* Move the whole line - undraw the line to start with */
comment|/* Then draw in new pos */
name|gint
name|xdiff
init|=
literal|0
decl_stmt|;
name|gint
name|ydiff
init|=
literal|0
decl_stmt|;
name|get_diffs
argument_list|(
name|obj
argument_list|,
operator|&
name|xdiff
argument_list|,
operator|&
name|ydiff
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdiff
operator|||
name|ydiff
condition|)
block|{
comment|/* undraw ! */
name|draw_one_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|update_pnts
argument_list|(
name|obj
argument_list|,
name|xdiff
argument_list|,
name|ydiff
argument_list|)
expr_stmt|;
comment|/* Draw in new pos */
name|draw_one_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_move_obj_pnt (Dobject * obj,GdkPoint * to_pnt)
name|do_move_obj_pnt
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
comment|/* Move the whole line - undraw the line to start with */
comment|/* Then draw in new pos */
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
name|gint
name|xdiff
init|=
literal|0
decl_stmt|;
name|gint
name|ydiff
init|=
literal|0
decl_stmt|;
name|spnt
operator|=
name|get_diffs
argument_list|(
name|obj
argument_list|,
operator|&
name|xdiff
argument_list|,
operator|&
name|ydiff
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|xdiff
operator|&&
operator|!
name|ydiff
operator|)
operator|||
operator|!
name|spnt
condition|)
return|return;
comment|/* undraw ! */
name|draw_one_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|-
name|xdiff
expr_stmt|;
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|-
name|ydiff
expr_stmt|;
comment|/* Draw in new pos */
name|draw_one_obj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy objs */
end_comment

begin_function
name|DAllObjs
modifier|*
DECL|function|copy_all_objs (DAllObjs * objs)
name|copy_all_objs
parameter_list|(
name|DAllObjs
modifier|*
name|objs
parameter_list|)
block|{
name|DAllObjs
modifier|*
name|nobj
decl_stmt|;
name|DAllObjs
modifier|*
name|new_all_objs
init|=
name|NULL
decl_stmt|;
name|DAllObjs
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|objs
condition|)
block|{
name|nobj
operator|=
name|g_new0
argument_list|(
name|DAllObjs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|new_all_objs
operator|=
name|nobj
expr_stmt|;
block|}
else|else
block|{
name|new_all_objs
operator|->
name|next
operator|=
name|nobj
expr_stmt|;
name|new_all_objs
operator|=
name|nobj
expr_stmt|;
block|}
name|nobj
operator|->
name|obj
operator|=
operator|(
name|Dobject
operator|*
operator|)
name|objs
operator|->
name|obj
operator|->
name|class
operator|->
name|copyfunc
argument_list|(
name|objs
operator|->
name|obj
argument_list|)
expr_stmt|;
name|objs
operator|=
name|objs
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Screen refresh */
end_comment

begin_function
specifier|static
name|void
DECL|function|draw_one_obj (Dobject * obj)
name|draw_one_obj
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|)
block|{
name|obj
operator|->
name|class
operator|->
name|drawfunc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|draw_objects (DAllObjs * objs,gint show_single)
name|draw_objects
parameter_list|(
name|DAllObjs
modifier|*
name|objs
parameter_list|,
name|gint
name|show_single
parameter_list|)
block|{
comment|/* Show_single - only one object to draw Unless shift     * is down in which case show all.    */
name|gint
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|objs
condition|)
block|{
if|if
condition|(
operator|!
name|show_single
operator|||
name|count
operator|==
name|obj_show_single
operator|||
name|obj_show_single
operator|==
operator|-
literal|1
condition|)
name|draw_one_obj
argument_list|(
name|objs
operator|->
name|obj
argument_list|)
expr_stmt|;
name|objs
operator|=
name|objs
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|prepend_to_all_obj (GFigObj * fobj,DAllObjs * nobj)
name|prepend_to_all_obj
parameter_list|(
name|GFigObj
modifier|*
name|fobj
parameter_list|,
name|DAllObjs
modifier|*
name|nobj
parameter_list|)
block|{
name|DAllObjs
modifier|*
name|cobj
decl_stmt|;
name|setup_undo
argument_list|()
expr_stmt|;
comment|/* Remember ME */
if|if
condition|(
operator|!
name|fobj
operator|->
name|obj_list
condition|)
block|{
name|fobj
operator|->
name|obj_list
operator|=
name|nobj
expr_stmt|;
return|return;
block|}
name|cobj
operator|=
name|fobj
operator|->
name|obj_list
expr_stmt|;
while|while
condition|(
name|cobj
operator|->
name|next
condition|)
block|{
name|cobj
operator|=
name|cobj
operator|->
name|next
expr_stmt|;
block|}
name|cobj
operator|->
name|next
operator|=
name|nobj
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|scale_obj_points (DobjPoints * opnt,gdouble scale_x,gdouble scale_y)
name|scale_obj_points
parameter_list|(
name|DobjPoints
modifier|*
name|opnt
parameter_list|,
name|gdouble
name|scale_x
parameter_list|,
name|gdouble
name|scale_y
parameter_list|)
block|{
while|while
condition|(
name|opnt
condition|)
block|{
name|opnt
operator|->
name|pnt
operator|.
name|x
operator|=
call|(
name|gint
call|)
argument_list|(
name|opnt
operator|->
name|pnt
operator|.
name|x
operator|*
name|scale_x
argument_list|)
expr_stmt|;
name|opnt
operator|->
name|pnt
operator|.
name|y
operator|=
call|(
name|gint
call|)
argument_list|(
name|opnt
operator|->
name|pnt
operator|.
name|y
operator|*
name|scale_y
argument_list|)
expr_stmt|;
name|opnt
operator|=
name|opnt
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|add_to_all_obj (GFigObj * fobj,Dobject * obj)
name|add_to_all_obj
parameter_list|(
name|GFigObj
modifier|*
name|fobj
parameter_list|,
name|Dobject
modifier|*
name|obj
parameter_list|)
block|{
name|DAllObjs
modifier|*
name|nobj
decl_stmt|;
name|nobj
operator|=
name|g_new0
argument_list|(
name|DAllObjs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nobj
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
if|if
condition|(
name|need_to_scale
condition|)
name|scale_obj_points
argument_list|(
name|obj
operator|->
name|points
argument_list|,
name|scale_x_factor
argument_list|,
name|scale_y_factor
argument_list|)
expr_stmt|;
name|prepend_to_all_obj
argument_list|(
name|fobj
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
comment|/* initialize style when we add the object */
name|gfig_context
operator|->
name|selected_obj
operator|=
name|obj
expr_stmt|;
name|gfig_context
operator|->
name|current_style
operator|=
operator|&
name|obj
operator|->
name|style
expr_stmt|;
block|}
end_function

begin_comment
comment|/* First button press -- start drawing object */
end_comment

begin_comment
comment|/*  * object_start() creates a new object of the type specified in the  * button panel.  It is activated by a button press, and causes  * a small square to be drawn at the initial point.  The style of  * the new object is set to values taken from the style control  * widgets.   */
end_comment

begin_function
name|void
DECL|function|object_start (GdkPoint * pnt,gint shift_down)
name|object_start
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gint
name|shift_down
parameter_list|)
block|{
comment|/* start for the current object */
if|if
condition|(
operator|!
name|selvals
operator|.
name|scaletoimage
condition|)
block|{
name|need_to_scale
operator|=
literal|1
expr_stmt|;
name|selvals
operator|.
name|scaletoimage
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|need_to_scale
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|LINE
case|:
comment|/* Shift means we are still drawing */
if|if
condition|(
operator|!
name|shift_down
operator|||
operator|!
name|obj_creating
condition|)
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_line_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIRCLE
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_circle_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELLIPSE
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_ellipse_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|POLY
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_poly_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARC
case|:
name|d_arc_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_star_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPIRAL
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_spiral_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER
case|:
if|if
condition|(
operator|!
name|tmp_bezier
condition|)
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_bezier_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
break|break;
block|}
if|if
condition|(
name|obj_creating
condition|)
block|{
if|if
condition|(
name|gfig_context
operator|->
name|debug_styles
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Creating object, setting style from context\n"
argument_list|)
expr_stmt|;
name|gfig_style_set_style_from_context
argument_list|(
operator|&
name|obj_creating
operator|->
name|style
argument_list|)
expr_stmt|;
name|gfig_context
operator|->
name|current_style
operator|=
operator|&
name|obj_creating
operator|->
name|style
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|object_end (GdkPoint * pnt,gint shift_down)
name|object_end
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gint
name|shift_down
parameter_list|)
block|{
comment|/* end for the current object */
comment|/* Add onto global object list */
comment|/* If shift is down may carry on drawing */
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|LINE
case|:
name|d_line_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIRCLE
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_circle_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELLIPSE
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_ellipse_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|POLY
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_poly_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_star_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARC
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_arc_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPIRAL
case|:
name|draw_sqr
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|d_spiral_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER
case|:
name|d_bezier_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
break|break;
block|}
if|if
condition|(
name|need_to_scale
condition|)
block|{
name|need_to_scale
operator|=
literal|0
expr_stmt|;
name|selvals
operator|.
name|scaletoimage
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|object_update (GdkPoint * pnt)
name|object_update
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
block|{
comment|/* update for the current object */
comment|/* New position xy */
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|LINE
case|:
name|d_update_line
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIRCLE
case|:
name|d_update_circle
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELLIPSE
case|:
name|d_update_ellipse
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|POLY
case|:
name|d_update_poly
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|d_update_star
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARC
case|:
name|d_update_arc
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPIRAL
case|:
name|d_update_spiral
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER
case|:
name|d_update_bezier
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Stuff for the generation/deletion of objects. */
end_comment

begin_comment
comment|/* Objects are easy one they are created - you just go down the object  * list calling the draw function for each object but... when they  * are been created we have to be a little more careful. When  * the first point is placed on the canvas we create the object,  * the mouse position then defines the next point that can move around.  * careful how we draw this position.  */
end_comment

begin_function
name|void
DECL|function|free_one_obj (Dobject * obj)
name|free_one_obj
parameter_list|(
name|Dobject
modifier|*
name|obj
parameter_list|)
block|{
name|d_delete_dobjpoints
argument_list|(
name|obj
operator|->
name|points
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|free_all_objs (DAllObjs * objs)
name|free_all_objs
parameter_list|(
name|DAllObjs
modifier|*
name|objs
parameter_list|)
block|{
comment|/* Free all objects */
name|DAllObjs
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|objs
condition|)
block|{
name|free_one_obj
argument_list|(
name|objs
operator|->
name|obj
argument_list|)
expr_stmt|;
name|next
operator|=
name|objs
operator|->
name|next
expr_stmt|;
name|g_free
argument_list|(
name|objs
argument_list|)
expr_stmt|;
name|objs
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|get_line (gchar * buf,gint s,FILE * from,gint init)
name|get_line
parameter_list|(
name|gchar
modifier|*
name|buf
parameter_list|,
name|gint
name|s
parameter_list|,
name|FILE
modifier|*
name|from
parameter_list|,
name|gint
name|init
parameter_list|)
block|{
name|gint
name|slen
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|init
condition|)
name|line_no
operator|=
literal|1
expr_stmt|;
else|else
name|line_no
operator|++
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ferror
argument_list|(
name|from
argument_list|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
do|;
name|slen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* The last newline is a pain */
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
name|buf
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"Error reading file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Processing line '%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|clear_undo (void)
name|clear_undo
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|lv
decl_stmt|;
for|for
control|(
name|lv
operator|=
name|undo_water_mark
init|;
name|lv
operator|>=
literal|0
condition|;
name|lv
operator|--
control|)
block|{
name|free_all_objs
argument_list|(
name|undo_table
index|[
name|lv
index|]
argument_list|)
expr_stmt|;
name|undo_table
index|[
name|lv
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|undo_water_mark
operator|=
operator|-
literal|1
expr_stmt|;
name|gtk_dialog_set_response_sensitive
argument_list|(
name|GTK_DIALOG
argument_list|(
name|top_level_dlg
argument_list|)
argument_list|,
name|RESPONSE_UNDO
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|setup_undo (void)
name|setup_undo
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copy object list to undo buffer */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"setup undo level [%d]\n"
argument_list|,
name|undo_water_mark
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUG*/
if|if
condition|(
operator|!
name|gfig_context
operator|->
name|current_obj
condition|)
block|{
comment|/* If no current_obj must be loading -> no undo */
return|return;
block|}
if|if
condition|(
name|undo_water_mark
operator|>=
name|selvals
operator|.
name|maxundo
operator|-
literal|1
condition|)
block|{
name|int
name|loop
decl_stmt|;
comment|/* the little one in the bed said "roll over".. */
if|if
condition|(
name|undo_table
index|[
literal|0
index|]
condition|)
name|free_one_obj
argument_list|(
name|undo_table
index|[
literal|0
index|]
operator|->
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|undo_water_mark
condition|;
name|loop
operator|++
control|)
block|{
name|undo_table
index|[
name|loop
index|]
operator|=
name|undo_table
index|[
name|loop
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|undo_water_mark
operator|++
expr_stmt|;
block|}
name|undo_table
index|[
name|undo_water_mark
index|]
operator|=
name|copy_all_objs
argument_list|(
name|gfig_context
operator|->
name|current_obj
operator|->
name|obj_list
argument_list|)
expr_stmt|;
name|gtk_dialog_set_response_sensitive
argument_list|(
name|GTK_DIALOG
argument_list|(
name|top_level_dlg
argument_list|)
argument_list|,
name|RESPONSE_UNDO
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gfig_context
operator|->
name|current_obj
operator|->
name|obj_status
operator||=
name|GFIG_MODIFIED
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|new_obj_2edit (GFigObj * obj)
name|new_obj_2edit
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|)
block|{
name|GFigObj
modifier|*
name|old_current
init|=
name|gfig_context
operator|->
name|current_obj
decl_stmt|;
comment|/* Clear undo levels */
comment|/* redraw the preview */
comment|/* Set up options as define in the selected object */
name|clear_undo
argument_list|()
expr_stmt|;
comment|/* Point at this one */
name|gfig_context
operator|->
name|current_obj
operator|=
name|obj
expr_stmt|;
comment|/* Show all objects to start with */
name|obj_show_single
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Change options */
name|update_options
argument_list|(
name|old_current
argument_list|)
expr_stmt|;
comment|/* redraw with new */
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
comment|/* And preview */
name|list_button_update
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|obj_status
operator|&
name|GFIG_READONLY
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Editing read-only object - "
literal|"you will not be able to save it"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_dialog_set_response_sensitive
argument_list|(
name|GTK_DIALOG
argument_list|(
name|top_level_dlg
argument_list|)
argument_list|,
name|RESPONSE_SAVE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gtk_dialog_set_response_sensitive
argument_list|(
name|GTK_DIALOG
argument_list|(
name|top_level_dlg
argument_list|)
argument_list|,
name|RESPONSE_SAVE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|gint
DECL|function|gfig_obj_counts (DAllObjs * objs)
name|gfig_obj_counts
parameter_list|(
name|DAllObjs
modifier|*
name|objs
parameter_list|)
block|{
name|gint
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|objs
condition|;
name|objs
operator|=
name|objs
operator|->
name|next
control|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

end_unit

