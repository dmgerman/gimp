begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This is a plug-in for GIMP.  *  * Generates images containing vector type drawings.  *  * Copyright (C) 1997 Andy Thomas  alt@picnic.demon.co.uk  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"gfig.h"
end_include

begin_include
include|#
directive|include
file|"gfig-dialog.h"
end_include

begin_include
include|#
directive|include
file|"gfig-style.h"
end_include

begin_include
include|#
directive|include
file|"gfig-arc.h"
end_include

begin_include
include|#
directive|include
file|"gfig-bezier.h"
end_include

begin_include
include|#
directive|include
file|"gfig-circle.h"
end_include

begin_include
include|#
directive|include
file|"gfig-dobject.h"
end_include

begin_include
include|#
directive|include
file|"gfig-ellipse.h"
end_include

begin_include
include|#
directive|include
file|"gfig-line.h"
end_include

begin_include
include|#
directive|include
file|"gfig-poly.h"
end_include

begin_include
include|#
directive|include
file|"gfig-rectangle.h"
end_include

begin_include
include|#
directive|include
file|"gfig-spiral.h"
end_include

begin_include
include|#
directive|include
file|"gfig-star.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_decl_stmt
DECL|variable|operation_obj
specifier|static
name|GfigObject
modifier|*
name|operation_obj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|move_all_pnt
specifier|static
name|GdkPoint
modifier|*
name|move_all_pnt
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|move_all_pnt
comment|/* Point moving all from */
end_comment

begin_function_decl
specifier|static
name|void
name|draw_one_obj
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_move_obj
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_move_all_obj
parameter_list|(
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_move_obj_pnt
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_obj_from_list
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|,
name|GfigObject
modifier|*
name|del_obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|scan_obj_points
parameter_list|(
name|DobjPoints
modifier|*
name|opnt
parameter_list|,
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
DECL|function|d_save_object (GfigObject * obj,GString * string)
name|d_save_object
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|GString
modifier|*
name|string
parameter_list|)
block|{
name|do_save_obj
argument_list|(
name|obj
argument_list|,
name|string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|BEZIER
case|:
case|case
name|POLY
case|:
case|case
name|SPIRAL
case|:
case|case
name|STAR
case|:
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"<EXTRA>\n"
argument_list|)
expr_stmt|;
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%d\n</EXTRA>\n"
argument_list|,
name|obj
operator|->
name|type_data
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|DobjType
DECL|function|gfig_read_object_type (gchar * desc)
name|gfig_read_object_type
parameter_list|(
name|gchar
modifier|*
name|desc
parameter_list|)
block|{
name|gchar
modifier|*
name|ptr
init|=
name|desc
decl_stmt|;
name|DobjType
name|type
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'<'
condition|)
return|return
name|OBJ_TYPE_NONE
return|;
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|type
operator|=
name|LINE
init|;
name|type
operator|<
name|NUM_OBJ_TYPES
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|==
name|strstr
argument_list|(
name|ptr
argument_list|,
name|dobj_class
index|[
name|type
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|type
return|;
block|}
return|return
name|OBJ_TYPE_NONE
return|;
block|}
end_function

begin_function
name|GfigObject
modifier|*
DECL|function|d_load_object (gchar * desc,FILE * fp)
name|d_load_object
parameter_list|(
name|gchar
modifier|*
name|desc
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|GfigObject
modifier|*
name|new_obj
init|=
name|NULL
decl_stmt|;
name|gint
name|xpnt
decl_stmt|;
name|gint
name|ypnt
decl_stmt|;
name|gchar
name|buf
index|[
name|MAX_LOAD_LINE
index|]
decl_stmt|;
name|DobjType
name|type
decl_stmt|;
name|type
operator|=
name|gfig_read_object_type
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OBJ_TYPE_NONE
condition|)
block|{
name|g_message
argument_list|(
literal|"Error loading object: type not recognized."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|get_line
argument_list|(
name|buf
argument_list|,
name|MAX_LOAD_LINE
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|xpnt
argument_list|,
operator|&
name|ypnt
argument_list|)
operator|!=
literal|2
condition|)
block|{
comment|/* Read<EXTRA> block if there is one */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"<EXTRA>"
argument_list|,
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|new_obj
condition|)
block|{
name|g_message
argument_list|(
literal|"Error while loading object (no points)"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|get_line
argument_list|(
name|buf
argument_list|,
name|MAX_LOAD_LINE
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|new_obj
operator|->
name|type_data
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|g_message
argument_list|(
literal|"Error while loading object (no type data)"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|new_obj
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|get_line
argument_list|(
name|buf
argument_list|,
name|MAX_LOAD_LINE
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"</EXTRA>"
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"Syntax error while loading object"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|new_obj
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Go around and read the last line */
continue|continue;
block|}
else|else
return|return
name|new_obj
return|;
block|}
if|if
condition|(
operator|!
name|new_obj
condition|)
name|new_obj
operator|=
name|d_new_object
argument_list|(
name|type
argument_list|,
name|xpnt
argument_list|,
name|ypnt
argument_list|)
expr_stmt|;
else|else
name|d_pnt_add_line
argument_list|(
name|new_obj
argument_list|,
name|xpnt
argument_list|,
name|ypnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|new_obj
return|;
block|}
end_function

begin_function
name|GfigObject
modifier|*
DECL|function|d_new_object (DobjType type,gint x,gint y)
name|d_new_object
parameter_list|(
name|DobjType
name|type
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GfigObject
modifier|*
name|nobj
init|=
name|g_new0
argument_list|(
name|GfigObject
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|nobj
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|nobj
operator|->
name|class
operator|=
operator|&
name|dobj_class
index|[
name|type
index|]
expr_stmt|;
name|nobj
operator|->
name|points
operator|=
name|new_dobjpoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|nobj
operator|->
name|type_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|BEZIER
condition|)
block|{
name|nobj
operator|->
name|type_data
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|POLY
condition|)
block|{
name|nobj
operator|->
name|type_data
operator|=
literal|3
expr_stmt|;
comment|/* default to 3 sides */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SPIRAL
condition|)
block|{
name|nobj
operator|->
name|type_data
operator|=
literal|4
expr_stmt|;
comment|/* default to 4 turns */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|STAR
condition|)
block|{
name|nobj
operator|->
name|type_data
operator|=
literal|3
expr_stmt|;
comment|/* default to 3 sides 6 points */
block|}
return|return
name|nobj
return|;
block|}
end_function

begin_function
name|void
DECL|function|gfig_init_object_classes (void)
name|gfig_init_object_classes
parameter_list|(
name|void
parameter_list|)
block|{
name|d_arc_object_class_init
argument_list|()
expr_stmt|;
name|d_line_object_class_init
argument_list|()
expr_stmt|;
name|d_rectangle_object_class_init
argument_list|()
expr_stmt|;
name|d_circle_object_class_init
argument_list|()
expr_stmt|;
name|d_ellipse_object_class_init
argument_list|()
expr_stmt|;
name|d_poly_object_class_init
argument_list|()
expr_stmt|;
name|d_spiral_object_class_init
argument_list|()
expr_stmt|;
name|d_star_object_class_init
argument_list|()
expr_stmt|;
name|d_bezier_object_class_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a list of points */
end_comment

begin_function
name|void
DECL|function|d_delete_dobjpoints (DobjPoints * pnts)
name|d_delete_dobjpoints
parameter_list|(
name|DobjPoints
modifier|*
name|pnts
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|next
decl_stmt|;
name|DobjPoints
modifier|*
name|pnt2del
init|=
name|pnts
decl_stmt|;
while|while
condition|(
name|pnt2del
condition|)
block|{
name|next
operator|=
name|pnt2del
operator|->
name|next
expr_stmt|;
name|g_free
argument_list|(
name|pnt2del
argument_list|)
expr_stmt|;
name|pnt2del
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|DobjPoints
modifier|*
DECL|function|new_dobjpoint (gint x,gint y)
name|new_dobjpoint
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|npnt
init|=
name|g_new0
argument_list|(
name|DobjPoints
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|npnt
operator|->
name|pnt
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|npnt
operator|->
name|pnt
operator|.
name|y
operator|=
name|y
expr_stmt|;
return|return
name|npnt
return|;
block|}
end_function

begin_function
name|DobjPoints
modifier|*
DECL|function|d_copy_dobjpoints (DobjPoints * pnts)
name|d_copy_dobjpoints
parameter_list|(
name|DobjPoints
modifier|*
name|pnts
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|DobjPoints
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|DobjPoints
modifier|*
name|newpnt
decl_stmt|;
name|DobjPoints
modifier|*
name|pnt2copy
decl_stmt|;
for|for
control|(
name|pnt2copy
operator|=
name|pnts
init|;
name|pnt2copy
condition|;
name|pnt2copy
operator|=
name|pnt2copy
operator|->
name|next
control|)
block|{
name|newpnt
operator|=
name|new_dobjpoint
argument_list|(
name|pnt2copy
operator|->
name|pnt
operator|.
name|x
argument_list|,
name|pnt2copy
operator|->
name|pnt
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|head
operator|=
name|ret
operator|=
name|newpnt
expr_stmt|;
block|}
else|else
block|{
name|head
operator|->
name|next
operator|=
name|newpnt
expr_stmt|;
name|head
operator|=
name|newpnt
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|DobjPoints
modifier|*
DECL|function|get_diffs (GfigObject * obj,gint * xdiff,gint * ydiff,GdkPoint * to_pnt)
name|get_diffs
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|gint
modifier|*
name|xdiff
parameter_list|,
name|gint
modifier|*
name|ydiff
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
name|g_assert
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|spnt
operator|=
name|obj
operator|->
name|points
init|;
name|spnt
condition|;
name|spnt
operator|=
name|spnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|spnt
operator|->
name|found_me
condition|)
block|{
operator|*
name|xdiff
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|-
name|to_pnt
operator|->
name|x
expr_stmt|;
operator|*
name|ydiff
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|-
name|to_pnt
operator|->
name|y
expr_stmt|;
return|return
name|spnt
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|inside_sqr (GdkPoint * cpnt,GdkPoint * testpnt)
name|inside_sqr
parameter_list|(
name|GdkPoint
modifier|*
name|cpnt
parameter_list|,
name|GdkPoint
modifier|*
name|testpnt
parameter_list|)
block|{
comment|/* Return TRUE if testpnt is near cpnt */
name|gint
name|x
init|=
name|cpnt
operator|->
name|x
decl_stmt|;
name|gint
name|y
init|=
name|cpnt
operator|->
name|y
decl_stmt|;
name|gint
name|tx
init|=
name|testpnt
operator|->
name|x
decl_stmt|;
name|gint
name|ty
init|=
name|testpnt
operator|->
name|y
decl_stmt|;
return|return
operator|(
name|abs
argument_list|(
name|x
operator|-
name|tx
argument_list|)
operator|<=
name|SQ_SIZE
operator|&&
name|abs
argument_list|(
name|y
operator|-
name|ty
argument_list|)
operator|<
name|SQ_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|scan_obj_points (DobjPoints * opnt,GdkPoint * pnt)
name|scan_obj_points
parameter_list|(
name|DobjPoints
modifier|*
name|opnt
parameter_list|,
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
block|{
while|while
condition|(
name|opnt
condition|)
block|{
if|if
condition|(
name|inside_sqr
argument_list|(
operator|&
name|opnt
operator|->
name|pnt
argument_list|,
name|pnt
argument_list|)
condition|)
block|{
name|opnt
operator|->
name|found_me
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|opnt
operator|->
name|found_me
operator|=
name|FALSE
expr_stmt|;
name|opnt
operator|=
name|opnt
operator|->
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|GfigObject
modifier|*
DECL|function|get_nearest_objs (GFigObj * obj,GdkPoint * pnt)
name|get_nearest_objs
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|pnt
parameter_list|)
block|{
comment|/* Nearest object to given point or NULL */
name|GList
modifier|*
name|all
decl_stmt|;
name|GfigObject
modifier|*
name|test_obj
decl_stmt|;
name|gint
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|all
operator|=
name|obj
operator|->
name|obj_list
init|;
name|all
condition|;
name|all
operator|=
name|g_list_next
argument_list|(
name|all
argument_list|)
control|)
block|{
name|test_obj
operator|=
name|all
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|obj_show_single
operator|||
name|obj_show_single
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|scan_obj_points
argument_list|(
name|test_obj
operator|->
name|points
argument_list|,
name|pnt
argument_list|)
condition|)
block|{
return|return
name|test_obj
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|object_operation_start (GdkPoint * pnt,gboolean shift_down)
name|object_operation_start
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gboolean
name|shift_down
parameter_list|)
block|{
name|GfigObject
modifier|*
name|new_obj
decl_stmt|;
comment|/* Find point in given object list */
name|operation_obj
operator|=
name|get_nearest_objs
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|,
name|pnt
argument_list|)
expr_stmt|;
comment|/* Special case if shift down&& move obj then moving all objs */
if|if
condition|(
name|shift_down
operator|&&
name|selvals
operator|.
name|otype
operator|==
name|MOVE_OBJ
condition|)
block|{
name|move_all_pnt
operator|=
name|g_new
argument_list|(
name|GdkPoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|move_all_pnt
operator|=
operator|*
name|pnt
expr_stmt|;
comment|/* Structure copy */
name|setup_undo
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|operation_obj
condition|)
return|return;
comment|/* None to work on */
name|gfig_context
operator|->
name|selected_obj
operator|=
name|operation_obj
expr_stmt|;
name|setup_undo
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|MOVE_OBJ
case|:
if|if
condition|(
name|operation_obj
operator|->
name|type
operator|==
name|BEZIER
condition|)
block|{
name|tmp_bezier
operator|=
name|operation_obj
expr_stmt|;
block|}
break|break;
case|case
name|MOVE_POINT
case|:
if|if
condition|(
name|operation_obj
operator|->
name|type
operator|==
name|BEZIER
condition|)
block|{
name|tmp_bezier
operator|=
name|operation_obj
expr_stmt|;
block|}
comment|/* If shift is down the break into sep lines */
if|if
condition|(
operator|(
name|operation_obj
operator|->
name|type
operator|==
name|POLY
operator|||
name|operation_obj
operator|->
name|type
operator|==
name|STAR
operator|)
operator|&&
name|shift_down
condition|)
block|{
switch|switch
condition|(
name|operation_obj
operator|->
name|type
condition|)
block|{
case|case
name|POLY
case|:
name|d_poly2lines
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|d_star2lines
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Re calc which object point we are lookin at */
name|scan_obj_points
argument_list|(
name|operation_obj
operator|->
name|points
argument_list|,
name|pnt
argument_list|)
expr_stmt|;
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COPY_OBJ
case|:
comment|/* Copy the "operation object" */
comment|/* Then bung us into "copy/move" mode */
name|new_obj
operator|=
operator|(
name|GfigObject
operator|*
operator|)
name|operation_obj
operator|->
name|class
operator|->
name|copyfunc
argument_list|(
name|operation_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_obj
condition|)
block|{
name|gfig_style_copy
argument_list|(
operator|&
name|new_obj
operator|->
name|style
argument_list|,
operator|&
name|operation_obj
operator|->
name|style
argument_list|,
literal|"Object"
argument_list|)
expr_stmt|;
name|scan_obj_points
argument_list|(
name|new_obj
operator|->
name|points
argument_list|,
name|pnt
argument_list|)
expr_stmt|;
name|add_to_all_obj
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|,
name|new_obj
argument_list|)
expr_stmt|;
name|operation_obj
operator|=
name|new_obj
expr_stmt|;
name|selvals
operator|.
name|otype
operator|=
name|MOVE_COPY_OBJ
expr_stmt|;
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEL_OBJ
case|:
name|remove_obj_from_list
argument_list|(
name|gfig_context
operator|->
name|current_obj
argument_list|,
name|operation_obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|SELECT_OBJ
case|:
comment|/* don't need to do anything */
break|break;
case|case
name|MOVE_COPY_OBJ
case|:
comment|/* Never when button down */
default|default:
name|g_warning
argument_list|(
literal|"Internal error selvals.otype object operation start"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
DECL|function|object_operation_end (GdkPoint * pnt,gboolean shift_down)
name|object_operation_end
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gboolean
name|shift_down
parameter_list|)
block|{
if|if
condition|(
name|selvals
operator|.
name|otype
operator|!=
name|DEL_OBJ
operator|&&
name|operation_obj
operator|&&
name|operation_obj
operator|->
name|type
operator|==
name|BEZIER
condition|)
block|{
name|tmp_bezier
operator|=
name|NULL
expr_stmt|;
comment|/* use as switch */
block|}
if|if
condition|(
name|operation_obj
operator|&&
name|selvals
operator|.
name|otype
operator|!=
name|DEL_OBJ
condition|)
name|gfig_style_set_context_from_style
argument_list|(
operator|&
name|operation_obj
operator|->
name|style
argument_list|)
expr_stmt|;
name|operation_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|move_all_pnt
condition|)
block|{
name|g_free
argument_list|(
name|move_all_pnt
argument_list|)
expr_stmt|;
name|move_all_pnt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Special case - if copying mode MUST be copy when button up received */
if|if
condition|(
name|selvals
operator|.
name|otype
operator|==
name|MOVE_COPY_OBJ
condition|)
name|selvals
operator|.
name|otype
operator|=
name|COPY_OBJ
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move object around */
end_comment

begin_function
name|void
DECL|function|object_operation (GdkPoint * to_pnt,gboolean shift_down)
name|object_operation
parameter_list|(
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|,
name|gboolean
name|shift_down
parameter_list|)
block|{
comment|/* Must do diffent things depending on object type */
comment|/* but must have object to operate on! */
comment|/* Special case - if shift own and move_obj then move ALL objects */
if|if
condition|(
name|move_all_pnt
operator|&&
name|shift_down
operator|&&
name|selvals
operator|.
name|otype
operator|==
name|MOVE_OBJ
condition|)
block|{
name|do_move_all_obj
argument_list|(
name|to_pnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|operation_obj
condition|)
return|return;
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|MOVE_OBJ
case|:
case|case
name|MOVE_COPY_OBJ
case|:
switch|switch
condition|(
name|operation_obj
operator|->
name|type
condition|)
block|{
case|case
name|LINE
case|:
case|case
name|RECTANGLE
case|:
case|case
name|CIRCLE
case|:
case|case
name|ELLIPSE
case|:
case|case
name|POLY
case|:
case|case
name|ARC
case|:
case|case
name|STAR
case|:
case|case
name|SPIRAL
case|:
case|case
name|BEZIER
case|:
name|do_move_obj
argument_list|(
name|operation_obj
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
name|g_warning
argument_list|(
literal|"Internal error in operation_obj->type"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOVE_POINT
case|:
switch|switch
condition|(
name|operation_obj
operator|->
name|type
condition|)
block|{
case|case
name|LINE
case|:
case|case
name|RECTANGLE
case|:
case|case
name|CIRCLE
case|:
case|case
name|ELLIPSE
case|:
case|case
name|POLY
case|:
case|case
name|ARC
case|:
case|case
name|STAR
case|:
case|case
name|SPIRAL
case|:
case|case
name|BEZIER
case|:
name|do_move_obj_pnt
argument_list|(
name|operation_obj
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
name|g_warning
argument_list|(
literal|"Internal error in operation_obj->type"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DEL_OBJ
case|:
case|case
name|SELECT_OBJ
case|:
break|break;
case|case
name|COPY_OBJ
case|:
comment|/* Should have been changed to MOVE_COPY_OBJ */
default|default:
name|g_warning
argument_list|(
literal|"Internal error selvals.otype"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|update_pnts (GfigObject * obj,gint xdiff,gint ydiff)
name|update_pnts
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|gint
name|xdiff
parameter_list|,
name|gint
name|ydiff
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
name|g_assert
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Update all pnts */
for|for
control|(
name|spnt
operator|=
name|obj
operator|->
name|points
init|;
name|spnt
condition|;
name|spnt
operator|=
name|spnt
operator|->
name|next
control|)
block|{
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|-=
name|xdiff
expr_stmt|;
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|-=
name|ydiff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|remove_obj_from_list (GFigObj * obj,GfigObject * del_obj)
name|remove_obj_from_list
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|,
name|GfigObject
modifier|*
name|del_obj
parameter_list|)
block|{
comment|/* Nearest object to given point or NULL */
name|g_assert
argument_list|(
name|del_obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_list_find
argument_list|(
name|obj
operator|->
name|obj_list
argument_list|,
name|del_obj
argument_list|)
condition|)
block|{
name|obj
operator|->
name|obj_list
operator|=
name|g_list_remove
argument_list|(
name|obj
operator|->
name|obj_list
argument_list|,
name|del_obj
argument_list|)
expr_stmt|;
name|free_one_obj
argument_list|(
name|del_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|obj_list
condition|)
name|gfig_context
operator|->
name|selected_obj
operator|=
name|obj
operator|->
name|obj_list
operator|->
name|data
expr_stmt|;
else|else
name|gfig_context
operator|->
name|selected_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|obj_show_single
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We've just deleted the only visible one */
name|draw_grid_clear
argument_list|()
expr_stmt|;
name|obj_show_single
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Show entry again */
block|}
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
block|}
else|else
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"Hey, where has the object gone?"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_move_all_obj (GdkPoint * to_pnt)
name|do_move_all_obj
parameter_list|(
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
comment|/* Move all objects in one go */
comment|/* Undraw/then draw in new pos */
name|gint
name|xdiff
init|=
name|move_all_pnt
operator|->
name|x
operator|-
name|to_pnt
operator|->
name|x
decl_stmt|;
name|gint
name|ydiff
init|=
name|move_all_pnt
operator|->
name|y
operator|-
name|to_pnt
operator|->
name|y
decl_stmt|;
if|if
condition|(
name|xdiff
operator|||
name|ydiff
condition|)
block|{
name|GList
modifier|*
name|all
decl_stmt|;
for|for
control|(
name|all
operator|=
name|gfig_context
operator|->
name|current_obj
operator|->
name|obj_list
init|;
name|all
condition|;
name|all
operator|=
name|all
operator|->
name|next
control|)
block|{
name|GfigObject
modifier|*
name|obj
init|=
name|all
operator|->
name|data
decl_stmt|;
name|update_pnts
argument_list|(
name|obj
argument_list|,
name|xdiff
argument_list|,
name|ydiff
argument_list|)
expr_stmt|;
block|}
operator|*
name|move_all_pnt
operator|=
operator|*
name|to_pnt
expr_stmt|;
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|do_save_obj (GfigObject * obj,GString * string)
name|do_save_obj
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|GString
modifier|*
name|string
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
for|for
control|(
name|spnt
operator|=
name|obj
operator|->
name|points
init|;
name|spnt
condition|;
name|spnt
operator|=
name|spnt
operator|->
name|next
control|)
block|{
name|g_string_append_printf
argument_list|(
name|string
argument_list|,
literal|"%d %d\n"
argument_list|,
name|spnt
operator|->
name|pnt
operator|.
name|x
argument_list|,
name|spnt
operator|->
name|pnt
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_move_obj (GfigObject * obj,GdkPoint * to_pnt)
name|do_move_obj
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
comment|/* Move the whole line - undraw the line to start with */
comment|/* Then draw in new pos */
name|gint
name|xdiff
init|=
literal|0
decl_stmt|;
name|gint
name|ydiff
init|=
literal|0
decl_stmt|;
name|get_diffs
argument_list|(
name|obj
argument_list|,
operator|&
name|xdiff
argument_list|,
operator|&
name|ydiff
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdiff
operator|||
name|ydiff
condition|)
block|{
name|update_pnts
argument_list|(
name|obj
argument_list|,
name|xdiff
argument_list|,
name|ydiff
argument_list|)
expr_stmt|;
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_move_obj_pnt (GfigObject * obj,GdkPoint * to_pnt)
name|do_move_obj_pnt
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|GdkPoint
modifier|*
name|to_pnt
parameter_list|)
block|{
comment|/* Move the whole line - undraw the line to start with */
comment|/* Then draw in new pos */
name|DobjPoints
modifier|*
name|spnt
decl_stmt|;
name|gint
name|xdiff
init|=
literal|0
decl_stmt|;
name|gint
name|ydiff
init|=
literal|0
decl_stmt|;
name|spnt
operator|=
name|get_diffs
argument_list|(
name|obj
argument_list|,
operator|&
name|xdiff
argument_list|,
operator|&
name|ydiff
argument_list|,
name|to_pnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|xdiff
operator|&&
operator|!
name|ydiff
operator|)
operator|||
operator|!
name|spnt
condition|)
return|return;
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|x
operator|-
name|xdiff
expr_stmt|;
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|=
name|spnt
operator|->
name|pnt
operator|.
name|y
operator|-
name|ydiff
expr_stmt|;
comment|/* Draw in new pos */
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy objs */
end_comment

begin_function
name|GList
modifier|*
DECL|function|copy_all_objs (GList * objs)
name|copy_all_objs
parameter_list|(
name|GList
modifier|*
name|objs
parameter_list|)
block|{
name|GList
modifier|*
name|new_all_objs
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|objs
condition|)
block|{
name|GfigObject
modifier|*
name|object
init|=
name|objs
operator|->
name|data
decl_stmt|;
name|GfigObject
modifier|*
name|new_object
init|=
operator|(
name|GfigObject
operator|*
operator|)
name|object
operator|->
name|class
operator|->
name|copyfunc
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|gfig_style_copy
argument_list|(
operator|&
name|new_object
operator|->
name|style
argument_list|,
operator|&
name|object
operator|->
name|style
argument_list|,
literal|"Object"
argument_list|)
expr_stmt|;
name|new_all_objs
operator|=
name|g_list_prepend
argument_list|(
name|new_all_objs
argument_list|,
name|new_object
argument_list|)
expr_stmt|;
name|objs
operator|=
name|objs
operator|->
name|next
expr_stmt|;
block|}
name|new_all_objs
operator|=
name|g_list_reverse
argument_list|(
name|new_all_objs
argument_list|)
expr_stmt|;
return|return
name|new_all_objs
return|;
block|}
end_function

begin_comment
comment|/* Screen refresh */
end_comment

begin_function
specifier|static
name|void
DECL|function|draw_one_obj (GfigObject * obj,cairo_t * cr)
name|draw_one_obj
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|)
block|{
name|obj
operator|->
name|class
operator|->
name|drawfunc
argument_list|(
name|obj
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|draw_objects (GList * objs,gboolean show_single,cairo_t * cr)
name|draw_objects
parameter_list|(
name|GList
modifier|*
name|objs
parameter_list|,
name|gboolean
name|show_single
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|)
block|{
comment|/* Show_single - only one object to draw Unless shift    * is down in which case show all.    */
name|gint
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|objs
condition|)
block|{
if|if
condition|(
operator|!
name|show_single
operator|||
name|count
operator|==
name|obj_show_single
operator|||
name|obj_show_single
operator|==
operator|-
literal|1
condition|)
name|draw_one_obj
argument_list|(
name|objs
operator|->
name|data
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|objs
operator|=
name|g_list_next
argument_list|(
name|objs
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|prepend_to_all_obj (GFigObj * fobj,GList * nobj)
name|prepend_to_all_obj
parameter_list|(
name|GFigObj
modifier|*
name|fobj
parameter_list|,
name|GList
modifier|*
name|nobj
parameter_list|)
block|{
name|setup_undo
argument_list|()
expr_stmt|;
comment|/* Remember ME */
name|fobj
operator|->
name|obj_list
operator|=
name|g_list_concat
argument_list|(
name|fobj
operator|->
name|obj_list
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|scale_obj_points (DobjPoints * opnt,gdouble scale_x,gdouble scale_y)
name|scale_obj_points
parameter_list|(
name|DobjPoints
modifier|*
name|opnt
parameter_list|,
name|gdouble
name|scale_x
parameter_list|,
name|gdouble
name|scale_y
parameter_list|)
block|{
while|while
condition|(
name|opnt
condition|)
block|{
name|opnt
operator|->
name|pnt
operator|.
name|x
operator|=
call|(
name|gint
call|)
argument_list|(
name|opnt
operator|->
name|pnt
operator|.
name|x
operator|*
name|scale_x
argument_list|)
expr_stmt|;
name|opnt
operator|->
name|pnt
operator|.
name|y
operator|=
call|(
name|gint
call|)
argument_list|(
name|opnt
operator|->
name|pnt
operator|.
name|y
operator|*
name|scale_y
argument_list|)
expr_stmt|;
name|opnt
operator|=
name|opnt
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|add_to_all_obj (GFigObj * fobj,GfigObject * obj)
name|add_to_all_obj
parameter_list|(
name|GFigObj
modifier|*
name|fobj
parameter_list|,
name|GfigObject
modifier|*
name|obj
parameter_list|)
block|{
name|GList
modifier|*
name|nobj
init|=
name|NULL
decl_stmt|;
name|nobj
operator|=
name|g_list_append
argument_list|(
name|nobj
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_to_scale
condition|)
name|scale_obj_points
argument_list|(
name|obj
operator|->
name|points
argument_list|,
name|scale_x_factor
argument_list|,
name|scale_y_factor
argument_list|)
expr_stmt|;
name|prepend_to_all_obj
argument_list|(
name|fobj
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
comment|/* initialize style when we add the object */
name|gfig_context
operator|->
name|selected_obj
operator|=
name|obj
expr_stmt|;
block|}
end_function

begin_comment
comment|/* First button press -- start drawing object */
end_comment

begin_comment
comment|/*  * object_start() creates a new object of the type specified in the  * button panel.  It is activated by a button press, and causes  * a small square to be drawn at the initial point.  The style of  * the new object is set to values taken from the style control  * widgets.  */
end_comment

begin_function
name|void
DECL|function|object_start (GdkPoint * pnt,gboolean shift_down)
name|object_start
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gboolean
name|shift_down
parameter_list|)
block|{
comment|/* start for the current object */
if|if
condition|(
operator|!
name|selvals
operator|.
name|scaletoimage
condition|)
block|{
name|need_to_scale
operator|=
literal|1
expr_stmt|;
name|selvals
operator|.
name|scaletoimage
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|need_to_scale
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|LINE
case|:
comment|/* Shift means we are still drawing */
name|d_line_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECTANGLE
case|:
name|d_rectangle_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIRCLE
case|:
name|d_circle_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELLIPSE
case|:
name|d_ellipse_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|POLY
case|:
name|d_poly_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARC
case|:
name|d_arc_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|d_star_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPIRAL
case|:
name|d_spiral_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER
case|:
name|d_bezier_start
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
break|break;
block|}
if|if
condition|(
name|obj_creating
condition|)
block|{
if|if
condition|(
name|gfig_context
operator|->
name|debug_styles
condition|)
name|g_printerr
argument_list|(
literal|"Creating object, setting style from context\n"
argument_list|)
expr_stmt|;
name|gfig_style_set_style_from_context
argument_list|(
operator|&
name|obj_creating
operator|->
name|style
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|object_end (GdkPoint * pnt,gboolean shift_down)
name|object_end
parameter_list|(
name|GdkPoint
modifier|*
name|pnt
parameter_list|,
name|gboolean
name|shift_down
parameter_list|)
block|{
comment|/* end for the current object */
comment|/* Add onto global object list */
comment|/* If shift is down may carry on drawing */
switch|switch
condition|(
name|selvals
operator|.
name|otype
condition|)
block|{
case|case
name|LINE
case|:
name|d_line_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECTANGLE
case|:
name|d_rectangle_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIRCLE
case|:
name|d_circle_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELLIPSE
case|:
name|d_ellipse_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|POLY
case|:
name|d_poly_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|d_star_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARC
case|:
name|d_arc_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPIRAL
case|:
name|d_spiral_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEZIER
case|:
name|d_bezier_end
argument_list|(
name|pnt
argument_list|,
name|shift_down
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Internal error */
break|break;
block|}
if|if
condition|(
name|need_to_scale
condition|)
block|{
name|need_to_scale
operator|=
literal|0
expr_stmt|;
name|selvals
operator|.
name|scaletoimage
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stuff for the generation/deletion of objects. */
end_comment

begin_comment
comment|/* Objects are easy one they are created - you just go down the object  * list calling the draw function for each object but... when they  * are been created we have to be a little more careful. When  * the first point is placed on the canvas we create the object,  * the mouse position then defines the next point that can move around.  * careful how we draw this position.  */
end_comment

begin_function
name|void
DECL|function|free_one_obj (GfigObject * obj)
name|free_one_obj
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|)
block|{
name|d_delete_dobjpoints
argument_list|(
name|obj
operator|->
name|points
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|free_all_objs (GList * objs)
name|free_all_objs
parameter_list|(
name|GList
modifier|*
name|objs
parameter_list|)
block|{
name|g_list_free_full
argument_list|(
name|objs
argument_list|,
operator|(
name|GDestroyNotify
operator|)
name|free_one_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|get_line (gchar * buf,gint s,FILE * from,gint init)
name|get_line
parameter_list|(
name|gchar
modifier|*
name|buf
parameter_list|,
name|gint
name|s
parameter_list|,
name|FILE
modifier|*
name|from
parameter_list|,
name|gint
name|init
parameter_list|)
block|{
name|gint
name|slen
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|init
condition|)
name|line_no
operator|=
literal|1
expr_stmt|;
else|else
name|line_no
operator|++
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ferror
argument_list|(
name|from
argument_list|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
do|;
name|slen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* The last newline is a pain */
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
name|buf
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check and remove an '\r' too from Windows */
if|if
condition|(
operator|(
name|slen
operator|>
literal|1
operator|)
operator|&&
operator|(
name|buf
index|[
name|slen
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|)
condition|)
name|buf
index|[
name|slen
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
name|_
argument_list|(
literal|"Error reading file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Processing line '%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
DECL|function|clear_undo (void)
name|clear_undo
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|lv
decl_stmt|;
for|for
control|(
name|lv
operator|=
name|undo_level
init|;
name|lv
operator|>=
literal|0
condition|;
name|lv
operator|--
control|)
block|{
name|free_all_objs
argument_list|(
name|undo_table
index|[
name|lv
index|]
argument_list|)
expr_stmt|;
name|undo_table
index|[
name|lv
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|undo_level
operator|=
operator|-
literal|1
expr_stmt|;
name|gfig_dialog_action_set_sensitive
argument_list|(
literal|"undo"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|setup_undo (void)
name|setup_undo
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copy object list to undo buffer */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"setup undo level [%d]\n"
argument_list|,
name|undo_level
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUG*/
if|if
condition|(
operator|!
name|gfig_context
operator|->
name|current_obj
condition|)
block|{
comment|/* If no current_obj must be loading -> no undo */
return|return;
block|}
if|if
condition|(
name|undo_level
operator|>=
name|selvals
operator|.
name|maxundo
operator|-
literal|1
condition|)
block|{
name|int
name|loop
decl_stmt|;
comment|/* the little one in the bed said "roll over".. */
if|if
condition|(
name|undo_table
index|[
literal|0
index|]
condition|)
name|free_one_obj
argument_list|(
name|undo_table
index|[
literal|0
index|]
operator|->
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|undo_level
condition|;
name|loop
operator|++
control|)
block|{
name|undo_table
index|[
name|loop
index|]
operator|=
name|undo_table
index|[
name|loop
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|undo_level
operator|++
expr_stmt|;
block|}
name|undo_table
index|[
name|undo_level
index|]
operator|=
name|copy_all_objs
argument_list|(
name|gfig_context
operator|->
name|current_obj
operator|->
name|obj_list
argument_list|)
expr_stmt|;
name|gfig_dialog_action_set_sensitive
argument_list|(
literal|"undo"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gfig_context
operator|->
name|current_obj
operator|->
name|obj_status
operator||=
name|GFIG_MODIFIED
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|new_obj_2edit (GFigObj * obj)
name|new_obj_2edit
parameter_list|(
name|GFigObj
modifier|*
name|obj
parameter_list|)
block|{
name|GFigObj
modifier|*
name|old_current
init|=
name|gfig_context
operator|->
name|current_obj
decl_stmt|;
comment|/* Clear undo levels */
comment|/* redraw the preview */
comment|/* Set up options as define in the selected object */
name|clear_undo
argument_list|()
expr_stmt|;
comment|/* Point at this one */
name|gfig_context
operator|->
name|current_obj
operator|=
name|obj
expr_stmt|;
comment|/* Show all objects to start with */
name|obj_show_single
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Change options */
name|options_update
argument_list|(
name|old_current
argument_list|)
expr_stmt|;
comment|/* redraw with new */
name|gtk_widget_queue_draw
argument_list|(
name|gfig_context
operator|->
name|preview
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|obj_status
operator|&
name|GFIG_READONLY
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Editing read-only object - "
literal|"you will not be able to save it"
argument_list|)
argument_list|)
expr_stmt|;
name|gfig_dialog_action_set_sensitive
argument_list|(
literal|"save"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gfig_dialog_action_set_sensitive
argument_list|(
literal|"save"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a point to a line (given x, y)  * pos = 0 = head  * pos = -1 = tail  * 0< pos = nth position  */
end_comment

begin_function
name|void
DECL|function|d_pnt_add_line (GfigObject * obj,gint x,gint y,gint pos)
name|d_pnt_add_line
parameter_list|(
name|GfigObject
modifier|*
name|obj
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|gint
name|pos
parameter_list|)
block|{
name|DobjPoints
modifier|*
name|npnts
init|=
name|new_dobjpoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|g_assert
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
block|{
comment|/* Add to head */
name|npnts
operator|->
name|next
operator|=
name|obj
operator|->
name|points
expr_stmt|;
name|obj
operator|->
name|points
operator|=
name|npnts
expr_stmt|;
block|}
else|else
block|{
name|DobjPoints
modifier|*
name|pnt
init|=
name|obj
operator|->
name|points
decl_stmt|;
comment|/* Go down chain until the end if pos */
while|while
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pnt
operator|->
name|next
operator|)
operator|||
operator|!
name|pos
condition|)
block|{
name|npnts
operator|->
name|next
operator|=
name|pnt
operator|->
name|next
expr_stmt|;
name|pnt
operator|->
name|next
operator|=
name|npnts
expr_stmt|;
break|break;
block|}
else|else
block|{
name|pnt
operator|=
name|pnt
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

