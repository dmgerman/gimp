begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* refguts.c, 1/2/98 - this file contains the icky stuff.  * refract: a plug-in for the GIMP 0.99  * By Kevin Turner<kevint@poboxes.com>  * http://www.poboxes.com/kevint/gimp/refract.html  */
end_comment

begin_comment
comment|/*  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  */
end_comment

begin_comment
comment|/* Refresher course in optics:    Incident ray is the light ray hitting the surface.    Angles are measured from the perpendicular to the surface.    Angle of reflection is equal to angle of incidence.    Angle of refraction is determined by     Snell's law: index[a] * sin(a) = index[b] * sin(b)     If second index is smaller than first, light is bent toward normal.    Otherwise, away.    */
end_comment

begin_include
include|#
directive|include
file|"refract.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_typedef
DECL|struct|__anon29c3a7610108
typedef|typedef
struct|struct
block|{
comment|/* Quartic's pixelfetcher thing */
DECL|member|col
DECL|member|row
name|gint
name|col
decl_stmt|,
name|row
decl_stmt|;
DECL|member|img_width
DECL|member|img_height
DECL|member|img_bpp
DECL|member|img_has_alpha
name|gint
name|img_width
decl_stmt|,
name|img_height
decl_stmt|,
name|img_bpp
decl_stmt|,
name|img_has_alpha
decl_stmt|;
DECL|member|tile_width
DECL|member|tile_height
name|gint
name|tile_width
decl_stmt|,
name|tile_height
decl_stmt|;
DECL|member|bg_color
name|guchar
name|bg_color
index|[
literal|4
index|]
decl_stmt|;
DECL|member|drawable
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
DECL|member|tile
name|GTile
modifier|*
name|tile
decl_stmt|;
DECL|typedef|pixel_fetcher_t
block|}
name|pixel_fetcher_t
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|RefractValues
name|refractvals
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|go_refract
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_refract
parameter_list|(
name|GPixelRgn
modifier|*
name|dest_rgn
parameter_list|,
name|GPixelRgn
modifier|*
name|lens_rgn
parameter_list|,
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|delta
parameter_list|(
name|gdouble
modifier|*
name|offset
parameter_list|,
name|gdouble
name|slope
parameter_list|,
name|gint
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_SLOPE_MACROS
end_ifndef

begin_function_decl
specifier|static
name|gdouble
name|slope
parameter_list|(
name|gint
name|h
parameter_list|,
comment|/* FIXME: I should probably be inlined. */
name|HEIGHT_TYPE
name|p1
parameter_list|,
name|HEIGHT_TYPE
name|p2
parameter_list|,
name|HEIGHT_TYPE
name|p3
parameter_list|,
name|HEIGHT_TYPE
name|p4
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* More pixelfetcher things */
end_comment

begin_function_decl
specifier|static
name|pixel_fetcher_t
modifier|*
name|pixel_fetcher_new
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pixel_fetcher_set_bg_color
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|guchar
name|r
parameter_list|,
name|guchar
name|g
parameter_list|,
name|guchar
name|b
parameter_list|,
name|guchar
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pixel_fetcher_get_pixel
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|guchar
modifier|*
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pixel_fetcher_destroy
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This bilinear interpolation function also borrowed. */
end_comment

begin_function_decl
specifier|static
name|guchar
name|bilinear_new
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|guchar
name|v
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|guint8
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|sel_x1
DECL|variable|sel_x2
DECL|variable|sel_y1
DECL|variable|sel_y2
specifier|static
name|gint
name|sel_x1
init|=
operator|-
literal|1
decl_stmt|,
name|sel_x2
init|=
operator|-
literal|1
decl_stmt|,
name|sel_y1
init|=
operator|-
literal|1
decl_stmt|,
name|sel_y2
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sel_w
DECL|variable|sel_h
specifier|static
name|gint
name|sel_w
decl_stmt|,
name|sel_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|fg_color
specifier|static
name|guchar
name|fg_color
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
DECL|function|go_refract (GDrawable * drawable,gint32 image_id)
name|go_refract
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
comment|/* For Initialize pixel fetcher. */
name|pixel_fetcher_t
modifier|*
name|pf
decl_stmt|;
name|guchar
name|bg_color
index|[
literal|4
index|]
decl_stmt|;
comment|/* For Initialize lens region. */
name|GDrawable
modifier|*
name|lensmap
decl_stmt|;
name|GPixelRgn
name|lens_rgn
decl_stmt|;
name|gint
name|lxoff
decl_stmt|,
name|lyoff
decl_stmt|;
if|#
directive|if
literal|0
block|gint use_x1,use_x2,use_y1,use_y2, use_w, use_h;
endif|#
directive|endif
comment|/* For Initialize dest region. */
name|GPixelRgn
name|dest_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|output_drawable
decl_stmt|;
name|gint32
name|new_layer_id
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/*****************************/
comment|/* Initialize pixel fetcher. */
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
operator|->
name|id
argument_list|,
operator|&
name|sel_x1
argument_list|,
operator|&
name|sel_y1
argument_list|,
operator|&
name|sel_x2
argument_list|,
operator|&
name|sel_y2
argument_list|)
expr_stmt|;
name|sel_w
operator|=
name|sel_x2
operator|-
name|sel_x1
expr_stmt|;
name|sel_h
operator|=
name|sel_y2
operator|-
name|sel_y1
expr_stmt|;
name|pf
operator|=
name|pixel_fetcher_new
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_palette_get_background
argument_list|(
operator|&
name|bg_color
index|[
literal|0
index|]
argument_list|,
operator|&
name|bg_color
index|[
literal|1
index|]
argument_list|,
operator|&
name|bg_color
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_set_bg_color
argument_list|(
name|pf
argument_list|,
name|bg_color
index|[
literal|0
index|]
argument_list|,
name|bg_color
index|[
literal|1
index|]
argument_list|,
name|bg_color
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/***************************/
comment|/* Initialize lens region: */
name|lensmap
operator|=
name|gimp_drawable_get
argument_list|(
name|refractvals
operator|.
name|lens_id
argument_list|)
expr_stmt|;
comment|/* Fortunately, this isn't really run repeatedly, so it's OK if         it's not all that compact, right? */
ifdef|#
directive|ifdef
name|__PSYCHIC_COMPILER__
comment|/* If your compiler can read my mind better than I can. */
comment|/* Crap.  We need a smegging lens-wrap toggle. */
if|if
condition|(
name|lens
name|wrap
condition|)
block|{
if|if
condition|(
name|no
name|lens
name|offsets
condition|)
block|{
comment|/* no problems. */
name|lens_rgn
operator|=
name|foo
argument_list|(
name|sel_x1
argument_list|,
name|sel_x2
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|)
expr_stmt|;
comment|/* To conserve resources, we might want to change that 	     to take less if the lens stops before the image 	     does. */
block|}
else|else
block|{
comment|/* offsets.  Uhoh. */
if|if
condition|(
name|lens_size
operator|>=
name|drawable_size
condition|)
block|{
comment|/* Do this for each dimension. */
comment|/* Oh, it'll be okay.  We'll just add offset and take absmod. */
if|if
condition|(
name|split
condition|)
block|{
name|lens_rgn
operator|=
name|wholething
expr_stmt|;
comment|/* Oh well, we'll take the whole thing. */
block|}
else|else
block|{
comment|/* not split */
name|lens_rgn
operator|=
name|foo
argument_list|(
name|sel_x1
operator|-
name|xoff
argument_list|,
name|sel_y1
operator|-
name|yoff
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|)
expr_stmt|;
block|}
comment|/* endif not split */
block|}
else|else
block|{
comment|/* lens is smaller */
if|if
condition|(
name|split
condition|)
block|{
name|g_warning
argument_list|(
literal|"refract: refguts.c: Go to hell.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lens_rgn
operator|=
name|foo
argument_list|(
name|sel_x1
operator|-
name|xoff
argument_list|,
name|sel_y1
operator|-
name|yoff
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* lens is smaller */
block|}
comment|/* endif offsets */
block|}
else|else
block|{
comment|/* no lens wrap */
comment|/* If there's no lens wrapping, I have no problem.  It's yo 	     own dang fault if your lens doesn't land on your drawable 	     any more. */
comment|/* Let's rub it in... */
if|if
condition|(
operator|(
operator|(
name|xoff
operator|>
literal|0
operator|)
condition|?
operator|(
name|xoff
operator|>=
name|sel_w
operator|)
else|:
operator|(
operator|-
name|xoff
operator|<=
name|lens_w
operator|)
operator|)
operator|||
operator|(
operator|(
name|yoff
operator|>
literal|0
operator|)
condition|?
operator|(
name|yoff
operator|>=
name|sel_h
operator|)
else|:
operator|(
operator|-
name|yoff
operator|<=
name|lens_h
operator|)
operator|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"refract: refguts.c: loose nut detected between chair and keyboard.\n"
argument_list|)
expr_stmt|;
name|g_error
argument_list|(
literal|"refract: refguts.c: Offsets move lens off image.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lens_rgn
operator|=
name|foo
argument_list|(
name|sel_x1
operator|-
name|xoff
argument_list|,
name|sel_y1
operator|-
name|yoff
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|)
expr_stmt|;
comment|/* To conserve resources, we might want to change that 		  to take less if the lens stops before the image 		  does. */
block|}
block|}
comment|/* endif no lens wrap */
else|#
directive|else
comment|/* Compiler requires actual code. */
name|gimp_drawable_offsets
argument_list|(
name|lensmap
operator|->
name|id
argument_list|,
operator|&
name|lxoff
argument_list|,
operator|&
name|lyoff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
name|g_print
argument_list|(
literal|"x: %d\ty: %d\tw: %d\th: %d\n"
argument_list|,
name|lxoff
argument_list|,
name|lyoff
argument_list|,
name|lensmap
operator|->
name|width
argument_list|,
name|lensmap
operator|->
name|height
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REFRACT_DEBUG */
if|#
directive|if
literal|0
comment|/* If we *didn't* wrap the lens... */
block|if( (sel_x1> (lxoff + lensmap->width)) ||  	 (lxoff> sel_x2) || 	 (sel_y1> (lyoff + lensmap->height)) || 	 (lyoff> sel_y2)) { 	  g_error("refract:refguts.c:Selection and lens don't overlap.  You lose.\n");      } else { 	  use_x1=MAX(sel_x1,lxoff); 	  use_x2=MIN(sel_x2,lxoff + lensmap->width); 	  use_y1=MAX(sel_y1,lyoff); 	  use_y2=MIN(sel_y2,lyoff + lensmap->height); 	  use_w=use_x2-use_x1; 	  use_h=use_y2-use_y1;      }
endif|#
directive|endif
comment|/* if we didn't wrap lenses */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lensmap
argument_list|,
name|lxoff
argument_list|,
name|lyoff
argument_list|,
name|lensmap
operator|->
name|width
argument_list|,
name|lensmap
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compiler requires actual code. */
comment|/**********************************/
comment|/* Initialize destination region: */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Refracted %s"
argument_list|,
name|gimp_drawable_name
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|refractvals
operator|.
name|newl
condition|)
block|{
comment|/* New layer?  Yes... */
name|new_layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|image_id
argument_list|,
name|buf
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|,
name|gimp_drawable_gray
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
condition|?
name|GRAYA_IMAGE
else|:
name|RGBA_IMAGE
argument_list|,
literal|100.0
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
comment|/* For layer position (currently 0), how would I say  	     "one above current layer"? */
name|gimp_image_add_layer
argument_list|(
name|image_id
argument_list|,
name|new_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_set_offsets
argument_list|(
name|new_layer_id
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|)
expr_stmt|;
name|output_drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|new_layer_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* New layer No. */
name|output_drawable
operator|=
name|drawable
expr_stmt|;
block|}
comment|/* New layer No. */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|output_drawable
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
name|g_print
argument_list|(
literal|"drawable-id: %d\toutput-id: %d:\tlens_rgn-id: %d\n"
argument_list|,
name|drawable
operator|->
name|id
argument_list|,
name|output_drawable
operator|->
name|id
argument_list|,
name|lens_rgn
operator|.
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/********/
comment|/* Misc */
name|gimp_palette_get_foreground
argument_list|(
operator|&
name|fg_color
index|[
literal|0
index|]
argument_list|,
operator|&
name|fg_color
index|[
literal|1
index|]
argument_list|,
operator|&
name|fg_color
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fg_color
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
comment|/**********/
comment|/* Do it! */
name|do_refract
argument_list|(
operator|&
name|dest_rgn
argument_list|,
operator|&
name|lens_rgn
argument_list|,
name|pf
argument_list|)
expr_stmt|;
comment|/*************/
comment|/* Clean up. */
comment|/* FIXME: If we are cancelled, make sure there's none of that         unsightly new layer residue. */
name|pixel_fetcher_destroy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* I hope this works... */
name|gimp_drawable_flush
argument_list|(
name|output_drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|output_drawable
operator|->
name|id
argument_list|,
operator|!
name|refractvals
operator|.
name|newl
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|output_drawable
operator|->
name|id
argument_list|,
name|sel_x1
argument_list|,
name|sel_y1
argument_list|,
name|sel_w
argument_list|,
name|sel_h
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable
operator|!=
name|output_drawable
condition|)
name|gimp_drawable_detach
argument_list|(
name|output_drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|lensmap
argument_list|)
expr_stmt|;
comment|/* return (refractvals.newl ? new_layer_id : NULL); */
block|}
end_function

begin_comment
comment|/* go_refract */
end_comment

begin_define
DECL|macro|ABSMOD (A,B)
define|#
directive|define
name|ABSMOD
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|( ((A)< 0) ? (((B) + (A)) % (B)) : ((A) % (B)) )
end_define

begin_define
DECL|macro|X (F)
define|#
directive|define
name|X
parameter_list|(
name|F
parameter_list|)
value|( ABSMOD((F)+refractvals.xofs,lens_rgn->w) )
end_define

begin_define
DECL|macro|Y (F)
define|#
directive|define
name|Y
parameter_list|(
name|F
parameter_list|)
value|( ABSMOD((F)+refractvals.yofs,lens_rgn->h) )
end_define

begin_define
DECL|macro|ROWM2
define|#
directive|define
name|ROWM2
value|(lm_rowm2[ X(x) * lens_rgn->bpp ])
end_define

begin_define
DECL|macro|ROWM1
define|#
directive|define
name|ROWM1
value|(lm_rowm1[ X(x) * lens_rgn->bpp ])
end_define

begin_define
DECL|macro|ROW0 (F)
define|#
directive|define
name|ROW0
parameter_list|(
name|F
parameter_list|)
value|(lm_row0[ X(x+(F)) * lens_rgn->bpp ])
end_define

begin_define
DECL|macro|ROWP1
define|#
directive|define
name|ROWP1
value|(lm_rowp1[ X(x) * lens_rgn->bpp ])
end_define

begin_define
DECL|macro|ROWP2
define|#
directive|define
name|ROWP2
value|(lm_rowp2[ X(x) * lens_rgn->bpp ])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OLD_SLOPE_MACROS
end_ifdef

begin_define
DECL|macro|SLOPE_X
define|#
directive|define
name|SLOPE_X
value|((gdouble) 1.0 / (12 * h) * ( ROW0(-2*h) - 8 * ROW0(-1*h) + 8 * ROW0(1*h) - ROW0(2*h) ) * depths )
end_define

begin_define
DECL|macro|SLOPE_Y
define|#
directive|define
name|SLOPE_Y
value|((gdouble) 1.0 / (12 * h) * ( ROWM2    - 8 * ROWM1    + 8 * ROWP1   - ROWP2   ) * depths )
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Macros calling the slope function. Functionally equivillant. */
end_comment

begin_define
DECL|macro|SLOPE_X
define|#
directive|define
name|SLOPE_X
value|(slope(h,ROW0(-2*h), ROW0(-1*h), ROW0(1*h), ROW0(2*h)))
end_define

begin_define
DECL|macro|SLOPE_Y
define|#
directive|define
name|SLOPE_Y
value|(slope(h,ROWM2,    ROWM1,    ROWP1,   ROWP2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD_SLOPE_MACROS */
end_comment

begin_function
specifier|static
name|void
DECL|function|do_refract (GPixelRgn * dest_rgn,GPixelRgn * lens_rgn,pixel_fetcher_t * pf)
name|do_refract
parameter_list|(
name|GPixelRgn
modifier|*
name|dest_rgn
parameter_list|,
name|GPixelRgn
modifier|*
name|lens_rgn
parameter_list|,
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|)
block|{
name|HEIGHT_TYPE
modifier|*
name|lm_rowm2
decl_stmt|,
modifier|*
name|lm_rowm1
decl_stmt|,
modifier|*
name|lm_row0
decl_stmt|,
modifier|*
name|lm_rowp1
decl_stmt|,
modifier|*
name|lm_rowp2
decl_stmt|;
name|HEIGHT_TYPE
modifier|*
name|lm_rowfoo
decl_stmt|;
name|guchar
name|pixel
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|guint8
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint8
name|diff_bpp
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|dest_row
decl_stmt|;
name|gdouble
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|gdouble
name|depths
init|=
operator|(
name|gdouble
operator|)
name|refractvals
operator|.
name|thick
operator|/
operator|(
name|gdouble
operator|)
literal|256.0
decl_stmt|;
comment|/* Depth scalar */
specifier|const
name|gint
name|h
init|=
literal|1
decl_stmt|;
comment|/* The delta value for the slope interpolation equation. */
comment|/* FIXME: Give option of changing h?  */
comment|/* See if dest_rgn and pf have different bpp */
name|diff_bpp
operator|=
name|dest_rgn
operator|->
name|bpp
operator|-
name|pf
operator|->
name|img_bpp
expr_stmt|;
comment|/***************/
comment|/* Allocations */
name|lm_rowm2
operator|=
name|g_malloc
argument_list|(
name|lens_rgn
operator|->
name|w
operator|*
name|lens_rgn
operator|->
name|bpp
operator|*
sizeof|sizeof
argument_list|(
name|HEIGHT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowm1
operator|=
name|g_malloc
argument_list|(
name|lens_rgn
operator|->
name|w
operator|*
name|lens_rgn
operator|->
name|bpp
operator|*
sizeof|sizeof
argument_list|(
name|HEIGHT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lm_row0
operator|=
name|g_malloc
argument_list|(
name|lens_rgn
operator|->
name|w
operator|*
name|lens_rgn
operator|->
name|bpp
operator|*
sizeof|sizeof
argument_list|(
name|HEIGHT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowp1
operator|=
name|g_malloc
argument_list|(
name|lens_rgn
operator|->
name|w
operator|*
name|lens_rgn
operator|->
name|bpp
operator|*
sizeof|sizeof
argument_list|(
name|HEIGHT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowp2
operator|=
name|g_malloc
argument_list|(
name|lens_rgn
operator|->
name|w
operator|*
name|lens_rgn
operator|->
name|bpp
operator|*
sizeof|sizeof
argument_list|(
name|HEIGHT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|dest_row
operator|=
name|g_malloc
argument_list|(
name|dest_rgn
operator|->
name|w
operator|*
name|dest_rgn
operator|->
name|bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
comment|/************************/
comment|/* Grab some lens rows. */
name|gimp_pixel_rgn_get_row
argument_list|(
name|lens_rgn
argument_list|,
name|lm_rowm2
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|sel_y1
operator|-
literal|2
operator|*
name|h
argument_list|)
argument_list|,
name|lens_rgn
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
name|lens_rgn
argument_list|,
name|lm_rowm1
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|sel_y1
operator|-
literal|1
operator|*
name|h
argument_list|)
argument_list|,
name|lens_rgn
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
name|lens_rgn
argument_list|,
name|lm_row0
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|sel_y1
argument_list|)
argument_list|,
name|lens_rgn
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
name|lens_rgn
argument_list|,
name|lm_rowp1
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|sel_y1
operator|+
literal|1
operator|*
name|h
argument_list|)
argument_list|,
name|lens_rgn
operator|->
name|w
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
name|lens_rgn
argument_list|,
name|lm_rowp2
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|sel_y1
operator|+
literal|2
operator|*
name|h
argument_list|)
argument_list|,
name|lens_rgn
operator|->
name|w
argument_list|)
expr_stmt|;
comment|/***********************/
comment|/* Let's begin work... */
for|for
control|(
name|y
operator|=
name|sel_y1
init|;
name|y
operator|<
name|sel_y2
condition|;
name|y
operator|++
control|)
block|{
name|gimp_pixel_rgn_get_row
argument_list|(
name|dest_rgn
argument_list|,
name|dest_row
argument_list|,
name|sel_x1
argument_list|,
name|y
argument_list|,
name|sel_w
argument_list|)
expr_stmt|;
name|dest
operator|=
name|dest_row
expr_stmt|;
for|for
control|(
name|x
operator|=
name|sel_x1
init|;
name|x
operator|<
name|sel_x2
condition|;
name|x
operator|++
control|)
block|{
comment|/* If offsets in both X and Y direction exist... */
comment|/* (meaning no internal refraction) */
if|if
condition|(
name|delta
argument_list|(
operator|&
name|dx
argument_list|,
name|SLOPE_X
argument_list|,
name|ROW0
argument_list|(
literal|0
argument_list|)
operator|*
name|depths
argument_list|)
operator|&&
name|delta
argument_list|(
operator|&
name|dy
argument_list|,
name|SLOPE_Y
argument_list|,
name|ROW0
argument_list|(
literal|0
argument_list|)
operator|*
name|depths
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|refractvals
operator|.
name|edge
condition|)
block|{
case|case
name|WRAP
case|:
name|xf
operator|=
name|ABSMOD
argument_list|(
name|x
operator|+
operator|(
name|gint
operator|)
name|dx
argument_list|,
name|dest_rgn
operator|->
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
name|yf
operator|=
name|ABSMOD
argument_list|(
name|y
operator|+
operator|(
name|gint
operator|)
name|dy
argument_list|,
name|dest_rgn
operator|->
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKGROUND
case|:
case|case
name|OUTSIDE
case|:
name|xf
operator|=
name|x
operator|+
operator|(
name|gint
operator|)
name|dx
expr_stmt|;
name|yf
operator|=
name|y
operator|+
operator|(
name|gint
operator|)
name|dy
expr_stmt|;
break|break;
default|default:
name|g_error
argument_list|(
literal|"refract: refract.c: Unanticipated value for edge in do_refract\n"
argument_list|)
expr_stmt|;
block|}
comment|/* switch refractvals.edge */
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
argument_list|,
name|yf
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
operator|+
literal|1
argument_list|,
name|yf
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
argument_list|,
name|yf
operator|+
literal|1
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
operator|+
literal|1
argument_list|,
name|yf
operator|+
literal|1
argument_list|,
name|pixel
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|img_bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
name|bilinear_new
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|pixel
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* next i */
comment|/* If dest_rgn has more bpp than pf's source, 		       then fill in the rest with 255's...  This helps 		       when making a new layer from a non-alpha layer. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|diff_bpp
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|255
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if a delta() call returns false. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dest_rgn
operator|->
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
name|fg_color
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* next i */
block|}
comment|/* endif delta() */
block|}
comment|/* next x */
name|gimp_pixel_rgn_set_row
argument_list|(
name|dest_rgn
argument_list|,
name|dest_row
argument_list|,
name|sel_x1
argument_list|,
name|y
argument_list|,
name|sel_w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|y
operator|%
name|PROGRESS_ROWS
operator|)
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y
operator|-
name|sel_y1
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|sel_y2
operator|-
name|sel_y1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move lensmap pointers */
name|lm_rowfoo
operator|=
name|lm_rowm2
expr_stmt|;
name|lm_rowm2
operator|=
name|lm_rowm1
expr_stmt|;
name|lm_rowm1
operator|=
name|lm_row0
expr_stmt|;
name|lm_row0
operator|=
name|lm_rowp1
expr_stmt|;
name|lm_rowp1
operator|=
name|lm_rowp2
expr_stmt|;
name|lm_rowp2
operator|=
name|lm_rowfoo
expr_stmt|;
comment|/* get new lensmap row */
name|gimp_pixel_rgn_get_row
argument_list|(
name|lens_rgn
argument_list|,
name|lm_rowp2
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|y
operator|+
literal|3
operator|*
name|h
argument_list|)
argument_list|,
name|lens_rgn
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
comment|/* next y */
block|}
end_function

begin_comment
comment|/* do_refract */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_SLOPE_MACROS
end_ifndef

begin_function
specifier|static
name|gdouble
comment|/* FIXME: I should probably be inlined. */
DECL|function|slope (gint h,HEIGHT_TYPE p1,HEIGHT_TYPE p2,HEIGHT_TYPE p3,HEIGHT_TYPE p4)
name|slope
parameter_list|(
name|gint
name|h
parameter_list|,
name|HEIGHT_TYPE
name|p1
parameter_list|,
name|HEIGHT_TYPE
name|p2
parameter_list|,
name|HEIGHT_TYPE
name|p3
parameter_list|,
name|HEIGHT_TYPE
name|p4
parameter_list|)
block|{
comment|/* p1 = f(x-2h), p2 = f(x-1h), p3 = f(x+1h), p4=f(x+2h) */
return|return
literal|1.0
operator|/
operator|(
literal|12
operator|*
name|h
operator|)
operator|*
operator|(
name|p1
operator|-
literal|8
operator|*
name|p2
operator|+
literal|8
operator|*
name|p3
operator|-
name|p4
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD_SLOPE_MACROS */
end_comment

begin_function
specifier|static
name|gint
DECL|function|delta (gdouble * offset,gdouble slope,gint height)
name|delta
parameter_list|(
name|gdouble
modifier|*
name|offset
parameter_list|,
name|gdouble
name|slope
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gdouble
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
name|alpha
operator|=
name|atan
argument_list|(
name|slope
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha
operator|>
name|asin
argument_list|(
name|refractvals
operator|.
name|nb
operator|/
name|refractvals
operator|.
name|na
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
comment|/* Total Internal Refraction.  Aiee! */
block|}
name|beta
operator|=
name|asin
argument_list|(
name|refractvals
operator|.
name|na
operator|*
name|sin
argument_list|(
name|alpha
argument_list|)
operator|/
name|refractvals
operator|.
name|nb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
operator|-
operator|(
name|refractvals
operator|.
name|refr_dist
operator|+
name|height
operator|)
operator|*
name|tan
argument_list|(
name|beta
operator|-
name|alpha
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A "borrowed" bilinear interpolation function, modified to select from a     two dimensional array instead of a linear one. */
end_comment

begin_function
specifier|static
name|guchar
DECL|function|bilinear_new (double x,double y,guchar values[4][4],guint8 i)
name|bilinear_new
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|guchar
name|values
index|[
literal|4
index|]
index|[
literal|4
index|]
parameter_list|,
name|guint8
name|i
parameter_list|)
block|{
name|double
name|m0
decl_stmt|,
name|m1
decl_stmt|;
name|x
operator|=
name|fmod
argument_list|(
name|x
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|y
operator|=
name|fmod
argument_list|(
name|y
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0.0
condition|)
name|x
operator|+=
literal|1.0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0.0
condition|)
name|y
operator|+=
literal|1.0
expr_stmt|;
name|m0
operator|=
operator|(
name|double
operator|)
name|values
index|[
literal|0
index|]
index|[
name|i
index|]
operator|+
name|x
operator|*
operator|(
operator|(
name|double
operator|)
name|values
index|[
literal|1
index|]
index|[
name|i
index|]
operator|-
name|values
index|[
literal|0
index|]
index|[
name|i
index|]
operator|)
expr_stmt|;
name|m1
operator|=
operator|(
name|double
operator|)
name|values
index|[
literal|2
index|]
index|[
name|i
index|]
operator|+
name|x
operator|*
operator|(
operator|(
name|double
operator|)
name|values
index|[
literal|3
index|]
index|[
name|i
index|]
operator|-
name|values
index|[
literal|2
index|]
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
call|(
name|guchar
call|)
argument_list|(
name|m0
operator|+
name|y
operator|*
operator|(
name|m1
operator|-
name|m0
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* bilinear_new */
end_comment

begin_comment
comment|/************************************************************************  *  *   Fun pixel fetching stuff...  Quartic's code from whirlpinch.c  *   Uses the globals sel_x1,sel_x2,sel_y1,sel_y2.  */
end_comment

begin_function
specifier|static
name|pixel_fetcher_t
modifier|*
DECL|function|pixel_fetcher_new (GDrawable * drawable)
name|pixel_fetcher_new
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|pixel_fetcher_t
modifier|*
name|pf
decl_stmt|;
name|pf
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pixel_fetcher_t
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|col
operator|=
operator|-
literal|1
expr_stmt|;
name|pf
operator|->
name|row
operator|=
operator|-
literal|1
expr_stmt|;
name|pf
operator|->
name|img_width
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|pf
operator|->
name|img_height
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|pf
operator|->
name|img_bpp
operator|=
name|drawable
operator|->
name|bpp
expr_stmt|;
name|pf
operator|->
name|img_has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tile_width
operator|=
name|gimp_tile_width
argument_list|()
expr_stmt|;
name|pf
operator|->
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|drawable
operator|=
name|drawable
expr_stmt|;
name|pf
operator|->
name|tile
operator|=
name|NULL
expr_stmt|;
return|return
name|pf
return|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_new */
end_comment

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|pixel_fetcher_set_bg_color (pixel_fetcher_t * pf,guchar r,guchar g,guchar b,guchar a)
name|pixel_fetcher_set_bg_color
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|guchar
name|r
parameter_list|,
name|guchar
name|g
parameter_list|,
name|guchar
name|b
parameter_list|,
name|guchar
name|a
parameter_list|)
block|{
name|pf
operator|->
name|bg_color
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|img_has_alpha
condition|)
name|pf
operator|->
name|bg_color
index|[
name|pf
operator|->
name|img_bpp
operator|-
literal|1
index|]
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_set_bg_color */
end_comment

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|pixel_fetcher_get_pixel (pixel_fetcher_t * pf,int x,int y,guchar * pixel)
name|pixel_fetcher_get_pixel
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|guchar
modifier|*
name|pixel
parameter_list|)
block|{
name|gint
name|col
decl_stmt|,
name|row
decl_stmt|;
name|gint
name|coloff
decl_stmt|,
name|rowoff
decl_stmt|;
name|guchar
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|<
name|sel_x1
operator|)
operator|||
operator|(
name|x
operator|>=
name|sel_x2
operator|)
operator|||
operator|(
name|y
operator|<
name|sel_y1
operator|)
operator|||
operator|(
name|y
operator|>=
name|sel_y2
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|img_bpp
condition|;
name|i
operator|++
control|)
name|pixel
index|[
name|i
index|]
operator|=
name|pf
operator|->
name|bg_color
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
comment|/* if */
name|col
operator|=
name|x
operator|/
name|pf
operator|->
name|tile_width
expr_stmt|;
name|coloff
operator|=
name|x
operator|%
name|pf
operator|->
name|tile_width
expr_stmt|;
name|row
operator|=
name|y
operator|/
name|pf
operator|->
name|tile_height
expr_stmt|;
name|rowoff
operator|=
name|y
operator|%
name|pf
operator|->
name|tile_height
expr_stmt|;
if|if
condition|(
operator|(
name|col
operator|!=
name|pf
operator|->
name|col
operator|)
operator|||
operator|(
name|row
operator|!=
name|pf
operator|->
name|row
operator|)
operator|||
operator|(
name|pf
operator|->
name|tile
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|pf
operator|->
name|tile
operator|!=
name|NULL
condition|)
name|gimp_tile_unref
argument_list|(
name|pf
operator|->
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tile
operator|=
name|gimp_drawable_get_tile
argument_list|(
name|pf
operator|->
name|drawable
argument_list|,
name|FALSE
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|gimp_tile_ref
argument_list|(
name|pf
operator|->
name|tile
argument_list|)
expr_stmt|;
name|pf
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|pf
operator|->
name|row
operator|=
name|row
expr_stmt|;
block|}
comment|/* if */
name|p
operator|=
name|pf
operator|->
name|tile
operator|->
name|data
operator|+
name|pf
operator|->
name|img_bpp
operator|*
operator|(
name|pf
operator|->
name|tile
operator|->
name|ewidth
operator|*
name|rowoff
operator|+
name|coloff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pf
operator|->
name|img_bpp
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|*
name|pixel
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_get_pixel */
end_comment

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|pixel_fetcher_destroy (pixel_fetcher_t * pf)
name|pixel_fetcher_destroy
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|)
block|{
if|if
condition|(
name|pf
operator|->
name|tile
operator|!=
name|NULL
condition|)
name|gimp_tile_unref
argument_list|(
name|pf
operator|->
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_destroy */
end_comment

end_unit

