begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* refract.c, version 0.1.1-alpha, 23 October 1997   * A plug-in for the GIMP 0.99.  * Uses a height field as a lens of specified refraction index.  *  * by Kevin Turner<kevint@poboxes.com>  * http://www.poboxes.com/kevint/gimp/refract.html  *  * Check that web page for a more complete description of what the  * plug-in does and does _not_ do. */
end_comment

begin_comment
comment|/* I require megawidgets to compile!  A copy was probably compiled in    the plug-ins directory of your GIMP source distribution, it will    work nicely.  Just move me or it somewhere I can see it...  */
end_comment

begin_comment
comment|/* THIS IS AN ALPHA RELEASE.     The code is ugly, and the plug-in is NOT full featured and I know I    still have work left to do before it is.  Hopefully I'll have much    done by the end of October (well, that's what I thought)...  But I    thought I'd go with "release early, release often" in case anyone    cares to improve an alogrythm (or my spelling) or something...     But it's fun enough that I thought I'd let people play with it...      So enjoy, and keep on hackin'.  */
end_comment

begin_comment
comment|/*  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  */
end_comment

begin_comment
comment|/* I'm not a very expirenced C programmer, so questions, comments, and  * reservations on code and style are more than welcome.  This plug-in  * was developed on Linux and I will be the first to admit that I'm  * rather inexpirenced (okay, ignorant) with other operating systems.  * If I do wrong, educate me.  */
end_comment

begin_comment
comment|/* Pixel fetcher routines are from Quartic's whirlpinch plug-in.    Thanks, Quartic[1]! */
end_comment

begin_comment
comment|/* 1: Quartic, AKA Federico Mena-Quintero    federico@nuclecu.unam.mx    http://www.nuclecu.unam.mx/~federico */
end_comment

begin_comment
comment|/* TO DO:  * UI:  *   megawidgets are insufficient.  (No way to integrate entry_scale  *   with tooltips or option_menu). Replace them.  * necessities:  *   Make the "new layer" option work correctly.  * necessary luxuries:  *   Make offsets work.  Add radio buttons for wrapping options.  * excess luxuries:  *   Variable IOR information in some [alpha?] channel.  * for version 1.1:  *   THIS PLUGIN NEEDS A PREVIEW THING!  *   Reflections  * for version> 1.1:  *   Diffraction or whatever that thing that makes rainbows is called.  *   Lighting */
end_comment

begin_comment
comment|/* Refresher course in optics:    Incident ray is the light ray hitting the surface.    Angles are measured from the perpendicular to the surface.    Angle of reflection is equal to angle of incidence.    Angle of refraction is determined by     Snell's law: index[a] * sin(a) = index[b] * sin(b)     If second index is smaller than first, light is bent toward normal.    Otherwise, away.    */
end_comment

begin_comment
comment|/* Comment out the #define REFRACT_DEBUG for distribution releases, or  * if you get unwanted diagnostic noise from refract on stdout or  * stderr... */
end_comment

begin_define
DECL|macro|REFRACT_DEBUG
define|#
directive|define
name|REFRACT_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* It's not clear to me if this needs be here or no... */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_include
include|#
directive|include
file|"../megawidget/megawidget.h"
end_include

begin_comment
comment|/* For entry/scale pairs. */
end_comment

begin_comment
comment|/* PONDER: How does libgck compare to megawidget? */
end_comment

begin_comment
comment|/* I need radio buttons and drop-down menus too... */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REFRACT_DEBUG
end_ifndef

begin_define
DECL|macro|REFRACT_TITLE
define|#
directive|define
name|REFRACT_TITLE
value|"Refract 12/24/97-Alpha"
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|REFRACT_TITLE
define|#
directive|define
name|REFRACT_TITLE
value|"Refract 12/24/97 (debug)"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Update the progress bar every this-many rows...  */
end_comment

begin_define
DECL|macro|PROGRESS_ROWS
define|#
directive|define
name|PROGRESS_ROWS
value|8
end_define

begin_typedef
DECL|struct|__anon2bfa712a0108
typedef|typedef
struct|struct
block|{
DECL|member|lensmap
name|gint32
name|lensmap
decl_stmt|;
comment|/* lens map id */
DECL|member|depth
name|gint32
name|depth
decl_stmt|;
comment|/* lens depth */
DECL|member|dist
name|gint32
name|dist
decl_stmt|;
comment|/* distance */
DECL|member|na
name|gdouble
name|na
decl_stmt|;
comment|/* index a */
DECL|member|nb
name|gdouble
name|nb
decl_stmt|;
comment|/* index b */
DECL|member|wrap
name|gint
name|wrap
decl_stmt|;
comment|/* wrap/transparent */
DECL|member|newl
name|gint
name|newl
decl_stmt|;
comment|/* new layer? */
DECL|member|xofs
name|gint
name|xofs
decl_stmt|;
comment|/* offset x */
DECL|member|yofs
name|gint
name|yofs
decl_stmt|;
comment|/* offset y */
DECL|typedef|RefractValues
block|}
name|RefractValues
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2bfa712a0208
typedef|typedef
struct|struct
block|{
DECL|member|x
name|gint
name|x
decl_stmt|;
DECL|member|y
name|gint
name|y
decl_stmt|;
DECL|typedef|EksWhy
block|}
name|EksWhy
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2bfa712a0308
typedef|typedef
struct|struct
block|{
DECL|member|run
name|gint
name|run
decl_stmt|;
DECL|typedef|RefractInterface
block|}
name|RefractInterface
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2bfa712a0408
typedef|typedef
struct|struct
block|{
comment|/* Quartic's pixelfetcher thing */
DECL|member|col
DECL|member|row
name|gint
name|col
decl_stmt|,
name|row
decl_stmt|;
DECL|member|img_width
DECL|member|img_height
DECL|member|img_bpp
DECL|member|img_has_alpha
name|gint
name|img_width
decl_stmt|,
name|img_height
decl_stmt|,
name|img_bpp
decl_stmt|,
name|img_has_alpha
decl_stmt|;
DECL|member|tile_width
DECL|member|tile_height
name|gint
name|tile_width
decl_stmt|,
name|tile_height
decl_stmt|;
DECL|member|bg_color
name|guchar
name|bg_color
index|[
literal|4
index|]
decl_stmt|;
DECL|member|drawable
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
DECL|member|tile
name|GTile
modifier|*
name|tile
decl_stmt|;
DECL|typedef|pixel_fetcher_t
block|}
name|pixel_fetcher_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|refract
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|,
name|gint32
name|image_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|delta
parameter_list|(
name|gdouble
modifier|*
name|offset
parameter_list|,
name|gdouble
name|slope
parameter_list|,
name|gint
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|refract_dialog
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|map_constrain
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|drawable_id
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newl_toggle_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tooltips_toggle_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|refract_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|refract_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|map_menu_callback
parameter_list|(
name|gint32
name|id
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GtkWidget
modifier|*
name|ior_menu_new
parameter_list|(
name|GtkWidget
modifier|*
name|tieto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ior_menu_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* More pixelfetcher things */
end_comment

begin_function_decl
specifier|static
name|pixel_fetcher_t
modifier|*
name|pixel_fetcher_new
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pixel_fetcher_set_bg_color
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|guchar
name|r
parameter_list|,
name|guchar
name|g
parameter_list|,
name|guchar
name|b
parameter_list|,
name|guchar
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pixel_fetcher_get_pixel
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|guchar
modifier|*
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pixel_fetcher_destroy
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This bilinear interpolation function also borrowed. */
end_comment

begin_function_decl
specifier|static
name|guchar
name|bilinear
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|guchar
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|refractvals
specifier|static
name|RefractValues
name|refractvals
init|=
block|{
operator|-
literal|1
block|,
comment|/* Lens map ID */
literal|32
block|,
comment|/* lens depth */
literal|0
block|,
comment|/* distance */
literal|1.0003
block|,
comment|/* index a */
literal|1.333
block|,
comment|/* index b */
literal|1
block|,
comment|/* 0 = wrap, 1 = transparent */
name|FALSE
block|,
comment|/* new layer? */
literal|0
block|,
comment|/* offset x */
literal|0
block|,
comment|/* offset y */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|refractint
specifier|static
name|RefractInterface
name|refractint
init|=
block|{
name|FALSE
comment|/* run */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sel_x1
DECL|variable|sel_x2
DECL|variable|sel_y1
DECL|variable|sel_y2
name|gint
name|sel_x1
init|=
operator|-
literal|1
decl_stmt|,
name|sel_x2
init|=
operator|-
literal|1
decl_stmt|,
name|sel_y1
init|=
operator|-
literal|1
decl_stmt|,
name|sel_y2
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pixel_fetcher uses these as globals and I'm too lazy to make it do otherwise. */
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Input drawable"
block|}
block|,
comment|/* If we did have parameters, these be them: */
block|{
name|PARAM_DRAWABLE
block|,
literal|"lensmap"
block|,
literal|"Lens map drawable"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"depth"
block|,
literal|"Lens depth"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"dist"
block|,
literal|"Lens distance from image"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"na"
block|,
literal|"Index of Refraction A"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"nb"
block|,
literal|"Index of Refraction B"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"wrap"
block|,
literal|"Wrap (0), Background (1)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"newl"
block|,
literal|"New layer?"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"xofs"
block|,
literal|"X offset"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"yofs"
block|,
literal|"Y offset"
block|}
block|}
decl_stmt|;
specifier|static
name|GParamDef
modifier|*
name|return_vals
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|nargs
init|=
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nreturn_vals
init|=
literal|0
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_refract"
argument_list|,
literal|"Uses a height field as a lens."
argument_list|,
literal|"Distorts the image by refracting it through a height field 'lens' with a specified index of refraction."
argument_list|,
literal|"Kevin Turner<kevint@poboxes.com>"
argument_list|,
literal|"Kevin Turner"
argument_list|,
literal|"1997"
argument_list|,
literal|"<Image>/Filters/Distorts/Refract&Reflect..."
argument_list|,
literal|"RGB*, GRAY*, INDEXED*"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nargs
argument_list|,
name|nreturn_vals
argument_list|,
name|args
argument_list|,
name|return_vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* query */
end_comment

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparams,GParam * param,gint * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
name|printf
argument_list|(
literal|"refract: pid %d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
comment|/* Possibly retrieve data */
name|gimp_get_data
argument_list|(
literal|"plug_in_refract"
argument_list|,
operator|&
name|refractvals
argument_list|)
expr_stmt|;
comment|/* Acquire info with a dialog */
if|if
condition|(
operator|!
name|refract_dialog
argument_list|()
condition|)
block|{
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
name|refractvals
operator|.
name|lensmap
operator|=
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_drawable
expr_stmt|;
name|refractvals
operator|.
name|depth
operator|=
name|param
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|refractvals
operator|.
name|dist
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|refractvals
operator|.
name|na
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|refractvals
operator|.
name|nb
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|refractvals
operator|.
name|wrap
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|refractvals
operator|.
name|newl
operator|=
name|param
index|[
literal|9
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|refractvals
operator|.
name|xofs
operator|=
name|param
index|[
literal|10
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|refractvals
operator|.
name|yofs
operator|=
name|param
index|[
literal|11
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
comment|/* if */
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
comment|/* Possibly retrieve data */
name|gimp_get_data
argument_list|(
literal|"plug_in_refract"
argument_list|,
operator|&
name|refractvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* switch run_mode */
if|if
condition|(
name|gimp_drawable_color
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
operator|||
name|gimp_drawable_gray
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
condition|)
block|{
name|gimp_progress_init
argument_list|(
literal|"Doing optics homework..."
argument_list|)
expr_stmt|;
comment|/* What's this do? */
name|gimp_tile_cache_ntiles
argument_list|(
literal|2
operator|*
operator|(
name|drawable
operator|->
name|width
operator|+
name|gimp_tile_width
argument_list|()
operator|-
literal|1
operator|)
operator|/
name|gimp_tile_width
argument_list|()
argument_list|)
expr_stmt|;
name|refract
argument_list|(
name|drawable
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|!=
name|RUN_NONINTERACTIVE
condition|)
name|gimp_displays_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
comment|/*|| run_mode == RUN_WITH_LAST_VALS*/
condition|)
name|gimp_set_data
argument_list|(
literal|"plug_in_refract"
argument_list|,
operator|&
name|refractvals
argument_list|,
sizeof|sizeof
argument_list|(
name|RefractValues
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* run */
end_comment

begin_function
specifier|static
name|void
DECL|function|refract (GDrawable * drawable,gint32 image_id)
name|refract
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|GPixelRgn
name|src_rgn
decl_stmt|,
name|dest_rgn
decl_stmt|;
name|GPixelRgn
name|lens_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|output_drawable
decl_stmt|;
name|gint32
name|new_layer_id
decl_stmt|;
name|guchar
modifier|*
name|lm_rowm2
decl_stmt|,
modifier|*
name|lm_rowm1
decl_stmt|,
modifier|*
name|lm_row0
decl_stmt|;
name|guchar
modifier|*
name|lm_rowp1
decl_stmt|,
modifier|*
name|lm_rowp2
decl_stmt|,
modifier|*
name|lm_rowfoo
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|dest_row
decl_stmt|;
name|GDrawable
modifier|*
name|lensmap
decl_stmt|;
name|gint
name|lm_width
decl_stmt|,
name|lm_row_width
decl_stmt|,
name|lm_height
decl_stmt|;
comment|/* Lensmap stuff */
name|gint
name|lm_bpp
decl_stmt|,
name|lm_has_alpha
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
comment|/* Bounds of the selection */
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|;
name|gdouble
name|depths
decl_stmt|;
comment|/* Depth scalar */
name|gdouble
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|gint
name|xf
decl_stmt|,
name|yf
decl_stmt|;
specifier|const
name|gint
name|h
init|=
literal|1
decl_stmt|;
comment|/* The delta value for the slope interpolation equation. */
comment|/* FIXME: Give option of changing h for large maps?  */
name|gint
name|img_width
decl_stmt|,
name|img_height
decl_stmt|,
name|img_has_alpha
decl_stmt|,
name|img_bpp
decl_stmt|;
name|pixel_fetcher_t
modifier|*
name|pf
decl_stmt|;
name|guchar
name|bg_color
index|[
literal|4
index|]
decl_stmt|,
name|fg_color
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|pixel
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|,
name|values
index|[
literal|4
index|]
decl_stmt|;
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
operator|->
name|id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
name|sel_x1
operator|=
name|x1
operator|,
name|sel_y1
operator|=
name|y1
operator|,
name|sel_x2
operator|=
name|x2
operator|,
name|sel_y2
operator|=
name|y2
expr_stmt|;
comment|/* Source region: */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|img_width
operator|=
name|gimp_drawable_width
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|img_height
operator|=
name|gimp_drawable_height
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Destination region: */
if|if
condition|(
name|refractvals
operator|.
name|newl
condition|)
block|{
comment|/* FIXME(somewhere): New layer doesn't work right! */
comment|/* FIXME: Make new layer no bigger than the selection. */
name|new_layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|image_id
argument_list|,
literal|"Refracted"
argument_list|,
name|img_width
argument_list|,
name|img_height
argument_list|,
name|RGBA_IMAGE
argument_list|,
comment|/* Should this ever be RGB_IMAGE? */
literal|100.0
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
comment|/* or could be GRAY */
name|gimp_image_add_layer
argument_list|(
name|image_id
argument_list|,
name|new_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|new_layer_id
argument_list|)
expr_stmt|;
block|}
else|else
name|output_drawable
operator|=
name|drawable
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|output_drawable
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Set up pixel fetcher...  */
name|pf
operator|=
name|pixel_fetcher_new
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_palette_get_background
argument_list|(
operator|&
name|bg_color
index|[
literal|0
index|]
argument_list|,
operator|&
name|bg_color
index|[
literal|1
index|]
argument_list|,
operator|&
name|bg_color
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gimp_palette_get_foreground
argument_list|(
operator|&
name|fg_color
index|[
literal|0
index|]
argument_list|,
operator|&
name|fg_color
index|[
literal|1
index|]
argument_list|,
operator|&
name|fg_color
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fg_color
index|[
literal|3
index|]
operator|=
literal|255
expr_stmt|;
comment|/* Which needs drawable and which needs output_drawable         is somewhat confused.  */
name|img_has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|output_drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|img_bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|output_drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|pixel_fetcher_set_bg_color
argument_list|(
name|pf
argument_list|,
name|bg_color
index|[
literal|0
index|]
argument_list|,
name|bg_color
index|[
literal|1
index|]
argument_list|,
name|bg_color
index|[
literal|2
index|]
argument_list|,
operator|(
name|img_has_alpha
condition|?
literal|0
else|:
literal|255
operator|)
argument_list|)
expr_stmt|;
comment|/* Get the lens map... */
name|lensmap
operator|=
name|gimp_drawable_get
argument_list|(
name|refractvals
operator|.
name|lensmap
argument_list|)
expr_stmt|;
name|lm_width
operator|=
name|gimp_drawable_width
argument_list|(
name|refractvals
operator|.
name|lensmap
argument_list|)
expr_stmt|;
name|lm_height
operator|=
name|gimp_drawable_height
argument_list|(
name|refractvals
operator|.
name|lensmap
argument_list|)
expr_stmt|;
name|lm_bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|refractvals
operator|.
name|lensmap
argument_list|)
expr_stmt|;
name|lm_has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|refractvals
operator|.
name|lensmap
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lensmap
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|lm_width
argument_list|,
name|lm_height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dest_row
operator|=
name|g_malloc
argument_list|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
name|img_bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|>=
name|lm_width
condition|)
block|{
comment|/* If we need the entire lens map... */
name|lm_row_width
operator|=
name|lm_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refractvals
operator|.
name|xofs
operator|==
literal|0
condition|)
block|{
comment|/* Image is smaller than lens map, and doesn't */
comment|/* require wrapping over the edge... */
name|lm_row_width
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME */
name|g_warning
argument_list|(
literal|"refract: X offset breaks oversized lensmaps.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* lm_rows could (should?) be handled by array, but isn't. */
comment|/* FIXME: Increase robustness for lensmaps with rather small heights. */
comment|/* FIXME: X offset not used.        That'll take a bit of tweaking...  */
if|if
condition|(
name|lm_row_width
operator|>
literal|0
condition|)
block|{
name|lm_rowm2
operator|=
name|g_malloc
argument_list|(
name|lm_row_width
operator|*
name|lm_bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowm1
operator|=
name|g_malloc
argument_list|(
name|lm_row_width
operator|*
name|lm_bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
name|lm_row0
operator|=
name|g_malloc
argument_list|(
name|lm_row_width
operator|*
name|lm_bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowp1
operator|=
name|g_malloc
argument_list|(
name|lm_row_width
operator|*
name|lm_bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowp2
operator|=
name|g_malloc
argument_list|(
name|lm_row_width
operator|*
name|lm_bpp
operator|*
sizeof|sizeof
argument_list|(
name|guchar
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: Provide an alternative to wrapping         for the top and bottom of the lens map... */
DECL|macro|ABSMOD (A,B)
define|#
directive|define
name|ABSMOD
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|( ((A)< 0) ? (B) + (A) % (B) : (A) % (B) )
DECL|macro|Y (O)
define|#
directive|define
name|Y
parameter_list|(
name|O
parameter_list|)
value|( ABSMOD((O)+refractvals.yofs,lm_height) )
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lm_rowm2
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|y1
operator|-
literal|2
argument_list|)
argument_list|,
name|lm_row_width
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lm_rowm1
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|y1
operator|-
literal|1
argument_list|)
argument_list|,
name|lm_row_width
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lm_row0
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|y1
argument_list|)
argument_list|,
name|lm_row_width
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lm_rowp1
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|y1
operator|+
literal|1
argument_list|)
argument_list|,
name|lm_row_width
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lm_rowp2
argument_list|,
literal|0
argument_list|,
name|Y
argument_list|(
name|y1
operator|+
literal|2
argument_list|)
argument_list|,
name|lm_row_width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME */
name|g_warning
argument_list|(
literal|"refract: Row buffers not initalized.\n"
argument_list|)
expr_stmt|;
block|}
name|depths
operator|=
operator|(
name|gdouble
operator|)
name|refractvals
operator|.
name|depth
operator|/
operator|(
name|gdouble
operator|)
literal|256.0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<
name|y2
condition|;
name|y
operator|++
control|)
block|{
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|dest_row
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|dest_row
expr_stmt|;
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<
name|x2
condition|;
name|x
operator|++
control|)
block|{
comment|/* So on a scale of 1 to 100, how far below zero does this                rank for coding style?  */
comment|/* FIXME: This may not produce the desired behaviour with  	       lm_row_width< lm_width and xofs != 0 */
DECL|macro|X (O)
define|#
directive|define
name|X
parameter_list|(
name|O
parameter_list|)
value|( ABSMOD((O)+refractvals.xofs,lm_row_width) )
DECL|macro|ROWM2
define|#
directive|define
name|ROWM2
value|(lm_rowm2[ X(x) * lm_bpp ])
DECL|macro|ROWM1
define|#
directive|define
name|ROWM1
value|(lm_rowm1[ X(x) * lm_bpp ])
DECL|macro|ROW0 (O)
define|#
directive|define
name|ROW0
parameter_list|(
name|O
parameter_list|)
value|(lm_row0[ X(x+0) * lm_bpp ])
DECL|macro|ROWP1
define|#
directive|define
name|ROWP1
value|(lm_rowp1[ X(x) * lm_bpp ])
DECL|macro|ROWP2
define|#
directive|define
name|ROWP2
value|(lm_rowp2[ X(x) * lm_bpp ])
DECL|macro|SLOPE_X
define|#
directive|define
name|SLOPE_X
value|((gdouble) 1.0 / (12 * h) * ( ROW0(-2) - 8 * ROW0(-1) + 8 * ROW0(1) - ROW0(2) ) * depths )
DECL|macro|SLOPE_Y
define|#
directive|define
name|SLOPE_Y
value|((gdouble) 1.0 / (12 * h) * ( ROWM2    - 8 * ROWM1    + 8 * ROWP1   - ROWP2   ) * depths )
if|if
condition|(
name|delta
argument_list|(
operator|&
name|dx
argument_list|,
name|SLOPE_X
argument_list|,
name|ROW0
argument_list|(
literal|0
argument_list|)
operator|*
name|depths
argument_list|)
operator|&&
name|delta
argument_list|(
operator|&
name|dy
argument_list|,
name|SLOPE_Y
argument_list|,
name|ROW0
argument_list|(
literal|0
argument_list|)
operator|*
name|depths
argument_list|)
condition|)
block|{
if|if
condition|(
name|refractvals
operator|.
name|wrap
condition|)
block|{
name|xf
operator|=
name|ABSMOD
argument_list|(
name|x
operator|+
operator|(
name|gint
operator|)
name|dx
argument_list|,
name|img_width
argument_list|)
expr_stmt|;
name|yf
operator|=
name|ABSMOD
argument_list|(
name|y
operator|+
operator|(
name|gint
operator|)
name|dy
argument_list|,
name|img_height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xf
operator|=
name|x
operator|+
operator|(
name|gint
operator|)
name|dx
expr_stmt|;
name|yf
operator|=
name|y
operator|+
operator|(
name|gint
operator|)
name|dy
expr_stmt|;
block|}
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
argument_list|,
name|yf
argument_list|,
name|pixel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
operator|+
literal|1
argument_list|,
name|yf
argument_list|,
name|pixel
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
argument_list|,
name|yf
operator|+
literal|1
argument_list|,
name|pixel
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|pixel_fetcher_get_pixel
argument_list|(
name|pf
argument_list|,
name|xf
operator|+
literal|1
argument_list|,
name|yf
operator|+
literal|1
argument_list|,
name|pixel
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|img_bpp
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
literal|0
index|]
operator|=
name|pixel
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|pixel
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|pixel
index|[
literal|2
index|]
index|[
name|i
index|]
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|pixel
index|[
literal|3
index|]
index|[
name|i
index|]
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|bilinear
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
comment|/* for */
block|}
else|else
block|{
comment|/* if a delta() call returns FALSE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|img_bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
name|fg_color
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* for */
block|}
comment|/* if */
block|}
comment|/* next x */
name|gimp_pixel_rgn_set_row
argument_list|(
operator|&
name|dest_rgn
argument_list|,
name|dest_row
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|)
expr_stmt|;
comment|/* On the theory that a % takes less time than an update, 	   we only need them done occasionally... */
if|if
condition|(
operator|!
operator|(
name|y
operator|%
name|PROGRESS_ROWS
operator|)
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y
operator|-
name|y1
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|lm_rowfoo
operator|=
name|lm_rowm2
expr_stmt|;
name|lm_rowm2
operator|=
name|lm_rowm1
expr_stmt|;
name|lm_rowm1
operator|=
name|lm_row0
expr_stmt|;
name|lm_row0
operator|=
name|lm_rowp1
expr_stmt|;
name|lm_rowp1
operator|=
name|lm_rowp2
expr_stmt|;
name|lm_rowp2
operator|=
name|lm_rowfoo
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|lens_rgn
argument_list|,
name|lm_rowp2
argument_list|,
name|x1
argument_list|,
name|Y
argument_list|(
name|y
operator|+
literal|3
argument_list|)
argument_list|,
name|lm_row_width
argument_list|)
expr_stmt|;
block|}
comment|/* next y */
comment|/* Cleanup */
comment|/* FIXME: Make *certain* that anything we created (e.g. new layers) is cleaned        up when plug-in is cancelled! */
name|pixel_fetcher_destroy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest_row
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lm_rowm2
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lm_rowm1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lm_row0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lm_rowp1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lm_rowp2
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|output_drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_merge_shadow
argument_list|(
name|output_drawable
operator|->
name|id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gimp_drawable_update
argument_list|(
name|output_drawable
operator|->
name|id
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|x2
operator|-
name|x1
operator|)
argument_list|,
operator|(
name|y2
operator|-
name|y1
operator|)
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|output_drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|refractvals
operator|.
name|newl
condition|)
block|{
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* refract */
end_comment

begin_function
specifier|static
name|gint
DECL|function|delta (gdouble * offset,gdouble slope,gint height)
name|delta
parameter_list|(
name|gdouble
modifier|*
name|offset
parameter_list|,
name|gdouble
name|slope
parameter_list|,
name|gint
name|height
parameter_list|)
block|{
name|gdouble
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
name|alpha
operator|=
name|atan
argument_list|(
name|slope
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha
operator|>
name|asin
argument_list|(
name|refractvals
operator|.
name|nb
operator|/
name|refractvals
operator|.
name|na
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
name|puts
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
comment|/* Total Internal Refraction.  Aiee! */
block|}
name|beta
operator|=
name|asin
argument_list|(
name|refractvals
operator|.
name|na
operator|*
name|sin
argument_list|(
name|alpha
argument_list|)
operator|/
name|refractvals
operator|.
name|nb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
operator|-
operator|(
name|refractvals
operator|.
name|dist
operator|+
name|height
operator|)
operator|*
name|tan
argument_list|(
name|beta
operator|-
name|alpha
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Realistically, this number should be 1.0.  An index of refraction    of less than 1 means the speed of light in that substance is    *faster* than in a vacuum!  But hey, it's GIMP, when was the last    time we payed any attention to reality?  Go ahead...  Add    "subspace" to the list of materials... */
end_comment

begin_define
DECL|macro|INDEX_SCALE_MIN
define|#
directive|define
name|INDEX_SCALE_MIN
value|0.0
end_define

begin_function
specifier|static
name|gint
DECL|function|refract_dialog ()
name|refract_dialog
parameter_list|()
block|{
name|gint
name|argc
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|GtkTooltips
modifier|*
name|tooltips
decl_stmt|;
name|GtkWidget
modifier|*
name|menu
decl_stmt|,
modifier|*
name|option_menu
decl_stmt|,
modifier|*
name|ior_a_menu
decl_stmt|,
modifier|*
name|ior_b_menu
decl_stmt|;
name|GtkWidget
modifier|*
name|ok_button
decl_stmt|,
modifier|*
name|cancel_button
decl_stmt|;
name|GtkWidget
modifier|*
name|layercheck
decl_stmt|,
modifier|*
name|toolcheck
decl_stmt|;
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
if|#
directive|if
literal|0
block|printf("refract: waiting... (pid %d)\n", getpid());     kill(getpid(), SIGSTOP);
endif|#
directive|endif
endif|#
directive|endif
comment|/* Standard GTK startup sequence */
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"refract"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gdk_set_use_xshm
argument_list|(
name|gimp_use_xshm
argument_list|()
argument_list|)
expr_stmt|;
comment|/* FIXME: Can we use the GIMP colormap when in 8-bit to reduce flashing? */
comment|/* end standard GTK startup */
comment|/* I guess we need a window... */
name|dlg
operator|=
name|gtk_dialog_new
argument_list|()
expr_stmt|;
name|gtk_window_set_title
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
name|REFRACT_TITLE
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|refract_close_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tooltips
operator|=
name|gtk_tooltips_new
argument_list|()
expr_stmt|;
comment|/* Action area: */
comment|/* OK */
name|ok_button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|ok_button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|ok_button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|refract_ok_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
name|gtk_widget_grab_default
argument_list|(
name|ok_button
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|ok_button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|ok_button
argument_list|)
expr_stmt|;
comment|/* Cancel */
name|cancel_button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|cancel_button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect_object
argument_list|(
name|GTK_OBJECT
argument_list|(
name|cancel_button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|refract_close_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|cancel_button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|cancel_button
argument_list|)
expr_stmt|;
comment|/* Paramater settings: */
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|7
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* FIXME: add preview box */
comment|/* drop box for lens map */
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Lens map"
argument_list|)
expr_stmt|;
name|option_menu
operator|=
name|gtk_option_menu_new
argument_list|()
expr_stmt|;
name|menu
operator|=
name|gimp_drawable_menu_new
argument_list|(
name|map_constrain
argument_list|,
name|map_menu_callback
argument_list|,
name|NULL
argument_list|,
name|refractvals
operator|.
name|lensmap
argument_list|)
expr_stmt|;
name|gtk_option_menu_set_menu
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|option_menu
argument_list|)
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|gtk_tooltips_set_tips
argument_list|(
name|tooltips
argument_list|,
name|option_menu
argument_list|,
literal|"The drawable to use as the lens."
argument_list|)
expr_stmt|;
name|gtk_table_attach_defaults
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_table_attach_defaults
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|option_menu
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|option_menu
argument_list|)
expr_stmt|;
comment|/* TODO? Add "Invert lens map"  Not anytime soon...  */
comment|/* Would require adding all sorts of conditional subtracting stuff        in the main loop...  Let them invert it first! :) */
comment|/* Eek.  Megawidgets don't return a value I can tie tooltips to.        Maybe I should look in to libgck. */
comment|/* entry/scale for depth of lens */
name|mw_iscale_entry_new
argument_list|(
name|table
argument_list|,
literal|"Depth"
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|refractvals
operator|.
name|depth
argument_list|)
expr_stmt|;
comment|/* entry/scale pair for distance */
name|mw_iscale_entry_new
argument_list|(
name|table
argument_list|,
literal|"Distance"
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
literal|0
comment|/*what's this do?*/
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
operator|&
name|refractvals
operator|.
name|dist
argument_list|)
expr_stmt|;
comment|/* a entry/scale/drop-menu for each index */
name|mw_fscale_entry_new
argument_list|(
name|table
argument_list|,
literal|"Index A"
argument_list|,
name|INDEX_SCALE_MIN
argument_list|,
literal|5.0
argument_list|,
literal|1.0
argument_list|,
literal|0.1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
operator|&
name|refractvals
operator|.
name|na
argument_list|)
expr_stmt|;
name|ior_a_menu
operator|=
name|ior_menu_new
argument_list|(
name|NULL
comment|/*FIXME*/
argument_list|)
expr_stmt|;
name|gtk_table_attach_defaults
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|ior_a_menu
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|ior_a_menu
argument_list|)
expr_stmt|;
name|gtk_tooltips_set_tips
argument_list|(
name|tooltips
argument_list|,
name|ior_a_menu
argument_list|,
literal|"FIXME (No, it doesn't work.)"
argument_list|)
expr_stmt|;
name|mw_fscale_entry_new
argument_list|(
name|table
argument_list|,
literal|"Index B"
argument_list|,
name|INDEX_SCALE_MIN
argument_list|,
literal|5.0
argument_list|,
literal|1.0
argument_list|,
literal|0.1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
operator|&
name|refractvals
operator|.
name|nb
argument_list|)
expr_stmt|;
name|ior_b_menu
operator|=
name|ior_menu_new
argument_list|(
name|NULL
comment|/*FIXME*/
argument_list|)
expr_stmt|;
name|gtk_table_attach_defaults
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|ior_b_menu
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|ior_b_menu
argument_list|)
expr_stmt|;
name|gtk_tooltips_set_tips
argument_list|(
name|tooltips
argument_list|,
name|ior_b_menu
argument_list|,
literal|"FIXME (No, it doesn't work.)"
argument_list|)
expr_stmt|;
comment|/* entry/scale pairs for x and y offsets */
name|mw_iscale_entry_new
argument_list|(
name|table
argument_list|,
literal|"X Offset"
argument_list|,
operator|-
literal|1000
argument_list|,
literal|1000
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
operator|&
name|refractvals
operator|.
name|xofs
argument_list|)
expr_stmt|;
name|mw_iscale_entry_new
argument_list|(
name|table
argument_list|,
literal|"Y Offset"
argument_list|,
operator|-
literal|1000
argument_list|,
literal|1000
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
operator|&
name|refractvals
operator|.
name|yofs
argument_list|)
expr_stmt|;
comment|/* radio buttons for wrap/transparent (or bg, if image isn't layered) */
comment|/* button = gtk_check_button_new_with_label ("Wrap?");     toggle_button_callback (button, gpointer   data);     gtk_toggle_button_set_state (GtkToggleButton button, refractvals.wrap); */
comment|/* Make new layer(s) or dirty the old? */
name|layercheck
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"New layer?"
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|layercheck
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|layercheck
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|newl_toggle_callback
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|layercheck
argument_list|)
argument_list|,
name|refractvals
operator|.
name|newl
argument_list|)
expr_stmt|;
name|gtk_tooltips_set_tips
argument_list|(
name|tooltips
argument_list|,
name|layercheck
argument_list|,
literal|"Put the refracted image on a new layer or dirty this one?"
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|layercheck
argument_list|)
expr_stmt|;
name|toolcheck
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Tooltips?"
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|toolcheck
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toolcheck
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
name|GTK_SIGNAL_FUNC
argument_list|(
name|tooltips_toggle_callback
argument_list|)
argument_list|,
operator|(
name|gpointer
operator|)
name|tooltips
argument_list|)
expr_stmt|;
name|gtk_tooltips_set_tips
argument_list|(
name|tooltips
argument_list|,
name|toolcheck
argument_list|,
literal|"Turn off these dumb tooltips."
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toolcheck
argument_list|)
expr_stmt|;
comment|/* Tooltips OFF by default. */
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toolcheck
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_tooltips_disable
argument_list|(
name|tooltips
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|refractint
operator|.
name|run
return|;
block|}
end_function

begin_comment
comment|/* refract_dialog */
end_comment

begin_function
specifier|static
name|GtkWidget
modifier|*
DECL|function|ior_menu_new (GtkWidget * tieto)
name|ior_menu_new
parameter_list|(
name|GtkWidget
modifier|*
name|tieto
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|chooser
decl_stmt|;
name|GtkWidget
modifier|*
name|menu
decl_stmt|,
modifier|*
name|menuitem
decl_stmt|;
name|guint
name|i
decl_stmt|;
DECL|struct|foo
struct|struct
name|foo
block|{
DECL|member|index
specifier|const
name|gfloat
name|index
decl_stmt|;
DECL|member|name
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
block|}
struct|;
comment|/* If you change stuff, don't forget to change this. */
DECL|macro|NUMSTUFF
define|#
directive|define
name|NUMSTUFF
value|9
specifier|static
specifier|const
name|struct
name|foo
name|material
index|[
name|NUMSTUFF
index|]
init|=
block|{
comment|/* Common indicies of refraction (for yellow sodium light, 589 nm) */
comment|/* From my Sears, Zemansky, Young physics book. */
comment|/* For more, check your copy of the CRC or your favorite pov-ray        include file.  */
block|{
literal|1.0003
block|,
literal|"Air"
block|}
block|,
block|{
literal|1.309
block|,
literal|"Ice"
block|}
block|,
block|{
literal|1.333
block|,
literal|"Water"
block|}
block|,
block|{
literal|1.36
block|,
literal|"Alcohol"
block|}
block|,
block|{
literal|1.473
block|,
literal|"Glycerine"
block|}
block|,
block|{
literal|1.52
block|,
literal|"Glass"
block|}
block|,
block|{
literal|1.544
block|,
literal|"Quartz"
block|}
block|,
block|{
literal|1.923
block|,
literal|"Zircon"
block|}
block|,
block|{
literal|2.417
block|,
literal|"Diamond"
block|}
block|,   }
decl_stmt|;
name|chooser
operator|=
name|gtk_option_menu_new
argument_list|()
expr_stmt|;
name|menu
operator|=
name|gtk_menu_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMSTUFF
condition|;
name|i
operator|++
control|)
block|{
name|menuitem
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
name|material
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|gtk_menu_append
argument_list|(
name|GTK_MENU
argument_list|(
name|menu
argument_list|)
argument_list|,
name|menuitem
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|menuitem
argument_list|)
argument_list|,
literal|"activate"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|ior_menu_callback
argument_list|,
operator|(
name|gfloat
operator|*
operator|)
operator|&
name|material
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|menuitem
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* next i */
name|gtk_option_menu_set_menu
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|chooser
argument_list|)
argument_list|,
name|menu
argument_list|)
expr_stmt|;
return|return
name|chooser
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ior_menu_callback (GtkWidget * widget,gfloat * data)
name|ior_menu_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gfloat
modifier|*
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|REFRACT_DEBUG
name|printf
argument_list|(
literal|"%f\n"
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|map_constrain (gint32 image_id,gint32 drawable_id,gpointer data)
name|map_constrain
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|drawable_id
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
if|if
condition|(
name|drawable_id
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
return|return
operator|(
name|gimp_drawable_color
argument_list|(
name|drawable_id
argument_list|)
operator|||
name|gimp_drawable_gray
argument_list|(
name|drawable_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* map_constrain */
end_comment

begin_comment
comment|/* Callbacks */
end_comment

begin_function
specifier|static
name|void
DECL|function|newl_toggle_callback (GtkWidget * widget,gpointer data)
name|newl_toggle_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|refractvals
operator|.
name|newl
operator|=
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|tooltips_toggle_callback (GtkWidget * widget,gpointer data)
name|tooltips_toggle_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|GtkTooltips
modifier|*
name|tooltips
decl_stmt|;
name|tooltips
operator|=
operator|(
name|GtkTooltips
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
condition|)
name|gtk_tooltips_enable
argument_list|(
name|tooltips
argument_list|)
expr_stmt|;
else|else
name|gtk_tooltips_disable
argument_list|(
name|tooltips
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|refract_close_callback (GtkWidget * widget,gpointer data)
name|refract_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|refract_ok_callback (GtkWidget * widget,gpointer data)
name|refract_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|refractint
operator|.
name|run
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|map_menu_callback (gint32 id,gpointer data)
name|map_menu_callback
parameter_list|(
name|gint32
name|id
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|refractvals
operator|.
name|lensmap
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************  * A borrowed bilinear interpolation function.  */
end_comment

begin_function
specifier|static
name|guchar
DECL|function|bilinear (double x,double y,guchar * values)
name|bilinear
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|guchar
modifier|*
name|values
parameter_list|)
block|{
name|double
name|m0
decl_stmt|,
name|m1
decl_stmt|;
name|x
operator|=
name|fmod
argument_list|(
name|x
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|y
operator|=
name|fmod
argument_list|(
name|y
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0.0
condition|)
name|x
operator|+=
literal|1.0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0.0
condition|)
name|y
operator|+=
literal|1.0
expr_stmt|;
name|m0
operator|=
operator|(
name|double
operator|)
name|values
index|[
literal|0
index|]
operator|+
name|x
operator|*
operator|(
operator|(
name|double
operator|)
name|values
index|[
literal|1
index|]
operator|-
name|values
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|m1
operator|=
operator|(
name|double
operator|)
name|values
index|[
literal|2
index|]
operator|+
name|x
operator|*
operator|(
operator|(
name|double
operator|)
name|values
index|[
literal|3
index|]
operator|-
name|values
index|[
literal|2
index|]
operator|)
expr_stmt|;
return|return
call|(
name|guchar
call|)
argument_list|(
name|m0
operator|+
name|y
operator|*
operator|(
name|m1
operator|-
name|m0
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* bilinear */
end_comment

begin_comment
comment|/************************************************************************  *  *   Fun pixel fetching stuff...  Quartic's code from whirlpinch.c  *   Uses the globals sel_x1,sel_x2,sel_y1,sel_y2.  */
end_comment

begin_function
specifier|static
name|pixel_fetcher_t
modifier|*
DECL|function|pixel_fetcher_new (GDrawable * drawable)
name|pixel_fetcher_new
parameter_list|(
name|GDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|pixel_fetcher_t
modifier|*
name|pf
decl_stmt|;
name|pf
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pixel_fetcher_t
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|col
operator|=
operator|-
literal|1
expr_stmt|;
name|pf
operator|->
name|row
operator|=
operator|-
literal|1
expr_stmt|;
name|pf
operator|->
name|img_width
operator|=
name|gimp_drawable_width
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|pf
operator|->
name|img_height
operator|=
name|gimp_drawable_height
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|pf
operator|->
name|img_bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|pf
operator|->
name|img_has_alpha
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tile_width
operator|=
name|gimp_tile_width
argument_list|()
expr_stmt|;
name|pf
operator|->
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|drawable
operator|=
name|drawable
expr_stmt|;
name|pf
operator|->
name|tile
operator|=
name|NULL
expr_stmt|;
return|return
name|pf
return|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_new */
end_comment

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|pixel_fetcher_set_bg_color (pixel_fetcher_t * pf,guchar r,guchar g,guchar b,guchar a)
name|pixel_fetcher_set_bg_color
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|guchar
name|r
parameter_list|,
name|guchar
name|g
parameter_list|,
name|guchar
name|b
parameter_list|,
name|guchar
name|a
parameter_list|)
block|{
name|pf
operator|->
name|bg_color
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|pf
operator|->
name|bg_color
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|img_has_alpha
condition|)
name|pf
operator|->
name|bg_color
index|[
name|pf
operator|->
name|img_bpp
operator|-
literal|1
index|]
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_set_bg_color */
end_comment

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|pixel_fetcher_get_pixel (pixel_fetcher_t * pf,int x,int y,guchar * pixel)
name|pixel_fetcher_get_pixel
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|guchar
modifier|*
name|pixel
parameter_list|)
block|{
name|gint
name|col
decl_stmt|,
name|row
decl_stmt|;
name|gint
name|coloff
decl_stmt|,
name|rowoff
decl_stmt|;
name|guchar
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|<
name|sel_x1
operator|)
operator|||
operator|(
name|x
operator|>=
name|sel_x2
operator|)
operator|||
operator|(
name|y
operator|<
name|sel_y1
operator|)
operator|||
operator|(
name|y
operator|>=
name|sel_y2
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|img_bpp
condition|;
name|i
operator|++
control|)
name|pixel
index|[
name|i
index|]
operator|=
name|pf
operator|->
name|bg_color
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
comment|/* if */
name|col
operator|=
name|x
operator|/
name|pf
operator|->
name|tile_width
expr_stmt|;
name|coloff
operator|=
name|x
operator|%
name|pf
operator|->
name|tile_width
expr_stmt|;
name|row
operator|=
name|y
operator|/
name|pf
operator|->
name|tile_height
expr_stmt|;
name|rowoff
operator|=
name|y
operator|%
name|pf
operator|->
name|tile_height
expr_stmt|;
if|if
condition|(
operator|(
name|col
operator|!=
name|pf
operator|->
name|col
operator|)
operator|||
operator|(
name|row
operator|!=
name|pf
operator|->
name|row
operator|)
operator|||
operator|(
name|pf
operator|->
name|tile
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|pf
operator|->
name|tile
operator|!=
name|NULL
condition|)
name|gimp_tile_unref
argument_list|(
name|pf
operator|->
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tile
operator|=
name|gimp_drawable_get_tile
argument_list|(
name|pf
operator|->
name|drawable
argument_list|,
name|FALSE
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|gimp_tile_ref
argument_list|(
name|pf
operator|->
name|tile
argument_list|)
expr_stmt|;
name|pf
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|pf
operator|->
name|row
operator|=
name|row
expr_stmt|;
block|}
comment|/* if */
name|p
operator|=
name|pf
operator|->
name|tile
operator|->
name|data
operator|+
name|pf
operator|->
name|img_bpp
operator|*
operator|(
name|pf
operator|->
name|tile
operator|->
name|ewidth
operator|*
name|rowoff
operator|+
name|coloff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pf
operator|->
name|img_bpp
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|*
name|pixel
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_get_pixel */
end_comment

begin_comment
comment|/*****/
end_comment

begin_function
specifier|static
name|void
DECL|function|pixel_fetcher_destroy (pixel_fetcher_t * pf)
name|pixel_fetcher_destroy
parameter_list|(
name|pixel_fetcher_t
modifier|*
name|pf
parameter_list|)
block|{
if|if
condition|(
name|pf
operator|->
name|tile
operator|!=
name|NULL
condition|)
name|gimp_tile_unref
argument_list|(
name|pf
operator|->
name|tile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pixel_fetcher_destroy */
end_comment

end_unit

