begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* WARNING: XJT code and Fileformat under construction  *  * XJT (JPEG-TAR fileformat) loading and saving file filter for the GIMP  *  -hof (Wolfgang Hofer)  *  * This filter requires UNIX tar and the "jpeglib" Library to run.  * For optional further compression you also should install  *  gzip and bzip2 compression Programs.  *  * IMPORTANT NOTE:  *   The GIMP-core 1.0.2 does not provide all Interfaces (PDB-Procedures)  *   to enable a plugin to save/load all properties of an image.  *  *   The most of the missing PDB-Interfaces are available in the registry  *   as patches to the gimp core. (look for gap-patches or gap)  *   *   If you dont install the patches XJT will work on GIMP 1.0.2,   *   but some Informations can not be saved or loaded.  *   - floating selections  *   - the layers linked state  *   - guides                     (NO PATCH available)  *  * GIMP 1.1 will provide all the procedures to run XJT at full fuctionality.  * There are no Patches required to run XJT in the latest GIMP 1.1  * development version  *  * Things left to do for next XJT release  *    - show continous progress while loading/saving  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* TODO:  *   load tattoos (code is prepared for tattos, but  *                 ** there is no PDB interface available in gimp 1.1.2 **)  *   load/save support for parasites  */
end_comment

begin_comment
comment|/* revision history:  * version 1.02.00; 1999/03/16  hof: - save layer/channel Tattoos  *                                   - load/save image resolution added  *                                   - tolerate unknown properties with warnings  * version 1.01.00; 1998/11/22  hof: added load/save of guides  *                                   (you need gimp 1.1 to use this feature)  * version 1.00.00; 1998/10/29  hof: 1.st (pre) release  */
end_comment

begin_comment
comment|/* System UNIX includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* XJT includes */
end_comment

begin_include
include|#
directive|include
file|"xjpeg.h"
end_include

begin_include
include|#
directive|include
file|"xpdb_calls.h"
end_include

begin_define
DECL|macro|GIMP_XJ_IMAGE
define|#
directive|define
name|GIMP_XJ_IMAGE
value|"GIMP_XJ_IMAGE"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|MAX_LINE_LEN
define|#
directive|define
name|MAX_LINE_LEN
value|1024
end_define

begin_decl_stmt
DECL|variable|xjt_debug
name|int
name|xjt_debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|g_pid
name|pid_t
name|g_pid
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2aef7e630108
block|{
DECL|member|run
name|gint
name|run
decl_stmt|;
DECL|typedef|JpegSaveInterface
block|}
name|JpegSaveInterface
typedef|;
end_typedef

begin_comment
comment|/* PROPERTY enums   *  (0-21 are ident with PropType values as used in xcf.c  *   the rest was added for xjt  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2aef7e630203
block|{
DECL|enumerator|PROP_END
name|PROP_END
init|=
literal|0
block|,
DECL|enumerator|PROP_COLORMAP
name|PROP_COLORMAP
init|=
literal|1
block|,
DECL|enumerator|PROP_ACTIVE_LAYER
name|PROP_ACTIVE_LAYER
init|=
literal|2
block|,
DECL|enumerator|PROP_ACTIVE_CHANNEL
name|PROP_ACTIVE_CHANNEL
init|=
literal|3
block|,
DECL|enumerator|PROP_SELECTION
name|PROP_SELECTION
init|=
literal|4
block|,
DECL|enumerator|PROP_FLOATING_SELECTION
name|PROP_FLOATING_SELECTION
init|=
literal|5
block|,
DECL|enumerator|PROP_OPACITY
name|PROP_OPACITY
init|=
literal|6
block|,
DECL|enumerator|PROP_MODE
name|PROP_MODE
init|=
literal|7
block|,
DECL|enumerator|PROP_VISIBLE
name|PROP_VISIBLE
init|=
literal|8
block|,
DECL|enumerator|PROP_LINKED
name|PROP_LINKED
init|=
literal|9
block|,
DECL|enumerator|PROP_PRESERVE_TRANSPARENCY
name|PROP_PRESERVE_TRANSPARENCY
init|=
literal|10
block|,
DECL|enumerator|PROP_APPLY_MASK
name|PROP_APPLY_MASK
init|=
literal|11
block|,
DECL|enumerator|PROP_EDIT_MASK
name|PROP_EDIT_MASK
init|=
literal|12
block|,
DECL|enumerator|PROP_SHOW_MASK
name|PROP_SHOW_MASK
init|=
literal|13
block|,
DECL|enumerator|PROP_SHOW_MASKED
name|PROP_SHOW_MASKED
init|=
literal|14
block|,
DECL|enumerator|PROP_OFFSETS
name|PROP_OFFSETS
init|=
literal|15
block|,
DECL|enumerator|PROP_COLOR
name|PROP_COLOR
init|=
literal|16
block|,
DECL|enumerator|PROP_COMPRESSION
name|PROP_COMPRESSION
init|=
literal|17
block|,
DECL|enumerator|PROP_GUIDES
name|PROP_GUIDES
init|=
literal|18
block|,
DECL|enumerator|PROP_RESOLUTION
name|PROP_RESOLUTION
init|=
literal|19
block|,
DECL|enumerator|PROP_TATTOO
name|PROP_TATTOO
init|=
literal|20
block|,
DECL|enumerator|PROP_PARASITES
name|PROP_PARASITES
init|=
literal|21
block|,
DECL|enumerator|PROP_NAME
name|PROP_NAME
init|=
literal|90
block|,
DECL|enumerator|PROP_DIMENSION
name|PROP_DIMENSION
init|=
literal|91
block|,
DECL|enumerator|PROP_TYPE
name|PROP_TYPE
init|=
literal|92
block|,
DECL|enumerator|PROP_VERSION
name|PROP_VERSION
init|=
literal|93
block|,
DECL|enumerator|PROP_FLOATING_ATTACHED
name|PROP_FLOATING_ATTACHED
init|=
literal|94
block|,
DECL|enumerator|PROP_SYNTAX_ERROR
name|PROP_SYNTAX_ERROR
init|=
literal|99
DECL|typedef|t_proptype
block|}
name|t_proptype
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2aef7e630303
block|{
DECL|enumerator|PTYP_NOT_SUPPORTED
name|PTYP_NOT_SUPPORTED
init|=
literal|0
block|,
DECL|enumerator|PTYP_BOOLEAN
name|PTYP_BOOLEAN
init|=
literal|1
block|,
DECL|enumerator|PTYP_INT
name|PTYP_INT
init|=
literal|2
block|,
DECL|enumerator|PTYP_FLT
name|PTYP_FLT
init|=
literal|3
block|,
DECL|enumerator|PTYP_STRING
name|PTYP_STRING
init|=
literal|4
block|,
DECL|enumerator|PTYP_2xINT
name|PTYP_2xINT
init|=
literal|5
block|,
DECL|enumerator|PTYP_3xINT
name|PTYP_3xINT
init|=
literal|6
block|,
DECL|enumerator|PTYP_2xFLT
name|PTYP_2xFLT
init|=
literal|7
block|,
DECL|enumerator|PTYP_3xFLT
name|PTYP_3xFLT
init|=
literal|8
block|, }
DECL|typedef|t_param_typ
name|t_param_typ
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2aef7e630408
block|{
DECL|member|prop_id
name|t_proptype
name|prop_id
decl_stmt|;
DECL|member|prop_mnemonic
name|char
modifier|*
name|prop_mnemonic
decl_stmt|;
DECL|member|param_typ
name|t_param_typ
name|param_typ
decl_stmt|;
DECL|member|default_val1
name|gdouble
name|default_val1
decl_stmt|;
DECL|member|default_val2
name|gdouble
name|default_val2
decl_stmt|;
DECL|member|default_val3
name|gdouble
name|default_val3
decl_stmt|;
DECL|typedef|t_prop_table
block|}
name|t_prop_table
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2aef7e630508
block|{
DECL|member|int_val1
name|gint32
name|int_val1
decl_stmt|;
DECL|member|int_val2
name|gint32
name|int_val2
decl_stmt|;
DECL|member|int_val3
name|gint32
name|int_val3
decl_stmt|;
DECL|member|flt_val1
name|gdouble
name|flt_val1
decl_stmt|;
DECL|member|flt_val2
name|gdouble
name|flt_val2
decl_stmt|;
DECL|member|flt_val3
name|gdouble
name|flt_val3
decl_stmt|;
DECL|member|string_val
name|char
modifier|*
name|string_val
decl_stmt|;
DECL|typedef|t_param_prop
block|}
name|t_param_prop
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2aef7e630608
block|{
DECL|member|active_channel
name|gint
name|active_channel
decl_stmt|;
DECL|member|selection
name|gint
name|selection
decl_stmt|;
DECL|member|floating_attached
name|gint
name|floating_attached
decl_stmt|;
DECL|member|opacity
name|gdouble
name|opacity
decl_stmt|;
DECL|member|visible
name|gint
name|visible
decl_stmt|;
DECL|member|show_masked
name|gint
name|show_masked
decl_stmt|;
DECL|member|color_r
name|guchar
name|color_r
decl_stmt|;
DECL|member|color_g
name|guchar
name|color_g
decl_stmt|;
DECL|member|color_b
name|guchar
name|color_b
decl_stmt|;
DECL|member|offx
name|gint32
name|offx
decl_stmt|;
comment|/* do channels have offset ?? */
DECL|member|offy
name|gint32
name|offy
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|channel_pos
name|gint
name|channel_pos
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_channel_props
block|}
name|t_channel_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2aef7e630708
block|{
DECL|member|active_layer
name|gint
name|active_layer
decl_stmt|;
DECL|member|floating_selection
name|gint
name|floating_selection
decl_stmt|;
DECL|member|floating_attached
name|gint
name|floating_attached
decl_stmt|;
DECL|member|opacity
name|gdouble
name|opacity
decl_stmt|;
DECL|member|mode
name|gint32
name|mode
decl_stmt|;
DECL|member|visible
name|gint
name|visible
decl_stmt|;
DECL|member|linked
name|gint
name|linked
decl_stmt|;
DECL|member|preserve_transparency
name|gint
name|preserve_transparency
decl_stmt|;
DECL|member|apply_mask
name|gint
name|apply_mask
decl_stmt|;
DECL|member|edit_mask
name|gint
name|edit_mask
decl_stmt|;
DECL|member|show_mask
name|gint
name|show_mask
decl_stmt|;
DECL|member|offx
name|gint32
name|offx
decl_stmt|;
DECL|member|offy
name|gint32
name|offy
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|layer_pos
name|gint
name|layer_pos
decl_stmt|;
DECL|member|has_alpha
name|gint
name|has_alpha
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_layer_props
block|}
name|t_layer_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2aef7e630808
block|{
DECL|member|position
name|gint32
name|position
decl_stmt|;
DECL|member|orientation
name|gint8
name|orientation
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_guide_props
block|}
name|t_guide_props
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2aef7e630908
typedef|typedef
struct|struct
block|{
DECL|member|version
name|char
modifier|*
name|version
decl_stmt|;
DECL|member|image_type
name|GImageType
name|image_type
decl_stmt|;
DECL|member|image_width
name|gint
name|image_width
decl_stmt|;
DECL|member|image_height
name|gint
name|image_height
decl_stmt|;
DECL|member|xresolution
name|float
name|xresolution
decl_stmt|;
DECL|member|yresolution
name|float
name|yresolution
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|n_layers
name|gint
name|n_layers
decl_stmt|;
DECL|member|n_channels
name|gint
name|n_channels
decl_stmt|;
DECL|member|layer_props
name|t_layer_props
modifier|*
name|layer_props
decl_stmt|;
DECL|member|channel_props
name|t_channel_props
modifier|*
name|channel_props
decl_stmt|;
DECL|member|mask_props
name|t_channel_props
modifier|*
name|mask_props
decl_stmt|;
DECL|member|guide_props
name|t_guide_props
modifier|*
name|guide_props
decl_stmt|;
DECL|typedef|t_image_props
block|}
name|t_image_props
typedef|;
end_typedef

begin_define
DECL|macro|PROP_TABLE_ENTRIES
define|#
directive|define
name|PROP_TABLE_ENTRIES
value|27
end_define

begin_decl_stmt
DECL|variable|g_prop_table
name|t_prop_table
name|g_prop_table
index|[
name|PROP_TABLE_ENTRIES
index|]
init|=
block|{
comment|/* t_proptype              mnemonic   t_paramtyp             default values */
block|{
name|PROP_END
block|,
literal|"*"
block|,
name|PTYP_NOT_SUPPORTED
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_COLORMAP
block|,
literal|"*"
block|,
name|PTYP_NOT_SUPPORTED
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_ACTIVE_LAYER
block|,
literal|"acl"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_ACTIVE_CHANNEL
block|,
literal|"acc"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_SELECTION
block|,
literal|"sel"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_FLOATING_SELECTION
block|,
literal|"fsl"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_OPACITY
block|,
literal|"op"
block|,
name|PTYP_FLT
block|,
literal|100.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_MODE
block|,
literal|"md"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_VISIBLE
block|,
literal|"iv"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_LINKED
block|,
literal|"ln"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PRESERVE_TRANSPARENCY
block|,
literal|"pt"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_APPLY_MASK
block|,
literal|"aml"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_EDIT_MASK
block|,
literal|"eml"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_SHOW_MASK
block|,
literal|"sml"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_SHOW_MASKED
block|,
literal|"smc"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_OFFSETS
block|,
literal|"o"
block|,
name|PTYP_2xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_COLOR
block|,
literal|"c"
block|,
name|PTYP_3xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_COMPRESSION
block|,
literal|"*"
block|,
name|PTYP_NOT_SUPPORTED
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_GUIDES
block|,
literal|"g"
block|,
name|PTYP_2xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_RESOLUTION
block|,
literal|"res"
block|,
name|PTYP_2xFLT
block|,
literal|72.0
block|,
literal|72.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_TATTOO
block|,
literal|"tto"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PARASITES
block|,
literal|"pte"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_FLOATING_ATTACHED
block|,
literal|"fa"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_NAME
block|,
literal|"n"
block|,
name|PTYP_STRING
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_DIMENSION
block|,
literal|"w/h"
block|,
name|PTYP_2xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_TYPE
block|,
literal|"typ"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_VERSION
block|,
literal|"ver"
block|,
name|PTYP_STRING
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_xjt_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_xjt_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_dialog
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|double
modifier|*
name|scale_val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_optimize_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_clr_transparent_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|jsvals
specifier|static
name|t_JpegSaveVals
name|jsvals
init|=
block|{
literal|0.75
block|,
comment|/*  quality  */
literal|0.0
block|,
comment|/*  smoothing  */
literal|1
block|,
comment|/*  optimize  */
literal|0
comment|/*  clr_transparent */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|jsint
specifier|static
name|JpegSaveInterface
name|jsint
init|=
block|{
name|FALSE
comment|/*  run  */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|gint
DECL|function|p_invert (gint value)
name|p_invert
parameter_list|(
name|gint
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
name|FALSE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
DECL|function|p_system (char * cmd)
name|int
name|p_system
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_rc2
decl_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"CMD: %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
comment|/* Shift 8 Bits gets Retcode of the executed Program */
name|l_rc2
operator|=
name|l_rc
operator|>>
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR system: %s\nreturncodes %d %d"
argument_list|,
name|cmd
argument_list|,
name|l_rc
argument_list|,
name|l_rc2
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nload_return_vals
init|=
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|GParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"is ignored"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"quality"
block|,
literal|"Quality of saved image (0<= quality<= 1)"
block|}
block|,
block|{
name|PARAM_FLOAT
block|,
literal|"smoothing"
block|,
literal|"Smoothing factor for saved image (0<= smoothing<= 1)"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"optimize"
block|,
literal|"Optimization of entropy encoding parameters"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"clr_transparent"
block|,
literal|"set all full-transparent pixels to 0"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|nsave_args
init|=
sizeof|sizeof
argument_list|(
name|save_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|save_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_xjt_load"
argument_list|,
literal|"loads files of the jpeg-tar file format"
argument_list|,
literal|"FIXME: help not available"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"1999-Mar-16"
argument_list|,
literal|"<Load>/xjt"
argument_list|,
name|NULL
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_xjt_save"
argument_list|,
literal|"saves files in the jpeg-tar file format"
argument_list|,
literal|"FIXME: help not available"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"1999-Mar-16"
argument_list|,
literal|"<Save>/xjt"
argument_list|,
literal|"RGB*, GRAY*"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nsave_args
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
literal|"file_xjt_load"
argument_list|,
literal|"xjt,xjtgz,xjtbz2"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_xjt_save"
argument_list|,
literal|"xjt,xjtgz,xjtbz2"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (char * name,int nparams,GParam * param,int * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|char
modifier|*
name|l_env
decl_stmt|;
name|g_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|xjt_debug
operator|=
name|FALSE
expr_stmt|;
name|l_env
operator|=
name|getenv
argument_list|(
literal|"XJT_DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_env
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_env
operator|!=
literal|'n'
operator|)
operator|&&
operator|(
operator|*
name|l_env
operator|!=
literal|'N'
operator|)
condition|)
name|xjt_debug
operator|=
name|TRUE
expr_stmt|;
block|}
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_xjt_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_xjt_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PARAM_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_xjt_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_xjt_save"
argument_list|,
operator|&
name|jsvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
block|{
return|return;
block|}
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|8
condition|)
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
name|jsvals
operator|.
name|quality
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|jsvals
operator|.
name|smoothing
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|jsvals
operator|.
name|optimize
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|jsvals
operator|.
name|clr_transparent
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
operator|&&
operator|(
name|jsvals
operator|.
name|quality
operator|<
literal|0.0
operator|||
name|jsvals
operator|.
name|quality
operator|>
literal|1.0
operator|)
condition|)
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
operator|&&
operator|(
name|jsvals
operator|.
name|smoothing
operator|<
literal|0.0
operator|||
name|jsvals
operator|.
name|smoothing
operator|>
literal|1.0
operator|)
condition|)
block|{
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
block|}
case|case
name|RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_xjt_save"
argument_list|,
operator|&
name|jsvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|save_xjt_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|)
operator|<
literal|0
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|/*  Store mvals data  */
name|gimp_set_data
argument_list|(
literal|"file_xjt_save"
argument_list|,
operator|&
name|jsvals
argument_list|,
sizeof|sizeof
argument_list|(
name|t_JpegSaveVals
argument_list|)
argument_list|)
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end run */
end_comment

begin_comment
comment|/* ---------------------- SAVE DIALOG procedures  -------------------------- */
end_comment

begin_function
specifier|static
name|gint
DECL|function|save_dialog ()
name|save_dialog
parameter_list|()
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|GtkWidget
modifier|*
name|scale
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkObject
modifier|*
name|scale_data
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|gint
name|argc
decl_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"save"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gtk_rc_parse
argument_list|(
name|gimp_gtkrc
argument_list|()
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gtk_dialog_new
argument_list|()
expr_stmt|;
name|gtk_window_set_title
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"Save as xjt"
argument_list|)
expr_stmt|;
name|gtk_window_position
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_close_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Action area  */
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_ok_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_grab_default
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect_object
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|gtk_widget_destroy
argument_list|,
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
comment|/*  parameter settings  */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"Parameter Settings"
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Quality"
argument_list|)
expr_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_FILL
operator||
name|GTK_EXPAND
argument_list|,
name|GTK_FILL
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
name|jsvals
operator|.
name|quality
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|0.01
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|scale
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|scale
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_FILL
operator||
name|GTK_EXPAND
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_scale_set_digits
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_scale_update
argument_list|,
operator|&
name|jsvals
operator|.
name|quality
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Smoothing"
argument_list|)
expr_stmt|;
name|gtk_misc_set_alignment
argument_list|(
name|GTK_MISC
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_FILL
operator||
name|GTK_EXPAND
argument_list|,
name|GTK_FILL
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gtk_adjustment_new
argument_list|(
name|jsvals
operator|.
name|smoothing
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|0.01
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|gtk_hscale_new
argument_list|(
name|GTK_ADJUSTMENT
argument_list|(
name|scale_data
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|scale
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|scale
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_FILL
operator||
name|GTK_EXPAND
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_scale_set_value_pos
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|GTK_POS_TOP
argument_list|)
expr_stmt|;
name|gtk_scale_set_digits
argument_list|(
name|GTK_SCALE
argument_list|(
name|scale
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_range_set_update_policy
argument_list|(
name|GTK_RANGE
argument_list|(
name|scale
argument_list|)
argument_list|,
name|GTK_UPDATE_DELAYED
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|scale_data
argument_list|)
argument_list|,
literal|"value_changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_scale_update
argument_list|,
operator|&
name|jsvals
operator|.
name|smoothing
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Optimize"
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_optimize_update
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|jsvals
operator|.
name|optimize
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Clear_Transparent"
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_clr_transparent_update
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_state
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|jsvals
operator|.
name|clr_transparent
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|jsint
operator|.
name|run
return|;
block|}
end_function

begin_comment
comment|/*  Save interface functions  */
end_comment

begin_function
specifier|static
name|void
DECL|function|save_close_callback (GtkWidget * widget,gpointer data)
name|save_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_ok_callback (GtkWidget * widget,gpointer data)
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|jsint
operator|.
name|run
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_scale_update (GtkAdjustment * adjustment,double * scale_val)
name|save_scale_update
parameter_list|(
name|GtkAdjustment
modifier|*
name|adjustment
parameter_list|,
name|double
modifier|*
name|scale_val
parameter_list|)
block|{
operator|*
name|scale_val
operator|=
name|adjustment
operator|->
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_optimize_update (GtkWidget * widget,gpointer data)
name|save_optimize_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|jsvals
operator|.
name|optimize
operator|=
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|save_clr_transparent_update (GtkWidget * widget,gpointer data)
name|save_clr_transparent_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|jsvals
operator|.
name|clr_transparent
operator|=
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------- SAVE WORKER procedures  -------------------------- */
end_comment

begin_comment
comment|/* ============================================================================  * p_get_property_index  *   get index in g_prop_table by proptype (id)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_get_property_index (t_proptype proptype)
name|p_get_property_index
parameter_list|(
name|t_proptype
name|proptype
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|PROP_TABLE_ENTRIES
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|prop_id
operator|==
name|proptype
condition|)
block|{
return|return
operator|(
name|l_idx
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* index of PROP_END -- not supported */
block|}
end_function

begin_comment
comment|/* end p_get_property_index */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_prop  *   write out the property mnemonic   *   and parameter(s) according to the property type  *  *   wr_all_prp is used for debug only and causes to write out all properties  *   Normally (wr_all_prp == FALSE) properties are NOT written, if they are  *   equal to their default value.  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_prop (FILE * fp,t_proptype proptype,t_param_prop * param,gint wr_all_prp)
name|p_write_prop
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|t_proptype
name|proptype
parameter_list|,
name|t_param_prop
modifier|*
name|param
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|int
name|l_prop_idx
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|char
name|f_buff
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|l_str
decl_stmt|;
name|l_prop_idx
operator|=
name|p_get_property_index
argument_list|(
name|proptype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|param_typ
condition|)
block|{
case|case
name|PTYP_BOOLEAN
case|:
comment|/* boolean properties are written if they are not FALSE */
if|if
condition|(
name|param
operator|->
name|int_val1
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wr_all_prp
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s!"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PTYP_INT
case|:
comment|/* int properties are written if they are not equal to default */
if|if
condition|(
operator|(
name|param
operator|->
name|int_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:%d"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_FLT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|flt_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|f_buff
argument_list|,
literal|"%.3f"
argument_list|,
operator|(
name|float
operator|)
name|param
operator|->
name|flt_val1
argument_list|)
expr_stmt|;
name|l_idx
operator|=
name|strlen
argument_list|(
name|f_buff
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l_idx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|f_buff
index|[
name|l_idx
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|f_buff
index|[
name|l_idx
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|)
condition|)
name|f_buff
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
break|break;
name|l_idx
operator|--
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|f_buff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_2xFLT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|flt_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|flt_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|f_buff
argument_list|,
literal|"%.3f,%.3f"
argument_list|,
operator|(
name|float
operator|)
name|param
operator|->
name|flt_val1
argument_list|,
operator|(
name|float
operator|)
name|param
operator|->
name|flt_val2
argument_list|)
expr_stmt|;
name|l_idx
operator|=
name|strlen
argument_list|(
name|f_buff
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l_idx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|f_buff
index|[
name|l_idx
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|f_buff
index|[
name|l_idx
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|)
condition|)
name|f_buff
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
break|break;
name|l_idx
operator|--
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|f_buff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_3xFLT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|flt_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|flt_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|param
operator|->
name|flt_val3
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val3
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|f_buff
argument_list|,
literal|"%.3f,%.3f,%.3f"
argument_list|,
operator|(
name|float
operator|)
name|param
operator|->
name|flt_val1
argument_list|,
operator|(
name|float
operator|)
name|param
operator|->
name|flt_val2
argument_list|,
operator|(
name|float
operator|)
name|param
operator|->
name|flt_val3
argument_list|)
expr_stmt|;
name|l_idx
operator|=
name|strlen
argument_list|(
name|f_buff
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l_idx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|f_buff
index|[
name|l_idx
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|f_buff
index|[
name|l_idx
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|)
condition|)
name|f_buff
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
break|break;
name|l_idx
operator|--
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|f_buff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_STRING
case|:
if|if
condition|(
name|param
operator|->
name|string_val
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|param
operator|->
name|string_val
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
comment|/* make sure thar string does not contain double quotes 	       * (by replacing them by single ones) 	       */
name|l_str
operator|=
name|param
operator|->
name|string_val
expr_stmt|;
while|while
condition|(
operator|*
name|l_str
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|l_str
operator|==
literal|'\"'
condition|)
block|{
operator|*
name|l_str
operator|=
literal|'\''
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|l_str
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|l_str
operator|=
literal|' '
expr_stmt|;
block|}
name|l_str
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:\"%s\""
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|param
operator|->
name|string_val
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PTYP_2xINT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|int_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|int_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:%d,%d"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_3xINT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|int_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|int_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|param
operator|->
name|int_val3
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val3
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s:%d,%d,%d"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val2
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val3
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/*  PTYP_NOT_SUPPORTED */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* end p_write_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_layer_prp  *   write out all properties of the given layer  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_layer_prp (FILE * fp,char * layer_shortname,gint32 image_id,gint32 layer_id,gint wr_all_prp)
name|p_write_layer_prp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|layer_shortname
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|layer_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|t_param_prop
name|l_param
decl_stmt|;
name|gint
name|l_ofsx
decl_stmt|,
name|l_ofsy
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|layer_shortname
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|layer_id
operator|==
name|gimp_image_get_active_layer
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_ACTIVE_LAYER
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_is_floating_selection
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_FLOATING_SELECTION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* check if floating selection is attached to this layer */
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|layer_id
operator|==
name|p_gimp_image_floating_sel_attached_to
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_FLOATING_ATTACHED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|flt_val1
operator|=
name|gimp_layer_get_opacity
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OPACITY
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|gint32
operator|)
name|gimp_layer_get_mode
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_MODE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_invert
argument_list|(
name|gimp_layer_get_visible
argument_list|(
name|layer_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_VISIBLE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_layer_get_linked
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_LINKED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_preserve_transparency
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_PRESERVE_TRANSPARENCY
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_apply_mask
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_edit_mask
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_show_mask
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layer_id
argument_list|,
operator|&
name|l_ofsx
argument_list|,
operator|&
name|l_ofsy
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_ofsx
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_ofsy
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OFFSETS
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_gimp_layer_get_tattoo
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TATTOO
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
name|gimp_layer_get_name
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_NAME
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_layer_prp */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_channel_prp  *   write out all properties of the given channel  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_channel_prp (FILE * fp,char * channel_shortname,gint32 image_id,gint32 channel_id,gint wr_all_prp)
name|p_write_channel_prp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|channel_shortname
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|channel_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|t_param_prop
name|l_param
decl_stmt|;
name|gint
name|l_ofsx
decl_stmt|,
name|l_ofsy
decl_stmt|;
name|guchar
name|l_r
decl_stmt|,
name|l_g
decl_stmt|,
name|l_b
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|channel_shortname
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|channel_id
operator|==
name|gimp_image_get_active_channel
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_ACTIVE_CHANNEL
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|channel_id
operator|==
name|gimp_image_get_selection
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_SELECTION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* check if floating selection is attached to this channel */
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|channel_id
operator|==
name|p_gimp_image_floating_sel_attached_to
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_FLOATING_ATTACHED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|flt_val1
operator|=
name|gimp_channel_get_opacity
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OPACITY
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_invert
argument_list|(
name|gimp_channel_get_visible
argument_list|(
name|channel_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_VISIBLE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_channel_get_show_masked
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_SHOW_MASKED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_channel_get_color
argument_list|(
name|channel_id
argument_list|,
operator|&
name|l_r
argument_list|,
operator|&
name|l_g
argument_list|,
operator|&
name|l_b
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_r
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_g
expr_stmt|;
name|l_param
operator|.
name|int_val3
operator|=
name|l_b
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_COLOR
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|channel_id
argument_list|,
operator|&
name|l_ofsx
argument_list|,
operator|&
name|l_ofsy
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_ofsx
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_ofsy
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OFFSETS
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_gimp_channel_get_tattoo
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TATTOO
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
name|gimp_channel_get_name
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_NAME
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_channel_prp */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_image_prp  *   write out the properties of the image  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_image_prp (FILE * fp,gint32 image_id,gint wr_all_prp)
name|p_write_image_prp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|GImageType
name|l_image_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|float
name|l_xresolution
decl_stmt|,
name|l_yresolution
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|gint32
name|l_guide_id
decl_stmt|;
comment|/* get info about the image */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_image_type
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|GIMP_XJ_IMAGE
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
literal|"1.1"
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_VERSION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_width
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_height
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_DIMENSION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|p_gimp_image_get_resolution
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_xresolution
argument_list|,
operator|&
name|l_yresolution
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|flt_val1
operator|=
name|l_xresolution
expr_stmt|;
name|l_param
operator|.
name|flt_val2
operator|=
name|l_yresolution
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_RESOLUTION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* in GIMP 1.0.2 there is no interface to access guides     * (so they were ignored in GIMP1.0.2 with warnings.     *  The warning is printed even if there are no guides,     *  because XJT does not know if there are guides without the Interface)     *     * In GIMP 1.1 guide are saved as expected.     */
name|l_guide_id
operator|=
name|p_gimp_image_findnext_guide
argument_list|(
name|image_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get 1.st guide */
while|while
condition|(
name|l_guide_id
operator|>
literal|0
condition|)
block|{
comment|/* get position and orientation for the current guide ID */
name|l_param
operator|.
name|int_val1
operator|=
name|p_gimp_image_get_guide_position
argument_list|(
name|image_id
argument_list|,
name|l_guide_id
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|p_gimp_image_get_guide_orientation
argument_list|(
name|image_id
argument_list|,
name|l_guide_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_GUIDES
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* findnext returns 0 if no (more) guides there       * (or -1 if no PDB interface is available)       */
name|l_guide_id
operator|=
name|p_gimp_image_findnext_guide
argument_list|(
name|image_id
argument_list|,
name|l_guide_id
argument_list|)
expr_stmt|;
block|}
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|gint32
operator|)
name|l_image_type
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TYPE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_image_prp */
end_comment

begin_comment
comment|/* ---------------------- SAVE  -------------------------- */
end_comment

begin_function
specifier|static
name|gint
DECL|function|save_xjt_image (char * filename,gint32 image_id,gint32 drawable_id)
name|save_xjt_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|drawable_id
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_len
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|char
name|l_dirname
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_prop_file
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_jpg_file
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_cmd
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|l_name
decl_stmt|;
name|FILE
modifier|*
name|l_fp_prp
decl_stmt|;
name|mode_t
name|l_mode_dir
decl_stmt|;
name|GImageType
name|l_image_type
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
modifier|*
name|l_channels_list
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint
name|l_nchannels
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_channel_id
decl_stmt|;
name|gint32
name|l_floating_layer_id
decl_stmt|;
name|gint32
name|l_selection_channel_id
decl_stmt|;
name|int
name|l_sel
decl_stmt|;
name|gint32
name|l_x1
decl_stmt|,
name|l_x2
decl_stmt|,
name|l_y1
decl_stmt|,
name|l_y2
decl_stmt|;
name|gint
name|l_wr_all_prp
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init retcode to Errorstate */
name|l_floating_layer_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_fp_prp
operator|=
name|NULL
expr_stmt|;
name|l_layers_list
operator|=
name|NULL
expr_stmt|;
name|l_channels_list
operator|=
name|NULL
expr_stmt|;
name|l_wr_all_prp
operator|=
name|FALSE
expr_stmt|;
comment|/* FALSE write only non-default properties                               * TRUE  write all properties (should be used for DEBUG only) 			      */
comment|/* get info about the image */
name|l_image_type
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_image_type
condition|)
block|{
case|case
name|RGB_IMAGE
case|:
case|case
name|GRAY_IMAGE
case|:
case|case
name|RGBA_IMAGE
case|:
case|case
name|GRAYA_IMAGE
case|:
break|break;
case|case
name|INDEXED_IMAGE
case|:
name|g_message
argument_list|(
literal|"xjt: cannot operate on indexed color images"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
default|default:
name|g_message
argument_list|(
literal|"xjt: cannot operate on unknown image types"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
name|l_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_name
argument_list|,
literal|"Saving %s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
comment|/* create temporary directory<filename>.tmpdir.<PID> */
name|sprintf
argument_list|(
name|l_dirname
argument_list|,
literal|"%s.tmpdir.%d"
argument_list|,
name|filename
argument_list|,
operator|(
name|int
operator|)
name|g_pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_prop_file
argument_list|,
literal|"%s/PRP"
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|l_mode_dir
operator|=
literal|0777
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|l_dirname
argument_list|,
name|l_mode_dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"can't create working dir: %s\n"
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* create property file PRP */
name|l_fp_prp
operator|=
name|fopen
argument_list|(
name|l_prop_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp_prp
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
literal|"can't open %s\n"
argument_list|,
name|l_prop_file
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* write image properties */
name|p_write_image_prp
argument_list|(
name|l_fp_prp
argument_list|,
name|image_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
name|l_floating_layer_id
operator|=
name|gimp_image_floating_selection
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_floating_layer_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: call floating_sel_relax fsel_id=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_floating_layer_id
argument_list|)
expr_stmt|;
name|p_gimp_floating_sel_relax
argument_list|(
name|l_floating_layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
comment|/* foreach layer do */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_nlayers
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_layer_id
operator|=
name|l_layers_list
index|[
name|l_idx
index|]
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"Layer [%d] id=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|)
expr_stmt|;
comment|/* save layer as jpeg file */
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/l%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving layer to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|JSVM_DRAWABLE
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* write out the layer properties */
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|l_layer_id
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"L%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"l%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
block|}
name|p_write_layer_prp
argument_list|(
name|l_fp_prp
argument_list|,
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
comment|/* check, and save alpha channel */
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|l_layer_id
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/la%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving alpha-channel to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|JSVM_ALPHA
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* check and save layer_mask channel */
name|l_channel_id
operator|=
name|gimp_layer_get_mask_id
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_id
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/lm%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving layer-mask to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|JSVM_DRAWABLE
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* write out the layer_mask (== channel) properties */
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"m%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
name|p_write_channel_prp
argument_list|(
name|l_fp_prp
argument_list|,
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end foreach layer */
comment|/* check and see if we have to save out the selection */
name|l_sel
operator|=
literal|0
expr_stmt|;
name|l_selection_channel_id
operator|=
name|gimp_image_get_selection
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_get_gimp_selection_bounds
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_x1
argument_list|,
operator|&
name|l_y1
argument_list|,
operator|&
name|l_x2
argument_list|,
operator|&
name|l_y2
argument_list|)
operator|)
operator|&&
operator|(
name|l_selection_channel_id
operator|>=
literal|0
operator|)
condition|)
block|{
name|l_sel
operator|=
literal|1
expr_stmt|;
block|}
name|l_channels_list
operator|=
name|gimp_image_get_channels
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_nchannels
argument_list|)
expr_stmt|;
comment|/* foreach channel do */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_nchannels
operator|+
name|l_sel
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|l_idx
operator|<
name|l_nchannels
condition|)
name|l_channel_id
operator|=
name|l_channels_list
index|[
name|l_idx
index|]
expr_stmt|;
else|else
name|l_channel_id
operator|=
name|l_selection_channel_id
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"channel [%d] id=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|int
operator|)
name|l_channel_id
argument_list|)
expr_stmt|;
comment|/* save channel as jpeg file */
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/c%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving channel to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|JSVM_DRAWABLE
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* write out the channel properties */
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"c%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
name|p_write_channel_prp
argument_list|(
name|l_fp_prp
argument_list|,
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
block|}
comment|/* end foreach channel */
name|fclose
argument_list|(
name|l_fp_prp
argument_list|)
expr_stmt|;
name|l_fp_prp
operator|=
name|NULL
expr_stmt|;
comment|/* store properties and  all layers and cannels in a     * tar archive with filename.tar     */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"cd %s; tar -cf \"%s\" *; cd .."
argument_list|,
name|l_dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_len
operator|>
literal|3
operator|)
operator|&&
operator|(
name|l_rc
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* call optional extracompression programs gzip or bzip2        * (depends on filename's extension)       *       * used gzip options: (bzip2 uses the same options)       *     -c --stdout --to-stdout       *          Write  output  on  standard  output       *     -f --force       *           Force compression or decompression even if the file       */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|3
index|]
argument_list|,
literal|"bz2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"bzip2 -cf \"%s\">\"%s.tmp_bz2\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"mv \"%s.tmp_bz2\" \"%s\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|2
index|]
argument_list|,
literal|"gz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"gzip -cf<\"%s\">\"%s.tmp_gz\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"mv \"%s.tmp_gz\" \"%s\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|l_fp_prp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|l_fp_prp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_floating_layer_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: here we should call floating_sel_rigor sel_id=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_floating_layer_id
argument_list|)
expr_stmt|;
name|p_gimp_floating_sel_rigor
argument_list|(
name|l_floating_layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_layers_list
condition|)
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channels_list
condition|)
name|g_free
argument_list|(
name|l_channels_list
argument_list|)
expr_stmt|;
comment|/* remove the temorary directory */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"rm -rf \"%s\""
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xjt_debug
condition|)
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------- LOAD WORKER procedures  -------------------------- */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_layer_prop  *   allocate new layer_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
DECL|function|p_new_layer_prop ()
name|t_layer_props
modifier|*
name|p_new_layer_prop
parameter_list|()
block|{
name|t_layer_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_layer_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|!=
name|NULL
condition|)
block|{
name|l_new_prop
operator|->
name|active_layer
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_ACTIVE_LAYER
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|floating_selection
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_FLOATING_SELECTION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_FLOATING_ATTACHED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|opacity
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OPACITY
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|mode
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_MODE
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_VISIBLE
argument_list|)
index|]
operator|.
name|default_val1
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|linked
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_LINKED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|preserve_transparency
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_PRESERVE_TRANSPARENCY
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|apply_mask
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_APPLY_MASK
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|edit_mask
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_EDIT_MASK
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|show_mask
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_SHOW_MASK
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offx
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|layer_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|l_new_prop
operator|->
name|has_alpha
operator|=
name|FALSE
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|l_new_prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_new_layer_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_channel_prop  *   allocate new channel_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
DECL|function|p_new_channel_prop ()
name|t_channel_props
modifier|*
name|p_new_channel_prop
parameter_list|()
block|{
name|t_channel_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_channel_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|!=
name|NULL
condition|)
block|{
name|l_new_prop
operator|->
name|active_channel
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_ACTIVE_CHANNEL
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|selection
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_SELECTION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_FLOATING_ATTACHED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|opacity
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OPACITY
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_VISIBLE
argument_list|)
index|]
operator|.
name|default_val1
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|show_masked
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_SHOW_MASKED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offx
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|color_r
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_COLOR
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
empty_stmt|;
name|l_new_prop
operator|->
name|color_g
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_COLOR
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|color_b
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_COLOR
argument_list|)
index|]
operator|.
name|default_val3
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|channel_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|l_new_prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_new_channel_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_guide_prop  *   allocate new guide_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
DECL|function|p_new_guide_prop ()
name|t_guide_props
modifier|*
name|p_new_guide_prop
parameter_list|()
block|{
name|t_guide_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_guide_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|!=
name|NULL
condition|)
block|{
name|l_new_prop
operator|->
name|position
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|orientation
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|l_new_prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_new_guide_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_image_prop  *   allocate new layer_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
DECL|function|p_new_image_prop ()
name|t_image_props
modifier|*
name|p_new_image_prop
parameter_list|()
block|{
name|t_image_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_image_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|!=
name|NULL
condition|)
block|{
name|l_new_prop
operator|->
name|image_type
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TYPE
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|image_width
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_DIMENSION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|image_height
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_DIMENSION
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|xresolution
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_RESOLUTION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|yresolution
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_RESOLUTION
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|n_layers
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|n_channels
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|layer_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|channel_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|mask_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|guide_props
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|l_new_prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_new_image_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_skip_blanks  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_skip_blanks (char * scan_ptr)
specifier|static
name|char
modifier|*
name|p_skip_blanks
parameter_list|(
name|char
modifier|*
name|scan_ptr
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|scan_ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|scan_ptr
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|scan_ptr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|scan_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_scann_token  *   scan one token with its parameter(s)  *   return pointer to character behind the last scanned byte.  *  * Check prop_id for PROP_END             (no more tokens found)  *               for PROP_SYNTAX_ERROR    (illegal token/params detected)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_scann_token (char * scan_ptr,t_param_prop * param,t_proptype * prop_id)
specifier|static
name|char
modifier|*
name|p_scann_token
parameter_list|(
name|char
modifier|*
name|scan_ptr
parameter_list|,
name|t_param_prop
modifier|*
name|param
parameter_list|,
name|t_proptype
modifier|*
name|prop_id
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
name|int
name|l_ids
decl_stmt|;
name|char
name|l_token
index|[
name|MAX_LINE_LEN
index|]
decl_stmt|;
name|char
name|l_string_buff
index|[
name|MAX_LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|char
modifier|*
name|l_ptr2
decl_stmt|;
comment|/* check for end of property line */
if|if
condition|(
operator|(
operator|*
name|scan_ptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|scan_ptr
operator|==
literal|'\n'
operator|)
condition|)
block|{
operator|*
name|prop_id
operator|=
name|PROP_END
expr_stmt|;
return|return
operator|(
name|scan_ptr
operator|)
return|;
block|}
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
comment|/* extract current token at scann_ptr position */
name|l_ptr
operator|=
name|scan_ptr
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
operator|(
name|MAX_LINE_LEN
operator|-
literal|1
operator|)
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|':'
operator|)
condition|)
block|{
break|break;
block|}
name|l_token
index|[
name|l_idx
index|]
operator|=
operator|(
operator|*
name|l_ptr
operator|)
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
name|l_token
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT:TOKEN:%s:"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
comment|/* check if token is one of the supported mnemonics */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|PROP_TABLE_ENTRIES
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|==
name|PTYP_NOT_SUPPORTED
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
literal|0
operator|!=
name|strcmp
argument_list|(
name|l_token
argument_list|,
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|prop_mnemonic
argument_list|)
condition|)
block|{
continue|continue;
block|}
operator|*
name|prop_id
operator|=
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|prop_id
expr_stmt|;
comment|/* scann parameters according to detected property type */
switch|switch
condition|(
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
condition|)
block|{
case|case
name|PTYP_BOOLEAN
case|:
name|param
operator|->
name|int_val1
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|':'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (bool property %s terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'!'
condition|)
comment|/* inverter character */
block|{
name|param
operator|->
name|int_val1
operator|=
name|FALSE
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTYP_3xINT
case|:
case|case
name|PTYP_2xINT
case|:
case|case
name|PTYP_INT
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (int property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
else|else
block|{
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|int_val1
operator|=
name|strtol
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Scan 1.st integer (base = 10) */
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (int property %s :integer value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PTYP_2xINT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
operator|||
operator|(
name|PTYP_3xINT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (int property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|int_val2
operator|=
name|strtol
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan 2.nd integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (int property %s : 2.nd integer value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTYP_3xINT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (int property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|int_val3
operator|=
name|strtol
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan 3.rd integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (int property %s : 3.rd integer value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PTYP_3xFLT
case|:
case|case
name|PTYP_2xFLT
case|:
case|case
name|PTYP_FLT
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (float property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
else|else
block|{
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|flt_val1
operator|=
name|strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (float property %s :float value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%f"
argument_list|,
name|param
operator|->
name|flt_val1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PTYP_2xFLT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
operator|||
operator|(
name|PTYP_3xFLT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (float property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|flt_val2
operator|=
name|strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (float property %s : 2.nd float value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%f"
argument_list|,
name|param
operator|->
name|flt_val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTYP_3xFLT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (float property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|flt_val3
operator|=
name|strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (float property %s : 3.rd float value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%f"
argument_list|,
name|param
operator|->
name|flt_val3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PTYP_STRING
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (string property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|'\"'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (string property %s starting \" is missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
for|for
control|(
name|l_ids
operator|=
literal|0
init|;
name|l_ids
operator|<
operator|(
name|MAX_LINE_LEN
operator|-
literal|1
operator|)
condition|;
name|l_ids
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|'\"'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\0'
operator|)
condition|)
block|{
break|break;
block|}
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
operator|*
name|l_ptr
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\"'
condition|)
block|{
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|string_val
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|l_string_buff
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|param
operator|->
name|string_val
argument_list|,
name|l_string_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|param
operator|->
name|string_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP syntax error (string property %s terminating \" is missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: ** Warning ** PRP file with unsupported property %s\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* advance l_ptr to next Blank    * (this is needed to skip unknown tokens     */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\0'
operator|)
condition|)
block|{
break|break;
block|}
name|l_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|prop_id
operator|==
name|PROP_SYNTAX_ERROR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: ** Warning ** PRP file skipping property: %s\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_scann_token */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_layer_prop  *   scann one inputline for layer properties (also used for layer_mask props)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_scann_layer_prop (char * scan_ptr,t_image_props * image_prop)
name|gint
name|p_scann_layer_prop
parameter_list|(
name|char
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|t_layer_props
modifier|*
name|l_new_prop
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|l_new_prop
operator|=
name|p_new_layer_prop
argument_list|()
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* add the new element to the layer_props list */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|layer_props
expr_stmt|;
name|image_prop
operator|->
name|layer_props
operator|=
name|l_new_prop
expr_stmt|;
if|if
condition|(
operator|*
name|scan_ptr
operator|==
literal|'L'
condition|)
block|{
name|l_new_prop
operator|->
name|has_alpha
operator|=
name|TRUE
expr_stmt|;
block|}
name|l_new_prop
operator|->
name|layer_pos
operator|=
name|strtol
argument_list|(
operator|&
name|scan_ptr
index|[
literal|1
index|]
argument_list|,
operator|&
name|l_ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|scan_ptr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP file layer# missing, scanned bad line:\n%s\n"
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_ACTIVE_LAYER
case|:
name|l_new_prop
operator|->
name|active_layer
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
name|l_new_prop
operator|->
name|floating_selection
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_ATTACHED
case|:
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|l_new_prop
operator|->
name|opacity
operator|=
name|l_param
operator|.
name|flt_val1
expr_stmt|;
break|break;
case|case
name|PROP_MODE
case|:
name|l_new_prop
operator|->
name|mode
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_LINKED
case|:
name|l_new_prop
operator|->
name|linked
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_PRESERVE_TRANSPARENCY
case|:
name|l_new_prop
operator|->
name|preserve_transparency
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_APPLY_MASK
case|:
name|l_new_prop
operator|->
name|apply_mask
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_EDIT_MASK
case|:
name|l_new_prop
operator|->
name|edit_mask
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASK
case|:
name|l_new_prop
operator|->
name|show_mask
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
name|l_new_prop
operator|->
name|offx
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
break|break;
case|case
name|PROP_NAME
case|:
name|l_new_prop
operator|->
name|name
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|l_new_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
default|default :
comment|/* fprintf(stderr, "XJT: PRP file scanned bad line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_layer_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_channel_prop  *   scann one inputline for channel properties (also used for layer_mask props)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_scann_channel_prop (char * scan_ptr,t_image_props * image_prop)
name|gint
name|p_scann_channel_prop
parameter_list|(
name|char
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|t_channel_props
modifier|*
name|l_new_prop
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|l_new_prop
operator|=
name|p_new_channel_prop
argument_list|()
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|l_new_prop
operator|->
name|channel_pos
operator|=
name|strtol
argument_list|(
operator|&
name|scan_ptr
index|[
literal|1
index|]
argument_list|,
operator|&
name|l_ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|scan_ptr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP file channel# missing, scanned bad line:\n%s\n"
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check if it is layer_mask or channel */
if|if
condition|(
operator|*
name|scan_ptr
operator|==
literal|'m'
condition|)
block|{
comment|/* add the new element to the mask_props list of the image */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|mask_props
expr_stmt|;
name|image_prop
operator|->
name|mask_props
operator|=
name|l_new_prop
expr_stmt|;
block|}
else|else
block|{
comment|/* add the new element to the channel_props list of the image */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|channel_props
expr_stmt|;
name|image_prop
operator|->
name|channel_props
operator|=
name|l_new_prop
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_ACTIVE_CHANNEL
case|:
name|l_new_prop
operator|->
name|active_channel
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_SELECTION
case|:
name|l_new_prop
operator|->
name|selection
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_ATTACHED
case|:
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|l_new_prop
operator|->
name|opacity
operator|=
name|l_param
operator|.
name|flt_val1
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
name|l_new_prop
operator|->
name|show_masked
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
name|l_new_prop
operator|->
name|offx
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
break|break;
case|case
name|PROP_COLOR
case|:
name|l_new_prop
operator|->
name|color_r
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_new_prop
operator|->
name|color_g
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
name|l_new_prop
operator|->
name|color_b
operator|=
name|l_param
operator|.
name|int_val3
expr_stmt|;
break|break;
case|case
name|PROP_NAME
case|:
name|l_new_prop
operator|->
name|name
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|l_new_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
default|default :
comment|/* fprintf(stderr, "XJT: PRP file scanned bad line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_channel_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_image_prop  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_scann_image_prop (char * scan_ptr,t_image_props * image_prop)
name|gint
name|p_scann_image_prop
parameter_list|(
name|char
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|t_guide_props
modifier|*
name|l_guide_prop
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|scan_ptr
argument_list|,
name|GIMP_XJ_IMAGE
argument_list|,
name|strlen
argument_list|(
name|GIMP_XJ_IMAGE
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP file %s identstring missing, scanned bad line:\n%s\n"
argument_list|,
name|GIMP_XJ_IMAGE
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_ptr
operator|=
operator|&
name|scan_ptr
index|[
name|strlen
argument_list|(
name|GIMP_XJ_IMAGE
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_VERSION
case|:
name|image_prop
operator|->
name|version
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_TYPE
case|:
name|image_prop
operator|->
name|image_type
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
switch|switch
condition|(
name|image_prop
operator|->
name|image_type
condition|)
block|{
case|case
name|RGB_IMAGE
case|:
case|case
name|GRAY_IMAGE
case|:
case|case
name|RGBA_IMAGE
case|:
case|case
name|GRAYA_IMAGE
case|:
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: PRP unsupported image_type %d\n"
argument_list|,
operator|(
name|int
operator|)
name|image_prop
operator|->
name|image_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
break|break;
case|case
name|PROP_DIMENSION
case|:
name|image_prop
operator|->
name|image_width
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|image_prop
operator|->
name|image_height
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
break|break;
case|case
name|PROP_GUIDES
case|:
name|l_guide_prop
operator|=
name|p_new_guide_prop
argument_list|()
expr_stmt|;
if|if
condition|(
name|l_guide_prop
condition|)
block|{
name|l_guide_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|guide_props
expr_stmt|;
name|image_prop
operator|->
name|guide_props
operator|=
name|l_guide_prop
expr_stmt|;
name|l_guide_prop
operator|->
name|position
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_guide_prop
operator|->
name|orientation
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
name|image_prop
operator|->
name|xresolution
operator|=
name|l_param
operator|.
name|flt_val1
expr_stmt|;
name|image_prop
operator|->
name|yresolution
operator|=
name|l_param
operator|.
name|flt_val2
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|image_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
default|default :
comment|/* fprintf(stderr, "XJT: Warning PRP unexpected token in line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_image_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_load_prop_file  *   read all properties from file "PRP"  *   and return the information in a t_image_props stucture  * ============================================================================  */
end_comment

begin_function
DECL|function|p_load_prop_file (char * prop_filename)
name|t_image_props
modifier|*
name|p_load_prop_file
parameter_list|(
name|char
modifier|*
name|prop_filename
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp_prp
decl_stmt|;
name|char
name|l_file_buffer
index|[
name|MAX_LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|char
modifier|*
name|l_ret
decl_stmt|;
name|t_image_props
modifier|*
name|l_image_prop
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"p_load_prop_file: %s\n"
argument_list|,
name|prop_filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_image_prop
operator|=
name|p_new_image_prop
argument_list|()
expr_stmt|;
if|if
condition|(
name|l_image_prop
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|l_fp_prp
operator|=
name|fopen
argument_list|(
name|prop_filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp_prp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: Error, No Properties %s found\n"
argument_list|,
name|prop_filename
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* read and parse 1.st line (image properties) */
name|l_ret
operator|=
name|fgets
argument_list|(
name|l_file_buffer
argument_list|,
operator|(
name|MAX_LINE_LEN
operator|-
literal|1
operator|)
argument_list|,
name|l_fp_prp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ret
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: Error, %s is empty\n"
argument_list|,
name|prop_filename
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"\nXJT:PRP_LINE:%s:\n"
argument_list|,
name|l_file_buffer
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_scann_image_prop
argument_list|(
name|l_file_buffer
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|l_ret
operator|=
name|fgets
argument_list|(
name|l_file_buffer
argument_list|,
operator|(
name|MAX_LINE_LEN
operator|-
literal|1
operator|)
argument_list|,
name|l_fp_prp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ret
operator|==
name|NULL
condition|)
block|{
break|break;
comment|/* end of file */
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"\nXJT:PRP_LINE:%s:\n"
argument_list|,
name|l_file_buffer
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
operator|&
name|l_file_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* skip commentlines */
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* skip empty lines */
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* skip empty lines */
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|'l'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'L'
operator|)
condition|)
block|{
name|l_rc
operator|=
name|p_scann_layer_prop
argument_list|(
name|l_file_buffer
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
name|l_image_prop
operator|->
name|n_layers
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|'c'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'m'
operator|)
condition|)
block|{
name|l_rc
operator|=
name|p_scann_channel_prop
argument_list|(
name|l_file_buffer
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
name|l_image_prop
operator|->
name|n_channels
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XJT: Warning, undefined PRP line scanned:\n%s\n"
argument_list|,
name|l_file_buffer
argument_list|)
expr_stmt|;
comment|/* goto cleanup; */
block|}
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|l_fp_prp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|l_fp_prp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|l_image_prop
operator|)
return|;
block|}
return|return
name|NULL
return|;
comment|/* error */
block|}
end_function

begin_comment
comment|/* end p_load_prop_file */
end_comment

begin_comment
comment|/* ---------------------- LOAD  -------------------------- */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|load_xjt_image (char * filename)
name|load_xjt_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_len
decl_stmt|;
name|char
name|l_dirname
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_prop_file
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_jpg_file
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_cmd
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|l_name
decl_stmt|;
name|mode_t
name|l_mode_dir
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
modifier|*
name|l_channels_list
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_channel_id
decl_stmt|;
name|gint32
name|l_image_id
decl_stmt|;
name|gint32
name|l_fsel_attached_to_id
decl_stmt|;
comment|/* the drawable id where the floating selection is attached to */
name|gint32
name|l_fsel_id
decl_stmt|;
comment|/* the drawable id of the floating selection itself */
name|gint32
name|l_active_layer_id
decl_stmt|;
name|gint32
name|l_active_channel_id
decl_stmt|;
name|t_image_props
modifier|*
name|l_image_prp_ptr
decl_stmt|;
name|t_layer_props
modifier|*
name|l_layer_prp_ptr
decl_stmt|;
name|t_channel_props
modifier|*
name|l_channel_prp_ptr
decl_stmt|;
name|t_guide_props
modifier|*
name|l_guide_prp_ptr
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init retcode to Errorstate */
name|l_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_layers_list
operator|=
name|NULL
expr_stmt|;
name|l_channels_list
operator|=
name|NULL
expr_stmt|;
name|l_image_prp_ptr
operator|=
name|NULL
expr_stmt|;
name|l_active_layer_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_active_channel_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_fsel_attached_to_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1  assume fsel is not available (and not attached to any drawable) */
name|l_fsel_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1  assume there is no floating selection */
name|l_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_name
argument_list|,
literal|"Loading %s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
comment|/* create temporary directory<filename>.tmpdir.<PID> */
name|sprintf
argument_list|(
name|l_dirname
argument_list|,
literal|"%s.tmpdir.%d"
argument_list|,
name|filename
argument_list|,
operator|(
name|int
operator|)
name|g_pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_prop_file
argument_list|,
literal|"%s/PRP"
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|l_mode_dir
operator|=
literal|0777
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|l_dirname
argument_list|,
name|l_mode_dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"can't create working dir: %s\n"
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* prepare for extract tar files directly from filename into l_dirname */
if|if
condition|(
operator|*
name|filename
operator|==
literal|'/'
condition|)
block|{
comment|/* filename with absolute path */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"cd %s; tar -xf \"%s\"; cd .."
argument_list|,
name|l_dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* filename with relative path */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"cd %s; tar -xf \"../%s\" *; cd .."
argument_list|,
name|l_dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|l_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_len
operator|>
literal|3
condition|)
block|{
comment|/* call optional extracompression programs gzip or bzip2        * (depends on filename's extension)       *       * used gzip options: (bzip2 uses the same options)       *     -c --stdout --to-stdout       *          Write  output  on  standard  output       *     -d --decompress --uncompress       *          Decompress.       *     -f --force       *           Force compression or decompression even if the file       */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|3
index|]
argument_list|,
literal|"bz2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"bunzip2<\"%s\">\"%s/arc.tar\""
argument_list|,
name|filename
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"cd %s; tar -xf arc.tar; cd .."
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|2
index|]
argument_list|,
literal|"gz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"gzip -cdf<\"%s\">\"%s/arc.tar\""
argument_list|,
name|filename
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"cd %s; tar -xf arc.tar; cd .."
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now we can extract the unpacked tar archive */
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* check and read Property file (PRP must exist in each xjt archive) */
name|sprintf
argument_list|(
name|l_prop_file
argument_list|,
literal|"%s/PRP"
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|l_image_prp_ptr
operator|=
name|p_load_prop_file
argument_list|(
name|l_prop_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_image_prp_ptr
operator|==
name|NULL
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* create new image (with type and size values from the Property file) */
name|l_image_id
operator|=
name|gimp_image_new
argument_list|(
name|l_image_prp_ptr
operator|->
name|image_width
argument_list|,
name|l_image_prp_ptr
operator|->
name|image_height
argument_list|,
name|l_image_prp_ptr
operator|->
name|image_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_image_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|gimp_image_set_filename
argument_list|(
name|l_image_id
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|p_gimp_image_set_resolution
argument_list|(
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|xresolution
argument_list|,
name|l_image_prp_ptr
operator|->
name|yresolution
argument_list|)
expr_stmt|;
comment|/* load all layers */
for|for
control|(
name|l_layer_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|layer_props
init|;
name|l_layer_prp_ptr
operator|!=
name|NULL
condition|;
name|l_layer_prp_ptr
operator|=
operator|(
name|t_layer_props
operator|*
operator|)
name|l_layer_prp_ptr
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/l%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
operator|(
name|int
operator|)
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading layer from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
name|l_layer_id
operator|=
name|xjpg_load_layer
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|image_type
argument_list|,
name|l_layer_prp_ptr
operator|->
name|name
argument_list|,
name|l_layer_prp_ptr
operator|->
name|opacity
argument_list|,
name|l_layer_prp_ptr
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|floating_selection
condition|)
block|{
name|l_fsel_id
operator|=
name|l_layer_id
expr_stmt|;
comment|/* this layer is the floating selection */
block|}
else|else
block|{
comment|/* add the layer on top of the images layerstak */
name|gimp_image_add_layer
argument_list|(
name|l_image_id
argument_list|,
name|l_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|floating_attached
condition|)
block|{
name|l_fsel_attached_to_id
operator|=
name|l_layer_id
expr_stmt|;
comment|/* the floating selection is attached to this layer */
block|}
block|}
comment|/* check for alpha channel */
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|has_alpha
condition|)
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/la%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
operator|(
name|int
operator|)
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading alpha-channel from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjpg_load_layer_alpha
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
name|l_layer_id
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* adjust offsets and other layerproperties */
name|gimp_layer_set_offsets
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|offx
argument_list|,
name|l_layer_prp_ptr
operator|->
name|offy
argument_list|)
expr_stmt|;
name|gimp_layer_set_visible
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|visible
argument_list|)
expr_stmt|;
name|p_layer_set_linked
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|linked
argument_list|)
expr_stmt|;
name|gimp_layer_set_preserve_transparency
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|preserve_transparency
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|active_layer
condition|)
block|{
name|l_active_layer_id
operator|=
name|l_layer_id
expr_stmt|;
block|}
comment|/* search for the properties of the layermask */
for|for
control|(
name|l_channel_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|mask_props
init|;
name|l_channel_prp_ptr
operator|!=
name|NULL
condition|;
name|l_channel_prp_ptr
operator|=
operator|(
name|t_channel_props
operator|*
operator|)
name|l_channel_prp_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|channel_pos
operator|==
name|l_layer_prp_ptr
operator|->
name|layer_pos
condition|)
block|{
comment|/* layermask properties found: load the layermask */
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/lm%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
operator|(
name|int
operator|)
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading layer-mask from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
name|l_channel_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|l_layer_id
argument_list|,
literal|0
comment|/* mask_type 0 = WHITE_MASK */
argument_list|)
expr_stmt|;
comment|/* load should overwrite the layer_mask with data from jpeg file */
name|l_channel_id
operator|=
name|xjpg_load_channel
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|name
argument_list|,
name|l_channel_prp_ptr
operator|->
name|opacity
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_r
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_g
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_id
operator|>=
literal|0
condition|)
block|{
comment|/* attach the layer_mask to the layer (with identical offsets) */
name|gimp_image_add_layer_mask
argument_list|(
name|l_image_id
argument_list|,
name|l_layer_id
argument_list|,
name|l_channel_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|floating_attached
condition|)
block|{
name|l_fsel_attached_to_id
operator|=
name|l_channel_id
expr_stmt|;
comment|/* the floating selection is attached to this layer_mask */
block|}
comment|/* gimp_layer_set_offsets(l_channel_id, l_layer_prp_ptr->offx, l_layer_prp_ptr->offy); */
name|gimp_layer_set_apply_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|apply_mask
argument_list|)
expr_stmt|;
name|gimp_layer_set_edit_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|edit_mask
argument_list|)
expr_stmt|;
name|gimp_layer_set_show_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|show_mask
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* end search for layermask */
block|}
comment|/* load all channels */
for|for
control|(
name|l_channel_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|channel_props
init|;
name|l_channel_prp_ptr
operator|!=
name|NULL
condition|;
name|l_channel_prp_ptr
operator|=
operator|(
name|t_channel_props
operator|*
operator|)
name|l_channel_prp_ptr
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|l_jpg_file
argument_list|,
literal|"%s/c%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
operator|(
name|int
operator|)
name|l_channel_prp_ptr
operator|->
name|channel_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading channel from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
name|l_channel_id
operator|=
name|xjpg_load_channel
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
operator|-
literal|1
argument_list|,
name|l_channel_prp_ptr
operator|->
name|name
argument_list|,
name|l_channel_prp_ptr
operator|->
name|opacity
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_r
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_g
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|selection
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: SELECTION loaded channel id = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_channel_id
argument_list|)
expr_stmt|;
name|p_gimp_selection_load
argument_list|(
name|l_image_id
argument_list|,
name|l_channel_id
argument_list|)
expr_stmt|;
comment|/* delete the channel after load into selection */
name|gimp_channel_delete
argument_list|(
name|l_channel_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add channel on top of the channelstack */
name|gimp_image_add_channel
argument_list|(
name|l_image_id
argument_list|,
name|l_channel_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust offsets and other channelproperties */
name|gimp_channel_set_visible
argument_list|(
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|visible
argument_list|)
expr_stmt|;
name|gimp_channel_set_show_masked
argument_list|(
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|show_masked
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|floating_attached
condition|)
block|{
name|l_fsel_attached_to_id
operator|=
name|l_channel_id
expr_stmt|;
comment|/* the floating_selection is attached to this channel */
block|}
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|active_channel
condition|)
block|{
name|l_active_channel_id
operator|=
name|l_channel_id
expr_stmt|;
block|}
block|}
block|}
comment|/* attach the floating selection... */
if|if
condition|(
operator|(
name|l_fsel_id
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|l_fsel_attached_to_id
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: attaching floating_selection id=%d to id %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_fsel_id
argument_list|,
operator|(
name|int
operator|)
name|l_fsel_attached_to_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_gimp_floating_sel_attach
argument_list|(
name|l_fsel_id
argument_list|,
name|l_fsel_attached_to_id
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* in case of error add floating_selection like an ordinary layer 	  * (if patches are not installed you'll get the error for sure) 	  */
name|printf
argument_list|(
literal|"XJT: floating_selection is added as top-layer (attach failed)\n"
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|l_image_id
argument_list|,
name|l_fsel_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set active layer/channel */
if|if
condition|(
name|l_active_channel_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"SET active channel\n"
argument_list|)
expr_stmt|;
name|gimp_image_set_active_channel
argument_list|(
name|l_image_id
argument_list|,
name|l_active_channel_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_active_layer_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"SET active layer\n"
argument_list|)
expr_stmt|;
name|gimp_image_set_active_layer
argument_list|(
name|l_image_id
argument_list|,
name|l_active_layer_id
argument_list|)
expr_stmt|;
block|}
comment|/* set guides     * You need GIMP 1.1 or higher for that feature     * (in GIMP 1.0.2 there is no interface for that job     * and guides will be ignored.)     */
for|for
control|(
name|l_guide_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|guide_props
init|;
name|l_guide_prp_ptr
operator|!=
name|NULL
condition|;
name|l_guide_prp_ptr
operator|=
operator|(
name|t_guide_props
operator|*
operator|)
name|l_guide_prp_ptr
operator|->
name|next
control|)
block|{
name|p_gimp_image_add_guide
argument_list|(
name|l_image_id
argument_list|,
name|l_guide_prp_ptr
operator|->
name|position
argument_list|,
name|l_guide_prp_ptr
operator|->
name|orientation
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|l_layers_list
condition|)
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channels_list
condition|)
name|g_free
argument_list|(
name|l_channels_list
argument_list|)
expr_stmt|;
comment|/* remove the temorary directory */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"rm -rf \"%s\""
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|l_image_id
operator|)
return|;
comment|/* all done OK */
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_image_id
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* end load_xjt_image */
end_comment

end_unit

