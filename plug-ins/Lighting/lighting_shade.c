begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Shading stuff */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<gck/gck.h>
end_include

begin_include
include|#
directive|include
file|"lighting_main.h"
end_include

begin_include
include|#
directive|include
file|"lighting_image.h"
end_include

begin_include
include|#
directive|include
file|"lighting_shade.h"
end_include

begin_decl_stmt
DECL|variable|triangle_normals
specifier|static
name|GimpVector3
modifier|*
name|triangle_normals
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vertex_normals
specifier|static
name|GimpVector3
modifier|*
name|vertex_normals
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|heights
specifier|static
name|gdouble
modifier|*
name|heights
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xstep
DECL|variable|ystep
specifier|static
name|gdouble
name|xstep
decl_stmt|,
name|ystep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bumprow
specifier|static
name|guchar
modifier|*
name|bumprow
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pre_w
specifier|static
name|gint
name|pre_w
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pre_h
specifier|static
name|gint
name|pre_h
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Phong shading */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_function
specifier|static
name|GckRGB
DECL|function|phong_shade (GimpVector3 * position,GimpVector3 * viewpoint,GimpVector3 * normal,GimpVector3 * lightposition,GckRGB * diff_col,GckRGB * spec_col,LightType light_type)
name|phong_shade
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|,
name|GimpVector3
modifier|*
name|viewpoint
parameter_list|,
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|GimpVector3
modifier|*
name|lightposition
parameter_list|,
name|GckRGB
modifier|*
name|diff_col
parameter_list|,
name|GckRGB
modifier|*
name|spec_col
parameter_list|,
name|LightType
name|light_type
parameter_list|)
block|{
name|GckRGB
name|ambient_color
decl_stmt|,
name|diffuse_color
decl_stmt|,
name|specular_color
decl_stmt|;
name|gdouble
name|nl
decl_stmt|,
name|rv
decl_stmt|,
name|dist
decl_stmt|;
name|GimpVector3
name|l
decl_stmt|,
name|nn
decl_stmt|,
name|v
decl_stmt|,
name|n
decl_stmt|;
comment|/* Compute ambient intensity */
comment|/* ========================= */
name|n
operator|=
operator|*
name|normal
expr_stmt|;
name|ambient_color
operator|=
operator|*
name|diff_col
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|ambient_color
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
comment|/* Compute (N*L) term of Phong's equation */
comment|/* ====================================== */
if|if
condition|(
name|light_type
operator|==
name|POINT_LIGHT
condition|)
name|gimp_vector3_sub
argument_list|(
operator|&
name|l
argument_list|,
name|lightposition
argument_list|,
name|position
argument_list|)
expr_stmt|;
else|else
name|l
operator|=
operator|*
name|lightposition
expr_stmt|;
name|dist
operator|=
name|gimp_vector3_length
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|!=
literal|0.0
condition|)
name|gimp_vector3_mul
argument_list|(
operator|&
name|l
argument_list|,
literal|1.0
operator|/
name|dist
argument_list|)
expr_stmt|;
name|nl
operator|=
literal|2.0
operator|*
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>=
literal|0.0
condition|)
block|{
comment|/* Compute (R*V)^alpha term of Phong's equation */
comment|/* ============================================ */
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|gimp_vector3_mul
argument_list|(
operator|&
name|n
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|nn
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|rv
operator|=
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|nn
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pow
argument_list|(
name|rv
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|highlight
argument_list|)
expr_stmt|;
comment|/* Compute diffuse and specular intensity contribution */
comment|/* =================================================== */
name|diffuse_color
operator|=
operator|*
name|diff_col
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|diffuse_color
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_ref
argument_list|)
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|diffuse_color
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|specular_color
operator|=
operator|*
name|spec_col
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|specular_color
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|specular_ref
argument_list|)
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|specular_color
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|gck_rgb_add
argument_list|(
operator|&
name|diffuse_color
argument_list|,
operator|&
name|specular_color
argument_list|)
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|diffuse_color
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
argument_list|)
expr_stmt|;
name|gck_rgb_clamp
argument_list|(
operator|&
name|diffuse_color
argument_list|)
expr_stmt|;
name|gck_rgb_add
argument_list|(
operator|&
name|ambient_color
argument_list|,
operator|&
name|diffuse_color
argument_list|)
expr_stmt|;
block|}
name|gck_rgb_clamp
argument_list|(
operator|&
name|ambient_color
argument_list|)
expr_stmt|;
return|return
name|ambient_color
return|;
block|}
end_function

begin_comment
comment|/* static void get_normal (gdouble      xf, 	    gdouble      yf, 	    GimpVector3 *normal) {   GimpVector3 v1,v2,n;   gint numvecs=0,x,y,f;   gdouble val,val1=-1.0,val2=-1.0,val3=-1.0,val4=-1.0, xstep,ystep;    x=(gint)(xf+0.5);   y=(gint)(yf+0.5);    xstep=1.0/(gdouble)width;   ystep=1.0/(gdouble)height;    val=mapvals.bumpmax*get_map_value(&bump_region, xf,yf,&f)/255.0;   if (check_bounds(x-1,y)) val1=mapvals.bumpmax*get_map_value(&bump_region, xf-1.0,yf,&f)/255.0 - val;   if (check_bounds(x,y-1)) val2=mapvals.bumpmax*get_map_value(&bump_region, xf,yf-1.0,&f)/255.0 - val;   if (check_bounds(x+1,y)) val3=mapvals.bumpmax*get_map_value(&bump_region, xf+1.0,yf,&f)/255.0 - val;   if (check_bounds(x,y+1)) val4=mapvals.bumpmax*get_map_value(&bump_region, xf,yf+1.0,&f)/255.0 - val;    gimp_vector3_set(normal, 0.0,0.0,0.0);    if (val1!=-1.0&& val4!=-1.0)     {       v1.x=-xstep; v1.y=0.0; v1.z=val1;       v2.x=0.0; v2.y=ystep; v2.z=val4;       n=gimp_vector3_cross_product(&v1,&v2);       gimp_vector3_normalize(&n);              if (n.z<0.0)         n.z=-n.z;              gimp_vector3_add(normal,normal,&n);       numvecs++;     }    if (val1!=-1.0&& val2!=-1.0)     {       v1.x=-xstep; v1.y=0.0;    v1.z=val1;       v2.x=0.0;    v2.y=-ystep; v2.z=val2;       n=gimp_vector3_cross_product(&v1,&v2);       gimp_vector3_normalize(&n);              if (n.z<0.0)         n.z=-n.z;              gimp_vector3_add(normal,normal,&n);       numvecs++;     }    if (val2!=-1.0&& val3!=-1.0)     {       v1.x=0.0;   v1.y=-ystep; v1.z=val2;       v2.x=xstep; v2.y=0.0;    v2.z=val3;       n=gimp_vector3_cross_product(&v1,&v2);       gimp_vector3_normalize(&n);              if (n.z<0.0)         n.z=-n.z;              gimp_vector3_add(normal,normal,&n);       numvecs++;     }    if (val3!=-1.0&& val4!=-1.0)     {       v1.x=xstep; v1.y=0.0;   v1.z=val3;       v2.x=0.0;   v2.y=ystep; v2.z=val4;       n=gimp_vector3_cross_product(&v1,&v2);       gimp_vector3_normalize(&n);              if (n.z<0.0)         n.z=-n.z;              gimp_vector3_add(normal,normal,&n);       numvecs++;     }    gimp_vector3_mul(normal,1.0/(gdouble)numvecs);   gimp_vector3_normalize(normal); } */
end_comment

begin_function
name|void
DECL|function|precompute_init (gint w,gint h)
name|precompute_init
parameter_list|(
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|gint
name|n
decl_stmt|;
name|xstep
operator|=
literal|1.0
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|ystep
operator|=
literal|1.0
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|pre_w
operator|=
name|w
expr_stmt|;
name|pre_h
operator|=
name|h
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|3
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|vertex_normals
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|vertex_normals
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|heights
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|heights
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|heights
index|[
name|n
index|]
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|vertex_normals
index|[
name|n
index|]
operator|=
name|g_new
argument_list|(
name|GimpVector3
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|2
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|triangle_normals
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|triangle_normals
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bumprow
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|bumprow
argument_list|)
expr_stmt|;
name|bumprow
operator|=
name|NULL
expr_stmt|;
block|}
name|bumprow
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|triangle_normals
index|[
literal|0
index|]
operator|=
name|g_new
argument_list|(
name|GimpVector3
argument_list|,
operator|(
name|w
operator|<<
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
operator|=
name|g_new
argument_list|(
name|GimpVector3
argument_list|,
operator|(
name|w
operator|<<
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|w
operator|<<
literal|1
operator|)
operator|+
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|gimp_vector3_set
argument_list|(
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|w
condition|;
name|n
operator|++
control|)
block|{
name|gimp_vector3_set
argument_list|(
operator|&
name|vertex_normals
index|[
literal|0
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|vertex_normals
index|[
literal|1
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|vertex_normals
index|[
literal|2
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|heights
index|[
literal|0
index|]
index|[
name|n
index|]
operator|=
literal|0.0
expr_stmt|;
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
operator|=
literal|0.0
expr_stmt|;
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************/
end_comment

begin_comment
comment|/* Compute triangle and then vertex normals */
end_comment

begin_comment
comment|/********************************************/
end_comment

begin_function
name|void
DECL|function|precompute_normals (gint x1,gint x2,gint y)
name|precompute_normals
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpVector3
modifier|*
name|tmpv
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|normal
decl_stmt|;
name|gdouble
modifier|*
name|tmpd
decl_stmt|;
name|gint
name|n
decl_stmt|,
name|i
decl_stmt|,
name|nv
decl_stmt|;
name|guchar
modifier|*
name|map
init|=
name|NULL
decl_stmt|;
comment|/* First, compute the heights */
comment|/* ========================== */
name|tmpv
operator|=
name|triangle_normals
index|[
literal|0
index|]
expr_stmt|;
name|triangle_normals
index|[
literal|0
index|]
operator|=
name|triangle_normals
index|[
literal|1
index|]
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
operator|=
name|tmpv
expr_stmt|;
name|tmpv
operator|=
name|vertex_normals
index|[
literal|0
index|]
expr_stmt|;
name|vertex_normals
index|[
literal|0
index|]
operator|=
name|vertex_normals
index|[
literal|1
index|]
expr_stmt|;
name|vertex_normals
index|[
literal|1
index|]
operator|=
name|vertex_normals
index|[
literal|2
index|]
expr_stmt|;
name|vertex_normals
index|[
literal|2
index|]
operator|=
name|tmpv
expr_stmt|;
name|tmpd
operator|=
name|heights
index|[
literal|0
index|]
expr_stmt|;
name|heights
index|[
literal|0
index|]
operator|=
name|heights
index|[
literal|1
index|]
expr_stmt|;
name|heights
index|[
literal|1
index|]
operator|=
name|heights
index|[
literal|2
index|]
expr_stmt|;
name|heights
index|[
literal|2
index|]
operator|=
name|tmpd
expr_stmt|;
comment|/*  printf("Get row (%d,%d,%d) to %p\n",x1,y,x2-x1,bumprow); */
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|bump_region
argument_list|,
name|bumprow
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bumpmaptype
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|mapvals
operator|.
name|bumpmaptype
condition|)
block|{
case|case
literal|1
case|:
name|map
operator|=
name|logmap
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|map
operator|=
name|sinemap
expr_stmt|;
break|break;
default|default:
name|map
operator|=
name|spheremap
expr_stmt|;
break|break;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|)
condition|;
name|n
operator|++
control|)
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|=
operator|(
name|gdouble
operator|)
name|mapvals
operator|.
name|bumpmax
operator|*
operator|(
name|gdouble
operator|)
name|map
index|[
name|bumprow
index|[
name|n
index|]
index|]
operator|/
literal|255.0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|)
condition|;
name|n
operator|++
control|)
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|=
operator|(
name|gdouble
operator|)
name|mapvals
operator|.
name|bumpmax
operator|*
operator|(
name|gdouble
operator|)
name|bumprow
index|[
name|n
index|]
operator|/
literal|255.0
expr_stmt|;
block|}
comment|/* Compute triangle normals */
comment|/* ======================== */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|-
literal|1
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|p1
operator|.
name|x
operator|=
literal|0.0
expr_stmt|;
name|p1
operator|.
name|y
operator|=
name|ystep
expr_stmt|;
name|p1
operator|.
name|z
operator|=
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|-
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
name|p2
operator|.
name|x
operator|=
name|xstep
expr_stmt|;
name|p2
operator|.
name|y
operator|=
name|ystep
expr_stmt|;
name|p2
operator|.
name|z
operator|=
name|heights
index|[
literal|2
index|]
index|[
name|n
operator|+
literal|1
index|]
operator|-
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
name|p3
operator|.
name|x
operator|=
name|xstep
expr_stmt|;
name|p3
operator|.
name|y
operator|=
literal|0.0
expr_stmt|;
name|p3
operator|.
name|z
operator|=
name|heights
index|[
literal|1
index|]
index|[
name|n
operator|+
literal|1
index|]
operator|-
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|p2
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|p3
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Compute vertex normals */
comment|/* ====================== */
name|i
operator|=
literal|0
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|normal
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|-
literal|1
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|nv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|nv
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
name|pre_h
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nv
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
name|pre_w
condition|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|nv
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
name|pre_h
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|nv
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|gimp_vector3_mul
argument_list|(
operator|&
name|normal
argument_list|,
literal|1.0
operator|/
operator|(
name|gdouble
operator|)
name|nv
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|vertex_normals
index|[
literal|1
index|]
index|[
name|n
index|]
operator|=
name|normal
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Compute the reflected ray given the normalized normal and ins. vec. */
end_comment

begin_comment
comment|/***********************************************************************/
end_comment

begin_function
specifier|static
name|GimpVector3
DECL|function|compute_reflected_ray (GimpVector3 * normal,GimpVector3 * view)
name|compute_reflected_ray
parameter_list|(
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|GimpVector3
modifier|*
name|view
parameter_list|)
block|{
name|GimpVector3
name|ref
decl_stmt|;
name|gdouble
name|nl
decl_stmt|;
name|nl
operator|=
literal|2.0
operator|*
name|gimp_vector3_inner_product
argument_list|(
name|normal
argument_list|,
name|view
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|*
name|normal
expr_stmt|;
name|gimp_vector3_mul
argument_list|(
operator|&
name|ref
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|ref
argument_list|,
operator|&
name|ref
argument_list|,
name|view
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Given the NorthPole, Equator and a third vector (normal) compute     */
end_comment

begin_comment
comment|/* the conversion from spherical coordinates to image space coordinates */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|sphere_to_image (GimpVector3 * normal,gdouble * u,gdouble * v)
name|sphere_to_image
parameter_list|(
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
specifier|static
name|gdouble
name|alpha
decl_stmt|,
name|fac
decl_stmt|;
specifier|static
name|GimpVector3
name|cross_prod
decl_stmt|;
specifier|static
name|GimpVector3
name|firstaxis
init|=
block|{
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
decl_stmt|;
specifier|static
name|GimpVector3
name|secondaxis
init|=
block|{
literal|0.0
block|,
literal|1.0
block|,
literal|0.0
block|}
decl_stmt|;
name|alpha
operator|=
name|acos
argument_list|(
operator|-
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|secondaxis
argument_list|,
name|normal
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|alpha
operator|/
name|G_PI
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0.0
operator|||
operator|*
name|v
operator|==
literal|1.0
condition|)
block|{
operator|*
name|u
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|fac
operator|=
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|firstaxis
argument_list|,
name|normal
argument_list|)
operator|/
name|sin
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
comment|/* Make sure that we map to -1.0..1.0 (take care of rounding errors) */
comment|/* ================================================================= */
if|if
condition|(
name|fac
operator|>
literal|1.0
condition|)
name|fac
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|fac
operator|<
operator|-
literal|1.0
condition|)
name|fac
operator|=
operator|-
literal|1.0
expr_stmt|;
operator|*
name|u
operator|=
name|acos
argument_list|(
name|fac
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|G_PI
operator|)
expr_stmt|;
name|cross_prod
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|secondaxis
argument_list|,
operator|&
name|firstaxis
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|cross_prod
argument_list|,
name|normal
argument_list|)
operator|<
literal|0.0
condition|)
operator|*
name|u
operator|=
literal|1.0
operator|-
operator|*
name|u
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/* These routines computes the color of the surface at a given point */
end_comment

begin_comment
comment|/*********************************************************************/
end_comment

begin_function
name|GckRGB
DECL|function|get_ray_color (GimpVector3 * position)
name|get_ray_color
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GckRGB
name|color
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|f
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|color
operator|.
name|a
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|get_image_color
argument_list|(
name|xf
argument_list|,
name|yf
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|direction
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
block|{
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|xf
argument_list|)
index|]
expr_stmt|;
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|color
return|;
block|}
end_function

begin_function
name|GckRGB
DECL|function|get_ray_color_ref (GimpVector3 * position)
name|get_ray_color_ref
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GckRGB
name|color
decl_stmt|,
name|env_color
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|f
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|color
operator|.
name|a
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|get_image_color
argument_list|(
name|xf
argument_list|,
name|yf
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|direction
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
block|{
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|xf
argument_list|)
index|]
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|compute_reflected_ray
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* Get color in the direction of r */
comment|/* =============================== */
name|sphere_to_image
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|env_color
operator|=
name|peek_env_map
argument_list|(
name|RINT
argument_list|(
name|env_width
operator|*
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|env_height
operator|*
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|env_color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|color
return|;
block|}
end_function

begin_function
name|GckRGB
DECL|function|get_ray_color_no_bilinear (GimpVector3 * position)
name|get_ray_color_no_bilinear
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GckRGB
name|color
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|color
operator|.
name|a
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|peek
argument_list|(
name|x
argument_list|,
name|RINT
argument_list|(
name|yf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|direction
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
block|{
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
name|x
index|]
expr_stmt|;
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|color
return|;
block|}
end_function

begin_function
name|GckRGB
DECL|function|get_ray_color_no_bilinear_ref (GimpVector3 * position)
name|get_ray_color_no_bilinear_ref
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GckRGB
name|color
decl_stmt|,
name|env_color
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|color
operator|.
name|a
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|peek
argument_list|(
name|RINT
argument_list|(
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|yf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|direction
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
block|{
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|color
operator|=
name|peek
argument_list|(
name|RINT
argument_list|(
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|compute_reflected_ray
argument_list|(
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* Get color in the direction of r */
comment|/* =============================== */
name|sphere_to_image
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|env_color
operator|=
name|peek_env_map
argument_list|(
name|RINT
argument_list|(
name|env_width
operator|*
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|env_height
operator|*
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
name|p
argument_list|,
operator|&
name|env_color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|xf
argument_list|)
index|]
expr_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|color
operator|=
name|peek
argument_list|(
name|RINT
argument_list|(
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|compute_reflected_ray
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* Get color in the direction of r */
comment|/* =============================== */
name|sphere_to_image
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|env_color
operator|=
name|peek_env_map
argument_list|(
name|RINT
argument_list|(
name|env_width
operator|*
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|env_height
operator|*
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|env_color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|color
return|;
block|}
end_function

end_unit

