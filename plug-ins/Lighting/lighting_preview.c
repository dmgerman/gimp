begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************/
end_comment

begin_comment
comment|/* Compute a preview image and preview wireframe */
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<gck/gck.h>
end_include

begin_include
include|#
directive|include
file|"lighting_main.h"
end_include

begin_include
include|#
directive|include
file|"lighting_ui.h"
end_include

begin_include
include|#
directive|include
file|"lighting_image.h"
end_include

begin_include
include|#
directive|include
file|"lighting_apply.h"
end_include

begin_include
include|#
directive|include
file|"lighting_shade.h"
end_include

begin_include
include|#
directive|include
file|"lighting_preview.h"
end_include

begin_decl_stmt
DECL|variable|lightx
DECL|variable|lighty
name|gint
name|lightx
decl_stmt|,
name|lighty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|backbuf
name|BackBuffer
name|backbuf
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* g_free()'ed on exit */
end_comment

begin_decl_stmt
DECL|variable|xpostab
name|gdouble
modifier|*
name|xpostab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ypostab
name|gdouble
modifier|*
name|ypostab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xpostab_size
specifier|static
name|gint
name|xpostab_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|xpostab_size
comment|/* if preview size change, do realloc */
end_comment

begin_decl_stmt
DECL|variable|ypostab_size
specifier|static
name|gint
name|ypostab_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protos */
end_comment

begin_comment
comment|/* ====== */
end_comment

begin_function
specifier|static
name|void
DECL|function|compute_preview (gint startx,gint starty,gint w,gint h)
name|compute_preview
parameter_list|(
name|gint
name|startx
parameter_list|,
name|gint
name|starty
parameter_list|,
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|gint
name|xcnt
decl_stmt|,
name|ycnt
decl_stmt|,
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|gdouble
name|imagex
decl_stmt|,
name|imagey
decl_stmt|;
name|gint32
name|index
init|=
literal|0
decl_stmt|;
name|GckRGB
name|color
decl_stmt|,
name|darkcheck
decl_stmt|,
name|lightcheck
decl_stmt|,
name|temp
decl_stmt|;
name|GimpVector3
name|pos
decl_stmt|;
name|get_ray_func
name|ray_func
decl_stmt|;
if|if
condition|(
name|xpostab_size
operator|!=
name|w
condition|)
block|{
if|if
condition|(
name|xpostab
condition|)
block|{
name|g_free
argument_list|(
name|xpostab
argument_list|)
expr_stmt|;
name|xpostab
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|xpostab
condition|)
block|{
name|xpostab
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|w
argument_list|)
expr_stmt|;
name|xpostab_size
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|ypostab_size
operator|!=
name|h
condition|)
block|{
if|if
condition|(
name|ypostab
condition|)
block|{
name|g_free
argument_list|(
name|ypostab
argument_list|)
expr_stmt|;
name|ypostab
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ypostab
condition|)
block|{
name|ypostab
operator|=
operator|(
name|gdouble
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|h
argument_list|)
expr_stmt|;
name|ypostab_size
operator|=
name|h
expr_stmt|;
block|}
for|for
control|(
name|xcnt
operator|=
literal|0
init|;
name|xcnt
operator|<
name|w
condition|;
name|xcnt
operator|++
control|)
name|xpostab
index|[
name|xcnt
index|]
operator|=
operator|(
name|gdouble
operator|)
name|width
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|xcnt
operator|/
operator|(
name|gdouble
operator|)
name|w
operator|)
expr_stmt|;
for|for
control|(
name|ycnt
operator|=
literal|0
init|;
name|ycnt
operator|<
name|h
condition|;
name|ycnt
operator|++
control|)
name|ypostab
index|[
name|ycnt
index|]
operator|=
operator|(
name|gdouble
operator|)
name|height
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|ycnt
operator|/
operator|(
name|gdouble
operator|)
name|h
operator|)
expr_stmt|;
name|init_compute
argument_list|()
expr_stmt|;
name|precompute_init
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|gck_rgb_set
argument_list|(
operator|&
name|lightcheck
argument_list|,
literal|0.75
argument_list|,
literal|0.75
argument_list|,
literal|0.75
argument_list|)
expr_stmt|;
name|gck_rgb_set
argument_list|(
operator|&
name|darkcheck
argument_list|,
literal|0.50
argument_list|,
literal|0.50
argument_list|,
literal|0.50
argument_list|)
expr_stmt|;
name|gck_rgb_set
argument_list|(
operator|&
name|color
argument_list|,
literal|0.3
argument_list|,
literal|0.7
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|bumpmap_id
operator|!=
operator|-
literal|1
condition|)
block|{
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|bump_region
argument_list|,
name|gimp_drawable_get
argument_list|(
name|mapvals
operator|.
name|bumpmap_id
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|imagey
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|previewquality
condition|)
name|ray_func
operator|=
name|get_ray_color
expr_stmt|;
else|else
name|ray_func
operator|=
name|get_ray_color_no_bilinear
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|env_mapped
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|envmap_id
operator|!=
operator|-
literal|1
condition|)
block|{
name|env_width
operator|=
name|gimp_drawable_width
argument_list|(
name|mapvals
operator|.
name|envmap_id
argument_list|)
expr_stmt|;
name|env_height
operator|=
name|gimp_drawable_height
argument_list|(
name|mapvals
operator|.
name|envmap_id
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|env_region
argument_list|,
name|gimp_drawable_get
argument_list|(
name|mapvals
operator|.
name|envmap_id
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|env_width
argument_list|,
name|env_height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|previewquality
condition|)
name|ray_func
operator|=
name|get_ray_color_ref
expr_stmt|;
else|else
name|ray_func
operator|=
name|get_ray_color_no_bilinear_ref
expr_stmt|;
block|}
for|for
control|(
name|ycnt
operator|=
literal|0
init|;
name|ycnt
operator|<
name|PREVIEW_HEIGHT
condition|;
name|ycnt
operator|++
control|)
block|{
for|for
control|(
name|xcnt
operator|=
literal|0
init|;
name|xcnt
operator|<
name|PREVIEW_WIDTH
condition|;
name|xcnt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ycnt
operator|>=
name|starty
operator|&&
name|ycnt
operator|<
operator|(
name|starty
operator|+
name|h
operator|)
operator|)
operator|&&
operator|(
name|xcnt
operator|>=
name|startx
operator|&&
name|xcnt
operator|<
operator|(
name|startx
operator|+
name|w
operator|)
operator|)
condition|)
block|{
name|imagex
operator|=
name|xpostab
index|[
name|xcnt
operator|-
name|startx
index|]
expr_stmt|;
name|imagey
operator|=
name|ypostab
index|[
name|ycnt
operator|-
name|starty
index|]
expr_stmt|;
name|pos
operator|=
name|int_to_posf
argument_list|(
name|imagex
argument_list|,
name|imagey
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|bumpmap_id
operator|!=
operator|-
literal|1
operator|&&
name|xcnt
operator|==
name|startx
condition|)
block|{
name|pos_to_float
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|imagex
argument_list|,
operator|&
name|imagey
argument_list|)
expr_stmt|;
name|precompute_normals
argument_list|(
literal|0
argument_list|,
name|width
argument_list|,
call|(
name|gint
call|)
argument_list|(
name|imagey
operator|+
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|color
operator|=
call|(
modifier|*
name|ray_func
call|)
argument_list|(
operator|&
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
operator|.
name|a
operator|<
literal|1.0
condition|)
block|{
name|f1
operator|=
operator|(
operator|(
name|xcnt
operator|%
literal|32
operator|)
operator|<
literal|16
operator|)
expr_stmt|;
name|f2
operator|=
operator|(
operator|(
name|ycnt
operator|%
literal|32
operator|)
operator|<
literal|16
operator|)
expr_stmt|;
name|f1
operator|=
name|f1
operator|^
name|f2
expr_stmt|;
if|if
condition|(
name|f1
condition|)
block|{
if|if
condition|(
name|color
operator|.
name|a
operator|==
literal|0.0
condition|)
name|color
operator|=
name|lightcheck
expr_stmt|;
else|else
block|{
name|gck_rgb_mul
argument_list|(
operator|&
name|color
argument_list|,
name|color
operator|.
name|a
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lightcheck
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|temp
argument_list|,
literal|1.0
operator|-
name|color
operator|.
name|a
argument_list|)
expr_stmt|;
name|gck_rgb_add
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|color
operator|.
name|a
operator|==
literal|0.0
condition|)
name|color
operator|=
name|darkcheck
expr_stmt|;
else|else
block|{
name|gck_rgb_mul
argument_list|(
operator|&
name|color
argument_list|,
name|color
operator|.
name|a
argument_list|)
expr_stmt|;
name|temp
operator|=
name|darkcheck
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|temp
argument_list|,
literal|1.0
operator|-
name|color
operator|.
name|a
argument_list|)
expr_stmt|;
name|gck_rgb_add
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|preview_rgb_data
index|[
name|index
operator|++
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
literal|255.0
operator|*
name|color
operator|.
name|r
argument_list|)
expr_stmt|;
name|preview_rgb_data
index|[
name|index
operator|++
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
literal|255.0
operator|*
name|color
operator|.
name|g
argument_list|)
expr_stmt|;
name|preview_rgb_data
index|[
name|index
operator|++
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
literal|255.0
operator|*
name|color
operator|.
name|b
argument_list|)
expr_stmt|;
name|imagex
operator|++
expr_stmt|;
block|}
else|else
block|{
name|preview_rgb_data
index|[
name|index
operator|++
index|]
operator|=
literal|200
expr_stmt|;
name|preview_rgb_data
index|[
name|index
operator|++
index|]
operator|=
literal|200
expr_stmt|;
name|preview_rgb_data
index|[
name|index
operator|++
index|]
operator|=
literal|200
expr_stmt|;
block|}
block|}
block|}
name|gck_rgb_to_gdkimage
argument_list|(
name|visinfo
argument_list|,
name|preview_rgb_data
argument_list|,
name|image
argument_list|,
name|PREVIEW_WIDTH
argument_list|,
name|PREVIEW_HEIGHT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static void blah (void) { */
end_comment

begin_comment
comment|/* First, compute the linear mapping (x,y,x+w,y+h) to (0,0,pw,ph) */
end_comment

begin_comment
comment|/* ============================================================== */
end_comment

begin_comment
comment|/*  realw=(p2.x-p1.x);   realh=(p2.y-p1.y);    for (xcnt=0;xcnt<pw;xcnt++)     xpostab[xcnt]=p1.x+realw*((double)xcnt/(double)pw);     for (ycnt=0;ycnt<ph;ycnt++)     ypostab[ycnt]=p1.y+realh*((double)ycnt/(double)ph); */
end_comment

begin_comment
comment|/* Compute preview using the offset tables */
end_comment

begin_comment
comment|/* ======================================= */
end_comment

begin_comment
comment|/*  if (mapvals.transparent_background==TRUE)     gck_rgba_set(&background,0.0,0.0,0.0,0.0);   else     {       gimp_palette_get_background(&r,&g,&b);       background.r=(gdouble)r/255.0;       background.g=(gdouble)g/255.0;       background.b=(gdouble)b/255.0;       background.a=1.0;     }    gck_rgb_set(&lightcheck,0.75,0.75,0.75);   gck_rgb_set(&darkcheck, 0.50,0.50,0.50);   gck_vector3_set(&p2,-1.0,-1.0,0.0);    for (ycnt=0;ycnt<ph;ycnt++)     {       for (xcnt=0;xcnt<pw;xcnt++)         {           p1.x=xpostab[xcnt];           p1.y=ypostab[ycnt]; */
end_comment

begin_comment
comment|/* If oldpos = newpos => same color, so skip shading */
end_comment

begin_comment
comment|/* ================================================= */
end_comment

begin_comment
comment|/*          p2=p1;           color=get_ray_color(&p1);            if (color.a<1.0)             {               f1=((xcnt % 32)<16);               f2=((ycnt % 32)<16);               f1=f1^f2;                if (f1)                 {                   if (color.a==0.0)                     color=lightcheck;                   else                     {                       gck_rgb_mul(&color,color.a);                       temp=lightcheck;                       gck_rgb_mul(&temp,1.0-color.a);                       gck_rgb_add(&color,&temp);                     }                 }               else                 {                   if (color.a==0.0)                     color=darkcheck;                   else                     {                       gck_rgb_mul(&color,color.a);                       temp=darkcheck;                       gck_rgb_mul(&temp,1.0-color.a);                       gck_rgb_add(&color,&temp);                     }                 }             }            preview_rgb_data[index++]=(guchar)(color.r*255.0);           preview_rgb_data[index++]=(guchar)(color.g*255.0);           preview_rgb_data[index++]=(guchar)(color.b*255.0);         }     } */
end_comment

begin_comment
comment|/* Convert to visual type */
end_comment

begin_comment
comment|/* ====================== */
end_comment

begin_comment
comment|/*  gck_rgb_to_gdkimage(visinfo,preview_rgb_data,image,pw,ph); */
end_comment

begin_comment
comment|/* } */
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_comment
comment|/* Check if the given position is within the     */
end_comment

begin_comment
comment|/* light marker. Return TRUE if so, FALSE if not */
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_function
name|gint
DECL|function|check_light_hit (gint xpos,gint ypos)
name|check_light_hit
parameter_list|(
name|gint
name|xpos
parameter_list|,
name|gint
name|ypos
parameter_list|)
block|{
comment|/*  gdouble dx,dy,r;      if (mapvals.lightsource.type==POINT_LIGHT)     {       dx=(gdouble)lightx-xpos;       dy=(gdouble)lighty-ypos;       r=sqrt(dx*dx+dy*dy)+0.5;        if ((gint)r>7)         return(FALSE);       else         return(TRUE);     }    */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* Draw a marker to show light position */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* static void draw_light_marker (gint xpos, 		   gint ypos) { */
end_comment

begin_comment
comment|/*  gck_gc_set_foreground(visinfo,gc,0,50,255);   gck_gc_set_background(visinfo,gc,0,0,0);    gdk_gc_set_function(gc,GDK_COPY);    if (mapvals.lightsource.type==POINT_LIGHT)     {       lightx=xpos;       lighty=ypos; */
end_comment

begin_comment
comment|/* Save background */
end_comment

begin_comment
comment|/* =============== */
end_comment

begin_comment
comment|/*      backbuf.x=lightx-7;       backbuf.y=lighty-7;       backbuf.w=14;       backbuf.h=14; */
end_comment

begin_comment
comment|/* X doesn't like images that's outside a window, make sure */
end_comment

begin_comment
comment|/* we get the backbuffer image from within the boundaries   */
end_comment

begin_comment
comment|/* ======================================================== */
end_comment

begin_comment
comment|/*      if (backbuf.x<0)         backbuf.x=0;       else if ((backbuf.x+backbuf.w)>PREVIEW_WIDTH)         backbuf.w=(PREVIEW_WIDTH-backbuf.x);        if (backbuf.y<0)         backbuf.y=0;       else if ((backbuf.y+backbuf.h)>PREVIEW_HEIGHT)         backbuf.h=(PREVIEW_WIDTH-backbuf.y);         backbuf.image=gdk_image_get(previewarea->window,backbuf.x,backbuf.y,backbuf.w,backbuf.h);       gdk_draw_arc(previewarea->window,gc,TRUE,lightx-7,lighty-7,14,14,0,360*64);     } */
end_comment

begin_comment
comment|/*}*/
end_comment

begin_function
specifier|static
name|void
DECL|function|clear_light_marker (void)
name|clear_light_marker
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Restore background if it has been saved */
comment|/* ======================================= */
comment|/*  if (backbuf.image!=NULL)     {       gck_gc_set_foreground(visinfo,gc,255,255,255);       gck_gc_set_background(visinfo,gc,0,0,0);        gdk_gc_set_function(gc,GDK_COPY);       gdk_draw_image(previewarea->window,gc,backbuf.image,0,0,backbuf.x,backbuf.y,         backbuf.w,backbuf.h);       gdk_image_destroy(backbuf.image);       backbuf.image=NULL;     } */
block|}
end_function

begin_comment
comment|/* static void draw_lights (void) {   gdouble dxpos,dypos;   gint xpos,ypos;    clear_light_marker();     gck_3d_to_2d(startx,starty,pw,ph,&dxpos,&dypos,&mapvals.viewpoint,&mapvals.lightsource.position);    xpos=(gint)(dxpos+0.5);   ypos=(gint)(dypos+0.5);    if (xpos>=0&& xpos<=PREVIEW_WIDTH&& ypos>=0&& ypos<=PREVIEW_HEIGHT)     draw_light_marker(xpos,ypos); }*/
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_comment
comment|/* Update light position given new screen coords */
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_function
name|void
DECL|function|update_light (gint xpos,gint ypos)
name|update_light
parameter_list|(
name|gint
name|xpos
parameter_list|,
name|gint
name|ypos
parameter_list|)
block|{
comment|/*  gint startx,starty,pw,ph;    pw=PREVIEW_WIDTH>> mapvals.preview_zoom_factor;   ph=PREVIEW_HEIGHT>> mapvals.preview_zoom_factor;   startx=(PREVIEW_WIDTH-pw)>>1;   starty=(PREVIEW_HEIGHT-ph)>>1;      gck_2d_to_3d(startx,starty,pw,ph,xpos,ypos,&mapvals.viewpoint,&mapvals.lightsource.position);    draw_lights(startx,starty,pw,ph); */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_preview_rectangle (gint * xp,gint * yp,gint * wid,gint * heig)
name|compute_preview_rectangle
parameter_list|(
name|gint
modifier|*
name|xp
parameter_list|,
name|gint
modifier|*
name|yp
parameter_list|,
name|gint
modifier|*
name|wid
parameter_list|,
name|gint
modifier|*
name|heig
parameter_list|)
block|{
name|gdouble
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
name|width
operator|>=
name|height
condition|)
block|{
name|w
operator|=
operator|(
name|PREVIEW_WIDTH
operator|-
literal|50.0
operator|)
expr_stmt|;
name|h
operator|=
operator|(
name|gdouble
operator|)
name|height
operator|*
operator|(
name|w
operator|/
operator|(
name|gdouble
operator|)
name|width
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|PREVIEW_WIDTH
operator|-
name|w
operator|)
operator|/
literal|2.0
expr_stmt|;
name|y
operator|=
operator|(
name|PREVIEW_HEIGHT
operator|-
name|h
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
operator|(
name|PREVIEW_HEIGHT
operator|-
literal|50.0
operator|)
expr_stmt|;
name|w
operator|=
operator|(
name|gdouble
operator|)
name|width
operator|*
operator|(
name|h
operator|/
operator|(
name|gdouble
operator|)
name|height
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|PREVIEW_WIDTH
operator|-
name|w
operator|)
operator|/
literal|2.0
expr_stmt|;
name|y
operator|=
operator|(
name|PREVIEW_HEIGHT
operator|-
name|h
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
operator|*
name|xp
operator|=
call|(
name|gint
call|)
argument_list|(
name|x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
operator|*
name|yp
operator|=
call|(
name|gint
call|)
argument_list|(
name|y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
operator|*
name|wid
operator|=
call|(
name|gint
call|)
argument_list|(
name|w
operator|+
literal|0.5
argument_list|)
expr_stmt|;
operator|*
name|heig
operator|=
call|(
name|gint
call|)
argument_list|(
name|h
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/* Draw preview image. if DoCompute is TRUE then recompute image. */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
name|void
DECL|function|draw_preview_image (gint recompute)
name|draw_preview_image
parameter_list|(
name|gint
name|recompute
parameter_list|)
block|{
name|gint
name|startx
decl_stmt|,
name|starty
decl_stmt|,
name|pw
decl_stmt|,
name|ph
decl_stmt|;
name|gck_gc_set_foreground
argument_list|(
name|visinfo
argument_list|,
name|gc
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|gck_gc_set_background
argument_list|(
name|visinfo
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdk_gc_set_function
argument_list|(
name|gc
argument_list|,
name|GDK_COPY
argument_list|)
expr_stmt|;
name|compute_preview_rectangle
argument_list|(
operator|&
name|startx
argument_list|,
operator|&
name|starty
argument_list|,
operator|&
name|pw
argument_list|,
operator|&
name|ph
argument_list|)
expr_stmt|;
if|if
condition|(
name|recompute
operator|==
name|TRUE
condition|)
block|{
name|GdkCursor
modifier|*
name|newcursor
decl_stmt|;
name|newcursor
operator|=
name|gdk_cursor_new
argument_list|(
name|GDK_WATCH
argument_list|)
expr_stmt|;
name|gdk_window_set_cursor
argument_list|(
name|previewarea
operator|->
name|window
argument_list|,
name|newcursor
argument_list|)
expr_stmt|;
name|gdk_cursor_destroy
argument_list|(
name|newcursor
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
name|compute_preview
argument_list|(
name|startx
argument_list|,
name|starty
argument_list|,
name|pw
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|newcursor
operator|=
name|gdk_cursor_new
argument_list|(
name|GDK_HAND2
argument_list|)
expr_stmt|;
name|gdk_window_set_cursor
argument_list|(
name|previewarea
operator|->
name|window
argument_list|,
name|newcursor
argument_list|)
expr_stmt|;
name|gdk_cursor_destroy
argument_list|(
name|newcursor
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
name|clear_light_marker
argument_list|()
expr_stmt|;
block|}
name|gdk_draw_image
argument_list|(
name|previewarea
operator|->
name|window
argument_list|,
name|gc
argument_list|,
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PREVIEW_WIDTH
argument_list|,
name|PREVIEW_HEIGHT
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

