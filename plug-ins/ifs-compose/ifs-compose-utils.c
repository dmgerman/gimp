begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * IfsCompose is a interface for creating IFS fractals by  * direct manipulation.  * Copyright (C) 1997 Owen Taylor  *  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gdk/gdk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"ifs-compose.h"
end_include

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28fdb4420108
block|{
DECL|member|point
name|GdkPoint
name|point
decl_stmt|;
DECL|member|angle
name|gdouble
name|angle
decl_stmt|;
DECL|typedef|SortPoint
block|}
name|SortPoint
typedef|;
end_typedef

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|aff_element_compute_click_boundary
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|,
name|gint
name|num_elements
parameter_list|,
name|gdouble
modifier|*
name|points_x
parameter_list|,
name|gdouble
modifier|*
name|points_y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|create_brush
parameter_list|(
name|IfsComposeVals
modifier|*
name|ifsvals
parameter_list|,
name|gint
modifier|*
name|brush_size
parameter_list|,
name|gdouble
modifier|*
name|brush_offset
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
DECL|function|aff2_translate (Aff2 * naff,gdouble x,gdouble y)
name|aff2_translate
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|naff
operator|->
name|a11
operator|=
literal|1.0
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
literal|1.0
expr_stmt|;
name|naff
operator|->
name|b1
operator|=
name|x
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff2_rotate (Aff2 * naff,gdouble theta)
name|aff2_rotate
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|gdouble
name|theta
parameter_list|)
block|{
name|naff
operator|->
name|a11
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
operator|-
name|naff
operator|->
name|a12
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
name|naff
operator|->
name|a11
expr_stmt|;
name|naff
operator|->
name|b1
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff2_scale (Aff2 * naff,gdouble s,gboolean flip)
name|aff2_scale
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|gdouble
name|s
parameter_list|,
name|gboolean
name|flip
parameter_list|)
block|{
if|if
condition|(
name|flip
condition|)
name|naff
operator|->
name|a11
operator|=
operator|-
name|s
expr_stmt|;
else|else
name|naff
operator|->
name|a11
operator|=
name|s
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
name|s
expr_stmt|;
name|naff
operator|->
name|b1
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a unitary transform with given x-y asymmetry and shear */
end_comment

begin_function
name|void
DECL|function|aff2_distort (Aff2 * naff,gdouble asym,gdouble shear)
name|aff2_distort
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|gdouble
name|asym
parameter_list|,
name|gdouble
name|shear
parameter_list|)
block|{
name|naff
operator|->
name|a11
operator|=
name|asym
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
literal|1
operator|/
name|asym
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
name|shear
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|b1
operator|=
literal|0
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a pure stretch in some directon that brings xo,yo to xn,yn */
end_comment

begin_function
name|void
DECL|function|aff2_compute_stretch (Aff2 * naff,gdouble xo,gdouble yo,gdouble xn,gdouble yn)
name|aff2_compute_stretch
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|gdouble
name|xo
parameter_list|,
name|gdouble
name|yo
parameter_list|,
name|gdouble
name|xn
parameter_list|,
name|gdouble
name|yn
parameter_list|)
block|{
name|gdouble
name|denom
init|=
name|xo
operator|*
name|xn
operator|+
name|yo
operator|*
name|yn
decl_stmt|;
if|if
condition|(
name|denom
operator|==
literal|0.0
condition|)
comment|/* singular */
block|{
name|naff
operator|->
name|a11
operator|=
literal|1.0
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
literal|0.0
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
literal|0.0
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
name|naff
operator|->
name|a11
operator|=
operator|(
name|SQR
argument_list|(
name|xn
argument_list|)
operator|+
name|SQR
argument_list|(
name|yo
argument_list|)
operator|)
operator|/
name|denom
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
operator|(
name|SQR
argument_list|(
name|xo
argument_list|)
operator|+
name|SQR
argument_list|(
name|yn
argument_list|)
operator|)
operator|/
name|denom
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
name|naff
operator|->
name|a21
operator|=
operator|(
name|xn
operator|*
name|yn
operator|-
name|xo
operator|*
name|yo
operator|)
operator|/
name|denom
expr_stmt|;
block|}
name|naff
operator|->
name|b1
operator|=
literal|0.0
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
literal|0.0
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff2_compose (Aff2 * naff,Aff2 * aff1,Aff2 * aff2)
name|aff2_compose
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|Aff2
modifier|*
name|aff1
parameter_list|,
name|Aff2
modifier|*
name|aff2
parameter_list|)
block|{
name|naff
operator|->
name|a11
operator|=
name|aff1
operator|->
name|a11
operator|*
name|aff2
operator|->
name|a11
operator|+
name|aff1
operator|->
name|a12
operator|*
name|aff2
operator|->
name|a21
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
name|aff1
operator|->
name|a11
operator|*
name|aff2
operator|->
name|a12
operator|+
name|aff1
operator|->
name|a12
operator|*
name|aff2
operator|->
name|a22
expr_stmt|;
name|naff
operator|->
name|b1
operator|=
name|aff1
operator|->
name|a11
operator|*
name|aff2
operator|->
name|b1
operator|+
name|aff1
operator|->
name|a12
operator|*
name|aff2
operator|->
name|b2
operator|+
name|aff1
operator|->
name|b1
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
name|aff1
operator|->
name|a21
operator|*
name|aff2
operator|->
name|a11
operator|+
name|aff1
operator|->
name|a22
operator|*
name|aff2
operator|->
name|a21
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
name|aff1
operator|->
name|a21
operator|*
name|aff2
operator|->
name|a12
operator|+
name|aff1
operator|->
name|a22
operator|*
name|aff2
operator|->
name|a22
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
name|aff1
operator|->
name|a21
operator|*
name|aff2
operator|->
name|b1
operator|+
name|aff1
operator|->
name|a22
operator|*
name|aff2
operator|->
name|b2
operator|+
name|aff1
operator|->
name|b2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the identity matrix if the original matrix was singular */
end_comment

begin_function
name|void
DECL|function|aff2_invert (Aff2 * naff,Aff2 * aff)
name|aff2_invert
parameter_list|(
name|Aff2
modifier|*
name|naff
parameter_list|,
name|Aff2
modifier|*
name|aff
parameter_list|)
block|{
name|gdouble
name|det
init|=
name|aff
operator|->
name|a11
operator|*
name|aff
operator|->
name|a22
operator|-
name|aff
operator|->
name|a12
operator|*
name|aff
operator|->
name|a21
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0
condition|)
block|{
name|aff2_scale
argument_list|(
name|naff
argument_list|,
literal|1.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|naff
operator|->
name|a11
operator|=
name|aff
operator|->
name|a22
operator|/
name|det
expr_stmt|;
name|naff
operator|->
name|a22
operator|=
name|aff
operator|->
name|a11
operator|/
name|det
expr_stmt|;
name|naff
operator|->
name|a21
operator|=
operator|-
name|aff
operator|->
name|a21
operator|/
name|det
expr_stmt|;
name|naff
operator|->
name|a12
operator|=
operator|-
name|aff
operator|->
name|a12
operator|/
name|det
expr_stmt|;
name|naff
operator|->
name|b1
operator|=
operator|-
name|naff
operator|->
name|a11
operator|*
name|aff
operator|->
name|b1
operator|-
name|naff
operator|->
name|a12
operator|*
name|aff
operator|->
name|b2
expr_stmt|;
name|naff
operator|->
name|b2
operator|=
operator|-
name|naff
operator|->
name|a21
operator|*
name|aff
operator|->
name|b1
operator|-
name|naff
operator|->
name|a22
operator|*
name|aff
operator|->
name|b2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|aff2_apply (Aff2 * aff,gdouble x,gdouble y,gdouble * xf,gdouble * yf)
name|aff2_apply
parameter_list|(
name|Aff2
modifier|*
name|aff
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|gdouble
modifier|*
name|xf
parameter_list|,
name|gdouble
modifier|*
name|yf
parameter_list|)
block|{
name|gdouble
name|xt
init|=
name|aff
operator|->
name|a11
operator|*
name|x
operator|+
name|aff
operator|->
name|a12
operator|*
name|y
operator|+
name|aff
operator|->
name|b1
decl_stmt|;
name|gdouble
name|yt
init|=
name|aff
operator|->
name|a21
operator|*
name|x
operator|+
name|aff
operator|->
name|a22
operator|*
name|y
operator|+
name|aff
operator|->
name|b2
decl_stmt|;
operator|*
name|xf
operator|=
name|xt
expr_stmt|;
operator|*
name|yf
operator|=
name|yt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the fixed point of an affine transformation    (Will return garbage for pure translations) */
end_comment

begin_function
name|void
DECL|function|aff2_fixed_point (Aff2 * aff,gdouble * xf,gdouble * yf)
name|aff2_fixed_point
parameter_list|(
name|Aff2
modifier|*
name|aff
parameter_list|,
name|gdouble
modifier|*
name|xf
parameter_list|,
name|gdouble
modifier|*
name|yf
parameter_list|)
block|{
name|Aff2
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|.
name|a11
operator|=
literal|1
operator|-
name|aff
operator|->
name|a11
expr_stmt|;
name|t1
operator|.
name|a22
operator|=
literal|1
operator|-
name|aff
operator|->
name|a22
expr_stmt|;
name|t1
operator|.
name|a12
operator|=
operator|-
name|aff
operator|->
name|a12
expr_stmt|;
name|t1
operator|.
name|a21
operator|=
operator|-
name|aff
operator|->
name|a21
expr_stmt|;
name|t1
operator|.
name|b1
operator|=
literal|0
expr_stmt|;
name|t1
operator|.
name|b2
operator|=
literal|0
expr_stmt|;
name|aff2_invert
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|aff2_apply
argument_list|(
operator|&
name|t2
argument_list|,
name|aff
operator|->
name|b1
argument_list|,
name|aff
operator|->
name|b2
argument_list|,
name|xf
argument_list|,
name|yf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff3_apply (Aff3 * t,gdouble x,gdouble y,gdouble z,gdouble * xf,gdouble * yf,gdouble * zf)
name|aff3_apply
parameter_list|(
name|Aff3
modifier|*
name|t
parameter_list|,
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|gdouble
name|z
parameter_list|,
name|gdouble
modifier|*
name|xf
parameter_list|,
name|gdouble
modifier|*
name|yf
parameter_list|,
name|gdouble
modifier|*
name|zf
parameter_list|)
block|{
name|gdouble
name|xt
init|=
operator|(
name|t
operator|->
name|vals
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|t
operator|->
name|vals
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|t
operator|->
name|vals
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|z
operator|+
name|t
operator|->
name|vals
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|)
decl_stmt|;
name|gdouble
name|yt
init|=
operator|(
name|t
operator|->
name|vals
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|t
operator|->
name|vals
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|t
operator|->
name|vals
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|z
operator|+
name|t
operator|->
name|vals
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|)
decl_stmt|;
name|gdouble
name|zt
init|=
operator|(
name|t
operator|->
name|vals
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|x
operator|+
name|t
operator|->
name|vals
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|y
operator|+
name|t
operator|->
name|vals
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|z
operator|+
name|t
operator|->
name|vals
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|)
decl_stmt|;
operator|*
name|xf
operator|=
name|xt
expr_stmt|;
operator|*
name|yf
operator|=
name|yt
expr_stmt|;
operator|*
name|zf
operator|=
name|zt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|ipolygon_sort_func (const void * a,const void * b)
name|ipolygon_sort_func
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|SortPoint
operator|*
operator|)
name|a
operator|)
operator|->
name|angle
operator|<
operator|(
operator|(
name|SortPoint
operator|*
operator|)
name|b
operator|)
operator|->
name|angle
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|SortPoint
operator|*
operator|)
name|a
operator|)
operator|->
name|angle
operator|>
operator|(
operator|(
name|SortPoint
operator|*
operator|)
name|b
operator|)
operator|->
name|angle
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated polygon which is the convex hull    of the given polygon.     Uses the Graham scan. see    http://www.cs.curtin.edu.au/units/cg201/notes/node77.html     for a description */
end_comment

begin_function
name|IPolygon
modifier|*
DECL|function|ipolygon_convex_hull (IPolygon * poly)
name|ipolygon_convex_hull
parameter_list|(
name|IPolygon
modifier|*
name|poly
parameter_list|)
block|{
name|gint
name|num_new
init|=
name|poly
operator|->
name|npoints
decl_stmt|;
name|GdkPoint
modifier|*
name|new_points
init|=
name|g_new
argument_list|(
name|GdkPoint
argument_list|,
name|num_new
argument_list|)
decl_stmt|;
name|SortPoint
modifier|*
name|sort_points
init|=
name|g_new
argument_list|(
name|SortPoint
argument_list|,
name|num_new
argument_list|)
decl_stmt|;
name|IPolygon
modifier|*
name|new_poly
init|=
name|g_new
argument_list|(
name|IPolygon
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|lowest
decl_stmt|;
name|GdkPoint
name|lowest_pt
decl_stmt|;
name|new_poly
operator|->
name|points
operator|=
name|new_points
expr_stmt|;
if|if
condition|(
name|num_new
operator|<=
literal|3
condition|)
block|{
name|memcpy
argument_list|(
name|new_points
argument_list|,
name|poly
operator|->
name|points
argument_list|,
name|num_new
operator|*
sizeof|sizeof
argument_list|(
name|GdkPoint
argument_list|)
argument_list|)
expr_stmt|;
name|new_poly
operator|->
name|npoints
operator|=
name|num_new
expr_stmt|;
return|return
name|new_poly
return|;
block|}
comment|/* scan for the lowest point */
name|lowest_pt
operator|=
name|poly
operator|->
name|points
index|[
literal|0
index|]
expr_stmt|;
name|lowest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_new
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|poly
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
operator|<
name|lowest_pt
operator|.
name|y
condition|)
block|{
name|lowest_pt
operator|=
name|poly
operator|->
name|points
index|[
name|i
index|]
expr_stmt|;
name|lowest
operator|=
name|i
expr_stmt|;
block|}
comment|/* sort by angle from lowest point */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|num_new
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|lowest
condition|)
name|j
operator|--
expr_stmt|;
else|else
block|{
name|gdouble
name|dy
init|=
name|poly
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
operator|-
name|lowest_pt
operator|.
name|y
decl_stmt|;
name|gdouble
name|dx
init|=
name|poly
operator|->
name|points
index|[
name|i
index|]
operator|.
name|x
operator|-
name|lowest_pt
operator|.
name|x
decl_stmt|;
if|if
condition|(
name|dy
operator|==
literal|0
operator|&&
name|dx
operator|==
literal|0
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|num_new
operator|--
expr_stmt|;
continue|continue;
block|}
name|sort_points
index|[
name|j
index|]
operator|.
name|point
operator|=
name|poly
operator|->
name|points
index|[
name|i
index|]
expr_stmt|;
name|sort_points
index|[
name|j
index|]
operator|.
name|angle
operator|=
name|atan2
argument_list|(
name|dy
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|sort_points
argument_list|,
name|num_new
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|SortPoint
argument_list|)
argument_list|,
name|ipolygon_sort_func
argument_list|)
expr_stmt|;
comment|/* now ensure that all turns as we trace the perimiter are      counter-clockwise */
name|new_points
index|[
literal|0
index|]
operator|=
name|lowest_pt
expr_stmt|;
name|new_points
index|[
literal|1
index|]
operator|=
name|sort_points
index|[
literal|0
index|]
operator|.
name|point
expr_stmt|;
name|x1
operator|=
name|new_points
index|[
literal|1
index|]
operator|.
name|x
operator|-
name|new_points
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|y1
operator|=
name|new_points
index|[
literal|1
index|]
operator|.
name|y
operator|-
name|new_points
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|num_new
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|x2
operator|=
name|sort_points
index|[
name|i
index|]
operator|.
name|point
operator|.
name|x
operator|-
name|new_points
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|y2
operator|=
name|sort_points
index|[
name|i
index|]
operator|.
name|point
operator|.
name|y
operator|-
name|new_points
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|x2
operator|==
literal|0
operator|&&
name|y2
operator|==
literal|0
condition|)
block|{
name|num_new
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|x1
operator|*
name|y2
operator|-
name|x2
operator|*
name|y1
operator|<
literal|0
condition|)
comment|/* clockwise rotation */
block|{
name|num_new
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
name|x1
operator|=
name|new_points
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|x
operator|-
name|new_points
index|[
name|j
operator|-
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|y1
operator|=
name|new_points
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|y
operator|-
name|new_points
index|[
name|j
operator|-
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|x2
operator|=
name|sort_points
index|[
name|i
index|]
operator|.
name|point
operator|.
name|x
operator|-
name|new_points
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|y2
operator|=
name|sort_points
index|[
name|i
index|]
operator|.
name|point
operator|.
name|y
operator|-
name|new_points
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
block|}
name|new_points
index|[
name|j
index|]
operator|=
name|sort_points
index|[
name|i
index|]
operator|.
name|point
expr_stmt|;
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
block|}
name|g_free
argument_list|(
name|sort_points
argument_list|)
expr_stmt|;
name|new_poly
operator|->
name|npoints
operator|=
name|num_new
expr_stmt|;
return|return
name|new_poly
return|;
block|}
end_function

begin_comment
comment|/* Determines whether a specified point is in the given polygon.    Based on     inpoly.c by Bob Stein and Craig Yap.     (Linux Journal, Issue 35 (March 1997), p 68)    */
end_comment

begin_function
name|gint
DECL|function|ipolygon_contains (IPolygon * poly,gint xt,gint yt)
name|ipolygon_contains
parameter_list|(
name|IPolygon
modifier|*
name|poly
parameter_list|,
name|gint
name|xt
parameter_list|,
name|gint
name|yt
parameter_list|)
block|{
name|gint
name|xnew
decl_stmt|,
name|ynew
decl_stmt|;
name|gint
name|xold
decl_stmt|,
name|yold
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|gint
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|inside
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|poly
operator|->
name|npoints
operator|<
literal|3
condition|)
return|return
literal|0
return|;
name|xold
operator|=
name|poly
operator|->
name|points
index|[
name|poly
operator|->
name|npoints
operator|-
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|yold
operator|=
name|poly
operator|->
name|points
index|[
name|poly
operator|->
name|npoints
operator|-
literal|1
index|]
operator|.
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poly
operator|->
name|npoints
condition|;
name|i
operator|++
control|)
block|{
name|xnew
operator|=
name|poly
operator|->
name|points
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|ynew
operator|=
name|poly
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|xnew
operator|>
name|xold
condition|)
block|{
name|x1
operator|=
name|xold
expr_stmt|;
name|x2
operator|=
name|xnew
expr_stmt|;
name|y1
operator|=
name|yold
expr_stmt|;
name|y2
operator|=
name|ynew
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|xnew
expr_stmt|;
name|x2
operator|=
name|xold
expr_stmt|;
name|y1
operator|=
name|ynew
expr_stmt|;
name|y2
operator|=
name|yold
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xnew
operator|<
name|xt
operator|)
operator|==
operator|(
name|xt
operator|<=
name|xold
operator|)
operator|&&
operator|(
name|yt
operator|-
name|y1
operator|)
operator|*
operator|(
name|x2
operator|-
name|x1
operator|)
operator|<
operator|(
name|y2
operator|-
name|y1
operator|)
operator|*
operator|(
name|xt
operator|-
name|x1
operator|)
condition|)
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
name|xold
operator|=
name|xnew
expr_stmt|;
name|yold
operator|=
name|ynew
expr_stmt|;
block|}
return|return
name|inside
return|;
block|}
end_function

begin_function
name|void
DECL|function|aff_element_compute_color_trans (AffElement * elem)
name|aff_element_compute_color_trans
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|elem
operator|->
name|v
operator|.
name|simple_color
condition|)
block|{
name|gdouble
name|mag2
decl_stmt|;
name|mag2
operator|=
name|SQR
argument_list|(
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|r
argument_list|)
expr_stmt|;
name|mag2
operator|+=
name|SQR
argument_list|(
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|g
argument_list|)
expr_stmt|;
name|mag2
operator|+=
name|SQR
argument_list|(
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|b
argument_list|)
expr_stmt|;
comment|/* For mag2 == 0, the transformation blows up in general          but is well defined for hue_scale == value_scale, so          we assume that special case. */
if|if
condition|(
name|mag2
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0.0
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
name|i
index|]
index|[
name|i
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|hue_scale
expr_stmt|;
block|}
else|else
block|{
comment|/*  red  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
name|j
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|r
operator|/
name|mag2
operator|*
operator|(
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|-
name|elem
operator|->
name|v
operator|.
name|hue_scale
operator|)
expr_stmt|;
block|}
comment|/*  green  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
name|j
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|g
operator|/
name|mag2
operator|*
operator|(
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|-
name|elem
operator|->
name|v
operator|.
name|hue_scale
operator|)
expr_stmt|;
block|}
comment|/*  blue  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
name|j
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|g
operator|/
name|mag2
operator|*
operator|(
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|-
name|elem
operator|->
name|v
operator|.
name|hue_scale
operator|)
expr_stmt|;
block|}
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+=
name|elem
operator|->
name|v
operator|.
name|hue_scale
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+=
name|elem
operator|->
name|v
operator|.
name|hue_scale
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+=
name|elem
operator|->
name|v
operator|.
name|hue_scale
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
operator|(
literal|1
operator|-
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|)
operator|*
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|r
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
operator|(
literal|1
operator|-
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|)
operator|*
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|g
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
operator|(
literal|1
operator|-
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|)
operator|*
name|elem
operator|->
name|v
operator|.
name|target_color
operator|.
name|b
expr_stmt|;
block|}
name|aff3_apply
argument_list|(
operator|&
name|elem
operator|->
name|color_trans
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|red_color
operator|.
name|r
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|red_color
operator|.
name|g
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|red_color
operator|.
name|b
argument_list|)
expr_stmt|;
name|aff3_apply
argument_list|(
operator|&
name|elem
operator|->
name|color_trans
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|green_color
operator|.
name|r
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|green_color
operator|.
name|g
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|green_color
operator|.
name|b
argument_list|)
expr_stmt|;
name|aff3_apply
argument_list|(
operator|&
name|elem
operator|->
name|color_trans
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|.
name|r
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|.
name|g
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|.
name|b
argument_list|)
expr_stmt|;
name|aff3_apply
argument_list|(
operator|&
name|elem
operator|->
name|color_trans
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|r
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|g
argument_list|,
operator|&
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|red_color
operator|.
name|r
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|r
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|red_color
operator|.
name|g
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|g
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|red_color
operator|.
name|b
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|b
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|green_color
operator|.
name|r
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|r
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|green_color
operator|.
name|g
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|g
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|green_color
operator|.
name|b
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|b
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|.
name|r
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|r
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|.
name|g
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|g
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|.
name|b
operator|-
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|b
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|r
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|g
expr_stmt|;
name|elem
operator|->
name|color_trans
operator|.
name|vals
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
name|elem
operator|->
name|v
operator|.
name|black_color
operator|.
name|b
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|aff_element_compute_trans (AffElement * elem,gdouble width,gdouble height,gdouble center_x,gdouble center_y)
name|aff_element_compute_trans
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|,
name|gdouble
name|width
parameter_list|,
name|gdouble
name|height
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|)
block|{
name|Aff2
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
comment|/* create the rotation, scaling and shearing part of the transform */
name|aff2_distort
argument_list|(
operator|&
name|t1
argument_list|,
name|elem
operator|->
name|v
operator|.
name|asym
argument_list|,
name|elem
operator|->
name|v
operator|.
name|shear
argument_list|)
expr_stmt|;
name|aff2_scale
argument_list|(
operator|&
name|t2
argument_list|,
name|elem
operator|->
name|v
operator|.
name|scale
argument_list|,
name|elem
operator|->
name|v
operator|.
name|flip
argument_list|)
expr_stmt|;
name|aff2_compose
argument_list|(
operator|&
name|t3
argument_list|,
operator|&
name|t2
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|aff2_rotate
argument_list|(
operator|&
name|t2
argument_list|,
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
expr_stmt|;
name|aff2_compose
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|,
operator|&
name|t3
argument_list|)
expr_stmt|;
comment|/* now create the translational part */
name|aff2_translate
argument_list|(
operator|&
name|t2
argument_list|,
operator|-
name|center_x
operator|*
name|width
argument_list|,
operator|-
name|center_y
operator|*
name|width
argument_list|)
expr_stmt|;
name|aff2_compose
argument_list|(
operator|&
name|t3
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|aff2_translate
argument_list|(
operator|&
name|t2
argument_list|,
name|elem
operator|->
name|v
operator|.
name|x
operator|*
name|width
argument_list|,
name|elem
operator|->
name|v
operator|.
name|y
operator|*
name|width
argument_list|)
expr_stmt|;
name|aff2_compose
argument_list|(
operator|&
name|elem
operator|->
name|trans
argument_list|,
operator|&
name|t2
argument_list|,
operator|&
name|t3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff_element_decompose_trans (AffElement * elem,Aff2 * aff,gdouble width,gdouble height,gdouble center_x,gdouble center_y)
name|aff_element_decompose_trans
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|,
name|Aff2
modifier|*
name|aff
parameter_list|,
name|gdouble
name|width
parameter_list|,
name|gdouble
name|height
parameter_list|,
name|gdouble
name|center_x
parameter_list|,
name|gdouble
name|center_y
parameter_list|)
block|{
name|Aff2
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|gdouble
name|det
decl_stmt|,
name|scale
decl_stmt|,
name|sign
decl_stmt|;
comment|/* pull of the translational parts */
name|aff2_translate
argument_list|(
operator|&
name|t1
argument_list|,
name|center_x
operator|*
name|width
argument_list|,
name|center_y
operator|*
name|width
argument_list|)
expr_stmt|;
name|aff2_compose
argument_list|(
operator|&
name|t2
argument_list|,
name|aff
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|x
operator|=
name|t2
operator|.
name|b1
operator|/
name|width
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|y
operator|=
name|t2
operator|.
name|b2
operator|/
name|width
expr_stmt|;
name|det
operator|=
name|t2
operator|.
name|a11
operator|*
name|t2
operator|.
name|a22
operator|-
name|t2
operator|.
name|a12
operator|*
name|t2
operator|.
name|a21
expr_stmt|;
if|if
condition|(
name|det
operator|==
literal|0.0
condition|)
block|{
name|elem
operator|->
name|v
operator|.
name|scale
operator|=
literal|0.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|theta
operator|=
literal|0.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|asym
operator|=
literal|1.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|shear
operator|=
literal|0.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|flip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|det
operator|>=
literal|0
condition|)
block|{
name|scale
operator|=
name|elem
operator|->
name|v
operator|.
name|scale
operator|=
name|sqrt
argument_list|(
name|det
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|flip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|elem
operator|->
name|v
operator|.
name|scale
operator|=
name|sqrt
argument_list|(
operator|-
name|det
argument_list|)
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|flip
operator|=
literal|1
expr_stmt|;
block|}
name|elem
operator|->
name|v
operator|.
name|theta
operator|=
name|atan2
argument_list|(
operator|-
name|t2
operator|.
name|a21
argument_list|,
name|t2
operator|.
name|a11
argument_list|)
expr_stmt|;
if|if
condition|(
name|cos
argument_list|(
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|elem
operator|->
name|v
operator|.
name|asym
operator|=
operator|-
name|t2
operator|.
name|a21
operator|/
name|scale
operator|/
name|sin
argument_list|(
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|shear
operator|=
operator|-
name|sign
operator|*
name|t2
operator|.
name|a22
operator|/
name|scale
operator|/
name|sin
argument_list|(
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elem
operator|->
name|v
operator|.
name|asym
operator|=
name|sign
operator|*
name|t2
operator|.
name|a11
operator|/
name|scale
operator|/
name|cos
argument_list|(
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|shear
operator|=
name|sign
operator|*
operator|(
name|t2
operator|.
name|a12
operator|/
name|scale
operator|-
name|sin
argument_list|(
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
operator|/
name|elem
operator|->
name|v
operator|.
name|asym
operator|)
operator|/
name|cos
argument_list|(
name|elem
operator|->
name|v
operator|.
name|theta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|aff_element_compute_click_boundary (AffElement * elem,int num_elements,gdouble * points_x,gdouble * points_y)
name|aff_element_compute_click_boundary
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|,
name|int
name|num_elements
parameter_list|,
name|gdouble
modifier|*
name|points_x
parameter_list|,
name|gdouble
modifier|*
name|points_y
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|gdouble
name|xtot
init|=
literal|0
decl_stmt|;
name|gdouble
name|ytot
init|=
literal|0
decl_stmt|;
name|gdouble
name|xc
decl_stmt|,
name|yc
decl_stmt|;
name|gdouble
name|theta
decl_stmt|;
name|gdouble
name|sth
decl_stmt|,
name|cth
decl_stmt|;
comment|/* sin(theta), cos(theta) */
name|gdouble
name|axis1
decl_stmt|,
name|axis2
decl_stmt|;
name|gdouble
name|axis1max
decl_stmt|,
name|axis2max
decl_stmt|,
name|axis1min
decl_stmt|,
name|axis2min
decl_stmt|;
comment|/* compute the center of mass of the points */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|xtot
operator|+=
name|points_x
index|[
name|i
index|]
expr_stmt|;
name|ytot
operator|+=
name|points_y
index|[
name|i
index|]
expr_stmt|;
block|}
name|xc
operator|=
name|xtot
operator|/
name|num_elements
expr_stmt|;
name|yc
operator|=
name|ytot
operator|/
name|num_elements
expr_stmt|;
comment|/* compute the sum of the (x+iy)^2, and take half the the resulting      angle (xtot+iytot = A*exp(2i*theta)), to get an average direction */
name|xtot
operator|=
literal|0
expr_stmt|;
name|ytot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|xtot
operator|+=
name|SQR
argument_list|(
name|points_x
index|[
name|i
index|]
operator|-
name|xc
argument_list|)
operator|-
name|SQR
argument_list|(
name|points_y
index|[
name|i
index|]
operator|-
name|yc
argument_list|)
expr_stmt|;
name|ytot
operator|+=
literal|2
operator|*
operator|(
name|points_x
index|[
name|i
index|]
operator|-
name|xc
operator|)
operator|*
operator|(
name|points_y
index|[
name|i
index|]
operator|-
name|yc
operator|)
expr_stmt|;
block|}
name|theta
operator|=
literal|0.5
operator|*
name|atan2
argument_list|(
name|ytot
argument_list|,
name|xtot
argument_list|)
expr_stmt|;
name|sth
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|cth
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
comment|/* compute the minimum rectangle at angle theta that bounds the points,      1/2 side lenghs left in axis1, axis2, center in xc, yc */
name|axis1max
operator|=
name|axis1min
operator|=
literal|0.0
expr_stmt|;
name|axis2max
operator|=
name|axis2min
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|gdouble
name|proj1
init|=
operator|(
name|points_x
index|[
name|i
index|]
operator|-
name|xc
operator|)
operator|*
name|cth
operator|+
operator|(
name|points_y
index|[
name|i
index|]
operator|-
name|yc
operator|)
operator|*
name|sth
decl_stmt|;
name|gdouble
name|proj2
init|=
operator|-
operator|(
name|points_x
index|[
name|i
index|]
operator|-
name|xc
operator|)
operator|*
name|sth
operator|+
operator|(
name|points_y
index|[
name|i
index|]
operator|-
name|yc
operator|)
operator|*
name|cth
decl_stmt|;
if|if
condition|(
name|proj1
operator|<
name|axis1min
condition|)
name|axis1min
operator|=
name|proj1
expr_stmt|;
if|if
condition|(
name|proj1
operator|>
name|axis1max
condition|)
name|axis1max
operator|=
name|proj1
expr_stmt|;
if|if
condition|(
name|proj2
operator|<
name|axis2min
condition|)
name|axis2min
operator|=
name|proj2
expr_stmt|;
if|if
condition|(
name|proj2
operator|>
name|axis2max
condition|)
name|axis2max
operator|=
name|proj2
expr_stmt|;
block|}
name|axis1
operator|=
literal|0.5
operator|*
operator|(
name|axis1max
operator|-
name|axis1min
operator|)
expr_stmt|;
name|axis2
operator|=
literal|0.5
operator|*
operator|(
name|axis2max
operator|-
name|axis2min
operator|)
expr_stmt|;
name|xc
operator|+=
literal|0.5
operator|*
operator|(
operator|(
name|axis1max
operator|+
name|axis1min
operator|)
operator|*
name|cth
operator|-
operator|(
name|axis2max
operator|+
name|axis2min
operator|)
operator|*
name|sth
operator|)
expr_stmt|;
name|yc
operator|+=
literal|0.5
operator|*
operator|(
operator|(
name|axis1max
operator|+
name|axis1min
operator|)
operator|*
name|sth
operator|+
operator|(
name|axis2max
operator|+
name|axis2min
operator|)
operator|*
name|cth
operator|)
expr_stmt|;
comment|/* if the the rectangle is less than 10 pixels in any dimension,      make it click_boundary, otherwise set click_boundary = draw_boundary */
if|if
condition|(
name|axis1
operator|<
literal|8.0
operator|||
name|axis2
operator|<
literal|8.0
condition|)
block|{
name|GdkPoint
modifier|*
name|points
init|=
name|g_new
argument_list|(
name|GdkPoint
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|elem
operator|->
name|click_boundary
operator|=
name|g_new
argument_list|(
name|IPolygon
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elem
operator|->
name|click_boundary
operator|->
name|points
operator|=
name|points
expr_stmt|;
name|elem
operator|->
name|click_boundary
operator|->
name|npoints
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|axis1
operator|<
literal|8.0
condition|)
name|axis1
operator|=
literal|8.0
expr_stmt|;
if|if
condition|(
name|axis2
operator|<
literal|8.0
condition|)
name|axis2
operator|=
literal|8.0
expr_stmt|;
name|points
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|xc
operator|+
name|axis1
operator|*
name|cth
operator|-
name|axis2
operator|*
name|sth
expr_stmt|;
name|points
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|yc
operator|+
name|axis1
operator|*
name|sth
operator|+
name|axis2
operator|*
name|cth
expr_stmt|;
name|points
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|xc
operator|-
name|axis1
operator|*
name|cth
operator|-
name|axis2
operator|*
name|sth
expr_stmt|;
name|points
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|yc
operator|-
name|axis1
operator|*
name|sth
operator|+
name|axis2
operator|*
name|cth
expr_stmt|;
name|points
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|xc
operator|-
name|axis1
operator|*
name|cth
operator|+
name|axis2
operator|*
name|sth
expr_stmt|;
name|points
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|yc
operator|-
name|axis1
operator|*
name|sth
operator|-
name|axis2
operator|*
name|cth
expr_stmt|;
name|points
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|xc
operator|+
name|axis1
operator|*
name|cth
operator|+
name|axis2
operator|*
name|sth
expr_stmt|;
name|points
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|yc
operator|+
name|axis1
operator|*
name|sth
operator|-
name|axis2
operator|*
name|cth
expr_stmt|;
block|}
else|else
name|elem
operator|->
name|click_boundary
operator|=
name|elem
operator|->
name|draw_boundary
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff_element_compute_boundary (AffElement * elem,gint width,gint height,AffElement ** elements,gint num_elements)
name|aff_element_compute_boundary
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|AffElement
modifier|*
modifier|*
name|elements
parameter_list|,
name|gint
name|num_elements
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|IPolygon
name|tmp_poly
decl_stmt|;
name|gdouble
modifier|*
name|points_x
decl_stmt|;
name|gdouble
modifier|*
name|points_y
decl_stmt|;
if|if
condition|(
name|elem
operator|->
name|click_boundary
operator|&&
name|elem
operator|->
name|click_boundary
operator|!=
name|elem
operator|->
name|draw_boundary
condition|)
name|g_free
argument_list|(
name|elem
operator|->
name|click_boundary
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|draw_boundary
condition|)
name|g_free
argument_list|(
name|elem
operator|->
name|draw_boundary
argument_list|)
expr_stmt|;
name|tmp_poly
operator|.
name|npoints
operator|=
name|num_elements
expr_stmt|;
name|tmp_poly
operator|.
name|points
operator|=
name|g_new
argument_list|(
name|GdkPoint
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|points_x
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|points_y
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|aff2_apply
argument_list|(
operator|&
name|elem
operator|->
name|trans
argument_list|,
name|elements
index|[
name|i
index|]
operator|->
name|v
operator|.
name|x
operator|*
name|width
argument_list|,
name|elements
index|[
name|i
index|]
operator|->
name|v
operator|.
name|y
operator|*
name|width
argument_list|,
operator|&
name|points_x
index|[
name|i
index|]
argument_list|,
operator|&
name|points_y
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tmp_poly
operator|.
name|points
index|[
name|i
index|]
operator|.
name|x
operator|=
operator|(
name|gint
operator|)
name|points_x
index|[
name|i
index|]
expr_stmt|;
name|tmp_poly
operator|.
name|points
index|[
name|i
index|]
operator|.
name|y
operator|=
operator|(
name|gint
operator|)
name|points_y
index|[
name|i
index|]
expr_stmt|;
block|}
name|elem
operator|->
name|draw_boundary
operator|=
name|ipolygon_convex_hull
argument_list|(
operator|&
name|tmp_poly
argument_list|)
expr_stmt|;
name|aff_element_compute_click_boundary
argument_list|(
name|elem
argument_list|,
name|num_elements
argument_list|,
name|points_x
argument_list|,
name|points_y
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_poly
operator|.
name|points
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|aff_element_draw (AffElement * elem,gboolean selected,gint width,gint height,cairo_t * cr,GdkColor * color,PangoLayout * layout)
name|aff_element_draw
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|,
name|gboolean
name|selected
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|cairo_t
modifier|*
name|cr
parameter_list|,
name|GdkColor
modifier|*
name|color
parameter_list|,
name|PangoLayout
modifier|*
name|layout
parameter_list|)
block|{
name|PangoRectangle
name|rect
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|pango_layout_set_text
argument_list|(
name|layout
argument_list|,
name|elem
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pango_layout_get_pixel_extents
argument_list|(
name|layout
argument_list|,
name|NULL
argument_list|,
operator|&
name|rect
argument_list|)
expr_stmt|;
name|gdk_cairo_set_source_color
argument_list|(
name|cr
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|cairo_move_to
argument_list|(
name|cr
argument_list|,
name|elem
operator|->
name|v
operator|.
name|x
operator|*
name|width
operator|-
name|rect
operator|.
name|width
operator|/
literal|2
argument_list|,
name|elem
operator|->
name|v
operator|.
name|y
operator|*
name|width
operator|+
name|rect
operator|.
name|height
operator|/
literal|2
argument_list|)
expr_stmt|;
name|pango_cairo_show_layout
argument_list|(
name|cr
argument_list|,
name|layout
argument_list|)
expr_stmt|;
name|cairo_fill
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cairo_set_line_width
argument_list|(
name|cr
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|click_boundary
operator|!=
name|elem
operator|->
name|draw_boundary
condition|)
block|{
name|cairo_move_to
argument_list|(
name|cr
argument_list|,
name|elem
operator|->
name|click_boundary
operator|->
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|elem
operator|->
name|click_boundary
operator|->
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elem
operator|->
name|click_boundary
operator|->
name|npoints
condition|;
name|i
operator|++
control|)
name|cairo_line_to
argument_list|(
name|cr
argument_list|,
name|elem
operator|->
name|click_boundary
operator|->
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|elem
operator|->
name|click_boundary
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|cairo_close_path
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cairo_stroke
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selected
condition|)
name|cairo_set_line_width
argument_list|(
name|cr
argument_list|,
literal|3.0
argument_list|)
expr_stmt|;
name|cairo_move_to
argument_list|(
name|cr
argument_list|,
name|elem
operator|->
name|draw_boundary
operator|->
name|points
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|elem
operator|->
name|draw_boundary
operator|->
name|points
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elem
operator|->
name|draw_boundary
operator|->
name|npoints
condition|;
name|i
operator|++
control|)
name|cairo_line_to
argument_list|(
name|cr
argument_list|,
name|elem
operator|->
name|draw_boundary
operator|->
name|points
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|elem
operator|->
name|draw_boundary
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|cairo_close_path
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|cairo_stroke
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|AffElement
modifier|*
DECL|function|aff_element_new (gdouble x,gdouble y,GimpRGB * color,gint count)
name|aff_element_new
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|GimpRGB
modifier|*
name|color
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|AffElement
modifier|*
name|elem
init|=
name|g_new
argument_list|(
name|AffElement
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gchar
name|buffer
index|[
literal|16
index|]
decl_stmt|;
name|elem
operator|->
name|v
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|theta
operator|=
literal|0.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|scale
operator|=
literal|0.5
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|asym
operator|=
literal|1.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|shear
operator|=
literal|0.0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|flip
operator|=
literal|0
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|red_color
operator|=
operator|*
name|color
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|blue_color
operator|=
operator|*
name|color
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|green_color
operator|=
operator|*
name|color
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|black_color
operator|=
operator|*
name|color
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|target_color
operator|=
operator|*
name|color
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|hue_scale
operator|=
literal|0.5
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|value_scale
operator|=
literal|0.5
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|simple_color
operator|=
name|TRUE
expr_stmt|;
name|elem
operator|->
name|draw_boundary
operator|=
name|NULL
expr_stmt|;
name|elem
operator|->
name|click_boundary
operator|=
name|NULL
expr_stmt|;
name|aff_element_compute_color_trans
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|elem
operator|->
name|v
operator|.
name|prob
operator|=
literal|1.0
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|elem
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|elem
return|;
block|}
end_function

begin_function
name|void
DECL|function|aff_element_free (AffElement * elem)
name|aff_element_free
parameter_list|(
name|AffElement
modifier|*
name|elem
parameter_list|)
block|{
if|if
condition|(
name|elem
operator|->
name|click_boundary
operator|!=
name|elem
operator|->
name|draw_boundary
condition|)
name|g_free
argument_list|(
name|elem
operator|->
name|click_boundary
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|elem
operator|->
name|draw_boundary
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_BRUSH
end_ifdef

begin_expr_stmt
specifier|static
name|brush_chars
index|[]
operator|=
block|{
literal|' '
block|,
literal|':'
block|,
literal|'*'
block|,
literal|'@'
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|create_brush (IfsComposeVals * ifsvals,gint * brush_size,gdouble * brush_offset)
name|create_brush
parameter_list|(
name|IfsComposeVals
modifier|*
name|ifsvals
parameter_list|,
name|gint
modifier|*
name|brush_size
parameter_list|,
name|gdouble
modifier|*
name|brush_offset
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|guchar
modifier|*
name|brush
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_BRUSH
name|gdouble
name|totpix
init|=
literal|0.0
decl_stmt|;
endif|#
directive|endif
name|gdouble
name|radius
init|=
name|ifsvals
operator|->
name|radius
operator|*
name|ifsvals
operator|->
name|subdivide
decl_stmt|;
operator|*
name|brush_size
operator|=
name|ceil
argument_list|(
literal|2
operator|*
name|radius
argument_list|)
expr_stmt|;
operator|*
name|brush_offset
operator|=
literal|0.5
operator|*
operator|(
operator|*
name|brush_size
operator|-
literal|1
operator|)
expr_stmt|;
name|brush
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|SQR
argument_list|(
operator|*
name|brush_size
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|brush_size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|*
name|brush_size
condition|;
name|j
operator|++
control|)
block|{
name|gdouble
name|pixel
init|=
literal|0.0
decl_stmt|;
name|gdouble
name|d
init|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|i
operator|-
operator|*
name|brush_offset
argument_list|)
operator|+
name|SQR
argument_list|(
name|j
operator|-
operator|*
name|brush_offset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|-
literal|0.5
operator|*
name|G_SQRT2
operator|>
name|radius
condition|)
name|pixel
operator|=
literal|0.0
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|+
literal|0.5
operator|*
name|G_SQRT2
operator|<
name|radius
condition|)
name|pixel
operator|=
literal|1.0
expr_stmt|;
else|else
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|10
condition|;
name|ii
operator|++
control|)
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
literal|10
condition|;
name|jj
operator|++
control|)
block|{
name|d
operator|=
name|sqrt
argument_list|(
name|SQR
argument_list|(
name|i
operator|-
operator|*
name|brush_offset
operator|+
name|ii
operator|*
literal|0.1
operator|-
literal|0.45
argument_list|)
operator|+
name|SQR
argument_list|(
name|j
operator|-
operator|*
name|brush_offset
operator|+
name|jj
operator|*
literal|0.1
operator|-
literal|0.45
argument_list|)
argument_list|)
expr_stmt|;
name|pixel
operator|+=
operator|(
name|d
operator|<
name|radius
operator|)
operator|/
literal|100.0
expr_stmt|;
block|}
name|brush
index|[
name|i
operator|*
operator|*
name|brush_size
operator|+
name|j
index|]
operator|=
literal|255.999
operator|*
name|pixel
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_BRUSH
name|putchar
argument_list|(
name|brush_chars
index|[
call|(
name|gint
call|)
argument_list|(
name|pixel
operator|*
literal|3.999
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|totpix
operator|+=
name|pixel
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_BRUSH */
block|}
ifdef|#
directive|ifdef
name|DEBUG_BRUSH
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_BRUSH */
block|}
ifdef|#
directive|ifdef
name|DEBUG_BRUSH
name|printf
argument_list|(
literal|"Brush total / area = %f\n"
argument_list|,
name|totpix
operator|/
name|SQR
argument_list|(
name|ifsvals
operator|->
name|subdivide
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_BRUSH */
return|return
name|brush
return|;
block|}
end_function

begin_function
name|void
DECL|function|ifs_render (AffElement ** elements,gint num_elements,gint width,gint height,gint nsteps,IfsComposeVals * vals,gint band_y,gint band_height,guchar * data,guchar * mask,guchar * nhits,gboolean preview)
name|ifs_render
parameter_list|(
name|AffElement
modifier|*
modifier|*
name|elements
parameter_list|,
name|gint
name|num_elements
parameter_list|,
name|gint
name|width
parameter_list|,
name|gint
name|height
parameter_list|,
name|gint
name|nsteps
parameter_list|,
name|IfsComposeVals
modifier|*
name|vals
parameter_list|,
name|gint
name|band_y
parameter_list|,
name|gint
name|band_height
parameter_list|,
name|guchar
modifier|*
name|data
parameter_list|,
name|guchar
modifier|*
name|mask
parameter_list|,
name|guchar
modifier|*
name|nhits
parameter_list|,
name|gboolean
name|preview
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|gdouble
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gdouble
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|gint
name|ri
decl_stmt|,
name|gi
decl_stmt|,
name|bi
decl_stmt|;
name|guint32
name|p0
decl_stmt|,
name|psum
decl_stmt|;
name|gdouble
name|pt
decl_stmt|;
name|guchar
modifier|*
name|ptr
decl_stmt|;
name|guint32
modifier|*
name|prob
decl_stmt|;
name|gdouble
modifier|*
name|fprob
decl_stmt|;
name|gint
name|subdivide
decl_stmt|;
name|guchar
modifier|*
name|brush
init|=
name|NULL
decl_stmt|;
name|gint
name|brush_size
init|=
literal|1
decl_stmt|;
name|gdouble
name|brush_offset
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
name|preview
condition|)
name|subdivide
operator|=
literal|1
expr_stmt|;
else|else
name|subdivide
operator|=
name|vals
operator|->
name|subdivide
expr_stmt|;
comment|/* compute the probabilities and transforms */
name|fprob
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|prob
operator|=
name|g_new
argument_list|(
name|guint32
argument_list|,
name|num_elements
argument_list|)
expr_stmt|;
name|pt
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|aff_element_compute_trans
argument_list|(
name|elements
index|[
name|i
index|]
argument_list|,
name|width
operator|*
name|subdivide
argument_list|,
name|height
operator|*
name|subdivide
argument_list|,
name|vals
operator|->
name|center_x
argument_list|,
name|vals
operator|->
name|center_y
argument_list|)
expr_stmt|;
name|fprob
index|[
name|i
index|]
operator|=
name|fabs
argument_list|(
name|elements
index|[
name|i
index|]
operator|->
name|trans
operator|.
name|a11
operator|*
name|elements
index|[
name|i
index|]
operator|->
name|trans
operator|.
name|a22
operator|-
name|elements
index|[
name|i
index|]
operator|->
name|trans
operator|.
name|a12
operator|*
name|elements
index|[
name|i
index|]
operator|->
name|trans
operator|.
name|a21
argument_list|)
expr_stmt|;
comment|/* As a heuristic, if the determinant is really small, it's          probably a line element, so increase the probability so          it gets rendered */
comment|/* FIXME: figure out what 0.01 really should be */
if|if
condition|(
name|fprob
index|[
name|i
index|]
operator|<
literal|0.01
condition|)
name|fprob
index|[
name|i
index|]
operator|=
literal|0.01
expr_stmt|;
name|fprob
index|[
name|i
index|]
operator|*=
name|elements
index|[
name|i
index|]
operator|->
name|v
operator|.
name|prob
expr_stmt|;
name|pt
operator|+=
name|fprob
index|[
name|i
index|]
expr_stmt|;
block|}
name|psum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|psum
operator|+=
operator|(
name|guint32
operator|)
operator|-
literal|1
operator|*
operator|(
name|fprob
index|[
name|i
index|]
operator|/
name|pt
operator|)
expr_stmt|;
name|prob
index|[
name|i
index|]
operator|=
name|psum
expr_stmt|;
block|}
name|prob
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|(
name|guint32
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* make sure we don't get bitten by roundoff */
comment|/* create the brush */
if|if
condition|(
operator|!
name|preview
condition|)
name|brush
operator|=
name|create_brush
argument_list|(
name|vals
argument_list|,
operator|&
name|brush_size
argument_list|,
operator|&
name|brush_offset
argument_list|)
expr_stmt|;
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|g
operator|=
name|b
operator|=
literal|0
expr_stmt|;
comment|/* n is used to limit the number of progress updates */
name|n
operator|=
name|nsteps
operator|/
literal|32
expr_stmt|;
comment|/* now run the iteration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsteps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|preview
operator|&&
operator|(
operator|(
name|i
operator|%
name|n
operator|)
operator|==
literal|0
operator|)
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|i
operator|/
operator|(
name|gdouble
operator|)
name|nsteps
argument_list|)
expr_stmt|;
name|p0
operator|=
name|g_random_int
argument_list|()
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p0
operator|>
name|prob
index|[
name|k
index|]
condition|)
name|k
operator|++
expr_stmt|;
name|aff2_apply
argument_list|(
operator|&
name|elements
index|[
name|k
index|]
operator|->
name|trans
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|aff3_apply
argument_list|(
operator|&
name|elements
index|[
name|k
index|]
operator|->
name|color_trans
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|50
condition|)
continue|continue;
name|ri
operator|=
call|(
name|gint
call|)
argument_list|(
literal|255.0
operator|*
name|r
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|gi
operator|=
call|(
name|gint
call|)
argument_list|(
literal|255.0
operator|*
name|g
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|bi
operator|=
call|(
name|gint
call|)
argument_list|(
literal|255.0
operator|*
name|b
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ri
operator|<
literal|0
operator|)
operator|||
operator|(
name|ri
operator|>
literal|255
operator|)
operator|||
operator|(
name|gi
operator|<
literal|0
operator|)
operator|||
operator|(
name|gi
operator|>
literal|255
operator|)
operator|||
operator|(
name|bi
operator|<
literal|0
operator|)
operator|||
operator|(
name|bi
operator|>
literal|255
operator|)
condition|)
continue|continue;
if|if
condition|(
name|preview
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|<
name|width
operator|)
operator|&&
operator|(
name|y
operator|<
operator|(
name|band_y
operator|+
name|band_height
operator|)
operator|)
operator|&&
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|y
operator|>=
name|band_y
operator|)
condition|)
block|{
name|ptr
operator|=
name|data
operator|+
literal|3
operator|*
operator|(
operator|(
call|(
name|gint
call|)
argument_list|(
name|y
operator|-
name|band_y
argument_list|)
operator|)
operator|*
name|width
operator|+
operator|(
name|gint
operator|)
name|x
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|ri
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|gi
expr_stmt|;
operator|*
name|ptr
operator|=
name|bi
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|x
operator|<
name|width
operator|*
name|subdivide
operator|)
operator|&&
operator|(
name|y
operator|<
name|height
operator|*
name|subdivide
operator|)
operator|&&
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|y
operator|>=
literal|0
operator|)
condition|)
block|{
name|gint
name|ii
decl_stmt|;
name|gint
name|jj
decl_stmt|;
name|gint
name|jj0
init|=
name|floor
argument_list|(
name|y
operator|-
name|brush_offset
operator|-
name|band_y
operator|*
name|subdivide
argument_list|)
decl_stmt|;
name|gint
name|ii0
init|=
name|floor
argument_list|(
name|x
operator|-
name|brush_offset
argument_list|)
decl_stmt|;
name|gint
name|jjmin
init|=
literal|0
decl_stmt|;
name|gint
name|iimin
init|=
literal|0
decl_stmt|;
name|gint
name|jjmax
decl_stmt|;
name|gint
name|iimax
decl_stmt|;
if|if
condition|(
name|ii0
operator|<
literal|0
condition|)
name|iimin
operator|=
operator|-
name|ii0
expr_stmt|;
else|else
name|iimin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|jj0
operator|<
literal|0
condition|)
name|jjmin
operator|=
operator|-
name|jj0
expr_stmt|;
else|else
name|jjmin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|jj0
operator|+
name|brush_size
operator|>=
name|subdivide
operator|*
name|band_height
condition|)
name|jjmax
operator|=
name|subdivide
operator|*
name|band_height
operator|-
name|jj0
expr_stmt|;
else|else
name|jjmax
operator|=
name|brush_size
expr_stmt|;
if|if
condition|(
name|ii0
operator|+
name|brush_size
operator|>=
name|subdivide
operator|*
name|width
condition|)
name|iimax
operator|=
name|subdivide
operator|*
name|width
operator|-
name|ii0
expr_stmt|;
else|else
name|iimax
operator|=
name|brush_size
expr_stmt|;
for|for
control|(
name|jj
operator|=
name|jjmin
init|;
name|jj
operator|<
name|jjmax
condition|;
name|jj
operator|++
control|)
for|for
control|(
name|ii
operator|=
name|iimin
init|;
name|ii
operator|<
name|iimax
condition|;
name|ii
operator|++
control|)
block|{
name|guint
name|m_old
decl_stmt|;
name|guint
name|m_new
decl_stmt|;
name|guint
name|m_pix
decl_stmt|;
name|guint
name|n_hits
decl_stmt|;
name|guint
name|old_scale
decl_stmt|;
name|guint
name|pix_scale
decl_stmt|;
name|gint
name|index
init|=
operator|(
name|jj0
operator|+
name|jj
operator|)
operator|*
name|width
operator|*
name|subdivide
operator|+
name|ii0
operator|+
name|ii
decl_stmt|;
name|n_hits
operator|=
name|nhits
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|n_hits
operator|==
literal|255
condition|)
continue|continue;
name|m_pix
operator|=
name|brush
index|[
name|jj
operator|*
name|brush_size
operator|+
name|ii
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|m_pix
condition|)
continue|continue;
name|nhits
index|[
name|index
index|]
operator|=
operator|++
name|n_hits
expr_stmt|;
name|m_old
operator|=
name|mask
index|[
name|index
index|]
expr_stmt|;
name|m_new
operator|=
name|m_old
operator|+
name|m_pix
operator|-
name|m_old
operator|*
name|m_pix
operator|/
literal|255
expr_stmt|;
name|mask
index|[
name|index
index|]
operator|=
name|m_new
expr_stmt|;
comment|/* relative probability that old colored pixel is on top */
name|old_scale
operator|=
name|m_old
operator|*
operator|(
literal|255
operator|*
name|n_hits
operator|-
name|m_pix
operator|)
expr_stmt|;
comment|/* relative probability that new colored pixel is on top */
name|pix_scale
operator|=
name|m_pix
operator|*
operator|(
operator|(
literal|255
operator|-
name|m_old
operator|)
operator|*
name|n_hits
operator|+
name|m_old
operator|)
expr_stmt|;
name|ptr
operator|=
name|data
operator|+
literal|3
operator|*
name|index
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
operator|(
name|old_scale
operator|*
operator|(
operator|*
name|ptr
operator|)
operator|+
name|pix_scale
operator|*
name|ri
operator|)
operator|/
operator|(
name|old_scale
operator|+
name|pix_scale
operator|)
operator|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
operator|(
name|old_scale
operator|*
operator|(
operator|*
name|ptr
operator|)
operator|+
name|pix_scale
operator|*
name|gi
operator|)
operator|/
operator|(
name|old_scale
operator|+
name|pix_scale
operator|)
operator|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
operator|(
name|old_scale
operator|*
operator|(
operator|*
name|ptr
operator|)
operator|+
name|pix_scale
operator|*
name|bi
operator|)
operator|/
operator|(
name|old_scale
operator|+
name|pix_scale
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* main iteration */
if|if
condition|(
operator|!
name|preview
condition|)
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|prob
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|fprob
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

