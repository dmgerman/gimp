begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_line
line|#
directive|line
number|3
file|"<stdout>"
end_line

begin_define
DECL|macro|YY_INT_ALIGNED
define|#
directive|define
name|YY_INT_ALIGNED
value|short int
end_define

begin_comment
comment|/* A lexical scanner generated by flex */
end_comment

begin_define
DECL|macro|FLEX_SCANNER
define|#
directive|define
name|FLEX_SCANNER
end_define

begin_define
DECL|macro|YY_FLEX_MAJOR_VERSION
define|#
directive|define
name|YY_FLEX_MAJOR_VERSION
value|2
end_define

begin_define
DECL|macro|YY_FLEX_MINOR_VERSION
define|#
directive|define
name|YY_FLEX_MINOR_VERSION
value|5
end_define

begin_define
DECL|macro|YY_FLEX_SUBMINOR_VERSION
define|#
directive|define
name|YY_FLEX_SUBMINOR_VERSION
value|31
end_define

begin_if
if|#
directive|if
name|YY_FLEX_SUBMINOR_VERSION
operator|>
literal|0
end_if

begin_define
DECL|macro|FLEX_BETA
define|#
directive|define
name|FLEX_BETA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First, we deal with  platform-specific or compiler-specific issues. */
end_comment

begin_comment
comment|/* begin standard C headers. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* end standard C headers. */
end_comment

begin_comment
comment|/* flex integer type definitions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLEXINT_H
end_ifndef

begin_define
DECL|macro|FLEXINT_H
define|#
directive|define
name|FLEXINT_H
end_define

begin_comment
comment|/* C99 systems have<inttypes.h>. Non-C99 systems may or may not. */
end_comment

begin_if
if|#
directive|if
name|defined
name|__STDC_VERSION__
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_typedef
DECL|typedef|flex_int8_t
typedef|typedef
name|int8_t
name|flex_int8_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_uint8_t
typedef|typedef
name|uint8_t
name|flex_uint8_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_int16_t
typedef|typedef
name|int16_t
name|flex_int16_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_uint16_t
typedef|typedef
name|uint16_t
name|flex_uint16_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_int32_t
typedef|typedef
name|int32_t
name|flex_int32_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_uint32_t
typedef|typedef
name|uint32_t
name|flex_uint32_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
DECL|typedef|flex_int8_t
typedef|typedef
name|signed
name|char
name|flex_int8_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_int16_t
typedef|typedef
name|short
name|int
name|flex_int16_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_int32_t
typedef|typedef
name|int
name|flex_int32_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_uint8_t
typedef|typedef
name|unsigned
name|char
name|flex_uint8_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_uint16_t
typedef|typedef
name|unsigned
name|short
name|int
name|flex_uint16_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|flex_uint32_t
typedef|typedef
name|unsigned
name|int
name|flex_uint32_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! C99 */
end_comment

begin_comment
comment|/* Limits of integral types. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INT8_MIN
end_ifndef

begin_define
DECL|macro|INT8_MIN
define|#
directive|define
name|INT8_MIN
value|(-128)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT16_MIN
end_ifndef

begin_define
DECL|macro|INT16_MIN
define|#
directive|define
name|INT16_MIN
value|(-32767-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT32_MIN
end_ifndef

begin_define
DECL|macro|INT32_MIN
define|#
directive|define
name|INT32_MIN
value|(-2147483647-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT8_MAX
end_ifndef

begin_define
DECL|macro|INT8_MAX
define|#
directive|define
name|INT8_MAX
value|(127)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT16_MAX
end_ifndef

begin_define
DECL|macro|INT16_MAX
define|#
directive|define
name|INT16_MAX
value|(32767)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT32_MAX
end_ifndef

begin_define
DECL|macro|INT32_MAX
define|#
directive|define
name|INT32_MAX
value|(2147483647)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINT8_MAX
end_ifndef

begin_define
DECL|macro|UINT8_MAX
define|#
directive|define
name|UINT8_MAX
value|(255U)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINT16_MAX
end_ifndef

begin_define
DECL|macro|UINT16_MAX
define|#
directive|define
name|UINT16_MAX
value|(65535U)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINT32_MAX
end_ifndef

begin_define
DECL|macro|UINT32_MAX
define|#
directive|define
name|UINT32_MAX
value|(4294967295U)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! FLEXINT_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_comment
comment|/* The "const" storage-class-modifier is valid. */
end_comment

begin_define
DECL|macro|YY_USE_CONST
define|#
directive|define
name|YY_USE_CONST
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! __cplusplus */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_define
DECL|macro|YY_USE_CONST
define|#
directive|define
name|YY_USE_CONST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! __cplusplus */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YY_USE_CONST
end_ifdef

begin_define
DECL|macro|yyconst
define|#
directive|define
name|yyconst
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|yyconst
define|#
directive|define
name|yyconst
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Returned upon end-of-file. */
end_comment

begin_define
DECL|macro|YY_NULL
define|#
directive|define
name|YY_NULL
value|0
end_define

begin_comment
comment|/* Promotes a possibly negative, possibly signed char to an unsigned  * integer for use as an array index.  If the signed char is negative,  * we want to instead treat it as an 8-bit unsigned char, hence the  * double cast.  */
end_comment

begin_define
DECL|macro|YY_SC_TO_UI (c)
define|#
directive|define
name|YY_SC_TO_UI
parameter_list|(
name|c
parameter_list|)
value|((unsigned int) (unsigned char) c)
end_define

begin_comment
comment|/* Enter a start condition.  This macro really ought to take a parameter,  * but we do it the disgusting crufty way forced on us by the ()-less  * definition of BEGIN.  */
end_comment

begin_define
DECL|macro|BEGIN
define|#
directive|define
name|BEGIN
value|(yy_start) = 1 + 2 *
end_define

begin_comment
comment|/* Translate the current start state into a value that can be later handed  * to BEGIN to return to the state.  The YYSTATE alias is for lex  * compatibility.  */
end_comment

begin_define
DECL|macro|YY_START
define|#
directive|define
name|YY_START
value|(((yy_start) - 1) / 2)
end_define

begin_define
DECL|macro|YYSTATE
define|#
directive|define
name|YYSTATE
value|YY_START
end_define

begin_comment
comment|/* Action number for EOF rule of a given start state. */
end_comment

begin_define
DECL|macro|YY_STATE_EOF (state)
define|#
directive|define
name|YY_STATE_EOF
parameter_list|(
name|state
parameter_list|)
value|(YY_END_OF_BUFFER + state + 1)
end_define

begin_comment
comment|/* Special action meaning "start processing a new file". */
end_comment

begin_define
DECL|macro|YY_NEW_FILE
define|#
directive|define
name|YY_NEW_FILE
value|ncsa_restart(ncsa_in  )
end_define

begin_define
DECL|macro|YY_END_OF_BUFFER_CHAR
define|#
directive|define
name|YY_END_OF_BUFFER_CHAR
value|0
end_define

begin_comment
comment|/* Size of default input buffer. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_BUF_SIZE
end_ifndef

begin_define
DECL|macro|YY_BUF_SIZE
define|#
directive|define
name|YY_BUF_SIZE
value|16384
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YY_TYPEDEF_YY_BUFFER_STATE
end_ifndef

begin_define
DECL|macro|YY_TYPEDEF_YY_BUFFER_STATE
define|#
directive|define
name|YY_TYPEDEF_YY_BUFFER_STATE
end_define

begin_typedef
DECL|typedef|YY_BUFFER_STATE
typedef|typedef
name|struct
name|yy_buffer_state
modifier|*
name|YY_BUFFER_STATE
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|ncsa_leng
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|ncsa_in
decl_stmt|,
modifier|*
name|ncsa_out
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|EOB_ACT_CONTINUE_SCAN
define|#
directive|define
name|EOB_ACT_CONTINUE_SCAN
value|0
end_define

begin_define
DECL|macro|EOB_ACT_END_OF_FILE
define|#
directive|define
name|EOB_ACT_END_OF_FILE
value|1
end_define

begin_define
DECL|macro|EOB_ACT_LAST_MATCH
define|#
directive|define
name|EOB_ACT_LAST_MATCH
value|2
end_define

begin_define
DECL|macro|YY_LESS_LINENO (n)
define|#
directive|define
name|YY_LESS_LINENO
parameter_list|(
name|n
parameter_list|)
end_define

begin_comment
comment|/* Return all but the first "n" matched characters back to the input stream. */
end_comment

begin_define
DECL|macro|yyless (n)
define|#
directive|define
name|yyless
parameter_list|(
name|n
parameter_list|)
define|\
value|do \ 		{ \
comment|/* Undo effects of setting up ncsa_text. */
value|\         int yyless_macro_arg = (n); \         YY_LESS_LINENO(yyless_macro_arg);\ 		*yy_cp = (yy_hold_char); \ 		YY_RESTORE_YY_MORE_OFFSET \ 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \ 		YY_DO_BEFORE_ACTION;
comment|/* set up ncsa_text again */
value|\ 		} \ 	while ( 0 )
end_define

begin_define
DECL|macro|unput (c)
define|#
directive|define
name|unput
parameter_list|(
name|c
parameter_list|)
value|yyunput( c, (yytext_ptr)  )
end_define

begin_comment
comment|/* The following is because we cannot portably get our hands on size_t  * (without autoconf's help, which isn't available because we want  * flex-generated scanners to compile on their own).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_TYPEDEF_YY_SIZE_T
end_ifndef

begin_define
DECL|macro|YY_TYPEDEF_YY_SIZE_T
define|#
directive|define
name|YY_TYPEDEF_YY_SIZE_T
end_define

begin_typedef
DECL|typedef|yy_size_t
typedef|typedef
name|unsigned
name|int
name|yy_size_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YY_STRUCT_YY_BUFFER_STATE
end_ifndef

begin_define
DECL|macro|YY_STRUCT_YY_BUFFER_STATE
define|#
directive|define
name|YY_STRUCT_YY_BUFFER_STATE
end_define

begin_struct
DECL|struct|yy_buffer_state
struct|struct
name|yy_buffer_state
block|{
DECL|member|yy_input_file
name|FILE
modifier|*
name|yy_input_file
decl_stmt|;
DECL|member|yy_ch_buf
name|char
modifier|*
name|yy_ch_buf
decl_stmt|;
comment|/* input buffer */
DECL|member|yy_buf_pos
name|char
modifier|*
name|yy_buf_pos
decl_stmt|;
comment|/* current position in input buffer */
comment|/* Size of input buffer in bytes, not including room for EOB 	 * characters. 	 */
DECL|member|yy_buf_size
name|yy_size_t
name|yy_buf_size
decl_stmt|;
comment|/* Number of characters read into yy_ch_buf, not including EOB 	 * characters. 	 */
DECL|member|yy_n_chars
name|int
name|yy_n_chars
decl_stmt|;
comment|/* Whether we "own" the buffer - i.e., we know we created it, 	 * and can realloc() it to grow it, and should free() it to 	 * delete it. 	 */
DECL|member|yy_is_our_buffer
name|int
name|yy_is_our_buffer
decl_stmt|;
comment|/* Whether this is an "interactive" input source; if so, and 	 * if we're using stdio for input, then we want to use getc() 	 * instead of fread(), to make sure we stop fetching input after 	 * each newline. 	 */
DECL|member|yy_is_interactive
name|int
name|yy_is_interactive
decl_stmt|;
comment|/* Whether we're considered to be at the beginning of a line. 	 * If so, '^' rules will be active on the next match, otherwise 	 * not. 	 */
DECL|member|yy_at_bol
name|int
name|yy_at_bol
decl_stmt|;
DECL|member|yy_bs_lineno
name|int
name|yy_bs_lineno
decl_stmt|;
comment|/**< The line count. */
DECL|member|yy_bs_column
name|int
name|yy_bs_column
decl_stmt|;
comment|/**< The column count. */
comment|/* Whether to try to fill the input buffer when we reach the 	 * end of it. 	 */
DECL|member|yy_fill_buffer
name|int
name|yy_fill_buffer
decl_stmt|;
DECL|member|yy_buffer_status
name|int
name|yy_buffer_status
decl_stmt|;
DECL|macro|YY_BUFFER_NEW
define|#
directive|define
name|YY_BUFFER_NEW
value|0
DECL|macro|YY_BUFFER_NORMAL
define|#
directive|define
name|YY_BUFFER_NORMAL
value|1
comment|/* When an EOF's been seen but there's still some text to process 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we 	 * shouldn't try reading from the input source any more.  We might 	 * still have a bunch of tokens to match, though, because of 	 * possible backing-up. 	 * 	 * When we actually see the EOF, we change the status to "new" 	 * (via ncsa_restart()), so that the user can continue scanning by 	 * just pointing ncsa_in at a new input file. 	 */
DECL|macro|YY_BUFFER_EOF_PENDING
define|#
directive|define
name|YY_BUFFER_EOF_PENDING
value|2
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YY_STRUCT_YY_BUFFER_STATE */
end_comment

begin_comment
comment|/* Stack of input buffers. */
end_comment

begin_decl_stmt
DECL|variable|yy_buffer_stack_top
specifier|static
name|size_t
name|yy_buffer_stack_top
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|yy_buffer_stack_top
comment|/**< index of top of stack. */
end_comment

begin_decl_stmt
DECL|variable|yy_buffer_stack_max
specifier|static
name|size_t
name|yy_buffer_stack_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|yy_buffer_stack_max
comment|/**< capacity of stack. */
end_comment

begin_decl_stmt
DECL|variable|yy_buffer_stack
specifier|static
name|YY_BUFFER_STATE
modifier|*
name|yy_buffer_stack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|yy_buffer_stack
comment|/**< Stack as an array. */
end_comment

begin_comment
comment|/* We provide macros for accessing buffer states in case in the  * future we want to put the buffer states in a more general  * "scanner state".  *  * Returns the top of the stack, or NULL.  */
end_comment

begin_define
DECL|macro|YY_CURRENT_BUFFER
define|#
directive|define
name|YY_CURRENT_BUFFER
value|( (yy_buffer_stack) \                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \                           : NULL)
end_define

begin_comment
comment|/* Same as previous macro, but useful when we know that the buffer stack is not  * NULL or when we need an lvalue. For internal use only.  */
end_comment

begin_define
DECL|macro|YY_CURRENT_BUFFER_LVALUE
define|#
directive|define
name|YY_CURRENT_BUFFER_LVALUE
value|(yy_buffer_stack)[(yy_buffer_stack_top)]
end_define

begin_comment
comment|/* yy_hold_char holds the character lost when ncsa_text is formed. */
end_comment

begin_decl_stmt
DECL|variable|yy_hold_char
specifier|static
name|char
name|yy_hold_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_n_chars
specifier|static
name|int
name|yy_n_chars
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|yy_n_chars
comment|/* number of characters read into yy_ch_buf */
end_comment

begin_decl_stmt
DECL|variable|ncsa_leng
name|int
name|ncsa_leng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to current character in buffer. */
end_comment

begin_decl_stmt
DECL|variable|yy_c_buf_p
specifier|static
name|char
modifier|*
name|yy_c_buf_p
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_init
specifier|static
name|int
name|yy_init
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|yy_init
comment|/* whether we need to initialize */
end_comment

begin_decl_stmt
DECL|variable|yy_start
specifier|static
name|int
name|yy_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|yy_start
comment|/* start state number */
end_comment

begin_comment
comment|/* Flag which is used to allow ncsa_wrap()'s to do buffer switches  * instead of setting up a fresh ncsa_in.  A bit of a hack ...  */
end_comment

begin_decl_stmt
DECL|variable|yy_did_buffer_switch_on_eof
specifier|static
name|int
name|yy_did_buffer_switch_on_eof
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ncsa_restart
parameter_list|(
name|FILE
modifier|*
name|input_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ncsa__switch_to_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|YY_BUFFER_STATE
name|ncsa__create_buffer
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ncsa__delete_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ncsa__flush_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ncsa_push_buffer_state
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ncsa_pop_buffer_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncsa_ensure_buffer_stack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncsa__load_buffer_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncsa__init_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_define
DECL|macro|YY_FLUSH_BUFFER
define|#
directive|define
name|YY_FLUSH_BUFFER
value|ncsa__flush_buffer(YY_CURRENT_BUFFER )
end_define

begin_function_decl
name|YY_BUFFER_STATE
name|ncsa__scan_buffer
parameter_list|(
name|char
modifier|*
name|base
parameter_list|,
name|yy_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|YY_BUFFER_STATE
name|ncsa__scan_string
parameter_list|(
name|yyconst
name|char
modifier|*
name|yy_str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|YY_BUFFER_STATE
name|ncsa__scan_bytes
parameter_list|(
name|yyconst
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|ncsa_alloc
parameter_list|(
name|yy_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|ncsa_realloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|yy_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ncsa_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
DECL|macro|yy_new_buffer
define|#
directive|define
name|yy_new_buffer
value|ncsa__create_buffer
end_define

begin_define
DECL|macro|yy_set_interactive (is_interactive)
define|#
directive|define
name|yy_set_interactive
parameter_list|(
name|is_interactive
parameter_list|)
define|\
value|{ \ 	if ( ! YY_CURRENT_BUFFER ){ \         ncsa_ensure_buffer_stack (); \ 		YY_CURRENT_BUFFER_LVALUE =    \             ncsa__create_buffer(ncsa_in,YY_BUF_SIZE ); \ 	} \ 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \ 	}
end_define

begin_define
DECL|macro|yy_set_bol (at_bol)
define|#
directive|define
name|yy_set_bol
parameter_list|(
name|at_bol
parameter_list|)
define|\
value|{ \ 	if ( ! YY_CURRENT_BUFFER ){\         ncsa_ensure_buffer_stack (); \ 		YY_CURRENT_BUFFER_LVALUE =    \             ncsa__create_buffer(ncsa_in,YY_BUF_SIZE ); \ 	} \ 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \ 	}
end_define

begin_define
DECL|macro|YY_AT_BOL ()
define|#
directive|define
name|YY_AT_BOL
parameter_list|()
value|(YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
end_define

begin_comment
comment|/* Begin user sect3 */
end_comment

begin_define
DECL|macro|ncsa_wrap (n)
define|#
directive|define
name|ncsa_wrap
parameter_list|(
name|n
parameter_list|)
value|1
end_define

begin_define
DECL|macro|YY_SKIP_YYWRAP
define|#
directive|define
name|YY_SKIP_YYWRAP
end_define

begin_typedef
DECL|typedef|YY_CHAR
typedef|typedef
name|unsigned
name|char
name|YY_CHAR
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|ncsa_in
DECL|variable|ncsa_out
name|FILE
modifier|*
name|ncsa_in
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|ncsa_out
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|typedef|yy_state_type
typedef|typedef
name|int
name|yy_state_type
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|ncsa_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ncsa_lineno
name|int
name|ncsa_lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ncsa_text
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|yytext_ptr
define|#
directive|define
name|yytext_ptr
value|ncsa_text
end_define

begin_function_decl
specifier|static
name|yy_state_type
name|yy_get_previous_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|yy_state_type
name|yy_try_NUL_trans
parameter_list|(
name|yy_state_type
name|current_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yy_get_next_buffer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yy_fatal_error
parameter_list|(
name|yyconst
name|char
name|msg
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Done after the current pattern has been matched and before the  * corresponding action - sets up ncsa_text.  */
end_comment

begin_define
DECL|macro|YY_DO_BEFORE_ACTION
define|#
directive|define
name|YY_DO_BEFORE_ACTION
define|\
value|(yytext_ptr) = yy_bp; \ 	ncsa_leng = (size_t) (yy_cp - yy_bp); \ 	(yy_hold_char) = *yy_cp; \ 	*yy_cp = '\0'; \ 	(yy_c_buf_p) = yy_cp;
end_define

begin_define
DECL|macro|YY_NUM_RULES
define|#
directive|define
name|YY_NUM_RULES
value|14
end_define

begin_define
DECL|macro|YY_END_OF_BUFFER
define|#
directive|define
name|YY_END_OF_BUFFER
value|15
end_define

begin_comment
comment|/* This struct is not used in this scanner,    but its presence is necessary. */
end_comment

begin_struct
DECL|struct|yy_trans_info
struct|struct
name|yy_trans_info
block|{
DECL|member|yy_verify
name|flex_int32_t
name|yy_verify
decl_stmt|;
DECL|member|yy_nxt
name|flex_int32_t
name|yy_nxt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|yy_accept
specifier|static
name|yyconst
name|flex_int16_t
name|yy_accept
index|[
literal|76
index|]
init|=
block|{
literal|0
block|,
literal|11
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|5
block|,
literal|15
block|,
literal|13
block|,
literal|12
block|,
literal|12
block|,
literal|4
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|13
block|,
literal|13
block|,
literal|11
block|,
literal|13
block|,
literal|13
block|,
literal|10
block|,
literal|14
block|,
literal|5
block|,
literal|12
block|,
literal|0
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|8
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_ec
specifier|static
name|yyconst
name|flex_int32_t
name|yy_ec
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|12
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|1
block|,
literal|17
block|,
literal|18
block|,
literal|1
block|,
literal|1
block|,
literal|19
block|,
literal|1
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|1
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|27
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|12
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|1
block|,
literal|17
block|,
literal|18
block|,
literal|1
block|,
literal|1
block|,
literal|19
block|,
literal|1
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|1
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|27
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_meta
specifier|static
name|yyconst
name|flex_int32_t
name|yy_meta
index|[
literal|28
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_base
specifier|static
name|yyconst
name|flex_int16_t
name|yy_base
index|[
literal|80
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|26
block|,
literal|28
block|,
literal|114
block|,
literal|113
block|,
literal|115
block|,
literal|118
block|,
literal|34
block|,
literal|36
block|,
literal|109
block|,
literal|31
block|,
literal|32
block|,
literal|34
block|,
literal|95
block|,
literal|97
block|,
literal|42
block|,
literal|90
block|,
literal|95
block|,
literal|0
block|,
literal|118
block|,
literal|0
block|,
literal|51
block|,
literal|20
block|,
literal|41
block|,
literal|48
block|,
literal|54
block|,
literal|51
block|,
literal|86
block|,
literal|92
block|,
literal|97
block|,
literal|96
block|,
literal|86
block|,
literal|91
block|,
literal|0
block|,
literal|0
block|,
literal|77
block|,
literal|87
block|,
literal|83
block|,
literal|87
block|,
literal|87
block|,
literal|71
block|,
literal|72
block|,
literal|71
block|,
literal|71
block|,
literal|69
block|,
literal|74
block|,
literal|66
block|,
literal|118
block|,
literal|118
block|,
literal|74
block|,
literal|77
block|,
literal|70
block|,
literal|73
block|,
literal|68
block|,
literal|65
block|,
literal|62
block|,
literal|69
block|,
literal|118
block|,
literal|58
block|,
literal|59
block|,
literal|63
block|,
literal|69
block|,
literal|118
block|,
literal|68
block|,
literal|56
block|,
literal|118
block|,
literal|118
block|,
literal|52
block|,
literal|58
block|,
literal|54
block|,
literal|45
block|,
literal|48
block|,
literal|118
block|,
literal|118
block|,
literal|66
block|,
literal|69
block|,
literal|54
block|,
literal|72
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_def
specifier|static
name|yyconst
name|flex_int16_t
name|yy_def
index|[
literal|80
index|]
init|=
block|{
literal|0
block|,
literal|75
block|,
literal|1
block|,
literal|76
block|,
literal|76
block|,
literal|77
block|,
literal|77
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|78
block|,
literal|75
block|,
literal|79
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|78
block|,
literal|79
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|0
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_nxt
specifier|static
name|yyconst
name|flex_int16_t
name|yy_nxt
index|[
literal|146
index|]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|8
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|18
block|,
literal|19
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|37
block|,
literal|21
block|,
literal|38
block|,
literal|21
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|25
block|,
literal|26
block|,
literal|28
block|,
literal|25
block|,
literal|26
block|,
literal|39
block|,
literal|27
block|,
literal|27
block|,
literal|31
block|,
literal|27
block|,
literal|31
block|,
literal|28
block|,
literal|32
block|,
literal|23
block|,
literal|23
block|,
literal|35
block|,
literal|27
block|,
literal|25
block|,
literal|26
block|,
literal|74
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|27
block|,
literal|32
block|,
literal|73
block|,
literal|27
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|36
block|,
literal|36
block|,
literal|72
block|,
literal|71
block|,
literal|70
block|,
literal|69
block|,
literal|68
block|,
literal|67
block|,
literal|66
block|,
literal|65
block|,
literal|64
block|,
literal|63
block|,
literal|62
block|,
literal|61
block|,
literal|60
block|,
literal|59
block|,
literal|58
block|,
literal|57
block|,
literal|56
block|,
literal|55
block|,
literal|54
block|,
literal|53
block|,
literal|52
block|,
literal|51
block|,
literal|50
block|,
literal|49
block|,
literal|48
block|,
literal|47
block|,
literal|46
block|,
literal|45
block|,
literal|44
block|,
literal|43
block|,
literal|42
block|,
literal|32
block|,
literal|32
block|,
literal|41
block|,
literal|40
block|,
literal|34
block|,
literal|33
block|,
literal|30
block|,
literal|29
block|,
literal|24
block|,
literal|75
block|,
literal|21
block|,
literal|21
block|,
literal|7
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_chk
specifier|static
name|yyconst
name|flex_int16_t
name|yy_chk
index|[
literal|146
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|24
block|,
literal|3
block|,
literal|24
block|,
literal|4
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|14
block|,
literal|24
block|,
literal|12
block|,
literal|13
block|,
literal|17
block|,
literal|14
block|,
literal|17
block|,
literal|25
block|,
literal|17
block|,
literal|23
block|,
literal|23
block|,
literal|78
block|,
literal|25
block|,
literal|26
block|,
literal|26
block|,
literal|73
block|,
literal|27
block|,
literal|28
block|,
literal|27
block|,
literal|26
block|,
literal|27
block|,
literal|72
block|,
literal|28
block|,
literal|76
block|,
literal|76
block|,
literal|76
block|,
literal|77
block|,
literal|77
block|,
literal|77
block|,
literal|79
block|,
literal|79
block|,
literal|71
block|,
literal|70
block|,
literal|69
block|,
literal|66
block|,
literal|65
block|,
literal|63
block|,
literal|62
block|,
literal|61
block|,
literal|60
block|,
literal|58
block|,
literal|57
block|,
literal|56
block|,
literal|55
block|,
literal|54
block|,
literal|53
block|,
literal|52
block|,
literal|51
block|,
literal|48
block|,
literal|47
block|,
literal|46
block|,
literal|45
block|,
literal|44
block|,
literal|43
block|,
literal|42
block|,
literal|41
block|,
literal|40
block|,
literal|39
block|,
literal|38
block|,
literal|37
block|,
literal|34
block|,
literal|33
block|,
literal|32
block|,
literal|31
block|,
literal|30
block|,
literal|29
block|,
literal|19
block|,
literal|18
block|,
literal|16
block|,
literal|15
block|,
literal|11
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|,
literal|75
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_last_accepting_state
specifier|static
name|yy_state_type
name|yy_last_accepting_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|yy_last_accepting_cpos
specifier|static
name|char
modifier|*
name|yy_last_accepting_cpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ncsa__flex_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ncsa__flex_debug
name|int
name|ncsa__flex_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The intent behind this definition is that it'll catch  * any uses of REJECT which flex missed.  */
end_comment

begin_define
DECL|macro|REJECT
define|#
directive|define
name|REJECT
value|reject_used_but_not_detected
end_define

begin_define
DECL|macro|yymore ()
define|#
directive|define
name|yymore
parameter_list|()
value|yymore_used_but_not_detected
end_define

begin_define
DECL|macro|YY_MORE_ADJ
define|#
directive|define
name|YY_MORE_ADJ
value|0
end_define

begin_define
DECL|macro|YY_RESTORE_YY_MORE_OFFSET
define|#
directive|define
name|YY_RESTORE_YY_MORE_OFFSET
end_define

begin_decl_stmt
DECL|variable|ncsa_text
name|char
modifier|*
name|ncsa_text
decl_stmt|;
end_decl_stmt

begin_line
line|#
directive|line
number|1
file|"imap_ncsa.l"
end_line

begin_line
line|#
directive|line
number|2
file|"imap_ncsa.l"
end_line

begin_comment
comment|/*  * This is a plug-in for the GIMP.  *  * Generates clickable image maps.  *  * Copyright (C) 1998-1999 Maurits Rijk  lpeek.mrijk@consunet.nl  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"imap_ncsa_parse.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FLEX_SCANNER
end_ifdef

begin_define
DECL|macro|YY_NO_UNPUT
define|#
directive|define
name|YY_NO_UNPUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLEX_SCANNER */
end_comment

begin_line
line|#
directive|line
number|537
file|"<stdout>"
end_line

begin_define
DECL|macro|INITIAL
define|#
directive|define
name|INITIAL
value|0
end_define

begin_define
DECL|macro|link
define|#
directive|define
name|link
value|1
end_define

begin_define
DECL|macro|comment
define|#
directive|define
name|comment
value|2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YY_NO_UNISTD_H
end_ifndef

begin_comment
comment|/* Special case for "unistd.h", since it is non-ANSI. We include it way  * down here because we want the user's section 1 to have been scanned first.  * The user has a chance to override it with an option.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YY_EXTRA_TYPE
end_ifndef

begin_define
DECL|macro|YY_EXTRA_TYPE
define|#
directive|define
name|YY_EXTRA_TYPE
value|void *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros after this point can all be overridden by user definitions in  * section 1.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_SKIP_YYWRAP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
name|int
name|ncsa_wrap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_extern

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|ncsa_wrap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|yyunput
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|buf_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|yytext_ptr
end_ifndef

begin_function_decl
specifier|static
name|void
name|yy_flex_strncpy
parameter_list|(
name|char
modifier|*
parameter_list|,
name|yyconst
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YY_NEED_STRLEN
end_ifdef

begin_function_decl
specifier|static
name|int
name|yy_flex_strlen
parameter_list|(
name|yyconst
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YY_NO_INPUT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_function_decl
specifier|static
name|int
name|yyinput
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|input
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Amount of stuff to slurp up with each read. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_READ_BUF_SIZE
end_ifndef

begin_define
DECL|macro|YY_READ_BUF_SIZE
define|#
directive|define
name|YY_READ_BUF_SIZE
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copy whatever the last rule matched to the standard output. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ECHO
end_ifndef

begin_comment
comment|/* This used to be an fputs(), but since the string might contain NUL's,  * we now use fwrite().  */
end_comment

begin_define
DECL|macro|ECHO
define|#
directive|define
name|ECHO
value|(void) fwrite( ncsa_text, ncsa_leng, 1, ncsa_out )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,  * is returned in "result".  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_INPUT
end_ifndef

begin_define
DECL|macro|YY_INPUT (buf,result,max_size)
define|#
directive|define
name|YY_INPUT
parameter_list|(
name|buf
parameter_list|,
name|result
parameter_list|,
name|max_size
parameter_list|)
define|\
value|if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \ 		{ \ 		int c = '*'; \ 		size_t n; \ 		for ( n = 0; n< max_size&& \ 			     (c = getc( ncsa_in )) != EOF&& c != '\n'; ++n ) \ 			buf[n] = (char) c; \ 		if ( c == '\n' ) \ 			buf[n++] = (char) c; \ 		if ( c == EOF&& ferror( ncsa_in ) ) \ 			YY_FATAL_ERROR( "input in flex scanner failed" ); \ 		result = n; \ 		} \ 	else \ 		{ \ 		errno=0; \ 		while ( (result = fread(buf, 1, max_size, ncsa_in))==0&& ferror(ncsa_in)) \ 			{ \ 			if( errno != EINTR) \ 				{ \ 				YY_FATAL_ERROR( "input in flex scanner failed" ); \ 				break; \ 				} \ 			errno=0; \ 			clearerr(ncsa_in); \ 			} \ 		}\ \  #endif
end_define

begin_comment
comment|/* No semi-colon after return; correct usage is to write "yyterminate();" -  * we don't want an extra ';' after the "return" because that will cause  * some compilers to complain about unreachable statements.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|yyterminate
end_ifndef

begin_define
DECL|macro|yyterminate ()
define|#
directive|define
name|yyterminate
parameter_list|()
value|return YY_NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of entries by which start-condition stack grows. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_START_STACK_INCR
end_ifndef

begin_define
DECL|macro|YY_START_STACK_INCR
define|#
directive|define
name|YY_START_STACK_INCR
value|25
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Report a fatal error. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_FATAL_ERROR
end_ifndef

begin_define
DECL|macro|YY_FATAL_ERROR (msg)
define|#
directive|define
name|YY_FATAL_ERROR
parameter_list|(
name|msg
parameter_list|)
value|yy_fatal_error( msg )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end tables serialization structures and prototypes */
end_comment

begin_comment
comment|/* Default declaration of generated scanner - a define so the user can  * easily add parameters.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_DECL
end_ifndef

begin_define
DECL|macro|YY_DECL_IS_OURS
define|#
directive|define
name|YY_DECL_IS_OURS
value|1
end_define

begin_function_decl
specifier|extern
name|int
name|ncsa_lex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
DECL|macro|YY_DECL
define|#
directive|define
name|YY_DECL
value|int ncsa_lex (void)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YY_DECL */
end_comment

begin_comment
comment|/* Code executed at the beginning of each rule, after ncsa_text and ncsa_leng  * have been set up.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_USER_ACTION
end_ifndef

begin_define
DECL|macro|YY_USER_ACTION
define|#
directive|define
name|YY_USER_ACTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Code executed at the end of each rule. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YY_BREAK
end_ifndef

begin_define
DECL|macro|YY_BREAK
define|#
directive|define
name|YY_BREAK
value|break;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|YY_RULE_SETUP
define|#
directive|define
name|YY_RULE_SETUP
define|\
value|YY_USER_ACTION
end_define

begin_comment
comment|/** The main scanner function which does all the work.  */
end_comment

begin_macro
name|YY_DECL
end_macro

begin_block
block|{
DECL|variable|yy_current_state
specifier|register
name|yy_state_type
name|yy_current_state
decl_stmt|;
DECL|variable|yy_cp
DECL|variable|yy_bp
specifier|register
name|char
modifier|*
name|yy_cp
decl_stmt|,
modifier|*
name|yy_bp
decl_stmt|;
DECL|variable|yy_act
specifier|register
name|int
name|yy_act
decl_stmt|;
line|#
directive|line
number|50
file|"imap_ncsa.l"
line|#
directive|line
number|693
file|"<stdout>"
if|if
condition|(
operator|(
name|yy_init
operator|)
condition|)
block|{
operator|(
name|yy_init
operator|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|YY_USER_INIT
name|YY_USER_INIT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|yy_start
operator|)
condition|)
operator|(
name|yy_start
operator|)
operator|=
literal|1
expr_stmt|;
comment|/* first start state */
if|if
condition|(
operator|!
name|ncsa_in
condition|)
name|ncsa_in
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|ncsa_out
condition|)
name|ncsa_out
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
block|{
name|ncsa_ensure_buffer_stack
argument_list|()
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|ncsa__create_buffer
argument_list|(
name|ncsa_in
argument_list|,
name|YY_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
name|ncsa__load_buffer_state
argument_list|( )
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
comment|/* loops until end-of-file is reached */
block|{
name|yy_cp
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
comment|/* Support of ncsa_text. */
operator|*
name|yy_cp
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
comment|/* yy_bp points to the position in yy_ch_buf of the start of 		 * the current run. 		 */
name|yy_bp
operator|=
name|yy_cp
expr_stmt|;
name|yy_current_state
operator|=
operator|(
name|yy_start
operator|)
expr_stmt|;
name|yy_match
label|:
do|do
block|{
DECL|variable|yy_c
specifier|register
name|YY_CHAR
name|yy_c
init|=
name|yy_ec
index|[
name|YY_SC_TO_UI
argument_list|(
operator|*
name|yy_cp
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|yy_accept
index|[
name|yy_current_state
index|]
condition|)
block|{
operator|(
name|yy_last_accepting_state
operator|)
operator|=
name|yy_current_state
expr_stmt|;
operator|(
name|yy_last_accepting_cpos
operator|)
operator|=
name|yy_cp
expr_stmt|;
block|}
while|while
condition|(
name|yy_chk
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
name|yy_c
index|]
operator|!=
name|yy_current_state
condition|)
block|{
name|yy_current_state
operator|=
operator|(
name|int
operator|)
name|yy_def
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_current_state
operator|>=
literal|76
condition|)
name|yy_c
operator|=
name|yy_meta
index|[
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
name|yy_current_state
operator|=
name|yy_nxt
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
operator|++
name|yy_cp
expr_stmt|;
block|}
do|while
condition|(
name|yy_base
index|[
name|yy_current_state
index|]
operator|!=
literal|118
condition|)
do|;
name|yy_find_action
label|:
name|yy_act
operator|=
name|yy_accept
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_act
operator|==
literal|0
condition|)
block|{
comment|/* have to back up */
name|yy_cp
operator|=
operator|(
name|yy_last_accepting_cpos
operator|)
expr_stmt|;
name|yy_current_state
operator|=
operator|(
name|yy_last_accepting_state
operator|)
expr_stmt|;
name|yy_act
operator|=
name|yy_accept
index|[
name|yy_current_state
index|]
expr_stmt|;
block|}
name|YY_DO_BEFORE_ACTION
expr_stmt|;
name|do_action
label|:
comment|/* This label is used only to access EOF actions. */
switch|switch
condition|(
name|yy_act
condition|)
block|{
comment|/* beginning of action switch */
case|case
literal|0
case|:
comment|/* must back up */
comment|/* undo the effects of YY_DO_BEFORE_ACTION */
operator|*
name|yy_cp
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
name|yy_cp
operator|=
operator|(
name|yy_last_accepting_cpos
operator|)
expr_stmt|;
name|yy_current_state
operator|=
operator|(
name|yy_last_accepting_state
operator|)
expr_stmt|;
goto|goto
name|yy_find_action
goto|;
case|case
literal|1
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|52
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
name|AUTHOR
return|;
block|}
name|YY_BREAK
case|case
literal|2
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|57
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
name|TITLE
return|;
block|}
name|YY_BREAK
case|case
literal|3
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|62
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
name|DESCRIPTION
return|;
block|}
name|YY_BREAK
case|case
literal|4
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|67
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
name|BEGIN_COMMENT
return|;
block|}
name|YY_BREAK
case|case
literal|5
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|72
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|INITIAL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ncsa_lval
operator|.
name|id
argument_list|,
name|ncsa_text
argument_list|)
expr_stmt|;
return|return
name|COMMENT
return|;
block|}
name|YY_BREAK
case|case
literal|6
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|78
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
return|return
name|RECTANGLE
return|;
block|}
name|YY_BREAK
case|case
literal|7
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|83
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
return|return
name|CIRCLE
return|;
block|}
name|YY_BREAK
case|case
literal|8
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|88
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
return|return
name|POLYGON
return|;
block|}
name|YY_BREAK
case|case
literal|9
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|93
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
return|return
name|DEFAULT
return|;
block|}
name|YY_BREAK
case|case
literal|10
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|98
file|"imap_ncsa.l"
block|{
name|BEGIN
argument_list|(
name|INITIAL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ncsa_lval
operator|.
name|id
argument_list|,
name|ncsa_text
argument_list|)
expr_stmt|;
name|ncsa_lval
operator|.
name|id
index|[
name|ncsa_leng
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|LINK
return|;
block|}
name|YY_BREAK
case|case
literal|11
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|105
file|"imap_ncsa.l"
block|{
name|ncsa_lval
operator|.
name|value
operator|=
name|atof
argument_list|(
name|ncsa_text
argument_list|)
expr_stmt|;
return|return
name|FLOAT
return|;
block|}
name|YY_BREAK
case|case
literal|12
case|:
comment|/* rule 12 can match eol */
name|YY_RULE_SETUP
line|#
directive|line
number|110
file|"imap_ncsa.l"
expr_stmt|;
comment|/* Eat white space */
name|YY_BREAK
case|case
literal|13
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|112
file|"imap_ncsa.l"
return|return
operator|*
name|ncsa_text
return|;
name|YY_BREAK
case|case
literal|14
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|114
file|"imap_ncsa.l"
DECL|variable|ECHO
name|ECHO
decl_stmt|;
name|YY_BREAK
line|#
directive|line
number|883
file|"<stdout>"
case|case
name|YY_STATE_EOF
argument_list|(
name|INITIAL
argument_list|)
case|:
case|case
name|YY_STATE_EOF
argument_list|(
name|link
argument_list|)
case|:
case|case
name|YY_STATE_EOF
argument_list|(
name|comment
argument_list|)
case|:
name|yyterminate
argument_list|()
expr_stmt|;
case|case
name|YY_END_OF_BUFFER
case|:
block|{
comment|/* Amount of text matched not including the EOB char. */
DECL|variable|yy_amount_of_matched_text
name|int
name|yy_amount_of_matched_text
init|=
call|(
name|int
call|)
argument_list|(
name|yy_cp
operator|-
operator|(
name|yytext_ptr
operator|)
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Undo the effects of YY_DO_BEFORE_ACTION. */
operator|*
name|yy_cp
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
name|YY_RESTORE_YY_MORE_OFFSET
if|if
condition|(
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|==
name|YY_BUFFER_NEW
condition|)
block|{
comment|/* We're scanning a new file or input source.  It's 			 * possible that this happened because the user 			 * just pointed ncsa_in at a new source and called 			 * ncsa_lex().  If so, then we have to assure 			 * consistency between YY_CURRENT_BUFFER and our 			 * globals.  Here is the right place to do so, because 			 * this is the first action (other than possibly a 			 * back-up) that will match for the new input source. 			 */
operator|(
name|yy_n_chars
operator|)
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_input_file
operator|=
name|ncsa_in
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_NORMAL
expr_stmt|;
block|}
comment|/* Note that here we test for yy_c_buf_p "<=" to the position 		 * of the first EOB in the buffer, since yy_c_buf_p will 		 * already have been incremented past the NUL character 		 * (since all states make transitions on EOB to the 		 * end-of-buffer state).  Contrast this with the test 		 * in input(). 		 */
if|if
condition|(
operator|(
name|yy_c_buf_p
operator|)
operator|<=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
operator|(
name|yy_n_chars
operator|)
index|]
condition|)
block|{
comment|/* This was really a NUL. */
DECL|variable|yy_next_state
name|yy_state_type
name|yy_next_state
decl_stmt|;
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|yy_amount_of_matched_text
expr_stmt|;
name|yy_current_state
operator|=
name|yy_get_previous_state
argument_list|(  )
expr_stmt|;
comment|/* Okay, we're now positioned to make the NUL 			 * transition.  We couldn't have 			 * yy_get_previous_state() go ahead and do it 			 * for us because it doesn't know how to deal 			 * with the possibility of jamming (and we don't 			 * want to build jamming into it because then it 			 * will run more slowly). 			 */
name|yy_next_state
operator|=
name|yy_try_NUL_trans
argument_list|(
name|yy_current_state
argument_list|)
expr_stmt|;
name|yy_bp
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|YY_MORE_ADJ
expr_stmt|;
if|if
condition|(
name|yy_next_state
condition|)
block|{
comment|/* Consume the NUL. */
name|yy_cp
operator|=
operator|++
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
name|yy_current_state
operator|=
name|yy_next_state
expr_stmt|;
goto|goto
name|yy_match
goto|;
block|}
else|else
block|{
name|yy_cp
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
goto|goto
name|yy_find_action
goto|;
block|}
block|}
else|else
switch|switch
condition|(
name|yy_get_next_buffer
argument_list|(  )
condition|)
block|{
case|case
name|EOB_ACT_END_OF_FILE
case|:
block|{
operator|(
name|yy_did_buffer_switch_on_eof
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ncsa_wrap
argument_list|( )
condition|)
block|{
comment|/* Note: because we've taken care in 					 * yy_get_next_buffer() to have set up 					 * ncsa_text, we can now set up 					 * yy_c_buf_p so that if some total 					 * hoser (like flex itself) wants to 					 * call the scanner after we return the 					 * YY_NULL, it'll still work - another 					 * YY_NULL will get returned. 					 */
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|YY_MORE_ADJ
expr_stmt|;
name|yy_act
operator|=
name|YY_STATE_EOF
argument_list|(
name|YY_START
argument_list|)
expr_stmt|;
goto|goto
name|do_action
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|yy_did_buffer_switch_on_eof
operator|)
condition|)
name|YY_NEW_FILE
expr_stmt|;
block|}
break|break;
block|}
case|case
name|EOB_ACT_CONTINUE_SCAN
case|:
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|yy_amount_of_matched_text
expr_stmt|;
name|yy_current_state
operator|=
name|yy_get_previous_state
argument_list|(  )
expr_stmt|;
name|yy_cp
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
name|yy_bp
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|YY_MORE_ADJ
expr_stmt|;
goto|goto
name|yy_match
goto|;
case|case
name|EOB_ACT_LAST_MATCH
case|:
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
operator|(
name|yy_n_chars
operator|)
index|]
expr_stmt|;
name|yy_current_state
operator|=
name|yy_get_previous_state
argument_list|(  )
expr_stmt|;
name|yy_cp
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
name|yy_bp
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|YY_MORE_ADJ
expr_stmt|;
goto|goto
name|yy_find_action
goto|;
block|}
break|break;
block|}
default|default:
name|YY_FATAL_ERROR
argument_list|(
literal|"fatal flex scanner internal error--no action found"
argument_list|)
expr_stmt|;
block|}
comment|/* end of action switch */
block|}
comment|/* end of scanning one token */
block|}
end_block

begin_comment
comment|/* end of ncsa_lex */
end_comment

begin_comment
comment|/* yy_get_next_buffer - try to read in a new buffer  *  * Returns a code representing an action:  *	EOB_ACT_LAST_MATCH -  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position  *	EOB_ACT_END_OF_FILE - end of file  */
end_comment

begin_function
DECL|function|yy_get_next_buffer (void)
specifier|static
name|int
name|yy_get_next_buffer
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|dest
init|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|source
init|=
operator|(
name|yytext_ptr
operator|)
decl_stmt|;
specifier|register
name|int
name|number_to_move
decl_stmt|,
name|i
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
if|if
condition|(
operator|(
name|yy_c_buf_p
operator|)
operator|>
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
operator|(
name|yy_n_chars
operator|)
operator|+
literal|1
index|]
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"fatal flex scanner internal error--end of buffer missed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_fill_buffer
operator|==
literal|0
condition|)
block|{
comment|/* Don't try to fill the buffer, so this is an EOF. */
if|if
condition|(
operator|(
name|yy_c_buf_p
operator|)
operator|-
operator|(
name|yytext_ptr
operator|)
operator|-
name|YY_MORE_ADJ
operator|==
literal|1
condition|)
block|{
comment|/* We matched a single character, the EOB, so 			 * treat this as a final EOF. 			 */
return|return
name|EOB_ACT_END_OF_FILE
return|;
block|}
else|else
block|{
comment|/* We matched some text prior to the EOB, first 			 * process it. 			 */
return|return
name|EOB_ACT_LAST_MATCH
return|;
block|}
block|}
comment|/* Try to read more data. */
comment|/* First move last chars to start of buffer. */
name|number_to_move
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|yy_c_buf_p
operator|)
operator|-
operator|(
name|yytext_ptr
operator|)
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_to_move
condition|;
operator|++
name|i
control|)
operator|*
operator|(
name|dest
operator|++
operator|)
operator|=
operator|*
operator|(
name|source
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|==
name|YY_BUFFER_EOF_PENDING
condition|)
comment|/* don't do the read, it's not guaranteed to return an EOF, 		 * just force an EOF 		 */
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
operator|(
name|yy_n_chars
operator|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|size_t
name|num_to_read
init|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
operator|-
name|number_to_move
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|num_to_read
operator|<=
literal|0
condition|)
block|{
comment|/* Not enough room in the buffer - grow it. */
comment|/* just a shorter name for the current buffer */
name|YY_BUFFER_STATE
name|b
init|=
name|YY_CURRENT_BUFFER
decl_stmt|;
name|int
name|yy_c_buf_p_offset
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|yy_c_buf_p
operator|)
operator|-
name|b
operator|->
name|yy_ch_buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|yy_is_our_buffer
condition|)
block|{
name|int
name|new_size
init|=
name|b
operator|->
name|yy_buf_size
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|new_size
operator|<=
literal|0
condition|)
name|b
operator|->
name|yy_buf_size
operator|+=
name|b
operator|->
name|yy_buf_size
operator|/
literal|8
expr_stmt|;
else|else
name|b
operator|->
name|yy_buf_size
operator|*=
literal|2
expr_stmt|;
name|b
operator|->
name|yy_ch_buf
operator|=
operator|(
name|char
operator|*
operator|)
comment|/* Include room in for 2 EOB chars. */
name|ncsa_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
operator|->
name|yy_ch_buf
argument_list|,
name|b
operator|->
name|yy_buf_size
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Can't grow it, we don't own it. */
name|b
operator|->
name|yy_ch_buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|yy_ch_buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"fatal error - scanner input buffer overflow"
argument_list|)
expr_stmt|;
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|&
name|b
operator|->
name|yy_ch_buf
index|[
name|yy_c_buf_p_offset
index|]
expr_stmt|;
name|num_to_read
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
operator|-
name|number_to_move
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_to_read
operator|>
name|YY_READ_BUF_SIZE
condition|)
name|num_to_read
operator|=
name|YY_READ_BUF_SIZE
expr_stmt|;
comment|/* Read in more data. */
name|YY_INPUT
argument_list|(
operator|(
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|number_to_move
index|]
operator|)
argument_list|,
operator|(
name|yy_n_chars
operator|)
argument_list|,
name|num_to_read
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
operator|(
name|yy_n_chars
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|yy_n_chars
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|number_to_move
operator|==
name|YY_MORE_ADJ
condition|)
block|{
name|ret_val
operator|=
name|EOB_ACT_END_OF_FILE
expr_stmt|;
name|ncsa_restart
argument_list|(
name|ncsa_in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|EOB_ACT_LAST_MATCH
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_EOF_PENDING
expr_stmt|;
block|}
block|}
else|else
name|ret_val
operator|=
name|EOB_ACT_CONTINUE_SCAN
expr_stmt|;
operator|(
name|yy_n_chars
operator|)
operator|+=
name|number_to_move
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
operator|(
name|yy_n_chars
operator|)
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
operator|(
name|yy_n_chars
operator|)
operator|+
literal|1
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
operator|(
name|yytext_ptr
operator|)
operator|=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
literal|0
index|]
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* yy_get_previous_state - get the state just before the EOB char was reached */
end_comment

begin_function
DECL|function|yy_get_previous_state (void)
specifier|static
name|yy_state_type
name|yy_get_previous_state
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|yy_state_type
name|yy_current_state
decl_stmt|;
specifier|register
name|char
modifier|*
name|yy_cp
decl_stmt|;
name|yy_current_state
operator|=
operator|(
name|yy_start
operator|)
expr_stmt|;
for|for
control|(
name|yy_cp
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|YY_MORE_ADJ
init|;
name|yy_cp
operator|<
operator|(
name|yy_c_buf_p
operator|)
condition|;
operator|++
name|yy_cp
control|)
block|{
specifier|register
name|YY_CHAR
name|yy_c
init|=
operator|(
operator|*
name|yy_cp
condition|?
name|yy_ec
index|[
name|YY_SC_TO_UI
argument_list|(
operator|*
name|yy_cp
argument_list|)
index|]
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|yy_accept
index|[
name|yy_current_state
index|]
condition|)
block|{
operator|(
name|yy_last_accepting_state
operator|)
operator|=
name|yy_current_state
expr_stmt|;
operator|(
name|yy_last_accepting_cpos
operator|)
operator|=
name|yy_cp
expr_stmt|;
block|}
while|while
condition|(
name|yy_chk
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
name|yy_c
index|]
operator|!=
name|yy_current_state
condition|)
block|{
name|yy_current_state
operator|=
operator|(
name|int
operator|)
name|yy_def
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_current_state
operator|>=
literal|76
condition|)
name|yy_c
operator|=
name|yy_meta
index|[
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
name|yy_current_state
operator|=
name|yy_nxt
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
return|return
name|yy_current_state
return|;
block|}
end_function

begin_comment
comment|/* yy_try_NUL_trans - try to make a transition on the NUL character  *  * synopsis  *	next_state = yy_try_NUL_trans( current_state );  */
end_comment

begin_function
DECL|function|yy_try_NUL_trans (yy_state_type yy_current_state)
specifier|static
name|yy_state_type
name|yy_try_NUL_trans
parameter_list|(
name|yy_state_type
name|yy_current_state
parameter_list|)
block|{
specifier|register
name|int
name|yy_is_jam
decl_stmt|;
specifier|register
name|char
modifier|*
name|yy_cp
init|=
operator|(
name|yy_c_buf_p
operator|)
decl_stmt|;
specifier|register
name|YY_CHAR
name|yy_c
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|yy_accept
index|[
name|yy_current_state
index|]
condition|)
block|{
operator|(
name|yy_last_accepting_state
operator|)
operator|=
name|yy_current_state
expr_stmt|;
operator|(
name|yy_last_accepting_cpos
operator|)
operator|=
name|yy_cp
expr_stmt|;
block|}
while|while
condition|(
name|yy_chk
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
name|yy_c
index|]
operator|!=
name|yy_current_state
condition|)
block|{
name|yy_current_state
operator|=
operator|(
name|int
operator|)
name|yy_def
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_current_state
operator|>=
literal|76
condition|)
name|yy_c
operator|=
name|yy_meta
index|[
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
name|yy_current_state
operator|=
name|yy_nxt
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
name|yy_is_jam
operator|=
operator|(
name|yy_current_state
operator|==
literal|75
operator|)
expr_stmt|;
return|return
name|yy_is_jam
condition|?
literal|0
else|:
name|yy_current_state
return|;
block|}
end_function

begin_function
DECL|function|yyunput (int c,register char * yy_bp)
specifier|static
name|void
name|yyunput
parameter_list|(
name|int
name|c
parameter_list|,
specifier|register
name|char
modifier|*
name|yy_bp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|yy_cp
decl_stmt|;
name|yy_cp
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
comment|/* undo effects of setting up ncsa_text */
operator|*
name|yy_cp
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
if|if
condition|(
name|yy_cp
operator|<
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
operator|+
literal|2
condition|)
block|{
comment|/* need to shift things up to make room */
comment|/* +2 for EOB chars. */
specifier|register
name|int
name|number_to_move
init|=
operator|(
name|yy_n_chars
operator|)
operator|+
literal|2
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
init|=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
operator|+
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|source
init|=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|number_to_move
index|]
decl_stmt|;
while|while
condition|(
name|source
operator|>
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
condition|)
operator|*
operator|--
name|dest
operator|=
operator|*
operator|--
name|source
expr_stmt|;
name|yy_cp
operator|+=
call|(
name|int
call|)
argument_list|(
name|dest
operator|-
name|source
argument_list|)
expr_stmt|;
name|yy_bp
operator|+=
call|(
name|int
call|)
argument_list|(
name|dest
operator|-
name|source
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
operator|(
name|yy_n_chars
operator|)
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
expr_stmt|;
if|if
condition|(
name|yy_cp
operator|<
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
operator|+
literal|2
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"flex scanner push-back overflow"
argument_list|)
expr_stmt|;
block|}
operator|*
operator|--
name|yy_cp
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
operator|(
name|yytext_ptr
operator|)
operator|=
name|yy_bp
expr_stmt|;
operator|(
name|yy_hold_char
operator|)
operator|=
operator|*
name|yy_cp
expr_stmt|;
operator|(
name|yy_c_buf_p
operator|)
operator|=
name|yy_cp
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|YY_NO_INPUT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_decl_stmt
DECL|function|yyinput (void)
specifier|static
name|int
name|yyinput
argument_list|(
name|void
argument_list|)
else|#
directive|else
decl|static
name|int
name|input
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|int
name|c
decl_stmt|;
operator|*
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|yy_c_buf_p
operator|)
operator|==
name|YY_END_OF_BUFFER_CHAR
condition|)
block|{
comment|/* yy_c_buf_p now points to the character we want to return. 		 * If this occurs *before* the EOB characters, then it's a 		 * valid NUL; if not, then we've hit the end of the buffer. 		 */
if|if
condition|(
operator|(
name|yy_c_buf_p
operator|)
operator|<
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
operator|(
name|yy_n_chars
operator|)
index|]
condition|)
comment|/* This was really a NUL. */
operator|*
operator|(
name|yy_c_buf_p
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
comment|/* need more input */
name|int
name|offset
init|=
operator|(
name|yy_c_buf_p
operator|)
operator|-
operator|(
name|yytext_ptr
operator|)
decl_stmt|;
operator|++
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
switch|switch
condition|(
name|yy_get_next_buffer
argument_list|(  )
condition|)
block|{
case|case
name|EOB_ACT_LAST_MATCH
case|:
comment|/* This happens because yy_g_n_b() 					 * sees that we've accumulated a 					 * token and flags that we need to 					 * try matching the token before 					 * proceeding.  But for input(), 					 * there's no matching to consider. 					 * So convert the EOB_ACT_LAST_MATCH 					 * to EOB_ACT_END_OF_FILE. 					 */
comment|/* Reset buffer status. */
name|ncsa_restart
argument_list|(
name|ncsa_in
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|EOB_ACT_END_OF_FILE
case|:
block|{
if|if
condition|(
name|ncsa_wrap
argument_list|( )
condition|)
return|return
name|EOF
return|;
if|if
condition|(
operator|!
operator|(
name|yy_did_buffer_switch_on_eof
operator|)
condition|)
name|YY_NEW_FILE
expr_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
return|return
name|yyinput
argument_list|()
return|;
else|#
directive|else
return|return
name|input
argument_list|()
return|;
endif|#
directive|endif
block|}
case|case
name|EOB_ACT_CONTINUE_SCAN
case|:
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yytext_ptr
operator|)
operator|+
name|offset
expr_stmt|;
break|break;
block|}
block|}
block|}
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
comment|/* cast for 8-bit char's */
operator|*
operator|(
name|yy_c_buf_p
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* preserve ncsa_text */
operator|(
name|yy_hold_char
operator|)
operator|=
operator|*
operator|++
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifndef YY_NO_INPUT */
end_comment

begin_comment
comment|/** Immediately switch to a different input stream.  * @param input_file A readable stream.  *   * @note This function does not reset the start condition to @c INITIAL .  */
end_comment

begin_function
DECL|function|ncsa_restart (FILE * input_file)
name|void
name|ncsa_restart
parameter_list|(
name|FILE
modifier|*
name|input_file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
block|{
name|ncsa_ensure_buffer_stack
argument_list|()
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|ncsa__create_buffer
argument_list|(
name|ncsa_in
argument_list|,
name|YY_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
name|ncsa__init_buffer
argument_list|(
name|YY_CURRENT_BUFFER
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
name|ncsa__load_buffer_state
argument_list|( )
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Switch to a different input buffer.  * @param new_buffer The new input buffer.  *   */
end_comment

begin_function
DECL|function|ncsa__switch_to_buffer (YY_BUFFER_STATE new_buffer)
name|void
name|ncsa__switch_to_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|)
block|{
comment|/* TODO. We should be able to replace this entire function body 	 * with 	 *		ncsa_pop_buffer_state(); 	 *		ncsa_push_buffer_state(new_buffer);      */
name|ncsa_ensure_buffer_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER
operator|==
name|new_buffer
condition|)
return|return;
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
comment|/* Flush out information for old buffer. */
operator|*
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_pos
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
operator|(
name|yy_n_chars
operator|)
expr_stmt|;
block|}
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|new_buffer
expr_stmt|;
name|ncsa__load_buffer_state
argument_list|( )
expr_stmt|;
comment|/* We don't actually know whether we did this switch during 	 * EOF (ncsa_wrap()) processing, but the only time this flag 	 * is looked at is after ncsa_wrap() is called, so it's safe 	 * to go ahead and always set it. 	 */
operator|(
name|yy_did_buffer_switch_on_eof
operator|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
DECL|function|ncsa__load_buffer_state (void)
specifier|static
name|void
name|ncsa__load_buffer_state
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|yy_n_chars
operator|)
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
expr_stmt|;
operator|(
name|yytext_ptr
operator|)
operator|=
operator|(
name|yy_c_buf_p
operator|)
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_pos
expr_stmt|;
name|ncsa_in
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_input_file
expr_stmt|;
operator|(
name|yy_hold_char
operator|)
operator|=
operator|*
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Allocate and initialize an input buffer state.  * @param file A readable stream.  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.  *   * @return the allocated buffer state.  */
end_comment

begin_function
DECL|function|ncsa__create_buffer (FILE * file,int size)
name|YY_BUFFER_STATE
name|ncsa__create_buffer
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|YY_BUFFER_STATE
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|YY_BUFFER_STATE
operator|)
name|ncsa_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in ncsa__create_buffer()"
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_buf_size
operator|=
name|size
expr_stmt|;
comment|/* yy_ch_buf has to be 2 characters longer than the size given because 	 * we need to put in 2 end-of-buffer characters. 	 */
name|b
operator|->
name|yy_ch_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ncsa_alloc
argument_list|(
name|b
operator|->
name|yy_buf_size
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|yy_ch_buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in ncsa__create_buffer()"
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_is_our_buffer
operator|=
literal|1
expr_stmt|;
name|ncsa__init_buffer
argument_list|(
name|b
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/** Destroy the buffer.  * @param b a buffer created with ncsa__create_buffer()  *   */
end_comment

begin_function
DECL|function|ncsa__delete_buffer (YY_BUFFER_STATE b)
name|void
name|ncsa__delete_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return;
if|if
condition|(
name|b
operator|==
name|YY_CURRENT_BUFFER
condition|)
comment|/* Not sure if we should pop here. */
name|YY_CURRENT_BUFFER_LVALUE
operator|=
operator|(
name|YY_BUFFER_STATE
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|yy_is_our_buffer
condition|)
name|ncsa_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
operator|->
name|yy_ch_buf
argument_list|)
expr_stmt|;
name|ncsa_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__cplusplus
end_ifndef

begin_function_decl
specifier|extern
name|int
name|isatty
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_comment
comment|/* Initializes or reinitializes a buffer.  * This function is sometimes called more than once on the same buffer,  * such as during a ncsa_restart() or at EOF.  */
end_comment

begin_function
DECL|function|ncsa__init_buffer (YY_BUFFER_STATE b,FILE * file)
specifier|static
name|void
name|ncsa__init_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
name|ncsa__flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_input_file
operator|=
name|file
expr_stmt|;
name|b
operator|->
name|yy_fill_buffer
operator|=
literal|1
expr_stmt|;
comment|/* If b is the current buffer, then ncsa__init_buffer was _probably_      * called from ncsa_restart() or through yy_get_next_buffer.      * In that case, we don't want to reset the lineno or column.      */
if|if
condition|(
name|b
operator|!=
name|YY_CURRENT_BUFFER
condition|)
block|{
name|b
operator|->
name|yy_bs_lineno
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|yy_bs_column
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|yy_is_interactive
operator|=
name|file
condition|?
operator|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
else|:
literal|0
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Discard all buffered characters. On the next scan, YY_INPUT will be called.  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.  *   */
end_comment

begin_function
DECL|function|ncsa__flush_buffer (YY_BUFFER_STATE b)
name|void
name|ncsa__flush_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return;
name|b
operator|->
name|yy_n_chars
operator|=
literal|0
expr_stmt|;
comment|/* We always need two end-of-buffer characters.  The first causes 	 * a transition to the end-of-buffer state.  The second causes 	 * a jam in that state. 	 */
name|b
operator|->
name|yy_ch_buf
index|[
literal|0
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|b
operator|->
name|yy_ch_buf
index|[
literal|1
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|b
operator|->
name|yy_buf_pos
operator|=
operator|&
name|b
operator|->
name|yy_ch_buf
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|->
name|yy_at_bol
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_NEW
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|YY_CURRENT_BUFFER
condition|)
name|ncsa__load_buffer_state
argument_list|( )
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Pushes the new state onto the stack. The new state becomes  *  the current state. This function will allocate the stack  *  if necessary.  *  @param new_buffer The new state.  *    */
end_comment

begin_function
DECL|function|ncsa_push_buffer_state (YY_BUFFER_STATE new_buffer)
name|void
name|ncsa_push_buffer_state
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|)
block|{
if|if
condition|(
name|new_buffer
operator|==
name|NULL
condition|)
return|return;
name|ncsa_ensure_buffer_stack
argument_list|()
expr_stmt|;
comment|/* This block is copied from ncsa__switch_to_buffer. */
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
comment|/* Flush out information for old buffer. */
operator|*
operator|(
name|yy_c_buf_p
operator|)
operator|=
operator|(
name|yy_hold_char
operator|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_pos
operator|=
operator|(
name|yy_c_buf_p
operator|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
operator|(
name|yy_n_chars
operator|)
expr_stmt|;
block|}
comment|/* Only push if top exists. Otherwise, replace top. */
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
operator|(
name|yy_buffer_stack_top
operator|)
operator|++
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|new_buffer
expr_stmt|;
comment|/* copied from ncsa__switch_to_buffer. */
name|ncsa__load_buffer_state
argument_list|( )
expr_stmt|;
operator|(
name|yy_did_buffer_switch_on_eof
operator|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Removes and deletes the top of the stack, if present.  *  The next element becomes the new top.  *    */
end_comment

begin_function
DECL|function|ncsa_pop_buffer_state (void)
name|void
name|ncsa_pop_buffer_state
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
return|return;
name|ncsa__delete_buffer
argument_list|(
name|YY_CURRENT_BUFFER
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|yy_buffer_stack_top
operator|)
operator|>
literal|0
condition|)
operator|--
operator|(
name|yy_buffer_stack_top
operator|)
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
name|ncsa__load_buffer_state
argument_list|( )
expr_stmt|;
operator|(
name|yy_did_buffer_switch_on_eof
operator|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocates the stack if it does not exist.  *  Guarantees space for at least one push.  */
end_comment

begin_function
DECL|function|ncsa_ensure_buffer_stack (void)
specifier|static
name|void
name|ncsa_ensure_buffer_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|num_to_alloc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|yy_buffer_stack
operator|)
condition|)
block|{
comment|/* First allocation is just for 2 elements, since we don't know if this 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an 		 * immediate realloc on the next call.          */
name|num_to_alloc
operator|=
literal|1
expr_stmt|;
operator|(
name|yy_buffer_stack
operator|)
operator|=
operator|(
expr|struct
name|yy_buffer_state
operator|*
operator|*
operator|)
name|ncsa_alloc
argument_list|(
name|num_to_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|yy_buffer_stack
operator|)
argument_list|,
literal|0
argument_list|,
name|num_to_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|yy_buffer_stack_max
operator|)
operator|=
name|num_to_alloc
expr_stmt|;
operator|(
name|yy_buffer_stack_top
operator|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|yy_buffer_stack_top
operator|)
operator|>=
operator|(
operator|(
name|yy_buffer_stack_max
operator|)
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Increase the buffer to prepare for a possible push. */
name|int
name|grow_size
init|=
literal|8
comment|/* arbitrary grow size */
decl_stmt|;
name|num_to_alloc
operator|=
operator|(
name|yy_buffer_stack_max
operator|)
operator|+
name|grow_size
expr_stmt|;
operator|(
name|yy_buffer_stack
operator|)
operator|=
operator|(
expr|struct
name|yy_buffer_state
operator|*
operator|*
operator|)
name|ncsa_realloc
argument_list|(
operator|(
name|yy_buffer_stack
operator|)
argument_list|,
name|num_to_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero only the new slots.*/
name|memset
argument_list|(
operator|(
name|yy_buffer_stack
operator|)
operator|+
operator|(
name|yy_buffer_stack_max
operator|)
argument_list|,
literal|0
argument_list|,
name|grow_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|yy_buffer_stack_max
operator|)
operator|=
name|num_to_alloc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Setup the input buffer state to scan directly from a user-specified character buffer.  * @param base the character buffer  * @param size the size in bytes of the character buffer  *   * @return the newly allocated buffer state object.   */
end_comment

begin_function
DECL|function|ncsa__scan_buffer (char * base,yy_size_t size)
name|YY_BUFFER_STATE
name|ncsa__scan_buffer
parameter_list|(
name|char
modifier|*
name|base
parameter_list|,
name|yy_size_t
name|size
parameter_list|)
block|{
name|YY_BUFFER_STATE
name|b
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
operator|||
name|base
index|[
name|size
operator|-
literal|2
index|]
operator|!=
name|YY_END_OF_BUFFER_CHAR
operator|||
name|base
index|[
name|size
operator|-
literal|1
index|]
operator|!=
name|YY_END_OF_BUFFER_CHAR
condition|)
comment|/* They forgot to leave room for the EOB's. */
return|return
literal|0
return|;
name|b
operator|=
operator|(
name|YY_BUFFER_STATE
operator|)
name|ncsa_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in ncsa__scan_buffer()"
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_buf_size
operator|=
name|size
operator|-
literal|2
expr_stmt|;
comment|/* "- 2" to take care of EOB's */
name|b
operator|->
name|yy_buf_pos
operator|=
name|b
operator|->
name|yy_ch_buf
operator|=
name|base
expr_stmt|;
name|b
operator|->
name|yy_is_our_buffer
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_input_file
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_n_chars
operator|=
name|b
operator|->
name|yy_buf_size
expr_stmt|;
name|b
operator|->
name|yy_is_interactive
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_at_bol
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|yy_fill_buffer
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_NEW
expr_stmt|;
name|ncsa__switch_to_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/** Setup the input buffer state to scan a string. The next call to ncsa_lex() will  * scan from a @e copy of @a str.  * @param str a NUL-terminated string to scan  *   * @return the newly allocated buffer state object.  * @note If you want to scan bytes that may contain NUL values, then use  *       ncsa__scan_bytes() instead.  */
end_comment

begin_function
DECL|function|ncsa__scan_string (yyconst char * yy_str)
name|YY_BUFFER_STATE
name|ncsa__scan_string
parameter_list|(
name|yyconst
name|char
modifier|*
name|yy_str
parameter_list|)
block|{
return|return
name|ncsa__scan_bytes
argument_list|(
name|yy_str
argument_list|,
name|strlen
argument_list|(
name|yy_str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Setup the input buffer state to scan the given bytes. The next call to ncsa_lex() will  * scan from a @e copy of @a bytes.  * @param bytes the byte buffer to scan  * @param len the number of bytes in the buffer pointed to by @a bytes.  *   * @return the newly allocated buffer state object.  */
end_comment

begin_function
DECL|function|ncsa__scan_bytes (yyconst char * bytes,int len)
name|YY_BUFFER_STATE
name|ncsa__scan_bytes
parameter_list|(
name|yyconst
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|YY_BUFFER_STATE
name|b
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|yy_size_t
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get memory for full buffer, including space for trailing EOB's. */
name|n
operator|=
name|len
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ncsa_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in ncsa__scan_bytes()"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|=
name|bytes
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
name|buf
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|b
operator|=
name|ncsa__scan_buffer
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"bad buffer in ncsa__scan_bytes()"
argument_list|)
expr_stmt|;
comment|/* It's okay to grow etc. this buffer, and we should throw it 	 * away when we're done. 	 */
name|b
operator|->
name|yy_is_our_buffer
operator|=
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|YY_EXIT_FAILURE
end_ifndef

begin_define
DECL|macro|YY_EXIT_FAILURE
define|#
directive|define
name|YY_EXIT_FAILURE
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
DECL|function|yy_fatal_error (yyconst char * msg)
specifier|static
name|void
name|yy_fatal_error
parameter_list|(
name|yyconst
name|char
modifier|*
name|msg
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|YY_EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redefine yyless() so it works in section 3 code. */
end_comment

begin_undef
undef|#
directive|undef
name|yyless
end_undef

begin_define
DECL|macro|yyless (n)
define|#
directive|define
name|yyless
parameter_list|(
name|n
parameter_list|)
define|\
value|do \ 		{ \
comment|/* Undo effects of setting up ncsa_text. */
value|\         int yyless_macro_arg = (n); \         YY_LESS_LINENO(yyless_macro_arg);\ 		ncsa_text[ncsa_leng] = (yy_hold_char); \ 		(yy_c_buf_p) = ncsa_text + yyless_macro_arg; \ 		(yy_hold_char) = *(yy_c_buf_p); \ 		*(yy_c_buf_p) = '\0'; \ 		ncsa_leng = yyless_macro_arg; \ 		} \ 	while ( 0 )
end_define

begin_comment
comment|/* Accessor  methods (get/set functions) to struct members. */
end_comment

begin_comment
comment|/** Get the current line number.  *   */
end_comment

begin_function
DECL|function|ncsa_get_lineno (void)
name|int
name|ncsa_get_lineno
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ncsa_lineno
return|;
block|}
end_function

begin_comment
comment|/** Get the input stream.  *   */
end_comment

begin_function
DECL|function|ncsa_get_in (void)
name|FILE
modifier|*
name|ncsa_get_in
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ncsa_in
return|;
block|}
end_function

begin_comment
comment|/** Get the output stream.  *   */
end_comment

begin_function
DECL|function|ncsa_get_out (void)
name|FILE
modifier|*
name|ncsa_get_out
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ncsa_out
return|;
block|}
end_function

begin_comment
comment|/** Get the length of the current token.  *   */
end_comment

begin_function
DECL|function|ncsa_get_leng (void)
name|int
name|ncsa_get_leng
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ncsa_leng
return|;
block|}
end_function

begin_comment
comment|/** Get the current token.  *   */
end_comment

begin_function
DECL|function|ncsa_get_text (void)
name|char
modifier|*
name|ncsa_get_text
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ncsa_text
return|;
block|}
end_function

begin_comment
comment|/** Set the current line number.  * @param line_number  *   */
end_comment

begin_function
DECL|function|ncsa_set_lineno (int line_number)
name|void
name|ncsa_set_lineno
parameter_list|(
name|int
name|line_number
parameter_list|)
block|{
name|ncsa_lineno
operator|=
name|line_number
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Set the input stream. This does not discard the current  * input buffer.  * @param in_str A readable stream.  *   * @see ncsa__switch_to_buffer  */
end_comment

begin_function
DECL|function|ncsa_set_in (FILE * in_str)
name|void
name|ncsa_set_in
parameter_list|(
name|FILE
modifier|*
name|in_str
parameter_list|)
block|{
name|ncsa_in
operator|=
name|in_str
expr_stmt|;
block|}
end_function

begin_function
DECL|function|ncsa_set_out (FILE * out_str)
name|void
name|ncsa_set_out
parameter_list|(
name|FILE
modifier|*
name|out_str
parameter_list|)
block|{
name|ncsa_out
operator|=
name|out_str
expr_stmt|;
block|}
end_function

begin_function
DECL|function|ncsa_get_debug (void)
name|int
name|ncsa_get_debug
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ncsa__flex_debug
return|;
block|}
end_function

begin_function
DECL|function|ncsa_set_debug (int bdebug)
name|void
name|ncsa_set_debug
parameter_list|(
name|int
name|bdebug
parameter_list|)
block|{
name|ncsa__flex_debug
operator|=
name|bdebug
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ncsa_lex_destroy is for both reentrant and non-reentrant scanners. */
end_comment

begin_function
DECL|function|ncsa_lex_destroy (void)
name|int
name|ncsa_lex_destroy
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Pop the buffer stack, destroying each element. */
while|while
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
name|ncsa__delete_buffer
argument_list|(
name|YY_CURRENT_BUFFER
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|NULL
expr_stmt|;
name|ncsa_pop_buffer_state
argument_list|()
expr_stmt|;
block|}
comment|/* Destroy the stack itself. */
name|ncsa_free
argument_list|(
operator|(
name|yy_buffer_stack
operator|)
argument_list|)
expr_stmt|;
operator|(
name|yy_buffer_stack
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Internal utility routines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|yytext_ptr
end_ifndef

begin_function
DECL|function|yy_flex_strncpy (char * s1,yyconst char * s2,int n)
specifier|static
name|void
name|yy_flex_strncpy
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|yyconst
name|char
modifier|*
name|s2
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|s1
index|[
name|i
index|]
operator|=
name|s2
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YY_NEED_STRLEN
end_ifdef

begin_function
DECL|function|yy_flex_strlen (yyconst char * s)
specifier|static
name|int
name|yy_flex_strlen
parameter_list|(
name|yyconst
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|s
index|[
name|n
index|]
condition|;
operator|++
name|n
control|)
empty_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
DECL|function|ncsa_alloc (yy_size_t size)
name|void
modifier|*
name|ncsa_alloc
parameter_list|(
name|yy_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|ncsa_realloc (void * ptr,yy_size_t size)
name|void
modifier|*
name|ncsa_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|yy_size_t
name|size
parameter_list|)
block|{
comment|/* The cast to (char *) in the following accommodates both 	 * implementations that use char* generic pointers, and those 	 * that use void* generic pointers.  It works with the latter 	 * because both ANSI C and C++ allow castless assignment from 	 * any pointer type to void*, and deal with argument conversions 	 * as though doing an assignment. 	 */
return|return
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|ncsa_free (void * ptr)
name|void
name|ncsa_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
comment|/* see ncsa_realloc() for (char *) cast */
block|}
end_function

begin_define
DECL|macro|YYTABLES_NAME
define|#
directive|define
name|YYTABLES_NAME
value|"yytables"
end_define

begin_undef
undef|#
directive|undef
name|YY_NEW_FILE
end_undef

begin_undef
undef|#
directive|undef
name|YY_FLUSH_BUFFER
end_undef

begin_undef
undef|#
directive|undef
name|yy_set_bol
end_undef

begin_undef
undef|#
directive|undef
name|yy_new_buffer
end_undef

begin_undef
undef|#
directive|undef
name|yy_set_interactive
end_undef

begin_undef
undef|#
directive|undef
name|yytext_ptr
end_undef

begin_undef
undef|#
directive|undef
name|YY_DO_BEFORE_ACTION
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|YY_DECL_IS_OURS
end_ifdef

begin_undef
undef|#
directive|undef
name|YY_DECL_IS_OURS
end_undef

begin_undef
undef|#
directive|undef
name|YY_DECL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_line
line|#
directive|line
number|114
file|"imap_ncsa.l"
end_line

end_unit

