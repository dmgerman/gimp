begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    * TWAIN Plug-in  * Copyright (C) 1999 Craig Setera  * Craig Setera, setera@infonet.isl.net  * 03/31/1999  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  *  * Based on (at least) the following plug-ins:  * Screenshot  * GIF  * Randomize  *  * Any suggestions, bug-reports or patches are welcome.  *   * This plug-in interfaces to the TWAIN support library in order  * to capture images from TWAIN devices directly into GIMP images.  * The plug-in is capable of acquiring the following type of  * images:  * - B/W (1 bit images translated to grayscale B/W)  * - Grayscale up to 16 bits per pixel  * - RGB up to 16 bits per sample (24, 30, 36, etc.)  * - Paletted images (both Gray and RGB)  *  * Prerequisites:  *  This plug-in will not compile on anything other than a Win32  *  platform.  Although the TWAIN documentation implies that there  *  is TWAIN support available on Macintosh, I neither have a   *  Macintosh nor the interest in porting this.  If anyone else  *  has an interest, consult www.twain.org for more information on  *  interfacing to TWAIN.  *  * Known problems:  * - Multiple image transfers will hang the plug-in.  The current  *   configuration compiles with a maximum of single image transfers.  */
end_comment

begin_comment
comment|/*   * Revision history  *  (02/07/99)  v0.1   First working version (internal)  *  (02/09/99)  v0.2   First release to anyone other than myself  *  (02/15/99)  v0.3   Added image dump and read support for debugging  *  (03/31/99)  v0.5   Added support for multi-byte samples and paletted   *                     images.  */
end_comment

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_comment
comment|/* Needed when compiling with gcc */
end_comment

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|"twain.h"
end_include

begin_include
include|#
directive|include
file|"tw_func.h"
end_include

begin_include
include|#
directive|include
file|"tw_util.h"
end_include

begin_comment
comment|/* The DLL to be loaded for TWAIN support */
end_comment

begin_define
DECL|macro|TWAIN_DLL_NAME
define|#
directive|define
name|TWAIN_DLL_NAME
value|"TWAIN_32.DLL"
end_define

begin_comment
comment|/*  * Twain error code to string mappings  */
end_comment

begin_decl_stmt
DECL|variable|twainErrorCount
specifier|static
name|int
name|twainErrorCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|twainErrors
specifier|static
name|char
modifier|*
name|twainErrors
index|[]
init|=
block|{
literal|"No error"
block|,
literal|"Failure due to unknown causes"
block|,
literal|"Not enough memory to perform operation"
block|,
literal|"No Data Source"
block|,
literal|"DS is connected to max possible apps"
block|,
literal|"DS or DSM reported error, application shouldn't"
block|,
literal|"Unknown capability"
block|,
literal|"Unrecognized MSG DG DAT combination"
block|,
literal|"Data parameter out of range"
block|,
literal|"DG DAT MSG out of expected sequence"
block|,
literal|"Unknown destination App/Src in DSM_Entry"
block|,
literal|"Capability not supported by source"
block|,
literal|"Operation not supported by capability"
block|,
literal|"Capability has dependency on other capability"
block|,
literal|"File System operation is denied (file is protected)"
block|,
literal|"Operation failed because file already exists."
block|,
literal|"File not found"
block|,
literal|"Operation failed because directory is not empty"
block|,
literal|"The feeder is jammed"
block|,
literal|"The feeder detected multiple pages"
block|,
literal|"Error writing the file (disk full?)"
block|,
literal|"The device went offline prior to or during this operation"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Storage for the DLL handle */
end_comment

begin_decl_stmt
DECL|variable|hDLL
specifier|static
name|HINSTANCE
name|hDLL
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Storage for the entry point into the DSM */
end_comment

begin_decl_stmt
DECL|variable|dsmEntryPoint
specifier|static
name|DSMENTRYPROC
name|dsmEntryPoint
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FloatToFix32  *  * Convert a floating point value into a FIX32.  */
end_comment

begin_function
DECL|function|FloatToFIX32 (float floater)
name|TW_FIX32
name|FloatToFIX32
parameter_list|(
name|float
name|floater
parameter_list|)
block|{
name|TW_FIX32
name|Fix32_value
decl_stmt|;
name|TW_INT32
name|value
init|=
call|(
name|TW_INT32
call|)
argument_list|(
name|floater
operator|*
literal|65536.0
operator|+
literal|0.5
argument_list|)
decl_stmt|;
name|Fix32_value
operator|.
name|Whole
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|Fix32_value
operator|.
name|Frac
operator|=
name|value
operator|&
literal|0x0000ffffL
expr_stmt|;
return|return
operator|(
name|Fix32_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fix32ToFloat  *  * Convert a FIX32 value into a floating point value.  */
end_comment

begin_function
DECL|function|FIX32ToFloat (TW_FIX32 fix32)
name|float
name|FIX32ToFloat
parameter_list|(
name|TW_FIX32
name|fix32
parameter_list|)
block|{
name|float
name|floater
decl_stmt|;
name|floater
operator|=
operator|(
name|float
operator|)
name|fix32
operator|.
name|Whole
operator|+
operator|(
name|float
operator|)
name|fix32
operator|.
name|Frac
operator|/
literal|65536.0
expr_stmt|;
return|return
name|floater
return|;
block|}
end_function

begin_comment
comment|/*  * callDSM  *  * Call the specified function on the data source manager.  */
end_comment

begin_function
name|TW_UINT16
DECL|function|callDSM (pTW_IDENTITY pOrigin,pTW_IDENTITY pDest,TW_UINT32 DG,TW_UINT16 DAT,TW_UINT16 MSG,TW_MEMREF pData)
name|callDSM
parameter_list|(
name|pTW_IDENTITY
name|pOrigin
parameter_list|,
name|pTW_IDENTITY
name|pDest
parameter_list|,
name|TW_UINT32
name|DG
parameter_list|,
name|TW_UINT16
name|DAT
parameter_list|,
name|TW_UINT16
name|MSG
parameter_list|,
name|TW_MEMREF
name|pData
parameter_list|)
block|{
comment|/* Call the function */
return|return
call|(
modifier|*
name|dsmEntryPoint
call|)
argument_list|(
name|pOrigin
argument_list|,
name|pDest
argument_list|,
name|DG
argument_list|,
name|DAT
argument_list|,
name|MSG
argument_list|,
name|pData
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * twainError  *   * Return the TWAIN error message associated  * with the specified error code.  */
end_comment

begin_function
name|char
modifier|*
DECL|function|twainError (int errorCode)
name|twainError
parameter_list|(
name|int
name|errorCode
parameter_list|)
block|{
comment|/* Check whether we've counted */
if|if
condition|(
name|twainErrorCount
operator|==
literal|0
condition|)
while|while
condition|(
name|twainErrors
index|[
name|twainErrorCount
operator|++
index|]
condition|)
block|{}
comment|/* Check out of bounds */
if|if
condition|(
name|errorCode
operator|>=
name|twainErrorCount
condition|)
return|return
literal|"Unknown TWAIN Error Code"
return|;
else|else
return|return
name|twainErrors
index|[
name|errorCode
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * currentTwainError  *  * Return the current TWAIN error message.  */
end_comment

begin_function
name|char
modifier|*
DECL|function|currentTwainError (pTW_SESSION twSession)
name|currentTwainError
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_STATUS
name|twStatus
decl_stmt|;
comment|/* Get the current status code from the DSM */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_STATUS
argument_list|,
name|MSG_GET
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|twStatus
argument_list|)
expr_stmt|;
comment|/* Return the mapped error code */
return|return
name|twainError
argument_list|(
name|twStatus
operator|.
name|ConditionCode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * twainIsAvailable  *  * Return boolean indicating whether TWAIN is available  */
end_comment

begin_function
name|int
DECL|function|twainIsAvailable (void)
name|twainIsAvailable
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Already loaded? */
if|if
condition|(
name|dsmEntryPoint
condition|)
block|{
return|return
name|TRUE
return|;
block|}
comment|/* Attempt to load the library */
name|hDLL
operator|=
name|LoadLibrary
argument_list|(
name|TWAIN_DLL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|hDLL
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Look up the entry point for use */
name|dsmEntryPoint
operator|=
operator|(
name|DSMENTRYPROC
operator|)
name|GetProcAddress
argument_list|(
name|hDLL
argument_list|,
literal|"DSM_Entry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsmEntryPoint
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * getImage  *   * This is a "high-level" function that can be called in order  * to take all of the steps necessary to kick off an image-transfer  * from a user-specified TWAIN datasource.  The data will be passed  * back to the callback function specified in the session structure.  */
end_comment

begin_function
name|int
DECL|function|getImage (pTW_SESSION twSession)
name|getImage
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
comment|/* Do some sanity checking first and bail    * if necessary.    */
if|if
condition|(
operator|!
name|twainIsAvailable
argument_list|()
condition|)
block|{
name|LogMessage
argument_list|(
literal|"TWAIN is not available for image capture\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* One step at a time */
if|if
condition|(
operator|!
name|openDSM
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Unable to open data source manager\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|selectDS
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Data source not selected\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|openDS
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Unable to open datasource\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|requestImageAcquire
argument_list|(
name|twSession
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * openDSM  *  * Open the data source manager  */
end_comment

begin_function
name|int
DECL|function|openDSM (pTW_SESSION twSession)
name|openDSM
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
comment|/* Make sure that we aren't already open */
if|if
condition|(
name|DSM_IS_OPEN
argument_list|(
name|twSession
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Open the data source manager */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_PARENT
argument_list|,
name|MSG_OPENDSM
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
operator|(
name|twSession
operator|->
name|hwnd
operator|)
argument_list|)
expr_stmt|;
comment|/* Check the return code */
switch|switch
condition|(
name|twSession
operator|->
name|twRC
condition|)
block|{
case|case
name|TWRC_SUCCESS
case|:
comment|/* We are now at state 3 */
name|twSession
operator|->
name|twainState
operator|=
literal|3
expr_stmt|;
return|return
name|TRUE
return|;
break|break;
case|case
name|TWRC_FAILURE
case|:
default|default:
name|LogMessage
argument_list|(
literal|"OpenDSM failure\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * selectDS  *  * Select a datasource using the TWAIN user  * interface.  */
end_comment

begin_function
name|int
DECL|function|selectDS (pTW_SESSION twSession)
name|selectDS
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
comment|/* The datasource manager must be open */
if|if
condition|(
name|DSM_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Can't select data source with closed source manager\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Ask TWAIN to present the source select dialog */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_IDENTITY
argument_list|,
name|MSG_USERSELECT
argument_list|,
operator|(
name|TW_MEMREF
operator|)
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the return to determine what the user decided    * to do.    */
switch|switch
condition|(
name|twSession
operator|->
name|twRC
condition|)
block|{
case|case
name|TWRC_SUCCESS
case|:
name|LogMessage
argument_list|(
literal|"Data source %s selected\n"
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
operator|->
name|ProductName
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
break|break;
case|case
name|TWRC_CANCEL
case|:
name|LogMessage
argument_list|(
literal|"User cancelled TWAIN source selection\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWRC_FAILURE
case|:
default|default:
name|LogMessage
argument_list|(
literal|"Error \"%s\" during TWAIN source selection\n"
argument_list|,
name|currentTwainError
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * selectDefaultDS  *  * Select the default datasource.  */
end_comment

begin_function
name|int
DECL|function|selectDefaultDS (pTW_SESSION twSession)
name|selectDefaultDS
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
comment|/* The datasource manager must be open */
if|if
condition|(
name|DSM_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Can't select data source with closed source manager\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Ask TWAIN to present the source select dialog */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_IDENTITY
argument_list|,
name|MSG_GETDEFAULT
argument_list|,
operator|(
name|TW_MEMREF
operator|)
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the return code */
return|return
operator|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * openDS  *  * Open a data source using the TWAIN user interface.  */
end_comment

begin_function
name|int
DECL|function|openDS (pTW_SESSION twSession)
name|openDS
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_IDENTITY
modifier|*
name|dsIdentity
decl_stmt|;
comment|/* The datasource manager must be open */
if|if
condition|(
name|DSM_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"openDS: Cannot open data source... manager closed\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Is the data source already open? */
if|if
condition|(
name|DS_IS_OPEN
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"openDS: Data source already open\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Open the TWAIN datasource */
name|dsIdentity
operator|=
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_IDENTITY
argument_list|,
name|MSG_OPENDS
argument_list|,
operator|(
name|TW_MEMREF
operator|)
name|dsIdentity
argument_list|)
expr_stmt|;
comment|/* Check the return to determine what the user decided    * to do. 	 */
switch|switch
condition|(
name|twSession
operator|->
name|twRC
condition|)
block|{
case|case
name|TWRC_SUCCESS
case|:
comment|/* We are now in TWAIN state 4 */
name|twSession
operator|->
name|twainState
operator|=
literal|4
expr_stmt|;
name|LogMessage
argument_list|(
literal|"Data source %s opened\n"
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
operator|->
name|ProductName
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tVersion.MajorNum = %d\n"
argument_list|,
name|dsIdentity
operator|->
name|Version
operator|.
name|MajorNum
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tVersion.MinorNum = %d\n"
argument_list|,
name|dsIdentity
operator|->
name|Version
operator|.
name|MinorNum
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tVersion.Info = %s\n"
argument_list|,
name|dsIdentity
operator|->
name|Version
operator|.
name|Info
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tProtocolMajor = %d\n"
argument_list|,
name|dsIdentity
operator|->
name|ProtocolMajor
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tProtocolMinor = %d\n"
argument_list|,
name|dsIdentity
operator|->
name|ProtocolMinor
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tManufacturer = %s\n"
argument_list|,
name|dsIdentity
operator|->
name|Manufacturer
argument_list|)
expr_stmt|;
name|LogMessage
argument_list|(
literal|"\tProductFamily = %s\n"
argument_list|,
name|dsIdentity
operator|->
name|ProductFamily
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
break|break;
default|default:
name|LogMessage
argument_list|(
literal|"Error \"%s\" opening data source\n"
argument_list|,
name|currentTwainError
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * setBufferedXfer  */
end_comment

begin_function
specifier|static
name|int
DECL|function|setBufferedXfer (pTW_SESSION twSession)
name|setBufferedXfer
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_CAPABILITY
name|bufXfer
decl_stmt|;
name|pTW_ONEVALUE
name|pvalOneValue
decl_stmt|;
comment|/* Make sure the data source is open first */
if|if
condition|(
name|DS_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create the capability information */
name|bufXfer
operator|.
name|Cap
operator|=
name|ICAP_XFERMECH
expr_stmt|;
name|bufXfer
operator|.
name|ConType
operator|=
name|TWON_ONEVALUE
expr_stmt|;
name|bufXfer
operator|.
name|hContainer
operator|=
name|GlobalAlloc
argument_list|(
name|GHND
argument_list|,
sizeof|sizeof
argument_list|(
name|TW_ONEVALUE
argument_list|)
argument_list|)
expr_stmt|;
name|pvalOneValue
operator|=
operator|(
name|pTW_ONEVALUE
operator|)
name|GlobalLock
argument_list|(
name|bufXfer
operator|.
name|hContainer
argument_list|)
expr_stmt|;
name|pvalOneValue
operator|->
name|ItemType
operator|=
name|TWTY_UINT16
expr_stmt|;
name|pvalOneValue
operator|->
name|Item
operator|=
name|TWSX_MEMORY
expr_stmt|;
name|GlobalUnlock
argument_list|(
name|bufXfer
operator|.
name|hContainer
argument_list|)
expr_stmt|;
comment|/* Make the call to the source manager */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_CAPABILITY
argument_list|,
name|MSG_SET
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|bufXfer
argument_list|)
expr_stmt|;
comment|/* Free the container */
name|GlobalFree
argument_list|(
name|bufXfer
operator|.
name|hContainer
argument_list|)
expr_stmt|;
comment|/* Let the caller know what happened */
return|return
operator|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * requestImageAcquire  *  * Request that the acquire user interface  * be displayed.  This may or may not cause  * an image to actually be transferred.  */
end_comment

begin_function
name|int
DECL|function|requestImageAcquire (pTW_SESSION twSession,BOOL showUI)
name|requestImageAcquire
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|,
name|BOOL
name|showUI
parameter_list|)
block|{
comment|/* Make sure in the correct state */
if|if
condition|(
name|DS_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Can't acquire image with closed datasource\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Set the transfer mode */
if|if
condition|(
name|setBufferedXfer
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|TW_USERINTERFACE
name|ui
decl_stmt|;
comment|/* Set the UI information */
name|ui
operator|.
name|ShowUI
operator|=
name|TRUE
expr_stmt|;
name|ui
operator|.
name|ModalUI
operator|=
name|TRUE
expr_stmt|;
name|ui
operator|.
name|hParent
operator|=
name|twSession
operator|->
name|hwnd
expr_stmt|;
comment|/* Make the call to the source manager */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_USERINTERFACE
argument_list|,
name|MSG_ENABLEDS
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
condition|)
block|{
comment|/* We are now at a new twain state */
name|twSession
operator|->
name|twainState
operator|=
literal|5
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|LogMessage
argument_list|(
literal|"Error during data source enable\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|LogMessage
argument_list|(
literal|"Unable to set buffered transfer mode: %s\n"
argument_list|,
name|currentTwainError
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * disableDS  *  * Disable the datasource associated with twSession.  */
end_comment

begin_function
name|int
DECL|function|disableDS (pTW_SESSION twSession)
name|disableDS
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_USERINTERFACE
name|ui
decl_stmt|;
comment|/* Verify the datasource is enabled */
if|if
condition|(
name|DS_IS_DISABLED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"disableDS: Data source not enabled\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Set the UI information */
name|ui
operator|.
name|ShowUI
operator|=
name|TRUE
expr_stmt|;
name|ui
operator|.
name|ModalUI
operator|=
name|TRUE
expr_stmt|;
name|ui
operator|.
name|hParent
operator|=
name|twSession
operator|->
name|hwnd
expr_stmt|;
comment|/* Make the call to the source manager */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_USERINTERFACE
argument_list|,
name|MSG_DISABLEDS
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
condition|)
block|{
comment|/* We are now at a new twain state */
name|twSession
operator|->
name|twainState
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|LogMessage
argument_list|(
literal|"Error during data source disable\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * closeDS  *  * Close the datasource associated with the   * specified session.  */
end_comment

begin_function
name|int
DECL|function|closeDS (pTW_SESSION twSession)
name|closeDS
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
comment|/* Can't close a closed data source */
if|if
condition|(
name|DS_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"closeDS: Data source already closed\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Open the TWAIN datasource */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_IDENTITY
argument_list|,
name|MSG_CLOSEDS
argument_list|,
operator|(
name|TW_MEMREF
operator|)
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the return to determine what the user decided    * to do. 	 */
switch|switch
condition|(
name|twSession
operator|->
name|twRC
condition|)
block|{
case|case
name|TWRC_SUCCESS
case|:
comment|/* We are now in TWAIN state 3 */
name|twSession
operator|->
name|twainState
operator|=
literal|3
expr_stmt|;
name|LogMessage
argument_list|(
literal|"Data source %s closed\n"
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
operator|->
name|ProductName
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
break|break;
default|default:
name|LogMessage
argument_list|(
literal|"Error \"%s\" closing data source\n"
argument_list|,
name|currentTwainError
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * closeDSM  *  * Close the data source manager  */
end_comment

begin_function
name|int
DECL|function|closeDSM (pTW_SESSION twSession)
name|closeDSM
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
if|if
condition|(
name|DSM_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"closeDSM: Source Manager not open\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|DS_IS_OPEN
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
name|LogMessage
argument_list|(
literal|"closeDSM: Can't close source manager with open source\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_PARENT
argument_list|,
name|MSG_CLOSEDSM
argument_list|,
operator|&
operator|(
name|twSession
operator|->
name|hwnd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|twSession
operator|->
name|twRC
operator|!=
name|TWRC_SUCCESS
condition|)
block|{
name|LogMessage
argument_list|(
literal|"CloseDSM failure -- %s\n"
argument_list|,
name|currentTwainError
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are now in state 2 */
name|twSession
operator|->
name|twainState
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
comment|/* Let the caller know what happened */
return|return
operator|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unloadTwainLibrary  *  * Unload the TWAIN dynamic link library  */
end_comment

begin_function
name|int
DECL|function|unloadTwainLibrary (pTW_SESSION twSession)
name|unloadTwainLibrary
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
comment|/* Explicitly free the SM library */
if|if
condition|(
name|hDLL
condition|)
block|{
name|FreeLibrary
argument_list|(
name|hDLL
argument_list|)
expr_stmt|;
name|hDLL
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* the data source id will no longer be valid after    * twain is killed.  If the id is left around the    * data source can not be found or opened 	 */
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
operator|->
name|Id
operator|=
literal|0
expr_stmt|;
comment|/* We are now back at state 1 */
name|twSession
operator|->
name|twainState
operator|=
literal|1
expr_stmt|;
name|LogMessage
argument_list|(
literal|"Source Manager successfully closed\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * beginImageTransfer  *  * Begin an image transfer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|beginImageTransfer (pTW_SESSION twSession,pTW_IMAGEINFO imageInfo)
name|beginImageTransfer
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|,
name|pTW_IMAGEINFO
name|imageInfo
parameter_list|)
block|{
comment|/* Clear our structures */
name|memset
argument_list|(
name|imageInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TW_IMAGEINFO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Query the image information */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_IMAGE
argument_list|,
name|DAT_IMAGEINFO
argument_list|,
name|MSG_GET
argument_list|,
operator|(
name|TW_MEMREF
operator|)
name|imageInfo
argument_list|)
expr_stmt|;
comment|/* Check the return code */
if|if
condition|(
name|twSession
operator|->
name|twRC
operator|!=
name|TWRC_SUCCESS
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Get Image Info failure - %s\n"
argument_list|,
name|currentTwainError
argument_list|(
name|twSession
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Call the begin transfer callback if registered */
if|if
condition|(
name|twSession
operator|->
name|transferFunctions
operator|->
name|txfrBeginCb
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|twSession
operator|->
name|transferFunctions
operator|->
name|txfrBeginCb
call|)
argument_list|(
name|imageInfo
argument_list|,
name|twSession
operator|->
name|clientData
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We should continue */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * transferImage  *  * The Source indicated it is ready to transfer data. It is   * waiting for the application to inquire about the image details,   * initiate the actual transfer, and, hence, transition the session   * from State 6 to 7.  Return the reason for exiting the transfer.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|transferImage (pTW_SESSION twSession,pTW_IMAGEINFO imageInfo)
name|transferImage
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|,
name|pTW_IMAGEINFO
name|imageInfo
parameter_list|)
block|{
name|TW_SETUPMEMXFER
name|setupMemXfer
decl_stmt|;
name|TW_IMAGEMEMXFER
name|imageMemXfer
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Clear our structures */
name|memset
argument_list|(
operator|&
name|setupMemXfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TW_SETUPMEMXFER
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|imageMemXfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TW_IMAGEMEMXFER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find out how the source would like to transfer... */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_SETUPMEMXFER
argument_list|,
name|MSG_GET
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|setupMemXfer
argument_list|)
expr_stmt|;
comment|/* Allocate the buffer for the transfer */
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|setupMemXfer
operator|.
name|Preferred
argument_list|)
expr_stmt|;
name|imageMemXfer
operator|.
name|Memory
operator|.
name|Flags
operator|=
name|TWMF_APPOWNS
operator||
name|TWMF_POINTER
expr_stmt|;
name|imageMemXfer
operator|.
name|Memory
operator|.
name|Length
operator|=
name|setupMemXfer
operator|.
name|Preferred
expr_stmt|;
name|imageMemXfer
operator|.
name|Memory
operator|.
name|TheMem
operator|=
operator|(
name|TW_MEMREF
operator|)
name|buffer
expr_stmt|;
comment|/* Get the data */
do|do
block|{
comment|/* Setup for the memory transfer */
name|imageMemXfer
operator|.
name|Compression
operator|=
name|TWON_DONTCARE16
expr_stmt|;
name|imageMemXfer
operator|.
name|BytesPerRow
operator|=
name|TWON_DONTCARE32
expr_stmt|;
name|imageMemXfer
operator|.
name|Columns
operator|=
name|TWON_DONTCARE32
expr_stmt|;
name|imageMemXfer
operator|.
name|Rows
operator|=
name|TWON_DONTCARE32
expr_stmt|;
name|imageMemXfer
operator|.
name|XOffset
operator|=
name|TWON_DONTCARE32
expr_stmt|;
name|imageMemXfer
operator|.
name|YOffset
operator|=
name|TWON_DONTCARE32
expr_stmt|;
name|imageMemXfer
operator|.
name|BytesWritten
operator|=
name|TWON_DONTCARE32
expr_stmt|;
comment|/* Get the next block of memory */
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_IMAGE
argument_list|,
name|DAT_IMAGEMEMXFER
argument_list|,
name|MSG_GET
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|imageMemXfer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
operator|)
operator|||
operator|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_XFERDONE
operator|)
condition|)
block|{
comment|/* Call the callback function */
if|if
condition|(
operator|!
call|(
modifier|*
name|twSession
operator|->
name|transferFunctions
operator|->
name|txfrDataCb
call|)
argument_list|(
name|imageInfo
argument_list|,
operator|&
name|imageMemXfer
argument_list|,
name|twSession
operator|->
name|clientData
argument_list|)
condition|)
block|{
comment|/* Callback function requested to cancel */
name|twSession
operator|->
name|twRC
operator|=
name|TWRC_CANCEL
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_SUCCESS
condition|)
do|;
comment|/* Free the memory buffer */
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|imageMemXfer
operator|.
name|Memory
operator|.
name|TheMem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * endPendingTransfer  *  * Cancel the currently pending transfer.  * Return the count of pending transfers.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|endPendingTransfer (pTW_SESSION twSession)
name|endPendingTransfer
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_PENDINGXFERS
name|pendingXfers
decl_stmt|;
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_PENDINGXFERS
argument_list|,
name|MSG_ENDXFER
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|pendingXfers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pendingXfers
operator|.
name|Count
condition|)
name|twSession
operator|->
name|twainState
operator|=
literal|5
expr_stmt|;
return|return
name|pendingXfers
operator|.
name|Count
return|;
block|}
end_function

begin_comment
comment|/*  * cancelPendingTransfers  *  * Cancel all pending image transfers.  */
end_comment

begin_function
name|void
DECL|function|cancelPendingTransfers (pTW_SESSION twSession)
name|cancelPendingTransfers
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_PENDINGXFERS
name|pendingXfers
decl_stmt|;
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_PENDINGXFERS
argument_list|,
name|MSG_RESET
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|pendingXfers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * endImageTransfer  *  * Finish transferring an image.  Return the count  * of pending images.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|endImageTransfer (pTW_SESSION twSession,int * pendingCount)
name|endImageTransfer
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|,
name|int
modifier|*
name|pendingCount
parameter_list|)
block|{
name|BOOL
name|continueTransfers
decl_stmt|;
name|int
name|exitCode
init|=
name|twSession
operator|->
name|twRC
decl_stmt|;
comment|/* Have now exited the transfer for some reason... Figure out    * why and what to do about it    */
switch|switch
condition|(
name|twSession
operator|->
name|twRC
condition|)
block|{
case|case
name|TWRC_XFERDONE
case|:
case|case
name|TWRC_CANCEL
case|:
name|LogMessage
argument_list|(
literal|"Xfer done received\n"
argument_list|)
expr_stmt|;
operator|*
name|pendingCount
operator|=
name|endPendingTransfer
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWRC_FAILURE
case|:
name|LogMessage
argument_list|(
literal|"Failure received\n"
argument_list|)
expr_stmt|;
operator|*
name|pendingCount
operator|=
name|endPendingTransfer
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Call the end transfer callback */
if|if
condition|(
name|twSession
operator|->
name|transferFunctions
operator|->
name|txfrEndCb
condition|)
name|continueTransfers
operator|=
call|(
modifier|*
name|twSession
operator|->
name|transferFunctions
operator|->
name|txfrEndCb
call|)
argument_list|(
name|exitCode
argument_list|,
operator|*
name|pendingCount
argument_list|,
name|twSession
operator|->
name|clientData
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|pendingCount
operator|&&
name|continueTransfers
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * transferImages  *  * Transfer all of the images that are available from the  * datasource.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|transferImages (pTW_SESSION twSession)
name|transferImages
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_IMAGEINFO
name|imageInfo
decl_stmt|;
name|int
name|pendingCount
decl_stmt|;
comment|/* Check the image transfer callback function    * before even attempting to do the transfer    */
if|if
condition|(
operator|!
name|twSession
operator|->
name|transferFunctions
operator|||
operator|!
name|twSession
operator|->
name|transferFunctions
operator|->
name|txfrDataCb
condition|)
block|{
name|LogMessage
argument_list|(
literal|"Attempting image transfer without callback function\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Inform our application that we are getting ready    * to transfer images.    */
if|if
condition|(
name|twSession
operator|->
name|transferFunctions
operator|->
name|preTxfrCb
condition|)
call|(
modifier|*
name|twSession
operator|->
name|transferFunctions
operator|->
name|preTxfrCb
call|)
argument_list|(
name|twSession
operator|->
name|clientData
argument_list|)
expr_stmt|;
comment|/* Loop through the available images */
do|do
block|{
comment|/* Move to the new state */
name|twSession
operator|->
name|twainState
operator|=
literal|6
expr_stmt|;
comment|/* Begin the image transfer */
if|if
condition|(
operator|!
name|beginImageTransfer
argument_list|(
name|twSession
argument_list|,
operator|&
name|imageInfo
argument_list|)
condition|)
continue|continue;
comment|/* Call the image transfer function */
name|transferImage
argument_list|(
name|twSession
argument_list|,
operator|&
name|imageInfo
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|endImageTransfer
argument_list|(
name|twSession
argument_list|,
operator|&
name|pendingCount
argument_list|)
condition|)
do|;
comment|/*    * Inform our application that we are done    * transferring images.    */
if|if
condition|(
name|twSession
operator|->
name|transferFunctions
operator|->
name|postTxfrCb
condition|)
call|(
modifier|*
name|twSession
operator|->
name|transferFunctions
operator|->
name|postTxfrCb
call|)
argument_list|(
name|pendingCount
argument_list|,
name|twSession
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TwainProcessMessage  *  * Returns TRUE if the application should process message as usual.  * Returns FALSE if the application should skip processing of this message  */
end_comment

begin_function
name|int
DECL|function|TwainProcessMessage (LPMSG lpMsg,pTW_SESSION twSession)
name|TwainProcessMessage
parameter_list|(
name|LPMSG
name|lpMsg
parameter_list|,
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|TW_EVENT
name|twEvent
decl_stmt|;
name|twSession
operator|->
name|twRC
operator|=
name|TWRC_NOTDSEVENT
expr_stmt|;
comment|/* Only ask Source Manager to process event if there is a Source connected. */
if|if
condition|(
name|DSM_IS_OPEN
argument_list|(
name|twSession
argument_list|)
operator|&&
name|DS_IS_OPEN
argument_list|(
name|twSession
argument_list|)
condition|)
block|{
comment|/* 		 * A Source provides a modeless dialog box as its user interface. 		 * The following call relays Windows messages down to the Source's 		 * UI that were intended for its dialog box.  It also retrieves TWAIN 		 * messages sent from the Source to our Application. 		 */
name|twEvent
operator|.
name|pEvent
operator|=
operator|(
name|TW_MEMREF
operator|)
name|lpMsg
expr_stmt|;
name|twSession
operator|->
name|twRC
operator|=
name|callDSM
argument_list|(
name|APP_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DS_IDENTITY
argument_list|(
name|twSession
argument_list|)
argument_list|,
name|DG_CONTROL
argument_list|,
name|DAT_EVENT
argument_list|,
name|MSG_PROCESSEVENT
argument_list|,
operator|(
name|TW_MEMREF
operator|)
operator|&
name|twEvent
argument_list|)
expr_stmt|;
comment|/* Check the return code */
if|if
condition|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_NOTDSEVENT
condition|)
block|{
return|return
name|FALSE
return|;
block|}
comment|/* Process the message as necessary */
switch|switch
condition|(
name|twEvent
operator|.
name|TWMessage
condition|)
block|{
case|case
name|MSG_XFERREADY
case|:
name|LogMessage
argument_list|(
literal|"Source says that data is ready\n"
argument_list|)
expr_stmt|;
name|transferImages
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_CLOSEDSREQ
case|:
comment|/* Disable the datasource, Close the Data source 			 * and close the data source manager 			 */
name|LogMessage
argument_list|(
literal|"CloseDSReq\n"
argument_list|)
expr_stmt|;
name|disableDS
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
name|closeDS
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
name|closeDSM
argument_list|(
name|twSession
argument_list|)
expr_stmt|;
break|break;
comment|/* No message from the Source to the App break; 			 * possible new message 			 */
case|case
name|MSG_NULL
case|:
default|default:
break|break;
block|}
block|}
comment|/* tell the caller what happened */
return|return
operator|(
name|twSession
operator|->
name|twRC
operator|==
name|TWRC_DSEVENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * twainMessageLoop  *  * Process Win32 window messages and provide special handling  * of TWAIN specific messages.  This loop will not exit until  * the application exits.  */
end_comment

begin_function
name|int
DECL|function|twainMessageLoop (pTW_SESSION twSession)
name|twainMessageLoop
parameter_list|(
name|pTW_SESSION
name|twSession
parameter_list|)
block|{
name|MSG
name|msg
decl_stmt|;
while|while
condition|(
name|GetMessage
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|DS_IS_CLOSED
argument_list|(
name|twSession
argument_list|)
operator|||
operator|!
name|TwainProcessMessage
argument_list|(
operator|&
name|msg
argument_list|,
name|twSession
argument_list|)
condition|)
block|{
name|TranslateMessage
argument_list|(
operator|(
name|LPMSG
operator|)
operator|&
name|msg
argument_list|)
expr_stmt|;
name|DispatchMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|msg
operator|.
name|wParam
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Session related functions  **********************************************************************/
end_comment

begin_comment
comment|/*  * newSession  *  * Create a new TWAIN session.  */
end_comment

begin_function
name|pTW_SESSION
DECL|function|newSession (pTW_IDENTITY appIdentity)
name|newSession
parameter_list|(
name|pTW_IDENTITY
name|appIdentity
parameter_list|)
block|{
comment|/* Create the structure */
name|pTW_SESSION
name|session
init|=
operator|(
name|pTW_SESSION
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TW_SESSION
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Set the structure fields */
name|session
operator|->
name|hwnd
operator|=
literal|0
expr_stmt|;
name|session
operator|->
name|twRC
operator|=
name|TWRC_SUCCESS
expr_stmt|;
name|session
operator|->
name|appIdentity
operator|=
name|appIdentity
expr_stmt|;
name|session
operator|->
name|dsIdentity
operator|=
operator|(
name|pTW_IDENTITY
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TW_IDENTITY
argument_list|)
argument_list|)
expr_stmt|;
name|session
operator|->
name|dsIdentity
operator|->
name|Id
operator|=
literal|0
expr_stmt|;
name|session
operator|->
name|dsIdentity
operator|->
name|ProductName
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|session
operator|->
name|transferFunctions
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|twainIsAvailable
argument_list|()
condition|)
name|session
operator|->
name|twainState
operator|=
literal|2
expr_stmt|;
else|else
name|session
operator|->
name|twainState
operator|=
literal|0
expr_stmt|;
return|return
name|session
return|;
block|}
end_function

begin_comment
comment|/*  * registerWindowHandle  *  * Register the window handle to be used for this  * session.  */
end_comment

begin_function
name|void
DECL|function|registerWindowHandle (pTW_SESSION session,HWND hwnd)
name|registerWindowHandle
parameter_list|(
name|pTW_SESSION
name|session
parameter_list|,
name|HWND
name|hwnd
parameter_list|)
block|{
name|session
operator|->
name|hwnd
operator|=
name|hwnd
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * registerTransferCallback  *  * Register the callback to use when transferring  * image data.  */
end_comment

begin_function
name|void
DECL|function|registerTransferCallbacks (pTW_SESSION session,pTXFR_CB_FUNCS txfrFuncs,void * clientData)
name|registerTransferCallbacks
parameter_list|(
name|pTW_SESSION
name|session
parameter_list|,
name|pTXFR_CB_FUNCS
name|txfrFuncs
parameter_list|,
name|void
modifier|*
name|clientData
parameter_list|)
block|{
name|session
operator|->
name|transferFunctions
operator|=
name|txfrFuncs
expr_stmt|;
name|session
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setClientData  *  * Set the client data associated with the specified  * TWAIN session.  */
end_comment

begin_function
name|void
DECL|function|setClientData (pTW_SESSION session,void * clientData)
name|setClientData
parameter_list|(
name|pTW_SESSION
name|session
parameter_list|,
name|void
modifier|*
name|clientData
parameter_list|)
block|{
name|session
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
block|}
end_function

end_unit

