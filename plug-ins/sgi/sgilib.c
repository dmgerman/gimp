begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   SGI image file format library routines.  *  *   Copyright 1997 Michael Sweet (mike@easysw.com)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Contents:  *  *   sgiClose()    - Close an SGI image file.  *   sgiGetRow()   - Get a row of image data from a file.  *   sgiOpen()     - Open an SGI image file for reading or writing.  *   sgiPutRow()   - Put a row of image data to a file.  *   getlong()     - Get a 32-bit big-endian integer.  *   getshort()    - Get a 16-bit big-endian integer.  *   putlong()     - Put a 32-bit big-endian integer.  *   putshort()    - Put a 16-bit big-endian integer.  *   read_rle8()   - Read 8-bit RLE data.  *   read_rle16()  - Read 16-bit RLE data.  *   write_rle8()  - Write 8-bit RLE data.  *   write_rle16() - Write 16-bit RLE data.  *  * Revision History:  *  *   $Log$  *   Revision 1.1  1997/11/24 22:04:37  sopwith  *   Initial revision  *  *   Revision 1.3  1997/11/18 03:04:29  nobody  *   fixed ugly comment-bugs introduced by evil darkwing  *   keep out configuration empty dirs  *   	--darkwing  *  *   Revision 1.2  1997/11/17 05:44:04  nobody  *   updated ChangeLog  *   dropped non-working doc/Makefile entries  *   applied many fixes from the registry as well as the devel ML  *   applied missing patches by Art Haas  *  *   	--darkwing  *  *   Revision 1.3  1997/07/02  16:40:16  mike  *   sgiOpen() wasn't opening files with "rb" or "wb+".  This caused problems  *   on PCs running Windows/DOS...  *  *   Revision 1.2  1997/06/18  00:55:28  mike  *   Updated to hold length table when writing.  *   Updated to hold current length when doing ARLE.  *   Wasn't writing length table on close.  *   Wasn't saving new line into arle_row when necessary.  *  *   Revision 1.1  1997/06/15  03:37:19  mike  *   Initial revision  */
end_comment

begin_include
include|#
directive|include
file|"sgi.h"
end_include

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|int
name|getlong
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getshort
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putlong
parameter_list|(
name|long
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putshort
parameter_list|(
name|short
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_rle8
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_rle16
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_rle8
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_rle16
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * 'sgiClose()' - Close an SGI image file.  */
end_comment

begin_function
name|int
DECL|function|sgiClose (sgi_t * sgip)
name|sgiClose
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|)
comment|/* I - SGI image */
block|{
name|int
name|i
decl_stmt|;
comment|/* Return status */
name|long
modifier|*
name|offset
decl_stmt|;
comment|/* Looping var for offset table */
if|if
condition|(
name|sgip
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sgip
operator|->
name|mode
operator|==
name|SGI_WRITE
operator|&&
name|sgip
operator|->
name|comp
operator|!=
name|SGI_COMP_NONE
condition|)
block|{
comment|/*     * Write the scanline offset table to the file...     */
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
literal|512
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
operator|,
name|offset
operator|=
name|sgip
operator|->
name|table
index|[
literal|0
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|offset
operator|++
control|)
if|if
condition|(
name|putlong
argument_list|(
name|offset
index|[
literal|0
index|]
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
operator|,
name|offset
operator|=
name|sgip
operator|->
name|length
index|[
literal|0
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|offset
operator|++
control|)
if|if
condition|(
name|putlong
argument_list|(
name|offset
index|[
literal|0
index|]
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
name|sgip
operator|->
name|table
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
operator|->
name|table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sgip
operator|->
name|length
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
operator|->
name|length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sgip
operator|->
name|comp
operator|==
name|SGI_COMP_ARLE
condition|)
name|free
argument_list|(
name|sgip
operator|->
name|arle_row
argument_list|)
expr_stmt|;
name|i
operator|=
name|fclose
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiGetRow()' - Get a row of image data from a file.  */
end_comment

begin_function
name|int
DECL|function|sgiGetRow (sgi_t * sgip,short * row,int y,int z)
name|sgiGetRow
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image */
name|short
modifier|*
name|row
parameter_list|,
comment|/* O - Row to read */
name|int
name|y
parameter_list|,
comment|/* I - Line to read */
name|int
name|z
parameter_list|)
comment|/* I - Channel to read */
block|{
name|int
name|x
decl_stmt|;
comment|/* X coordinate */
name|long
name|offset
decl_stmt|;
comment|/* File offset */
if|if
condition|(
name|sgip
operator|==
name|NULL
operator|||
name|row
operator|==
name|NULL
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|sgip
operator|->
name|ysize
operator|||
name|z
operator|<
literal|0
operator|||
name|z
operator|>=
name|sgip
operator|->
name|zsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|sgip
operator|->
name|comp
condition|)
block|{
case|case
name|SGI_COMP_NONE
case|:
comment|/*         * Seek to the image row - optimize buffering by only seeking if         * necessary...         */
name|offset
operator|=
literal|512
operator|+
operator|(
name|y
operator|+
name|z
operator|*
name|sgip
operator|->
name|ysize
operator|)
operator|*
name|sgip
operator|->
name|xsize
operator|*
name|sgip
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
operator|*
name|row
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
operator|*
name|row
operator|=
name|getshort
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_COMP_RLE
case|:
name|offset
operator|=
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
return|return
operator|(
name|read_rle8
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|read_rle16
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
return|;
break|break;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiOpen()' - Open an SGI image file for reading or writing.  */
end_comment

begin_function
name|sgi_t
modifier|*
DECL|function|sgiOpen (char * filename,int mode,int comp,int bpp,int xsize,int ysize,int zsize)
name|sgiOpen
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
comment|/* I - File to open */
name|int
name|mode
parameter_list|,
comment|/* I - Open mode (SGI_READ or SGI_WRITE) */
name|int
name|comp
parameter_list|,
comment|/* I - Type of compression */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes per pixel */
name|int
name|xsize
parameter_list|,
comment|/* I - Width of image in pixels */
name|int
name|ysize
parameter_list|,
comment|/* I - Height of image in pixels */
name|int
name|zsize
parameter_list|)
comment|/* I - Number of channels */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Looping var */
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
comment|/* Name of file in image header */
name|short
name|magic
decl_stmt|;
comment|/* Magic number */
name|sgi_t
modifier|*
name|sgip
decl_stmt|;
comment|/* New image pointer */
if|if
condition|(
operator|(
name|sgip
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sgi_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SGI_READ
case|:
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|sgip
operator|->
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
name|sgip
operator|->
name|mode
operator|=
name|SGI_READ
expr_stmt|;
name|magic
operator|=
name|getshort
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|SGI_MAGIC
condition|)
block|{
name|fclose
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
name|sgip
operator|->
name|comp
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|bpp
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|getshort
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Dimensions */
name|sgip
operator|->
name|xsize
operator|=
name|getshort
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|ysize
operator|=
name|getshort
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|zsize
operator|=
name|getshort
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|getlong
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Minimum pixel */
name|getlong
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Maximum pixel */
if|if
condition|(
name|sgip
operator|->
name|comp
condition|)
block|{
comment|/*           * This file is compressed; read the scanline tables...           */
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
literal|512
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
name|sgip
operator|->
name|table
index|[
name|i
index|]
operator|=
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|sgip
operator|->
name|ysize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sgip
operator|->
name|ysize
condition|;
name|j
operator|++
control|)
name|sgip
operator|->
name|table
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|getlong
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_WRITE
case|:
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|xsize
operator|<
literal|1
operator|||
name|ysize
operator|<
literal|1
operator|||
name|zsize
operator|<
literal|1
operator|||
name|bpp
operator|<
literal|1
operator|||
name|bpp
operator|>
literal|2
operator|||
name|comp
operator|<
name|SGI_COMP_NONE
operator|||
name|comp
operator|>
name|SGI_COMP_ARLE
condition|)
block|{
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|sgip
operator|->
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
name|sgip
operator|->
name|mode
operator|=
name|SGI_WRITE
expr_stmt|;
name|putshort
argument_list|(
name|SGI_MAGIC
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|sgip
operator|->
name|comp
operator|=
name|comp
operator|)
operator|!=
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|sgip
operator|->
name|bpp
operator|=
name|bpp
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putshort
argument_list|(
literal|3
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Dimensions */
name|putshort
argument_list|(
name|sgip
operator|->
name|xsize
operator|=
name|xsize
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putshort
argument_list|(
name|sgip
operator|->
name|ysize
operator|=
name|ysize
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putshort
argument_list|(
name|sgip
operator|->
name|zsize
operator|=
name|zsize
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Minimum pixel */
name|putlong
argument_list|(
literal|255
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Maximum pixel */
block|}
else|else
block|{
name|putlong
argument_list|(
operator|-
literal|32768
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Minimum pixel */
name|putlong
argument_list|(
literal|32767
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Maximum pixel */
block|}
empty_stmt|;
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Reserved */
name|memset
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
name|strncpy
argument_list|(
name|name
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|name
argument_list|,
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|102
condition|;
name|i
operator|++
control|)
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp
condition|)
block|{
case|case
name|SGI_COMP_NONE
case|:
comment|/* No compression */
comment|/*               * This file is uncompressed.  To avoid problems with sparse files,               * we need to write blank pixels for the entire image...               */
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|xsize
operator|*
name|ysize
operator|*
name|zsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|putc
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|xsize
operator|*
name|ysize
operator|*
name|zsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|putshort
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_COMP_ARLE
case|:
comment|/* Aggressive RLE */
name|sgip
operator|->
name|arle_row
operator|=
name|calloc
argument_list|(
name|xsize
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|arle_offset
operator|=
literal|0
expr_stmt|;
case|case
name|SGI_COMP_RLE
case|:
comment|/* Run-Length Encoding */
comment|/*               * This file is compressed; write the (blank) scanline tables...               */
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|ysize
operator|*
name|zsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|firstrow
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|nextrow
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
name|sgip
operator|->
name|table
index|[
name|i
index|]
operator|=
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|sgip
operator|->
name|ysize
expr_stmt|;
name|sgip
operator|->
name|length
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|length
index|[
literal|0
index|]
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
name|sgip
operator|->
name|length
index|[
name|i
index|]
operator|=
name|sgip
operator|->
name|length
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|sgip
operator|->
name|ysize
expr_stmt|;
break|break;
block|}
empty_stmt|;
break|break;
default|default :
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|sgip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiPutRow()' - Put a row of image data to a file.  */
end_comment

begin_function
name|int
DECL|function|sgiPutRow (sgi_t * sgip,short * row,int y,int z)
name|sgiPutRow
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image */
name|short
modifier|*
name|row
parameter_list|,
comment|/* I - Row to write */
name|int
name|y
parameter_list|,
comment|/* I - Line to write */
name|int
name|z
parameter_list|)
comment|/* I - Channel to write */
block|{
name|int
name|x
decl_stmt|;
comment|/* X coordinate */
name|long
name|offset
decl_stmt|;
comment|/* File offset */
if|if
condition|(
name|sgip
operator|==
name|NULL
operator|||
name|row
operator|==
name|NULL
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|sgip
operator|->
name|ysize
operator|||
name|z
operator|<
literal|0
operator|||
name|z
operator|>=
name|sgip
operator|->
name|zsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|sgip
operator|->
name|comp
condition|)
block|{
case|case
name|SGI_COMP_NONE
case|:
comment|/*         * Seek to the image row - optimize buffering by only seeking if         * necessary...         */
name|offset
operator|=
literal|512
operator|+
operator|(
name|y
operator|+
name|z
operator|*
name|sgip
operator|->
name|ysize
operator|)
operator|*
name|sgip
operator|->
name|xsize
operator|*
name|sgip
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
name|putc
argument_list|(
operator|*
name|row
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
name|putshort
argument_list|(
operator|*
name|row
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_COMP_ARLE
case|:
if|if
condition|(
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*         * First check the last row written...         */
if|if
condition|(
name|sgip
operator|->
name|arle_offset
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|row
index|[
name|x
index|]
operator|!=
name|sgip
operator|->
name|arle_row
index|[
name|x
index|]
condition|)
break|break;
if|if
condition|(
name|x
operator|==
name|sgip
operator|->
name|xsize
condition|)
block|{
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_offset
expr_stmt|;
name|sgip
operator|->
name|length
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*         * If that didn't match, search all the previous rows...         */
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|sgip
operator|->
name|firstrow
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
do|do
block|{
name|sgip
operator|->
name|arle_offset
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgip
operator|->
name|arle_length
operator|=
name|read_rle8
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|sgip
operator|->
name|arle_row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|row
index|[
name|x
index|]
operator|!=
name|sgip
operator|->
name|arle_row
index|[
name|x
index|]
condition|)
break|break;
block|}
do|while
condition|(
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|sgip
operator|->
name|arle_offset
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgip
operator|->
name|arle_length
operator|=
name|read_rle16
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|sgip
operator|->
name|arle_row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|row
index|[
name|x
index|]
operator|!=
name|sgip
operator|->
name|arle_row
index|[
name|x
index|]
condition|)
break|break;
block|}
do|while
condition|(
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|)
do|;
block|}
empty_stmt|;
if|if
condition|(
name|x
operator|==
name|sgip
operator|->
name|xsize
condition|)
block|{
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_offset
expr_stmt|;
name|sgip
operator|->
name|length
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/* Clear EOF */
case|case
name|SGI_COMP_RLE
case|:
if|if
condition|(
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|offset
operator|=
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|nextrow
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
name|x
operator|=
name|write_rle8
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|write_rle16
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|comp
operator|==
name|SGI_COMP_ARLE
condition|)
block|{
name|sgip
operator|->
name|arle_offset
operator|=
name|offset
expr_stmt|;
name|sgip
operator|->
name|arle_length
operator|=
name|x
expr_stmt|;
name|memcpy
argument_list|(
name|sgip
operator|->
name|arle_row
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|sgip
operator|->
name|nextrow
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|length
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'getlong()' - Get a 32-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|getlong (FILE * fp)
name|getlong
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
comment|/* I - File to read from */
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|fread
argument_list|(
name|b
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|3
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'getshort()' - Get a 16-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|getshort (FILE * fp)
name|getshort
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
comment|/* I - File to read from */
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|fread
argument_list|(
name|b
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'putlong()' - Put a 32-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|putlong (long n,FILE * fp)
name|putlong
parameter_list|(
name|long
name|n
parameter_list|,
comment|/* I - Long to write */
name|FILE
modifier|*
name|fp
parameter_list|)
comment|/* I - File to write to */
block|{
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|24
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|16
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'putshort()' - Put a 16-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|putshort (short n,FILE * fp)
name|putshort
parameter_list|(
name|short
name|n
parameter_list|,
comment|/* I - Short to write */
name|FILE
modifier|*
name|fp
parameter_list|)
comment|/* I - File to write to */
block|{
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'read_rle8()' - Read 8-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|read_rle8 (FILE * fp,short * row,int xsize)
name|read_rle8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
comment|/* I - File to read from */
name|short
modifier|*
name|row
parameter_list|,
comment|/* O - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|i
decl_stmt|,
comment|/* Looping var */
name|ch
decl_stmt|,
comment|/* Current character */
name|count
decl_stmt|,
comment|/* RLE count */
name|length
decl_stmt|;
comment|/* Number of bytes read... */
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
name|count
operator|=
name|ch
operator|&
literal|127
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ch
operator|&
literal|128
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
operator|,
name|length
operator|++
control|)
operator|*
name|row
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
control|)
operator|*
name|row
operator|=
name|ch
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|xsize
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
name|length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'read_rle16()' - Read 16-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|read_rle16 (FILE * fp,short * row,int xsize)
name|read_rle16
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
comment|/* I - File to read from */
name|short
modifier|*
name|row
parameter_list|,
comment|/* O - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|i
decl_stmt|,
comment|/* Looping var */
name|ch
decl_stmt|,
comment|/* Current character */
name|count
decl_stmt|,
comment|/* RLE count */
name|length
decl_stmt|;
comment|/* Number of bytes read... */
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getshort
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
name|count
operator|=
name|ch
operator|&
literal|127
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ch
operator|&
literal|128
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
operator|,
name|length
operator|++
control|)
operator|*
name|row
operator|=
name|getshort
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|getshort
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
control|)
operator|*
name|row
operator|=
name|ch
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|xsize
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
name|length
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'write_rle8()' - Write 8-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|write_rle8 (FILE * fp,short * row,int xsize)
name|write_rle8
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
comment|/* I - File to write to */
name|short
modifier|*
name|row
parameter_list|,
comment|/* I - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|length
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
name|short
modifier|*
name|start
decl_stmt|,
name|repeat
decl_stmt|;
for|for
control|(
name|x
operator|=
name|xsize
operator|,
name|length
operator|=
literal|0
init|;
name|x
operator|>
literal|0
condition|;
control|)
block|{
name|start
operator|=
name|row
expr_stmt|;
name|row
operator|+=
literal|2
expr_stmt|;
name|x
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|(
name|row
index|[
operator|-
literal|2
index|]
operator|!=
name|row
index|[
operator|-
literal|1
index|]
operator|||
name|row
index|[
operator|-
literal|1
index|]
operator|!=
name|row
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|row
operator|-=
literal|2
expr_stmt|;
name|x
operator|+=
literal|2
expr_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
literal|128
operator||
name|i
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
operator|*
name|start
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|start
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
break|break;
name|start
operator|=
name|row
expr_stmt|;
name|repeat
operator|=
name|row
index|[
literal|0
index|]
expr_stmt|;
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|*
name|row
operator|==
name|repeat
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|i
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|repeat
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'write_rle16()' - Write 16-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|write_rle16 (FILE * fp,short * row,int xsize)
name|write_rle16
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
comment|/* I - File to write to */
name|short
modifier|*
name|row
parameter_list|,
comment|/* I - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|length
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
name|short
modifier|*
name|start
decl_stmt|,
name|repeat
decl_stmt|;
for|for
control|(
name|x
operator|=
name|xsize
operator|,
name|length
operator|=
literal|0
init|;
name|x
operator|>
literal|0
condition|;
control|)
block|{
name|start
operator|=
name|row
expr_stmt|;
name|row
operator|+=
literal|2
expr_stmt|;
name|x
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|(
name|row
index|[
operator|-
literal|2
index|]
operator|!=
name|row
index|[
operator|-
literal|1
index|]
operator|||
name|row
index|[
operator|-
literal|1
index|]
operator|!=
name|row
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|row
operator|-=
literal|2
expr_stmt|;
name|x
operator|+=
literal|2
expr_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
literal|128
operator||
name|i
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|putshort
argument_list|(
operator|*
name|start
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|start
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
break|break;
name|start
operator|=
name|row
expr_stmt|;
name|repeat
operator|=
name|row
index|[
literal|0
index|]
expr_stmt|;
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|*
name|row
operator|==
name|repeat
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
name|i
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
name|repeat
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|2
operator|*
name|length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

