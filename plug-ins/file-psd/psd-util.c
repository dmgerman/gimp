begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * GIMP PSD Plug-in  * Copyright 2007 by John Marshall  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"psd.h"
end_include

begin_include
include|#
directive|include
file|"psd-util.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*  Local constants  */
end_comment

begin_define
DECL|macro|MIN_RUN
define|#
directive|define
name|MIN_RUN
value|3
end_define

begin_comment
comment|/*  Local types  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon290f65e70108
block|{
DECL|member|name
specifier|const
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|psd_mode
specifier|const
name|gchar
modifier|*
name|psd_mode
decl_stmt|;
DECL|member|gimp_mode
name|GimpLayerMode
name|gimp_mode
decl_stmt|;
DECL|member|exact
name|gboolean
name|exact
decl_stmt|;
comment|/* does the modes behave (more-or-less) the same in                          * Photoshop and in GIMP?                          */
DECL|typedef|LayerModeMapping
block|}
name|LayerModeMapping
typedef|;
end_typedef

begin_comment
comment|/*  Local function prototypes  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|gchar
modifier|*
name|get_enum_value_nick
parameter_list|(
name|GType
name|type
parameter_list|,
name|gint
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  Local varaibles  */
end_comment

begin_comment
comment|/* mapping table between Photoshop and GIMP modes.  in case a mode matches more  * than one entry (in either direction), the first entry wins.  */
end_comment

begin_decl_stmt
DECL|variable|layer_mode_map
specifier|static
specifier|const
name|LayerModeMapping
name|layer_mode_map
index|[]
init|=
block|{
comment|/*  Name             PSD     GIMP                                   Exact?  */
comment|/* Normal (ps3) */
block|{
literal|"Normal"
block|,
literal|"norm"
block|,
name|GIMP_LAYER_MODE_NORMAL
block|,
name|TRUE
block|}
block|,
block|{
literal|"Normal"
block|,
literal|"norm"
block|,
name|GIMP_LAYER_MODE_NORMAL_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Dissolve (ps3) */
block|{
literal|"Dissolve"
block|,
literal|"diss"
block|,
name|GIMP_LAYER_MODE_DISSOLVE
block|,
name|TRUE
block|}
block|,
comment|/* Multiply (ps3) */
block|{
literal|"Multiply"
block|,
literal|"mul "
block|,
name|GIMP_LAYER_MODE_MULTIPLY
block|,
name|TRUE
block|}
block|,
block|{
literal|"Multiply"
block|,
literal|"mul "
block|,
name|GIMP_LAYER_MODE_MULTIPLY_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Screen (ps3) */
block|{
literal|"Screen"
block|,
literal|"scrn"
block|,
name|GIMP_LAYER_MODE_SCREEN
block|,
name|TRUE
block|}
block|,
block|{
literal|"Screen"
block|,
literal|"scrn"
block|,
name|GIMP_LAYER_MODE_SCREEN_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Overlay (ps3) */
block|{
literal|"Overlay"
block|,
literal|"over"
block|,
name|GIMP_LAYER_MODE_OVERLAY
block|,
name|TRUE
block|}
block|,
comment|/* Difference (ps3) */
block|{
literal|"Difference"
block|,
literal|"diff"
block|,
name|GIMP_LAYER_MODE_DIFFERENCE
block|,
name|TRUE
block|}
block|,
block|{
literal|"Difference"
block|,
literal|"diff"
block|,
name|GIMP_LAYER_MODE_DIFFERENCE_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Linear Dodge (cs2) */
block|{
literal|"Linear Dodge"
block|,
literal|"lddg"
block|,
name|GIMP_LAYER_MODE_ADDITION
block|,
name|TRUE
block|}
block|,
block|{
literal|"Linear Dodge"
block|,
literal|"lddg"
block|,
name|GIMP_LAYER_MODE_ADDITION_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Subtract (??) */
block|{
literal|"Subtract"
block|,
literal|"fsub"
block|,
name|GIMP_LAYER_MODE_SUBTRACT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Subtract"
block|,
literal|"fsub"
block|,
name|GIMP_LAYER_MODE_SUBTRACT_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Darken (ps3) */
block|{
literal|"Darken"
block|,
literal|"dark"
block|,
name|GIMP_LAYER_MODE_DARKEN_ONLY
block|,
name|TRUE
block|}
block|,
block|{
literal|"Darken"
block|,
literal|"dark"
block|,
name|GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Lighten (ps3) */
block|{
literal|"Ligten"
block|,
literal|"lite"
block|,
name|GIMP_LAYER_MODE_LIGHTEN_ONLY
block|,
name|TRUE
block|}
block|,
block|{
literal|"Ligten"
block|,
literal|"lite"
block|,
name|GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Hue (ps3) */
block|{
literal|"Hue"
block|,
literal|"hue "
block|,
name|GIMP_LAYER_MODE_LCH_HUE
block|,
name|FALSE
block|}
block|,
block|{
literal|"Hue"
block|,
literal|"hue "
block|,
name|GIMP_LAYER_MODE_HSV_HUE
block|,
name|FALSE
block|}
block|,
block|{
literal|"Hue"
block|,
literal|"hue "
block|,
name|GIMP_LAYER_MODE_HSV_HUE_LEGACY
block|,
name|FALSE
block|}
block|,
comment|/* Stauration (ps3) */
block|{
literal|"Saturation"
block|,
literal|"sat "
block|,
name|GIMP_LAYER_MODE_LCH_CHROMA
block|,
name|FALSE
block|}
block|,
block|{
literal|"Saturation"
block|,
literal|"sat "
block|,
name|GIMP_LAYER_MODE_HSV_SATURATION
block|,
name|FALSE
block|}
block|,
block|{
literal|"Saturation"
block|,
literal|"sat "
block|,
name|GIMP_LAYER_MODE_HSV_SATURATION_LEGACY
block|,
name|FALSE
block|}
block|,
comment|/* Color (ps3) */
block|{
literal|"Color"
block|,
literal|"colr"
block|,
name|GIMP_LAYER_MODE_LCH_COLOR
block|,
name|FALSE
block|}
block|,
block|{
literal|"Color"
block|,
literal|"colr"
block|,
name|GIMP_LAYER_MODE_HSL_COLOR
block|,
name|FALSE
block|}
block|,
block|{
literal|"Color"
block|,
literal|"colr"
block|,
name|GIMP_LAYER_MODE_HSL_COLOR_LEGACY
block|,
name|FALSE
block|}
block|,
comment|/* Luminosity (ps3) */
block|{
literal|"Luminosity"
block|,
literal|"lum "
block|,
name|GIMP_LAYER_MODE_LCH_LIGHTNESS
block|,
name|FALSE
block|}
block|,
block|{
literal|"Luminosity"
block|,
literal|"lum "
block|,
name|GIMP_LAYER_MODE_HSV_VALUE
block|,
name|FALSE
block|}
block|,
block|{
literal|"Luminosity"
block|,
literal|"lum "
block|,
name|GIMP_LAYER_MODE_HSV_VALUE_LEGACY
block|,
name|FALSE
block|}
block|,
block|{
literal|"Luminosity"
block|,
literal|"lum "
block|,
name|GIMP_LAYER_MODE_LUMINANCE
block|,
name|FALSE
block|}
block|,
comment|/* Divide (??) */
block|{
literal|"Divide"
block|,
literal|"fdiv"
block|,
name|GIMP_LAYER_MODE_DIVIDE
block|,
name|TRUE
block|}
block|,
block|{
literal|"Divide"
block|,
literal|"fdiv"
block|,
name|GIMP_LAYER_MODE_DIVIDE_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Color Dodge (ps6) */
block|{
literal|"Color Dodge"
block|,
literal|"div "
block|,
name|GIMP_LAYER_MODE_DODGE
block|,
name|TRUE
block|}
block|,
block|{
literal|"Color Dodge"
block|,
literal|"div "
block|,
name|GIMP_LAYER_MODE_DODGE_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Color Burn (ps6) */
block|{
literal|"Color Burn"
block|,
literal|"idiv"
block|,
name|GIMP_LAYER_MODE_BURN
block|,
name|TRUE
block|}
block|,
block|{
literal|"Color Burn"
block|,
literal|"idiv"
block|,
name|GIMP_LAYER_MODE_BURN_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Hard Light (ps3) */
block|{
literal|"Hard Light"
block|,
literal|"hLit"
block|,
name|GIMP_LAYER_MODE_HARDLIGHT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Hard Light"
block|,
literal|"hLit"
block|,
name|GIMP_LAYER_MODE_HARDLIGHT_LEGACY
block|,
name|TRUE
block|}
block|,
comment|/* Soft Light (ps3) */
block|{
literal|"Soft Light"
block|,
literal|"sLit"
block|,
name|GIMP_LAYER_MODE_SOFTLIGHT
block|,
name|FALSE
block|}
block|,
block|{
literal|"Soft Light"
block|,
literal|"sLit"
block|,
name|GIMP_LAYER_MODE_SOFTLIGHT_LEGACY
block|,
name|FALSE
block|}
block|,
block|{
literal|"Soft Light"
block|,
literal|"sLit"
block|,
name|GIMP_LAYER_MODE_OVERLAY_LEGACY
block|,
name|FALSE
block|}
block|,
comment|/* Vivid Light (ps7)*/
block|{
literal|"Vivid Light"
block|,
literal|"vLit"
block|,
name|GIMP_LAYER_MODE_VIVID_LIGHT
block|,
name|TRUE
block|}
block|,
comment|/* Pin Light (ps7)*/
block|{
literal|"Pin Light"
block|,
literal|"pLit"
block|,
name|GIMP_LAYER_MODE_PIN_LIGHT
block|,
name|TRUE
block|}
block|,
comment|/* Linear Light (ps7)*/
block|{
literal|"Linear Light"
block|,
literal|"lLit"
block|,
name|GIMP_LAYER_MODE_LINEAR_LIGHT
block|,
name|TRUE
block|}
block|,
comment|/* Hard Mix (CS)*/
block|{
literal|"Hard Mix"
block|,
literal|"hMix"
block|,
name|GIMP_LAYER_MODE_HARD_MIX
block|,
name|TRUE
block|}
block|,
comment|/* Exclusion (ps6) */
block|{
literal|"Exclusion"
block|,
literal|"smud"
block|,
name|GIMP_LAYER_MODE_EXCLUSION
block|,
name|TRUE
block|}
block|,
comment|/* Linear Burn (ps7)*/
block|{
literal|"Linear Burn"
block|,
literal|"lbrn"
block|,
name|GIMP_LAYER_MODE_LINEAR_BURN
block|,
name|TRUE
block|}
block|,
comment|/* Darker Color (??)*/
block|{
literal|"Darker Color"
block|,
literal|"dkCl"
block|,
name|GIMP_LAYER_MODE_LUMA_DARKEN_ONLY
block|,
name|FALSE
block|}
block|,
comment|/* Lighter Color (??)*/
block|{
literal|"Lighter Color"
block|,
literal|"lgCl"
block|,
name|GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY
block|,
name|FALSE
block|}
block|,
comment|/* Pass Through (CS)*/
block|{
literal|"Pass Through"
block|,
literal|"pass"
block|,
name|GIMP_LAYER_MODE_PASS_THROUGH
block|,
name|TRUE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Utility function */
end_comment

begin_function
name|void
DECL|function|psd_set_error (gboolean file_eof,gint err_no,GError ** error)
name|psd_set_error
parameter_list|(
name|gboolean
name|file_eof
parameter_list|,
name|gint
name|err_no
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|file_eof
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|err_no
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|g_strerror
argument_list|(
name|err_no
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|fread_pascal_string (gint32 * bytes_read,gint32 * bytes_written,guint16 mod_len,FILE * f,GError ** error)
name|fread_pascal_string
parameter_list|(
name|gint32
modifier|*
name|bytes_read
parameter_list|,
name|gint32
modifier|*
name|bytes_written
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    * Reads a pascal string from the file padded to a multiple of mod_len    * and returns a utf-8 string.    */
name|gchar
modifier|*
name|str
decl_stmt|;
name|gchar
modifier|*
name|utf8_str
decl_stmt|;
name|guchar
name|len
decl_stmt|;
name|gint32
name|padded_len
decl_stmt|;
operator|*
name|bytes_read
operator|=
literal|0
expr_stmt|;
operator|*
name|bytes_written
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|bytes_read
operator|)
operator|++
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Pascal string length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|mod_len
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
operator|(
name|mod_len
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|str
operator|=
name|g_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
name|padded_len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|padded_len
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|bytes_read
operator|)
operator|++
expr_stmt|;
name|padded_len
operator|++
expr_stmt|;
block|}
block|}
name|utf8_str
operator|=
name|gimp_any_to_utf8
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
name|strlen
argument_list|(
name|utf8_str
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Pascal string: %s, bytes_read: %d, bytes_written: %d"
argument_list|,
name|utf8_str
argument_list|,
operator|*
name|bytes_read
argument_list|,
operator|*
name|bytes_written
argument_list|)
expr_stmt|;
return|return
name|utf8_str
return|;
block|}
end_function

begin_function
name|gint32
DECL|function|fwrite_pascal_string (const gchar * src,guint16 mod_len,FILE * f,GError ** error)
name|fwrite_pascal_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    *  Converts utf-8 string to current locale and writes as pascal    *  string with padding to a multiple of mod_len.    */
name|gchar
modifier|*
name|str
decl_stmt|;
name|gchar
modifier|*
name|pascal_str
decl_stmt|;
name|gchar
name|null_str
init|=
literal|0x0
decl_stmt|;
name|guchar
name|pascal_len
decl_stmt|;
name|gint32
name|bytes_written
init|=
literal|0
decl_stmt|;
name|gsize
name|len
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
comment|/* Write null string as two null bytes (0x0) */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|g_locale_from_utf8
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
name|pascal_len
operator|=
literal|255
expr_stmt|;
else|else
name|pascal_len
operator|=
name|len
expr_stmt|;
name|pascal_str
operator|=
name|g_strndup
argument_list|(
name|str
argument_list|,
name|pascal_len
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|pascal_len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fwrite
argument_list|(
name|pascal_str
argument_list|,
name|pascal_len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pascal_str
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|++
expr_stmt|;
name|bytes_written
operator|+=
name|pascal_len
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Pascal string: %s, bytes_written: %d"
argument_list|,
name|pascal_str
argument_list|,
name|bytes_written
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pascal_str
argument_list|)
expr_stmt|;
block|}
comment|/* Pad with nulls */
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|bytes_written
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|++
expr_stmt|;
block|}
block|}
return|return
name|bytes_written
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|fread_unicode_string (gint32 * bytes_read,gint32 * bytes_written,guint16 mod_len,FILE * f,GError ** error)
name|fread_unicode_string
parameter_list|(
name|gint32
modifier|*
name|bytes_read
parameter_list|,
name|gint32
modifier|*
name|bytes_written
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    * Reads a utf-16 string from the file padded to a multiple of mod_len    * and returns a utf-8 string.    */
name|gchar
modifier|*
name|utf8_str
decl_stmt|;
name|gunichar2
modifier|*
name|utf16_str
decl_stmt|;
name|gint32
name|len
decl_stmt|;
name|gint32
name|i
decl_stmt|;
name|gint32
name|padded_len
decl_stmt|;
name|glong
name|utf8_str_len
decl_stmt|;
operator|*
name|bytes_read
operator|=
literal|0
expr_stmt|;
operator|*
name|bytes_written
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
literal|4
expr_stmt|;
name|len
operator|=
name|GINT32_FROM_BE
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Unicode string length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|mod_len
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
operator|(
name|mod_len
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|utf16_str
operator|=
name|g_malloc
argument_list|(
name|len
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|utf16_str
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|utf16_str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
literal|2
expr_stmt|;
name|utf16_str
index|[
name|i
index|]
operator|=
name|GINT16_FROM_BE
argument_list|(
name|utf16_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
name|padded_len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|padded_len
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|utf16_str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|bytes_read
operator|)
operator|++
expr_stmt|;
name|padded_len
operator|++
expr_stmt|;
block|}
block|}
name|utf8_str
operator|=
name|g_utf16_to_utf8
argument_list|(
name|utf16_str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
operator|&
name|utf8_str_len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
name|utf8_str_len
expr_stmt|;
name|g_free
argument_list|(
name|utf16_str
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Unicode string: %s, bytes_read: %d, bytes_written: %d"
argument_list|,
name|utf8_str
argument_list|,
operator|*
name|bytes_read
argument_list|,
operator|*
name|bytes_written
argument_list|)
expr_stmt|;
return|return
name|utf8_str
return|;
block|}
end_function

begin_function
name|gint32
DECL|function|fwrite_unicode_string (const gchar * src,guint16 mod_len,FILE * f,GError ** error)
name|fwrite_unicode_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    *  Converts utf-8 string to utf-16 and writes 4 byte length    *  then string padding to multiple of mod_len.    */
name|gunichar2
modifier|*
name|utf16_str
decl_stmt|;
name|gchar
name|null_str
init|=
literal|0x0
decl_stmt|;
name|gint32
name|utf16_len
init|=
literal|0
decl_stmt|;
name|gint32
name|bytes_written
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|glong
name|len
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
comment|/* Write null string as four byte 0 int32 */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|utf16_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|utf16_str
operator|=
name|g_utf8_to_utf16
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Byte swap as required */
name|utf16_len
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|utf16_len
condition|;
operator|++
name|i
control|)
name|utf16_str
index|[
name|i
index|]
operator|=
name|GINT16_TO_BE
argument_list|(
name|utf16_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|utf16_len
operator|=
name|GINT32_TO_BE
argument_list|(
name|utf16_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|utf16_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fwrite
argument_list|(
name|utf16_str
argument_list|,
literal|2
argument_list|,
name|utf16_len
operator|+
literal|1
argument_list|,
name|f
argument_list|)
operator|<
name|utf16_len
operator|+
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|+=
operator|(
literal|4
operator|+
literal|2
operator|*
name|utf16_len
operator|+
literal|2
operator|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Unicode string: %s, bytes_written: %d"
argument_list|,
name|src
argument_list|,
name|bytes_written
argument_list|)
expr_stmt|;
block|}
comment|/* Pad with nulls */
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|bytes_written
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|++
expr_stmt|;
block|}
block|}
return|return
name|bytes_written
return|;
block|}
end_function

begin_function
name|gint
DECL|function|decode_packbits (const gchar * src,gchar * dst,guint16 packed_len,guint32 unpacked_len)
name|decode_packbits
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|guint16
name|packed_len
parameter_list|,
name|guint32
name|unpacked_len
parameter_list|)
block|{
comment|/*    *  Decode a PackBits chunk.    */
name|gint
name|n
decl_stmt|;
name|gchar
name|dat
decl_stmt|;
name|gint32
name|unpack_left
init|=
name|unpacked_len
decl_stmt|;
name|gint32
name|pack_left
init|=
name|packed_len
decl_stmt|;
name|gint32
name|error_code
init|=
literal|0
decl_stmt|;
name|gint32
name|return_val
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|unpack_left
operator|>
literal|0
operator|&&
name|pack_left
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|pack_left
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|128
condition|)
comment|/* nop */
continue|continue;
elseif|else
if|if
condition|(
name|n
operator|>
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* replicate next gchar |n|+ 1 times */
block|{
name|n
operator|=
literal|1
operator|-
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|pack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Input buffer exhausted in replicate"
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|>
name|unpack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Overrun in packbits replicate of %d chars"
argument_list|,
name|n
operator|-
name|unpack_left
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|2
expr_stmt|;
block|}
name|dat
operator|=
operator|*
name|src
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
operator|!
name|unpack_left
condition|)
break|break;
operator|*
name|dst
operator|=
name|dat
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|unpack_left
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|pack_left
operator|--
expr_stmt|;
block|}
block|}
else|else
comment|/* copy next n+1 gchars literally */
block|{
name|n
operator|++
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
operator|!
name|pack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Input buffer exhausted in copy"
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|unpack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Output buffer exhausted in copy"
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|4
expr_stmt|;
break|break;
block|}
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|pack_left
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|unpack_left
operator|>
literal|0
condition|)
block|{
comment|/* Pad with zeros to end of output buffer */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|pack_left
condition|;
operator|++
name|n
control|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unpack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Packbits decode - unpack left %d"
argument_list|,
name|unpack_left
argument_list|)
expr_stmt|;
name|return_val
operator|-=
name|unpack_left
expr_stmt|;
block|}
if|if
condition|(
name|pack_left
condition|)
block|{
comment|/* Some images seem to have a pad byte at the end of the packed data */
if|if
condition|(
name|error_code
operator|||
name|pack_left
operator|!=
literal|1
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Packbits decode - pack left %d"
argument_list|,
name|pack_left
argument_list|)
expr_stmt|;
name|return_val
operator|=
name|pack_left
expr_stmt|;
block|}
block|}
name|IFDBG
argument_list|(
literal|2
argument_list|)
if|if
condition|(
name|error_code
condition|)
name|g_debug
argument_list|(
literal|"Error code %d"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
return|return
name|return_val
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|encode_packbits (const gchar * src,guint32 unpacked_len,guint16 * packed_len)
name|encode_packbits
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|guint32
name|unpacked_len
parameter_list|,
name|guint16
modifier|*
name|packed_len
parameter_list|)
block|{
comment|/*    *  Encode a PackBits chunk.    */
name|GString
modifier|*
name|dst_str
decl_stmt|;
comment|/* destination string */
name|gint
name|curr_char
decl_stmt|;
comment|/* current character */
name|gchar
name|char_buff
index|[
literal|128
index|]
decl_stmt|;
comment|/* buffer of already read characters */
name|guchar
name|run_len
decl_stmt|;
comment|/* number of characters in a run */
name|gint32
name|unpack_left
init|=
name|unpacked_len
decl_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Encode packbits"
argument_list|)
expr_stmt|;
comment|/* Initialise destination string */
name|dst_str
operator|=
name|g_string_sized_new
argument_list|(
name|unpacked_len
argument_list|)
expr_stmt|;
comment|/* prime the read loop */
name|curr_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|run_len
operator|=
literal|0
expr_stmt|;
comment|/* read input until there's nothing left */
while|while
condition|(
name|unpack_left
operator|>
literal|0
condition|)
block|{
name|char_buff
index|[
name|run_len
index|]
operator|=
operator|(
name|gchar
operator|)
name|curr_char
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"buff %x, run len %d, curr char %x"
argument_list|,
name|char_buff
index|[
name|run_len
index|]
argument_list|,
name|run_len
argument_list|,
operator|(
name|gchar
operator|)
name|curr_char
argument_list|)
expr_stmt|;
name|run_len
operator|++
expr_stmt|;
if|if
condition|(
name|run_len
operator|>=
name|MIN_RUN
condition|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* check for run  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|MIN_RUN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|curr_char
operator|!=
name|char_buff
index|[
name|run_len
operator|-
name|i
index|]
condition|)
block|{
comment|/* no run */
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* we have a run write out buffer before run*/
name|gint
name|next_char
decl_stmt|;
if|if
condition|(
name|run_len
operator|>
name|MIN_RUN
condition|)
block|{
comment|/* block size - 1 followed by contents */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
operator|(
name|run_len
operator|-
name|MIN_RUN
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|g_string_append_len
argument_list|(
name|dst_str
argument_list|,
name|char_buff
argument_list|,
operator|(
name|run_len
operator|-
name|MIN_RUN
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(1) Number of chars: %d, run length tag: %d"
argument_list|,
name|run_len
operator|-
name|MIN_RUN
argument_list|,
name|run_len
operator|-
name|MIN_RUN
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* determine run length (MIN_RUN so far) */
name|run_len
operator|=
name|MIN_RUN
expr_stmt|;
comment|/* get next character */
name|next_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
while|while
condition|(
name|next_char
operator|==
name|curr_char
condition|)
block|{
name|run_len
operator|++
expr_stmt|;
if|if
condition|(
name|run_len
operator|==
literal|128
condition|)
block|{
comment|/* run is at max length */
break|break;
block|}
name|next_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
block|}
comment|/* write out encoded run length and run symbol */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
call|(
name|gchar
call|)
argument_list|(
literal|1
operator|-
call|(
name|gint
call|)
argument_list|(
name|run_len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
name|curr_char
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(2) Number of chars: %d, run length tag: %d"
argument_list|,
name|run_len
argument_list|,
operator|(
literal|1
operator|-
call|(
name|gint
call|)
argument_list|(
name|run_len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_left
operator|>
literal|0
condition|)
block|{
comment|/* make run breaker start of next buffer */
name|char_buff
index|[
literal|0
index|]
operator|=
name|next_char
expr_stmt|;
name|run_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* file ends in a run */
name|run_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|run_len
operator|==
literal|128
condition|)
block|{
comment|/* write out buffer */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
literal|127
argument_list|)
expr_stmt|;
name|g_string_append_len
argument_list|(
name|dst_str
argument_list|,
name|char_buff
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(3) Number of chars: 128, run length tag: 127"
argument_list|)
expr_stmt|;
comment|/* start a new buffer */
name|run_len
operator|=
literal|0
expr_stmt|;
block|}
name|curr_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
block|}
comment|/* write out last buffer */
if|if
condition|(
name|run_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|run_len
operator|<=
literal|128
condition|)
block|{
comment|/* write out entire copy buffer */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
name|run_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_string_append_len
argument_list|(
name|dst_str
argument_list|,
name|char_buff
argument_list|,
name|run_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(4) Number of chars: %d, run length tag: %d"
argument_list|,
name|run_len
argument_list|,
name|run_len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(5) Very bad - should not be here"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|packed_len
operator|=
name|dst_str
operator|->
name|len
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Packed len %d, unpacked %d"
argument_list|,
operator|*
name|packed_len
argument_list|,
name|unpacked_len
argument_list|)
expr_stmt|;
return|return
name|g_string_free
argument_list|(
name|dst_str
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|psd_to_gimp_blend_mode (const gchar * psd_mode,LayerModeInfo * mode_info)
name|psd_to_gimp_blend_mode
parameter_list|(
specifier|const
name|gchar
modifier|*
name|psd_mode
parameter_list|,
name|LayerModeInfo
modifier|*
name|mode_info
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|mode_info
operator|->
name|mode
operator|=
name|GIMP_LAYER_MODE_NORMAL
expr_stmt|;
comment|/* FIXME: use the image mode to select the correct color spaces.  for now,    * we use rgb-perceptual blending/compositing unconditionally.    */
name|mode_info
operator|->
name|blend_space
operator|=
name|GIMP_LAYER_COLOR_SPACE_RGB_PERCEPTUAL
expr_stmt|;
name|mode_info
operator|->
name|composite_space
operator|=
name|GIMP_LAYER_COLOR_SPACE_RGB_PERCEPTUAL
expr_stmt|;
name|mode_info
operator|->
name|composite_mode
operator|=
name|GIMP_LAYER_COMPOSITE_SRC_OVER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|layer_mode_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|psd_mode
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|exact
operator|&&
name|CONVERSION_WARNINGS
condition|)
block|{
name|g_message
argument_list|(
literal|"GIMP uses a different equation than Photoshop for "
literal|"blend mode: %s. Results will differ."
argument_list|,
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|mode_info
operator|->
name|mode
operator|=
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|gimp_mode
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
name|gchar
modifier|*
name|mode_name
init|=
name|g_strndup
argument_list|(
name|psd_mode
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|mode_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|gimp_to_psd_blend_mode (const LayerModeInfo * mode_info)
name|gimp_to_psd_blend_mode
parameter_list|(
specifier|const
name|LayerModeInfo
modifier|*
name|mode_info
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* FIXME: select the image mode based on the layer mode color spaces.  for    * now, we assume rgb-perceptual blending/compositing unconditionally.    */
if|if
condition|(
name|mode_info
operator|->
name|blend_space
operator|!=
name|GIMP_LAYER_COLOR_SPACE_AUTO
operator|&&
name|mode_info
operator|->
name|blend_space
operator|!=
name|GIMP_LAYER_COLOR_SPACE_RGB_PERCEPTUAL
condition|)
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend color space: %s. "
literal|"Blend color space reverts to rgb-perceptual"
argument_list|,
name|get_enum_value_nick
argument_list|(
name|GIMP_TYPE_LAYER_COLOR_SPACE
argument_list|,
name|mode_info
operator|->
name|blend_space
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode_info
operator|->
name|composite_space
operator|!=
name|GIMP_LAYER_COLOR_SPACE_AUTO
operator|&&
name|mode_info
operator|->
name|composite_space
operator|!=
name|GIMP_LAYER_COLOR_SPACE_RGB_PERCEPTUAL
condition|)
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported composite color space: %s. "
literal|"Composite color space reverts to rgb-perceptual"
argument_list|,
name|get_enum_value_nick
argument_list|(
name|GIMP_TYPE_LAYER_COLOR_SPACE
argument_list|,
name|mode_info
operator|->
name|composite_space
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode_info
operator|->
name|composite_mode
operator|!=
name|GIMP_LAYER_COMPOSITE_AUTO
operator|&&
name|mode_info
operator|->
name|composite_mode
operator|!=
name|GIMP_LAYER_COMPOSITE_SRC_OVER
condition|)
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported composite mode: %s. "
literal|"Composite mode reverts to src-over"
argument_list|,
name|get_enum_value_nick
argument_list|(
name|GIMP_TYPE_LAYER_COMPOSITE_MODE
argument_list|,
name|mode_info
operator|->
name|composite_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_N_ELEMENTS
argument_list|(
name|layer_mode_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|gimp_mode
operator|==
name|mode_info
operator|->
name|mode
condition|)
block|{
if|if
condition|(
operator|!
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|exact
operator|&&
name|CONVERSION_WARNINGS
condition|)
block|{
name|g_message
argument_list|(
literal|"GIMP uses a different equation than Photoshop for "
literal|"blend mode: %s. Results may differ."
argument_list|,
name|get_enum_value_nick
argument_list|(
name|GIMP_TYPE_LAYER_MODE
argument_list|,
name|mode_info
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|layer_mode_map
index|[
name|i
index|]
operator|.
name|psd_mode
return|;
block|}
block|}
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|get_enum_value_nick
argument_list|(
name|GIMP_TYPE_LAYER_MODE
argument_list|,
name|mode_info
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"norm"
return|;
block|}
end_function

begin_function
name|GimpColorTag
DECL|function|psd_to_gimp_layer_color_tag (guint16 layer_color_tag)
name|psd_to_gimp_layer_color_tag
parameter_list|(
name|guint16
name|layer_color_tag
parameter_list|)
block|{
name|GimpColorTag
name|colorTag
decl_stmt|;
switch|switch
condition|(
name|layer_color_tag
condition|)
block|{
case|case
literal|1
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_RED
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_ORANGE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_YELLOW
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_GREEN
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_BLUE
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_VIOLET
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_GRAY
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported Photoshop layer color tag: %i. GIMP layer color tag set to none."
argument_list|,
name|layer_color_tag
argument_list|)
expr_stmt|;
name|colorTag
operator|=
name|GIMP_COLOR_TAG_NONE
expr_stmt|;
block|}
return|return
name|colorTag
return|;
block|}
end_function

begin_function
name|guint16
DECL|function|gimp_to_psd_layer_color_tag (GimpColorTag layer_color_tag)
name|gimp_to_psd_layer_color_tag
parameter_list|(
name|GimpColorTag
name|layer_color_tag
parameter_list|)
block|{
name|guint16
name|color_tag
decl_stmt|;
switch|switch
condition|(
name|layer_color_tag
condition|)
block|{
case|case
name|GIMP_COLOR_TAG_RED
case|:
name|color_tag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_ORANGE
case|:
name|color_tag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_YELLOW
case|:
name|color_tag
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_GREEN
case|:
name|color_tag
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_BLUE
case|:
name|color_tag
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_VIOLET
case|:
name|color_tag
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_GRAY
case|:
name|color_tag
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Photoshop doesn't support GIMP layer color tag: %i. Photoshop layer color tag set to none."
argument_list|,
name|layer_color_tag
argument_list|)
expr_stmt|;
name|color_tag
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|color_tag
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|gchar
modifier|*
DECL|function|get_enum_value_nick (GType type,gint value)
name|get_enum_value_nick
parameter_list|(
name|GType
name|type
parameter_list|,
name|gint
name|value
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|nick
decl_stmt|;
if|if
condition|(
name|gimp_enum_get_value
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
operator|&
name|nick
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
name|nick
return|;
block|}
else|else
block|{
specifier|static
name|gchar
name|err_name
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|err_name
argument_list|,
sizeof|sizeof
argument_list|(
name|err_name
argument_list|)
argument_list|,
literal|"UNKNOWN (%d)"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|err_name
return|;
block|}
block|}
end_function

end_unit

