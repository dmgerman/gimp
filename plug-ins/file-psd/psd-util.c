begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * GIMP PSD Plug-in  * Copyright 2007 by John Marshall  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"psd.h"
end_include

begin_include
include|#
directive|include
file|"psd-util.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*  Local constants */
end_comment

begin_define
DECL|macro|MIN_RUN
define|#
directive|define
name|MIN_RUN
value|3
end_define

begin_comment
comment|/*  Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gchar
modifier|*
name|gimp_layer_mode_effects_name
parameter_list|(
name|GimpLayerMode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility function */
end_comment

begin_function
name|void
DECL|function|psd_set_error (gboolean file_eof,gint err_no,GError ** error)
name|psd_set_error
parameter_list|(
name|gboolean
name|file_eof
parameter_list|,
name|gint
name|err_no
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
name|file_eof
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|err_no
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|g_strerror
argument_list|(
name|err_no
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|fread_pascal_string (gint32 * bytes_read,gint32 * bytes_written,guint16 mod_len,FILE * f,GError ** error)
name|fread_pascal_string
parameter_list|(
name|gint32
modifier|*
name|bytes_read
parameter_list|,
name|gint32
modifier|*
name|bytes_written
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    * Reads a pascal string from the file padded to a multiple of mod_len    * and returns a utf-8 string.    */
name|gchar
modifier|*
name|str
decl_stmt|;
name|gchar
modifier|*
name|utf8_str
decl_stmt|;
name|guchar
name|len
decl_stmt|;
name|gint32
name|padded_len
decl_stmt|;
operator|*
name|bytes_read
operator|=
literal|0
expr_stmt|;
operator|*
name|bytes_written
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|bytes_read
operator|)
operator|++
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Pascal string length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|mod_len
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
operator|(
name|mod_len
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|str
operator|=
name|g_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
name|padded_len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|padded_len
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|bytes_read
operator|)
operator|++
expr_stmt|;
name|padded_len
operator|++
expr_stmt|;
block|}
block|}
name|utf8_str
operator|=
name|gimp_any_to_utf8
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
name|strlen
argument_list|(
name|utf8_str
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Pascal string: %s, bytes_read: %d, bytes_written: %d"
argument_list|,
name|utf8_str
argument_list|,
operator|*
name|bytes_read
argument_list|,
operator|*
name|bytes_written
argument_list|)
expr_stmt|;
return|return
name|utf8_str
return|;
block|}
end_function

begin_function
name|gint32
DECL|function|fwrite_pascal_string (const gchar * src,guint16 mod_len,FILE * f,GError ** error)
name|fwrite_pascal_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    *  Converts utf-8 string to current locale and writes as pascal    *  string with padding to a multiple of mod_len.    */
name|gchar
modifier|*
name|str
decl_stmt|;
name|gchar
modifier|*
name|pascal_str
decl_stmt|;
name|gchar
name|null_str
init|=
literal|0x0
decl_stmt|;
name|guchar
name|pascal_len
decl_stmt|;
name|gint32
name|bytes_written
init|=
literal|0
decl_stmt|;
name|gsize
name|len
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
comment|/* Write null string as two null bytes (0x0) */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|g_locale_from_utf8
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
name|pascal_len
operator|=
literal|255
expr_stmt|;
else|else
name|pascal_len
operator|=
name|len
expr_stmt|;
name|pascal_str
operator|=
name|g_strndup
argument_list|(
name|str
argument_list|,
name|pascal_len
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|pascal_len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fwrite
argument_list|(
name|pascal_str
argument_list|,
name|pascal_len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pascal_str
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|++
expr_stmt|;
name|bytes_written
operator|+=
name|pascal_len
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Pascal string: %s, bytes_written: %d"
argument_list|,
name|pascal_str
argument_list|,
name|bytes_written
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pascal_str
argument_list|)
expr_stmt|;
block|}
comment|/* Pad with nulls */
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|bytes_written
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|++
expr_stmt|;
block|}
block|}
return|return
name|bytes_written
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|fread_unicode_string (gint32 * bytes_read,gint32 * bytes_written,guint16 mod_len,FILE * f,GError ** error)
name|fread_unicode_string
parameter_list|(
name|gint32
modifier|*
name|bytes_read
parameter_list|,
name|gint32
modifier|*
name|bytes_written
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    * Reads a utf-16 string from the file padded to a multiple of mod_len    * and returns a utf-8 string.    */
name|gchar
modifier|*
name|utf8_str
decl_stmt|;
name|gunichar2
modifier|*
name|utf16_str
decl_stmt|;
name|gint32
name|len
decl_stmt|;
name|gint32
name|i
decl_stmt|;
name|gint32
name|padded_len
decl_stmt|;
name|glong
name|utf8_str_len
decl_stmt|;
operator|*
name|bytes_read
operator|=
literal|0
expr_stmt|;
operator|*
name|bytes_written
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
literal|4
expr_stmt|;
name|len
operator|=
name|GINT32_FROM_BE
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Unicode string length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|mod_len
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
operator|(
name|mod_len
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|utf16_str
operator|=
name|g_malloc
argument_list|(
name|len
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|utf16_str
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|utf16_str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read
operator|+=
literal|2
expr_stmt|;
name|utf16_str
index|[
name|i
index|]
operator|=
name|GINT16_FROM_BE
argument_list|(
name|utf16_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
name|padded_len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|padded_len
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|utf16_str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|bytes_read
operator|)
operator|++
expr_stmt|;
name|padded_len
operator|++
expr_stmt|;
block|}
block|}
name|utf8_str
operator|=
name|g_utf16_to_utf8
argument_list|(
name|utf16_str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
operator|&
name|utf8_str_len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bytes_written
operator|=
name|utf8_str_len
expr_stmt|;
name|g_free
argument_list|(
name|utf16_str
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Unicode string: %s, bytes_read: %d, bytes_written: %d"
argument_list|,
name|utf8_str
argument_list|,
operator|*
name|bytes_read
argument_list|,
operator|*
name|bytes_written
argument_list|)
expr_stmt|;
return|return
name|utf8_str
return|;
block|}
end_function

begin_function
name|gint32
DECL|function|fwrite_unicode_string (const gchar * src,guint16 mod_len,FILE * f,GError ** error)
name|fwrite_unicode_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|guint16
name|mod_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
comment|/*    *  Converts utf-8 string to utf-16 and writes 4 byte length    *  then string padding to multiple of mod_len.    */
name|gunichar2
modifier|*
name|utf16_str
decl_stmt|;
name|gchar
name|null_str
init|=
literal|0x0
decl_stmt|;
name|gint32
name|utf16_len
init|=
literal|0
decl_stmt|;
name|gint32
name|bytes_written
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|glong
name|len
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
comment|/* Write null string as four byte 0 int32 */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|utf16_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|utf16_str
operator|=
name|g_utf8_to_utf16
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Byte swap as required */
name|utf16_len
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|utf16_len
condition|;
operator|++
name|i
control|)
name|utf16_str
index|[
name|i
index|]
operator|=
name|GINT16_TO_BE
argument_list|(
name|utf16_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|utf16_len
operator|=
name|GINT32_TO_BE
argument_list|(
name|utf16_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|utf16_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fwrite
argument_list|(
name|utf16_str
argument_list|,
literal|2
argument_list|,
name|utf16_len
operator|+
literal|1
argument_list|,
name|f
argument_list|)
operator|<
name|utf16_len
operator|+
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|+=
operator|(
literal|4
operator|+
literal|2
operator|*
name|utf16_len
operator|+
literal|2
operator|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Unicode string: %s, bytes_written: %d"
argument_list|,
name|src
argument_list|,
name|bytes_written
argument_list|)
expr_stmt|;
block|}
comment|/* Pad with nulls */
if|if
condition|(
name|mod_len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|bytes_written
operator|%
name|mod_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|null_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bytes_written
operator|++
expr_stmt|;
block|}
block|}
return|return
name|bytes_written
return|;
block|}
end_function

begin_function
name|gint
DECL|function|decode_packbits (const gchar * src,gchar * dst,guint16 packed_len,guint32 unpacked_len)
name|decode_packbits
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|guint16
name|packed_len
parameter_list|,
name|guint32
name|unpacked_len
parameter_list|)
block|{
comment|/*    *  Decode a PackBits chunk.    */
name|gint
name|n
decl_stmt|;
name|gchar
name|dat
decl_stmt|;
name|gint32
name|unpack_left
init|=
name|unpacked_len
decl_stmt|;
name|gint32
name|pack_left
init|=
name|packed_len
decl_stmt|;
name|gint32
name|error_code
init|=
literal|0
decl_stmt|;
name|gint32
name|return_val
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|unpack_left
operator|>
literal|0
operator|&&
name|pack_left
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|pack_left
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|128
condition|)
comment|/* nop */
continue|continue;
elseif|else
if|if
condition|(
name|n
operator|>
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* replicate next gchar |n|+ 1 times */
block|{
name|n
operator|=
literal|1
operator|-
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|pack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Input buffer exhausted in replicate"
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|>
name|unpack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Overrun in packbits replicate of %d chars"
argument_list|,
name|n
operator|-
name|unpack_left
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|2
expr_stmt|;
block|}
name|dat
operator|=
operator|*
name|src
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
operator|!
name|unpack_left
condition|)
break|break;
operator|*
name|dst
operator|=
name|dat
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|unpack_left
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|pack_left
operator|--
expr_stmt|;
block|}
block|}
else|else
comment|/* copy next n+1 gchars literally */
block|{
name|n
operator|++
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
operator|!
name|pack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Input buffer exhausted in copy"
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|unpack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Output buffer exhausted in copy"
argument_list|)
expr_stmt|;
name|error_code
operator|=
literal|4
expr_stmt|;
break|break;
block|}
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|pack_left
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|unpack_left
operator|>
literal|0
condition|)
block|{
comment|/* Pad with zeros to end of output buffer */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|pack_left
condition|;
operator|++
name|n
control|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unpack_left
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Packbits decode - unpack left %d"
argument_list|,
name|unpack_left
argument_list|)
expr_stmt|;
name|return_val
operator|-=
name|unpack_left
expr_stmt|;
block|}
if|if
condition|(
name|pack_left
condition|)
block|{
comment|/* Some images seem to have a pad byte at the end of the packed data */
if|if
condition|(
name|error_code
operator|||
name|pack_left
operator|!=
literal|1
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Packbits decode - pack left %d"
argument_list|,
name|pack_left
argument_list|)
expr_stmt|;
name|return_val
operator|=
name|pack_left
expr_stmt|;
block|}
block|}
name|IFDBG
argument_list|(
literal|2
argument_list|)
if|if
condition|(
name|error_code
condition|)
name|g_debug
argument_list|(
literal|"Error code %d"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
return|return
name|return_val
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|encode_packbits (const gchar * src,guint32 unpacked_len,guint16 * packed_len)
name|encode_packbits
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|guint32
name|unpacked_len
parameter_list|,
name|guint16
modifier|*
name|packed_len
parameter_list|)
block|{
comment|/*    *  Encode a PackBits chunk.    */
name|GString
modifier|*
name|dst_str
decl_stmt|;
comment|/* destination string */
name|gint
name|curr_char
decl_stmt|;
comment|/* current character */
name|gchar
name|char_buff
index|[
literal|128
index|]
decl_stmt|;
comment|/* buffer of already read characters */
name|guchar
name|run_len
decl_stmt|;
comment|/* number of characters in a run */
name|gint32
name|unpack_left
init|=
name|unpacked_len
decl_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Encode packbits"
argument_list|)
expr_stmt|;
comment|/* Initialise destination string */
name|dst_str
operator|=
name|g_string_sized_new
argument_list|(
name|unpacked_len
argument_list|)
expr_stmt|;
comment|/* prime the read loop */
name|curr_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|run_len
operator|=
literal|0
expr_stmt|;
comment|/* read input until there's nothing left */
while|while
condition|(
name|unpack_left
operator|>
literal|0
condition|)
block|{
name|char_buff
index|[
name|run_len
index|]
operator|=
operator|(
name|gchar
operator|)
name|curr_char
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"buff %x, run len %d, curr char %x"
argument_list|,
name|char_buff
index|[
name|run_len
index|]
argument_list|,
name|run_len
argument_list|,
operator|(
name|gchar
operator|)
name|curr_char
argument_list|)
expr_stmt|;
name|run_len
operator|++
expr_stmt|;
if|if
condition|(
name|run_len
operator|>=
name|MIN_RUN
condition|)
block|{
name|gint
name|i
decl_stmt|;
comment|/* check for run  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|MIN_RUN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|curr_char
operator|!=
name|char_buff
index|[
name|run_len
operator|-
name|i
index|]
condition|)
block|{
comment|/* no run */
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* we have a run write out buffer before run*/
name|gint
name|next_char
decl_stmt|;
if|if
condition|(
name|run_len
operator|>
name|MIN_RUN
condition|)
block|{
comment|/* block size - 1 followed by contents */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
operator|(
name|run_len
operator|-
name|MIN_RUN
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|g_string_append_len
argument_list|(
name|dst_str
argument_list|,
name|char_buff
argument_list|,
operator|(
name|run_len
operator|-
name|MIN_RUN
operator|)
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(1) Number of chars: %d, run length tag: %d"
argument_list|,
name|run_len
operator|-
name|MIN_RUN
argument_list|,
name|run_len
operator|-
name|MIN_RUN
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* determine run length (MIN_RUN so far) */
name|run_len
operator|=
name|MIN_RUN
expr_stmt|;
comment|/* get next character */
name|next_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
while|while
condition|(
name|next_char
operator|==
name|curr_char
condition|)
block|{
name|run_len
operator|++
expr_stmt|;
if|if
condition|(
name|run_len
operator|==
literal|128
condition|)
block|{
comment|/* run is at max length */
break|break;
block|}
name|next_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
block|}
comment|/* write out encoded run length and run symbol */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
call|(
name|gchar
call|)
argument_list|(
literal|1
operator|-
call|(
name|gint
call|)
argument_list|(
name|run_len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
name|curr_char
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(2) Number of chars: %d, run length tag: %d"
argument_list|,
name|run_len
argument_list|,
operator|(
literal|1
operator|-
call|(
name|gint
call|)
argument_list|(
name|run_len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_left
operator|>
literal|0
condition|)
block|{
comment|/* make run breaker start of next buffer */
name|char_buff
index|[
literal|0
index|]
operator|=
name|next_char
expr_stmt|;
name|run_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* file ends in a run */
name|run_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|run_len
operator|==
literal|128
condition|)
block|{
comment|/* write out buffer */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
literal|127
argument_list|)
expr_stmt|;
name|g_string_append_len
argument_list|(
name|dst_str
argument_list|,
name|char_buff
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(3) Number of chars: 128, run length tag: 127"
argument_list|)
expr_stmt|;
comment|/* start a new buffer */
name|run_len
operator|=
literal|0
expr_stmt|;
block|}
name|curr_char
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|unpack_left
operator|--
expr_stmt|;
block|}
comment|/* write out last buffer */
if|if
condition|(
name|run_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|run_len
operator|<=
literal|128
condition|)
block|{
comment|/* write out entire copy buffer */
name|g_string_append_c
argument_list|(
name|dst_str
argument_list|,
name|run_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_string_append_len
argument_list|(
name|dst_str
argument_list|,
name|char_buff
argument_list|,
name|run_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(4) Number of chars: %d, run length tag: %d"
argument_list|,
name|run_len
argument_list|,
name|run_len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"(5) Very bad - should not be here"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|packed_len
operator|=
name|dst_str
operator|->
name|len
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Packed len %d, unpacked %d"
argument_list|,
operator|*
name|packed_len
argument_list|,
name|unpacked_len
argument_list|)
expr_stmt|;
return|return
name|g_string_free
argument_list|(
name|dst_str
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
name|GimpLayerMode
DECL|function|psd_to_gimp_blend_mode (const gchar * psd_mode,GimpLayerCompositeMode * layer_composite)
name|psd_to_gimp_blend_mode
parameter_list|(
specifier|const
name|gchar
modifier|*
name|psd_mode
parameter_list|,
name|GimpLayerCompositeMode
modifier|*
name|layer_composite
parameter_list|)
block|{
comment|/* FIXME: Do all photoshop modes use the union rule?  We always return    * "union", effectively, only returning "auto" for modes that default to    * "union", to reduce UI clutter.    */
if|if
condition|(
name|layer_composite
condition|)
operator|*
name|layer_composite
operator|=
name|GIMP_LAYER_COMPOSITE_SRC_ATOP
expr_stmt|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"pass"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Pass through (CS)*/
return|return
name|GIMP_LAYER_MODE_PASS_THROUGH
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"norm"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Normal (ps3) */
block|{
if|if
condition|(
name|layer_composite
condition|)
operator|*
name|layer_composite
operator|=
name|GIMP_LAYER_COMPOSITE_AUTO
expr_stmt|;
return|return
name|GIMP_LAYER_MODE_NORMAL_LEGACY
return|;
block|}
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"dark"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Darken (ps3) */
return|return
name|GIMP_LAYER_MODE_DARKEN_ONLY
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lite"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Lighten (ps3) */
return|return
name|GIMP_LAYER_MODE_LIGHTEN_ONLY
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"hue "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Hue (ps3) */
return|return
name|GIMP_LAYER_MODE_LCH_HUE
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"sat "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Saturation (ps3) */
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
specifier|static
name|gchar
modifier|*
name|mode_name
init|=
literal|"SATURATION"
decl_stmt|;
name|g_message
argument_list|(
literal|"Gimp uses a different equation to photoshop for "
literal|"blend mode: %s. Results will differ."
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
block|}
return|return
name|GIMP_LAYER_MODE_LCH_CHROMA
return|;
block|}
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"colr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Color (ps3) */
return|return
name|GIMP_LAYER_MODE_LCH_COLOR
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lum "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Luminosity (ps3) */
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
specifier|static
name|gchar
modifier|*
name|mode_name
init|=
literal|"LUMINOSITY (VALUE)"
decl_stmt|;
name|g_message
argument_list|(
literal|"Gimp uses a different equation to photoshop for "
literal|"blend mode: %s. Results will differ."
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
block|}
return|return
name|GIMP_LAYER_MODE_LCH_LIGHTNESS
return|;
block|}
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"mul "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Multiply (ps3) */
return|return
name|GIMP_LAYER_MODE_MULTIPLY
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lddg"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Linear Dodge (cs2) */
return|return
name|GIMP_LAYER_MODE_ADDITION
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"scrn"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Screen (ps3) */
return|return
name|GIMP_LAYER_MODE_SCREEN
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"diss"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Dissolve (ps3) */
block|{
if|if
condition|(
name|layer_composite
condition|)
operator|*
name|layer_composite
operator|=
name|GIMP_LAYER_COMPOSITE_AUTO
expr_stmt|;
return|return
name|GIMP_LAYER_MODE_DISSOLVE
return|;
block|}
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"over"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Overlay (ps3) */
return|return
name|GIMP_LAYER_MODE_OVERLAY
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"hLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Hard light (ps3) */
return|return
name|GIMP_LAYER_MODE_HARDLIGHT
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"sLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Soft light (ps3) */
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
specifier|static
name|gchar
modifier|*
name|mode_name
init|=
literal|"SOFT LIGHT"
decl_stmt|;
name|g_message
argument_list|(
literal|"GIMP uses a different equation to Photoshop for "
literal|"blend mode: %s. Results will differ."
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
block|}
return|return
name|GIMP_LAYER_MODE_SOFTLIGHT
return|;
block|}
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"diff"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Difference (ps3) */
return|return
name|GIMP_LAYER_MODE_DIFFERENCE
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"smud"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Exclusion (ps6) */
return|return
name|GIMP_LAYER_MODE_EXCLUSION
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"div "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Color dodge (ps6) */
return|return
name|GIMP_LAYER_MODE_DODGE
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"idiv"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Color burn (ps6) */
return|return
name|GIMP_LAYER_MODE_BURN
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lbrn"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Linear burn (ps7)*/
return|return
name|GIMP_LAYER_MODE_LINEAR_BURN
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lddg"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Linear dodge (ps7)*/
return|return
name|GIMP_LAYER_MODE_ADDITION
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Linear light (ps7)*/
return|return
name|GIMP_LAYER_MODE_LINEAR_LIGHT
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"pLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Pin light (ps7)*/
return|return
name|GIMP_LAYER_MODE_PIN_LIGHT
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"vLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Vivid light (ps7)*/
return|return
name|GIMP_LAYER_MODE_VIVID_LIGHT
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"hMix"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Hard Mix (CS)*/
return|return
name|GIMP_LAYER_MODE_HARD_MIX
return|;
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"dkCl"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Darker Color */
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
specifier|static
name|gchar
modifier|*
name|mode_name
init|=
literal|"DARKER COLOR"
decl_stmt|;
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer_composite
condition|)
operator|*
name|layer_composite
operator|=
name|GIMP_LAYER_COMPOSITE_AUTO
expr_stmt|;
return|return
name|GIMP_LAYER_MODE_NORMAL_LEGACY
return|;
block|}
if|if
condition|(
name|g_ascii_strncasecmp
argument_list|(
name|psd_mode
argument_list|,
literal|"lgCl"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* Lighter Color */
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
specifier|static
name|gchar
modifier|*
name|mode_name
init|=
literal|"LIGHTER COLOR"
decl_stmt|;
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer_composite
condition|)
operator|*
name|layer_composite
operator|=
name|GIMP_LAYER_COMPOSITE_AUTO
expr_stmt|;
return|return
name|GIMP_LAYER_MODE_NORMAL_LEGACY
return|;
block|}
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
block|{
name|gchar
modifier|*
name|mode_name
init|=
name|g_strndup
argument_list|(
name|psd_mode
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|mode_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer_composite
condition|)
operator|*
name|layer_composite
operator|=
name|GIMP_LAYER_COMPOSITE_AUTO
expr_stmt|;
return|return
name|GIMP_LAYER_MODE_NORMAL_LEGACY
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|gimp_to_psd_blend_mode (GimpLayerMode layer_mode,GimpLayerCompositeMode layer_composite)
name|gimp_to_psd_blend_mode
parameter_list|(
name|GimpLayerMode
name|layer_mode
parameter_list|,
name|GimpLayerCompositeMode
name|layer_composite
parameter_list|)
block|{
name|gchar
modifier|*
name|psd_mode
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|layer_mode
operator|==
name|GIMP_LAYER_MODE_NORMAL_LEGACY
operator|||
name|layer_mode
operator|==
name|GIMP_LAYER_MODE_DISSOLVE
operator|)
operator|&&
operator|(
name|layer_composite
operator|!=
name|GIMP_LAYER_COMPOSITE_AUTO
operator|&&
name|layer_composite
operator|!=
name|GIMP_LAYER_COMPOSITE_SRC_OVER
operator|)
operator|)
operator|||
name|layer_composite
operator|!=
name|GIMP_LAYER_COMPOSITE_SRC_OVER
condition|)
block|{
comment|/* FIXME, and above if() */
block|}
switch|switch
condition|(
name|layer_mode
condition|)
block|{
case|case
name|GIMP_LAYER_MODE_PASS_THROUGH
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"pass"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Pass through (CS) */
break|break;
case|case
name|GIMP_LAYER_MODE_NORMAL_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Normal (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_DISSOLVE
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"diss"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Dissolve (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_BEHIND
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LAYER_MODE_MULTIPLY
case|:
case|case
name|GIMP_LAYER_MODE_MULTIPLY_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"mul "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Multiply (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_SCREEN
case|:
case|case
name|GIMP_LAYER_MODE_SCREEN_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"scrn"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Screen (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_OVERLAY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"over"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Overlay (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_DIFFERENCE
case|:
case|case
name|GIMP_LAYER_MODE_DIFFERENCE_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"diff"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Difference (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_ADDITION
case|:
case|case
name|GIMP_LAYER_MODE_ADDITION_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"lddg"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Linear dodge (ps7)*/
break|break;
case|case
name|GIMP_LAYER_MODE_SUBTRACT_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LAYER_MODE_DARKEN_ONLY
case|:
case|case
name|GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"dark"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Darken (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_LIGHTEN_ONLY
case|:
case|case
name|GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"lite"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Lighten (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_LCH_HUE
case|:
case|case
name|GIMP_LAYER_MODE_HSV_HUE_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"hue "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Hue (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_LCH_CHROMA
case|:
case|case
name|GIMP_LAYER_MODE_HSV_SATURATION_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"GIMP uses a different equation to Photoshop for "
literal|"blend mode: %s. Results may differ."
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"sat "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Saturation (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_LCH_COLOR
case|:
case|case
name|GIMP_LAYER_MODE_HSL_COLOR_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"colr"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Color (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_LCH_LIGHTNESS
case|:
case|case
name|GIMP_LAYER_MODE_HSV_VALUE_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"GIMP uses a different equation to Photoshop for "
literal|"blend mode: %s. Results may differ."
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"lum "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Luminosity (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_DIVIDE_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LAYER_MODE_DODGE
case|:
case|case
name|GIMP_LAYER_MODE_DODGE_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"div "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Color Dodge (ps6) */
break|break;
case|case
name|GIMP_LAYER_MODE_EXCLUSION
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"smud"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Exclusion (ps6) */
break|break;
case|case
name|GIMP_LAYER_MODE_BURN
case|:
case|case
name|GIMP_LAYER_MODE_BURN_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"idiv"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Color Burn (ps6) */
break|break;
case|case
name|GIMP_LAYER_MODE_LINEAR_BURN
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"lbrn"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Linear Burn (ps6) */
break|break;
case|case
name|GIMP_LAYER_MODE_HARDLIGHT
case|:
case|case
name|GIMP_LAYER_MODE_HARDLIGHT_LEGACY
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"hLit"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Hard Light (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_VIVID_LIGHT
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"GIMP uses a different equation to Photoshop for "
literal|"blend mode: %s. Results may differ."
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"vLit"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Vivid Light (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_LINEAR_LIGHT
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"lLit"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Linear light (ps7)*/
break|break;
case|case
name|GIMP_LAYER_MODE_PIN_LIGHT
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"pLit"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Pin light (ps7)*/
break|break;
case|case
name|GIMP_LAYER_MODE_HARD_MIX
case|:
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"hMix"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Hard Mix (CS)*/
break|break;
case|case
name|GIMP_LAYER_MODE_OVERLAY_LEGACY
case|:
case|case
name|GIMP_LAYER_MODE_SOFTLIGHT_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"sLit"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Soft Light (ps3) */
break|break;
case|case
name|GIMP_LAYER_MODE_GRAIN_EXTRACT
case|:
case|case
name|GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LAYER_MODE_GRAIN_MERGE
case|:
case|case
name|GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_LAYER_MODE_COLOR_ERASE
case|:
case|case
name|GIMP_LAYER_MODE_COLOR_ERASE_LEGACY
case|:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported blend mode: %s. Mode reverts to normal"
argument_list|,
name|gimp_layer_mode_effects_name
argument_list|(
name|layer_mode
argument_list|)
argument_list|)
expr_stmt|;
name|psd_mode
operator|=
name|g_strndup
argument_list|(
literal|"norm"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|psd_mode
return|;
block|}
end_function

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|gimp_layer_mode_effects_name (GimpLayerMode mode)
name|gimp_layer_mode_effects_name
parameter_list|(
name|GimpLayerMode
name|mode
parameter_list|)
block|{
specifier|static
name|gchar
modifier|*
name|layer_mode_effects_names
index|[]
init|=
block|{
literal|"NORMAL"
block|,
literal|"DISSOLVE"
block|,
literal|"BEHIND"
block|,
literal|"MULTIPLY"
block|,
literal|"SCREEN"
block|,
literal|"OVERLAY"
block|,
literal|"DIFFERENCE"
block|,
literal|"ADD"
block|,
literal|"SUBTRACT"
block|,
literal|"EXCLUSION"
literal|"DARKEN"
block|,
literal|"LIGHTEN"
block|,
literal|"HUE"
block|,
literal|"SATURATION"
block|,
literal|"COLOR"
block|,
literal|"VALUE"
block|,
literal|"DIVIDE"
block|,
literal|"DODGE"
block|,
literal|"BURN"
block|,
literal|"LINEAR BURN"
literal|"HARD LIGHT"
block|,
literal|"SOFT LIGHT"
block|,
literal|"VIVID LIGHT"
block|,
literal|"LINEAR LIGHT"
block|,
literal|"PIN LIGHT"
block|,
literal|"HARD MIX"
literal|"GRAIN EXTRACT"
block|,
literal|"GRAIN MERGE"
block|,
literal|"COLOR ERASE"
literal|"PASS THROUGH"
block|}
decl_stmt|;
specifier|static
name|gchar
modifier|*
name|err_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mode
operator|>=
literal|0
operator|&&
name|mode
operator|<=
name|GIMP_LAYER_MODE_COLOR_ERASE_LEGACY
condition|)
return|return
name|layer_mode_effects_names
index|[
name|mode
index|]
return|;
name|g_free
argument_list|(
name|err_name
argument_list|)
expr_stmt|;
name|err_name
operator|=
name|g_strdup_printf
argument_list|(
literal|"UNKNOWN (%d)"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|err_name
return|;
block|}
end_function

begin_function
name|GimpColorTag
DECL|function|psd_to_gimp_layer_color_tag (guint16 layer_color_tag)
name|psd_to_gimp_layer_color_tag
parameter_list|(
name|guint16
name|layer_color_tag
parameter_list|)
block|{
name|GimpColorTag
name|colorTag
decl_stmt|;
switch|switch
condition|(
name|layer_color_tag
condition|)
block|{
case|case
literal|1
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_RED
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_ORANGE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_YELLOW
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_GREEN
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_BLUE
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_VIOLET
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|colorTag
operator|=
name|GIMP_COLOR_TAG_GRAY
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Unsupported Photoshop layer color tag: %i. GIMP layer color tag set to none."
argument_list|,
name|layer_color_tag
argument_list|)
expr_stmt|;
name|colorTag
operator|=
name|GIMP_COLOR_TAG_NONE
expr_stmt|;
block|}
return|return
name|colorTag
return|;
block|}
end_function

begin_function
name|guint16
DECL|function|gimp_to_psd_layer_color_tag (GimpColorTag layer_color_tag)
name|gimp_to_psd_layer_color_tag
parameter_list|(
name|GimpColorTag
name|layer_color_tag
parameter_list|)
block|{
name|guint16
name|color_tag
decl_stmt|;
switch|switch
condition|(
name|layer_color_tag
condition|)
block|{
case|case
name|GIMP_COLOR_TAG_RED
case|:
name|color_tag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_ORANGE
case|:
name|color_tag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_YELLOW
case|:
name|color_tag
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_GREEN
case|:
name|color_tag
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_BLUE
case|:
name|color_tag
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_VIOLET
case|:
name|color_tag
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|GIMP_COLOR_TAG_GRAY
case|:
name|color_tag
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Photoshop doesn't support GIMP layer color tag: %i. Photoshop layer color tag set to none."
argument_list|,
name|layer_color_tag
argument_list|)
expr_stmt|;
name|color_tag
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|color_tag
return|;
block|}
end_function

end_unit

