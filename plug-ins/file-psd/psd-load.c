begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * GIMP PSD Plug-in  * Copyright 2007 by John Marshall  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"psd.h"
end_include

begin_include
include|#
directive|include
file|"psd-util.h"
end_include

begin_include
include|#
directive|include
file|"psd-image-res-load.h"
end_include

begin_include
include|#
directive|include
file|"psd-layer-res-load.h"
end_include

begin_include
include|#
directive|include
file|"psd-load.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_define
DECL|macro|COMP_MODE_SIZE
define|#
directive|define
name|COMP_MODE_SIZE
value|sizeof(guint16)
end_define

begin_comment
comment|/*  Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gint
name|read_header_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|read_color_mode_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|read_image_resource_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PSDlayer
modifier|*
modifier|*
name|read_layer_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|read_merged_image_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|create_gimp_image
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|add_color_map
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|add_image_resources
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|gboolean
modifier|*
name|resolution_loaded
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|add_layers
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|PSDlayer
modifier|*
modifier|*
name|lyr_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|add_merged_image
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  Local utility function prototypes  */
end_comment

begin_function_decl
specifier|static
name|gchar
modifier|*
name|get_psd_color_mode_name
parameter_list|(
name|PSDColorMode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psd_to_gimp_color_map
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|GimpImageType
name|get_gimp_image_type
parameter_list|(
name|GimpImageBaseType
name|image_base_type
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|read_channel_data
parameter_list|(
name|PSDchannel
modifier|*
name|channel
parameter_list|,
name|guint16
name|bps
parameter_list|,
name|guint16
name|compression
parameter_list|,
specifier|const
name|guint16
modifier|*
name|rle_pack_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|guint32
name|comp_len
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_1_bit
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|guint32
name|rows
parameter_list|,
name|guint32
name|columns
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|Babl
modifier|*
name|get_layer_format
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|Babl
modifier|*
name|get_channel_format
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|Babl
modifier|*
name|get_mask_format
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Main file load function */
end_comment

begin_function
name|gint32
DECL|function|load_image (const gchar * filename,gboolean * resolution_loaded,GError ** load_error)
name|load_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gboolean
modifier|*
name|resolution_loaded
parameter_list|,
name|GError
modifier|*
modifier|*
name|load_error
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|PSDimage
name|img_a
decl_stmt|;
name|PSDlayer
modifier|*
modifier|*
name|lyr_a
decl_stmt|;
name|gint32
name|image_id
init|=
operator|-
literal|1
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
comment|/* ----- Open PSD file ----- */
if|if
condition|(
name|g_stat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Open file %s"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|load_error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ----- Read the PSD file Header block ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Read header block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_header_block
argument_list|(
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.1
argument_list|)
expr_stmt|;
comment|/* ----- Read the PSD file Color Mode block ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Read color mode block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_color_mode_block
argument_list|(
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.2
argument_list|)
expr_stmt|;
comment|/* ----- Read the PSD file Image Resource block ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Read image resource block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_image_resource_block
argument_list|(
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.3
argument_list|)
expr_stmt|;
comment|/* ----- Read the PSD file Layer& Mask block ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Read layer& mask block"
argument_list|)
expr_stmt|;
name|lyr_a
operator|=
name|read_layer_block
argument_list|(
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|img_a
operator|.
name|num_layers
operator|!=
literal|0
operator|&&
name|lyr_a
operator|==
name|NULL
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.4
argument_list|)
expr_stmt|;
comment|/* ----- Read the PSD file Merged Image Data block ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Read merged image and extra alpha channel block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_merged_image_block
argument_list|(
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
comment|/* ----- Create GIMP image ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Create GIMP image"
argument_list|)
expr_stmt|;
name|image_id
operator|=
name|create_gimp_image
argument_list|(
operator|&
name|img_a
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_id
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.6
argument_list|)
expr_stmt|;
comment|/* ----- Add color map ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Add color map"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_color_map
argument_list|(
name|image_id
argument_list|,
operator|&
name|img_a
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.7
argument_list|)
expr_stmt|;
comment|/* ----- Add image resources ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Add image resources"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_image_resources
argument_list|(
name|image_id
argument_list|,
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
name|resolution_loaded
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.8
argument_list|)
expr_stmt|;
comment|/* ----- Add layers -----*/
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Add layers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|img_a
argument_list|,
name|lyr_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|0.9
argument_list|)
expr_stmt|;
comment|/* ----- Add merged image data and extra alpha channels ----- */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Add merged image data and extra alpha channels"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_merged_image
argument_list|(
name|image_id
argument_list|,
operator|&
name|img_a
argument_list|,
name|f
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|load_error
goto|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Close file& return, image id: %d"
argument_list|,
name|image_id
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"\n----------------------------------------"
literal|"----------------------------------------\n"
argument_list|)
expr_stmt|;
name|gimp_image_clean_all
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|gimp_image_undo_enable
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|image_id
return|;
comment|/* ----- Process load errors ----- */
name|load_error
label|:
if|if
condition|(
name|error
condition|)
block|{
name|g_set_error
argument_list|(
name|load_error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error loading PSD file: %s"
argument_list|)
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
name|g_error_free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Delete partially loaded image */
if|if
condition|(
name|image_id
operator|>
literal|0
condition|)
name|gimp_image_delete
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
comment|/* Close file if Open */
if|if
condition|(
operator|!
operator|(
name|f
operator|==
name|NULL
operator|)
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Local functions */
end_comment

begin_function
specifier|static
name|gint
DECL|function|read_header_block (PSDimage * img_a,FILE * f,GError ** error)
name|read_header_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guint16
name|version
decl_stmt|;
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|gchar
name|buf
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|sig
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|version
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
name|buf
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|img_a
operator|->
name|channels
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|img_a
operator|->
name|rows
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|img_a
operator|->
name|columns
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|img_a
operator|->
name|bps
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|img_a
operator|->
name|color_mode
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|version
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|channels
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|img_a
operator|->
name|channels
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|rows
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|img_a
operator|->
name|rows
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|columns
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|img_a
operator|->
name|columns
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|bps
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|img_a
operator|->
name|bps
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|color_mode
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|img_a
operator|->
name|color_mode
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"\n\n\tSig: %.4s\n\tVer: %d\n\tChannels: "
literal|"%d\n\tSize: %dx%d\n\tBPS: %d\n\tMode: %d\n"
argument_list|,
name|sig
argument_list|,
name|version
argument_list|,
name|img_a
operator|->
name|channels
argument_list|,
name|img_a
operator|->
name|columns
argument_list|,
name|img_a
operator|->
name|rows
argument_list|,
name|img_a
operator|->
name|bps
argument_list|,
name|img_a
operator|->
name|color_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|sig
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Not a valid Photoshop document file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported file format version: %d"
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|img_a
operator|->
name|channels
operator|>
name|MAX_CHANNELS
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Too many channels in file: %d"
argument_list|)
argument_list|,
name|img_a
operator|->
name|channels
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Photoshop CS (version 8) supports 300000 x 300000, but this        is currently larger than GIMP_MAX_IMAGE_SIZE */
if|if
condition|(
name|img_a
operator|->
name|rows
operator|<
literal|1
operator|||
name|img_a
operator|->
name|rows
operator|>
name|GIMP_MAX_IMAGE_SIZE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid image height: %d"
argument_list|)
argument_list|,
name|img_a
operator|->
name|rows
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|img_a
operator|->
name|columns
operator|<
literal|1
operator|||
name|img_a
operator|->
name|columns
operator|>
name|GIMP_MAX_IMAGE_SIZE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid image width: %d"
argument_list|)
argument_list|,
name|img_a
operator|->
name|columns
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* img_a->rows is sanitized above, so a division by zero is avoided here */
if|if
condition|(
name|img_a
operator|->
name|columns
operator|>
name|G_MAXINT32
operator|/
name|img_a
operator|->
name|rows
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid image size: %dx%d"
argument_list|)
argument_list|,
name|img_a
operator|->
name|columns
argument_list|,
name|img_a
operator|->
name|rows
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|img_a
operator|->
name|color_mode
operator|!=
name|PSD_BITMAP
operator|&&
name|img_a
operator|->
name|color_mode
operator|!=
name|PSD_GRAYSCALE
operator|&&
name|img_a
operator|->
name|color_mode
operator|!=
name|PSD_INDEXED
operator|&&
name|img_a
operator|->
name|color_mode
operator|!=
name|PSD_RGB
operator|&&
name|img_a
operator|->
name|color_mode
operator|!=
name|PSD_DUOTONE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported color mode: %s"
argument_list|)
argument_list|,
name|get_psd_color_mode_name
argument_list|(
name|img_a
operator|->
name|color_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Warning for unsupported bit depth */
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"32 Bit Data"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"16 Bit Data"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"8 Bit Data"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"1 Bit Data"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported bit depth: %d"
argument_list|)
argument_list|,
name|img_a
operator|->
name|bps
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|read_color_mode_block (PSDimage * img_a,FILE * f,GError ** error)
name|read_color_mode_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
specifier|static
name|guchar
name|cmap
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
decl_stmt|;
name|guint32
name|block_len
decl_stmt|;
name|img_a
operator|->
name|color_map_entries
operator|=
literal|0
expr_stmt|;
name|img_a
operator|->
name|color_map_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|block_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Color map block size = %d"
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_INDEXED
operator|||
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_DUOTONE
condition|)
block|{
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"No color block for indexed or duotone image"
argument_list|)
expr_stmt|;
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"The file is corrupt!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_INDEXED
condition|)
block|{
if|if
condition|(
name|block_len
operator|!=
literal|768
condition|)
block|{
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Invalid color block size for indexed image"
argument_list|)
expr_stmt|;
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"The file is corrupt!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|img_a
operator|->
name|color_map_len
operator|=
name|block_len
expr_stmt|;
name|img_a
operator|->
name|color_map
operator|=
name|g_malloc
argument_list|(
name|img_a
operator|->
name|color_map_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|img_a
operator|->
name|color_map
argument_list|,
name|block_len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|psd_to_gimp_color_map
argument_list|(
name|img_a
operator|->
name|color_map
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|color_map_entries
operator|=
literal|256
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_DUOTONE
condition|)
block|{
name|img_a
operator|->
name|color_map_len
operator|=
name|block_len
expr_stmt|;
name|img_a
operator|->
name|color_map
operator|=
name|g_malloc
argument_list|(
name|img_a
operator|->
name|color_map_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|img_a
operator|->
name|color_map
argument_list|,
name|block_len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Create color map for bitmap image */
if|if
condition|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_BITMAP
condition|)
block|{
name|img_a
operator|->
name|color_map_len
operator|=
literal|6
expr_stmt|;
name|img_a
operator|->
name|color_map
operator|=
name|g_malloc
argument_list|(
name|img_a
operator|->
name|color_map_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|img_a
operator|->
name|color_map
argument_list|,
name|cmap
argument_list|,
name|img_a
operator|->
name|color_map_len
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|color_map_entries
operator|=
literal|2
expr_stmt|;
block|}
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Color map data length %d"
argument_list|,
name|img_a
operator|->
name|color_map_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|read_image_resource_block (PSDimage * img_a,FILE * f,GError ** error)
name|read_image_resource_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|guint32
name|block_len
decl_stmt|;
name|guint32
name|block_end
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|img_a
operator|->
name|image_res_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Image resource block size = %d"
argument_list|,
operator|(
name|int
operator|)
name|img_a
operator|->
name|image_res_len
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|image_res_start
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|block_end
operator|=
name|img_a
operator|->
name|image_res_start
operator|+
name|img_a
operator|->
name|image_res_len
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|block_end
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|PSDlayer
modifier|*
modifier|*
DECL|function|read_layer_info (PSDimage * img_a,FILE * f,GError ** error)
name|read_layer_info
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|PSDlayer
modifier|*
modifier|*
name|lyr_a
init|=
name|NULL
decl_stmt|;
name|guint32
name|block_len
decl_stmt|;
name|guint32
name|block_rem
decl_stmt|;
name|gint32
name|read_len
decl_stmt|;
name|gint32
name|write_len
decl_stmt|;
name|gint
name|lidx
decl_stmt|;
comment|/* Layer index */
name|gint
name|cidx
decl_stmt|;
comment|/* Channel index */
comment|/* Get number of layers */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|img_a
operator|->
name|num_layers
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|num_layers
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|img_a
operator|->
name|num_layers
operator|=
name|GINT16_FROM_BE
argument_list|(
name|img_a
operator|->
name|num_layers
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Number of layers: %d"
argument_list|,
name|img_a
operator|->
name|num_layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|img_a
operator|->
name|num_layers
operator|<
literal|0
condition|)
block|{
name|img_a
operator|->
name|transparency
operator|=
name|TRUE
expr_stmt|;
name|img_a
operator|->
name|num_layers
operator|=
operator|-
name|img_a
operator|->
name|num_layers
expr_stmt|;
block|}
if|if
condition|(
name|img_a
operator|->
name|num_layers
condition|)
block|{
comment|/* Read layer records */
name|PSDlayerres
name|res_a
decl_stmt|;
comment|/* Create pointer array for the layer records */
name|lyr_a
operator|=
name|g_new
argument_list|(
name|PSDlayer
operator|*
argument_list|,
name|img_a
operator|->
name|num_layers
argument_list|)
expr_stmt|;
for|for
control|(
name|lidx
operator|=
literal|0
init|;
name|lidx
operator|<
name|img_a
operator|->
name|num_layers
condition|;
operator|++
name|lidx
control|)
block|{
comment|/* Allocate layer record */
name|lyr_a
index|[
name|lidx
index|]
operator|=
operator|(
name|PSDlayer
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PSDlayer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialise record */
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|drop
operator|=
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
operator|>
name|MAX_CHANNELS
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Too many channels in layer: %d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
operator|||
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
operator|>
name|GIMP_MAX_IMAGE_SIZE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid layer height: %d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
operator|||
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
operator|>
name|GIMP_MAX_IMAGE_SIZE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid layer width: %d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
operator|)
operator|>
name|G_MAXINT32
operator|/
name|MAX
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid layer size: %dx%d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Layer %d, Coords %d %d %d %d, channels %d, "
argument_list|,
name|lidx
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
operator|=
name|g_new
argument_list|(
name|ChannelLengthInfo
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
condition|;
operator|++
name|cidx
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|channel_id
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|channel_id
operator|=
name|GINT16_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|channel_id
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|layer_data_len
operator|+=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Channel ID %d, data len %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|channel_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|mode_key
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|blend_mode
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|opacity
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|clipping
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|filler
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|extra_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|mode_key
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Incorrect layer mode signature %.4s"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|mode_key
argument_list|)
expr_stmt|;
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"The file is corrupt!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|trans_prot
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|flags
operator|&
literal|1
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|visible
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|flags
operator|&
literal|2
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|flags
operator|&
literal|8
condition|)
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|irrelevant
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|flags
operator|&
literal|16
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
else|else
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|irrelevant
operator|=
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|extra_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|block_rem
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|extra_len
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"\n\tLayer mode sig: %.4s\n\tBlend mode: %.4s\n\t"
literal|"Opacity: %d\n\tClipping: %d\n\tExtra data len: %d\n\t"
literal|"Alpha lock: %d\n\tVisible: %d\n\tIrrelevant: %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|mode_key
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|blend_mode
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|opacity
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|clipping
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|extra_len
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|trans_prot
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|visible
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|irrelevant
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Remaining length %d"
argument_list|,
name|block_rem
argument_list|)
expr_stmt|;
comment|/* Layer mask data */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|block_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|block_rem
operator|-=
operator|(
name|block_len
operator|+
literal|4
operator|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Remaining length %d"
argument_list|,
name|block_rem
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|def_color
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|extra_def_color
operator|=
literal|0
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|relative_pos
operator|=
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|disabled
operator|=
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|invert
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|block_len
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|20
case|:
if|if
condition|(
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|def_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|extra_def_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|extra_flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|relative_pos
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
operator|&
literal|1
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|disabled
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
operator|&
literal|2
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|invert
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
operator|&
literal|4
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
break|break;
case|case
literal|36
case|:
comment|/* If we have a 36 byte mask record assume second data set is correct */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|top
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|left
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|bottom
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|right
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|extra_def_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|extra_flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|def_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|top
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|top
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|left
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|left
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|bottom
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|right
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask_extra
operator|.
name|right
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|=
name|GINT32_FROM_BE
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
argument_list|)
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|relative_pos
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
operator|&
literal|1
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|disabled
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
operator|&
literal|2
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|invert
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|flags
operator|&
literal|4
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
break|break;
default|default:
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Unknown layer mask record size ... skipping"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|block_len
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* sanity checks */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|||
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|>
name|GIMP_MAX_IMAGE_SIZE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid layer mask height: %d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|||
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|>
name|GIMP_MAX_IMAGE_SIZE
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid layer mask width: %d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|)
operator|>
name|G_MAXINT32
operator|/
name|MAX
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid layer mask size: %dx%d"
argument_list|)
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Layer mask coords %d %d %d %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Default mask color, %d, %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|def_color
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|extra_def_color
argument_list|)
expr_stmt|;
comment|/* Layer blending ranges */
comment|/* FIXME  */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|block_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|block_rem
operator|-=
operator|(
name|block_len
operator|+
literal|4
operator|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Remaining length %d"
argument_list|,
name|block_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|block_len
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|name
operator|=
name|fread_pascal_string
argument_list|(
operator|&
name|read_len
argument_list|,
operator|&
name|write_len
argument_list|,
literal|4
argument_list|,
name|f
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|error
condition|)
return|return
name|NULL
return|;
name|block_rem
operator|-=
name|read_len
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Remaining length %d"
argument_list|,
name|block_rem
argument_list|)
expr_stmt|;
comment|/* Adjustment layer info */
comment|/* FIXME */
while|while
condition|(
name|block_rem
operator|>
literal|7
condition|)
block|{
if|if
condition|(
name|get_layer_resource_header
argument_list|(
operator|&
name|res_a
argument_list|,
name|f
argument_list|,
name|error
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|block_rem
operator|-=
literal|12
expr_stmt|;
if|if
condition|(
name|res_a
operator|.
name|data_len
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
comment|/*  Warn the user about an invalid length value but                    *  try to recover graciously. See bug #771558.                    */
name|g_printerr
argument_list|(
literal|"psd-load: Layer extra data length should "
literal|"be even, but it is %d."
argument_list|,
name|res_a
operator|.
name|data_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res_a
operator|.
name|data_len
operator|>
name|block_rem
condition|)
block|{
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Unexpected end of layer resource data"
argument_list|)
expr_stmt|;
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"The file is corrupt!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|load_layer_resource
argument_list|(
operator|&
name|res_a
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
argument_list|,
name|f
argument_list|,
name|error
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|block_rem
operator|-=
name|res_a
operator|.
name|data_len
expr_stmt|;
block|}
if|if
condition|(
name|block_rem
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|block_rem
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
name|img_a
operator|->
name|layer_data_start
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|img_a
operator|->
name|layer_data_len
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Layer image data block size %d"
argument_list|,
name|img_a
operator|->
name|layer_data_len
argument_list|)
expr_stmt|;
block|}
return|return
name|lyr_a
return|;
block|}
end_function

begin_function
specifier|static
name|PSDlayer
modifier|*
modifier|*
DECL|function|read_layer_block (PSDimage * img_a,FILE * f,GError ** error)
name|read_layer_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|PSDlayer
modifier|*
modifier|*
name|lyr_a
init|=
name|NULL
decl_stmt|;
name|guint32
name|block_len
decl_stmt|;
name|guint32
name|block_end
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|num_layers
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|img_a
operator|->
name|mask_layer_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Layer and mask block size = %d"
argument_list|,
name|img_a
operator|->
name|mask_layer_len
argument_list|)
expr_stmt|;
name|img_a
operator|->
name|transparency
operator|=
name|FALSE
expr_stmt|;
name|img_a
operator|->
name|layer_data_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|img_a
operator|->
name|mask_layer_len
condition|)
block|{
name|img_a
operator|->
name|num_layers
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|guint32
name|total_len
init|=
name|img_a
operator|->
name|mask_layer_len
decl_stmt|;
name|img_a
operator|->
name|mask_layer_start
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|block_end
operator|=
name|img_a
operator|->
name|mask_layer_start
operator|+
name|img_a
operator|->
name|mask_layer_len
expr_stmt|;
comment|/* Layer info */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|==
literal|1
operator|&&
name|block_len
condition|)
block|{
name|block_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Layer info size = %d"
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
name|lyr_a
operator|=
name|read_layer_info
argument_list|(
name|img_a
argument_list|,
name|f
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|total_len
operator|-=
name|block_len
expr_stmt|;
block|}
else|else
block|{
name|img_a
operator|->
name|num_layers
operator|=
literal|0
expr_stmt|;
name|lyr_a
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Global layer mask info */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|==
literal|1
operator|&&
name|block_len
condition|)
block|{
name|block_len
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|block_len
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Global layer mask info size = %d"
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
comment|/* read_global_layer_mask_info (img_a, f, error); */
name|fseek
argument_list|(
name|f
argument_list|,
name|block_len
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|total_len
operator|-=
name|block_len
expr_stmt|;
block|}
comment|/* Additional Layer Information */
if|if
condition|(
name|total_len
operator|>
literal|12
condition|)
block|{
name|gchar
name|signature_key
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|signature_key
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
name|f
argument_list|)
operator|==
literal|2
operator|&&
operator|(
name|memcmp
argument_list|(
name|signature_key
argument_list|,
literal|"8BIMLr16"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|signature_key
argument_list|,
literal|"8BIMLr32"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|fread
argument_list|(
operator|&
name|block_len
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|==
literal|1
operator|&&
name|block_len
condition|)
name|lyr_a
operator|=
name|read_layer_info
argument_list|(
name|img_a
argument_list|,
name|f
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Skip to end of block */
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|block_end
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|lyr_a
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|read_merged_image_block (PSDimage * img_a,FILE * f,GError ** error)
name|read_merged_image_block
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|img_a
operator|->
name|merged_image_start
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|img_a
operator|->
name|merged_image_len
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
operator|-
name|img_a
operator|->
name|merged_image_start
expr_stmt|;
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Merged image data block: Start: %d, len: %d"
argument_list|,
name|img_a
operator|->
name|merged_image_start
argument_list|,
name|img_a
operator|->
name|merged_image_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|create_gimp_image (PSDimage * img_a,const gchar * filename)
name|create_gimp_image
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|)
block|{
name|gint32
name|image_id
init|=
operator|-
literal|1
decl_stmt|;
name|GimpPrecision
name|precision
decl_stmt|;
switch|switch
condition|(
name|img_a
operator|->
name|color_mode
condition|)
block|{
case|case
name|PSD_GRAYSCALE
case|:
case|case
name|PSD_DUOTONE
case|:
name|img_a
operator|->
name|base_type
operator|=
name|GIMP_GRAY
expr_stmt|;
break|break;
case|case
name|PSD_BITMAP
case|:
case|case
name|PSD_INDEXED
case|:
name|img_a
operator|->
name|base_type
operator|=
name|GIMP_INDEXED
expr_stmt|;
break|break;
case|case
name|PSD_RGB
case|:
name|img_a
operator|->
name|base_type
operator|=
name|GIMP_RGB
expr_stmt|;
break|break;
default|default:
comment|/* Color mode already validated - should not be here */
name|g_warning
argument_list|(
literal|"Invalid color mode"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|precision
operator|=
name|GIMP_PRECISION_U32_GAMMA
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|precision
operator|=
name|GIMP_PRECISION_U16_GAMMA
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|precision
operator|=
name|GIMP_PRECISION_U8_GAMMA
expr_stmt|;
break|break;
default|default:
comment|/* Precision not supported */
name|g_warning
argument_list|(
literal|"Invalid precision"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
comment|/* Create gimp image */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Create image"
argument_list|)
expr_stmt|;
name|image_id
operator|=
name|gimp_image_new_with_precision
argument_list|(
name|img_a
operator|->
name|columns
argument_list|,
name|img_a
operator|->
name|rows
argument_list|,
name|img_a
operator|->
name|base_type
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_id
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_image_undo_disable
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
return|return
name|image_id
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|add_color_map (gint32 image_id,PSDimage * img_a)
name|add_color_map
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|parasite
decl_stmt|;
if|if
condition|(
name|img_a
operator|->
name|color_map_len
condition|)
block|{
if|if
condition|(
name|img_a
operator|->
name|color_mode
operator|!=
name|PSD_DUOTONE
condition|)
block|{
name|gimp_image_set_colormap
argument_list|(
name|image_id
argument_list|,
name|img_a
operator|->
name|color_map
argument_list|,
name|img_a
operator|->
name|color_map_entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add parasite for Duotone color data */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Add Duotone color data parasite"
argument_list|)
expr_stmt|;
name|parasite
operator|=
name|gimp_parasite_new
argument_list|(
name|PSD_PARASITE_DUOTONE_DATA
argument_list|,
literal|0
argument_list|,
name|img_a
operator|->
name|color_map_len
argument_list|,
name|img_a
operator|->
name|color_map
argument_list|)
expr_stmt|;
name|gimp_image_attach_parasite
argument_list|(
name|image_id
argument_list|,
name|parasite
argument_list|)
expr_stmt|;
name|gimp_parasite_free
argument_list|(
name|parasite
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|img_a
operator|->
name|color_map
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|add_image_resources (gint32 image_id,PSDimage * img_a,FILE * f,gboolean * resolution_loaded,GError ** error)
name|add_image_resources
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|gboolean
modifier|*
name|resolution_loaded
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|PSDimageres
name|res_a
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|img_a
operator|->
name|image_res_start
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialise image resource variables */
name|img_a
operator|->
name|no_icc
operator|=
name|FALSE
expr_stmt|;
name|img_a
operator|->
name|layer_state
operator|=
literal|0
expr_stmt|;
name|img_a
operator|->
name|alpha_names
operator|=
name|NULL
expr_stmt|;
name|img_a
operator|->
name|alpha_display_info
operator|=
name|NULL
expr_stmt|;
name|img_a
operator|->
name|alpha_display_count
operator|=
literal|0
expr_stmt|;
name|img_a
operator|->
name|alpha_id
operator|=
name|NULL
expr_stmt|;
name|img_a
operator|->
name|alpha_id_count
operator|=
literal|0
expr_stmt|;
name|img_a
operator|->
name|quick_mask_id
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ftell
argument_list|(
name|f
argument_list|)
operator|<
name|img_a
operator|->
name|image_res_start
operator|+
name|img_a
operator|->
name|image_res_len
condition|)
block|{
if|if
condition|(
name|get_image_resource_header
argument_list|(
operator|&
name|res_a
argument_list|,
name|f
argument_list|,
name|error
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|res_a
operator|.
name|data_start
operator|+
name|res_a
operator|.
name|data_len
operator|>
name|img_a
operator|->
name|image_res_start
operator|+
name|img_a
operator|->
name|image_res_len
condition|)
block|{
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"Unexpected end of image resource data"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|load_image_resource
argument_list|(
operator|&
name|res_a
argument_list|,
name|image_id
argument_list|,
name|img_a
argument_list|,
name|f
argument_list|,
name|resolution_loaded
argument_list|,
name|error
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|add_layers (gint32 image_id,PSDimage * img_a,PSDlayer ** lyr_a,FILE * f,GError ** error)
name|add_layers
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|PSDlayer
modifier|*
modifier|*
name|lyr_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|PSDchannel
modifier|*
modifier|*
name|lyr_chn
decl_stmt|;
name|GArray
modifier|*
name|parent_group_stack
decl_stmt|;
name|gint32
name|parent_group_id
init|=
operator|-
literal|1
decl_stmt|;
name|guchar
modifier|*
name|pixels
decl_stmt|;
name|guint16
name|alpha_chn
decl_stmt|;
name|guint16
name|user_mask_chn
decl_stmt|;
name|guint16
name|layer_channels
decl_stmt|;
name|guint16
name|channel_idx
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|guint16
modifier|*
name|rle_pack_len
decl_stmt|;
name|guint16
name|bps
decl_stmt|;
name|gint32
name|l_x
decl_stmt|;
comment|/* Layer x */
name|gint32
name|l_y
decl_stmt|;
comment|/* Layer y */
name|gint32
name|l_w
decl_stmt|;
comment|/* Layer width */
name|gint32
name|l_h
decl_stmt|;
comment|/* Layer height */
name|gint32
name|lm_x
decl_stmt|;
comment|/* Layer mask x */
name|gint32
name|lm_y
decl_stmt|;
comment|/* Layer mask y */
name|gint32
name|lm_w
decl_stmt|;
comment|/* Layer mask width */
name|gint32
name|lm_h
decl_stmt|;
comment|/* Layer mask height */
name|gint32
name|layer_size
decl_stmt|;
name|gint32
name|layer_id
init|=
operator|-
literal|1
decl_stmt|;
name|gint32
name|mask_id
init|=
operator|-
literal|1
decl_stmt|;
name|gint
name|lidx
decl_stmt|;
comment|/* Layer index */
name|gint
name|cidx
decl_stmt|;
comment|/* Channel index */
name|gint
name|rowi
decl_stmt|;
comment|/* Row index */
name|gint
name|coli
decl_stmt|;
comment|/* Column index */
name|gint
name|i
decl_stmt|;
name|gboolean
name|alpha
decl_stmt|;
name|gboolean
name|user_mask
decl_stmt|;
name|gboolean
name|empty
decl_stmt|;
name|gboolean
name|empty_mask
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|GimpImageType
name|image_type
decl_stmt|;
name|LayerModeInfo
name|mode_info
decl_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Number of layers: %d"
argument_list|,
name|img_a
operator|->
name|num_layers
argument_list|)
expr_stmt|;
if|if
condition|(
name|img_a
operator|->
name|num_layers
operator|==
literal|0
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"No layers to process"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Layered image - Photoshop 3 style */
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|img_a
operator|->
name|layer_data_start
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* set the root of the group hierarchy */
name|parent_group_stack
operator|=
name|g_array_new
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|,
sizeof|sizeof
argument_list|(
name|gint32
argument_list|)
argument_list|)
expr_stmt|;
name|g_array_append_val
argument_list|(
name|parent_group_stack
argument_list|,
name|parent_group_id
argument_list|)
expr_stmt|;
for|for
control|(
name|lidx
operator|=
literal|0
init|;
name|lidx
operator|<
name|img_a
operator|->
name|num_layers
condition|;
operator|++
name|lidx
control|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Process Layer No %d."
argument_list|,
name|lidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|drop
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Drop layer %d"
argument_list|,
name|lidx
argument_list|)
expr_stmt|;
comment|/* Step past layer data */
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
condition|;
operator|++
name|cidx
control|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Empty layer */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
operator|==
literal|0
operator|||
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
operator|==
literal|0
condition|)
name|empty
operator|=
name|TRUE
expr_stmt|;
else|else
name|empty
operator|=
name|FALSE
expr_stmt|;
comment|/* Empty mask */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|==
literal|0
operator|||
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|==
literal|0
condition|)
name|empty_mask
operator|=
name|TRUE
expr_stmt|;
else|else
name|empty_mask
operator|=
name|FALSE
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Empty mask %d, size %d %d"
argument_list|,
name|empty_mask
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* Load layer channel data */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Number of channels: %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|)
expr_stmt|;
comment|/* Create pointer array for the channel records */
name|lyr_chn
operator|=
name|g_new
argument_list|(
name|PSDchannel
operator|*
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
condition|;
operator|++
name|cidx
control|)
block|{
name|guint16
name|comp_mode
init|=
name|PSD_COMP_RAW
decl_stmt|;
comment|/* Allocate channel record */
name|lyr_chn
index|[
name|cidx
index|]
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PSDchannel
argument_list|)
argument_list|)
expr_stmt|;
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|id
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|channel_id
expr_stmt|;
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
expr_stmt|;
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|columns
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|id
operator|==
name|PSD_CHANNEL_MASK
condition|)
block|{
comment|/* Works around a bug in panotools psd files where the layer mask                      size is given as 0 but data exists. Set mask size to layer size.                   */
if|if
condition|(
name|empty_mask
operator|&&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|-
literal|2
operator|>
literal|0
condition|)
block|{
name|empty_mask
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|==
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
condition|)
block|{
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
expr_stmt|;
block|}
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|==
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
condition|)
block|{
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
expr_stmt|;
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
expr_stmt|;
block|}
block|}
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
operator|=
operator|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|)
expr_stmt|;
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|columns
operator|=
operator|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|)
expr_stmt|;
block|}
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Channel id %d, %dx%d"
argument_list|,
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|id
argument_list|,
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|columns
argument_list|,
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
argument_list|)
expr_stmt|;
comment|/* Only read channel data if there is any channel                * data. Note that the channel data can contain a                * compression method but no actual data.                */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|>=
name|COMP_MODE_SIZE
condition|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|comp_mode
argument_list|,
name|COMP_MODE_SIZE
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|comp_mode
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|comp_mode
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Compression mode: %d"
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|>
name|COMP_MODE_SIZE
condition|)
block|{
switch|switch
condition|(
name|comp_mode
condition|)
block|{
case|case
name|PSD_COMP_RAW
case|:
comment|/* Planar raw data */
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Raw data length: %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_channel_data
argument_list|(
name|lyr_chn
index|[
name|cidx
index|]
argument_list|,
name|img_a
operator|->
name|bps
argument_list|,
name|PSD_COMP_RAW
argument_list|,
name|NULL
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|PSD_COMP_RLE
case|:
comment|/* Packbits */
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"RLE channel length %d, RLE length data: %d, "
literal|"RLE data block: %d"
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|-
literal|2
argument_list|,
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
operator|*
literal|2
argument_list|,
operator|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|-
literal|2
operator|-
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
name|rle_pack_len
operator|=
name|g_malloc
argument_list|(
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|rowi
operator|=
literal|0
init|;
name|rowi
operator|<
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|rows
condition|;
operator|++
name|rowi
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|rle_pack_len
index|[
name|rowi
index|]
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|rle_pack_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rle_pack_len
index|[
name|rowi
index|]
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|rle_pack_len
index|[
name|rowi
index|]
argument_list|)
expr_stmt|;
block|}
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"RLE decode - data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_channel_data
argument_list|(
name|lyr_chn
index|[
name|cidx
index|]
argument_list|,
name|img_a
operator|->
name|bps
argument_list|,
name|PSD_COMP_RLE
argument_list|,
name|rle_pack_len
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|g_free
argument_list|(
name|rle_pack_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSD_COMP_ZIP
case|:
comment|/* ? */
case|case
name|PSD_COMP_ZIP_PRED
case|:
if|if
condition|(
name|read_channel_data
argument_list|(
name|lyr_chn
index|[
name|cidx
index|]
argument_list|,
name|img_a
operator|->
name|bps
argument_list|,
name|comp_mode
argument_list|,
name|NULL
argument_list|,
name|f
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
index|[
name|cidx
index|]
operator|.
name|data_len
operator|-
literal|2
argument_list|,
name|error
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported compression mode: %d"
argument_list|)
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
block|}
block|}
comment|/* Draw layer */
name|alpha
operator|=
name|FALSE
expr_stmt|;
name|alpha_chn
operator|=
operator|-
literal|1
expr_stmt|;
name|user_mask
operator|=
name|FALSE
expr_stmt|;
name|user_mask_chn
operator|=
operator|-
literal|1
expr_stmt|;
name|layer_channels
operator|=
literal|0
expr_stmt|;
name|l_x
operator|=
literal|0
expr_stmt|;
name|l_y
operator|=
literal|0
expr_stmt|;
name|l_w
operator|=
name|img_a
operator|->
name|columns
expr_stmt|;
name|l_h
operator|=
name|img_a
operator|->
name|rows
expr_stmt|;
if|if
condition|(
name|parent_group_stack
operator|->
name|len
operator|>
literal|0
condition|)
name|parent_group_id
operator|=
name|g_array_index
argument_list|(
name|parent_group_stack
argument_list|,
name|gint32
argument_list|,
name|parent_group_stack
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|parent_group_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* root */
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Re-hash channel indices"
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
condition|;
operator|++
name|cidx
control|)
block|{
if|if
condition|(
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|id
operator|==
name|PSD_CHANNEL_MASK
condition|)
block|{
name|user_mask
operator|=
name|TRUE
expr_stmt|;
name|user_mask_chn
operator|=
name|cidx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lyr_chn
index|[
name|cidx
index|]
operator|->
name|id
operator|==
name|PSD_CHANNEL_ALPHA
condition|)
block|{
name|alpha
operator|=
name|TRUE
expr_stmt|;
name|alpha_chn
operator|=
name|cidx
expr_stmt|;
block|}
else|else
block|{
name|channel_idx
index|[
name|layer_channels
index|]
operator|=
name|cidx
expr_stmt|;
comment|/* Assumes in sane order */
name|layer_channels
operator|++
expr_stmt|;
comment|/* RGB, Lab, CMYK etc.   */
block|}
block|}
if|if
condition|(
name|alpha
condition|)
block|{
name|channel_idx
index|[
name|layer_channels
index|]
operator|=
name|alpha_chn
expr_stmt|;
name|layer_channels
operator|++
expr_stmt|;
block|}
comment|/* Create the layer */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|3
condition|)
block|{
comment|/* the</Layer group> marker layers are used to                    * assemble the layer structure in a single pass                    */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Create placeholder group layer"
argument_list|)
expr_stmt|;
name|layer_id
operator|=
name|gimp_layer_group_new
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
comment|/* add this group layer as the new parent */
name|g_array_append_val
argument_list|(
name|parent_group_stack
argument_list|,
name|layer_id
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* group-type == 1 || group_type == 2 */
block|{
if|if
condition|(
name|parent_group_stack
operator|->
name|len
condition|)
block|{
name|layer_id
operator|=
name|g_array_index
argument_list|(
name|parent_group_stack
argument_list|,
name|gint32
argument_list|,
name|parent_group_stack
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"End group layer id %d."
argument_list|,
name|layer_id
argument_list|)
expr_stmt|;
comment|/* since the layers are stored in reverse, the group                        * layer start marker actually means we're done with                        * that layer group                        */
name|g_array_remove_index
argument_list|(
name|parent_group_stack
argument_list|,
name|parent_group_stack
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
argument_list|(
literal|1
argument_list|)
name|g_debug
argument_list|(
literal|"WARNING: Unmatched group layer start marker."
argument_list|)
expr_stmt|;
name|layer_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|empty
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Create blank layer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Create normal layer"
argument_list|)
expr_stmt|;
name|l_x
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
expr_stmt|;
name|l_y
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
expr_stmt|;
name|l_w
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|left
expr_stmt|;
name|l_h
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|top
expr_stmt|;
block|}
name|image_type
operator|=
name|get_gimp_image_type
argument_list|(
name|img_a
operator|->
name|base_type
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Layer type %d"
argument_list|,
name|image_type
argument_list|)
expr_stmt|;
name|layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|image_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|name
argument_list|,
name|l_w
argument_list|,
name|l_h
argument_list|,
name|image_type
argument_list|,
literal|100
argument_list|,
name|GIMP_LAYER_MODE_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer_id
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Set the layer name.  Note that we do this even for group-end                * markers, to avoid having the default group name collide with                * subsequent layers; the real group name is set by the group                * start marker.                */
name|gimp_item_set_name
argument_list|(
name|layer_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Set the layer properties (skip this for layer group end                * markers; we set their properties when processing the start                * marker.)                */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|!=
literal|3
condition|)
block|{
comment|/* Mode */
name|psd_to_gimp_blend_mode
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|blend_mode
argument_list|,
operator|&
name|mode_info
argument_list|)
expr_stmt|;
name|gimp_layer_set_mode
argument_list|(
name|layer_id
argument_list|,
name|mode_info
operator|.
name|mode
argument_list|)
expr_stmt|;
name|gimp_layer_set_blend_space
argument_list|(
name|layer_id
argument_list|,
name|mode_info
operator|.
name|blend_space
argument_list|)
expr_stmt|;
name|gimp_layer_set_composite_space
argument_list|(
name|layer_id
argument_list|,
name|mode_info
operator|.
name|composite_space
argument_list|)
expr_stmt|;
name|gimp_layer_set_composite_mode
argument_list|(
name|layer_id
argument_list|,
name|mode_info
operator|.
name|composite_mode
argument_list|)
expr_stmt|;
comment|/* Opacity */
name|gimp_layer_set_opacity
argument_list|(
name|layer_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|opacity
operator|*
literal|100.0
operator|/
literal|255.0
argument_list|)
expr_stmt|;
comment|/* Flags */
name|gimp_layer_set_lock_alpha
argument_list|(
name|layer_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|trans_prot
argument_list|)
expr_stmt|;
name|gimp_item_set_visible
argument_list|(
name|layer_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|visible
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_flags
operator|.
name|irrelevant
operator|&&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|0
condition|)
block|{
name|gimp_item_set_visible
argument_list|(
name|layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Position */
if|if
condition|(
name|l_x
operator|!=
literal|0
operator|||
name|l_y
operator|!=
literal|0
condition|)
name|gimp_layer_set_offsets
argument_list|(
name|layer_id
argument_list|,
name|l_x
argument_list|,
name|l_y
argument_list|)
expr_stmt|;
comment|/* Color tag */
name|gimp_item_set_color_tag
argument_list|(
name|layer_id
argument_list|,
name|psd_to_gimp_layer_color_tag
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|color_tag
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tattoo */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|id
condition|)
name|gimp_item_set_tattoo
argument_list|(
name|layer_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* For layer groups, expand or collapse the group */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|!=
literal|0
condition|)
block|{
name|gimp_item_set_expanded
argument_list|(
name|layer_id
argument_list|,
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert the layer */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|0
operator|||
comment|/* normal layer */
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|3
comment|/* group layer end marker */
condition|)
block|{
name|gimp_image_insert_layer
argument_list|(
name|image_id
argument_list|,
name|layer_id
argument_list|,
name|parent_group_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set the active layer */
if|if
condition|(
name|lidx
operator|==
name|img_a
operator|->
name|layer_state
condition|)
block|{
name|gimp_image_set_active_layer
argument_list|(
name|image_id
argument_list|,
name|layer_id
argument_list|)
expr_stmt|;
block|}
comment|/* Set the layer data */
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|0
condition|)
block|{
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Draw layer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
name|gimp_drawable_fill
argument_list|(
name|layer_id
argument_list|,
name|GIMP_FILL_TRANSPARENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|layer_size
operator|=
name|l_w
operator|*
name|l_h
expr_stmt|;
name|bps
operator|=
name|img_a
operator|->
name|bps
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|bps
operator|==
literal|0
condition|)
name|bps
operator|++
expr_stmt|;
name|pixels
operator|=
name|g_malloc
argument_list|(
name|layer_size
operator|*
name|layer_channels
operator|*
name|bps
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|layer_channels
condition|;
operator|++
name|cidx
control|)
block|{
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Start channel %d"
argument_list|,
name|channel_idx
index|[
name|cidx
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layer_size
condition|;
operator|++
name|i
control|)
name|memcpy
argument_list|(
operator|&
name|pixels
index|[
operator|(
operator|(
name|i
operator|*
name|layer_channels
operator|)
operator|+
name|cidx
operator|)
operator|*
name|bps
index|]
argument_list|,
operator|&
name|lyr_chn
index|[
name|channel_idx
index|[
name|cidx
index|]
index|]
operator|->
name|data
index|[
name|i
operator|*
name|bps
index|]
argument_list|,
name|bps
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lyr_chn
index|[
name|channel_idx
index|[
name|cidx
index|]
index|]
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|get_layer_format
argument_list|(
name|img_a
argument_list|,
name|alpha
argument_list|)
argument_list|,
name|pixels
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Layer mask */
if|if
condition|(
name|user_mask
operator|&&
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|group_type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|empty_mask
condition|)
block|{
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Create empty mask"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|def_color
operator|==
literal|255
condition|)
name|mask_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer_id
argument_list|,
name|GIMP_ADD_MASK_WHITE
argument_list|)
expr_stmt|;
else|else
name|mask_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer_id
argument_list|,
name|GIMP_ADD_MASK_BLACK
argument_list|)
expr_stmt|;
name|gimp_layer_add_mask
argument_list|(
name|layer_id
argument_list|,
name|mask_id
argument_list|)
expr_stmt|;
name|gimp_layer_set_apply_mask
argument_list|(
name|layer_id
argument_list|,
operator|!
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|disabled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Load layer mask data */
name|lm_x
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
operator|-
name|l_x
expr_stmt|;
name|lm_y
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
operator|-
name|l_y
expr_stmt|;
name|lm_w
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|right
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|left
expr_stmt|;
name|lm_h
operator|=
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|bottom
operator|-
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|top
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Mask channel index %d"
argument_list|,
name|user_mask_chn
argument_list|)
expr_stmt|;
name|bps
operator|=
operator|(
name|img_a
operator|->
name|bps
operator|+
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
name|layer_size
operator|=
name|lm_w
operator|*
name|lm_h
operator|*
name|bps
expr_stmt|;
name|pixels
operator|=
name|g_malloc
argument_list|(
name|layer_size
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Allocate Pixels %d"
argument_list|,
name|layer_size
argument_list|)
expr_stmt|;
comment|/* Crop mask at layer boundary */
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Original Mask %d %d %d %d"
argument_list|,
name|lm_x
argument_list|,
name|lm_y
argument_list|,
name|lm_w
argument_list|,
name|lm_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm_x
operator|<
literal|0
operator|||
name|lm_y
operator|<
literal|0
operator|||
name|lm_w
operator|+
name|lm_x
operator|>
name|l_w
operator|||
name|lm_h
operator|+
name|lm_y
operator|>
name|l_h
condition|)
block|{
if|if
condition|(
name|CONVERSION_WARNINGS
condition|)
name|g_message
argument_list|(
literal|"Warning\n"
literal|"The layer mask is partly outside the "
literal|"layer boundary. The mask will be "
literal|"cropped which may result in data loss."
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rowi
operator|=
literal|0
init|;
name|rowi
operator|<
name|lm_h
condition|;
operator|++
name|rowi
control|)
block|{
if|if
condition|(
name|rowi
operator|+
name|lm_y
operator|>=
literal|0
operator|&&
name|rowi
operator|+
name|lm_y
operator|<
name|l_h
condition|)
block|{
for|for
control|(
name|coli
operator|=
literal|0
init|;
name|coli
operator|<
name|lm_w
condition|;
operator|++
name|coli
control|)
block|{
if|if
condition|(
name|coli
operator|+
name|lm_x
operator|>=
literal|0
operator|&&
name|coli
operator|+
name|lm_x
operator|<
name|l_w
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pixels
index|[
name|i
operator|*
name|bps
index|]
argument_list|,
operator|&
name|lyr_chn
index|[
name|user_mask_chn
index|]
operator|->
name|data
index|[
operator|(
name|rowi
operator|*
name|lm_w
operator|+
name|coli
operator|)
operator|*
name|bps
index|]
argument_list|,
name|bps
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|lm_x
operator|<
literal|0
condition|)
block|{
name|lm_w
operator|+=
name|lm_x
expr_stmt|;
name|lm_x
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lm_y
operator|<
literal|0
condition|)
block|{
name|lm_h
operator|+=
name|lm_y
expr_stmt|;
name|lm_y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lm_w
operator|+
name|lm_x
operator|>
name|l_w
condition|)
name|lm_w
operator|=
name|l_w
operator|-
name|lm_x
expr_stmt|;
if|if
condition|(
name|lm_h
operator|+
name|lm_y
operator|>
name|l_h
condition|)
name|lm_h
operator|=
name|l_h
operator|-
name|lm_y
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|pixels
argument_list|,
name|lyr_chn
index|[
name|user_mask_chn
index|]
operator|->
name|data
argument_list|,
name|layer_size
argument_list|)
expr_stmt|;
name|i
operator|=
name|layer_size
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lyr_chn
index|[
name|user_mask_chn
index|]
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Draw layer mask data, if any */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Layer %d %d %d %d"
argument_list|,
name|l_x
argument_list|,
name|l_y
argument_list|,
name|l_w
argument_list|,
name|l_h
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Mask %d %d %d %d"
argument_list|,
name|lm_x
argument_list|,
name|lm_y
argument_list|,
name|lm_w
argument_list|,
name|lm_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|def_color
operator|==
literal|255
condition|)
name|mask_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer_id
argument_list|,
name|GIMP_ADD_MASK_WHITE
argument_list|)
expr_stmt|;
else|else
name|mask_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|layer_id
argument_list|,
name|GIMP_ADD_MASK_BLACK
argument_list|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"New layer mask %d"
argument_list|,
name|mask_id
argument_list|)
expr_stmt|;
name|gimp_layer_add_mask
argument_list|(
name|layer_id
argument_list|,
name|mask_id
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|mask_id
argument_list|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
name|lm_x
argument_list|,
name|lm_y
argument_list|,
name|lm_w
argument_list|,
name|lm_h
argument_list|)
argument_list|,
literal|0
argument_list|,
name|get_mask_format
argument_list|(
name|img_a
argument_list|)
argument_list|,
name|pixels
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gimp_layer_set_apply_mask
argument_list|(
name|layer_id
argument_list|,
operator|!
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|layer_mask
operator|.
name|mask_flags
operator|.
name|disabled
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|num_channels
condition|;
operator|++
name|cidx
control|)
if|if
condition|(
name|lyr_chn
index|[
name|cidx
index|]
condition|)
name|g_free
argument_list|(
name|lyr_chn
index|[
name|cidx
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lyr_chn
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|chn_info
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lyr_a
index|[
name|lidx
index|]
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|lyr_a
argument_list|)
expr_stmt|;
name|g_array_free
argument_list|(
name|parent_group_stack
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|add_merged_image (gint32 image_id,PSDimage * img_a,FILE * f,GError ** error)
name|add_merged_image
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|PSDchannel
name|chn_a
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|gchar
modifier|*
name|alpha_name
decl_stmt|;
name|guchar
modifier|*
name|pixels
decl_stmt|;
name|guint16
name|comp_mode
decl_stmt|;
name|guint16
name|base_channels
decl_stmt|;
name|guint16
name|extra_channels
decl_stmt|;
name|guint16
name|total_channels
decl_stmt|;
name|guint16
name|bps
decl_stmt|;
name|guint16
modifier|*
name|rle_pack_len
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
name|guint32
name|alpha_id
decl_stmt|;
name|gint32
name|layer_size
decl_stmt|;
name|gint32
name|layer_id
init|=
operator|-
literal|1
decl_stmt|;
name|gint32
name|channel_id
init|=
operator|-
literal|1
decl_stmt|;
name|gint16
name|alpha_opacity
decl_stmt|;
name|gint
name|cidx
decl_stmt|;
comment|/* Channel index */
name|gint
name|rowi
decl_stmt|;
comment|/* Row index */
name|gint
name|offset
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gboolean
name|alpha_visible
decl_stmt|;
name|GeglBuffer
modifier|*
name|buffer
decl_stmt|;
name|GimpImageType
name|image_type
decl_stmt|;
name|GimpRGB
name|alpha_rgb
decl_stmt|;
name|total_channels
operator|=
name|img_a
operator|->
name|channels
expr_stmt|;
name|extra_channels
operator|=
literal|0
expr_stmt|;
name|bps
operator|=
name|img_a
operator|->
name|bps
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|bps
operator|==
literal|0
condition|)
name|bps
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_BITMAP
operator|||
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_GRAYSCALE
operator|||
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_DUOTONE
operator|||
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_INDEXED
operator|)
operator|&&
name|total_channels
operator|>
literal|1
condition|)
block|{
name|extra_channels
operator|=
name|total_channels
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_RGB
operator|||
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_LAB
operator|)
operator|&&
name|total_channels
operator|>
literal|3
condition|)
block|{
name|extra_channels
operator|=
name|total_channels
operator|-
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|img_a
operator|->
name|color_mode
operator|==
name|PSD_CMYK
operator|)
operator|&&
name|total_channels
operator|>
literal|4
condition|)
block|{
name|extra_channels
operator|=
name|total_channels
operator|-
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|img_a
operator|->
name|transparency
operator|&&
name|extra_channels
operator|>
literal|0
condition|)
name|extra_channels
operator|--
expr_stmt|;
name|base_channels
operator|=
name|total_channels
operator|-
name|extra_channels
expr_stmt|;
comment|/* ----- Read merged image& extra channel pixel data ----- */
if|if
condition|(
name|img_a
operator|->
name|num_layers
operator|==
literal|0
operator|||
name|extra_channels
operator|>
literal|0
condition|)
block|{
name|guint32
name|block_len
decl_stmt|;
name|guint32
name|block_start
decl_stmt|;
name|block_start
operator|=
name|img_a
operator|->
name|merged_image_start
expr_stmt|;
name|block_len
operator|=
name|img_a
operator|->
name|merged_image_len
expr_stmt|;
name|fseek
argument_list|(
name|f
argument_list|,
name|block_start
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|comp_mode
argument_list|,
name|COMP_MODE_SIZE
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|comp_mode
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|comp_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_mode
condition|)
block|{
case|case
name|PSD_COMP_RAW
case|:
comment|/* Planar raw data */
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Raw data length: %d"
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|total_channels
condition|;
operator|++
name|cidx
control|)
block|{
name|chn_a
index|[
name|cidx
index|]
operator|.
name|columns
operator|=
name|img_a
operator|->
name|columns
expr_stmt|;
name|chn_a
index|[
name|cidx
index|]
operator|.
name|rows
operator|=
name|img_a
operator|->
name|rows
expr_stmt|;
if|if
condition|(
name|read_channel_data
argument_list|(
operator|&
name|chn_a
index|[
name|cidx
index|]
argument_list|,
name|img_a
operator|->
name|bps
argument_list|,
name|PSD_COMP_RAW
argument_list|,
name|NULL
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|PSD_COMP_RLE
case|:
comment|/* Packbits */
comment|/* Image data is stored as packed scanlines in planar order                with all compressed length counters stored first */
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"RLE length data: %d, RLE data block: %d"
argument_list|,
name|total_channels
operator|*
name|img_a
operator|->
name|rows
operator|*
literal|2
argument_list|,
name|block_len
operator|-
operator|(
name|total_channels
operator|*
name|img_a
operator|->
name|rows
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|total_channels
condition|;
operator|++
name|cidx
control|)
block|{
name|chn_a
index|[
name|cidx
index|]
operator|.
name|columns
operator|=
name|img_a
operator|->
name|columns
expr_stmt|;
name|chn_a
index|[
name|cidx
index|]
operator|.
name|rows
operator|=
name|img_a
operator|->
name|rows
expr_stmt|;
name|rle_pack_len
index|[
name|cidx
index|]
operator|=
name|g_malloc
argument_list|(
name|img_a
operator|->
name|rows
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|rowi
operator|=
literal|0
init|;
name|rowi
operator|<
name|img_a
operator|->
name|rows
condition|;
operator|++
name|rowi
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|rle_pack_len
index|[
name|cidx
index|]
index|[
name|rowi
index|]
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rle_pack_len
index|[
name|cidx
index|]
index|[
name|rowi
index|]
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|rle_pack_len
index|[
name|cidx
index|]
index|[
name|rowi
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"RLE decode - data"
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|total_channels
condition|;
operator|++
name|cidx
control|)
block|{
if|if
condition|(
name|read_channel_data
argument_list|(
operator|&
name|chn_a
index|[
name|cidx
index|]
argument_list|,
name|img_a
operator|->
name|bps
argument_list|,
name|PSD_COMP_RLE
argument_list|,
name|rle_pack_len
index|[
name|cidx
index|]
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|g_free
argument_list|(
name|rle_pack_len
index|[
name|cidx
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PSD_COMP_ZIP
case|:
comment|/* ? */
case|case
name|PSD_COMP_ZIP_PRED
case|:
default|default:
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported compression mode: %d"
argument_list|)
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
block|}
comment|/* ----- Draw merged image ----- */
if|if
condition|(
name|img_a
operator|->
name|num_layers
operator|==
literal|0
condition|)
comment|/* Merged image - Photoshop 2 style */
block|{
name|image_type
operator|=
name|get_gimp_image_type
argument_list|(
name|img_a
operator|->
name|base_type
argument_list|,
name|img_a
operator|->
name|transparency
argument_list|)
expr_stmt|;
name|layer_size
operator|=
name|img_a
operator|->
name|columns
operator|*
name|img_a
operator|->
name|rows
expr_stmt|;
name|pixels
operator|=
name|g_malloc
argument_list|(
name|layer_size
operator|*
name|base_channels
operator|*
name|bps
argument_list|)
expr_stmt|;
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|base_channels
condition|;
operator|++
name|cidx
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layer_size
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|pixels
index|[
operator|(
operator|(
name|i
operator|*
name|base_channels
operator|)
operator|+
name|cidx
operator|)
operator|*
name|bps
index|]
argument_list|,
operator|&
name|chn_a
index|[
name|cidx
index|]
operator|.
name|data
index|[
name|i
operator|*
name|bps
index|]
argument_list|,
name|bps
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|chn_a
index|[
name|cidx
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* Add background layer */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Draw merged image"
argument_list|)
expr_stmt|;
name|layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|image_id
argument_list|,
name|_
argument_list|(
literal|"Background"
argument_list|)
argument_list|,
name|img_a
operator|->
name|columns
argument_list|,
name|img_a
operator|->
name|rows
argument_list|,
name|image_type
argument_list|,
literal|100
argument_list|,
name|gimp_image_get_default_new_layer_mode
argument_list|(
name|image_id
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_insert_layer
argument_list|(
name|image_id
argument_list|,
name|layer_id
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|get_layer_format
argument_list|(
name|img_a
argument_list|,
name|img_a
operator|->
name|transparency
argument_list|)
argument_list|,
name|pixels
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Free merged image data for layered image */
if|if
condition|(
name|extra_channels
condition|)
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|base_channels
condition|;
operator|++
name|cidx
control|)
name|g_free
argument_list|(
name|chn_a
index|[
name|cidx
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* ----- Draw extra alpha channels ----- */
if|if
condition|(
operator|(
name|extra_channels
comment|/* Extra alpha channels */
operator|||
name|img_a
operator|->
name|transparency
operator|)
comment|/* Transparency alpha channel */
operator|&&
name|image_id
operator|>
operator|-
literal|1
condition|)
block|{
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Add extra channels"
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|g_malloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Get channel resource data */
if|if
condition|(
name|img_a
operator|->
name|transparency
condition|)
block|{
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* Free "Transparency" channel name */
if|if
condition|(
name|img_a
operator|->
name|alpha_names
condition|)
block|{
name|alpha_name
operator|=
name|g_ptr_array_index
argument_list|(
name|img_a
operator|->
name|alpha_names
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_name
condition|)
name|g_free
argument_list|(
name|alpha_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Draw channels */
name|IFDBG
argument_list|(
literal|2
argument_list|)
name|g_debug
argument_list|(
literal|"Number of channels: %d"
argument_list|,
name|extra_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_channels
condition|;
operator|++
name|i
control|)
block|{
comment|/* Alpha channel name */
name|alpha_name
operator|=
name|NULL
expr_stmt|;
name|alpha_visible
operator|=
name|FALSE
expr_stmt|;
comment|/* Quick mask channel*/
if|if
condition|(
name|img_a
operator|->
name|quick_mask_id
condition|)
if|if
condition|(
name|i
operator|==
name|img_a
operator|->
name|quick_mask_id
operator|-
name|base_channels
operator|+
name|offset
condition|)
block|{
comment|/* Free "Quick Mask" channel name */
name|alpha_name
operator|=
name|g_ptr_array_index
argument_list|(
name|img_a
operator|->
name|alpha_names
argument_list|,
name|i
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_name
condition|)
name|g_free
argument_list|(
name|alpha_name
argument_list|)
expr_stmt|;
name|alpha_name
operator|=
name|g_strdup
argument_list|(
name|GIMP_IMAGE_QUICK_MASK_NAME
argument_list|)
expr_stmt|;
name|alpha_visible
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|alpha_name
operator|&&
name|img_a
operator|->
name|alpha_names
condition|)
if|if
condition|(
name|offset
operator|<
name|img_a
operator|->
name|alpha_names
operator|->
name|len
operator|&&
name|i
operator|+
name|offset
operator|<=
name|img_a
operator|->
name|alpha_names
operator|->
name|len
condition|)
name|alpha_name
operator|=
name|g_ptr_array_index
argument_list|(
name|img_a
operator|->
name|alpha_names
argument_list|,
name|i
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alpha_name
condition|)
name|alpha_name
operator|=
name|g_strdup
argument_list|(
name|_
argument_list|(
literal|"Extra"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|img_a
operator|->
name|alpha_id_count
operator|&&
name|offset
operator|+
name|i
operator|<=
name|img_a
operator|->
name|alpha_id_count
condition|)
name|alpha_id
operator|=
name|img_a
operator|->
name|alpha_id
index|[
name|i
operator|+
name|offset
index|]
expr_stmt|;
else|else
name|alpha_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|img_a
operator|->
name|alpha_display_count
operator|&&
name|i
operator|+
name|offset
operator|<=
name|img_a
operator|->
name|alpha_display_count
condition|)
block|{
name|alpha_rgb
operator|=
name|img_a
operator|->
name|alpha_display_info
index|[
name|i
operator|+
name|offset
index|]
operator|->
name|gimp_color
expr_stmt|;
name|alpha_opacity
operator|=
name|img_a
operator|->
name|alpha_display_info
index|[
name|i
operator|+
name|offset
index|]
operator|->
name|opacity
expr_stmt|;
block|}
else|else
block|{
name|gimp_rgba_set
argument_list|(
operator|&
name|alpha_rgb
argument_list|,
literal|1.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|alpha_opacity
operator|=
literal|50
expr_stmt|;
block|}
name|cidx
operator|=
name|base_channels
operator|+
name|i
expr_stmt|;
name|pixels
operator|=
name|g_realloc
argument_list|(
name|pixels
argument_list|,
name|chn_a
index|[
name|cidx
index|]
operator|.
name|columns
operator|*
name|chn_a
index|[
name|cidx
index|]
operator|.
name|rows
operator|*
name|bps
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pixels
argument_list|,
name|chn_a
index|[
name|cidx
index|]
operator|.
name|data
argument_list|,
name|chn_a
index|[
name|cidx
index|]
operator|.
name|columns
operator|*
name|chn_a
index|[
name|cidx
index|]
operator|.
name|rows
operator|*
name|bps
argument_list|)
expr_stmt|;
name|channel_id
operator|=
name|gimp_channel_new
argument_list|(
name|image_id
argument_list|,
name|alpha_name
argument_list|,
name|chn_a
index|[
name|cidx
index|]
operator|.
name|columns
argument_list|,
name|chn_a
index|[
name|cidx
index|]
operator|.
name|rows
argument_list|,
name|alpha_opacity
argument_list|,
operator|&
name|alpha_rgb
argument_list|)
expr_stmt|;
name|gimp_image_insert_channel
argument_list|(
name|image_id
argument_list|,
name|channel_id
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|alpha_name
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|gimp_drawable_get_buffer
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_id
condition|)
name|gimp_item_set_tattoo
argument_list|(
name|channel_id
argument_list|,
name|alpha_id
argument_list|)
expr_stmt|;
name|gimp_item_set_visible
argument_list|(
name|channel_id
argument_list|,
name|alpha_visible
argument_list|)
expr_stmt|;
name|gegl_buffer_set
argument_list|(
name|buffer
argument_list|,
name|GEGL_RECTANGLE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|gegl_buffer_get_width
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|gegl_buffer_get_height
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|get_channel_format
argument_list|(
name|img_a
argument_list|)
argument_list|,
name|pixels
argument_list|,
name|GEGL_AUTO_ROWSTRIDE
argument_list|)
expr_stmt|;
name|g_object_unref
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|chn_a
index|[
name|cidx
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
if|if
condition|(
name|img_a
operator|->
name|alpha_names
condition|)
name|g_ptr_array_free
argument_list|(
name|img_a
operator|->
name|alpha_names
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|img_a
operator|->
name|alpha_id
condition|)
name|g_free
argument_list|(
name|img_a
operator|->
name|alpha_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|img_a
operator|->
name|alpha_display_info
condition|)
block|{
for|for
control|(
name|cidx
operator|=
literal|0
init|;
name|cidx
operator|<
name|img_a
operator|->
name|alpha_display_count
condition|;
operator|++
name|cidx
control|)
name|g_free
argument_list|(
name|img_a
operator|->
name|alpha_display_info
index|[
name|cidx
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|img_a
operator|->
name|alpha_display_info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FIXME gimp image tattoo state */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Local utility functions */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|get_psd_color_mode_name (PSDColorMode mode)
name|get_psd_color_mode_name
parameter_list|(
name|PSDColorMode
name|mode
parameter_list|)
block|{
specifier|static
name|gchar
modifier|*
specifier|const
name|psd_color_mode_names
index|[]
init|=
block|{
literal|"BITMAP"
block|,
literal|"GRAYSCALE"
block|,
literal|"INDEXED"
block|,
literal|"RGB"
block|,
literal|"CMYK"
block|,
literal|"UNKNOWN (5)"
block|,
literal|"UNKNOWN (6)"
block|,
literal|"MULTICHANNEL"
block|,
literal|"DUOTONE"
block|,
literal|"LAB"
block|}
decl_stmt|;
specifier|static
name|gchar
modifier|*
name|err_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mode
operator|>=
name|PSD_BITMAP
operator|&&
name|mode
operator|<=
name|PSD_LAB
condition|)
return|return
name|psd_color_mode_names
index|[
name|mode
index|]
return|;
name|g_free
argument_list|(
name|err_name
argument_list|)
expr_stmt|;
name|err_name
operator|=
name|g_strdup_printf
argument_list|(
literal|"UNKNOWN (%d)"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|err_name
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|psd_to_gimp_color_map (guchar * map256)
name|psd_to_gimp_color_map
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpmap
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|tmpmap
operator|=
name|g_malloc
argument_list|(
literal|3
operator|*
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|tmpmap
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|map256
index|[
name|i
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|256
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|512
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|map256
argument_list|,
name|tmpmap
argument_list|,
literal|3
operator|*
literal|256
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GimpImageType
DECL|function|get_gimp_image_type (GimpImageBaseType image_base_type,gboolean alpha)
name|get_gimp_image_type
parameter_list|(
name|GimpImageBaseType
name|image_base_type
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
block|{
name|GimpImageType
name|image_type
decl_stmt|;
switch|switch
condition|(
name|image_base_type
condition|)
block|{
case|case
name|GIMP_GRAY
case|:
name|image_type
operator|=
operator|(
name|alpha
operator|)
condition|?
name|GIMP_GRAYA_IMAGE
else|:
name|GIMP_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
name|GIMP_INDEXED
case|:
name|image_type
operator|=
operator|(
name|alpha
operator|)
condition|?
name|GIMP_INDEXEDA_IMAGE
else|:
name|GIMP_INDEXED_IMAGE
expr_stmt|;
break|break;
case|case
name|GIMP_RGB
case|:
name|image_type
operator|=
operator|(
name|alpha
operator|)
condition|?
name|GIMP_RGBA_IMAGE
else|:
name|GIMP_RGB_IMAGE
expr_stmt|;
break|break;
default|default:
name|image_type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|image_type
return|;
block|}
end_function

begin_function
specifier|static
name|voidpf
DECL|function|zzalloc (voidpf opaque,uInt items,uInt size)
name|zzalloc
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|uInt
name|items
parameter_list|,
name|uInt
name|size
parameter_list|)
block|{
comment|/* overflow check missing */
return|return
name|g_malloc
argument_list|(
name|items
operator|*
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|zzfree (voidpf opaque,voidpf address)
name|zzfree
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|voidpf
name|address
parameter_list|)
block|{
name|g_free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|read_channel_data (PSDchannel * channel,guint16 bps,guint16 compression,const guint16 * rle_pack_len,FILE * f,guint32 comp_len,GError ** error)
name|read_channel_data
parameter_list|(
name|PSDchannel
modifier|*
name|channel
parameter_list|,
name|guint16
name|bps
parameter_list|,
name|guint16
name|compression
parameter_list|,
specifier|const
name|guint16
modifier|*
name|rle_pack_len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|guint32
name|comp_len
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gchar
modifier|*
name|raw_data
decl_stmt|;
name|gchar
modifier|*
name|src
decl_stmt|;
name|gchar
modifier|*
name|dst
decl_stmt|;
name|guint32
name|readline_len
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|bps
operator|==
literal|1
condition|)
name|readline_len
operator|=
operator|(
operator|(
name|channel
operator|->
name|columns
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
else|else
name|readline_len
operator|=
operator|(
name|channel
operator|->
name|columns
operator|*
name|bps
operator|/
literal|8
operator|)
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"raw data size %d x %d = %d"
argument_list|,
name|readline_len
argument_list|,
name|channel
operator|->
name|rows
argument_list|,
name|readline_len
operator|*
name|channel
operator|->
name|rows
argument_list|)
expr_stmt|;
comment|/* sanity check, int overflow check (avoid divisions by zero) */
if|if
condition|(
operator|(
name|channel
operator|->
name|rows
operator|==
literal|0
operator|)
operator|||
operator|(
name|channel
operator|->
name|columns
operator|==
literal|0
operator|)
operator|||
operator|(
name|channel
operator|->
name|rows
operator|>
name|G_MAXINT32
operator|/
name|channel
operator|->
name|columns
operator|/
name|MAX
argument_list|(
name|bps
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Unsupported or invalid channel size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|raw_data
operator|=
name|g_malloc
argument_list|(
name|readline_len
operator|*
name|channel
operator|->
name|rows
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|compression
condition|)
block|{
case|case
name|PSD_COMP_RAW
case|:
if|if
condition|(
name|fread
argument_list|(
name|raw_data
argument_list|,
name|readline_len
argument_list|,
name|channel
operator|->
name|rows
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|PSD_COMP_RLE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel
operator|->
name|rows
condition|;
operator|++
name|i
control|)
block|{
name|src
operator|=
name|g_malloc
argument_list|(
name|rle_pack_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dst
operator|=
name|g_malloc
argument_list|(
name|readline_len
argument_list|)
expr_stmt|;
comment|/*      FIXME check for over-run             if (ftell (f) + rle_pack_len[i]> block_end)               {                 psd_set_error (TRUE, errno, error);                 return -1;               } */
if|if
condition|(
name|fread
argument_list|(
name|src
argument_list|,
name|rle_pack_len
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* FIXME check for errors returned from decode packbits */
name|decode_packbits
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|rle_pack_len
index|[
name|i
index|]
argument_list|,
name|readline_len
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw_data
operator|+
name|i
operator|*
name|readline_len
argument_list|,
name|dst
argument_list|,
name|readline_len
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PSD_COMP_ZIP
case|:
case|case
name|PSD_COMP_ZIP_PRED
case|:
block|{
name|z_stream
name|zs
decl_stmt|;
name|src
operator|=
name|g_malloc
argument_list|(
name|comp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|src
argument_list|,
name|comp_len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
name|psd_set_error
argument_list|(
name|feof
argument_list|(
name|f
argument_list|)
argument_list|,
name|errno
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|zs
operator|.
name|next_in
operator|=
operator|(
name|guchar
operator|*
operator|)
name|src
expr_stmt|;
name|zs
operator|.
name|avail_in
operator|=
name|comp_len
expr_stmt|;
name|zs
operator|.
name|next_out
operator|=
operator|(
name|guchar
operator|*
operator|)
name|raw_data
expr_stmt|;
name|zs
operator|.
name|avail_out
operator|=
name|readline_len
operator|*
name|channel
operator|->
name|rows
expr_stmt|;
name|zs
operator|.
name|zalloc
operator|=
name|zzalloc
expr_stmt|;
name|zs
operator|.
name|zfree
operator|=
name|zzfree
expr_stmt|;
if|if
condition|(
name|inflateInit
argument_list|(
operator|&
name|zs
argument_list|)
operator|==
name|Z_OK
operator|&&
name|inflate
argument_list|(
operator|&
name|zs
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_STREAM_END
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Failed to decompress data"
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|g_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Convert channel data to GIMP format */
switch|switch
condition|(
name|bps
condition|)
block|{
case|case
literal|32
case|:
block|{
name|guint32
modifier|*
name|src
init|=
operator|(
name|guint32
operator|*
operator|)
name|raw_data
decl_stmt|;
name|guint32
modifier|*
name|dst
init|=
name|g_malloc
argument_list|(
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
operator|*
literal|4
argument_list|)
decl_stmt|;
name|channel
operator|->
name|data
operator|=
operator|(
name|gchar
operator|*
operator|)
name|dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
condition|;
operator|++
name|i
control|)
name|dst
index|[
name|i
index|]
operator|=
name|GUINT32_FROM_BE
argument_list|(
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression
operator|==
name|PSD_COMP_ZIP_PRED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel
operator|->
name|rows
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|channel
operator|->
name|columns
condition|;
operator|++
name|j
control|)
name|dst
index|[
name|i
operator|*
name|channel
operator|->
name|columns
operator|+
name|j
index|]
operator|+=
name|dst
index|[
name|i
operator|*
name|channel
operator|->
name|columns
operator|+
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|16
case|:
block|{
name|guint16
modifier|*
name|src
init|=
operator|(
name|guint16
operator|*
operator|)
name|raw_data
decl_stmt|;
name|guint16
modifier|*
name|dst
init|=
name|g_malloc
argument_list|(
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
operator|*
literal|2
argument_list|)
decl_stmt|;
name|channel
operator|->
name|data
operator|=
operator|(
name|gchar
operator|*
operator|)
name|dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
condition|;
operator|++
name|i
control|)
name|dst
index|[
name|i
index|]
operator|=
name|GUINT16_FROM_BE
argument_list|(
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression
operator|==
name|PSD_COMP_ZIP_PRED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel
operator|->
name|rows
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|channel
operator|->
name|columns
condition|;
operator|++
name|j
control|)
name|dst
index|[
name|i
operator|*
name|channel
operator|->
name|columns
operator|+
name|j
index|]
operator|+=
name|dst
index|[
name|i
operator|*
name|channel
operator|->
name|columns
operator|+
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|8
case|:
name|channel
operator|->
name|data
operator|=
name|g_malloc
argument_list|(
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
operator|*
name|bps
operator|/
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|channel
operator|->
name|data
argument_list|,
name|raw_data
argument_list|,
operator|(
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
operator|*
name|bps
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression
operator|==
name|PSD_COMP_ZIP_PRED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channel
operator|->
name|rows
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|channel
operator|->
name|columns
condition|;
operator|++
name|j
control|)
name|channel
operator|->
name|data
index|[
name|i
operator|*
name|channel
operator|->
name|columns
operator|+
name|j
index|]
operator|+=
name|channel
operator|->
name|data
index|[
name|i
operator|*
name|channel
operator|->
name|columns
operator|+
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|channel
operator|->
name|data
operator|=
operator|(
name|gchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|channel
operator|->
name|rows
operator|*
name|channel
operator|->
name|columns
argument_list|)
expr_stmt|;
name|convert_1_bit
argument_list|(
name|raw_data
argument_list|,
name|channel
operator|->
name|data
argument_list|,
name|channel
operator|->
name|rows
argument_list|,
name|channel
operator|->
name|columns
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
break|break;
block|}
name|g_free
argument_list|(
name|raw_data
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|convert_1_bit (const gchar * src,gchar * dst,guint32 rows,guint32 columns)
name|convert_1_bit
parameter_list|(
specifier|const
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|guint32
name|rows
parameter_list|,
name|guint32
name|columns
parameter_list|)
block|{
comment|/* Convert bits to bytes left to right by row.    Rows are padded out to a byte boundary. */
name|guint32
name|row_pos
init|=
literal|0
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"Start 1 bit conversion"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rows
operator|*
operator|(
operator|(
name|columns
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|guchar
name|mask
init|=
literal|0x80
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
operator|&&
name|row_pos
operator|<
name|columns
condition|;
operator|++
name|j
control|)
block|{
operator|*
name|dst
operator|=
operator|(
operator|*
name|src
operator|&
name|mask
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"byte %d, bit %d, offset %d, src %d, dst %d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|row_pos
argument_list|,
operator|*
name|src
argument_list|,
operator|*
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
name|row_pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|row_pos
operator|>=
name|columns
condition|)
name|row_pos
operator|=
literal|0
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
name|IFDBG
argument_list|(
literal|3
argument_list|)
name|g_debug
argument_list|(
literal|"End 1 bit conversion"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Babl
modifier|*
DECL|function|get_layer_format (PSDimage * img_a,gboolean alpha)
name|get_layer_format
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|,
name|gboolean
name|alpha
parameter_list|)
block|{
specifier|const
name|Babl
modifier|*
name|format
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|get_gimp_image_type
argument_list|(
name|img_a
operator|->
name|base_type
argument_list|,
name|alpha
argument_list|)
condition|)
block|{
case|case
name|GIMP_GRAY_IMAGE
case|:
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y' u32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y' u16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y' u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
break|break;
case|case
name|GIMP_GRAYA_IMAGE
case|:
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y'A u32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y'A u16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y'A u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
break|break;
case|case
name|GIMP_RGB_IMAGE
case|:
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B' u32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B' u16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B' u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
break|break;
case|case
name|GIMP_RGBA_IMAGE
case|:
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A u32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A u16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"R'G'B'A u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
return|return
name|format
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Babl
modifier|*
DECL|function|get_channel_format (PSDimage * img_a)
name|get_channel_format
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|)
block|{
specifier|const
name|Babl
modifier|*
name|format
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y u32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y u16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|format
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Babl
modifier|*
DECL|function|get_mask_format (PSDimage * img_a)
name|get_mask_format
parameter_list|(
name|PSDimage
modifier|*
name|img_a
parameter_list|)
block|{
specifier|const
name|Babl
modifier|*
name|format
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|img_a
operator|->
name|bps
condition|)
block|{
case|case
literal|32
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y u32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y u16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|1
case|:
name|format
operator|=
name|babl_format
argument_list|(
literal|"Y u8"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|format
return|;
block|}
end_function

end_unit

