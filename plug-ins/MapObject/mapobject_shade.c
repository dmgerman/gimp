begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Shading stuff */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_include
include|#
directive|include
file|"mapobject_shade.h"
end_include

begin_decl_stmt
DECL|variable|bx1
DECL|variable|by1
DECL|variable|bx2
DECL|variable|by2
name|gdouble
name|bx1
decl_stmt|,
name|by1
decl_stmt|,
name|bx2
decl_stmt|,
name|by2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|get_ray_color
name|get_ray_color_func
name|get_ray_color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Phong shading */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_function
DECL|function|phong_shade (GckVector3 * pos,GckVector3 * viewpoint,GckVector3 * normal,GckVector3 * light,GckRGB * diff_col,GckRGB * spec_col,gint type)
name|GckRGB
name|phong_shade
parameter_list|(
name|GckVector3
modifier|*
name|pos
parameter_list|,
name|GckVector3
modifier|*
name|viewpoint
parameter_list|,
name|GckVector3
modifier|*
name|normal
parameter_list|,
name|GckVector3
modifier|*
name|light
parameter_list|,
name|GckRGB
modifier|*
name|diff_col
parameter_list|,
name|GckRGB
modifier|*
name|spec_col
parameter_list|,
name|gint
name|type
parameter_list|)
block|{
name|GckRGB
name|ambientcolor
decl_stmt|,
name|diffusecolor
decl_stmt|,
name|specularcolor
decl_stmt|;
name|gdouble
name|NL
decl_stmt|,
name|RV
decl_stmt|,
name|dist
decl_stmt|;
name|GckVector3
name|L
decl_stmt|,
name|NN
decl_stmt|,
name|V
decl_stmt|,
name|N
decl_stmt|;
comment|/* Compute ambient intensity */
comment|/* ========================= */
name|N
operator|=
operator|*
name|normal
expr_stmt|;
name|ambientcolor
operator|=
operator|*
name|diff_col
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|ambientcolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
comment|/* Compute (N*L) term of Phong's equation */
comment|/* ====================================== */
if|if
condition|(
name|type
operator|==
name|POINT_LIGHT
condition|)
name|gck_vector3_sub
argument_list|(
operator|&
name|L
argument_list|,
name|light
argument_list|,
name|pos
argument_list|)
expr_stmt|;
else|else
name|L
operator|=
operator|*
name|light
expr_stmt|;
name|dist
operator|=
name|gck_vector3_length
argument_list|(
operator|&
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|!=
literal|0.0
condition|)
name|gck_vector3_mul
argument_list|(
operator|&
name|L
argument_list|,
literal|1.0
operator|/
name|dist
argument_list|)
expr_stmt|;
name|NL
operator|=
literal|2.0
operator|*
name|gck_vector3_inner_product
argument_list|(
operator|&
name|N
argument_list|,
operator|&
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|NL
operator|>=
literal|0.0
condition|)
block|{
comment|/* Compute (R*V)^alpha term of Phong's equation */
comment|/* ============================================ */
name|gck_vector3_sub
argument_list|(
operator|&
name|V
argument_list|,
name|viewpoint
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|V
argument_list|)
expr_stmt|;
name|gck_vector3_mul
argument_list|(
operator|&
name|N
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|gck_vector3_sub
argument_list|(
operator|&
name|NN
argument_list|,
operator|&
name|N
argument_list|,
operator|&
name|L
argument_list|)
expr_stmt|;
name|RV
operator|=
name|gck_vector3_inner_product
argument_list|(
operator|&
name|NN
argument_list|,
operator|&
name|V
argument_list|)
expr_stmt|;
name|RV
operator|=
name|pow
argument_list|(
name|RV
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|highlight
argument_list|)
expr_stmt|;
comment|/* Compute diffuse and specular intensity contribution */
comment|/* =================================================== */
name|diffusecolor
operator|=
operator|*
name|diff_col
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|diffusecolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_ref
argument_list|)
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|diffusecolor
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|specularcolor
operator|=
operator|*
name|spec_col
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|specularcolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|specular_ref
argument_list|)
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|specularcolor
argument_list|,
name|RV
argument_list|)
expr_stmt|;
name|gck_rgb_add
argument_list|(
operator|&
name|diffusecolor
argument_list|,
operator|&
name|specularcolor
argument_list|)
expr_stmt|;
name|gck_rgb_mul
argument_list|(
operator|&
name|diffusecolor
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
argument_list|)
expr_stmt|;
name|gck_rgb_clamp
argument_list|(
operator|&
name|diffusecolor
argument_list|)
expr_stmt|;
name|gck_rgb_add
argument_list|(
operator|&
name|ambientcolor
argument_list|,
operator|&
name|diffusecolor
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ambientcolor
operator|)
return|;
block|}
end_function

begin_function
DECL|function|plane_intersect (GckVector3 * dir,GckVector3 * viewp,GckVector3 * ipos,gdouble * u,gdouble * v)
name|gint
name|plane_intersect
parameter_list|(
name|GckVector3
modifier|*
name|dir
parameter_list|,
name|GckVector3
modifier|*
name|viewp
parameter_list|,
name|GckVector3
modifier|*
name|ipos
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
specifier|static
name|gdouble
name|det
decl_stmt|,
name|det1
decl_stmt|,
name|det2
decl_stmt|,
name|det3
decl_stmt|,
name|t
decl_stmt|;
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|x
expr_stmt|;
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|y
expr_stmt|;
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|z
expr_stmt|;
comment|/* Compute determinant of the first 3x3 sub matrix (denominator) */
comment|/* ============================================================= */
name|det
operator|=
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* If the determinant is non-zero, a intersection point exists */
comment|/* =========================================================== */
if|if
condition|(
name|det
operator|!=
literal|0.0
condition|)
block|{
comment|/* Now, lets compute the numerator determinants (wow ;) */
comment|/* ==================================================== */
name|det1
operator|=
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|-
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|det2
operator|=
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|det3
operator|=
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|imat
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|-
name|imat
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|*
name|imat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|imat
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* Now we have the simultanous solutions. Lets compute the unknowns */
comment|/* (skip u&v if t is<0, this means the intersection is behind us)  */
comment|/* ================================================================ */
name|t
operator|=
name|det1
operator|/
name|det
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0.0
condition|)
block|{
operator|*
name|u
operator|=
literal|1.0
operator|+
operator|(
operator|(
name|det2
operator|/
name|det
operator|)
operator|-
literal|0.5
operator|)
expr_stmt|;
operator|*
name|v
operator|=
literal|1.0
operator|+
operator|(
operator|(
name|det3
operator|/
name|det
operator|)
operator|-
literal|0.5
operator|)
expr_stmt|;
name|ipos
operator|->
name|x
operator|=
name|viewp
operator|->
name|x
operator|+
name|t
operator|*
name|dir
operator|->
name|x
expr_stmt|;
name|ipos
operator|->
name|y
operator|=
name|viewp
operator|->
name|y
operator|+
name|t
operator|*
name|dir
operator|->
name|y
expr_stmt|;
name|ipos
operator|->
name|z
operator|=
name|viewp
operator|->
name|z
operator|+
name|t
operator|*
name|dir
operator|->
name|z
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************************/
end_comment

begin_comment
comment|/* These routines computes the color of the surface of the plane at a given point */
end_comment

begin_comment
comment|/**********************************************************************************/
end_comment

begin_function
DECL|function|get_ray_color_plane (GckVector3 * pos)
name|GckRGB
name|get_ray_color_plane
parameter_list|(
name|GckVector3
modifier|*
name|pos
parameter_list|)
block|{
name|GckRGB
name|color
init|=
name|background
decl_stmt|;
specifier|static
name|gint
name|inside
init|=
name|FALSE
decl_stmt|;
specifier|static
name|GckVector3
name|ray
decl_stmt|,
name|spos
decl_stmt|;
specifier|static
name|gdouble
name|vx
decl_stmt|,
name|vy
decl_stmt|;
comment|/* Construct a line from our VP to the point */
comment|/* ========================================= */
name|gck_vector3_sub
argument_list|(
operator|&
name|ray
argument_list|,
name|pos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|ray
argument_list|)
expr_stmt|;
comment|/* Check for intersection. This is a quasi ray-tracer. */
comment|/* =================================================== */
if|if
condition|(
name|plane_intersect
argument_list|(
operator|&
name|ray
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|spos
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|color
operator|=
name|get_image_color
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
operator|.
name|a
operator|!=
literal|0.0
operator|&&
name|inside
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|!=
name|NO_LIGHT
condition|)
block|{
comment|/* Compute shading at this point */
comment|/* ============================= */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|spos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|normal
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gck_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|color
operator|.
name|a
operator|==
literal|0.0
condition|)
name|color
operator|=
name|background
expr_stmt|;
return|return
operator|(
name|color
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Given the NorthPole, Equator and a third vector (normal) compute    */
end_comment

begin_comment
comment|/* the conversion from spherical oordinates to image space coordinates */
end_comment

begin_comment
comment|/***********************************************************************/
end_comment

begin_function
DECL|function|sphere_to_image (GckVector3 * normal,gdouble * u,gdouble * v)
name|void
name|sphere_to_image
parameter_list|(
name|GckVector3
modifier|*
name|normal
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
specifier|static
name|gdouble
name|alpha
decl_stmt|,
name|fac
decl_stmt|;
specifier|static
name|GckVector3
name|cross_prod
decl_stmt|;
name|alpha
operator|=
name|acos
argument_list|(
operator|-
name|gck_vector3_inner_product
argument_list|(
operator|&
name|mapvals
operator|.
name|secondaxis
argument_list|,
name|normal
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|alpha
operator|/
name|M_PI
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0.0
operator|||
operator|*
name|v
operator|==
literal|1.0
condition|)
operator|*
name|u
operator|=
literal|0.0
expr_stmt|;
else|else
block|{
name|fac
operator|=
name|gck_vector3_inner_product
argument_list|(
operator|&
name|mapvals
operator|.
name|firstaxis
argument_list|,
name|normal
argument_list|)
operator|/
name|sin
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
comment|/* Make sure that we map to -1.0..1.0 (take care of rounding errors) */
comment|/* ================================================================= */
if|if
condition|(
name|fac
operator|>
literal|1.0
condition|)
name|fac
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|fac
operator|<
operator|-
literal|1.0
condition|)
name|fac
operator|=
operator|-
literal|1.0
expr_stmt|;
operator|*
name|u
operator|=
name|acos
argument_list|(
name|fac
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|M_PI
operator|)
expr_stmt|;
name|cross_prod
operator|=
name|gck_vector3_cross_product
argument_list|(
operator|&
name|mapvals
operator|.
name|secondaxis
argument_list|,
operator|&
name|mapvals
operator|.
name|firstaxis
argument_list|)
expr_stmt|;
if|if
condition|(
name|gck_vector3_inner_product
argument_list|(
operator|&
name|cross_prod
argument_list|,
name|normal
argument_list|)
operator|<
literal|0.0
condition|)
operator|*
name|u
operator|=
literal|1.0
operator|-
operator|*
name|u
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/* Compute intersection point with sphere (if any) */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
DECL|function|sphere_intersect (GckVector3 * dir,GckVector3 * viewp,GckVector3 * spos1,GckVector3 * spos2)
name|gint
name|sphere_intersect
parameter_list|(
name|GckVector3
modifier|*
name|dir
parameter_list|,
name|GckVector3
modifier|*
name|viewp
parameter_list|,
name|GckVector3
modifier|*
name|spos1
parameter_list|,
name|GckVector3
modifier|*
name|spos2
parameter_list|)
block|{
specifier|static
name|gdouble
name|alpha
decl_stmt|,
name|beta
decl_stmt|,
name|tau
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|GckVector3
name|t
decl_stmt|;
name|gck_vector3_sub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|mapvals
operator|.
name|position
argument_list|,
name|viewp
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|gck_vector3_inner_product
argument_list|(
name|dir
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|beta
operator|=
name|gck_vector3_inner_product
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|tau
operator|=
name|alpha
operator|*
name|alpha
operator|-
name|beta
operator|+
name|mapvals
operator|.
name|radius
operator|*
name|mapvals
operator|.
name|radius
expr_stmt|;
if|if
condition|(
name|tau
operator|>=
literal|0.0
condition|)
block|{
name|tau
operator|=
name|sqrt
argument_list|(
name|tau
argument_list|)
expr_stmt|;
name|s1
operator|=
name|alpha
operator|+
name|tau
expr_stmt|;
name|s2
operator|=
name|alpha
operator|-
name|tau
expr_stmt|;
if|if
condition|(
name|s2
operator|<
name|s1
condition|)
block|{
name|tmp
operator|=
name|s1
expr_stmt|;
name|s1
operator|=
name|s2
expr_stmt|;
name|s2
operator|=
name|tmp
expr_stmt|;
block|}
name|spos1
operator|->
name|x
operator|=
name|viewp
operator|->
name|x
operator|+
name|s1
operator|*
name|dir
operator|->
name|x
expr_stmt|;
name|spos1
operator|->
name|y
operator|=
name|viewp
operator|->
name|y
operator|+
name|s1
operator|*
name|dir
operator|->
name|y
expr_stmt|;
name|spos1
operator|->
name|z
operator|=
name|viewp
operator|->
name|z
operator|+
name|s1
operator|*
name|dir
operator|->
name|z
expr_stmt|;
name|spos2
operator|->
name|x
operator|=
name|viewp
operator|->
name|x
operator|+
name|s2
operator|*
name|dir
operator|->
name|x
expr_stmt|;
name|spos2
operator|->
name|y
operator|=
name|viewp
operator|->
name|y
operator|+
name|s2
operator|*
name|dir
operator|->
name|y
expr_stmt|;
name|spos2
operator|->
name|z
operator|=
name|viewp
operator|->
name|z
operator|+
name|s2
operator|*
name|dir
operator|->
name|z
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************************/
end_comment

begin_comment
comment|/* These routines computes the color of the surface of the sphere at a given point */
end_comment

begin_comment
comment|/***********************************************************************************/
end_comment

begin_function
DECL|function|get_ray_color_sphere (GckVector3 * pos)
name|GckRGB
name|get_ray_color_sphere
parameter_list|(
name|GckVector3
modifier|*
name|pos
parameter_list|)
block|{
name|GckRGB
name|color
init|=
name|background
decl_stmt|;
specifier|static
name|gint
name|inside
init|=
name|FALSE
decl_stmt|;
specifier|static
name|GckVector3
name|normal
decl_stmt|,
name|ray
decl_stmt|,
name|spos
decl_stmt|,
name|spos1
decl_stmt|,
name|spos2
decl_stmt|;
specifier|static
name|gdouble
name|vx
decl_stmt|,
name|vy
decl_stmt|;
comment|/* Check if ray is within the bounding box */
comment|/* ======================================= */
if|if
condition|(
name|pos
operator|->
name|x
operator|<
name|bx1
operator|||
name|pos
operator|->
name|x
operator|>
name|bx2
operator|||
name|pos
operator|->
name|y
operator|<
name|by1
operator|||
name|pos
operator|->
name|y
operator|>
name|by2
condition|)
return|return
operator|(
name|color
operator|)
return|;
comment|/* Construct a line from our VP to the point */
comment|/* ========================================= */
name|gck_vector3_sub
argument_list|(
operator|&
name|ray
argument_list|,
name|pos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|ray
argument_list|)
expr_stmt|;
comment|/* Check for intersection. This is a quasi ray-tracer. */
comment|/* =================================================== */
if|if
condition|(
name|sphere_intersect
argument_list|(
operator|&
name|ray
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|spos1
argument_list|,
operator|&
name|spos2
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|gck_vector3_sub
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|spos1
argument_list|,
operator|&
name|mapvals
operator|.
name|position
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|sphere_to_image
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
expr_stmt|;
name|color
operator|=
name|get_image_color
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
comment|/* Check for total transparency... */
comment|/* =============================== */
if|if
condition|(
name|color
operator|.
name|a
operator|==
literal|0.0
condition|)
block|{
comment|/* Hey, we can see right through here! */
comment|/* Lets see what's on the other side.. */
comment|/* =================================== */
name|gck_vector3_sub
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|spos2
argument_list|,
operator|&
name|mapvals
operator|.
name|position
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|sphere_to_image
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|vx
argument_list|,
operator|&
name|vy
argument_list|)
expr_stmt|;
name|color
operator|=
name|get_image_color
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|,
operator|&
name|inside
argument_list|)
expr_stmt|;
comment|/* Make the normal point inwards */
comment|/* ============================= */
name|gck_vector3_mul
argument_list|(
operator|&
name|normal
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|spos
operator|=
name|spos2
expr_stmt|;
block|}
else|else
name|spos
operator|=
name|spos1
expr_stmt|;
if|if
condition|(
name|color
operator|.
name|a
operator|!=
literal|0.0
operator|&&
name|inside
operator|==
name|TRUE
operator|&&
name|mapvals
operator|.
name|lightsource
operator|.
name|type
operator|!=
name|NO_LIGHT
condition|)
block|{
comment|/* Compute shading at this point */
comment|/* ============================= */
name|color
operator|=
name|phong_shade
argument_list|(
operator|&
name|spos
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|position
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|mapvals
operator|.
name|lightsource
operator|.
name|color
argument_list|,
name|mapvals
operator|.
name|lightsource
operator|.
name|type
argument_list|)
expr_stmt|;
name|gck_rgb_clamp
argument_list|(
operator|&
name|color
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|color
operator|.
name|a
operator|==
literal|0.0
condition|)
name|color
operator|=
name|background
expr_stmt|;
return|return
operator|(
name|color
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/* Transform the corners of the bounding box to 2D */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
DECL|function|compute_bounding_box (void)
name|void
name|compute_bounding_box
parameter_list|(
name|void
parameter_list|)
block|{
name|GckVector3
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|gdouble
name|t
decl_stmt|;
name|GckVector3
name|dir
decl_stmt|;
name|p1
operator|=
name|mapvals
operator|.
name|position
expr_stmt|;
name|p1
operator|.
name|x
operator|-=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|p1
operator|.
name|y
operator|-=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|p2
operator|=
name|mapvals
operator|.
name|position
expr_stmt|;
name|p2
operator|.
name|x
operator|+=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|p2
operator|.
name|y
operator|+=
operator|(
name|mapvals
operator|.
name|radius
operator|+
literal|0.01
operator|)
expr_stmt|;
name|gck_vector3_sub
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|z
operator|!=
literal|0.0
condition|)
block|{
name|t
operator|=
operator|(
operator|-
literal|1.0
operator|*
name|mapvals
operator|.
name|viewpoint
operator|.
name|z
operator|)
operator|/
name|dir
operator|.
name|z
expr_stmt|;
name|p1
operator|.
name|x
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|x
operator|+
name|t
operator|*
name|dir
operator|.
name|x
operator|)
expr_stmt|;
name|p1
operator|.
name|y
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|y
operator|+
name|t
operator|*
name|dir
operator|.
name|y
operator|)
expr_stmt|;
block|}
name|gck_vector3_sub
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|p2
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|)
expr_stmt|;
name|gck_vector3_normalize
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|z
operator|!=
literal|0.0
condition|)
block|{
name|t
operator|=
operator|(
operator|-
literal|1.0
operator|*
name|mapvals
operator|.
name|viewpoint
operator|.
name|z
operator|)
operator|/
name|dir
operator|.
name|z
expr_stmt|;
name|p2
operator|.
name|x
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|x
operator|+
name|t
operator|*
name|dir
operator|.
name|x
operator|)
expr_stmt|;
name|p2
operator|.
name|y
operator|=
operator|(
name|mapvals
operator|.
name|viewpoint
operator|.
name|y
operator|+
name|t
operator|*
name|dir
operator|.
name|y
operator|)
expr_stmt|;
block|}
name|bx1
operator|=
name|p1
operator|.
name|x
expr_stmt|;
name|by1
operator|=
name|p1
operator|.
name|y
expr_stmt|;
name|bx2
operator|=
name|p2
operator|.
name|x
expr_stmt|;
name|by2
operator|=
name|p2
operator|.
name|y
expr_stmt|;
block|}
end_function

end_unit

