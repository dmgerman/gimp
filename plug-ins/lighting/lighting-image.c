begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/* GIMP image manipulation routines. */
end_comment

begin_comment
comment|/*************************************/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"lighting-main.h"
end_include

begin_include
include|#
directive|include
file|"lighting-image.h"
end_include

begin_include
include|#
directive|include
file|"lighting-preview.h"
end_include

begin_include
include|#
directive|include
file|"lighting-ui.h"
end_include

begin_decl_stmt
DECL|variable|input_drawable
DECL|variable|output_drawable
name|GimpDrawable
modifier|*
name|input_drawable
decl_stmt|,
modifier|*
name|output_drawable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|source_region
DECL|variable|dest_region
name|GimpPixelRgn
name|source_region
decl_stmt|,
name|dest_region
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bump_drawable
name|GimpDrawable
modifier|*
name|bump_drawable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bump_region
name|GimpPixelRgn
name|bump_region
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|env_drawable
name|GimpDrawable
modifier|*
name|env_drawable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|env_region
name|GimpPixelRgn
name|env_region
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|preview_rgb_data
name|guchar
modifier|*
name|preview_rgb_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|preview_rgb_stride
name|gint
name|preview_rgb_stride
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|preview_surface
name|cairo_surface_t
modifier|*
name|preview_surface
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|maxcounter
name|glong
name|maxcounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|imgtype
DECL|variable|width
DECL|variable|height
DECL|variable|env_width
DECL|variable|env_height
DECL|variable|in_channels
DECL|variable|out_channels
name|gint
name|imgtype
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|env_width
decl_stmt|,
name|env_height
decl_stmt|,
name|in_channels
decl_stmt|,
name|out_channels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|background
name|GimpRGB
name|background
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|border_x1
DECL|variable|border_y1
DECL|variable|border_x2
DECL|variable|border_y2
name|gint
name|border_x1
decl_stmt|,
name|border_y1
decl_stmt|,
name|border_x2
decl_stmt|,
name|border_y2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|sinemap
DECL|variable|spheremap
DECL|variable|logmap
name|guchar
name|sinemap
index|[
literal|256
index|]
decl_stmt|,
name|spheremap
index|[
literal|256
index|]
decl_stmt|,
name|logmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************/
end_comment

begin_comment
comment|/* Implementation */
end_comment

begin_comment
comment|/******************/
end_comment

begin_function
name|guchar
DECL|function|peek_map (GimpPixelRgn * region,gint x,gint y)
name|peek_map
parameter_list|(
name|GimpPixelRgn
modifier|*
name|region
parameter_list|,
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|guchar
name|data
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|ret_val
decl_stmt|;
name|gimp_pixel_rgn_get_pixel
argument_list|(
name|region
argument_list|,
name|data
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
name|ret_val
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
call|(
name|guchar
call|)
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|(
name|data
index|[
literal|0
index|]
operator|+
name|data
index|[
literal|1
index|]
operator|+
name|data
index|[
literal|2
index|]
operator|)
operator|/
literal|3.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|peek (gint x,gint y)
name|peek
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|guchar
name|data
index|[
literal|4
index|]
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|gimp_pixel_rgn_get_pixel
argument_list|(
operator|&
name|source_region
argument_list|,
name|data
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|color
operator|.
name|r
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
name|color
operator|.
name|g
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
name|color
operator|.
name|b
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
if|if
condition|(
name|input_drawable
operator|->
name|bpp
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|in_channels
operator|==
literal|4
condition|)
name|color
operator|.
name|a
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
else|else
name|color
operator|.
name|a
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
name|color
operator|.
name|a
operator|=
literal|1.0
expr_stmt|;
block|}
return|return
name|color
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|peek_env_map (gint x,gint y)
name|peek_env_map
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|guchar
name|data
index|[
literal|4
index|]
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>=
name|env_width
condition|)
name|x
operator|=
name|env_width
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|>=
name|env_height
condition|)
name|y
operator|=
name|env_height
operator|-
literal|1
expr_stmt|;
name|gimp_pixel_rgn_get_pixel
argument_list|(
operator|&
name|env_region
argument_list|,
name|data
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|color
operator|.
name|r
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
name|color
operator|.
name|g
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
name|color
operator|.
name|b
operator|=
call|(
name|gdouble
call|)
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
operator|/
literal|255.0
expr_stmt|;
name|color
operator|.
name|a
operator|=
literal|1.0
expr_stmt|;
return|return
name|color
return|;
block|}
end_function

begin_function
name|void
DECL|function|poke (gint x,gint y,GimpRGB * color)
name|poke
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|,
name|GimpRGB
modifier|*
name|color
parameter_list|)
block|{
specifier|static
name|guchar
name|data
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>=
name|width
condition|)
name|x
operator|=
name|width
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|>=
name|height
condition|)
name|y
operator|=
name|height
operator|-
literal|1
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
name|color
operator|->
name|r
operator|*
literal|255.0
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
name|color
operator|->
name|g
operator|*
literal|255.0
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
name|color
operator|->
name|b
operator|*
literal|255.0
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
name|color
operator|->
name|a
operator|*
literal|255.0
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_pixel
argument_list|(
operator|&
name|dest_region
argument_list|,
name|data
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|gint
DECL|function|check_bounds (gint x,gint y)
name|check_bounds
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|<
name|border_x1
operator|||
name|y
operator|<
name|border_y1
operator|||
name|x
operator|>=
name|border_x2
operator|||
name|y
operator|>=
name|border_y2
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|GimpVector3
DECL|function|int_to_pos (gint x,gint y)
name|int_to_pos
parameter_list|(
name|gint
name|x
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpVector3
name|pos
decl_stmt|;
if|if
condition|(
name|width
operator|>=
name|height
condition|)
block|{
name|pos
operator|.
name|x
operator|=
operator|(
name|gdouble
operator|)
name|x
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|pos
operator|.
name|y
operator|=
operator|(
name|gdouble
operator|)
name|y
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|pos
operator|.
name|y
operator|+=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|height
operator|/
operator|(
name|gdouble
operator|)
name|width
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
operator|(
name|gdouble
operator|)
name|x
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|pos
operator|.
name|y
operator|=
operator|(
name|gdouble
operator|)
name|y
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|pos
operator|.
name|x
operator|+=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|width
operator|/
operator|(
name|gdouble
operator|)
name|height
operator|)
expr_stmt|;
block|}
name|pos
operator|.
name|z
operator|=
literal|0.0
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|GimpVector3
DECL|function|int_to_posf (gdouble x,gdouble y)
name|int_to_posf
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|)
block|{
name|GimpVector3
name|pos
decl_stmt|;
if|if
condition|(
name|width
operator|>=
name|height
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|x
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|y
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|pos
operator|.
name|y
operator|+=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|height
operator|/
operator|(
name|gdouble
operator|)
name|width
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|x
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|y
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|pos
operator|.
name|x
operator|+=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|width
operator|/
operator|(
name|gdouble
operator|)
name|height
operator|)
expr_stmt|;
block|}
name|pos
operator|.
name|z
operator|=
literal|0.0
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|void
DECL|function|pos_to_int (gdouble x,gdouble y,gint * scr_x,gint * scr_y)
name|pos_to_int
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|gint
modifier|*
name|scr_x
parameter_list|,
name|gint
modifier|*
name|scr_y
parameter_list|)
block|{
if|if
condition|(
name|width
operator|>=
name|height
condition|)
block|{
name|y
operator|-=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|height
operator|/
operator|(
name|gdouble
operator|)
name|width
operator|)
expr_stmt|;
operator|*
name|scr_x
operator|=
name|RINT
argument_list|(
operator|(
name|x
operator|*
operator|(
name|gdouble
operator|)
name|width
operator|)
argument_list|)
expr_stmt|;
operator|*
name|scr_y
operator|=
name|RINT
argument_list|(
operator|(
name|y
operator|*
operator|(
name|gdouble
operator|)
name|width
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|-=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|width
operator|/
operator|(
name|gdouble
operator|)
name|height
operator|)
expr_stmt|;
operator|*
name|scr_x
operator|=
name|RINT
argument_list|(
operator|(
name|x
operator|*
operator|(
name|gdouble
operator|)
name|height
operator|)
argument_list|)
expr_stmt|;
operator|*
name|scr_y
operator|=
name|RINT
argument_list|(
operator|(
name|y
operator|*
operator|(
name|gdouble
operator|)
name|height
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|pos_to_float (gdouble x,gdouble y,gdouble * xf,gdouble * yf)
name|pos_to_float
parameter_list|(
name|gdouble
name|x
parameter_list|,
name|gdouble
name|y
parameter_list|,
name|gdouble
modifier|*
name|xf
parameter_list|,
name|gdouble
modifier|*
name|yf
parameter_list|)
block|{
if|if
condition|(
name|width
operator|>=
name|height
condition|)
block|{
name|y
operator|-=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|height
operator|/
operator|(
name|gdouble
operator|)
name|width
operator|)
expr_stmt|;
operator|*
name|xf
operator|=
name|x
operator|*
call|(
name|gdouble
call|)
argument_list|(
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|yf
operator|=
name|y
operator|*
call|(
name|gdouble
call|)
argument_list|(
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|-=
literal|0.5
operator|*
operator|(
literal|1.0
operator|-
operator|(
name|gdouble
operator|)
name|width
operator|/
operator|(
name|gdouble
operator|)
name|height
operator|)
expr_stmt|;
operator|*
name|xf
operator|=
name|x
operator|*
call|(
name|gdouble
call|)
argument_list|(
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|yf
operator|=
name|y
operator|*
call|(
name|gdouble
call|)
argument_list|(
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************/
end_comment

begin_comment
comment|/* Compute the image color at pos (u,v) using */
end_comment

begin_comment
comment|/* Quartics bilinear interpolation stuff.     */
end_comment

begin_comment
comment|/**********************************************/
end_comment

begin_function
name|GimpRGB
DECL|function|get_image_color (gdouble u,gdouble v,gint * inside)
name|get_image_color
parameter_list|(
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|gint
modifier|*
name|inside
parameter_list|)
block|{
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|GimpRGB
name|p
index|[
literal|4
index|]
decl_stmt|;
name|x1
operator|=
name|RINT
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|y1
operator|=
name|RINT
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_bounds
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
operator|==
name|FALSE
condition|)
block|{
operator|*
name|inside
operator|=
name|FALSE
expr_stmt|;
return|return
name|background
return|;
block|}
name|x2
operator|=
operator|(
name|x1
operator|+
literal|1
operator|)
expr_stmt|;
name|y2
operator|=
operator|(
name|y1
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|check_bounds
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
operator|==
name|FALSE
condition|)
block|{
operator|*
name|inside
operator|=
name|TRUE
expr_stmt|;
return|return
name|peek
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
return|;
block|}
operator|*
name|inside
operator|=
name|TRUE
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|peek
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|peek
argument_list|(
name|x2
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|peek
argument_list|(
name|x1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|peek
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
return|return
name|gimp_bilinear_rgba
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|gdouble
DECL|function|get_map_value (GimpPixelRgn * region,gdouble u,gdouble v,gint * inside)
name|get_map_value
parameter_list|(
name|GimpPixelRgn
modifier|*
name|region
parameter_list|,
name|gdouble
name|u
parameter_list|,
name|gdouble
name|v
parameter_list|,
name|gint
modifier|*
name|inside
parameter_list|)
block|{
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|gdouble
name|p
index|[
literal|4
index|]
decl_stmt|;
name|x1
operator|=
name|RINT
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|y1
operator|=
name|RINT
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|x2
operator|=
operator|(
name|x1
operator|+
literal|1
operator|)
expr_stmt|;
name|y2
operator|=
operator|(
name|y1
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|check_bounds
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
operator|==
name|FALSE
condition|)
block|{
operator|*
name|inside
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|gdouble
operator|)
name|peek_map
argument_list|(
name|region
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
return|;
block|}
operator|*
name|inside
operator|=
name|TRUE
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|gdouble
operator|)
name|peek_map
argument_list|(
name|region
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|gdouble
operator|)
name|peek_map
argument_list|(
name|region
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|gdouble
operator|)
name|peek_map
argument_list|(
name|region
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|gdouble
operator|)
name|peek_map
argument_list|(
name|region
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
return|return
name|gimp_bilinear
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|compute_maps (void)
name|compute_maps
parameter_list|(
name|void
parameter_list|)
block|{
name|gint
name|x
decl_stmt|;
name|gdouble
name|val
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
comment|/* Compute Sine, Log ans Spherical transfer function maps */
comment|/* ====================================================== */
name|c
operator|=
literal|1.0
operator|/
literal|255.0
expr_stmt|;
name|d
operator|=
literal|1.15
operator|*
literal|255.0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
name|sinemap
index|[
name|x
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
literal|255.0
operator|*
operator|(
literal|0.5
operator|*
operator|(
name|sin
argument_list|(
operator|(
name|G_PI
operator|*
name|c
operator|*
operator|(
name|gdouble
operator|)
name|x
operator|)
operator|-
literal|0.5
operator|*
name|G_PI
argument_list|)
operator|+
literal|1.0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|spheremap
index|[
name|x
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
literal|255.0
operator|*
operator|(
name|sqrt
argument_list|(
name|sin
argument_list|(
name|G_PI
operator|*
operator|(
name|gdouble
operator|)
name|x
operator|/
literal|512.0
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|d
operator|*
name|exp
argument_list|(
operator|-
literal|1.0
operator|/
operator|(
literal|8.0
operator|*
name|c
operator|*
operator|(
operator|(
name|gdouble
operator|)
name|x
operator|+
literal|5.0
operator|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|255.0
condition|)
name|val
operator|=
literal|255.0
expr_stmt|;
name|logmap
index|[
name|x
index|]
operator|=
operator|(
name|guchar
operator|)
name|val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* Allocate memory for temporary images */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|gint
DECL|function|image_setup (GimpDrawable * drawable,gint interactive)
name|image_setup
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|,
name|gint
name|interactive
parameter_list|)
block|{
name|compute_maps
argument_list|()
expr_stmt|;
comment|/* Get some useful info on the input drawable */
comment|/* ========================================== */
name|input_drawable
operator|=
name|drawable
expr_stmt|;
name|output_drawable
operator|=
name|drawable
expr_stmt|;
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable
operator|->
name|drawable_id
argument_list|,
operator|&
name|border_x1
argument_list|,
operator|&
name|border_y1
argument_list|,
operator|&
name|border_x2
argument_list|,
operator|&
name|border_y2
argument_list|)
expr_stmt|;
name|width
operator|=
name|input_drawable
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|input_drawable
operator|->
name|height
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|source_region
argument_list|,
name|input_drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|maxcounter
operator|=
operator|(
name|glong
operator|)
name|width
operator|*
operator|(
name|glong
operator|)
name|height
expr_stmt|;
comment|/* Assume at least RGB */
comment|/* =================== */
name|in_channels
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|input_drawable
operator|->
name|drawable_id
argument_list|)
operator|==
name|TRUE
condition|)
name|in_channels
operator|++
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
name|preview_rgb_stride
operator|=
name|cairo_format_stride_for_width
argument_list|(
name|CAIRO_FORMAT_RGB24
argument_list|,
name|PREVIEW_WIDTH
argument_list|)
expr_stmt|;
name|preview_rgb_data
operator|=
name|g_new0
argument_list|(
name|guchar
argument_list|,
name|preview_rgb_stride
operator|*
name|PREVIEW_HEIGHT
argument_list|)
expr_stmt|;
name|preview_surface
operator|=
name|cairo_image_surface_create_for_data
argument_list|(
name|preview_rgb_data
argument_list|,
name|CAIRO_FORMAT_RGB24
argument_list|,
name|PREVIEW_WIDTH
argument_list|,
name|PREVIEW_HEIGHT
argument_list|,
name|preview_rgb_stride
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

