begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Shading stuff */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"lighting-main.h"
end_include

begin_include
include|#
directive|include
file|"lighting-image.h"
end_include

begin_include
include|#
directive|include
file|"lighting-shade.h"
end_include

begin_decl_stmt
DECL|variable|triangle_normals
specifier|static
name|GimpVector3
modifier|*
name|triangle_normals
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|vertex_normals
specifier|static
name|GimpVector3
modifier|*
name|vertex_normals
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|heights
specifier|static
name|gdouble
modifier|*
name|heights
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xstep
DECL|variable|ystep
specifier|static
name|gdouble
name|xstep
decl_stmt|,
name|ystep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|bumprow
specifier|static
name|guchar
modifier|*
name|bumprow
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pre_w
specifier|static
name|gint
name|pre_w
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pre_h
specifier|static
name|gint
name|pre_h
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Phong shading */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_function
specifier|static
name|GimpRGB
DECL|function|phong_shade (GimpVector3 * position,GimpVector3 * viewpoint,GimpVector3 * normal,GimpVector3 * lightposition,GimpRGB * diff_col,GimpRGB * light_col,LightType light_type)
name|phong_shade
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|,
name|GimpVector3
modifier|*
name|viewpoint
parameter_list|,
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|GimpVector3
modifier|*
name|lightposition
parameter_list|,
name|GimpRGB
modifier|*
name|diff_col
parameter_list|,
name|GimpRGB
modifier|*
name|light_col
parameter_list|,
name|LightType
name|light_type
parameter_list|)
block|{
name|GimpRGB
name|diffuse_color
decl_stmt|,
name|specular_color
decl_stmt|;
name|gdouble
name|nl
decl_stmt|,
name|rv
decl_stmt|,
name|dist
decl_stmt|;
name|GimpVector3
name|l
decl_stmt|,
name|v
decl_stmt|,
name|n
decl_stmt|,
name|lnormal
decl_stmt|,
name|h
decl_stmt|;
comment|/* Compute ambient intensity */
comment|/* ========================= */
name|n
operator|=
operator|*
name|normal
expr_stmt|;
comment|/* Compute (N*L) term of Phong's equation */
comment|/* ====================================== */
if|if
condition|(
name|light_type
operator|==
name|POINT_LIGHT
condition|)
name|gimp_vector3_sub
argument_list|(
operator|&
name|l
argument_list|,
name|lightposition
argument_list|,
name|position
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|=
operator|*
name|lightposition
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
name|dist
operator|=
name|gimp_vector3_length
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|!=
literal|0.0
condition|)
name|gimp_vector3_mul
argument_list|(
operator|&
name|l
argument_list|,
literal|1.0
operator|/
name|dist
argument_list|)
expr_stmt|;
name|nl
operator|=
name|MAX
argument_list|(
literal|0.
argument_list|,
literal|2.0
operator|*
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|lnormal
operator|=
name|l
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|lnormal
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>=
literal|0.0
condition|)
block|{
comment|/* Compute (R*V)^alpha term of Phong's equation */
comment|/* ============================================ */
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|lnormal
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|rv
operator|=
name|MAX
argument_list|(
literal|0.01
argument_list|,
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pow
argument_list|(
name|rv
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|highlight
argument_list|)
expr_stmt|;
name|rv
operator|*=
name|nl
expr_stmt|;
comment|/* Compute diffuse and specular intensity contribution */
comment|/* =================================================== */
name|diffuse_color
operator|=
operator|*
name|light_col
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|diffuse_color
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
argument_list|)
expr_stmt|;
name|diffuse_color
operator|.
name|r
operator|*=
name|diff_col
operator|->
name|r
expr_stmt|;
name|diffuse_color
operator|.
name|g
operator|*=
name|diff_col
operator|->
name|g
expr_stmt|;
name|diffuse_color
operator|.
name|b
operator|*=
name|diff_col
operator|->
name|b
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|diffuse_color
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|specular_color
operator|=
operator|*
name|light_col
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|material
operator|.
name|metallic
condition|)
comment|/* for metals, specular color = diffuse color */
block|{
name|specular_color
operator|.
name|r
operator|*=
name|diff_col
operator|->
name|r
expr_stmt|;
name|specular_color
operator|.
name|g
operator|*=
name|diff_col
operator|->
name|g
expr_stmt|;
name|specular_color
operator|.
name|b
operator|*=
name|diff_col
operator|->
name|b
expr_stmt|;
block|}
name|gimp_rgb_multiply
argument_list|(
operator|&
name|specular_color
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|specular_ref
argument_list|)
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|specular_color
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|gimp_rgb_add
argument_list|(
operator|&
name|diffuse_color
argument_list|,
operator|&
name|specular_color
argument_list|)
expr_stmt|;
name|gimp_rgb_clamp
argument_list|(
operator|&
name|diffuse_color
argument_list|)
expr_stmt|;
block|}
name|gimp_rgb_clamp
argument_list|(
operator|&
name|diffuse_color
argument_list|)
expr_stmt|;
return|return
name|diffuse_color
return|;
block|}
end_function

begin_function
name|void
DECL|function|precompute_init (gint w,gint h)
name|precompute_init
parameter_list|(
name|gint
name|w
parameter_list|,
name|gint
name|h
parameter_list|)
block|{
name|gint
name|n
decl_stmt|;
name|gint
name|bpp
init|=
literal|1
decl_stmt|;
name|xstep
operator|=
literal|1.0
operator|/
operator|(
name|gdouble
operator|)
name|width
expr_stmt|;
name|ystep
operator|=
literal|1.0
operator|/
operator|(
name|gdouble
operator|)
name|height
expr_stmt|;
name|pre_w
operator|=
name|w
expr_stmt|;
name|pre_h
operator|=
name|h
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|3
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|vertex_normals
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|vertex_normals
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|heights
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|heights
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|heights
index|[
name|n
index|]
operator|=
name|g_new
argument_list|(
name|gdouble
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|vertex_normals
index|[
name|n
index|]
operator|=
name|g_new
argument_list|(
name|GimpVector3
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|2
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|triangle_normals
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|triangle_normals
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bumprow
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|bumprow
argument_list|)
expr_stmt|;
name|bumprow
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mapvals
operator|.
name|bumpmap_id
operator|!=
operator|-
literal|1
condition|)
block|{
name|bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|mapvals
operator|.
name|bumpmap_id
argument_list|)
expr_stmt|;
block|}
name|bumprow
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|w
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|triangle_normals
index|[
literal|0
index|]
operator|=
name|g_new
argument_list|(
name|GimpVector3
argument_list|,
operator|(
name|w
operator|<<
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
operator|=
name|g_new
argument_list|(
name|GimpVector3
argument_list|,
operator|(
name|w
operator|<<
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|w
operator|<<
literal|1
operator|)
operator|+
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|gimp_vector3_set
argument_list|(
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|w
condition|;
name|n
operator|++
control|)
block|{
name|gimp_vector3_set
argument_list|(
operator|&
name|vertex_normals
index|[
literal|0
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|vertex_normals
index|[
literal|1
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|vertex_normals
index|[
literal|2
index|]
index|[
name|n
index|]
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|heights
index|[
literal|0
index|]
index|[
name|n
index|]
operator|=
literal|0.0
expr_stmt|;
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
operator|=
literal|0.0
expr_stmt|;
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************/
end_comment

begin_comment
comment|/* Compute triangle and then vertex normals */
end_comment

begin_comment
comment|/********************************************/
end_comment

begin_function
name|void
DECL|function|precompute_normals (gint x1,gint x2,gint y)
name|precompute_normals
parameter_list|(
name|gint
name|x1
parameter_list|,
name|gint
name|x2
parameter_list|,
name|gint
name|y
parameter_list|)
block|{
name|GimpVector3
modifier|*
name|tmpv
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|normal
decl_stmt|;
name|gdouble
modifier|*
name|tmpd
decl_stmt|;
name|gint
name|n
decl_stmt|,
name|i
decl_stmt|,
name|nv
decl_stmt|;
name|guchar
modifier|*
name|map
init|=
name|NULL
decl_stmt|;
name|gint
name|bpp
init|=
literal|1
decl_stmt|;
name|guchar
name|mapval
decl_stmt|;
comment|/* First, compute the heights */
comment|/* ========================== */
name|tmpv
operator|=
name|triangle_normals
index|[
literal|0
index|]
expr_stmt|;
name|triangle_normals
index|[
literal|0
index|]
operator|=
name|triangle_normals
index|[
literal|1
index|]
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
operator|=
name|tmpv
expr_stmt|;
name|tmpv
operator|=
name|vertex_normals
index|[
literal|0
index|]
expr_stmt|;
name|vertex_normals
index|[
literal|0
index|]
operator|=
name|vertex_normals
index|[
literal|1
index|]
expr_stmt|;
name|vertex_normals
index|[
literal|1
index|]
operator|=
name|vertex_normals
index|[
literal|2
index|]
expr_stmt|;
name|vertex_normals
index|[
literal|2
index|]
operator|=
name|tmpv
expr_stmt|;
name|tmpd
operator|=
name|heights
index|[
literal|0
index|]
expr_stmt|;
name|heights
index|[
literal|0
index|]
operator|=
name|heights
index|[
literal|1
index|]
expr_stmt|;
name|heights
index|[
literal|1
index|]
operator|=
name|heights
index|[
literal|2
index|]
expr_stmt|;
name|heights
index|[
literal|2
index|]
operator|=
name|tmpd
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bumpmap_id
operator|!=
operator|-
literal|1
condition|)
block|{
name|bpp
operator|=
name|gimp_drawable_bpp
argument_list|(
name|mapvals
operator|.
name|bumpmap_id
argument_list|)
expr_stmt|;
block|}
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|bump_region
argument_list|,
name|bumprow
argument_list|,
name|x1
argument_list|,
name|y
argument_list|,
name|x2
operator|-
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bumpmaptype
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|mapvals
operator|.
name|bumpmaptype
condition|)
block|{
case|case
literal|1
case|:
name|map
operator|=
name|logmap
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|map
operator|=
name|sinemap
expr_stmt|;
break|break;
default|default:
name|map
operator|=
name|spheremap
expr_stmt|;
break|break;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|bpp
operator|>
literal|1
condition|)
block|{
name|mapval
operator|=
call|(
name|guchar
call|)
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|(
name|bumprow
index|[
name|n
operator|*
name|bpp
index|]
operator|+
name|bumprow
index|[
name|n
operator|*
name|bpp
operator|+
literal|1
index|]
operator|+
name|bumprow
index|[
name|n
operator|*
name|bpp
operator|+
literal|2
index|]
operator|)
operator|/
literal|3.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mapval
operator|=
name|bumprow
index|[
name|n
operator|*
name|bpp
index|]
expr_stmt|;
block|}
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|=
operator|(
name|gdouble
operator|)
name|mapvals
operator|.
name|bumpmax
operator|*
operator|(
name|gdouble
operator|)
name|map
index|[
name|mapval
index|]
operator|/
literal|255.0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|bpp
operator|>
literal|1
condition|)
block|{
name|mapval
operator|=
call|(
name|guchar
call|)
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|(
name|bumprow
index|[
name|n
operator|*
name|bpp
index|]
operator|+
name|bumprow
index|[
name|n
operator|*
name|bpp
operator|+
literal|1
index|]
operator|+
name|bumprow
index|[
name|n
operator|*
name|bpp
operator|+
literal|2
index|]
operator|)
operator|/
literal|3.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mapval
operator|=
name|bumprow
index|[
name|n
operator|*
name|bpp
index|]
expr_stmt|;
block|}
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|=
operator|(
name|gdouble
operator|)
name|mapvals
operator|.
name|bumpmax
operator|*
operator|(
name|gdouble
operator|)
name|mapval
operator|/
literal|255.0
expr_stmt|;
block|}
block|}
comment|/* Compute triangle normals */
comment|/* ======================== */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|-
literal|1
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|p1
operator|.
name|x
operator|=
literal|0.0
expr_stmt|;
name|p1
operator|.
name|y
operator|=
name|ystep
expr_stmt|;
name|p1
operator|.
name|z
operator|=
name|heights
index|[
literal|2
index|]
index|[
name|n
index|]
operator|-
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
name|p2
operator|.
name|x
operator|=
name|xstep
expr_stmt|;
name|p2
operator|.
name|y
operator|=
name|ystep
expr_stmt|;
name|p2
operator|.
name|z
operator|=
name|heights
index|[
literal|2
index|]
index|[
name|n
operator|+
literal|1
index|]
operator|-
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
name|p3
operator|.
name|x
operator|=
name|xstep
expr_stmt|;
name|p3
operator|.
name|y
operator|=
literal|0.0
expr_stmt|;
name|p3
operator|.
name|z
operator|=
name|heights
index|[
literal|1
index|]
index|[
name|n
operator|+
literal|1
index|]
operator|-
name|heights
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|p2
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|p3
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Compute vertex normals */
comment|/* ====================== */
name|i
operator|=
literal|0
expr_stmt|;
name|gimp_vector3_set
argument_list|(
operator|&
name|normal
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|x2
operator|-
name|x1
operator|-
literal|1
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|nv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|nv
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
name|pre_h
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nv
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
name|pre_w
condition|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|0
index|]
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|nv
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
name|pre_h
condition|)
block|{
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_vector3_add
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|triangle_normals
index|[
literal|1
index|]
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|nv
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|gimp_vector3_mul
argument_list|(
operator|&
name|normal
argument_list|,
literal|1.0
operator|/
operator|(
name|gdouble
operator|)
name|nv
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|vertex_normals
index|[
literal|1
index|]
index|[
name|n
index|]
operator|=
name|normal
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Compute the reflected ray given the normalized normal and ins. vec. */
end_comment

begin_comment
comment|/***********************************************************************/
end_comment

begin_function
specifier|static
name|GimpVector3
DECL|function|compute_reflected_ray (GimpVector3 * normal,GimpVector3 * view)
name|compute_reflected_ray
parameter_list|(
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|GimpVector3
modifier|*
name|view
parameter_list|)
block|{
name|GimpVector3
name|ref
decl_stmt|;
name|gdouble
name|nl
decl_stmt|;
name|nl
operator|=
literal|2.0
operator|*
name|gimp_vector3_inner_product
argument_list|(
name|normal
argument_list|,
name|view
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|*
name|normal
expr_stmt|;
name|gimp_vector3_mul
argument_list|(
operator|&
name|ref
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|gimp_vector3_sub
argument_list|(
operator|&
name|ref
argument_list|,
operator|&
name|ref
argument_list|,
name|view
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Given the NorthPole, Equator and a third vector (normal) compute     */
end_comment

begin_comment
comment|/* the conversion from spherical coordinates to image space coordinates */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|void
DECL|function|sphere_to_image (GimpVector3 * normal,gdouble * u,gdouble * v)
name|sphere_to_image
parameter_list|(
name|GimpVector3
modifier|*
name|normal
parameter_list|,
name|gdouble
modifier|*
name|u
parameter_list|,
name|gdouble
modifier|*
name|v
parameter_list|)
block|{
specifier|static
name|gdouble
name|alpha
decl_stmt|,
name|fac
decl_stmt|;
specifier|static
name|GimpVector3
name|cross_prod
decl_stmt|;
specifier|static
name|GimpVector3
name|firstaxis
init|=
block|{
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
decl_stmt|;
specifier|static
name|GimpVector3
name|secondaxis
init|=
block|{
literal|0.0
block|,
literal|1.0
block|,
literal|0.0
block|}
decl_stmt|;
name|alpha
operator|=
name|acos
argument_list|(
operator|-
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|secondaxis
argument_list|,
name|normal
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|alpha
operator|/
name|G_PI
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0.0
operator|||
operator|*
name|v
operator|==
literal|1.0
condition|)
block|{
operator|*
name|u
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|fac
operator|=
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|firstaxis
argument_list|,
name|normal
argument_list|)
operator|/
name|sin
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
comment|/* Make sure that we map to -1.0..1.0 (take care of rounding errors) */
comment|/* ================================================================= */
if|if
condition|(
name|fac
operator|>
literal|1.0
condition|)
name|fac
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|fac
operator|<
operator|-
literal|1.0
condition|)
name|fac
operator|=
operator|-
literal|1.0
expr_stmt|;
operator|*
name|u
operator|=
name|acos
argument_list|(
name|fac
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|G_PI
operator|)
expr_stmt|;
name|cross_prod
operator|=
name|gimp_vector3_cross_product
argument_list|(
operator|&
name|secondaxis
argument_list|,
operator|&
name|firstaxis
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_vector3_inner_product
argument_list|(
operator|&
name|cross_prod
argument_list|,
name|normal
argument_list|)
operator|<
literal|0.0
condition|)
operator|*
name|u
operator|=
literal|1.0
operator|-
operator|*
name|u
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/* These routines computes the color of the surface at a given point */
end_comment

begin_comment
comment|/*********************************************************************/
end_comment

begin_function
name|GimpRGB
DECL|function|get_ray_color (GimpVector3 * position)
name|get_ray_color
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|GimpRGB
name|color_int
decl_stmt|;
name|GimpRGB
name|color_sum
decl_stmt|;
name|GimpRGB
name|light_color
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|f
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color_sum
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|get_image_color
argument_list|(
name|xf
argument_list|,
name|yf
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
name|color_sum
operator|=
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_sum
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_LIGHTS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|active
operator|||
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|NO_LIGHT
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|position
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|direction
expr_stmt|;
name|color_int
operator|=
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|intensity
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
block|{
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|xf
argument_list|)
index|]
expr_stmt|;
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|gimp_rgb_add
argument_list|(
operator|&
name|color_sum
argument_list|,
operator|&
name|light_color
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color_sum
argument_list|)
expr_stmt|;
return|return
name|color_sum
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|get_ray_color_ref (GimpVector3 * position)
name|get_ray_color_ref
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GimpRGB
name|color_sum
decl_stmt|;
name|GimpRGB
name|color_int
decl_stmt|;
name|GimpRGB
name|light_color
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|,
name|env_color
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|f
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|gdouble
name|tmpval
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
name|normal
operator|=
name|mapvals
operator|.
name|planenormal
expr_stmt|;
else|else
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|xf
argument_list|)
index|]
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color_sum
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|get_image_color
argument_list|(
name|xf
argument_list|,
name|yf
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
name|color_sum
operator|=
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_sum
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_LIGHTS
condition|;
name|k
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|direction
expr_stmt|;
if|if
condition|(
operator|!
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|active
operator|||
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|NO_LIGHT
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|position
expr_stmt|;
name|color_int
operator|=
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|intensity
argument_list|)
expr_stmt|;
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|compute_reflected_ray
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* Get color in the direction of r */
comment|/* =============================== */
name|sphere_to_image
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|env_color
operator|=
name|peek_env_map
argument_list|(
name|RINT
argument_list|(
name|env_width
operator|*
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|env_height
operator|*
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|tmpval
operator|=
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
expr_stmt|;
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
operator|=
literal|0.
expr_stmt|;
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|env_color
argument_list|,
name|DIRECTIONAL_LIGHT
argument_list|)
expr_stmt|;
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
operator|=
name|tmpval
expr_stmt|;
name|gimp_rgb_add
argument_list|(
operator|&
name|color_sum
argument_list|,
operator|&
name|light_color
argument_list|)
expr_stmt|;
block|}
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color_sum
argument_list|)
expr_stmt|;
return|return
name|color_sum
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|get_ray_color_no_bilinear (GimpVector3 * position)
name|get_ray_color_no_bilinear
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GimpRGB
name|color
decl_stmt|;
name|GimpRGB
name|color_int
decl_stmt|;
name|GimpRGB
name|color_sum
decl_stmt|;
name|GimpRGB
name|light_color
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color_sum
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|peek
argument_list|(
name|x
argument_list|,
name|RINT
argument_list|(
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|color_sum
operator|=
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_sum
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_LIGHTS
condition|;
name|k
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|direction
expr_stmt|;
if|if
condition|(
operator|!
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|active
operator|||
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|NO_LIGHT
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|position
expr_stmt|;
name|color_int
operator|=
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|intensity
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
block|{
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|mapvals
operator|.
name|planenormal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
name|x
index|]
expr_stmt|;
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|gimp_rgb_add
argument_list|(
operator|&
name|color_sum
argument_list|,
operator|&
name|light_color
argument_list|)
expr_stmt|;
block|}
block|}
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color_sum
argument_list|)
expr_stmt|;
return|return
name|color_sum
return|;
block|}
end_function

begin_function
name|GimpRGB
DECL|function|get_ray_color_no_bilinear_ref (GimpVector3 * position)
name|get_ray_color_no_bilinear_ref
parameter_list|(
name|GimpVector3
modifier|*
name|position
parameter_list|)
block|{
name|GimpRGB
name|color_sum
decl_stmt|;
name|GimpRGB
name|color_int
decl_stmt|;
name|GimpRGB
name|light_color
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|,
name|env_color
decl_stmt|;
name|gint
name|x
decl_stmt|;
name|gdouble
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|GimpVector3
name|normal
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|gint
name|k
decl_stmt|;
name|gdouble
name|tmpval
decl_stmt|;
name|pos_to_float
argument_list|(
name|position
operator|->
name|x
argument_list|,
name|position
operator|->
name|y
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|x
operator|=
name|RINT
argument_list|(
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|bump_mapped
operator|==
name|FALSE
operator|||
name|mapvals
operator|.
name|bumpmap_id
operator|==
operator|-
literal|1
condition|)
name|normal
operator|=
name|mapvals
operator|.
name|planenormal
expr_stmt|;
else|else
name|normal
operator|=
name|vertex_normals
index|[
literal|1
index|]
index|[
operator|(
name|gint
operator|)
name|RINT
argument_list|(
name|xf
argument_list|)
index|]
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapvals
operator|.
name|transparent_background
operator|&&
name|heights
index|[
literal|1
index|]
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|gimp_rgb_set_alpha
argument_list|(
operator|&
name|color_sum
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|color
operator|=
name|peek
argument_list|(
name|RINT
argument_list|(
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|color_sum
operator|=
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_sum
argument_list|,
name|mapvals
operator|.
name|material
operator|.
name|ambient_int
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_LIGHTS
condition|;
name|k
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|direction
expr_stmt|;
if|if
condition|(
operator|!
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|active
operator|||
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|NO_LIGHT
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|type
operator|==
name|POINT_LIGHT
condition|)
name|p
operator|=
operator|&
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|position
expr_stmt|;
name|color_int
operator|=
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|color
expr_stmt|;
name|gimp_rgb_multiply
argument_list|(
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
name|k
index|]
operator|.
name|intensity
argument_list|)
expr_stmt|;
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
name|p
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|color_int
argument_list|,
name|mapvals
operator|.
name|lightsource
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|gimp_vector3_sub
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_vector3_normalize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|r
operator|=
name|compute_reflected_ray
argument_list|(
operator|&
name|normal
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* Get color in the direction of r */
comment|/* =============================== */
name|sphere_to_image
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|xf
argument_list|,
operator|&
name|yf
argument_list|)
expr_stmt|;
name|env_color
operator|=
name|peek_env_map
argument_list|(
name|RINT
argument_list|(
name|env_width
operator|*
name|xf
argument_list|)
argument_list|,
name|RINT
argument_list|(
name|env_height
operator|*
name|yf
argument_list|)
argument_list|)
expr_stmt|;
name|tmpval
operator|=
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
expr_stmt|;
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
operator|=
literal|0.
expr_stmt|;
name|light_color
operator|=
name|phong_shade
argument_list|(
name|position
argument_list|,
operator|&
name|mapvals
operator|.
name|viewpoint
argument_list|,
operator|&
name|normal
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|color
argument_list|,
operator|&
name|env_color
argument_list|,
name|DIRECTIONAL_LIGHT
argument_list|)
expr_stmt|;
name|mapvals
operator|.
name|material
operator|.
name|diffuse_int
operator|=
name|tmpval
expr_stmt|;
name|gimp_rgb_add
argument_list|(
operator|&
name|color_sum
argument_list|,
operator|&
name|light_color
argument_list|)
expr_stmt|;
block|}
name|gimp_rgb_clamp
argument_list|(
operator|&
name|color_sum
argument_list|)
expr_stmt|;
return|return
name|color_sum
return|;
block|}
end_function

end_unit

