begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	DDS GIMP plugin  	Copyright (C) 2004-2012 Shawn Kirst<skirst@gmail.com>,    with parts (C) 2003 Arne Reuter<homepage@arnereuter.de> where specified.  	This program is free software; you can redistribute it and/or 	modify it under the terms of the GNU General Public 	License as published by the Free Software Foundation; either 	version 2 of the License, or (at your option) any later version.  	This program is distributed in the hope that it will be useful, 	but WITHOUT ANY WARRANTY; without even the implied warranty of 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 	General Public License for more details.  	You should have received a copy of the GNU General Public License 	along with this program; see the file COPYING.  If not, write to 	the Free Software Foundation, 51 Franklin Street, Fifth Floor 	Boston, MA 02110-1301, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_OPENMP
end_ifdef

begin_include
include|#
directive|include
file|<omp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dds.h"
end_include

begin_include
include|#
directive|include
file|"mipmap.h"
end_include

begin_include
include|#
directive|include
file|"imath.h"
end_include

begin_include
include|#
directive|include
file|"color.h"
end_include

begin_typedef
DECL|typedef|filterfunc_t
typedef|typedef
name|float
function_decl|(
modifier|*
name|filterfunc_t
function_decl|)
parameter_list|(
name|float
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|wrapfunc_t
typedef|typedef
name|int
function_decl|(
modifier|*
name|wrapfunc_t
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|mipmapfunc_t
typedef|typedef
name|void
function_decl|(
modifier|*
name|mipmapfunc_t
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|filterfunc_t
parameter_list|,
name|float
parameter_list|,
name|wrapfunc_t
parameter_list|,
name|int
parameter_list|,
name|float
parameter_list|)
function_decl|;
end_typedef

begin_typedef
DECL|typedef|volmipmapfunc_t
typedef|typedef
name|void
function_decl|(
modifier|*
name|volmipmapfunc_t
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|filterfunc_t
parameter_list|,
name|float
parameter_list|,
name|wrapfunc_t
parameter_list|,
name|int
parameter_list|,
name|float
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/******************************************************************************  * size functions                                                             *  ******************************************************************************/
end_comment

begin_function
DECL|function|get_num_mipmaps (int width,int height)
name|int
name|get_num_mipmaps
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|w
init|=
name|width
operator|<<
literal|1
decl_stmt|;
name|int
name|h
init|=
name|height
operator|<<
literal|1
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|w
operator|!=
literal|1
operator|||
name|h
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|w
operator|>
literal|1
condition|)
name|w
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|>
literal|1
condition|)
name|h
operator|>>=
literal|1
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
DECL|function|get_mipmapped_size (int width,int height,int bpp,int level,int num,int format)
name|unsigned
name|int
name|get_mipmapped_size
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|w
operator|=
name|width
operator|>>
name|level
expr_stmt|;
name|h
operator|=
name|height
operator|>>
name|level
expr_stmt|;
name|w
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|h
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|w
operator|<<=
literal|1
expr_stmt|;
name|h
operator|<<=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|num
operator|&&
operator|(
name|w
operator|!=
literal|1
operator|||
name|h
operator|!=
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|>
literal|1
condition|)
name|w
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|>
literal|1
condition|)
name|h
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_NONE
condition|)
name|size
operator|+=
operator|(
name|w
operator|*
name|h
operator|)
expr_stmt|;
else|else
name|size
operator|+=
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|*
operator|(
operator|(
name|h
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_NONE
condition|)
name|size
operator|*=
name|bpp
expr_stmt|;
else|else
block|{
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC1
operator|||
name|format
operator|==
name|DDS_COMPRESS_BC4
condition|)
name|size
operator|*=
literal|8
expr_stmt|;
else|else
name|size
operator|*=
literal|16
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
DECL|function|get_volume_mipmapped_size (int width,int height,int depth,int bpp,int level,int num,int format)
name|unsigned
name|int
name|get_volume_mipmapped_size
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|d
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|w
operator|=
name|width
operator|>>
name|level
expr_stmt|;
name|h
operator|=
name|height
operator|>>
name|level
expr_stmt|;
name|d
operator|=
name|depth
operator|>>
name|level
expr_stmt|;
name|w
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|h
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|d
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|w
operator|<<=
literal|1
expr_stmt|;
name|h
operator|<<=
literal|1
expr_stmt|;
name|d
operator|<<=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|num
operator|&&
operator|(
name|w
operator|!=
literal|1
operator|||
name|h
operator|!=
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|>
literal|1
condition|)
name|w
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|>
literal|1
condition|)
name|h
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|1
condition|)
name|d
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_NONE
condition|)
name|size
operator|+=
operator|(
name|w
operator|*
name|h
operator|*
name|d
operator|)
expr_stmt|;
else|else
name|size
operator|+=
operator|(
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|*
operator|(
operator|(
name|h
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|*
name|d
operator|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_NONE
condition|)
name|size
operator|*=
name|bpp
expr_stmt|;
else|else
block|{
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC1
operator|||
name|format
operator|==
name|DDS_COMPRESS_BC4
condition|)
name|size
operator|*=
literal|8
expr_stmt|;
else|else
name|size
operator|*=
literal|16
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
DECL|function|get_next_mipmap_dimensions (int * next_w,int * next_h,int curr_w,int curr_h)
name|int
name|get_next_mipmap_dimensions
parameter_list|(
name|int
modifier|*
name|next_w
parameter_list|,
name|int
modifier|*
name|next_h
parameter_list|,
name|int
name|curr_w
parameter_list|,
name|int
name|curr_h
parameter_list|)
block|{
if|if
condition|(
name|curr_w
operator|==
literal|1
operator|||
name|curr_h
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|next_w
condition|)
operator|*
name|next_w
operator|=
name|curr_w
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|next_h
condition|)
operator|*
name|next_h
operator|=
name|curr_h
operator|>>
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * wrap modes                                                                 *  ******************************************************************************/
end_comment

begin_function
DECL|function|wrap_mirror (int x,int max)
specifier|static
name|int
name|wrap_mirror
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|max
operator|==
literal|1
condition|)
name|x
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|abs
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|>=
name|max
condition|)
name|x
operator|=
name|abs
argument_list|(
name|max
operator|+
name|max
operator|-
name|x
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|wrap_repeat (int x,int max)
specifier|static
name|int
name|wrap_repeat
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
return|return
operator|(
name|x
operator|%
name|max
operator|)
return|;
return|return
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|%
name|max
operator|+
name|max
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
DECL|function|wrap_clamp (int x,int max)
specifier|static
name|int
name|wrap_clamp
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|max
parameter_list|)
block|{
return|return
operator|(
name|MAX
argument_list|(
literal|0
argument_list|,
name|MIN
argument_list|(
name|max
operator|-
literal|1
argument_list|,
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * gamma-correction                                                           *  ******************************************************************************/
end_comment

begin_function
DECL|function|linear_to_gamma (int gc,int v,float gamma)
specifier|static
name|int
name|linear_to_gamma
parameter_list|(
name|int
name|gc
parameter_list|,
name|int
name|v
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
if|if
condition|(
name|gc
operator|==
literal|1
condition|)
block|{
name|v
operator|=
call|(
name|int
call|)
argument_list|(
name|powf
argument_list|(
operator|(
name|float
operator|)
name|v
operator|/
literal|255.0f
argument_list|,
name|gamma
argument_list|)
operator|*
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|255
condition|)
name|v
operator|=
literal|255
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gc
operator|==
literal|2
condition|)
name|v
operator|=
name|linear_to_sRGB
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
DECL|function|gamma_to_linear (int gc,int v,float gamma)
specifier|static
name|int
name|gamma_to_linear
parameter_list|(
name|int
name|gc
parameter_list|,
name|int
name|v
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
if|if
condition|(
name|gc
operator|==
literal|1
condition|)
block|{
name|v
operator|=
call|(
name|int
call|)
argument_list|(
name|powf
argument_list|(
operator|(
name|float
operator|)
name|v
operator|/
literal|255.0f
argument_list|,
literal|1.0f
operator|/
name|gamma
argument_list|)
operator|*
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|255
condition|)
name|v
operator|=
literal|255
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gc
operator|==
literal|2
condition|)
name|v
operator|=
name|sRGB_to_linear
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * filters                                                                    *  ******************************************************************************/
end_comment

begin_function
DECL|function|box_filter (float t)
specifier|static
name|float
name|box_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|t
operator|>=
operator|-
literal|0.5f
operator|)
operator|&&
operator|(
name|t
operator|<
literal|0.5f
operator|)
condition|)
return|return
operator|(
literal|1.0f
operator|)
return|;
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_function
DECL|function|triangle_filter (float t)
specifier|static
name|float
name|triangle_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|<
literal|0.0f
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|1.0f
condition|)
return|return
operator|(
literal|1.0f
operator|-
name|t
operator|)
return|;
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_function
DECL|function|quadratic_filter (float t)
specifier|static
name|float
name|quadratic_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|<
literal|0.0f
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.5f
condition|)
return|return
operator|(
literal|0.75f
operator|-
name|t
operator|*
name|t
operator|)
return|;
if|if
condition|(
name|t
operator|<
literal|1.5f
condition|)
block|{
name|t
operator|-=
literal|1.5f
expr_stmt|;
return|return
operator|(
literal|0.5f
operator|*
name|t
operator|*
name|t
operator|)
return|;
block|}
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_function
DECL|function|bspline_filter (float t)
specifier|static
name|float
name|bspline_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
name|float
name|tt
decl_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0f
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|1.0f
condition|)
block|{
name|tt
operator|=
name|t
operator|*
name|t
expr_stmt|;
return|return
operator|(
operator|(
operator|(
literal|0.5f
operator|*
name|tt
operator|*
name|t
operator|)
operator|-
name|tt
operator|+
operator|(
literal|2.0f
operator|/
literal|3.0f
operator|)
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
literal|2.0f
condition|)
block|{
name|t
operator|=
literal|2.0f
operator|-
name|t
expr_stmt|;
return|return
operator|(
operator|(
literal|1.0f
operator|/
literal|6.0f
operator|)
operator|*
operator|(
name|t
operator|*
name|t
operator|*
name|t
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mitchell (float t,const float B,const float C)
specifier|static
name|float
name|mitchell
parameter_list|(
name|float
name|t
parameter_list|,
specifier|const
name|float
name|B
parameter_list|,
specifier|const
name|float
name|C
parameter_list|)
block|{
name|float
name|tt
decl_stmt|;
name|tt
operator|=
name|t
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0f
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|1.0f
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
literal|12.0f
operator|-
literal|9.0f
operator|*
name|B
operator|-
literal|6.0f
operator|*
name|C
operator|)
operator|*
operator|(
name|t
operator|*
name|tt
operator|)
operator|)
operator|+
operator|(
operator|(
operator|-
literal|18.0f
operator|+
literal|12.0f
operator|*
name|B
operator|+
literal|6.0f
operator|*
name|C
operator|)
operator|*
name|tt
operator|)
operator|+
operator|(
literal|6.0f
operator|-
literal|2.0f
operator|*
name|B
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|t
operator|/
literal|6.0f
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
literal|2.0f
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
operator|-
literal|1.0f
operator|*
name|B
operator|-
literal|6.0f
operator|*
name|C
operator|)
operator|*
operator|(
name|t
operator|*
name|tt
operator|)
operator|)
operator|+
operator|(
operator|(
literal|6.0f
operator|*
name|B
operator|+
literal|30.0f
operator|*
name|C
operator|)
operator|*
name|tt
operator|)
operator|+
operator|(
operator|(
operator|-
literal|12.0f
operator|*
name|B
operator|-
literal|48.0f
operator|*
name|C
operator|)
operator|*
name|t
operator|)
operator|+
operator|(
literal|8.0f
operator|*
name|B
operator|+
literal|24.0f
operator|*
name|C
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|t
operator|/
literal|6.0f
operator|)
return|;
block|}
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_function
DECL|function|mitchell_filter (float t)
specifier|static
name|float
name|mitchell_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
return|return
operator|(
name|mitchell
argument_list|(
name|t
argument_list|,
literal|1.0f
operator|/
literal|3.0f
argument_list|,
literal|1.0f
operator|/
literal|3.0f
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
DECL|function|sinc (float x)
specifier|static
name|float
name|sinc
parameter_list|(
name|float
name|x
parameter_list|)
block|{
name|x
operator|=
operator|(
name|x
operator|*
name|M_PI
operator|)
expr_stmt|;
if|if
condition|(
name|fabsf
argument_list|(
name|x
argument_list|)
operator|<
literal|1e-04f
condition|)
return|return
operator|(
literal|1.0f
operator|+
name|x
operator|*
name|x
operator|*
operator|(
operator|-
literal|1.0f
operator|/
literal|6.0f
operator|+
name|x
operator|*
name|x
operator|*
literal|1.0f
operator|/
literal|120.0f
operator|)
operator|)
return|;
return|return
operator|(
name|sinf
argument_list|(
name|x
argument_list|)
operator|/
name|x
operator|)
return|;
block|}
end_function

begin_function
DECL|function|lanczos_filter (float t)
specifier|static
name|float
name|lanczos_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|<
literal|0.0f
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|3.0f
condition|)
return|return
operator|(
name|sinc
argument_list|(
name|t
argument_list|)
operator|*
name|sinc
argument_list|(
name|t
operator|/
literal|3.0f
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_function
DECL|function|bessel0 (float x)
specifier|static
name|float
name|bessel0
parameter_list|(
name|float
name|x
parameter_list|)
block|{
specifier|const
name|float
name|EPSILON
init|=
literal|1e-6f
decl_stmt|;
name|float
name|xh
decl_stmt|,
name|sum
decl_stmt|,
name|pow
decl_stmt|,
name|ds
decl_stmt|;
name|int
name|k
decl_stmt|;
name|xh
operator|=
literal|0.5f
operator|*
name|x
expr_stmt|;
name|sum
operator|=
literal|1.0f
expr_stmt|;
name|pow
operator|=
literal|1.0f
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|ds
operator|=
literal|1.0f
expr_stmt|;
while|while
condition|(
name|ds
operator|>
name|sum
operator|*
name|EPSILON
condition|)
block|{
operator|++
name|k
expr_stmt|;
name|pow
operator|=
name|pow
operator|*
operator|(
name|xh
operator|/
name|k
operator|)
expr_stmt|;
name|ds
operator|=
name|pow
operator|*
name|pow
expr_stmt|;
name|sum
operator|+=
name|ds
expr_stmt|;
block|}
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
DECL|function|kaiser_filter (float t)
specifier|static
name|float
name|kaiser_filter
parameter_list|(
name|float
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|<
literal|0.0f
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|3.0f
condition|)
block|{
specifier|const
name|float
name|alpha
init|=
literal|4.0f
decl_stmt|;
specifier|const
name|float
name|rb04
init|=
literal|0.0884805322f
decl_stmt|;
comment|// 1.0f / bessel0(4.0f);
specifier|const
name|float
name|ratio
init|=
name|t
operator|/
literal|3.0f
decl_stmt|;
if|if
condition|(
operator|(
literal|1.0f
operator|-
name|ratio
operator|*
name|ratio
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|sinc
argument_list|(
name|t
argument_list|)
operator|*
name|bessel0
argument_list|(
name|alpha
operator|*
name|sqrtf
argument_list|(
literal|1.0f
operator|-
name|ratio
operator|*
name|ratio
argument_list|)
argument_list|)
operator|*
name|rb04
operator|)
return|;
block|}
return|return
operator|(
literal|0.0f
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * 2D image scaling                                                           *  ******************************************************************************/
end_comment

begin_function
DECL|function|scale_image_nearest (unsigned char * dst,int dw,int dh,unsigned char * src,int sw,int sh,int bpp,filterfunc_t filter,float support,wrapfunc_t wrap,int gc,float gamma)
specifier|static
name|void
name|scale_image_nearest
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|bpp
parameter_list|,
name|filterfunc_t
name|filter
parameter_list|,
name|float
name|support
parameter_list|,
name|wrapfunc_t
name|wrap
parameter_list|,
name|int
name|gc
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|int
name|srowbytes
init|=
name|sw
operator|*
name|bpp
decl_stmt|;
name|int
name|drowbytes
init|=
name|dw
operator|*
name|bpp
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
operator|++
name|y
control|)
block|{
name|iy
operator|=
operator|(
name|y
operator|*
name|sh
operator|+
name|sh
operator|/
literal|2
operator|)
operator|/
name|dh
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dw
condition|;
operator|++
name|x
control|)
block|{
name|ix
operator|=
operator|(
name|x
operator|*
name|sw
operator|+
name|sw
operator|/
literal|2
operator|)
operator|/
name|dw
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|bpp
condition|;
operator|++
name|n
control|)
block|{
name|dst
index|[
name|y
operator|*
name|drowbytes
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|n
index|]
operator|=
name|src
index|[
name|iy
operator|*
name|srowbytes
operator|+
operator|(
name|ix
operator|*
name|bpp
operator|)
operator|+
name|n
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
DECL|function|scale_image (unsigned char * dst,int dw,int dh,unsigned char * src,int sw,int sh,int bpp,filterfunc_t filter,float support,wrapfunc_t wrap,int gc,float gamma)
specifier|static
name|void
name|scale_image
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|bpp
parameter_list|,
name|filterfunc_t
name|filter
parameter_list|,
name|float
name|support
parameter_list|,
name|wrapfunc_t
name|wrap
parameter_list|,
name|int
name|gc
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
specifier|const
name|float
name|blur
init|=
literal|1.0f
decl_stmt|;
specifier|const
name|float
name|xfactor
init|=
operator|(
name|float
operator|)
name|dw
operator|/
operator|(
name|float
operator|)
name|sw
decl_stmt|;
specifier|const
name|float
name|yfactor
init|=
operator|(
name|float
operator|)
name|dh
operator|/
operator|(
name|float
operator|)
name|sh
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|nmax
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|int
name|sstride
init|=
name|sw
operator|*
name|bpp
decl_stmt|;
name|float
name|center
decl_stmt|,
name|contrib
decl_stmt|,
name|density
decl_stmt|,
name|s
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|row
decl_stmt|,
modifier|*
name|col
decl_stmt|;
name|float
name|xscale
init|=
name|MIN
argument_list|(
name|xfactor
argument_list|,
literal|1.0f
argument_list|)
operator|/
name|blur
decl_stmt|;
name|float
name|yscale
init|=
name|MIN
argument_list|(
name|yfactor
argument_list|,
literal|1.0f
argument_list|)
operator|/
name|blur
decl_stmt|;
name|float
name|xsupport
init|=
name|support
operator|/
name|xscale
decl_stmt|;
name|float
name|ysupport
init|=
name|support
operator|/
name|yscale
decl_stmt|;
if|if
condition|(
name|xsupport
operator|<=
literal|0.5f
condition|)
block|{
name|xsupport
operator|=
literal|0.5f
operator|+
literal|1e-10f
expr_stmt|;
name|xscale
operator|=
literal|1.0f
expr_stmt|;
block|}
if|if
condition|(
name|ysupport
operator|<=
literal|0.5f
condition|)
block|{
name|ysupport
operator|=
literal|0.5f
operator|+
literal|1e-10f
expr_stmt|;
name|yscale
operator|=
literal|1.0f
expr_stmt|;
block|}
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
name|tmp
operator|=
name|g_malloc
argument_list|(
name|sw
operator|*
name|bpp
operator|*
name|omp_get_max_threads
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
name|g_malloc
argument_list|(
name|sw
operator|*
name|bpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|)
pragma|\
name|private
name|(
name|x
name|,
name|y
name|,
name|d
name|,
name|row
name|,
name|col
name|,
name|center
name|,
name|start
name|,
name|stop
name|,
name|nmax
name|,
name|s
name|,
name|i
name|,
name|n
name|,
name|density
name|,
name|r
name|,
name|t
name|,
name|contrib
name|)
endif|#
directive|endif
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
operator|++
name|y
control|)
block|{
comment|/* resample in Y direction to temp buffer */
name|d
operator|=
name|tmp
expr_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
name|d
operator|+=
operator|(
name|sw
operator|*
name|bpp
operator|*
name|omp_get_thread_num
argument_list|()
operator|)
expr_stmt|;
endif|#
directive|endif
name|center
operator|=
operator|(
operator|(
name|float
operator|)
name|y
operator|+
literal|0.5f
operator|)
operator|/
name|yfactor
expr_stmt|;
name|start
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|-
name|ysupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|+
name|ysupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|nmax
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|start
operator|-
name|center
operator|+
literal|0.5f
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sw
condition|;
operator|++
name|x
control|)
block|{
name|col
operator|=
name|src
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
operator|++
name|i
control|)
block|{
name|density
operator|=
literal|0.0f
expr_stmt|;
name|r
operator|=
literal|0.0f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmax
condition|;
operator|++
name|n
control|)
block|{
name|contrib
operator|=
name|filter
argument_list|(
operator|(
name|s
operator|+
name|n
operator|)
operator|*
name|yscale
argument_list|)
expr_stmt|;
name|density
operator|+=
name|contrib
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|t
operator|=
name|col
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sh
argument_list|)
operator|*
name|sstride
operator|)
operator|+
name|i
index|]
expr_stmt|;
else|else
name|t
operator|=
name|linear_to_gamma
argument_list|(
name|gc
argument_list|,
name|col
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sh
argument_list|)
operator|*
name|sstride
operator|)
operator|+
name|i
index|]
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|+=
name|t
operator|*
name|contrib
expr_stmt|;
block|}
if|if
condition|(
name|density
operator|!=
literal|0.0f
operator|&&
name|density
operator|!=
literal|1.0f
condition|)
name|r
operator|/=
name|density
expr_stmt|;
name|r
operator|=
name|MIN
argument_list|(
literal|255
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3
condition|)
name|r
operator|=
name|gamma_to_linear
argument_list|(
name|gc
argument_list|,
name|r
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|d
index|[
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|r
expr_stmt|;
block|}
block|}
comment|/* resample in X direction using temp buffer */
name|row
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dw
condition|;
operator|++
name|x
control|)
block|{
name|center
operator|=
operator|(
operator|(
name|float
operator|)
name|x
operator|+
literal|0.5f
operator|)
operator|/
name|xfactor
expr_stmt|;
name|start
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|-
name|xsupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|+
name|xsupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|nmax
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|start
operator|-
name|center
operator|+
literal|0.5f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
operator|++
name|i
control|)
block|{
name|density
operator|=
literal|0.0f
expr_stmt|;
name|r
operator|=
literal|0.0f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmax
condition|;
operator|++
name|n
control|)
block|{
name|contrib
operator|=
name|filter
argument_list|(
operator|(
name|s
operator|+
name|n
operator|)
operator|*
name|xscale
argument_list|)
expr_stmt|;
name|density
operator|+=
name|contrib
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|t
operator|=
name|row
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sw
argument_list|)
operator|*
name|bpp
operator|)
operator|+
name|i
index|]
expr_stmt|;
else|else
name|t
operator|=
name|linear_to_gamma
argument_list|(
name|gc
argument_list|,
name|row
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sw
argument_list|)
operator|*
name|bpp
operator|)
operator|+
name|i
index|]
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|+=
name|t
operator|*
name|contrib
expr_stmt|;
block|}
if|if
condition|(
name|density
operator|!=
literal|0.0f
operator|&&
name|density
operator|!=
literal|1.0f
condition|)
name|r
operator|/=
name|density
expr_stmt|;
name|r
operator|=
name|MIN
argument_list|(
literal|255
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3
condition|)
name|r
operator|=
name|gamma_to_linear
argument_list|(
name|gc
argument_list|,
name|r
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|d
index|[
operator|(
name|y
operator|*
operator|(
name|dw
operator|*
name|bpp
operator|)
operator|)
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|r
expr_stmt|;
block|}
block|}
block|}
name|g_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * 3D image scaling                                                           *  ******************************************************************************/
end_comment

begin_function
DECL|function|scale_volume_image_nearest (unsigned char * dst,int dw,int dh,int dd,unsigned char * src,int sw,int sh,int sd,int bpp,filterfunc_t filter,float support,wrapfunc_t wrap,int gc,float gamma)
specifier|static
name|void
name|scale_volume_image_nearest
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dd
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|sd
parameter_list|,
name|int
name|bpp
parameter_list|,
name|filterfunc_t
name|filter
parameter_list|,
name|float
name|support
parameter_list|,
name|wrapfunc_t
name|wrap
parameter_list|,
name|int
name|gc
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|,
name|iz
decl_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|dd
condition|;
operator|++
name|z
control|)
block|{
name|iz
operator|=
operator|(
name|z
operator|*
name|sd
operator|+
name|sd
operator|/
literal|2
operator|)
operator|/
name|dd
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
operator|++
name|y
control|)
block|{
name|iy
operator|=
operator|(
name|y
operator|*
name|sh
operator|+
name|sh
operator|/
literal|2
operator|)
operator|/
name|dh
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dw
condition|;
operator|++
name|x
control|)
block|{
name|ix
operator|=
operator|(
name|x
operator|*
name|sw
operator|+
name|sw
operator|/
literal|2
operator|)
operator|/
name|dw
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|bpp
condition|;
operator|++
name|n
control|)
block|{
name|dst
index|[
operator|(
name|z
operator|*
operator|(
name|dw
operator|*
name|dh
operator|)
operator|)
operator|+
operator|(
name|y
operator|*
name|dw
operator|)
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|n
index|]
operator|=
name|src
index|[
operator|(
name|iz
operator|*
operator|(
name|sw
operator|*
name|sh
operator|)
operator|)
operator|+
operator|(
name|iy
operator|*
name|sw
operator|)
operator|+
operator|(
name|ix
operator|*
name|bpp
operator|)
operator|+
name|n
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
DECL|function|scale_volume_image (unsigned char * dst,int dw,int dh,int dd,unsigned char * src,int sw,int sh,int sd,int bpp,filterfunc_t filter,float support,wrapfunc_t wrap,int gc,float gamma)
specifier|static
name|void
name|scale_volume_image
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|dh
parameter_list|,
name|int
name|dd
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|,
name|int
name|sd
parameter_list|,
name|int
name|bpp
parameter_list|,
name|filterfunc_t
name|filter
parameter_list|,
name|float
name|support
parameter_list|,
name|wrapfunc_t
name|wrap
parameter_list|,
name|int
name|gc
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
comment|/* down to a 2D image, use the faster 2D image resampler */
if|if
condition|(
name|dd
operator|==
literal|1
operator|&&
name|sd
operator|==
literal|1
condition|)
block|{
name|scale_image
argument_list|(
name|dst
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
name|src
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|,
name|bpp
argument_list|,
name|filter
argument_list|,
name|support
argument_list|,
name|wrap
argument_list|,
name|gc
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|float
name|blur
init|=
literal|1.0f
decl_stmt|;
specifier|const
name|float
name|xfactor
init|=
operator|(
name|float
operator|)
name|dw
operator|/
operator|(
name|float
operator|)
name|sw
decl_stmt|;
specifier|const
name|float
name|yfactor
init|=
operator|(
name|float
operator|)
name|dh
operator|/
operator|(
name|float
operator|)
name|sh
decl_stmt|;
specifier|const
name|float
name|zfactor
init|=
operator|(
name|float
operator|)
name|dd
operator|/
operator|(
name|float
operator|)
name|sd
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|nmax
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|int
name|sstride
init|=
name|sw
operator|*
name|bpp
decl_stmt|;
name|int
name|zstride
init|=
name|sh
operator|*
name|sw
operator|*
name|bpp
decl_stmt|;
name|float
name|center
decl_stmt|,
name|contrib
decl_stmt|,
name|density
decl_stmt|,
name|s
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|row
decl_stmt|,
modifier|*
name|col
decl_stmt|,
modifier|*
name|slice
decl_stmt|;
name|float
name|xscale
init|=
name|MIN
argument_list|(
name|xfactor
argument_list|,
literal|1.0f
argument_list|)
operator|/
name|blur
decl_stmt|;
name|float
name|yscale
init|=
name|MIN
argument_list|(
name|yfactor
argument_list|,
literal|1.0f
argument_list|)
operator|/
name|blur
decl_stmt|;
name|float
name|zscale
init|=
name|MIN
argument_list|(
name|zfactor
argument_list|,
literal|1.0f
argument_list|)
operator|/
name|blur
decl_stmt|;
name|float
name|xsupport
init|=
name|support
operator|/
name|xscale
decl_stmt|;
name|float
name|ysupport
init|=
name|support
operator|/
name|yscale
decl_stmt|;
name|float
name|zsupport
init|=
name|support
operator|/
name|zscale
decl_stmt|;
if|if
condition|(
name|xsupport
operator|<=
literal|0.5f
condition|)
block|{
name|xsupport
operator|=
literal|0.5f
operator|+
literal|1e-10f
expr_stmt|;
name|xscale
operator|=
literal|1.0f
expr_stmt|;
block|}
if|if
condition|(
name|ysupport
operator|<=
literal|0.5f
condition|)
block|{
name|ysupport
operator|=
literal|0.5f
operator|+
literal|1e-10f
expr_stmt|;
name|yscale
operator|=
literal|1.0f
expr_stmt|;
block|}
if|if
condition|(
name|zsupport
operator|<=
literal|0.5f
condition|)
block|{
name|zsupport
operator|=
literal|0.5f
operator|+
literal|1e-10f
expr_stmt|;
name|zscale
operator|=
literal|1.0f
expr_stmt|;
block|}
name|unsigned
name|char
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|tmp1
operator|=
name|g_malloc
argument_list|(
name|sh
operator|*
name|sw
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|g_malloc
argument_list|(
name|dh
operator|*
name|sw
operator|*
name|bpp
argument_list|)
expr_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|dd
condition|;
operator|++
name|z
control|)
block|{
comment|/* resample in Z direction */
name|d
operator|=
name|tmp1
expr_stmt|;
name|center
operator|=
operator|(
operator|(
name|float
operator|)
name|z
operator|+
literal|0.5f
operator|)
operator|/
name|zfactor
expr_stmt|;
name|start
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|-
name|zsupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|+
name|zsupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|nmax
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|start
operator|-
name|center
operator|+
literal|0.5f
expr_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|)
pragma|\
name|private
name|(
name|x
name|,
name|y
name|,
name|slice
name|,
name|i
name|,
name|n
name|,
name|density
name|,
name|r
name|,
name|t
name|,
name|contrib
name|)
endif|#
directive|endif
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|sh
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sw
condition|;
operator|++
name|x
control|)
block|{
name|slice
operator|=
name|src
operator|+
operator|(
name|y
operator|*
operator|(
name|sw
operator|*
name|bpp
operator|)
operator|)
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
operator|++
name|i
control|)
block|{
name|density
operator|=
literal|0.0f
expr_stmt|;
name|r
operator|=
literal|0.0f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmax
condition|;
operator|++
name|n
control|)
block|{
name|contrib
operator|=
name|filter
argument_list|(
operator|(
name|s
operator|+
name|n
operator|)
operator|*
name|zscale
argument_list|)
expr_stmt|;
name|density
operator|+=
name|contrib
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|t
operator|=
name|slice
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sd
argument_list|)
operator|*
name|zstride
operator|)
operator|+
name|i
index|]
expr_stmt|;
else|else
name|t
operator|=
name|linear_to_gamma
argument_list|(
name|gc
argument_list|,
name|slice
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sd
argument_list|)
operator|*
name|zstride
operator|)
operator|+
name|i
index|]
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|+=
name|t
operator|*
name|contrib
expr_stmt|;
block|}
if|if
condition|(
name|density
operator|!=
literal|0.0f
operator|&&
name|density
operator|!=
literal|1.0f
condition|)
name|r
operator|/=
name|density
expr_stmt|;
name|r
operator|=
name|MIN
argument_list|(
literal|255
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3
condition|)
name|r
operator|=
name|gamma_to_linear
argument_list|(
name|gc
argument_list|,
name|r
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|d
index|[
operator|(
operator|(
name|y
operator|*
name|sw
operator|)
operator|+
name|x
operator|)
operator|*
name|bpp
operator|+
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|r
expr_stmt|;
block|}
block|}
block|}
comment|/* resample in Y direction */
name|d
operator|=
name|tmp2
expr_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|)
pragma|\
name|private
name|(
name|x
name|,
name|y
name|,
name|col
name|,
name|center
name|,
name|start
name|,
name|stop
name|,
name|nmax
name|,
name|s
name|,
name|i
name|,
name|n
name|,
name|density
name|,
name|r
name|,
name|t
name|,
name|contrib
name|)
endif|#
directive|endif
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
operator|++
name|y
control|)
block|{
name|center
operator|=
operator|(
operator|(
name|float
operator|)
name|y
operator|+
literal|0.5f
operator|)
operator|/
name|yfactor
expr_stmt|;
name|start
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|-
name|ysupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|+
name|ysupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|nmax
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|start
operator|-
name|center
operator|+
literal|0.5f
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sw
condition|;
operator|++
name|x
control|)
block|{
name|col
operator|=
name|tmp1
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
operator|++
name|i
control|)
block|{
name|density
operator|=
literal|0.0f
expr_stmt|;
name|r
operator|=
literal|0.0f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmax
condition|;
operator|++
name|n
control|)
block|{
name|contrib
operator|=
name|filter
argument_list|(
operator|(
name|s
operator|+
name|n
operator|)
operator|*
name|yscale
argument_list|)
expr_stmt|;
name|density
operator|+=
name|contrib
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|t
operator|=
name|col
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sh
argument_list|)
operator|*
name|sstride
operator|)
operator|+
name|i
index|]
expr_stmt|;
else|else
name|t
operator|=
name|linear_to_gamma
argument_list|(
name|gc
argument_list|,
name|col
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sh
argument_list|)
operator|*
name|sstride
operator|)
operator|+
name|i
index|]
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|+=
name|t
operator|*
name|contrib
expr_stmt|;
block|}
if|if
condition|(
name|density
operator|!=
literal|0.0f
operator|&&
name|density
operator|!=
literal|1.0f
condition|)
name|r
operator|/=
name|density
expr_stmt|;
name|r
operator|=
name|MIN
argument_list|(
literal|255
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3
condition|)
name|r
operator|=
name|gamma_to_linear
argument_list|(
name|gc
argument_list|,
name|r
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|d
index|[
operator|(
operator|(
name|y
operator|*
name|sw
operator|)
operator|+
name|x
operator|)
operator|*
name|bpp
operator|+
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|r
expr_stmt|;
block|}
block|}
block|}
comment|/* resample in X direction */
name|d
operator|=
name|dst
expr_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|)
pragma|\
name|private
name|(
name|x
name|,
name|y
name|,
name|row
name|,
name|center
name|,
name|start
name|,
name|stop
name|,
name|nmax
name|,
name|s
name|,
name|i
name|,
name|n
name|,
name|density
name|,
name|r
name|,
name|t
name|,
name|contrib
name|)
endif|#
directive|endif
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dh
condition|;
operator|++
name|y
control|)
block|{
name|row
operator|=
name|tmp2
operator|+
operator|(
name|y
operator|*
name|sstride
operator|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dw
condition|;
operator|++
name|x
control|)
block|{
name|center
operator|=
operator|(
operator|(
name|float
operator|)
name|x
operator|+
literal|0.5f
operator|)
operator|/
name|xfactor
expr_stmt|;
name|start
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|-
name|xsupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|int
call|)
argument_list|(
name|center
operator|+
name|xsupport
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|nmax
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|start
operator|-
name|center
operator|+
literal|0.5f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
operator|++
name|i
control|)
block|{
name|density
operator|=
literal|0.0f
expr_stmt|;
name|r
operator|=
literal|0.0f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmax
condition|;
operator|++
name|n
control|)
block|{
name|contrib
operator|=
name|filter
argument_list|(
operator|(
name|s
operator|+
name|n
operator|)
operator|*
name|xscale
argument_list|)
expr_stmt|;
name|density
operator|+=
name|contrib
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|t
operator|=
name|row
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sw
argument_list|)
operator|*
name|bpp
operator|)
operator|+
name|i
index|]
expr_stmt|;
else|else
name|t
operator|=
name|linear_to_gamma
argument_list|(
name|gc
argument_list|,
name|row
index|[
operator|(
name|wrap
argument_list|(
name|start
operator|+
name|n
argument_list|,
name|sw
argument_list|)
operator|*
name|bpp
operator|)
operator|+
name|i
index|]
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|r
operator|+=
name|t
operator|*
name|contrib
expr_stmt|;
block|}
if|if
condition|(
name|density
operator|!=
literal|0.0f
operator|&&
name|density
operator|!=
literal|1.0f
condition|)
name|r
operator|/=
name|density
expr_stmt|;
name|r
operator|=
name|MIN
argument_list|(
literal|255
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3
condition|)
name|r
operator|=
name|gamma_to_linear
argument_list|(
name|gc
argument_list|,
name|r
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|d
index|[
operator|(
operator|(
name|z
operator|*
name|dh
operator|*
name|dw
operator|)
operator|+
operator|(
name|y
operator|*
name|dw
operator|)
operator|+
name|x
operator|)
operator|*
name|bpp
operator|+
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|r
expr_stmt|;
block|}
block|}
block|}
block|}
name|g_free
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * filter lookup table                                                        *  ******************************************************************************/
end_comment

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2761ae0f0108
block|{
DECL|member|filter
name|int
name|filter
decl_stmt|;
DECL|member|func
name|filterfunc_t
name|func
decl_stmt|;
DECL|member|support
name|float
name|support
decl_stmt|;
DECL|variable|filters
block|}
name|filters
index|[]
init|=
block|{
block|{
name|DDS_MIPMAP_FILTER_BOX
block|,
name|box_filter
block|,
literal|0.5f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_TRIANGLE
block|,
name|triangle_filter
block|,
literal|1.0f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_QUADRATIC
block|,
name|quadratic_filter
block|,
literal|1.5f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_BSPLINE
block|,
name|bspline_filter
block|,
literal|2.0f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_MITCHELL
block|,
name|mitchell_filter
block|,
literal|2.0f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_LANCZOS
block|,
name|lanczos_filter
block|,
literal|3.0f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_KAISER
block|,
name|kaiser_filter
block|,
literal|3.0f
block|}
block|,
block|{
name|DDS_MIPMAP_FILTER_MAX
block|,
name|NULL
block|,
literal|0.0f
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Alpha test coverage - portion of visible texels after alpha test:  *   if (texel_alpha< alpha_test_threshold)  *      discard;  */
end_comment

begin_function
DECL|function|calc_alpha_test_coverage (unsigned char * src,unsigned int width,unsigned int height,int bpp,float alpha_test_threshold,float alpha_scale)
specifier|static
name|float
name|calc_alpha_test_coverage
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|,
name|float
name|alpha_test_threshold
parameter_list|,
name|float
name|alpha_scale
parameter_list|)
block|{
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|rowbytes
init|=
name|width
operator|*
name|bpp
decl_stmt|;
name|int
name|coverage
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|alpha_channel_idx
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|bpp
operator|<=
name|alpha_channel_idx
condition|)
block|{
comment|/* No alpha channel */
return|return
literal|1.f
return|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|float
name|alpha
init|=
name|src
index|[
name|y
operator|*
name|rowbytes
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|alpha_channel_idx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|alpha
operator|*
name|alpha_scale
operator|)
operator|>=
operator|(
name|alpha_test_threshold
operator|*
literal|255
operator|)
condition|)
block|{
operator|++
name|coverage
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|float
operator|)
name|coverage
operator|/
operator|(
name|width
operator|*
name|height
operator|)
return|;
block|}
end_function

begin_function
DECL|function|scale_alpha_to_coverage (unsigned char * img,unsigned int width,unsigned int height,int bpp,float desired_coverage,float alpha_test_threshold)
specifier|static
name|void
name|scale_alpha_to_coverage
parameter_list|(
name|unsigned
name|char
modifier|*
name|img
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|,
name|float
name|desired_coverage
parameter_list|,
name|float
name|alpha_test_threshold
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|const
name|int
name|rowbytes
init|=
name|width
operator|*
name|bpp
decl_stmt|;
specifier|const
name|int
name|alpha_channel_idx
init|=
literal|3
decl_stmt|;
name|float
name|min_alpha_scale
init|=
literal|0.0f
decl_stmt|;
name|float
name|max_alpha_scale
init|=
literal|4.0f
decl_stmt|;
name|float
name|alpha_scale
init|=
literal|1.0f
decl_stmt|;
if|if
condition|(
name|bpp
operator|<=
name|alpha_channel_idx
condition|)
block|{
comment|/* No alpha channel */
return|return;
block|}
comment|/* Binary search */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|float
name|cur_coverage
init|=
name|calc_alpha_test_coverage
argument_list|(
name|img
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|,
name|alpha_test_threshold
argument_list|,
name|alpha_scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_coverage
operator|<
name|desired_coverage
condition|)
block|{
name|min_alpha_scale
operator|=
name|alpha_scale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_coverage
operator|>
name|desired_coverage
condition|)
block|{
name|max_alpha_scale
operator|=
name|alpha_scale
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|alpha_scale
operator|=
operator|(
name|min_alpha_scale
operator|+
name|max_alpha_scale
operator|)
operator|/
literal|2
expr_stmt|;
block|}
comment|/* Scale alpha channel */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
name|float
name|new_alpha
init|=
name|img
index|[
name|y
operator|*
name|rowbytes
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|alpha_channel_idx
index|]
operator|*
name|alpha_scale
decl_stmt|;
if|if
condition|(
name|new_alpha
operator|>
literal|255.0f
condition|)
block|{
name|new_alpha
operator|=
literal|255.0f
expr_stmt|;
block|}
name|img
index|[
name|y
operator|*
name|rowbytes
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
operator|+
name|alpha_channel_idx
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|new_alpha
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * mipmap generation                                                          *  ******************************************************************************/
end_comment

begin_function
DECL|function|generate_mipmaps (unsigned char * dst,unsigned char * src,unsigned int width,unsigned int height,int bpp,int indexed,int mipmaps,int filter,int wrap,int gc,float gamma,int preserve_alpha_coverage,float alpha_test_threshold)
name|int
name|generate_mipmaps
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|indexed
parameter_list|,
name|int
name|mipmaps
parameter_list|,
name|int
name|filter
parameter_list|,
name|int
name|wrap
parameter_list|,
name|int
name|gc
parameter_list|,
name|float
name|gamma
parameter_list|,
name|int
name|preserve_alpha_coverage
parameter_list|,
name|float
name|alpha_test_threshold
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|dw
decl_stmt|,
name|dh
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|mipmapfunc_t
name|mipmap_func
init|=
name|NULL
decl_stmt|;
name|filterfunc_t
name|filter_func
init|=
name|NULL
decl_stmt|;
name|wrapfunc_t
name|wrap_func
init|=
name|NULL
decl_stmt|;
name|float
name|support
init|=
literal|0.0f
decl_stmt|;
specifier|const
name|int
name|has_alpha
init|=
operator|(
name|bpp
operator|>=
literal|3
operator|)
decl_stmt|;
name|float
name|alpha_test_coverage
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|indexed
operator|||
name|filter
operator|==
name|DDS_MIPMAP_FILTER_NEAREST
condition|)
block|{
name|mipmap_func
operator|=
name|scale_image_nearest
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|filter
operator|<=
name|DDS_MIPMAP_FILTER_DEFAULT
operator|)
operator|||
operator|(
name|filter
operator|>=
name|DDS_MIPMAP_FILTER_MAX
operator|)
condition|)
name|filter
operator|=
name|DDS_MIPMAP_FILTER_BOX
expr_stmt|;
name|mipmap_func
operator|=
name|scale_image
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|filters
index|[
name|i
index|]
operator|.
name|filter
operator|!=
name|DDS_MIPMAP_FILTER_MAX
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|filter
operator|==
name|filters
index|[
name|i
index|]
operator|.
name|filter
condition|)
block|{
name|filter_func
operator|=
name|filters
index|[
name|i
index|]
operator|.
name|func
expr_stmt|;
name|support
operator|=
name|filters
index|[
name|i
index|]
operator|.
name|support
expr_stmt|;
break|break;
block|}
block|}
block|}
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|DDS_MIPMAP_WRAP_MIRROR
case|:
name|wrap_func
operator|=
name|wrap_mirror
expr_stmt|;
break|break;
case|case
name|DDS_MIPMAP_WRAP_REPEAT
case|:
name|wrap_func
operator|=
name|wrap_repeat
expr_stmt|;
break|break;
case|case
name|DDS_MIPMAP_WRAP_CLAMP
case|:
name|wrap_func
operator|=
name|wrap_clamp
expr_stmt|;
break|break;
default|default:
name|wrap_func
operator|=
name|wrap_clamp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|has_alpha
operator|&&
name|preserve_alpha_coverage
condition|)
block|{
name|alpha_test_coverage
operator|=
name|calc_alpha_test_coverage
argument_list|(
name|src
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|,
name|alpha_test_threshold
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|width
operator|*
name|height
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|s
operator|=
name|dst
expr_stmt|;
name|d
operator|=
name|dst
operator|+
operator|(
name|width
operator|*
name|height
operator|*
name|bpp
operator|)
expr_stmt|;
name|sw
operator|=
name|width
expr_stmt|;
name|sh
operator|=
name|height
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mipmaps
condition|;
operator|++
name|i
control|)
block|{
name|dw
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|sw
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dh
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|sh
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|mipmap_func
argument_list|(
name|d
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
name|s
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|,
name|bpp
argument_list|,
name|filter_func
argument_list|,
name|support
argument_list|,
name|wrap_func
argument_list|,
name|gc
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_alpha
operator|&&
name|preserve_alpha_coverage
condition|)
block|{
name|scale_alpha_to_coverage
argument_list|(
name|d
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
name|bpp
argument_list|,
name|alpha_test_coverage
argument_list|,
name|alpha_test_threshold
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|d
expr_stmt|;
name|sw
operator|=
name|dw
expr_stmt|;
name|sh
operator|=
name|dh
expr_stmt|;
name|d
operator|+=
operator|(
name|dw
operator|*
name|dh
operator|*
name|bpp
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
DECL|function|generate_volume_mipmaps (unsigned char * dst,unsigned char * src,unsigned int width,unsigned int height,unsigned int depth,int bpp,int indexed,int mipmaps,int filter,int wrap,int gc,float gamma)
name|int
name|generate_volume_mipmaps
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|int
name|height
parameter_list|,
name|unsigned
name|int
name|depth
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|indexed
parameter_list|,
name|int
name|mipmaps
parameter_list|,
name|int
name|filter
parameter_list|,
name|int
name|wrap
parameter_list|,
name|int
name|gc
parameter_list|,
name|float
name|gamma
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|sd
decl_stmt|;
name|unsigned
name|int
name|dw
decl_stmt|,
name|dh
decl_stmt|,
name|dd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|volmipmapfunc_t
name|mipmap_func
init|=
name|NULL
decl_stmt|;
name|filterfunc_t
name|filter_func
init|=
name|NULL
decl_stmt|;
name|wrapfunc_t
name|wrap_func
init|=
name|NULL
decl_stmt|;
name|float
name|support
init|=
literal|0.0f
decl_stmt|;
if|if
condition|(
name|indexed
operator|||
name|filter
operator|==
name|DDS_MIPMAP_FILTER_NEAREST
condition|)
block|{
name|mipmap_func
operator|=
name|scale_volume_image_nearest
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|filter
operator|<=
name|DDS_MIPMAP_FILTER_DEFAULT
operator|)
operator|||
operator|(
name|filter
operator|>=
name|DDS_MIPMAP_FILTER_MAX
operator|)
condition|)
name|filter
operator|=
name|DDS_MIPMAP_FILTER_BOX
expr_stmt|;
name|mipmap_func
operator|=
name|scale_volume_image
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|filters
index|[
name|i
index|]
operator|.
name|filter
operator|!=
name|DDS_MIPMAP_FILTER_MAX
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|filter
operator|==
name|filters
index|[
name|i
index|]
operator|.
name|filter
condition|)
block|{
name|filter_func
operator|=
name|filters
index|[
name|i
index|]
operator|.
name|func
expr_stmt|;
name|support
operator|=
name|filters
index|[
name|i
index|]
operator|.
name|support
expr_stmt|;
break|break;
block|}
block|}
block|}
switch|switch
condition|(
name|wrap
condition|)
block|{
case|case
name|DDS_MIPMAP_WRAP_MIRROR
case|:
name|wrap_func
operator|=
name|wrap_mirror
expr_stmt|;
break|break;
case|case
name|DDS_MIPMAP_WRAP_REPEAT
case|:
name|wrap_func
operator|=
name|wrap_repeat
expr_stmt|;
break|break;
case|case
name|DDS_MIPMAP_WRAP_CLAMP
case|:
name|wrap_func
operator|=
name|wrap_clamp
expr_stmt|;
break|break;
default|default:
name|wrap_func
operator|=
name|wrap_clamp
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|width
operator|*
name|height
operator|*
name|depth
operator|*
name|bpp
argument_list|)
expr_stmt|;
name|s
operator|=
name|dst
expr_stmt|;
name|d
operator|=
name|dst
operator|+
operator|(
name|width
operator|*
name|height
operator|*
name|depth
operator|*
name|bpp
operator|)
expr_stmt|;
name|sw
operator|=
name|width
expr_stmt|;
name|sh
operator|=
name|height
expr_stmt|;
name|sd
operator|=
name|depth
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mipmaps
condition|;
operator|++
name|i
control|)
block|{
name|dw
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|sw
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dh
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|sh
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dd
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|sd
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|mipmap_func
argument_list|(
name|d
argument_list|,
name|dw
argument_list|,
name|dh
argument_list|,
name|dd
argument_list|,
name|s
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|,
name|sd
argument_list|,
name|bpp
argument_list|,
name|filter_func
argument_list|,
name|support
argument_list|,
name|wrap_func
argument_list|,
name|gc
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|s
operator|=
name|d
expr_stmt|;
name|sw
operator|=
name|dw
expr_stmt|;
name|sh
operator|=
name|dh
expr_stmt|;
name|sd
operator|=
name|dd
expr_stmt|;
name|d
operator|+=
operator|(
name|dw
operator|*
name|dh
operator|*
name|dd
operator|*
name|bpp
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

