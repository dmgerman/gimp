begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	DDS GIMP plugin  	Copyright (C) 2004-2012 Shawn Kirst<skirst@gmail.com>,    with parts (C) 2003 Arne Reuter<homepage@arnereuter.de> where specified.  	This program is free software; you can redistribute it and/or 	modify it under the terms of the GNU General Public 	License as published by the Free Software Foundation; either 	version 2 of the License, or (at your option) any later version.  	This program is distributed in the hope that it will be useful, 	but WITHOUT ANY WARRANTY; without even the implied warranty of 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 	General Public License for more details.  	You should have received a copy of the GNU General Public License 	along with this program; see the file COPYING.  If not, write to 	the Free Software Foundation, 51 Franklin Street, Fifth Floor 	Boston, MA 02110-1301, USA. */
end_comment

begin_comment
comment|/*  * Parts of this code have been generously released in the public domain  * by Fabian 'ryg' Giesen.  The original code can be found (at the time  * of writing) here:  http://mollyrocket.com/forums/viewtopic.php?t=392  *  * For more information about this code, see the README.dxt file that  * came with the source.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|"dds.h"
end_include

begin_include
include|#
directive|include
file|"dxt.h"
end_include

begin_include
include|#
directive|include
file|"endian_rw.h"
end_include

begin_include
include|#
directive|include
file|"mipmap.h"
end_include

begin_include
include|#
directive|include
file|"imath.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"dxt_tables.h"
end_include

begin_define
DECL|macro|SWAP (a,b)
define|#
directive|define
name|SWAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { typeof(a) t; t = a; a = b; b = t; } while(0)
end_define

begin_comment
comment|/* SIMD constants */
end_comment

begin_decl_stmt
DECL|variable|V4ZERO
specifier|static
specifier|const
name|vec4_t
name|V4ZERO
init|=
name|VEC4_CONST1
argument_list|(
literal|0.0f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4ONE
specifier|static
specifier|const
name|vec4_t
name|V4ONE
init|=
name|VEC4_CONST1
argument_list|(
literal|1.0f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4HALF
specifier|static
specifier|const
name|vec4_t
name|V4HALF
init|=
name|VEC4_CONST1
argument_list|(
literal|0.5f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4ONETHIRD
specifier|static
specifier|const
name|vec4_t
name|V4ONETHIRD
init|=
name|VEC4_CONST3
argument_list|(
literal|1.0f
operator|/
literal|3.0f
argument_list|,
literal|1.0f
operator|/
literal|3.0f
argument_list|,
literal|1.0f
operator|/
literal|3.0f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4TWOTHIRDS
specifier|static
specifier|const
name|vec4_t
name|V4TWOTHIRDS
init|=
name|VEC4_CONST3
argument_list|(
literal|2.0f
operator|/
literal|3.0f
argument_list|,
literal|2.0f
operator|/
literal|3.0f
argument_list|,
literal|2.0f
operator|/
literal|3.0f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4GRID
specifier|static
specifier|const
name|vec4_t
name|V4GRID
init|=
name|VEC4_CONST3
argument_list|(
literal|31.0f
argument_list|,
literal|63.0f
argument_list|,
literal|31.0f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4GRIDRCP
specifier|static
specifier|const
name|vec4_t
name|V4GRIDRCP
init|=
name|VEC4_CONST3
argument_list|(
literal|1.0f
operator|/
literal|31.0f
argument_list|,
literal|1.0f
operator|/
literal|63.0f
argument_list|,
literal|1.0f
operator|/
literal|31.0f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|V4EPSILON
specifier|static
specifier|const
name|vec4_t
name|V4EPSILON
init|=
name|VEC4_CONST1
argument_list|(
literal|1e-04f
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27440b5d0108
block|{
DECL|member|single
name|unsigned
name|int
name|single
decl_stmt|;
DECL|member|alphamask
name|unsigned
name|int
name|alphamask
decl_stmt|;
DECL|member|points
name|vec4_t
name|points
index|[
literal|16
index|]
decl_stmt|;
DECL|member|palette
name|vec4_t
name|palette
index|[
literal|4
index|]
decl_stmt|;
DECL|member|max
name|vec4_t
name|max
decl_stmt|;
DECL|member|min
name|vec4_t
name|min
decl_stmt|;
DECL|member|metric
name|vec4_t
name|metric
decl_stmt|;
DECL|typedef|dxtblock_t
block|}
name|dxtblock_t
typedef|;
end_typedef

begin_comment
comment|/* extract 4x4 BGRA block */
end_comment

begin_function
DECL|function|extract_block (const unsigned char * src,int x,int y,int w,int h,unsigned char * block)
specifier|static
name|void
name|extract_block
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|unsigned
name|char
modifier|*
name|block
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|bw
init|=
name|MIN
argument_list|(
name|w
operator|-
name|x
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|bh
init|=
name|MIN
argument_list|(
name|h
operator|-
name|y
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|bx
decl_stmt|,
name|by
decl_stmt|;
specifier|const
name|int
name|rem
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|by
operator|=
name|rem
index|[
operator|(
name|bh
operator|-
literal|1
operator|)
operator|*
literal|4
operator|+
name|i
index|]
operator|+
name|y
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|bx
operator|=
name|rem
index|[
operator|(
name|bw
operator|-
literal|1
operator|)
operator|*
literal|4
operator|+
name|j
index|]
operator|+
name|x
expr_stmt|;
name|block
index|[
operator|(
name|i
operator|*
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
operator|+
literal|0
index|]
operator|=
name|src
index|[
operator|(
name|by
operator|*
operator|(
name|w
operator|*
literal|4
operator|)
operator|)
operator|+
operator|(
name|bx
operator|*
literal|4
operator|)
operator|+
literal|0
index|]
expr_stmt|;
name|block
index|[
operator|(
name|i
operator|*
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
operator|+
literal|1
index|]
operator|=
name|src
index|[
operator|(
name|by
operator|*
operator|(
name|w
operator|*
literal|4
operator|)
operator|)
operator|+
operator|(
name|bx
operator|*
literal|4
operator|)
operator|+
literal|1
index|]
expr_stmt|;
name|block
index|[
operator|(
name|i
operator|*
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
operator|+
literal|2
index|]
operator|=
name|src
index|[
operator|(
name|by
operator|*
operator|(
name|w
operator|*
literal|4
operator|)
operator|)
operator|+
operator|(
name|bx
operator|*
literal|4
operator|)
operator|+
literal|2
index|]
expr_stmt|;
name|block
index|[
operator|(
name|i
operator|*
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
operator|+
literal|3
index|]
operator|=
name|src
index|[
operator|(
name|by
operator|*
operator|(
name|w
operator|*
literal|4
operator|)
operator|)
operator|+
operator|(
name|bx
operator|*
literal|4
operator|)
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* pack BGR8 to RGB565 */
end_comment

begin_function
DECL|function|pack_rgb565 (const unsigned char * c)
specifier|static
specifier|inline
name|unsigned
name|short
name|pack_rgb565
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|mul8bit
argument_list|(
name|c
index|[
literal|2
index|]
argument_list|,
literal|31
argument_list|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|mul8bit
argument_list|(
name|c
index|[
literal|1
index|]
argument_list|,
literal|63
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|mul8bit
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|,
literal|31
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* unpack RGB565 to BGR */
end_comment

begin_function
DECL|function|unpack_rgb565 (unsigned char * dst,unsigned short v)
specifier|static
name|void
name|unpack_rgb565
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|short
name|v
parameter_list|)
block|{
name|int
name|r
init|=
operator|(
name|v
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
decl_stmt|;
name|int
name|g
init|=
operator|(
name|v
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|int
name|b
init|=
operator|(
name|v
operator|)
operator|&
literal|0x1f
decl_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|b
operator|<<
literal|3
operator|)
operator||
operator|(
name|b
operator|>>
literal|2
operator|)
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|g
operator|<<
literal|2
operator|)
operator||
operator|(
name|g
operator|>>
literal|4
operator|)
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|r
operator|<<
literal|3
operator|)
operator||
operator|(
name|r
operator|>>
literal|2
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* linear interpolation at 1/3 point between a and b */
end_comment

begin_function
DECL|function|lerp_rgb13 (unsigned char * dst,unsigned char * a,unsigned char * b)
specifier|static
name|void
name|lerp_rgb13
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
literal|0
block|dst[0] = blerp(a[0], b[0], 0x55);    dst[1] = blerp(a[1], b[1], 0x55);    dst[2] = blerp(a[2], b[2], 0x55);
else|#
directive|else
comment|/*    * according to the S3TC/DX10 specs, this is the correct way to do the    * interpolation (with no rounding bias)    *    * dst = (2 * a + b) / 3;    */
name|dst
index|[
literal|0
index|]
operator|=
operator|(
literal|2
operator|*
name|a
index|[
literal|0
index|]
operator|+
name|b
index|[
literal|0
index|]
operator|)
operator|/
literal|3
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
literal|2
operator|*
name|a
index|[
literal|1
index|]
operator|+
name|b
index|[
literal|1
index|]
operator|)
operator|/
literal|3
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
literal|2
operator|*
name|a
index|[
literal|2
index|]
operator|+
name|b
index|[
literal|2
index|]
operator|)
operator|/
literal|3
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
DECL|function|vec4_endpoints_to_565 (int * start,int * end,const vec4_t a,const vec4_t b)
specifier|static
name|void
name|vec4_endpoints_to_565
parameter_list|(
name|int
modifier|*
name|start
parameter_list|,
name|int
modifier|*
name|end
parameter_list|,
specifier|const
name|vec4_t
name|a
parameter_list|,
specifier|const
name|vec4_t
name|b
parameter_list|)
block|{
name|int
name|c
index|[
literal|8
index|]
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|16
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|vec4_t
name|ta
init|=
name|a
operator|*
name|V4GRID
operator|+
name|V4HALF
decl_stmt|;
name|vec4_t
name|tb
init|=
name|b
operator|*
name|V4GRID
operator|+
name|V4HALF
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_SSE
ifdef|#
directive|ifdef
name|__SSE2__
specifier|const
name|__m128i
name|C565
init|=
name|_mm_setr_epi16
argument_list|(
literal|31
argument_list|,
literal|63
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|,
literal|63
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|__m128i
name|ia
init|=
name|_mm_cvttps_epi32
argument_list|(
name|ta
argument_list|)
decl_stmt|;
name|__m128i
name|ib
init|=
name|_mm_cvttps_epi32
argument_list|(
name|tb
argument_list|)
decl_stmt|;
name|__m128i
name|zero
init|=
name|_mm_setzero_si128
argument_list|()
decl_stmt|;
name|__m128i
name|words
init|=
name|_mm_packs_epi32
argument_list|(
name|ia
argument_list|,
name|ib
argument_list|)
decl_stmt|;
name|words
operator|=
name|_mm_min_epi16
argument_list|(
name|C565
argument_list|,
name|_mm_max_epi16
argument_list|(
name|zero
argument_list|,
name|words
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__m128i
operator|*
operator|)
operator|&
name|c
index|[
literal|0
index|]
operator|)
operator|=
name|_mm_unpacklo_epi16
argument_list|(
name|words
argument_list|,
name|zero
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__m128i
operator|*
operator|)
operator|&
name|c
index|[
literal|4
index|]
operator|)
operator|=
name|_mm_unpackhi_epi16
argument_list|(
name|words
argument_list|,
name|zero
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|__m64
name|C565
init|=
name|_mm_setr_pi16
argument_list|(
literal|31
argument_list|,
literal|63
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|__m64
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|c0
decl_stmt|,
name|c1
decl_stmt|;
name|__m64
name|zero
init|=
name|_mm_setzero_si64
argument_list|()
decl_stmt|;
name|lo
operator|=
name|_mm_cvttps_pi32
argument_list|(
name|ta
argument_list|)
expr_stmt|;
name|hi
operator|=
name|_mm_cvttps_pi32
argument_list|(
name|_mm_movehl_ps
argument_list|(
name|ta
argument_list|,
name|ta
argument_list|)
argument_list|)
expr_stmt|;
name|c0
operator|=
name|_mm_packs_pi32
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|_mm_cvttps_pi32
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|hi
operator|=
name|_mm_cvttps_pi32
argument_list|(
name|_mm_movehl_ps
argument_list|(
name|tb
argument_list|,
name|tb
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|_mm_packs_pi32
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|c0
operator|=
name|_mm_min_pi16
argument_list|(
name|C565
argument_list|,
name|_mm_max_pi16
argument_list|(
name|zero
argument_list|,
name|c0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|_mm_min_pi16
argument_list|(
name|C565
argument_list|,
name|_mm_max_pi16
argument_list|(
name|zero
argument_list|,
name|c1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__m64
operator|*
operator|)
operator|&
name|c
index|[
literal|0
index|]
operator|)
operator|=
name|_mm_unpacklo_pi16
argument_list|(
name|c0
argument_list|,
name|zero
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__m64
operator|*
operator|)
operator|&
name|c
index|[
literal|2
index|]
operator|)
operator|=
name|_mm_unpackhi_pi16
argument_list|(
name|c0
argument_list|,
name|zero
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__m64
operator|*
operator|)
operator|&
name|c
index|[
literal|4
index|]
operator|)
operator|=
name|_mm_unpacklo_pi16
argument_list|(
name|c1
argument_list|,
name|zero
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__m64
operator|*
operator|)
operator|&
name|c
index|[
literal|6
index|]
operator|)
operator|=
name|_mm_unpackhi_pi16
argument_list|(
name|c1
argument_list|,
name|zero
argument_list|)
expr_stmt|;
name|_mm_empty
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|ta
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|4
index|]
operator|=
operator|(
name|int
operator|)
name|tb
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|ta
index|[
literal|1
index|]
expr_stmt|;
name|c
index|[
literal|5
index|]
operator|=
operator|(
name|int
operator|)
name|tb
index|[
literal|1
index|]
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|)
name|ta
index|[
literal|2
index|]
expr_stmt|;
name|c
index|[
literal|6
index|]
operator|=
operator|(
name|int
operator|)
name|tb
index|[
literal|2
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|MIN
argument_list|(
literal|31
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|c
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|MIN
argument_list|(
literal|63
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|c
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
name|MIN
argument_list|(
literal|31
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|c
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
index|[
literal|4
index|]
operator|=
name|MIN
argument_list|(
literal|31
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|c
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
index|[
literal|5
index|]
operator|=
name|MIN
argument_list|(
literal|63
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|c
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
index|[
literal|6
index|]
operator|=
name|MIN
argument_list|(
literal|31
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|c
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|start
operator|=
operator|(
operator|(
name|c
index|[
literal|2
index|]
operator|<<
literal|11
operator|)
operator||
operator|(
name|c
index|[
literal|1
index|]
operator|<<
literal|5
operator|)
operator||
name|c
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
operator|(
name|c
index|[
literal|6
index|]
operator|<<
literal|11
operator|)
operator||
operator|(
name|c
index|[
literal|5
index|]
operator|<<
literal|5
operator|)
operator||
name|c
index|[
literal|4
index|]
operator|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|dxtblock_init (dxtblock_t * dxtb,const unsigned char * block,int flags)
specifier|static
name|void
name|dxtblock_init
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|c0
decl_stmt|,
name|c
decl_stmt|;
name|int
name|bc1
init|=
operator|(
name|flags
operator|&
name|DXT_BC1
operator|)
decl_stmt|;
name|float
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|vec4_t
name|min
decl_stmt|,
name|max
decl_stmt|,
name|center
decl_stmt|,
name|t
decl_stmt|,
name|cov
decl_stmt|,
name|inset
decl_stmt|;
name|dxtb
operator|->
name|single
operator|=
literal|1
expr_stmt|;
name|dxtb
operator|->
name|alphamask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DXT_PERCEPTUAL
condition|)
comment|/* ITU-R BT.709 luma coefficents */
name|dxtb
operator|->
name|metric
operator|=
name|vec4_set
argument_list|(
literal|0.2126f
argument_list|,
literal|0.7152f
argument_list|,
literal|0.0722f
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
else|else
name|dxtb
operator|->
name|metric
operator|=
name|vec4_set
argument_list|(
literal|1.0f
argument_list|,
literal|1.0f
argument_list|,
literal|1.0f
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|c0
operator|=
name|GETL24
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bc1
operator|&&
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|<
literal|128
operator|)
condition|)
name|dxtb
operator|->
name|alphamask
operator||=
operator|(
literal|3
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|float
operator|)
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|/
literal|255.0f
expr_stmt|;
name|y
operator|=
operator|(
name|float
operator|)
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|/
literal|255.0f
expr_stmt|;
name|z
operator|=
operator|(
name|float
operator|)
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|/
literal|255.0f
expr_stmt|;
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|=
name|vec4_set
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETL24
argument_list|(
operator|&
name|block
index|[
literal|4
operator|*
name|i
index|]
argument_list|)
expr_stmt|;
name|dxtb
operator|->
name|single
operator|=
name|dxtb
operator|->
name|single
operator|&&
operator|(
name|c
operator|==
name|c0
operator|)
expr_stmt|;
block|}
comment|// no need to continue if this is a single color block
if|if
condition|(
name|dxtb
operator|->
name|single
condition|)
return|return;
name|min
operator|=
name|vec4_set1
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
name|max
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
comment|// get bounding box extents
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|min
operator|=
name|vec4_min
argument_list|(
name|min
argument_list|,
name|dxtb
operator|->
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|max
operator|=
name|vec4_max
argument_list|(
name|max
argument_list|,
name|dxtb
operator|->
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// select diagonal
name|center
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|*
name|V4HALF
expr_stmt|;
name|cov
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|=
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|center
expr_stmt|;
name|cov
operator|+=
name|t
operator|*
name|vec4_splatz
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_SSE
block|{
name|__m128
name|mask
decl_stmt|,
name|tmp
decl_stmt|;
comment|// get mask
name|mask
operator|=
name|_mm_cmplt_ps
argument_list|(
name|cov
argument_list|,
name|_mm_setzero_ps
argument_list|()
argument_list|)
expr_stmt|;
comment|// clear high bits (z, w)
name|mask
operator|=
name|_mm_movelh_ps
argument_list|(
name|mask
argument_list|,
name|_mm_setzero_ps
argument_list|()
argument_list|)
expr_stmt|;
comment|// mask and combine
name|tmp
operator|=
name|_mm_or_ps
argument_list|(
name|_mm_and_ps
argument_list|(
name|mask
argument_list|,
name|min
argument_list|)
argument_list|,
name|_mm_andnot_ps
argument_list|(
name|mask
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|min
operator|=
name|_mm_or_ps
argument_list|(
name|_mm_and_ps
argument_list|(
name|mask
argument_list|,
name|max
argument_list|)
argument_list|,
name|_mm_andnot_ps
argument_list|(
name|mask
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
name|tmp
expr_stmt|;
block|}
else|#
directive|else
block|{
name|float
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|y0
decl_stmt|,
name|y1
decl_stmt|;
name|x0
operator|=
name|max
index|[
literal|0
index|]
expr_stmt|;
name|y0
operator|=
name|max
index|[
literal|1
index|]
expr_stmt|;
name|x1
operator|=
name|min
index|[
literal|0
index|]
expr_stmt|;
name|y1
operator|=
name|min
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cov
index|[
literal|0
index|]
operator|<
literal|0
condition|)
name|SWAP
argument_list|(
name|x0
argument_list|,
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cov
index|[
literal|1
index|]
operator|<
literal|0
condition|)
name|SWAP
argument_list|(
name|y0
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|max
index|[
literal|0
index|]
operator|=
name|x0
expr_stmt|;
name|max
index|[
literal|1
index|]
operator|=
name|y0
expr_stmt|;
name|min
index|[
literal|0
index|]
operator|=
name|x1
expr_stmt|;
name|min
index|[
literal|1
index|]
operator|=
name|y1
expr_stmt|;
block|}
endif|#
directive|endif
comment|// inset bounding box and clamp to [0,1]
name|inset
operator|=
operator|(
name|max
operator|-
name|min
operator|)
operator|*
name|vec4_set1
argument_list|(
literal|1.0f
operator|/
literal|16.0f
argument_list|)
operator|-
name|vec4_set1
argument_list|(
operator|(
literal|8.0f
operator|/
literal|255.0f
operator|)
operator|/
literal|16.0f
argument_list|)
expr_stmt|;
name|max
operator|=
name|vec4_min
argument_list|(
name|V4ONE
argument_list|,
name|vec4_max
argument_list|(
name|V4ZERO
argument_list|,
name|max
operator|-
name|inset
argument_list|)
argument_list|)
expr_stmt|;
name|min
operator|=
name|vec4_min
argument_list|(
name|V4ONE
argument_list|,
name|vec4_max
argument_list|(
name|V4ZERO
argument_list|,
name|min
operator|+
name|inset
argument_list|)
argument_list|)
expr_stmt|;
comment|// clamp to color space and save
name|dxtb
operator|->
name|max
operator|=
name|vec4_trunc
argument_list|(
name|V4GRID
operator|*
name|max
operator|+
name|V4HALF
argument_list|)
operator|*
name|V4GRIDRCP
expr_stmt|;
name|dxtb
operator|->
name|min
operator|=
name|vec4_trunc
argument_list|(
name|V4GRID
operator|*
name|min
operator|+
name|V4HALF
argument_list|)
operator|*
name|V4GRIDRCP
expr_stmt|;
block|}
end_function

begin_function
DECL|function|construct_palette3 (dxtblock_t * dxtb)
specifier|static
name|void
name|construct_palette3
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|)
block|{
name|dxtb
operator|->
name|palette
index|[
literal|0
index|]
operator|=
name|dxtb
operator|->
name|max
expr_stmt|;
name|dxtb
operator|->
name|palette
index|[
literal|1
index|]
operator|=
name|dxtb
operator|->
name|min
expr_stmt|;
name|dxtb
operator|->
name|palette
index|[
literal|2
index|]
operator|=
operator|(
name|dxtb
operator|->
name|max
operator|*
name|V4HALF
operator|)
operator|+
operator|(
name|dxtb
operator|->
name|min
operator|*
name|V4HALF
operator|)
expr_stmt|;
name|dxtb
operator|->
name|palette
index|[
literal|3
index|]
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
DECL|function|construct_palette4 (dxtblock_t * dxtb)
specifier|static
name|void
name|construct_palette4
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|)
block|{
name|dxtb
operator|->
name|palette
index|[
literal|0
index|]
operator|=
name|dxtb
operator|->
name|max
expr_stmt|;
name|dxtb
operator|->
name|palette
index|[
literal|1
index|]
operator|=
name|dxtb
operator|->
name|min
expr_stmt|;
name|dxtb
operator|->
name|palette
index|[
literal|2
index|]
operator|=
operator|(
name|dxtb
operator|->
name|max
operator|*
name|V4TWOTHIRDS
operator|)
operator|+
operator|(
name|dxtb
operator|->
name|min
operator|*
name|V4ONETHIRD
operator|)
expr_stmt|;
name|dxtb
operator|->
name|palette
index|[
literal|3
index|]
operator|=
operator|(
name|dxtb
operator|->
name|max
operator|*
name|V4ONETHIRD
operator|)
operator|+
operator|(
name|dxtb
operator|->
name|min
operator|*
name|V4TWOTHIRDS
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * from nvidia-texture-tools; see LICENSE.nvtt for copyright information  */
end_comment

begin_function
DECL|function|optimize_endpoints3 (dxtblock_t * dxtb,unsigned int indices,vec4_t * max,vec4_t * min)
specifier|static
name|void
name|optimize_endpoints3
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|,
name|unsigned
name|int
name|indices
parameter_list|,
name|vec4_t
modifier|*
name|max
parameter_list|,
name|vec4_t
modifier|*
name|min
parameter_list|)
block|{
name|float
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
name|vec4_t
name|alpha2_sum
decl_stmt|,
name|alphax_sum
decl_stmt|;
name|vec4_t
name|beta2_sum
decl_stmt|,
name|betax_sum
decl_stmt|;
name|vec4_t
name|alphabeta_sum
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|factor
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
name|alpha2_sum
operator|=
name|beta2_sum
operator|=
name|alphabeta_sum
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
name|alphax_sum
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
name|betax_sum
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|bits
operator|=
name|indices
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
expr_stmt|;
comment|// skip alpha pixels
if|if
condition|(
operator|(
name|bits
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
continue|continue;
name|beta
operator|=
call|(
name|float
call|)
argument_list|(
name|bits
operator|&
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
name|beta
operator|=
literal|0.5f
expr_stmt|;
name|alpha
operator|=
literal|1.0f
operator|-
name|beta
expr_stmt|;
name|a
operator|=
name|vec4_set1
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
name|b
operator|=
name|vec4_set1
argument_list|(
name|beta
argument_list|)
expr_stmt|;
name|alpha2_sum
operator|+=
name|a
operator|*
name|a
expr_stmt|;
name|beta2_sum
operator|+=
name|b
operator|*
name|b
expr_stmt|;
name|alphabeta_sum
operator|+=
name|a
operator|*
name|b
expr_stmt|;
name|alphax_sum
operator|+=
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|*
name|a
expr_stmt|;
name|betax_sum
operator|+=
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|*
name|b
expr_stmt|;
block|}
name|factor
operator|=
name|alpha2_sum
operator|*
name|beta2_sum
operator|-
name|alphabeta_sum
operator|*
name|alphabeta_sum
expr_stmt|;
if|if
condition|(
name|vec4_cmplt
argument_list|(
name|factor
argument_list|,
name|V4EPSILON
argument_list|)
condition|)
return|return;
name|factor
operator|=
name|vec4_rcp
argument_list|(
name|factor
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|alphax_sum
operator|*
name|beta2_sum
operator|-
name|betax_sum
operator|*
name|alphabeta_sum
operator|)
operator|*
name|factor
expr_stmt|;
name|b
operator|=
operator|(
name|betax_sum
operator|*
name|alpha2_sum
operator|-
name|alphax_sum
operator|*
name|alphabeta_sum
operator|)
operator|*
name|factor
expr_stmt|;
comment|// clamp to the color space
name|a
operator|=
name|vec4_min
argument_list|(
name|V4ONE
argument_list|,
name|vec4_max
argument_list|(
name|V4ZERO
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|vec4_min
argument_list|(
name|V4ONE
argument_list|,
name|vec4_max
argument_list|(
name|V4ZERO
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|vec4_trunc
argument_list|(
name|V4GRID
operator|*
name|a
operator|+
name|V4HALF
argument_list|)
operator|*
name|V4GRIDRCP
expr_stmt|;
name|b
operator|=
name|vec4_trunc
argument_list|(
name|V4GRID
operator|*
name|b
operator|+
name|V4HALF
argument_list|)
operator|*
name|V4GRIDRCP
expr_stmt|;
operator|*
name|max
operator|=
name|a
expr_stmt|;
operator|*
name|min
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * from nvidia-texture-tools; see LICENSE.nvtt for copyright information  */
end_comment

begin_function
DECL|function|optimize_endpoints4 (dxtblock_t * dxtb,unsigned int indices,vec4_t * max,vec4_t * min)
specifier|static
name|void
name|optimize_endpoints4
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|,
name|unsigned
name|int
name|indices
parameter_list|,
name|vec4_t
modifier|*
name|max
parameter_list|,
name|vec4_t
modifier|*
name|min
parameter_list|)
block|{
name|float
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
name|vec4_t
name|alpha2_sum
decl_stmt|,
name|alphax_sum
decl_stmt|;
name|vec4_t
name|beta2_sum
decl_stmt|,
name|betax_sum
decl_stmt|;
name|vec4_t
name|alphabeta_sum
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|factor
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
name|alpha2_sum
operator|=
name|beta2_sum
operator|=
name|alphabeta_sum
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
name|alphax_sum
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
name|betax_sum
operator|=
name|vec4_zero
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|bits
operator|=
name|indices
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
expr_stmt|;
name|beta
operator|=
call|(
name|float
call|)
argument_list|(
name|bits
operator|&
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
name|beta
operator|=
operator|(
literal|1.0f
operator|+
name|beta
operator|)
operator|/
literal|3.0f
expr_stmt|;
name|alpha
operator|=
literal|1.0f
operator|-
name|beta
expr_stmt|;
name|a
operator|=
name|vec4_set1
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
name|b
operator|=
name|vec4_set1
argument_list|(
name|beta
argument_list|)
expr_stmt|;
name|alpha2_sum
operator|+=
name|a
operator|*
name|a
expr_stmt|;
name|beta2_sum
operator|+=
name|b
operator|*
name|b
expr_stmt|;
name|alphabeta_sum
operator|+=
name|a
operator|*
name|b
expr_stmt|;
name|alphax_sum
operator|+=
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|*
name|a
expr_stmt|;
name|betax_sum
operator|+=
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|*
name|b
expr_stmt|;
block|}
name|factor
operator|=
name|alpha2_sum
operator|*
name|beta2_sum
operator|-
name|alphabeta_sum
operator|*
name|alphabeta_sum
expr_stmt|;
if|if
condition|(
name|vec4_cmplt
argument_list|(
name|factor
argument_list|,
name|V4EPSILON
argument_list|)
condition|)
return|return;
name|factor
operator|=
name|vec4_rcp
argument_list|(
name|factor
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|alphax_sum
operator|*
name|beta2_sum
operator|-
name|betax_sum
operator|*
name|alphabeta_sum
operator|)
operator|*
name|factor
expr_stmt|;
name|b
operator|=
operator|(
name|betax_sum
operator|*
name|alpha2_sum
operator|-
name|alphax_sum
operator|*
name|alphabeta_sum
operator|)
operator|*
name|factor
expr_stmt|;
comment|// clamp to the color space
name|a
operator|=
name|vec4_min
argument_list|(
name|V4ONE
argument_list|,
name|vec4_max
argument_list|(
name|V4ZERO
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|vec4_min
argument_list|(
name|V4ONE
argument_list|,
name|vec4_max
argument_list|(
name|V4ZERO
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|vec4_trunc
argument_list|(
name|V4GRID
operator|*
name|a
operator|+
name|V4HALF
argument_list|)
operator|*
name|V4GRIDRCP
expr_stmt|;
name|b
operator|=
name|vec4_trunc
argument_list|(
name|V4GRID
operator|*
name|b
operator|+
name|V4HALF
argument_list|)
operator|*
name|V4GRIDRCP
expr_stmt|;
operator|*
name|max
operator|=
name|a
expr_stmt|;
operator|*
name|min
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_function
DECL|function|match_colors3 (dxtblock_t * dxtb)
specifier|static
name|unsigned
name|int
name|match_colors3
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|unsigned
name|int
name|indices
init|=
literal|0
decl_stmt|;
name|vec4_t
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_SSE
name|vec4_t
name|d
decl_stmt|,
name|bits
decl_stmt|,
name|zero
init|=
name|_mm_setzero_ps
argument_list|()
decl_stmt|;
name|int
name|mask
decl_stmt|;
else|#
directive|else
name|float
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|;
endif|#
directive|endif
comment|// match each point to the closest color
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
comment|// skip alpha pixels
if|if
condition|(
operator|(
operator|(
name|dxtb
operator|->
name|alphamask
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|indices
operator||=
operator|(
literal|3
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
expr_stmt|;
continue|continue;
block|}
name|t0
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|0
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|t1
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|1
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|t2
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|2
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SSE
name|_MM_TRANSPOSE4_PS
argument_list|(
name|t0
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|zero
argument_list|)
expr_stmt|;
name|d
operator|=
name|t0
operator|*
name|t0
operator|+
name|t1
operator|*
name|t1
operator|+
name|t2
operator|*
name|t2
expr_stmt|;
name|bits
operator|=
name|_mm_cmplt_ps
argument_list|(
name|_mm_shuffle_ps
argument_list|(
name|d
argument_list|,
name|d
argument_list|,
name|_MM_SHUFFLE
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|_mm_shuffle_ps
argument_list|(
name|d
argument_list|,
name|d
argument_list|,
name|_MM_SHUFFLE
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|_mm_movemask_ps
argument_list|(
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
literal|4
condition|)
name|idx
operator|=
literal|1
expr_stmt|;
else|else
name|idx
operator|=
literal|2
expr_stmt|;
else|#
directive|else
name|d0
operator|=
name|vec4_dot
argument_list|(
name|t0
argument_list|,
name|t0
argument_list|)
expr_stmt|;
name|d1
operator|=
name|vec4_dot
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|vec4_dot
argument_list|(
name|t2
argument_list|,
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d0
operator|<
name|d1
operator|)
operator|&&
operator|(
name|d0
operator|<
name|d2
operator|)
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|d1
operator|<
name|d2
condition|)
name|idx
operator|=
literal|1
expr_stmt|;
else|else
name|idx
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|indices
operator||=
operator|(
name|idx
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|indices
operator|)
return|;
block|}
end_function

begin_function
DECL|function|match_colors4 (dxtblock_t * dxtb)
specifier|static
name|unsigned
name|int
name|match_colors4
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|indices
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|,
name|b4
decl_stmt|;
name|unsigned
name|int
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|vec4_t
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_SSE
name|vec4_t
name|d
decl_stmt|;
else|#
directive|else
name|float
name|d
index|[
literal|4
index|]
decl_stmt|;
endif|#
directive|endif
comment|// match each point to the closest color
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|t0
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|0
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|t1
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|1
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|t2
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|2
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|t3
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
literal|3
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SSE
name|_MM_TRANSPOSE4_PS
argument_list|(
name|t0
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|)
expr_stmt|;
name|d
operator|=
name|t0
operator|*
name|t0
operator|+
name|t1
operator|*
name|t1
operator|+
name|t2
operator|*
name|t2
expr_stmt|;
else|#
directive|else
name|d
index|[
literal|0
index|]
operator|=
name|vec4_dot
argument_list|(
name|t0
argument_list|,
name|t0
argument_list|)
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
name|vec4_dot
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|d
index|[
literal|2
index|]
operator|=
name|vec4_dot
argument_list|(
name|t2
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|d
index|[
literal|3
index|]
operator|=
name|vec4_dot
argument_list|(
name|t3
argument_list|,
name|t3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|b0
operator|=
name|d
index|[
literal|0
index|]
operator|>
name|d
index|[
literal|3
index|]
expr_stmt|;
name|b1
operator|=
name|d
index|[
literal|1
index|]
operator|>
name|d
index|[
literal|2
index|]
expr_stmt|;
name|b2
operator|=
name|d
index|[
literal|0
index|]
operator|>
name|d
index|[
literal|2
index|]
expr_stmt|;
name|b3
operator|=
name|d
index|[
literal|1
index|]
operator|>
name|d
index|[
literal|3
index|]
expr_stmt|;
name|b4
operator|=
name|d
index|[
literal|2
index|]
operator|>
name|d
index|[
literal|3
index|]
expr_stmt|;
name|x0
operator|=
name|b1
operator|&
name|b2
expr_stmt|;
name|x1
operator|=
name|b0
operator|&
name|b3
expr_stmt|;
name|x2
operator|=
name|b0
operator|&
name|b4
expr_stmt|;
name|idx
operator|=
name|x2
operator||
operator|(
operator|(
name|x0
operator||
name|x1
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|indices
operator||=
operator|(
name|idx
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|indices
operator|)
return|;
block|}
end_function

begin_function
DECL|function|compute_error3 (dxtblock_t * dxtb,unsigned int indices)
specifier|static
name|float
name|compute_error3
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|,
name|unsigned
name|int
name|indices
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|float
name|error
init|=
literal|0
decl_stmt|;
name|vec4_t
name|t
decl_stmt|;
comment|// compute error
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|idx
operator|=
operator|(
name|indices
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
comment|// skip alpha pixels
if|if
condition|(
name|idx
operator|==
literal|3
condition|)
continue|continue;
name|t
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
name|idx
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|error
operator|+=
name|vec4_dot
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
DECL|function|compute_error4 (dxtblock_t * dxtb,unsigned int indices)
specifier|static
name|float
name|compute_error4
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|,
name|unsigned
name|int
name|indices
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|float
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_SSE
name|vec4_t
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
name|vec4_t
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|;
name|vec4_t
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|idx
operator|=
name|indices
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|a0
operator|=
name|dxtb
operator|->
name|points
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
expr_stmt|;
name|a1
operator|=
name|dxtb
operator|->
name|points
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|a2
operator|=
name|dxtb
operator|->
name|points
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|a3
operator|=
name|dxtb
operator|->
name|points
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|b0
operator|=
name|dxtb
operator|->
name|palette
index|[
operator|(
name|idx
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|b1
operator|=
name|dxtb
operator|->
name|palette
index|[
operator|(
name|idx
operator|>>
literal|2
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|b2
operator|=
name|dxtb
operator|->
name|palette
index|[
operator|(
name|idx
operator|>>
literal|4
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|b3
operator|=
name|dxtb
operator|->
name|palette
index|[
operator|(
name|idx
operator|>>
literal|6
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|a0
operator|=
operator|(
name|a0
operator|-
name|b0
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|a1
operator|=
operator|(
name|a1
operator|-
name|b1
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|a2
operator|=
operator|(
name|a2
operator|-
name|b2
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|a3
operator|=
operator|(
name|a3
operator|-
name|b3
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|_MM_TRANSPOSE4_PS
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|d
operator|=
name|a0
operator|*
name|a0
operator|+
name|a1
operator|*
name|a1
operator|+
name|a2
operator|*
name|a2
expr_stmt|;
name|error
operator|+=
name|vec4_accum
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|vec4_t
name|t
decl_stmt|;
comment|// compute error
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|idx
operator|=
operator|(
name|indices
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
name|t
operator|=
operator|(
name|dxtb
operator|->
name|points
index|[
name|i
index|]
operator|-
name|dxtb
operator|->
name|palette
index|[
name|idx
index|]
operator|)
operator|*
name|dxtb
operator|->
name|metric
expr_stmt|;
name|error
operator|+=
name|vec4_dot
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
DECL|function|compress3 (dxtblock_t * dxtb)
specifier|static
name|unsigned
name|int
name|compress3
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|)
block|{
specifier|const
name|int
name|MAX_ITERATIONS
init|=
literal|8
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|indices
decl_stmt|,
name|bestindices
decl_stmt|;
name|float
name|error
decl_stmt|,
name|besterror
init|=
name|FLT_MAX
decl_stmt|;
name|vec4_t
name|oldmax
decl_stmt|,
name|oldmin
decl_stmt|;
name|construct_palette3
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|indices
operator|=
name|match_colors3
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|bestindices
operator|=
name|indices
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ITERATIONS
condition|;
operator|++
name|i
control|)
block|{
name|oldmax
operator|=
name|dxtb
operator|->
name|max
expr_stmt|;
name|oldmin
operator|=
name|dxtb
operator|->
name|min
expr_stmt|;
name|optimize_endpoints3
argument_list|(
name|dxtb
argument_list|,
name|indices
argument_list|,
operator|&
name|dxtb
operator|->
name|max
argument_list|,
operator|&
name|dxtb
operator|->
name|min
argument_list|)
expr_stmt|;
name|construct_palette3
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|indices
operator|=
name|match_colors3
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|error
operator|=
name|compute_error3
argument_list|(
name|dxtb
argument_list|,
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
name|besterror
condition|)
block|{
name|besterror
operator|=
name|error
expr_stmt|;
name|bestindices
operator|=
name|indices
expr_stmt|;
block|}
else|else
block|{
name|dxtb
operator|->
name|max
operator|=
name|oldmax
expr_stmt|;
name|dxtb
operator|->
name|min
operator|=
name|oldmin
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|bestindices
operator|)
return|;
block|}
end_function

begin_function
DECL|function|compress4 (dxtblock_t * dxtb)
specifier|static
name|unsigned
name|int
name|compress4
parameter_list|(
name|dxtblock_t
modifier|*
name|dxtb
parameter_list|)
block|{
specifier|const
name|int
name|MAX_ITERATIONS
init|=
literal|8
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|indices
decl_stmt|,
name|bestindices
decl_stmt|;
name|float
name|error
decl_stmt|,
name|besterror
init|=
name|FLT_MAX
decl_stmt|;
name|vec4_t
name|oldmax
decl_stmt|,
name|oldmin
decl_stmt|;
name|construct_palette4
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|indices
operator|=
name|match_colors4
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|bestindices
operator|=
name|indices
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ITERATIONS
condition|;
operator|++
name|i
control|)
block|{
name|oldmax
operator|=
name|dxtb
operator|->
name|max
expr_stmt|;
name|oldmin
operator|=
name|dxtb
operator|->
name|min
expr_stmt|;
name|optimize_endpoints4
argument_list|(
name|dxtb
argument_list|,
name|indices
argument_list|,
operator|&
name|dxtb
operator|->
name|max
argument_list|,
operator|&
name|dxtb
operator|->
name|min
argument_list|)
expr_stmt|;
name|construct_palette4
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|indices
operator|=
name|match_colors4
argument_list|(
name|dxtb
argument_list|)
expr_stmt|;
name|error
operator|=
name|compute_error4
argument_list|(
name|dxtb
argument_list|,
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
name|besterror
condition|)
block|{
name|besterror
operator|=
name|error
expr_stmt|;
name|bestindices
operator|=
name|indices
expr_stmt|;
block|}
else|else
block|{
name|dxtb
operator|->
name|max
operator|=
name|oldmax
expr_stmt|;
name|dxtb
operator|->
name|min
operator|=
name|oldmin
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|bestindices
operator|)
return|;
block|}
end_function

begin_function
DECL|function|encode_color_block (unsigned char * dst,unsigned char * block,int flags)
specifier|static
name|void
name|encode_color_block
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dxtblock_t
name|dxtb
decl_stmt|;
name|int
name|max16
decl_stmt|,
name|min16
decl_stmt|;
name|unsigned
name|int
name|indices
decl_stmt|,
name|mask
decl_stmt|;
name|dxtblock_init
argument_list|(
operator|&
name|dxtb
argument_list|,
name|block
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxtb
operator|.
name|single
condition|)
comment|// single color block
block|{
name|max16
operator|=
operator|(
name|omatch5
index|[
name|block
index|[
literal|2
index|]
index|]
index|[
literal|0
index|]
operator|<<
literal|11
operator|)
operator||
operator|(
name|omatch6
index|[
name|block
index|[
literal|1
index|]
index|]
index|[
literal|0
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|omatch5
index|[
name|block
index|[
literal|0
index|]
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|min16
operator|=
operator|(
name|omatch5
index|[
name|block
index|[
literal|2
index|]
index|]
index|[
literal|1
index|]
operator|<<
literal|11
operator|)
operator||
operator|(
name|omatch6
index|[
name|block
index|[
literal|1
index|]
index|]
index|[
literal|1
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|omatch5
index|[
name|block
index|[
literal|0
index|]
index|]
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|indices
operator|=
literal|0xaaaaaaaa
expr_stmt|;
comment|// 101010...
if|if
condition|(
operator|(
name|flags
operator|&
name|DXT_BC1
operator|)
operator|&&
name|dxtb
operator|.
name|alphamask
condition|)
block|{
comment|// DXT1 compression, non-opaque block.  Add alpha indices.
name|indices
operator||=
name|dxtb
operator|.
name|alphamask
expr_stmt|;
if|if
condition|(
name|max16
operator|>
name|min16
condition|)
name|SWAP
argument_list|(
name|max16
argument_list|,
name|min16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max16
operator|<
name|min16
condition|)
block|{
name|SWAP
argument_list|(
name|max16
argument_list|,
name|min16
argument_list|)
expr_stmt|;
name|indices
operator|^=
literal|0x55555555
expr_stmt|;
comment|// 010101...
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|DXT_BC1
operator|)
operator|&&
name|dxtb
operator|.
name|alphamask
condition|)
comment|// DXT1 compression, non-opaque block
block|{
name|indices
operator|=
name|compress3
argument_list|(
operator|&
name|dxtb
argument_list|)
expr_stmt|;
name|vec4_endpoints_to_565
argument_list|(
operator|&
name|max16
argument_list|,
operator|&
name|min16
argument_list|,
name|dxtb
operator|.
name|max
argument_list|,
name|dxtb
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|max16
operator|>
name|min16
condition|)
block|{
name|SWAP
argument_list|(
name|max16
argument_list|,
name|min16
argument_list|)
expr_stmt|;
comment|// remap indices 0 -> 1, 1 -> 0
name|mask
operator|=
name|indices
operator|&
literal|0xaaaaaaaa
expr_stmt|;
name|mask
operator|=
name|mask
operator||
operator|(
name|mask
operator|>>
literal|1
operator|)
expr_stmt|;
name|indices
operator|=
operator|(
name|indices
operator|&
name|mask
operator|)
operator||
operator|(
operator|(
name|indices
operator|^
literal|0x55555555
operator|)
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|indices
operator|=
name|compress4
argument_list|(
operator|&
name|dxtb
argument_list|)
expr_stmt|;
name|vec4_endpoints_to_565
argument_list|(
operator|&
name|max16
argument_list|,
operator|&
name|min16
argument_list|,
name|dxtb
operator|.
name|max
argument_list|,
name|dxtb
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|max16
operator|<
name|min16
condition|)
block|{
name|SWAP
argument_list|(
name|max16
argument_list|,
name|min16
argument_list|)
expr_stmt|;
name|indices
operator|^=
literal|0x55555555
expr_stmt|;
comment|// 010101...
block|}
block|}
name|PUTL16
argument_list|(
name|dst
operator|+
literal|0
argument_list|,
name|max16
argument_list|)
expr_stmt|;
name|PUTL16
argument_list|(
name|dst
operator|+
literal|2
argument_list|,
name|min16
argument_list|)
expr_stmt|;
name|PUTL32
argument_list|(
name|dst
operator|+
literal|4
argument_list|,
name|indices
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|get_min_max_YCoCg (const unsigned char * block,unsigned char * mincolor,unsigned char * maxcolor)
specifier|static
name|void
name|get_min_max_YCoCg
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|mincolor
parameter_list|,
name|unsigned
name|char
modifier|*
name|maxcolor
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mincolor
index|[
literal|2
index|]
operator|=
name|mincolor
index|[
literal|1
index|]
operator|=
literal|255
expr_stmt|;
name|maxcolor
index|[
literal|2
index|]
operator|=
name|maxcolor
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|<
name|mincolor
index|[
literal|2
index|]
condition|)
name|mincolor
index|[
literal|2
index|]
operator|=
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|<
name|mincolor
index|[
literal|1
index|]
condition|)
name|mincolor
index|[
literal|1
index|]
operator|=
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|>
name|maxcolor
index|[
literal|2
index|]
condition|)
name|maxcolor
index|[
literal|2
index|]
operator|=
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|>
name|maxcolor
index|[
literal|1
index|]
condition|)
name|maxcolor
index|[
literal|1
index|]
operator|=
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|scale_YCoCg (unsigned char * block,unsigned char * mincolor,unsigned char * maxcolor)
specifier|static
name|void
name|scale_YCoCg
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|mincolor
parameter_list|,
name|unsigned
name|char
modifier|*
name|maxcolor
parameter_list|)
block|{
specifier|const
name|int
name|s0
init|=
literal|128
operator|/
literal|2
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|s1
init|=
literal|128
operator|/
literal|4
operator|-
literal|1
decl_stmt|;
name|int
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|;
name|int
name|mask0
decl_stmt|,
name|mask1
decl_stmt|,
name|scale
decl_stmt|;
name|int
name|i
decl_stmt|;
name|m0
operator|=
name|abs
argument_list|(
name|mincolor
index|[
literal|2
index|]
operator|-
literal|128
argument_list|)
expr_stmt|;
name|m1
operator|=
name|abs
argument_list|(
name|mincolor
index|[
literal|1
index|]
operator|-
literal|128
argument_list|)
expr_stmt|;
name|m2
operator|=
name|abs
argument_list|(
name|maxcolor
index|[
literal|2
index|]
operator|-
literal|128
argument_list|)
expr_stmt|;
name|m3
operator|=
name|abs
argument_list|(
name|maxcolor
index|[
literal|1
index|]
operator|-
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|>
name|m0
condition|)
name|m0
operator|=
name|m1
expr_stmt|;
if|if
condition|(
name|m3
operator|>
name|m2
condition|)
name|m2
operator|=
name|m3
expr_stmt|;
if|if
condition|(
name|m2
operator|>
name|m0
condition|)
name|m0
operator|=
name|m2
expr_stmt|;
name|mask0
operator|=
operator|-
operator|(
name|m0
operator|<=
name|s0
operator|)
expr_stmt|;
name|mask1
operator|=
operator|-
operator|(
name|m0
operator|<=
name|s1
operator|)
expr_stmt|;
name|scale
operator|=
literal|1
operator|+
operator|(
literal|1
operator|&
name|mask0
operator|)
operator|+
operator|(
literal|2
operator|&
name|mask1
operator|)
expr_stmt|;
name|mincolor
index|[
literal|2
index|]
operator|=
operator|(
name|mincolor
index|[
literal|2
index|]
operator|-
literal|128
operator|)
operator|*
name|scale
operator|+
literal|128
expr_stmt|;
name|mincolor
index|[
literal|1
index|]
operator|=
operator|(
name|mincolor
index|[
literal|1
index|]
operator|-
literal|128
operator|)
operator|*
name|scale
operator|+
literal|128
expr_stmt|;
name|mincolor
index|[
literal|0
index|]
operator|=
operator|(
name|scale
operator|-
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|maxcolor
index|[
literal|2
index|]
operator|=
operator|(
name|maxcolor
index|[
literal|2
index|]
operator|-
literal|128
operator|)
operator|*
name|scale
operator|+
literal|128
expr_stmt|;
name|maxcolor
index|[
literal|1
index|]
operator|=
operator|(
name|maxcolor
index|[
literal|1
index|]
operator|-
literal|128
operator|)
operator|*
name|scale
operator|+
literal|128
expr_stmt|;
name|maxcolor
index|[
literal|0
index|]
operator|=
operator|(
name|scale
operator|-
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|block
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
operator|(
name|block
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|-
literal|128
operator|)
operator|*
name|scale
operator|+
literal|128
expr_stmt|;
name|block
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
operator|(
name|block
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|-
literal|128
operator|)
operator|*
name|scale
operator|+
literal|128
expr_stmt|;
block|}
block|}
end_function

begin_define
DECL|macro|INSET_SHIFT
define|#
directive|define
name|INSET_SHIFT
value|4
end_define

begin_function
DECL|function|inset_bbox_YCoCg (unsigned char * mincolor,unsigned char * maxcolor)
specifier|static
name|void
name|inset_bbox_YCoCg
parameter_list|(
name|unsigned
name|char
modifier|*
name|mincolor
parameter_list|,
name|unsigned
name|char
modifier|*
name|maxcolor
parameter_list|)
block|{
name|int
name|inset
index|[
literal|4
index|]
decl_stmt|,
name|mini
index|[
literal|4
index|]
decl_stmt|,
name|maxi
index|[
literal|4
index|]
decl_stmt|;
name|inset
index|[
literal|2
index|]
operator|=
operator|(
name|maxcolor
index|[
literal|2
index|]
operator|-
name|mincolor
index|[
literal|2
index|]
operator|)
operator|-
operator|(
operator|(
literal|1
operator|<<
operator|(
name|INSET_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|inset
index|[
literal|1
index|]
operator|=
operator|(
name|maxcolor
index|[
literal|1
index|]
operator|-
name|mincolor
index|[
literal|1
index|]
operator|)
operator|-
operator|(
operator|(
literal|1
operator|<<
operator|(
name|INSET_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|mini
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|mincolor
index|[
literal|2
index|]
operator|<<
name|INSET_SHIFT
operator|)
operator|+
name|inset
index|[
literal|2
index|]
operator|)
operator|>>
name|INSET_SHIFT
expr_stmt|;
name|mini
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|mincolor
index|[
literal|1
index|]
operator|<<
name|INSET_SHIFT
operator|)
operator|+
name|inset
index|[
literal|1
index|]
operator|)
operator|>>
name|INSET_SHIFT
expr_stmt|;
name|maxi
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|maxcolor
index|[
literal|2
index|]
operator|<<
name|INSET_SHIFT
operator|)
operator|-
name|inset
index|[
literal|2
index|]
operator|)
operator|>>
name|INSET_SHIFT
expr_stmt|;
name|maxi
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|maxcolor
index|[
literal|1
index|]
operator|<<
name|INSET_SHIFT
operator|)
operator|-
name|inset
index|[
literal|1
index|]
operator|)
operator|>>
name|INSET_SHIFT
expr_stmt|;
name|mini
index|[
literal|2
index|]
operator|=
operator|(
name|mini
index|[
literal|2
index|]
operator|>=
literal|0
operator|)
condition|?
name|mini
index|[
literal|2
index|]
else|:
literal|0
expr_stmt|;
name|mini
index|[
literal|1
index|]
operator|=
operator|(
name|mini
index|[
literal|1
index|]
operator|>=
literal|0
operator|)
condition|?
name|mini
index|[
literal|1
index|]
else|:
literal|0
expr_stmt|;
name|maxi
index|[
literal|2
index|]
operator|=
operator|(
name|maxi
index|[
literal|2
index|]
operator|<=
literal|255
operator|)
condition|?
name|maxi
index|[
literal|2
index|]
else|:
literal|255
expr_stmt|;
name|maxi
index|[
literal|1
index|]
operator|=
operator|(
name|maxi
index|[
literal|1
index|]
operator|<=
literal|255
operator|)
condition|?
name|maxi
index|[
literal|1
index|]
else|:
literal|255
expr_stmt|;
name|mincolor
index|[
literal|2
index|]
operator|=
operator|(
name|mini
index|[
literal|2
index|]
operator|&
literal|0xf8
operator|)
operator||
operator|(
name|mini
index|[
literal|2
index|]
operator|>>
literal|5
operator|)
expr_stmt|;
name|mincolor
index|[
literal|1
index|]
operator|=
operator|(
name|mini
index|[
literal|1
index|]
operator|&
literal|0xfc
operator|)
operator||
operator|(
name|mini
index|[
literal|1
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
name|maxcolor
index|[
literal|2
index|]
operator|=
operator|(
name|maxi
index|[
literal|2
index|]
operator|&
literal|0xf8
operator|)
operator||
operator|(
name|maxi
index|[
literal|2
index|]
operator|>>
literal|5
operator|)
expr_stmt|;
name|maxcolor
index|[
literal|1
index|]
operator|=
operator|(
name|maxi
index|[
literal|1
index|]
operator|&
literal|0xfc
operator|)
operator||
operator|(
name|maxi
index|[
literal|1
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|select_diagonal_YCoCg (const unsigned char * block,unsigned char * mincolor,unsigned char * maxcolor)
specifier|static
name|void
name|select_diagonal_YCoCg
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|mincolor
parameter_list|,
name|unsigned
name|char
modifier|*
name|maxcolor
parameter_list|)
block|{
name|unsigned
name|char
name|mid0
decl_stmt|,
name|mid1
decl_stmt|,
name|side
decl_stmt|,
name|mask
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|c0
decl_stmt|,
name|c1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mid0
operator|=
operator|(
operator|(
name|int
operator|)
name|mincolor
index|[
literal|2
index|]
operator|+
name|maxcolor
index|[
literal|2
index|]
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|mid1
operator|=
operator|(
operator|(
name|int
operator|)
name|mincolor
index|[
literal|1
index|]
operator|+
name|maxcolor
index|[
literal|1
index|]
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|side
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|b0
operator|=
name|block
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|>=
name|mid0
expr_stmt|;
name|b1
operator|=
name|block
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|>=
name|mid1
expr_stmt|;
name|side
operator|+=
operator|(
name|b0
operator|^
name|b1
operator|)
expr_stmt|;
block|}
name|mask
operator|=
operator|-
operator|(
name|side
operator|>
literal|8
operator|)
expr_stmt|;
name|mask
operator|&=
operator|-
operator|(
name|mincolor
index|[
literal|2
index|]
operator|!=
name|maxcolor
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|c0
operator|=
name|mincolor
index|[
literal|1
index|]
expr_stmt|;
name|c1
operator|=
name|maxcolor
index|[
literal|1
index|]
expr_stmt|;
name|c0
operator|^=
name|c1
expr_stmt|;
name|c1
operator|^=
name|c0
operator|&
name|mask
expr_stmt|;
name|c0
operator|^=
name|c1
expr_stmt|;
name|mincolor
index|[
literal|1
index|]
operator|=
name|c0
expr_stmt|;
name|maxcolor
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
block|}
end_function

begin_function
DECL|function|encode_YCoCg_block (unsigned char * dst,unsigned char * block)
specifier|static
name|void
name|encode_YCoCg_block
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|block
parameter_list|)
block|{
name|unsigned
name|char
name|colors
index|[
literal|4
index|]
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|maxcolor
decl_stmt|,
modifier|*
name|mincolor
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|int
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|,
name|b4
decl_stmt|;
name|int
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|maxcolor
operator|=
operator|&
name|colors
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|mincolor
operator|=
operator|&
name|colors
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|get_min_max_YCoCg
argument_list|(
name|block
argument_list|,
name|mincolor
argument_list|,
name|maxcolor
argument_list|)
expr_stmt|;
name|scale_YCoCg
argument_list|(
name|block
argument_list|,
name|mincolor
argument_list|,
name|maxcolor
argument_list|)
expr_stmt|;
name|inset_bbox_YCoCg
argument_list|(
name|mincolor
argument_list|,
name|maxcolor
argument_list|)
expr_stmt|;
name|select_diagonal_YCoCg
argument_list|(
name|block
argument_list|,
name|mincolor
argument_list|,
name|maxcolor
argument_list|)
expr_stmt|;
name|lerp_rgb13
argument_list|(
operator|&
name|colors
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|maxcolor
argument_list|,
name|mincolor
argument_list|)
expr_stmt|;
name|lerp_rgb13
argument_list|(
operator|&
name|colors
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|mincolor
argument_list|,
name|maxcolor
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|c0
operator|=
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|c1
operator|=
name|block
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|d0
operator|=
name|abs
argument_list|(
name|colors
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|-
name|c0
argument_list|)
operator|+
name|abs
argument_list|(
name|colors
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|-
name|c1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|abs
argument_list|(
name|colors
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|-
name|c0
argument_list|)
operator|+
name|abs
argument_list|(
name|colors
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|-
name|c1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|abs
argument_list|(
name|colors
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|-
name|c0
argument_list|)
operator|+
name|abs
argument_list|(
name|colors
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|-
name|c1
argument_list|)
expr_stmt|;
name|d3
operator|=
name|abs
argument_list|(
name|colors
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|-
name|c0
argument_list|)
operator|+
name|abs
argument_list|(
name|colors
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|-
name|c1
argument_list|)
expr_stmt|;
name|b0
operator|=
name|d0
operator|>
name|d3
expr_stmt|;
name|b1
operator|=
name|d1
operator|>
name|d2
expr_stmt|;
name|b2
operator|=
name|d0
operator|>
name|d2
expr_stmt|;
name|b3
operator|=
name|d1
operator|>
name|d3
expr_stmt|;
name|b4
operator|=
name|d2
operator|>
name|d3
expr_stmt|;
name|x0
operator|=
name|b1
operator|&
name|b2
expr_stmt|;
name|x1
operator|=
name|b0
operator|&
name|b3
expr_stmt|;
name|x2
operator|=
name|b0
operator|&
name|b4
expr_stmt|;
name|idx
operator|=
operator|(
name|x2
operator||
operator|(
operator|(
name|x0
operator||
name|x1
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|mask
operator||=
name|idx
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|PUTL16
argument_list|(
name|dst
operator|+
literal|0
argument_list|,
name|pack_rgb565
argument_list|(
name|maxcolor
argument_list|)
argument_list|)
expr_stmt|;
name|PUTL16
argument_list|(
name|dst
operator|+
literal|2
argument_list|,
name|pack_rgb565
argument_list|(
name|mincolor
argument_list|)
argument_list|)
expr_stmt|;
name|PUTL32
argument_list|(
name|dst
operator|+
literal|4
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write DXT3 alpha block */
end_comment

begin_function
DECL|function|encode_alpha_block_BC2 (unsigned char * dst,const unsigned char * block)
specifier|static
name|void
name|encode_alpha_block_BC2
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|block
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|block
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|a1
operator|=
name|mul8bit
argument_list|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
literal|0
index|]
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|a2
operator|=
name|mul8bit
argument_list|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
literal|4
index|]
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
name|a2
operator|<<
literal|4
operator|)
operator||
name|a1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write DXT5 alpha block */
end_comment

begin_function
DECL|function|encode_alpha_block_BC3 (unsigned char * dst,const unsigned char * block,const int offset)
specifier|static
name|void
name|encode_alpha_block_BC3
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
specifier|const
name|int
name|offset
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|mn
decl_stmt|,
name|mx
decl_stmt|;
name|int
name|dist
decl_stmt|,
name|bias
decl_stmt|,
name|dist2
decl_stmt|,
name|dist4
decl_stmt|,
name|bits
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|a
decl_stmt|,
name|idx
decl_stmt|,
name|t
decl_stmt|;
name|block
operator|+=
name|offset
expr_stmt|;
name|block
operator|+=
literal|3
expr_stmt|;
comment|/* find min/max alpha pair */
name|mn
operator|=
name|mx
operator|=
name|block
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|v
operator|=
name|block
index|[
literal|4
operator|*
name|i
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|mx
condition|)
name|mx
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|mn
condition|)
name|mn
operator|=
name|v
expr_stmt|;
block|}
comment|/* encode them */
operator|*
name|dst
operator|++
operator|=
name|mx
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|mn
expr_stmt|;
comment|/*     * determine bias and emit indices     * given the choice of mx/mn, these indices are optimal:     * http://fgiesen.wordpress.com/2009/12/15/dxt5-alpha-block-index-determination/     */
name|dist
operator|=
name|mx
operator|-
name|mn
expr_stmt|;
name|dist4
operator|=
name|dist
operator|*
literal|4
expr_stmt|;
name|dist2
operator|=
name|dist
operator|*
literal|2
expr_stmt|;
name|bias
operator|=
operator|(
name|dist
operator|<
literal|8
operator|)
condition|?
operator|(
name|dist
operator|-
literal|1
operator|)
else|:
operator|(
name|dist
operator|/
literal|2
operator|+
literal|2
operator|)
expr_stmt|;
name|bias
operator|-=
name|mn
operator|*
literal|7
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|a
operator|=
name|block
index|[
literal|4
operator|*
name|i
index|]
operator|*
literal|7
operator|+
name|bias
expr_stmt|;
comment|/* select index. this is a "linear scale" lerp factor between 0 (val=min) and 7 (val=max). */
name|t
operator|=
operator|(
name|a
operator|>=
name|dist4
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|idx
operator|=
name|t
operator|&
literal|4
expr_stmt|;
name|a
operator|-=
name|dist4
operator|&
name|t
expr_stmt|;
name|t
operator|=
operator|(
name|a
operator|>=
name|dist2
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|idx
operator|+=
name|t
operator|&
literal|2
expr_stmt|;
name|a
operator|-=
name|dist2
operator|&
name|t
expr_stmt|;
name|idx
operator|+=
operator|(
name|a
operator|>=
name|dist
operator|)
expr_stmt|;
comment|/* turn linear scale into DXT index (0/1 are extremal pts) */
name|idx
operator|=
operator|-
name|idx
operator|&
literal|7
expr_stmt|;
name|idx
operator|^=
operator|(
literal|2
operator|>
name|idx
operator|)
expr_stmt|;
comment|/* write index */
name|mask
operator||=
name|idx
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|bits
operator|+=
literal|3
operator|)
operator|>=
literal|8
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|mask
expr_stmt|;
name|mask
operator|>>=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
DECL|macro|BLOCK_COUNT (w,h)
define|#
directive|define
name|BLOCK_COUNT
parameter_list|(
name|w
parameter_list|,
name|h
parameter_list|)
value|((((h) + 3)>> 2) * (((w) + 3)>> 2))
end_define

begin_define
DECL|macro|BLOCK_OFFSET (x,y,w,bs)
define|#
directive|define
name|BLOCK_OFFSET
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|bs
parameter_list|)
value|(((y)>> 2) * ((bs) * (((w) + 3)>> 2)) + ((bs) * ((x)>> 2)))
end_define

begin_function
DECL|function|compress_BC1 (unsigned char * dst,const unsigned char * src,int w,int h,int flags)
specifier|static
name|void
name|compress_BC1
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|block_count
init|=
name|BLOCK_COUNT
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|,
name|256
name|)
name|private
name|(
name|block
name|,
name|p
name|,
name|x
name|,
name|y
name|)
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_count
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
operator|(
name|i
operator|%
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|/
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|p
operator|=
name|dst
operator|+
name|BLOCK_OFFSET
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|extract_block
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_color_block
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
name|DXT_BC1
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|compress_BC2 (unsigned char * dst,const unsigned char * src,int w,int h,int flags)
specifier|static
name|void
name|compress_BC2
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|block_count
init|=
name|BLOCK_COUNT
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|,
name|256
name|)
name|private
name|(
name|block
name|,
name|p
name|,
name|x
name|,
name|y
name|)
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_count
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
operator|(
name|i
operator|%
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|/
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|p
operator|=
name|dst
operator|+
name|BLOCK_OFFSET
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|extract_block
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_alpha_block_BC2
argument_list|(
name|p
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_color_block
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|block
argument_list|,
name|DXT_BC2
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|compress_BC3 (unsigned char * dst,const unsigned char * src,int w,int h,int flags)
specifier|static
name|void
name|compress_BC3
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|block_count
init|=
name|BLOCK_COUNT
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|,
name|256
name|)
name|private
name|(
name|block
name|,
name|p
name|,
name|x
name|,
name|y
name|)
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_count
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
operator|(
name|i
operator|%
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|/
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|p
operator|=
name|dst
operator|+
name|BLOCK_OFFSET
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|extract_block
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_alpha_block_BC3
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|encode_color_block
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|block
argument_list|,
name|DXT_BC3
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|compress_BC4 (unsigned char * dst,const unsigned char * src,int w,int h)
specifier|static
name|void
name|compress_BC4
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|block_count
init|=
name|BLOCK_COUNT
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|,
name|256
name|)
name|private
name|(
name|block
name|,
name|p
name|,
name|x
name|,
name|y
name|)
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_count
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
operator|(
name|i
operator|%
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|/
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|p
operator|=
name|dst
operator|+
name|BLOCK_OFFSET
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|extract_block
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_alpha_block_BC3
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|compress_BC5 (unsigned char * dst,const unsigned char * src,int w,int h)
specifier|static
name|void
name|compress_BC5
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|block_count
init|=
name|BLOCK_COUNT
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|,
name|256
name|)
name|private
name|(
name|block
name|,
name|p
name|,
name|x
name|,
name|y
name|)
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_count
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
operator|(
name|i
operator|%
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|/
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|p
operator|=
name|dst
operator|+
name|BLOCK_OFFSET
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|extract_block
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_alpha_block_BC3
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|encode_alpha_block_BC3
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|block
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|compress_YCoCg (unsigned char * dst,const unsigned char * src,int w,int h)
specifier|static
name|void
name|compress_YCoCg
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|block_count
init|=
name|BLOCK_COUNT
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
pragma|#
directive|pragma
name|omp
name|parallel
name|for
name|schedule
name|(
name|dynamic
name|,
name|256
name|)
name|private
name|(
name|block
name|,
name|p
name|,
name|x
name|,
name|y
name|)
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_count
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
operator|(
name|i
operator|%
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|/
operator|(
operator|(
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
name|p
operator|=
name|dst
operator|+
name|BLOCK_OFFSET
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|extract_block
argument_list|(
name|src
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|encode_alpha_block_BC3
argument_list|(
name|p
argument_list|,
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|encode_YCoCg_block
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|dxt_compress (unsigned char * dst,unsigned char * src,int format,unsigned int width,unsigned int height,int bpp,int mipmaps,int flags)
name|int
name|dxt_compress
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|format
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|mipmaps
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/* grayscale promoted to BGRA */
name|size
operator|=
name|get_mipmapped_size
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|mipmaps
argument_list|,
name|DDS_COMPRESS_NONE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|g_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
operator|++
name|i
operator|,
name|j
operator|+=
literal|4
control|)
block|{
name|tmp
index|[
name|j
operator|+
literal|0
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|3
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|bpp
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bpp
operator|==
literal|2
condition|)
block|{
comment|/* gray-alpha promoted to BGRA */
name|size
operator|=
name|get_mipmapped_size
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|mipmaps
argument_list|,
name|DDS_COMPRESS_NONE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|g_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|+=
literal|2
operator|,
name|j
operator|+=
literal|4
control|)
block|{
name|tmp
index|[
name|j
operator|+
literal|0
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|3
index|]
operator|=
name|src
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|bpp
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
block|{
name|size
operator|=
name|get_mipmapped_size
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|mipmaps
argument_list|,
name|DDS_COMPRESS_NONE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|g_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|i
operator|+=
literal|3
operator|,
name|j
operator|+=
literal|4
control|)
block|{
name|tmp
index|[
name|j
operator|+
literal|0
index|]
operator|=
name|src
index|[
name|i
operator|+
literal|0
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|src
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|2
index|]
operator|=
name|src
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|tmp
index|[
name|j
operator|+
literal|3
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|bpp
operator|=
literal|4
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|width
expr_stmt|;
name|h
operator|=
name|height
expr_stmt|;
name|s
operator|=
name|tmp
condition|?
name|tmp
else|:
name|src
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mipmaps
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|DDS_COMPRESS_BC1
case|:
name|compress_BC1
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|DDS_COMPRESS_BC2
case|:
name|compress_BC2
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|DDS_COMPRESS_BC3
case|:
case|case
name|DDS_COMPRESS_BC3N
case|:
case|case
name|DDS_COMPRESS_RXGB
case|:
case|case
name|DDS_COMPRESS_AEXP
case|:
case|case
name|DDS_COMPRESS_YCOCG
case|:
name|compress_BC3
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|DDS_COMPRESS_BC4
case|:
name|compress_BC4
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|DDS_COMPRESS_BC5
case|:
name|compress_BC5
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|DDS_COMPRESS_YCOCGS
case|:
name|compress_YCoCg
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
name|compress_BC3
argument_list|(
name|dst
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|+=
operator|(
name|w
operator|*
name|h
operator|*
name|bpp
operator|)
expr_stmt|;
name|offset
operator|+=
name|get_mipmapped_size
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|w
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|w
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|h
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|h
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
condition|)
name|g_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
DECL|function|decode_color_block (unsigned char * block,unsigned char * src,int format)
specifier|static
name|void
name|decode_color_block
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
init|=
name|block
decl_stmt|;
name|unsigned
name|int
name|indices
decl_stmt|,
name|idx
decl_stmt|;
name|unsigned
name|char
name|colors
index|[
literal|4
index|]
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|short
name|c0
decl_stmt|,
name|c1
decl_stmt|;
name|c0
operator|=
name|GETL16
argument_list|(
operator|&
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c1
operator|=
name|GETL16
argument_list|(
operator|&
name|src
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|unpack_rgb565
argument_list|(
name|colors
index|[
literal|0
index|]
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|unpack_rgb565
argument_list|(
name|colors
index|[
literal|1
index|]
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c0
operator|>
name|c1
operator|)
operator|||
operator|(
name|format
operator|==
name|DDS_COMPRESS_BC3
operator|)
condition|)
block|{
name|lerp_rgb13
argument_list|(
name|colors
index|[
literal|2
index|]
argument_list|,
name|colors
index|[
literal|0
index|]
argument_list|,
name|colors
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|lerp_rgb13
argument_list|(
name|colors
index|[
literal|3
index|]
argument_list|,
name|colors
index|[
literal|1
index|]
argument_list|,
name|colors
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|colors
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
operator|(
name|colors
index|[
literal|0
index|]
index|[
name|i
index|]
operator|+
name|colors
index|[
literal|1
index|]
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|colors
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
name|src
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|4
condition|;
operator|++
name|y
control|)
block|{
name|indices
operator|=
name|src
index|[
name|y
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
operator|++
name|x
control|)
block|{
name|idx
operator|=
name|indices
operator|&
literal|0x03
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
name|colors
index|[
name|idx
index|]
index|[
literal|2
index|]
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
name|colors
index|[
name|idx
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
index|[
literal|2
index|]
operator|=
name|colors
index|[
name|idx
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC1
condition|)
name|d
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|c0
operator|<=
name|c1
operator|)
operator|&&
name|idx
operator|==
literal|3
operator|)
condition|?
literal|0
else|:
literal|255
expr_stmt|;
name|indices
operator|>>=
literal|2
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|decode_alpha_block_BC2 (unsigned char * block,unsigned char * src)
specifier|static
name|void
name|decode_alpha_block_BC2
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
init|=
name|block
decl_stmt|;
name|unsigned
name|int
name|bits
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|4
condition|;
operator|++
name|y
control|)
block|{
name|bits
operator|=
name|GETL16
argument_list|(
operator|&
name|src
index|[
literal|2
operator|*
name|y
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
operator|++
name|x
control|)
block|{
name|d
index|[
literal|0
index|]
operator|=
operator|(
name|bits
operator|&
literal|0x0f
operator|)
operator|*
literal|17
expr_stmt|;
name|bits
operator|>>=
literal|4
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|decode_alpha_block_BC3 (unsigned char * block,unsigned char * src,int w)
specifier|static
name|void
name|decode_alpha_block_BC3
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|code
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
init|=
name|block
decl_stmt|;
name|unsigned
name|char
name|a0
init|=
name|src
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|char
name|a1
init|=
name|src
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|long
name|long
name|bits
init|=
name|GETL64
argument_list|(
name|src
argument_list|)
operator|>>
literal|16
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|4
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
operator|++
name|x
control|)
block|{
name|code
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|bits
operator|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
name|d
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|1
condition|)
name|d
index|[
literal|0
index|]
operator|=
name|a1
expr_stmt|;
elseif|else
if|if
condition|(
name|a0
operator|>
name|a1
condition|)
name|d
index|[
literal|0
index|]
operator|=
operator|(
operator|(
literal|8
operator|-
name|code
operator|)
operator|*
name|a0
operator|+
operator|(
name|code
operator|-
literal|1
operator|)
operator|*
name|a1
operator|)
operator|/
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|>=
literal|6
condition|)
name|d
index|[
literal|0
index|]
operator|=
operator|(
name|code
operator|==
literal|6
operator|)
condition|?
literal|0
else|:
literal|255
expr_stmt|;
else|else
name|d
index|[
literal|0
index|]
operator|=
operator|(
operator|(
literal|6
operator|-
name|code
operator|)
operator|*
name|a0
operator|+
operator|(
name|code
operator|-
literal|1
operator|)
operator|*
name|a1
operator|)
operator|/
literal|5
expr_stmt|;
name|bits
operator|>>=
literal|3
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|<
literal|4
condition|)
name|bits
operator|>>=
operator|(
literal|3
operator|*
operator|(
literal|4
operator|-
name|w
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|make_normal (unsigned char * dst,unsigned char x,unsigned char y)
specifier|static
name|void
name|make_normal
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
name|x
parameter_list|,
name|unsigned
name|char
name|y
parameter_list|)
block|{
name|float
name|nx
init|=
literal|2.0f
operator|*
operator|(
operator|(
name|float
operator|)
name|x
operator|/
literal|255.0f
operator|)
operator|-
literal|1.0f
decl_stmt|;
name|float
name|ny
init|=
literal|2.0f
operator|*
operator|(
operator|(
name|float
operator|)
name|y
operator|/
literal|255.0f
operator|)
operator|-
literal|1.0f
decl_stmt|;
name|float
name|nz
init|=
literal|0.0f
decl_stmt|;
name|float
name|d
init|=
literal|1.0f
operator|-
name|nx
operator|*
name|nx
operator|+
name|ny
operator|*
name|ny
decl_stmt|;
name|int
name|z
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
name|nz
operator|=
name|sqrtf
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|z
operator|=
call|(
name|int
call|)
argument_list|(
literal|255.0f
operator|*
operator|(
name|nz
operator|+
literal|1
operator|)
operator|/
literal|2.0f
argument_list|)
expr_stmt|;
name|z
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|MIN
argument_list|(
literal|255
argument_list|,
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
name|z
expr_stmt|;
block|}
end_function

begin_function
DECL|function|normalize_block (unsigned char * block,int format)
specifier|static
name|void
name|normalize_block
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|4
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|4
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC3
condition|)
block|{
name|tmp
operator|=
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
index|]
expr_stmt|;
name|make_normal
argument_list|(
operator|&
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
index|]
argument_list|,
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
operator|+
literal|3
index|]
argument_list|,
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
operator|+
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC5
condition|)
block|{
name|make_normal
argument_list|(
operator|&
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
index|]
argument_list|,
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
index|]
argument_list|,
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
DECL|function|put_block (unsigned char * dst,unsigned char * block,unsigned int bx,unsigned int by,unsigned int width,unsigned height,int bpp)
specifier|static
name|void
name|put_block
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|int
name|bx
parameter_list|,
name|unsigned
name|int
name|by
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|height
parameter_list|,
name|int
name|bpp
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|4
operator|&&
operator|(
operator|(
name|by
operator|+
name|y
operator|)
operator|<
name|height
operator|)
condition|;
operator|++
name|y
control|)
block|{
name|d
operator|=
name|dst
operator|+
operator|(
operator|(
name|y
operator|+
name|by
operator|)
operator|*
name|width
operator|+
name|bx
operator|)
operator|*
name|bpp
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|4
operator|&&
operator|(
operator|(
name|bx
operator|+
name|x
operator|)
operator|<
name|width
operator|)
condition|;
operator|++
name|x
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
operator|++
name|i
control|)
operator|*
name|d
operator|++
operator|=
name|block
index|[
name|y
operator|*
literal|16
operator|+
operator|(
name|x
operator|*
literal|4
operator|)
operator|+
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|function|dxt_decompress (unsigned char * dst,unsigned char * src,int format,unsigned int size,unsigned int width,unsigned int height,int bpp,int normals)
name|int
name|dxt_decompress
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|format
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|unsigned
name|int
name|height
parameter_list|,
name|int
name|bpp
parameter_list|,
name|int
name|normals
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|16
operator|*
literal|4
index|]
decl_stmt|;
name|s
operator|=
name|src
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
literal|4
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|+=
literal|4
control|)
block|{
name|memset
argument_list|(
name|block
argument_list|,
literal|255
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC1
condition|)
block|{
name|decode_color_block
argument_list|(
name|block
argument_list|,
name|s
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC2
condition|)
block|{
name|decode_alpha_block_BC2
argument_list|(
name|block
operator|+
literal|3
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|decode_color_block
argument_list|(
name|block
argument_list|,
name|s
operator|+
literal|8
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC3
condition|)
block|{
name|decode_alpha_block_BC3
argument_list|(
name|block
operator|+
literal|3
argument_list|,
name|s
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|decode_color_block
argument_list|(
name|block
argument_list|,
name|s
operator|+
literal|8
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC4
condition|)
block|{
name|decode_alpha_block_BC3
argument_list|(
name|block
argument_list|,
name|s
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|DDS_COMPRESS_BC5
condition|)
block|{
name|decode_alpha_block_BC3
argument_list|(
name|block
argument_list|,
name|s
operator|+
literal|8
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|decode_alpha_block_BC3
argument_list|(
name|block
operator|+
literal|1
argument_list|,
name|s
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|normals
condition|)
name|normalize_block
argument_list|(
name|block
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|put_block
argument_list|(
name|dst
argument_list|,
name|block
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

