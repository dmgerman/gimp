begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in EPSON ESC/P2 driver for the GIMP.  *  *   Copyright 1997 Michael Sweet (mike@easysw.com)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Contents:  *  *   escp2_print() - Print an image to an EPSON printer.  *   escp2_write() - Send ESC/P2 graphics using TIFF packbits compression.  *  * Revision History:  *  *   $Log$  *   Revision 1.1  1997/11/24 22:03:34  sopwith  *   Initial revision  *  *   Revision 1.3  1997/10/03 22:18:14  nobody  *   updated print er too the latest version  *  *   : ----------------------------------------------------------------------  *  *   Revision 1.6  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.6  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.5  1997/07/30  18:47:39  mike  *   Added scaling, orientation, and offset options.  *  *   Revision 1.4  1997/07/15  20:57:11  mike  *   Updated ESC 800/1520/3000 output code to use vertical spacing of 5 instead of 40.  *  *   Revision 1.3  1997/07/03  13:21:15  mike  *   Updated documentation for 1.0 release.  *  *   Revision 1.2  1997/07/03  13:03:57  mike  *   Added horizontal offset to try to center image.  *   Got rid of initial vertical positioning since the top margin is  *   now set properly.  *  *   Revision 1.2  1997/07/03  13:03:57  mike  *   Added horizontal offset to try to center image.  *   Got rid of initial vertical positioning since the top margin is  *   now set properly.  *  *   Revision 1.1  1997/07/02  13:51:53  mike  *   Initial revision  */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|escp2_write
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * 'escp2_print()' - Print an image to an EPSON printer.  */
end_comment

begin_function
name|void
DECL|function|escp2_print (FILE * prn,GDrawable * drawable,int media_size,int xdpi,int ydpi,int output_type,int model,guchar * lut,guchar * cmap,int orientation,int scaling,int left,int top)
name|escp2_print
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|GDrawable
modifier|*
name|drawable
parameter_list|,
comment|/* I - Image to print */
name|int
name|media_size
parameter_list|,
comment|/* I - Output size */
name|int
name|xdpi
parameter_list|,
comment|/* I - Horizontal resolution */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|output_type
parameter_list|,
comment|/* I - Color or grayscale? */
name|int
name|model
parameter_list|,
comment|/* I - Model of printer */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (for indexed images) */
name|int
name|orientation
parameter_list|,
comment|/* I - Orientation of image */
name|int
name|scaling
parameter_list|,
comment|/* I - Scaling of image */
name|int
name|left
parameter_list|,
comment|/* I - Left offset of image (10ths) */
name|int
name|top
parameter_list|)
comment|/* I - Top offset of image (10ths) */
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Looping vars */
name|int
name|n
decl_stmt|;
comment|/* Output number */
name|GPixelRgn
name|rgn
decl_stmt|;
comment|/* Image region */
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
comment|/* Input pixels */
modifier|*
name|out
decl_stmt|,
comment|/* Output pixels */
modifier|*
name|black
decl_stmt|,
comment|/* Black bitmap data */
modifier|*
name|cyan
decl_stmt|,
comment|/* Cyan bitmap data */
modifier|*
name|magenta
decl_stmt|,
comment|/* Magenta bitmap data */
modifier|*
name|yellow
decl_stmt|;
comment|/* Yellow bitmap data */
name|int
name|page_width
decl_stmt|,
comment|/* Width of page */
name|page_height
decl_stmt|,
comment|/* Height of page */
name|out_width
decl_stmt|,
comment|/* Width of image on page */
name|out_height
decl_stmt|,
comment|/* Height of image on page */
name|out_bpp
decl_stmt|,
comment|/* Output bytes per pixel */
name|temp_width
decl_stmt|,
comment|/* Temporary width of image on page */
name|temp_height
decl_stmt|,
comment|/* Temporary height of image on page */
name|landscape
decl_stmt|,
comment|/* True if we rotate the output 90 degrees */
name|length
decl_stmt|,
comment|/* Length of raster data */
name|errdiv
decl_stmt|,
comment|/* Error dividend */
name|errmod
decl_stmt|,
comment|/* Error modulus */
name|errval
decl_stmt|,
comment|/* Current error value */
name|errline
decl_stmt|,
comment|/* Current raster line */
name|errlast
decl_stmt|;
comment|/* Last raster line loaded */
name|convert_t
name|colorfunc
decl_stmt|;
comment|/* Color conversion function... */
comment|/*   * Setup a read-only pixel region for the entire image...   */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*   * Choose the correct color conversion function...   */
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|<
literal|3
operator|&&
name|cmap
operator|==
name|NULL
condition|)
name|output_type
operator|=
name|OUTPUT_GRAY
expr_stmt|;
comment|/* Force grayscale output */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
block|{
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_rgb
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_rgb
expr_stmt|;
block|}
else|else
block|{
name|out_bpp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_gray
expr_stmt|;
elseif|else
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
name|colorfunc
operator|=
name|gray_to_gray
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_gray
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Compute the output size...   */
name|landscape
operator|=
literal|0
expr_stmt|;
name|page_width
operator|=
name|media_width
argument_list|(
name|media_size
argument_list|,
name|xdpi
argument_list|)
expr_stmt|;
name|page_height
operator|=
name|media_height
argument_list|(
name|media_size
argument_list|,
name|ydpi
argument_list|)
expr_stmt|;
comment|/*   * Portrait width/height...   */
name|out_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100
expr_stmt|;
name|out_height
operator|=
name|out_width
operator|*
name|ydpi
operator|/
name|xdpi
operator|*
name|drawable
operator|->
name|height
operator|/
name|drawable
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|out_height
operator|>
name|page_height
condition|)
block|{
name|out_height
operator|=
name|page_height
expr_stmt|;
name|out_width
operator|=
name|out_height
operator|*
name|xdpi
operator|/
name|ydpi
operator|*
name|drawable
operator|->
name|width
operator|/
name|drawable
operator|->
name|height
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Landscape width/height...   */
name|temp_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100
expr_stmt|;
name|temp_height
operator|=
name|temp_width
operator|*
name|ydpi
operator|/
name|xdpi
operator|*
name|drawable
operator|->
name|width
operator|/
name|drawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|temp_height
operator|>
name|page_height
condition|)
block|{
name|temp_height
operator|=
name|page_height
expr_stmt|;
name|temp_width
operator|=
name|temp_height
operator|*
name|xdpi
operator|/
name|ydpi
operator|*
name|drawable
operator|->
name|height
operator|/
name|drawable
operator|->
name|width
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * See which orientation has the greatest area...   */
if|if
condition|(
operator|(
name|temp_width
operator|*
name|temp_height
operator|)
operator|>
operator|(
name|out_width
operator|*
name|out_height
operator|)
operator|&&
name|orientation
operator|!=
name|ORIENT_PORTRAIT
condition|)
block|{
name|out_width
operator|=
name|temp_width
expr_stmt|;
name|out_height
operator|=
name|temp_height
expr_stmt|;
name|landscape
operator|=
literal|1
expr_stmt|;
comment|/*     * Swap left/top offsets...     */
name|x
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|x
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Let the user know what we're doing...   */
name|gimp_progress_init
argument_list|(
literal|"Printing..."
argument_list|)
expr_stmt|;
comment|/*   * Send ESC/P2 initialization commands...   */
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
name|fwrite
argument_list|(
literal|"\033(G\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Enter graphics mode */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Set line feed increment */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\024"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\012"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\005"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|fwrite
argument_list|(
literal|"\033(C\002\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Page length */
name|n
operator|=
name|page_height
operator|+
name|ydpi
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
operator|||
name|top
operator|<
literal|0
condition|)
block|{
name|left
operator|=
operator|(
name|page_width
operator|-
name|out_width
operator|)
operator|/
literal|2
expr_stmt|;
name|top
operator|=
operator|(
name|page_height
operator|-
name|out_height
operator|+
name|ydpi
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|left
operator|*=
name|xdpi
operator|/
literal|10
expr_stmt|;
name|top
operator|=
name|top
operator|*
name|ydpi
operator|/
literal|10
operator|+
name|ydpi
operator|/
literal|2
expr_stmt|;
block|}
empty_stmt|;
name|fwrite
argument_list|(
literal|"\033(c\004\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Top/bottom margins */
name|putc
argument_list|(
name|top
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|top
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|n
operator|=
name|page_height
operator|+
name|ydpi
operator|/
literal|2
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|model
condition|)
comment|/* Printer specific initialization */
block|{
case|case
literal|0
case|:
comment|/* ESC */
break|break;
case|case
literal|1
case|:
comment|/* ESC Pro, Pro XL, 400, 500 */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
break|break;
case|case
literal|2
case|:
comment|/* ESC 1500 */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
break|break;
case|case
literal|3
case|:
comment|/* ESC 600 */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Fast black printing */
else|else
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Color printing */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\003"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
break|break;
case|case
literal|4
case|:
comment|/* ESC 800, 1520, 3000 */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Fast black printing */
else|else
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Color printing */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
break|break;
block|}
empty_stmt|;
comment|/*   * Allocate memory for the raster data...   */
name|length
operator|=
operator|(
name|out_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|black
operator|=
name|g_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|cyan
operator|=
name|NULL
expr_stmt|;
name|magenta
operator|=
name|NULL
expr_stmt|;
name|yellow
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cyan
operator|=
name|g_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|magenta
operator|=
name|g_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|yellow
operator|=
name|g_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|!=
literal|2
condition|)
name|black
operator|=
name|g_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
else|else
name|black
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Output the page, rotating as necessary...   */
if|if
condition|(
name|landscape
condition|)
block|{
name|in
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|height
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|height
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|drawable
operator|->
name|width
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|drawable
operator|->
name|width
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
name|drawable
operator|->
name|width
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|out_height
condition|;
name|x
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"escp2_print: x = %d, line = %d, val = %d, mod = %d, height = %d\n"
argument_list|,
name|x
argument_list|,
name|errline
argument_list|,
name|errval
argument_list|,
name|errmod
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|x
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|x
operator|/
operator|(
name|double
operator|)
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|gimp_pixel_rgn_get_col
argument_list|(
operator|&
name|rgn
argument_list|,
name|in
argument_list|,
name|errline
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|dither_black
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|out_width
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fwrite
argument_list|(
literal|"\033(v\002\000\001\000"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Feed one line */
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|-=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|drawable
operator|->
name|height
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|drawable
operator|->
name|height
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|out_height
condition|;
name|y
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"escp2_print: y = %d, line = %d, val = %d, mod = %d, height = %d\n"
argument_list|,
name|y
argument_list|,
name|errline
argument_list|,
name|errval
argument_list|,
name|errmod
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|y
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|y
operator|/
operator|(
name|double
operator|)
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|rgn
argument_list|,
name|in
argument_list|,
literal|0
argument_list|,
name|errline
argument_list|,
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|dither_black
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|out_width
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fwrite
argument_list|(
literal|"\033(v\002\000\001\000"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Feed one line */
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|+=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*   * Cleanup...   */
name|g_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyan
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|cyan
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|magenta
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|yellow
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|putc
argument_list|(
literal|'\014'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Eject page */
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
block|}
end_function

begin_comment
comment|/*  * 'escp2_write()' - Send ESC/P2 graphics using TIFF packbits compression.  */
end_comment

begin_function
name|void
DECL|function|escp2_write (FILE * prn,unsigned char * line,int length,int plane,int ydpi,int model,int width,int offset)
name|escp2_write
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
comment|/* I - Output bitmap data */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|plane
parameter_list|,
comment|/* I - True if this is the last plane */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|)
comment|/* I - Offset from left side */
block|{
name|unsigned
name|char
name|comp_buf
index|[
literal|1536
index|]
decl_stmt|,
comment|/* Compression buffer */
modifier|*
name|comp_ptr
decl_stmt|,
comment|/* Current slot in buffer */
modifier|*
name|start
decl_stmt|,
comment|/* Start of compressed data */
name|repeat
decl_stmt|;
comment|/* Repeating char */
name|int
name|count
decl_stmt|,
comment|/* Count of compressed bytes */
name|tcount
decl_stmt|;
comment|/* Temporary count< 128 */
specifier|static
name|int
name|last_plane
init|=
literal|0
decl_stmt|;
comment|/* Last color plane printed */
comment|/*   * Don't send blank lines...   */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/*   * Compress using TIFF "packbits" run-length encoding...   */
name|comp_ptr
operator|=
name|comp_buf
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/*     * Get a run of non-repeated chars...     */
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|(
name|line
index|[
operator|-
literal|2
index|]
operator|!=
name|line
index|[
operator|-
literal|1
index|]
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|!=
name|line
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|line
operator|-=
literal|2
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
comment|/*     * Output the non-repeated sequences (max 128 at a time).     */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
name|comp_ptr
index|[
literal|0
index|]
operator|=
name|tcount
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|comp_ptr
operator|+
literal|1
argument_list|,
name|start
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
name|comp_ptr
operator|+=
name|tcount
operator|+
literal|1
expr_stmt|;
name|start
operator|+=
name|tcount
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
break|break;
comment|/*     * Find the repeated sequences...     */
name|start
operator|=
name|line
expr_stmt|;
name|repeat
operator|=
name|line
index|[
literal|0
index|]
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|*
name|line
operator|==
name|repeat
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
empty_stmt|;
comment|/*     * Output the repeated sequences (max 128 at a time).     */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
name|comp_ptr
index|[
literal|0
index|]
operator|=
literal|1
operator|-
name|tcount
expr_stmt|;
name|comp_ptr
index|[
literal|1
index|]
operator|=
name|repeat
expr_stmt|;
name|comp_ptr
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*   * Set the print head position.   */
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|offset
operator|&
literal|255
argument_list|,
name|offset
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/*   * Set the color if necessary...   */
if|if
condition|(
name|last_plane
operator|!=
name|plane
condition|)
block|{
name|last_plane
operator|=
name|plane
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Send a line of raster graphics...   */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Raster graphics header */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033.\001\024\024\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033.\001\012\012\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
if|if
condition|(
name|model
operator|==
literal|3
condition|)
name|fwrite
argument_list|(
literal|"\033.\001\050\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fwrite
argument_list|(
literal|"\033.\001\005\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|putc
argument_list|(
name|width
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|width
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

