begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimpmath/gimpmath.h>
end_include

begin_include
include|#
directive|include
file|"ppmtool.h"
end_include

begin_include
include|#
directive|include
file|"gimpressionist.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_function
specifier|static
name|int
DECL|function|readline (FILE * f,char * buffer,int len)
name|readline
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|f
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
do|while
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
do|;
name|g_strchomp
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_kill (ppm_t * p)
name|ppm_kill
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|)
block|{
name|g_free
argument_list|(
name|p
operator|->
name|col
argument_list|)
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|p
operator|->
name|width
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
DECL|function|ppm_new (ppm_t * p,int xs,int ys)
name|void
name|ppm_new
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|xs
parameter_list|,
name|int
name|ys
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|guchar
name|bgcol
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|xs
operator|<
literal|1
condition|)
name|xs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ys
operator|<
literal|1
condition|)
name|ys
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|xs
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|ys
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|g_malloc
argument_list|(
name|xs
operator|*
literal|3
operator|*
name|ys
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xs
operator|*
literal|3
operator|*
name|ys
condition|;
name|x
operator|+=
literal|3
control|)
block|{
name|p
operator|->
name|col
index|[
name|x
operator|+
literal|0
index|]
operator|=
name|bgcol
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|col
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|bgcol
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|->
name|col
index|[
name|x
operator|+
literal|2
index|]
operator|=
name|bgcol
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|get_rgb (ppm_t * s,float xo,float yo,guchar * d)
name|get_rgb
parameter_list|(
name|ppm_t
modifier|*
name|s
parameter_list|,
name|float
name|xo
parameter_list|,
name|float
name|yo
parameter_list|,
name|guchar
modifier|*
name|d
parameter_list|)
block|{
name|float
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|float
name|x1y1
decl_stmt|,
name|x2y1
decl_stmt|,
name|x1y2
decl_stmt|,
name|x2y2
decl_stmt|;
name|float
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|int
name|bail
init|=
literal|0
decl_stmt|;
name|int
name|rowstride
init|=
name|s
operator|->
name|width
operator|*
literal|3
decl_stmt|;
if|if
condition|(
name|xo
operator|<
literal|0.0
condition|)
name|bail
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|xo
operator|>=
name|s
operator|->
name|width
operator|-
literal|1
condition|)
block|{
name|xo
operator|=
name|s
operator|->
name|width
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|bail=1;
endif|#
directive|endif
block|}
if|if
condition|(
name|yo
operator|<
literal|0.0
condition|)
name|bail
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|yo
operator|>=
name|s
operator|->
name|height
operator|-
literal|1
condition|)
block|{
name|yo
operator|=
name|s
operator|->
name|height
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|bail=1;
endif|#
directive|endif
block|}
if|if
condition|(
name|bail
condition|)
block|{
name|d
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ix
operator|=
operator|(
name|int
operator|)
name|xo
expr_stmt|;
name|iy
operator|=
operator|(
name|int
operator|)
name|yo
expr_stmt|;
if|#
directive|if
literal|0
block|x1 = wrap(ix, s->width);   x2 = wrap(ix+1, s->width);   y1 = wrap(iy, s->height);   y2 = wrap(iy+1, s->height);
endif|#
directive|endif
name|x1
operator|=
name|ix
expr_stmt|;
name|x2
operator|=
name|ix
operator|+
literal|1
expr_stmt|;
name|y1
operator|=
name|iy
expr_stmt|;
name|y2
operator|=
name|iy
operator|+
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|printf("x1=%d y1=%d x2=%d y2=%d\n",x1,y1,x2,y2);
endif|#
directive|endif
name|x1y1
operator|=
operator|(
literal|1.0
operator|-
name|xo
operator|+
name|ix
operator|)
operator|*
operator|(
literal|1.0
operator|-
name|yo
operator|+
name|iy
operator|)
expr_stmt|;
name|x2y1
operator|=
operator|(
name|xo
operator|-
name|ix
operator|)
operator|*
operator|(
literal|1.0
operator|-
name|yo
operator|+
name|iy
operator|)
expr_stmt|;
name|x1y2
operator|=
operator|(
literal|1.0
operator|-
name|xo
operator|+
name|ix
operator|)
operator|*
operator|(
name|yo
operator|-
name|iy
operator|)
expr_stmt|;
name|x2y2
operator|=
operator|(
name|xo
operator|-
name|ix
operator|)
operator|*
operator|(
name|yo
operator|-
name|iy
operator|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|col
index|[
name|y1
operator|*
name|rowstride
operator|+
name|x1
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|x1y1
expr_stmt|;
name|g
operator|=
name|s
operator|->
name|col
index|[
name|y1
operator|*
name|rowstride
operator|+
name|x1
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|x1y1
expr_stmt|;
name|b
operator|=
name|s
operator|->
name|col
index|[
name|y1
operator|*
name|rowstride
operator|+
name|x1
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|x1y1
expr_stmt|;
if|if
condition|(
name|x2y1
operator|>
literal|0.0
condition|)
name|r
operator|+=
name|s
operator|->
name|col
index|[
name|y1
operator|*
name|rowstride
operator|+
name|x2
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|x2y1
expr_stmt|;
if|if
condition|(
name|x2y1
operator|>
literal|0.0
condition|)
name|g
operator|+=
name|s
operator|->
name|col
index|[
name|y1
operator|*
name|rowstride
operator|+
name|x2
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|x2y1
expr_stmt|;
if|if
condition|(
name|x2y1
operator|>
literal|0.0
condition|)
name|b
operator|+=
name|s
operator|->
name|col
index|[
name|y1
operator|*
name|rowstride
operator|+
name|x2
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|x2y1
expr_stmt|;
if|if
condition|(
name|x1y2
operator|>
literal|0.0
condition|)
name|r
operator|+=
name|s
operator|->
name|col
index|[
name|y2
operator|*
name|rowstride
operator|+
name|x1
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|x1y2
expr_stmt|;
if|if
condition|(
name|x1y2
operator|>
literal|0.0
condition|)
name|g
operator|+=
name|s
operator|->
name|col
index|[
name|y2
operator|*
name|rowstride
operator|+
name|x1
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|x1y2
expr_stmt|;
if|if
condition|(
name|x1y2
operator|>
literal|0.0
condition|)
name|b
operator|+=
name|s
operator|->
name|col
index|[
name|y2
operator|*
name|rowstride
operator|+
name|x1
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|x1y2
expr_stmt|;
if|if
condition|(
name|x2y2
operator|>
literal|0.0
condition|)
name|r
operator|+=
name|s
operator|->
name|col
index|[
name|y2
operator|*
name|rowstride
operator|+
name|x2
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|x2y2
expr_stmt|;
if|if
condition|(
name|x2y2
operator|>
literal|0.0
condition|)
name|g
operator|+=
name|s
operator|->
name|col
index|[
name|y2
operator|*
name|rowstride
operator|+
name|x2
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|x2y2
expr_stmt|;
if|if
condition|(
name|x2y2
operator|>
literal|0.0
condition|)
name|b
operator|+=
name|s
operator|->
name|col
index|[
name|y2
operator|*
name|rowstride
operator|+
name|x2
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|x2y2
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|d
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|resize (ppm_t * p,int nx,int ny)
name|resize
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|nx
parameter_list|,
name|int
name|ny
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|float
name|xs
init|=
name|p
operator|->
name|width
operator|/
operator|(
name|float
operator|)
name|nx
decl_stmt|;
name|float
name|ys
init|=
name|p
operator|->
name|height
operator|/
operator|(
name|float
operator|)
name|ny
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ny
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|row
init|=
name|tmp
operator|.
name|col
operator|+
name|y
operator|*
name|tmp
operator|.
name|width
operator|*
literal|3
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nx
condition|;
name|x
operator|++
control|)
block|{
name|get_rgb
argument_list|(
name|p
argument_list|,
name|x
operator|*
name|xs
argument_list|,
name|y
operator|*
name|ys
argument_list|,
operator|&
name|row
index|[
name|x
operator|*
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|rescale (ppm_t * p,double sc)
name|rescale
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|double
name|sc
parameter_list|)
block|{
name|resize
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|width
operator|*
name|sc
argument_list|,
name|p
operator|->
name|height
operator|*
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|resize_fast (ppm_t * p,int nx,int ny)
name|void
name|resize_fast
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|nx
parameter_list|,
name|int
name|ny
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|float
name|xs
init|=
name|p
operator|->
name|width
operator|/
operator|(
name|float
operator|)
name|nx
decl_stmt|;
name|float
name|ys
init|=
name|p
operator|->
name|height
operator|/
operator|(
name|float
operator|)
name|ny
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|ny
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nx
condition|;
name|x
operator|++
control|)
block|{
name|gint
name|rx
init|=
name|x
operator|*
name|xs
decl_stmt|,
name|ry
init|=
name|y
operator|*
name|ys
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
operator|.
name|col
index|[
name|y
operator|*
name|tmp
operator|.
name|width
operator|*
literal|3
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|ry
operator|*
name|p
operator|->
name|width
operator|*
literal|3
operator|+
name|rx
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
block|}
end_function

begin_struct
DECL|struct|_BrushHeader
struct|struct
name|_BrushHeader
block|{
DECL|member|header_size
name|unsigned
name|int
name|header_size
decl_stmt|;
comment|/*  header_size = sz_BrushHeader + brush name  */
DECL|member|version
name|unsigned
name|int
name|version
decl_stmt|;
comment|/*  brush file version #  */
DECL|member|width
name|unsigned
name|int
name|width
decl_stmt|;
comment|/*  width of brush  */
DECL|member|height
name|unsigned
name|int
name|height
decl_stmt|;
comment|/*  height of brush  */
DECL|member|bytes
name|unsigned
name|int
name|bytes
decl_stmt|;
comment|/*  depth of brush in bytes--always 1 */
DECL|member|magic_number
name|unsigned
name|int
name|magic_number
decl_stmt|;
comment|/*  GIMP brush magic number  */
DECL|member|spacing
name|unsigned
name|int
name|spacing
decl_stmt|;
comment|/*  brush spacing  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
DECL|function|msb2lsb (unsigned int * i)
name|msb2lsb
parameter_list|(
name|unsigned
name|int
modifier|*
name|i
parameter_list|)
block|{
name|guchar
modifier|*
name|p
init|=
operator|(
name|guchar
operator|*
operator|)
name|i
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|3
index|]
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
DECL|function|fopen_from_search_path (const gchar * fn,const char * mode)
name|fopen_from_search_path
parameter_list|(
specifier|const
name|gchar
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|gchar
modifier|*
name|full_filename
decl_stmt|;
name|f
operator|=
name|g_fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|full_filename
operator|=
name|findfile
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|f
operator|=
name|g_fopen
argument_list|(
name|full_filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|full_filename
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|load_gimp_brush (const gchar * fn,ppm_t * p)
name|load_gimp_brush
parameter_list|(
specifier|const
name|gchar
modifier|*
name|fn
parameter_list|,
name|ppm_t
modifier|*
name|p
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|_BrushHeader
name|hdr
decl_stmt|;
name|gchar
modifier|*
name|ptr
decl_stmt|;
name|gint
name|x
decl_stmt|,
name|y
decl_stmt|;
name|f
operator|=
name|fopen_from_search_path
argument_list|(
name|fn
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|g_printerr
argument_list|(
literal|"load_gimp_brush: Unable to open file \"%s\"!\n"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|ppm_new
argument_list|(
name|p
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|fread
argument_list|(
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_BrushHeader
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|7
condition|;
name|x
operator|++
control|)
name|msb2lsb
argument_list|(
operator|&
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|hdr
operator|)
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|ppm_new
argument_list|(
name|p
argument_list|,
name|hdr
operator|.
name|width
argument_list|,
name|hdr
operator|.
name|height
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|g_malloc
argument_list|(
name|hdr
operator|.
name|width
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|f
argument_list|,
name|hdr
operator|.
name|header_size
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|fread
argument_list|(
name|ptr
argument_list|,
name|p
operator|->
name|width
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
name|int
name|k
init|=
name|y
operator|*
name|p
operator|->
name|width
operator|*
literal|3
operator|+
name|x
operator|*
literal|3
decl_stmt|;
name|p
operator|->
name|col
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|p
operator|->
name|col
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|p
operator|->
name|col
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|ptr
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_load (const char * fn,ppm_t * p)
name|ppm_load
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|ppm_t
modifier|*
name|p
parameter_list|)
block|{
name|char
name|line
index|[
literal|200
index|]
decl_stmt|;
name|int
name|y
decl_stmt|,
name|pgm
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|fn
index|[
name|strlen
argument_list|(
name|fn
argument_list|)
operator|-
literal|4
index|]
argument_list|,
literal|".gbr"
argument_list|)
condition|)
block|{
name|load_gimp_brush
argument_list|(
name|fn
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|fopen_from_search_path
argument_list|(
name|fn
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|g_printerr
argument_list|(
literal|"ppm_load: Unable to open file \"%s\"!\n"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|ppm_new
argument_list|(
name|p
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|readline
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"P6"
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"P5"
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|g_printerr
argument_list|(
literal|"ppm_load: File \"%s\" not PPM/PGM? (line=\"%s\")%c\n"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|fn
argument_list|)
argument_list|,
name|line
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|ppm_new
argument_list|(
name|p
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|pgm
operator|=
literal|1
expr_stmt|;
block|}
name|readline
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|atoi
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|atoi
argument_list|(
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|readline
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"255"
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|g_printerr
argument_list|(
literal|"ppm_load: File \"%s\" not valid PPM/PGM? (line=\"%s\")%c\n"
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|fn
argument_list|)
argument_list|,
name|line
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|ppm_new
argument_list|(
name|p
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|col
operator|=
name|g_malloc
argument_list|(
name|p
operator|->
name|height
operator|*
name|p
operator|->
name|width
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pgm
condition|)
block|{
name|fread
argument_list|(
name|p
operator|->
name|col
argument_list|,
name|p
operator|->
name|height
operator|*
literal|3
operator|*
name|p
operator|->
name|width
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|guchar
modifier|*
name|tmpcol
init|=
name|g_malloc
argument_list|(
name|p
operator|->
name|width
operator|*
name|p
operator|->
name|height
argument_list|)
decl_stmt|;
name|fread
argument_list|(
name|tmpcol
argument_list|,
name|p
operator|->
name|height
operator|*
name|p
operator|->
name|width
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|width
operator|*
name|p
operator|->
name|height
operator|*
literal|3
condition|;
name|y
operator|++
control|)
block|{
name|p
operator|->
name|col
index|[
name|y
index|]
operator|=
name|tmpcol
index|[
name|y
operator|/
literal|3
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|tmpcol
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|fill (ppm_t * p,guchar * c)
name|fill
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|guchar
modifier|*
name|c
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|c
index|[
literal|0
index|]
operator|==
name|c
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|c
index|[
literal|0
index|]
operator|==
name|c
index|[
literal|2
index|]
operator|)
condition|)
block|{
name|guchar
name|col
init|=
name|c
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memset
argument_list|(
name|p
operator|->
name|col
operator|+
name|y
operator|*
name|p
operator|->
name|width
operator|*
literal|3
argument_list|,
name|col
argument_list|,
name|p
operator|->
name|width
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|row
init|=
name|p
operator|->
name|col
operator|+
name|y
operator|*
name|p
operator|->
name|width
operator|*
literal|3
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
name|int
name|k
init|=
name|x
operator|*
literal|3
decl_stmt|;
name|row
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|c
index|[
literal|0
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|c
index|[
literal|1
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|c
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|ppm_copy (ppm_t * s,ppm_t * p)
name|ppm_copy
parameter_list|(
name|ppm_t
modifier|*
name|s
parameter_list|,
name|ppm_t
modifier|*
name|p
parameter_list|)
block|{
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|s
operator|->
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|s
operator|->
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|g_memdup
argument_list|(
name|s
operator|->
name|col
argument_list|,
name|p
operator|->
name|width
operator|*
literal|3
operator|*
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|free_rotate (ppm_t * p,double amount)
name|free_rotate
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|double
name|amount
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|double
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|double
name|R
decl_stmt|,
name|a
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|double
name|f
init|=
name|amount
operator|*
name|G_PI
operator|*
literal|2
operator|/
literal|360.0
decl_stmt|;
name|int
name|rowstride
init|=
name|p
operator|->
name|width
operator|*
literal|3
decl_stmt|;
name|a
operator|=
name|p
operator|->
name|width
operator|/
operator|(
name|float
operator|)
name|p
operator|->
name|height
expr_stmt|;
name|R
operator|=
name|p
operator|->
name|width
operator|<
name|p
operator|->
name|height
condition|?
name|p
operator|->
name|width
operator|/
literal|2
else|:
name|p
operator|->
name|height
operator|/
literal|2
expr_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|p
operator|->
name|width
argument_list|,
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
name|double
name|r
decl_stmt|,
name|d
decl_stmt|;
name|nx
operator|=
name|fabs
argument_list|(
name|x
operator|-
name|p
operator|->
name|width
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|ny
operator|=
name|fabs
argument_list|(
name|y
operator|-
name|p
operator|->
name|height
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|r
operator|=
name|sqrt
argument_list|(
name|nx
operator|*
name|nx
operator|+
name|ny
operator|*
name|ny
argument_list|)
expr_stmt|;
name|d
operator|=
name|atan2
argument_list|(
operator|(
name|y
operator|-
name|p
operator|->
name|height
operator|/
literal|2.0
operator|)
argument_list|,
operator|(
name|x
operator|-
name|p
operator|->
name|width
operator|/
literal|2.0
operator|)
argument_list|)
expr_stmt|;
name|nx
operator|=
operator|(
name|p
operator|->
name|width
operator|/
literal|2.0
operator|+
name|cos
argument_list|(
name|d
operator|-
name|f
argument_list|)
operator|*
name|r
operator|)
expr_stmt|;
name|ny
operator|=
operator|(
name|p
operator|->
name|height
operator|/
literal|2.0
operator|+
name|sin
argument_list|(
name|d
operator|-
name|f
argument_list|)
operator|*
name|r
operator|)
expr_stmt|;
name|get_rgb
argument_list|(
name|p
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|,
name|tmp
operator|.
name|col
operator|+
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|crop (ppm_t * p,int lx,int ly,int hx,int hy)
name|crop
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|lx
parameter_list|,
name|int
name|ly
parameter_list|,
name|int
name|hx
parameter_list|,
name|int
name|hy
parameter_list|)
block|{
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|srowstride
init|=
name|p
operator|->
name|width
operator|*
literal|3
decl_stmt|;
name|int
name|drowstride
decl_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|hx
operator|-
name|lx
argument_list|,
name|hy
operator|-
name|ly
argument_list|)
expr_stmt|;
name|drowstride
operator|=
name|tmp
operator|.
name|width
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|y
operator|=
name|ly
init|;
name|y
operator|<
name|hy
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|lx
init|;
name|x
operator|<
name|hx
condition|;
name|x
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|tmp
operator|.
name|col
index|[
operator|(
name|y
operator|-
name|ly
operator|)
operator|*
name|drowstride
operator|+
operator|(
name|x
operator|-
name|lx
operator|)
operator|*
literal|3
index|]
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|y
operator|*
name|srowstride
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|autocrop (ppm_t * p,int room)
name|autocrop
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|room
parameter_list|)
block|{
name|int
name|lx
init|=
literal|0
decl_stmt|,
name|hx
init|=
name|p
operator|->
name|width
decl_stmt|,
name|ly
init|=
literal|0
decl_stmt|,
name|hy
init|=
name|p
operator|->
name|height
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|guchar
name|tc
index|[
literal|3
index|]
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|rowstride
init|=
name|p
operator|->
name|width
operator|*
literal|3
decl_stmt|;
name|int
name|drowstride
decl_stmt|;
comment|/* upper */
name|memcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|p
operator|->
name|col
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|n
condition|)
name|ly
operator|=
name|y
expr_stmt|;
if|#
directive|if
literal|0
block|printf("ly = %d\n", ly);
endif|#
directive|endif
comment|/* lower */
name|memcpy
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
operator|(
name|p
operator|->
name|height
operator|-
literal|1
operator|)
operator|*
name|rowstride
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|p
operator|->
name|height
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|y
operator|--
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|n
condition|)
name|hy
operator|=
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hy
operator|>=
name|p
operator|->
name|height
condition|)
name|hy
operator|=
name|p
operator|->
name|height
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|printf("hy = %d\n", hy);
endif|#
directive|endif
comment|/* left */
name|memcpy
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|ly
operator|*
name|rowstride
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|ly
init|;
name|y
operator|<=
name|hy
operator|&&
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|n
condition|)
name|lx
operator|=
name|x
expr_stmt|;
if|#
directive|if
literal|0
block|printf("lx = %d\n", lx);
endif|#
directive|endif
comment|/* right */
name|memcpy
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|ly
operator|*
name|rowstride
operator|+
operator|(
name|p
operator|->
name|width
operator|-
literal|1
operator|)
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|p
operator|->
name|width
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|ly
init|;
name|y
operator|<=
name|hy
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|tc
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|n
condition|)
name|hx
operator|=
name|x
operator|+
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|printf("hx = %d\n", hx);
endif|#
directive|endif
name|lx
operator|-=
name|room
expr_stmt|;
if|if
condition|(
name|lx
operator|<
literal|0
condition|)
name|lx
operator|=
literal|0
expr_stmt|;
name|ly
operator|-=
name|room
expr_stmt|;
if|if
condition|(
name|ly
operator|<
literal|0
condition|)
name|ly
operator|=
literal|0
expr_stmt|;
name|hx
operator|+=
name|room
expr_stmt|;
if|if
condition|(
name|hx
operator|>=
name|p
operator|->
name|width
condition|)
name|hx
operator|=
name|p
operator|->
name|width
operator|-
literal|1
expr_stmt|;
name|hy
operator|+=
name|room
expr_stmt|;
if|if
condition|(
name|hy
operator|>=
name|p
operator|->
name|height
condition|)
name|hy
operator|=
name|p
operator|->
name|height
operator|-
literal|1
expr_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|hx
operator|-
name|lx
argument_list|,
name|hy
operator|-
name|ly
argument_list|)
expr_stmt|;
name|drowstride
operator|=
name|tmp
operator|.
name|width
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|y
operator|=
name|ly
init|;
name|y
operator|<
name|hy
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|lx
init|;
name|x
operator|<
name|hx
condition|;
name|x
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|tmp
operator|.
name|col
index|[
operator|(
name|y
operator|-
name|ly
operator|)
operator|*
name|drowstride
operator|+
operator|(
name|x
operator|-
name|lx
operator|)
operator|*
literal|3
index|]
argument_list|,
operator|&
name|p
operator|->
name|col
index|[
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_pad (ppm_t * p,int left,int right,int top,int bottom,guchar * bg)
name|ppm_pad
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|,
name|guchar
modifier|*
name|bg
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|p
operator|->
name|width
operator|+
name|left
operator|+
name|right
argument_list|,
name|p
operator|->
name|height
operator|+
name|top
operator|+
name|bottom
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|tmp
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|row
decl_stmt|,
modifier|*
name|srcrow
decl_stmt|;
name|row
operator|=
name|tmp
operator|.
name|col
operator|+
name|y
operator|*
name|tmp
operator|.
name|width
operator|*
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|<
name|top
operator|)
operator|||
operator|(
name|y
operator|>=
name|tmp
operator|.
name|height
operator|-
name|bottom
operator|)
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|tmp
operator|.
name|width
condition|;
name|x
operator|++
control|)
block|{
name|int
name|k
init|=
name|x
operator|*
literal|3
decl_stmt|;
name|row
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|bg
index|[
literal|0
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|bg
index|[
literal|1
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|bg
index|[
literal|2
index|]
expr_stmt|;
block|}
continue|continue;
block|}
name|srcrow
operator|=
name|p
operator|->
name|col
operator|+
operator|(
name|y
operator|-
name|top
operator|)
operator|*
name|p
operator|->
name|width
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|left
condition|;
name|x
operator|++
control|)
block|{
name|int
name|k
init|=
name|x
operator|*
literal|3
decl_stmt|;
name|row
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|bg
index|[
literal|0
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|bg
index|[
literal|1
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|bg
index|[
literal|2
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|x
operator|<
name|tmp
operator|.
name|width
operator|-
name|right
condition|;
name|x
operator|++
control|)
block|{
name|int
name|k
init|=
name|y
operator|*
name|tmp
operator|.
name|width
operator|*
literal|3
operator|+
name|x
operator|*
literal|3
decl_stmt|;
name|tmp
operator|.
name|col
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|srcrow
index|[
operator|(
name|x
operator|-
name|left
operator|)
operator|*
literal|3
operator|+
literal|0
index|]
expr_stmt|;
name|tmp
operator|.
name|col
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|srcrow
index|[
operator|(
name|x
operator|-
name|left
operator|)
operator|*
literal|3
operator|+
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|col
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|srcrow
index|[
operator|(
name|x
operator|-
name|left
operator|)
operator|*
literal|3
operator|+
literal|2
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|x
operator|<
name|tmp
operator|.
name|width
condition|;
name|x
operator|++
control|)
block|{
name|int
name|k
init|=
name|x
operator|*
literal|3
decl_stmt|;
name|row
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|bg
index|[
literal|0
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|bg
index|[
literal|1
index|]
expr_stmt|;
name|row
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|bg
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_save (ppm_t * p,const char * fn)
name|ppm_save
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|g_fopen
argument_list|(
name|fn
argument_list|,
literal|"wb"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/*        * gimp_filename_to_utf8 () and g_strerror () return temporary strings        * that need not and should not be freed. So this call is OK.        * */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Failed to save PPM file '%s': %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|fn
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"P6\n%d %d\n255\n"
argument_list|,
name|p
operator|->
name|width
argument_list|,
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|p
operator|->
name|col
argument_list|,
name|p
operator|->
name|width
operator|*
literal|3
operator|*
name|p
operator|->
name|height
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|edgepad (ppm_t * p,int left,int right,int top,int bottom)
name|edgepad
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|guchar
name|testcol
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|255
block|,
literal|0
block|}
decl_stmt|;
name|int
name|srowstride
decl_stmt|,
name|drowstride
decl_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|p
operator|->
name|width
operator|+
name|left
operator|+
name|right
argument_list|,
name|p
operator|->
name|height
operator|+
name|top
operator|+
name|bottom
argument_list|)
expr_stmt|;
name|fill
argument_list|(
operator|&
name|tmp
argument_list|,
name|testcol
argument_list|)
expr_stmt|;
name|srowstride
operator|=
name|p
operator|->
name|width
operator|*
literal|3
expr_stmt|;
name|drowstride
operator|=
name|tmp
operator|.
name|width
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|top
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmp
operator|.
name|col
index|[
name|y
operator|*
name|drowstride
operator|+
name|left
operator|*
literal|3
index|]
argument_list|,
name|p
operator|->
name|col
argument_list|,
name|srowstride
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|-
name|top
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmp
operator|.
name|col
index|[
name|y
operator|*
name|drowstride
operator|+
name|left
operator|*
literal|3
index|]
argument_list|,
name|p
operator|->
name|col
operator|+
operator|(
name|y
operator|-
name|top
operator|)
operator|*
name|srowstride
argument_list|,
name|srowstride
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|<
name|tmp
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmp
operator|.
name|col
index|[
name|y
operator|*
name|drowstride
operator|+
name|left
operator|*
literal|3
index|]
argument_list|,
name|p
operator|->
name|col
operator|+
operator|(
name|p
operator|->
name|height
operator|-
literal|1
operator|)
operator|*
name|srowstride
argument_list|,
name|srowstride
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|tmp
operator|.
name|height
condition|;
name|y
operator|++
control|)
block|{
name|guchar
modifier|*
name|col
decl_stmt|,
modifier|*
name|tmprow
decl_stmt|;
name|tmprow
operator|=
name|tmp
operator|.
name|col
operator|+
name|y
operator|*
name|drowstride
expr_stmt|;
name|col
operator|=
name|tmp
operator|.
name|col
operator|+
name|y
operator|*
name|drowstride
operator|+
name|left
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|left
condition|;
name|x
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmprow
index|[
name|x
operator|*
literal|3
index|]
argument_list|,
name|col
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|col
operator|=
name|tmp
operator|.
name|col
operator|+
name|y
operator|*
name|drowstride
operator|+
operator|(
name|tmp
operator|.
name|width
operator|-
name|right
operator|-
literal|1
operator|)
operator|*
literal|3
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|right
condition|;
name|x
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmprow
index|[
operator|(
name|x
operator|+
name|tmp
operator|.
name|width
operator|-
name|right
operator|-
literal|1
operator|)
operator|*
literal|3
index|]
argument_list|,
name|col
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_apply_gamma (ppm_t * p,float e,int r,int g,int b)
name|ppm_apply_gamma
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|float
name|e
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|l
init|=
name|p
operator|->
name|width
operator|*
literal|3
operator|*
name|p
operator|->
name|height
decl_stmt|;
name|guchar
name|xlat
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pix
decl_stmt|;
if|if
condition|(
name|e
operator|>
literal|0.0
condition|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
name|xlat
index|[
name|x
index|]
operator|=
name|pow
argument_list|(
operator|(
name|x
operator|/
literal|255.0
operator|)
argument_list|,
operator|(
literal|1.0
operator|/
name|e
operator|)
argument_list|)
operator|*
literal|255.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|<
literal|0.0
condition|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
name|xlat
index|[
literal|255
operator|-
name|x
index|]
operator|=
name|pow
argument_list|(
operator|(
name|x
operator|/
literal|255.0
operator|)
argument_list|,
operator|(
operator|-
literal|1.0
operator|/
name|e
operator|)
argument_list|)
operator|*
literal|255.0
expr_stmt|;
block|}
else|else
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
name|xlat
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|pix
operator|=
name|p
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|r
condition|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|l
condition|;
name|x
operator|+=
literal|3
control|)
name|pix
index|[
name|x
index|]
operator|=
name|xlat
index|[
name|pix
index|[
name|x
index|]
index|]
expr_stmt|;
if|if
condition|(
name|g
condition|)
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|l
condition|;
name|x
operator|+=
literal|3
control|)
name|pix
index|[
name|x
index|]
operator|=
name|xlat
index|[
name|pix
index|[
name|x
index|]
index|]
expr_stmt|;
if|if
condition|(
name|b
condition|)
for|for
control|(
name|x
operator|=
literal|2
init|;
name|x
operator|<
name|l
condition|;
name|x
operator|+=
literal|3
control|)
name|pix
index|[
name|x
index|]
operator|=
name|xlat
index|[
name|pix
index|[
name|x
index|]
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_apply_brightness (ppm_t * p,float e,int r,int g,int b)
name|ppm_apply_brightness
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|float
name|e
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|l
init|=
name|p
operator|->
name|width
operator|*
literal|3
operator|*
name|p
operator|->
name|height
decl_stmt|;
name|guchar
name|xlat
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pix
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
name|xlat
index|[
name|x
index|]
operator|=
name|x
operator|*
name|e
expr_stmt|;
name|pix
operator|=
name|p
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|r
condition|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|l
condition|;
name|x
operator|+=
literal|3
control|)
name|pix
index|[
name|x
index|]
operator|=
name|xlat
index|[
name|pix
index|[
name|x
index|]
index|]
expr_stmt|;
if|if
condition|(
name|g
condition|)
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|l
condition|;
name|x
operator|+=
literal|3
control|)
name|pix
index|[
name|x
index|]
operator|=
name|xlat
index|[
name|pix
index|[
name|x
index|]
index|]
expr_stmt|;
if|if
condition|(
name|b
condition|)
for|for
control|(
name|x
operator|=
literal|2
init|;
name|x
operator|<
name|l
condition|;
name|x
operator|+=
literal|3
control|)
name|pix
index|[
name|x
index|]
operator|=
name|xlat
index|[
name|pix
index|[
name|x
index|]
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|blur (ppm_t * p,int xrad,int yrad)
name|blur
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|int
name|xrad
parameter_list|,
name|int
name|yrad
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|;
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|ppm_t
name|tmp
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|n
decl_stmt|;
name|int
name|rowstride
init|=
name|p
operator|->
name|width
operator|*
literal|3
decl_stmt|;
name|ppm_new
argument_list|(
operator|&
name|tmp
argument_list|,
name|p
operator|->
name|width
argument_list|,
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|p
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|p
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
name|r
operator|=
name|g
operator|=
name|b
operator|=
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ty
operator|=
name|y
operator|-
name|yrad
init|;
name|ty
operator|<=
name|y
operator|+
name|yrad
condition|;
name|ty
operator|++
control|)
block|{
for|for
control|(
name|tx
operator|=
name|x
operator|-
name|xrad
init|;
name|tx
operator|<=
name|x
operator|+
name|xrad
condition|;
name|tx
operator|++
control|)
block|{
if|if
condition|(
name|ty
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ty
operator|>=
name|p
operator|->
name|height
condition|)
continue|continue;
if|if
condition|(
name|tx
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tx
operator|>=
name|p
operator|->
name|width
condition|)
continue|continue;
name|k
operator|=
name|ty
operator|*
name|rowstride
operator|+
name|tx
operator|*
literal|3
expr_stmt|;
name|r
operator|+=
name|p
operator|->
name|col
index|[
name|k
operator|+
literal|0
index|]
expr_stmt|;
name|g
operator|+=
name|p
operator|->
name|col
index|[
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|b
operator|+=
name|p
operator|->
name|col
index|[
name|k
operator|+
literal|2
index|]
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|k
operator|=
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
expr_stmt|;
name|tmp
operator|.
name|col
index|[
name|k
operator|+
literal|0
index|]
operator|=
name|r
operator|/
name|n
expr_stmt|;
name|tmp
operator|.
name|col
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|g
operator|/
name|n
expr_stmt|;
name|tmp
operator|.
name|col
index|[
name|k
operator|+
literal|2
index|]
operator|=
name|b
operator|/
name|n
expr_stmt|;
block|}
block|}
name|ppm_kill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|tmp
operator|.
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|tmp
operator|.
name|height
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|tmp
operator|.
name|col
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_put_rgb_fast (ppm_t * s,float xo,float yo,guchar * d)
name|ppm_put_rgb_fast
parameter_list|(
name|ppm_t
modifier|*
name|s
parameter_list|,
name|float
name|xo
parameter_list|,
name|float
name|yo
parameter_list|,
name|guchar
modifier|*
name|d
parameter_list|)
block|{
name|guchar
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|s
operator|->
name|col
operator|+
name|s
operator|->
name|width
operator|*
literal|3
operator|*
call|(
name|int
call|)
argument_list|(
name|yo
operator|+
literal|0.5
argument_list|)
operator|+
literal|3
operator|*
call|(
name|int
call|)
argument_list|(
name|xo
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|tp
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
name|tp
index|[
literal|2
index|]
operator|=
name|d
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_put_rgb (ppm_t * s,float xo,float yo,guchar * d)
name|ppm_put_rgb
parameter_list|(
name|ppm_t
modifier|*
name|s
parameter_list|,
name|float
name|xo
parameter_list|,
name|float
name|yo
parameter_list|,
name|guchar
modifier|*
name|d
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|float
name|aa
decl_stmt|,
name|ab
decl_stmt|,
name|ba
decl_stmt|,
name|bb
decl_stmt|;
name|int
name|k
decl_stmt|,
name|rowstride
init|=
name|s
operator|->
name|width
operator|*
literal|3
decl_stmt|;
name|x
operator|=
name|xo
expr_stmt|;
name|y
operator|=
name|yo
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|<
literal|0
operator|)
operator|||
operator|(
name|y
operator|<
literal|0
operator|)
operator|||
operator|(
name|x
operator|>=
name|s
operator|->
name|width
operator|-
literal|1
operator|)
operator|||
operator|(
name|y
operator|>=
name|s
operator|->
name|height
operator|-
literal|1
operator|)
condition|)
return|return;
name|xo
operator|-=
name|x
expr_stmt|;
name|yo
operator|-=
name|y
expr_stmt|;
name|aa
operator|=
operator|(
literal|1.0
operator|-
name|xo
operator|)
operator|*
operator|(
literal|1.0
operator|-
name|yo
operator|)
expr_stmt|;
name|ab
operator|=
name|xo
operator|*
operator|(
literal|1.0
operator|-
name|yo
operator|)
expr_stmt|;
name|ba
operator|=
operator|(
literal|1.0
operator|-
name|xo
operator|)
operator|*
name|yo
expr_stmt|;
name|bb
operator|=
name|xo
operator|*
name|yo
expr_stmt|;
name|k
operator|=
name|y
operator|*
name|rowstride
operator|+
name|x
operator|*
literal|3
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|0
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|aa
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|1
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|aa
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|2
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|aa
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|3
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|ab
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|4
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|ab
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|5
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|ab
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|0
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|ba
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|1
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|ba
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|2
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|ba
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|3
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|bb
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|4
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|bb
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|5
index|]
operator|*=
operator|(
literal|1.0
operator|-
name|bb
operator|)
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|0
index|]
operator|+=
name|aa
operator|*
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|1
index|]
operator|+=
name|aa
operator|*
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|2
index|]
operator|+=
name|aa
operator|*
name|d
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|3
index|]
operator|+=
name|ab
operator|*
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|4
index|]
operator|+=
name|ab
operator|*
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
literal|5
index|]
operator|+=
name|ab
operator|*
name|d
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|0
index|]
operator|+=
name|ba
operator|*
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|1
index|]
operator|+=
name|ba
operator|*
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|2
index|]
operator|+=
name|ba
operator|*
name|d
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|3
index|]
operator|+=
name|bb
operator|*
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|4
index|]
operator|+=
name|bb
operator|*
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|col
index|[
name|k
operator|+
name|rowstride
operator|+
literal|5
index|]
operator|+=
name|bb
operator|*
name|d
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|ppm_drawline (ppm_t * p,float fx,float fy,float tx,float ty,guchar * col)
name|ppm_drawline
parameter_list|(
name|ppm_t
modifier|*
name|p
parameter_list|,
name|float
name|fx
parameter_list|,
name|float
name|fy
parameter_list|,
name|float
name|tx
parameter_list|,
name|float
name|ty
parameter_list|,
name|guchar
modifier|*
name|col
parameter_list|)
block|{
name|float
name|i
decl_stmt|;
name|float
name|d
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|fx
operator|-
name|tx
argument_list|)
operator|>
name|fabs
argument_list|(
name|fy
operator|-
name|ty
argument_list|)
condition|)
block|{
if|if
condition|(
name|fx
operator|>
name|tx
condition|)
block|{
name|i
operator|=
name|tx
expr_stmt|;
name|tx
operator|=
name|fx
expr_stmt|;
name|fx
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|ty
expr_stmt|;
name|ty
operator|=
name|fy
expr_stmt|;
name|fy
operator|=
name|i
expr_stmt|;
block|}
name|d
operator|=
operator|(
name|ty
operator|-
name|fy
operator|)
operator|/
operator|(
name|tx
operator|-
name|fx
operator|)
expr_stmt|;
name|y
operator|=
name|fy
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fx
init|;
name|x
operator|<=
name|tx
condition|;
name|x
operator|+=
literal|1.0
control|)
block|{
name|ppm_put_rgb
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|y
operator|+=
name|d
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fy
operator|>
name|ty
condition|)
block|{
name|i
operator|=
name|tx
expr_stmt|;
name|tx
operator|=
name|fx
expr_stmt|;
name|fx
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|ty
expr_stmt|;
name|ty
operator|=
name|fy
expr_stmt|;
name|fy
operator|=
name|i
expr_stmt|;
block|}
name|d
operator|=
operator|(
name|tx
operator|-
name|fx
operator|)
operator|/
operator|(
name|ty
operator|-
name|fy
operator|)
expr_stmt|;
name|x
operator|=
name|fx
expr_stmt|;
for|for
control|(
name|y
operator|=
name|fy
init|;
name|y
operator|<=
name|ty
condition|;
name|y
operator|+=
literal|1.0
control|)
block|{
name|ppm_put_rgb
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|x
operator|+=
name|d
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

