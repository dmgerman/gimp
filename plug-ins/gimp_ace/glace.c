begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* :PREAMBLE: Glace.c  *  * Wrapper-independent Code:  *            For both PBMPLUS and Tk/Tcl-based versions  */
end_comment

begin_comment
comment|/*  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  See the file COPYING for details.  *  */
end_comment

begin_comment
comment|/* :HEADERS:  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_comment
comment|/* auto-generated by configure */
end_comment

begin_include
include|#
directive|include
file|"glaceInt.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_comment
comment|/* FLT_MIN ??? */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GLACE_GIMP
end_ifdef

begin_include
include|#
directive|include
file|"color.h"
end_include

begin_comment
comment|/* for vR vG vB -> y conversion, below. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* :*** Process Blocks ***:   * :FUNCTION: Glace_Output  */
end_comment

begin_define
DECL|macro|YMAP_ADD
define|#
directive|define
name|YMAP_ADD
value|(1.0)
end_define

begin_function
name|int
DECL|function|Glace_Output (Glace_WData wData,Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_Output
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|Glace_MidGray
name|temp_gray
decl_stmt|,
name|out_offset
decl_stmt|;
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|Glace_MidGray
modifier|*
name|agP
decl_stmt|;
comment|/*  register Glace_Pixel* opP;*/
name|Glace_Gray
modifier|*
name|ogP
decl_stmt|,
name|tmph
decl_stmt|,
name|tmpl
decl_stmt|;
comment|/* COLOR_Yxy */
name|Glace_Gray
modifier|*
name|xP
decl_stmt|,
modifier|*
name|yP
decl_stmt|;
comment|/* COLOR_LUMIN */
name|Glace_Gray
modifier|*
name|rP
decl_stmt|,
modifier|*
name|gP
decl_stmt|,
modifier|*
name|bP
decl_stmt|;
name|long
name|temp_long
decl_stmt|;
name|int
name|round_off
decl_stmt|;
specifier|register
name|int
name|gstep
decl_stmt|;
comment|/*float tmpz,tmpy;*/
comment|/* We output row-by-row */
name|Glace_WPutImgStart
argument_list|(
name|wData
argument_list|,
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
comment|/* 255 because that brings zero to the right (?) place and      1 because that becomes 0.5, that is rounding by truncation. */
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|==
name|GLACE_CC
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|==
name|GLACE_TRUE
operator|)
condition|)
name|round_off
operator|=
literal|0
expr_stmt|;
else|else
name|round_off
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
condition|)
name|out_offset
operator|=
operator|(
name|long
operator|)
name|ldexp
argument_list|(
literal|255
operator|+
name|round_off
argument_list|,
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|)
argument_list|)
expr_stmt|;
comment|/*   out_offset = (long)       ldexp(255 - ((double) 255.0-2*GLACE_CFG(inoffsetVal))                                  * GLACE_CFG(addbackFactor) + round_off, 				 (ACC_BITS - OUT_BITS));*/
else|else
name|out_offset
operator|=
operator|(
literal|255
operator|+
name|round_off
operator|)
operator|<<
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|)
expr_stmt|;
comment|/*  tmpz= (float) ldexp((double)out_offset ,-(ACC_BITS - OUT_BITS + 1) );   tmpy =  (float) ldexp((double)1.0 ,-(ACC_BITS - OUT_BITS + 1) );   */
name|agP
operator|=
name|GLACE_IMG
argument_list|(
name|outAccImgPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
condition|;
name|r
operator|++
control|)
block|{
name|Glace_WPutImgRowStart
argument_list|(
name|wData
argument_list|,
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|!=
name|GLACE_CC
operator|)
operator|&&
operator|(
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|==
name|GLACE_FALSE
operator|)
condition|)
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doClip
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
for|for
control|(
name|gstep
operator|=
name|GLACE_IMG
argument_list|(
name|pixelBytePad
argument_list|)
operator|,
name|c
operator|=
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|putImgRowPtr
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|ogP
operator|++
operator|,
name|ogP
operator|+=
name|gstep
operator|,
name|agP
operator|++
control|)
block|{
name|temp_gray
operator|=
operator|(
operator|*
name|agP
operator|+
name|out_offset
operator|)
operator|>>
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*temp_gray = (Glace_MidGray) (((float) *agP)*tmpy +tmpz);*/
operator|*
name|ogP
operator|=
name|temp_gray
operator|>
literal|255
condition|?
literal|255
else|:
name|temp_gray
operator|<
literal|0
condition|?
literal|0
else|:
name|temp_gray
expr_stmt|;
block|}
else|else
for|for
control|(
name|gstep
operator|=
name|GLACE_IMG
argument_list|(
name|pixelBytePad
argument_list|)
operator|,
name|c
operator|=
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|putImgRowPtr
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|ogP
operator|++
operator|,
name|ogP
operator|+=
name|gstep
operator|,
name|agP
operator|++
control|)
block|{
name|temp_gray
operator|=
operator|(
operator|*
name|agP
operator|+
name|out_offset
operator|)
operator|>>
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*temp_gray = (Glace_MidGray) (((float) *agP)*tmpy +tmpz);*/
operator|*
name|ogP
operator|=
name|temp_gray
operator|>
literal|255
condition|?
literal|255
else|:
name|temp_gray
operator|<
literal|0
condition|?
literal|0
else|:
literal|127
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
for|for
control|(
name|gstep
operator|=
literal|3
operator|+
name|GLACE_IMG
argument_list|(
name|pixelBytePad
argument_list|)
operator|,
name|c
operator|=
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|putImgRowPtr
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|ogP
operator|+=
name|gstep
operator|,
operator|++
name|agP
control|)
block|{
name|temp_long
operator|=
operator|(
operator|*
name|agP
operator|+
name|out_offset
operator|)
operator|<<
operator|(
literal|8
operator|-
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|temp_long
operator|=
name|temp_long
operator|>
literal|65535
condition|?
literal|65535
else|:
name|temp_long
operator|<
literal|0
condition|?
literal|0
else|:
name|temp_long
expr_stmt|;
name|BYTE_SPLIT
argument_list|(
name|temp_long
argument_list|,
name|tmph
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|GLACE_ASSIGN
argument_list|(
operator|*
operator|(
operator|(
name|Glace_Pixel
operator|*
operator|)
name|ogP
operator|)
argument_list|,
name|tmph
argument_list|,
name|tmph
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|colorMethod
argument_list|)
operator|==
name|GLACE_COLOR_Yxy
condition|)
block|{
for|for
control|(
name|gstep
operator|=
literal|3
operator|+
name|GLACE_IMG
argument_list|(
name|pixelBytePad
argument_list|)
operator|,
name|c
operator|=
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|putImgRowPtr
argument_list|)
operator|,
name|xP
operator|=
name|GLACE_IMG
argument_list|(
name|inImgCxPtr
argument_list|)
operator|+
name|r
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
name|yP
operator|=
name|GLACE_IMG
argument_list|(
name|inImgCyPtr
argument_list|)
operator|+
name|r
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|ogP
operator|+=
name|gstep
operator|,
name|xP
operator|+=
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
name|yP
operator|+=
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
operator|++
name|agP
control|)
block|{
name|float
name|x
decl_stmt|,
name|y
decl_stmt|,
name|X2
decl_stmt|,
name|Y2
decl_stmt|,
name|Z2
decl_stmt|,
name|vR
decl_stmt|,
name|vG
decl_stmt|,
name|vB
decl_stmt|;
comment|/* Note that x and y here range from 0 - 255 */
name|x
operator|=
operator|*
name|xP
expr_stmt|;
name|y
operator|=
operator|*
name|yP
expr_stmt|;
name|Y2
operator|=
operator|(
name|float
operator|)
name|ldexp
argument_list|(
operator|(
name|double
operator|)
operator|*
name|agP
operator|+
name|out_offset
argument_list|,
operator|-
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|Y2
operator|=
name|CLAMP
argument_list|(
name|Y2
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/* Convert new XYZ coordinates to RGB. */
comment|/* This is what it looks like without Y2 factored out: 	     vR = CLAMP(R_x * X2 + R_y * Y2 + R_z * Z2, 0,255); */
comment|/* Make new XYZ coordinates with new Y and same chromacity. */
comment|/* NOTE: These are not really X and Z coordinates! 	     They are missing a factor of Y2. 	     (Notice that Y2 is a factor of every term in the RGB 	     equations, so one may factor it out...) */
name|X2
operator|=
operator|(
name|x
operator|/
name|y
operator|)
expr_stmt|;
comment|/* * Y2 */
name|Z2
operator|=
operator|(
operator|(
literal|255.0
operator|-
name|x
operator|-
name|y
operator|)
operator|/
name|y
operator|)
expr_stmt|;
comment|/* * Y2 */
name|vR
operator|=
name|CLAMP
argument_list|(
name|Y2
operator|*
operator|(
name|R_x
operator|*
name|X2
operator|+
name|R_y
operator|+
name|R_z
operator|*
name|Z2
operator|)
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|vG
operator|=
name|CLAMP
argument_list|(
name|Y2
operator|*
operator|(
name|G_x
operator|*
name|X2
operator|+
name|G_y
operator|+
name|G_z
operator|*
name|Z2
operator|)
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|vB
operator|=
name|CLAMP
argument_list|(
name|Y2
operator|*
operator|(
name|B_x
operator|*
name|X2
operator|+
name|B_y
operator|+
name|B_z
operator|*
name|Z2
operator|)
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|GLACE_ASSIGN
argument_list|(
operator|*
operator|(
operator|(
name|Glace_Pixel
operator|*
operator|)
name|ogP
operator|)
argument_list|,
name|vR
argument_list|,
name|vG
argument_list|,
name|vB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* endif COLOR_Yxy */
else|else
block|{
comment|/* COLOR_LUMIN */
for|for
control|(
name|gstep
operator|=
literal|3
operator|+
name|GLACE_IMG
argument_list|(
name|pixelBytePad
argument_list|)
operator|,
name|c
operator|=
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|putImgRowPtr
argument_list|)
operator|,
name|rP
operator|=
name|GLACE_IMG
argument_list|(
name|inImgRPtr
argument_list|)
operator|+
name|r
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
name|gP
operator|=
name|GLACE_IMG
argument_list|(
name|inImgGPtr
argument_list|)
operator|+
name|r
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
name|bP
operator|=
name|GLACE_IMG
argument_list|(
name|inImgBPtr
argument_list|)
operator|+
name|r
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|ogP
operator|+=
name|gstep
operator|,
name|rP
operator|+=
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
name|gP
operator|+=
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
name|bP
operator|+=
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|,
operator|++
name|agP
control|)
block|{
name|float
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|vR
decl_stmt|,
name|vG
decl_stmt|,
name|vB
decl_stmt|,
name|lambda
decl_stmt|;
name|float
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
specifier|const
name|Glace_Gray
name|mmaxval
init|=
name|GLACE_MAXMAXGRAY
decl_stmt|;
name|y2
operator|=
operator|(
name|float
operator|)
name|ldexp
argument_list|(
operator|(
name|double
operator|)
operator|*
name|agP
operator|+
name|out_offset
argument_list|,
operator|-
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|y2
operator|=
name|y2
operator|>
literal|255
condition|?
literal|255
else|:
name|y2
operator|<
literal|0
condition|?
literal|0
else|:
name|y2
expr_stmt|;
name|vR
operator|=
operator|*
name|rP
expr_stmt|;
name|vG
operator|=
operator|*
name|gP
expr_stmt|;
name|vB
operator|=
operator|*
name|bP
expr_stmt|;
comment|/* y1 = 0.299*vR + 0.587*vG + 0.114*vB; */
name|y1
operator|=
name|Y_r
operator|*
name|vR
operator|+
name|Y_g
operator|*
name|vG
operator|+
name|Y_b
operator|*
name|vB
expr_stmt|;
name|vR
operator|-=
name|y1
expr_stmt|;
name|vG
operator|-=
name|y1
expr_stmt|;
name|vB
operator|-=
name|y1
expr_stmt|;
name|beta
operator|=
name|max
argument_list|(
name|max
argument_list|(
name|vR
argument_list|,
name|vG
argument_list|)
argument_list|,
name|vB
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|abs
argument_list|(
name|min
argument_list|(
name|min
argument_list|(
name|vR
argument_list|,
name|vG
argument_list|)
argument_list|,
name|vB
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	  lambda = min( beta*(y1-1), alpha*(maxval-1-y1) )/(beta+0.001)/(alpha+0.001);*/
name|lambda
operator|=
name|min
argument_list|(
name|beta
operator|*
name|y2
argument_list|,
name|alpha
operator|*
operator|(
name|mmaxval
operator|-
name|y2
operator|)
argument_list|)
operator|/
operator|(
name|YMAP_ADD
operator|+
name|min
argument_list|(
name|beta
operator|*
name|y1
argument_list|,
name|alpha
operator|*
operator|(
name|mmaxval
operator|-
name|y1
operator|)
argument_list|)
operator|)
expr_stmt|;
comment|/*	  lambda = min( y2/alpha, (maxval-y2)/beta ) / 		  (YMAP_ADD+min( y1/alpha, (maxval-y1)/beta ) );*/
name|GLACE_ASSIGN
argument_list|(
operator|*
operator|(
operator|(
name|Glace_Pixel
operator|*
operator|)
name|ogP
operator|)
argument_list|,
name|y2
operator|+
name|lambda
operator|*
name|vR
argument_list|,
name|y2
operator|+
name|lambda
operator|*
name|vG
argument_list|,
name|y2
operator|+
name|lambda
operator|*
name|vB
argument_list|)
expr_stmt|;
block|}
comment|/* next ogP */
block|}
comment|/* endif COLOR_LUMIN */
name|Glace_WPutImgRowFinish
argument_list|(
name|wData
argument_list|,
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|Glace_WPutImgFinish
argument_list|(
name|wData
argument_list|,
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
return|return
name|Glace_WErrorValue
argument_list|(
name|GLACE_IMG
argument_list|(
name|wData
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: GlaceBigGrayAccumulate  */
end_comment

begin_function
name|void
DECL|function|GlaceBigGrayAccumulate (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|GlaceBigGrayAccumulate
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
specifier|register
name|long
name|r
decl_stmt|;
specifier|register
name|Glace_MidGray
modifier|*
name|agP
decl_stmt|;
specifier|register
name|Glace_Gray
modifier|*
name|hgP
decl_stmt|,
modifier|*
name|lgP
decl_stmt|;
specifier|register
name|Glace_BigGray
modifier|*
name|bgP
decl_stmt|;
specifier|register
name|long
name|tmplong
decl_stmt|,
name|tmpoffset
decl_stmt|;
if|#
directive|if
literal|0
block|register Glace_Gray pixA, pixB;    Glace_FillTableForNotFilt (cfgInfoPtr,tableInfoPtr);    tmpoffset = 1<<(GLACE_TRM(accShift)-1);    for (r = GLACE_IMG(rows)*GLACE_IMG(cols)-2,          bgP = (Glace_BigGray *) GLACE_IMG(tmpImgPtr),          agP = (GLACE_IMG(accImgPtr)),          hgP = (GLACE_IMG(inImgHBPtr))+1, pixA = *(GLACE_IMG(inImgHBPtr)),          pixB=*((GLACE_IMG(inImgHBPtr))+1); r !=0; r--)               {                 tmplong = GLACE_TRM(seriesTable)[pixA];                 tmplong *= (*bgP>> (BSHIFT));                 tmplong += tmpoffset;                  *agP += (Glace_MidGray) (tmplong>> GLACE_TRM(accShift) );                  pixA = pixB;                 pixB = *hgP;                 bgP++; agP++; hgP++;               }                 tmplong = GLACE_TRM(seriesTable)[pixA];                 tmplong *= (*bgP>> (BSHIFT));                 tmplong += tmpoffset;                  *agP += (Glace_MidGray) (tmplong>> GLACE_TRM(accShift) );
elif|#
directive|elif
literal|0
specifier|register
name|Glace_Gray
name|pixA
decl_stmt|;
specifier|register
name|int
name|thisShift
decl_stmt|;
name|Glace_FillTableForNotFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|thisShift
operator|=
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
expr_stmt|;
name|tmpoffset
operator|=
literal|1
operator|<<
operator|(
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* About 1% better! */
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|-
literal|1
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
operator|+
literal|1
operator|,
name|pixA
operator|=
operator|*
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|tmplong
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|pixA
index|]
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
operator|(
name|thisShift
operator|)
argument_list|)
expr_stmt|;
name|pixA
operator|=
operator|*
name|hgP
expr_stmt|;
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
block|}
name|tmplong
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|pixA
index|]
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
operator|(
name|thisShift
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
literal|0
name|Glace_FillTableForNotFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|tmpoffset
operator|=
literal|1
operator|<<
operator|(
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|Glace_MidGray
modifier|*
name|cgP
decl_stmt|,
name|tmpMG
decl_stmt|,
name|tmpMGZ
decl_stmt|;
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|-
literal|1
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|cgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|+
literal|1
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
operator|,
name|pixA
operator|=
operator|*
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
operator|*
name|agP
operator|=
name|tmpMGZ
expr_stmt|;
name|tmplong
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|pixA
index|]
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
name|tmpMG
operator|=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
argument_list|)
expr_stmt|;
name|tmpMGZ
operator|=
operator|*
name|cgP
operator|+
name|tmpMG
expr_stmt|;
name|pixA
operator|=
operator|*
name|hgP
expr_stmt|;
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
name|cgP
operator|++
expr_stmt|;
block|}
elif|#
directive|elif
literal|0
name|float
name|tmpa
decl_stmt|,
name|tmpb
decl_stmt|,
name|tmpc
decl_stmt|,
name|tmplookup
index|[
literal|256
index|]
decl_stmt|;
name|Glace_FillTableForNotFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|tmpb
operator|=
call|(
name|float
call|)
argument_list|(
literal|1
operator|>>
operator|(
name|BSHIFT
operator|+
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmpc
operator|=
operator|(
name|float
operator|)
literal|0.5
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|255
operator|,
name|r
operator|>=
literal|0
operator|,
name|r
operator|--
control|)
name|tmplookup
index|[
name|r
index|]
operator|=
operator|(
name|float
operator|)
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|r
index|]
operator|*
name|tmpb
expr_stmt|;
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|tmpa
operator|=
name|tmplookup
index|[
operator|*
name|hgP
index|]
expr_stmt|;
name|tmpa
operator|*=
operator|(
name|float
operator|)
operator|*
name|bgP
expr_stmt|;
name|tmpa
operator|+=
name|tmpc
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmpa
argument_list|)
expr_stmt|;
comment|/*                  *agP += (Glace_MidGray)                  (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);                  */
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
block|}
elif|#
directive|elif
literal|0
name|Glace_FillTableForNotFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|tmpoffset
operator|=
literal|1
operator|<<
operator|(
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|tmplong
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
operator|*
name|hgP
index|]
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                  *agP += (Glace_MidGray)                  (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA);                  */
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
block|}
else|#
directive|else
specifier|register
name|int
name|thisShift
decl_stmt|;
specifier|register
name|long
modifier|*
name|thisTable
decl_stmt|;
specifier|register
name|Glace_FpSeries
modifier|*
name|thisAH
decl_stmt|,
modifier|*
name|thisAL
decl_stmt|,
modifier|*
name|thisBH
decl_stmt|,
modifier|*
name|thisBL
decl_stmt|;
specifier|register
name|float
name|thisABF
decl_stmt|;
name|Glace_FillTableForNotFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|thisShift
operator|=
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
expr_stmt|;
name|tmpoffset
operator|=
literal|1
operator|<<
operator|(
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
block|{
name|thisTable
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|tmplong
operator|=
name|thisTable
index|[
operator|*
name|hgP
index|]
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
name|thisShift
argument_list|)
expr_stmt|;
comment|/* 	 *agP += (Glace_MidGray) 	 (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA); 	*/
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|thisABF
operator|=
name|GLACE_TRM
argument_list|(
name|abFactor
argument_list|)
expr_stmt|;
name|thisAH
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
expr_stmt|;
name|thisAL
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
expr_stmt|;
name|thisBH
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
expr_stmt|;
name|thisBL
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_COS
condition|)
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
operator|,
name|lgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgLBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
if|#
directive|if
literal|1
name|tmplong
operator|=
name|thisAH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisBL
index|[
operator|*
name|lgP
index|]
operator|-
name|thisBH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisAL
index|[
operator|*
name|lgP
index|]
operator|+
literal|0.5
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|tmplong
operator|=
operator|(
name|thisAH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisBL
index|[
operator|*
name|lgP
index|]
operator|-
name|thisBH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisAL
index|[
operator|*
name|lgP
index|]
operator|)
operator|*
name|ldexp
argument_list|(
operator|*
name|bgP
argument_list|,
operator|-
operator|(
name|BSHIFT
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
name|thisShift
argument_list|)
expr_stmt|;
comment|/* 	     *agP += (Glace_MidGray) 	     (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA); 	    */
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
operator|,
name|lgP
operator|++
expr_stmt|;
block|}
else|else
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
operator|,
name|lgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgLBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
if|#
directive|if
literal|1
name|tmplong
operator|=
name|thisAH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisBL
index|[
operator|*
name|lgP
index|]
operator|-
name|thisBH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisAL
index|[
operator|*
name|lgP
index|]
operator|+
literal|0.5
operator|+
name|thisABF
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|bgP
operator|>>
operator|(
name|BSHIFT
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|tmplong
operator|=
operator|(
name|thisAH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisBL
index|[
operator|*
name|lgP
index|]
operator|-
name|thisBH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisAL
index|[
operator|*
name|lgP
index|]
operator|)
operator|*
name|ldexp
argument_list|(
operator|*
name|bgP
argument_list|,
operator|-
operator|(
name|BSHIFT
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
name|thisShift
argument_list|)
expr_stmt|;
comment|/* 	     *agP += (Glace_MidGray) 	     (GLACE_TRM(seriesTable)[*hgP] *  (*bgP) *tmpflA); 	    */
name|bgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|hgP
operator|++
operator|,
name|lgP
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: GlaceMidGrayAccumulate  */
end_comment

begin_function
name|void
DECL|function|GlaceMidGrayAccumulate (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|GlaceMidGrayAccumulate
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|long
name|r
decl_stmt|;
specifier|register
name|Glace_MidGray
modifier|*
name|agP
decl_stmt|;
specifier|register
name|Glace_Gray
modifier|*
name|igP
decl_stmt|;
specifier|register
name|Glace_MidGray
modifier|*
name|mgP
decl_stmt|;
specifier|register
name|long
name|tmplong
decl_stmt|,
name|tmpoffset
decl_stmt|;
name|Glace_FillTableForNotFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|tmpoffset
operator|=
literal|1
operator|<<
operator|(
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|mgP
operator|=
operator|(
name|Glace_MidGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|igP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|tmplong
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
operator|*
name|igP
index|]
expr_stmt|;
name|tmplong
operator|*=
operator|(
operator|*
name|mgP
operator|>>
operator|(
name|MSHIFT
operator|)
operator|)
expr_stmt|;
name|tmplong
operator|+=
name|tmpoffset
expr_stmt|;
operator|*
name|agP
operator|+=
call|(
name|Glace_MidGray
call|)
argument_list|(
name|tmplong
operator|>>
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
argument_list|)
expr_stmt|;
name|mgP
operator|++
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|igP
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CallFilt  */
end_comment

begin_function
name|void
DECL|function|Glace_CallFilt (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_CallFilt
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_WINDOW
condition|)
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
operator|==
name|GLACE_COS
argument_list|)
condition|)
name|Glace_FiltWind
argument_list|(
name|cfgInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|refImgLBPtr
argument_list|)
argument_list|,
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
argument_list|,
comment|/*GLACE_TRM(filtTable),*/
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|,
name|tableInfoPtr
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Glace_FiltWind
argument_list|(
name|cfgInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|refImgLBPtr
argument_list|)
argument_list|,
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
argument_list|,
comment|/*GLACE_TRM(filtTable),*/
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|,
name|tableInfoPtr
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_DIRDIFF
condition|)
block|{
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
operator|==
name|GLACE_COS
argument_list|)
condition|)
name|Glace_FiltDD
argument_list|(
name|cfgInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
argument_list|,
operator|(
name|Glace_MidGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
argument_list|,
comment|/*GLACE_TRM(filtTable),*/
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|,
name|tableInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|ddHImgPtr
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|ddVImgPtr
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_COSDIM
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Glace_FiltDD
argument_list|(
name|cfgInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
argument_list|,
operator|(
name|Glace_MidGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
argument_list|,
comment|/*GLACE_TRM(filtTable),*/
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|,
name|tableInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|ddHImgPtr
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|ddVImgPtr
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_SINDIM
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_InitAccIm  */
end_comment

begin_function
name|void
DECL|function|Glace_InitAccIm (Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_InitAccIm
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|Glace_MidGray
name|start_offset
decl_stmt|;
name|long
name|r
decl_stmt|;
name|Glace_MidGray
modifier|*
name|agP
decl_stmt|;
name|Glace_Gray
modifier|*
name|hgP
decl_stmt|,
modifier|*
name|lgP
decl_stmt|;
name|float
name|ptfac
decl_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|!=
name|GLACE_NORMAL
condition|)
return|return;
name|start_offset
operator|=
operator|(
name|long
operator|)
name|ldexp
argument_list|(
operator|-
operator|(
operator|(
name|double
operator|)
literal|255.0
operator|-
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
operator|(
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
operator|)
operator|-
literal|255.0
operator|*
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
argument_list|,
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|)
argument_list|)
expr_stmt|;
name|ptfac
operator|=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
argument_list|,
operator|(
name|ACC_BITS
operator|-
name|OUT_BITS
operator|-
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
operator|,
name|lgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgLBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
operator|*
name|agP
operator|+=
name|start_offset
operator|+
name|ptfac
operator|*
operator|(
operator|*
name|hgP
operator|*
literal|256
operator|+
operator|*
name|lgP
operator|)
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|lgP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
block|}
else|else
for|for
control|(
name|r
operator|=
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|,
name|agP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|)
operator|,
name|hgP
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|)
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
operator|*
name|agP
operator|+=
name|start_offset
operator|+
name|ptfac
operator|*
operator|(
operator|*
name|hgP
operator|*
literal|256
operator|)
expr_stmt|;
name|agP
operator|++
expr_stmt|;
name|lgP
operator|++
expr_stmt|;
name|hgP
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_GenGen  */
end_comment

begin_function
name|void
DECL|function|Glace_GenGen (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_GenGen
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|<
name|MAX_BIT_SHIFT
operator|)
operator|&&
comment|/*( (abs(GLACE_CFG(heseriesSeries)[GLACE_TRM(termNum)])> GLACE_CFG(coeffTol)) 	|| (abs(GLACE_CFG(addbackSeries)[GLACE_TRM(termNum)])> GLACE_CFG(coeffTol)) )*/
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
operator|<=
name|GLACE_CFG
argument_list|(
name|activeTerms
argument_list|)
condition|)
block|{
name|Glace_CallFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_IMG
argument_list|(
name|tmpImgGraySize
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
condition|)
name|GlaceBigGrayAccumulate
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_DIRDIFF
condition|)
name|GlaceMidGrayAccumulate
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* :*** Image Array Allocation ***:   * :FUNCTION: Glace_SetTmpImg  */
end_comment

begin_function
name|void
DECL|function|Glace_SetTmpImg (Glace_ImgArrays * imgArraysPtr,size_t graySize,int rowPad,int colPad)
name|Glace_SetTmpImg
parameter_list|(
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|,
name|size_t
name|graySize
parameter_list|,
name|int
name|rowPad
parameter_list|,
name|int
name|colPad
parameter_list|)
block|{
name|GLACE_IMG
argument_list|(
name|tmpImgGraySize
argument_list|)
operator|=
name|graySize
expr_stmt|;
name|GLACE_IMG
argument_list|(
name|tmpImgRPad
argument_list|)
operator|=
name|rowPad
expr_stmt|;
name|GLACE_IMG
argument_list|(
name|tmpImgCPad
argument_list|)
operator|=
name|colPad
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_DefaultTmpImg  */
end_comment

begin_function
name|void
DECL|function|Glace_DefaultTmpImg (Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_DefaultTmpImg
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_DIRDIFF
operator|)
condition|)
name|Glace_SetTmpImg
argument_list|(
name|imgArraysPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|Glace_SetTmpImg
argument_list|(
name|imgArraysPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_AllocImgArrays  */
end_comment

begin_function
name|void
DECL|function|Glace_AllocImgArrays (Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_AllocImgArrays
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|long
name|newTmpImgSize
decl_stmt|;
name|char
modifier|*
name|tmpPtr
decl_stmt|;
name|float
name|minBound
decl_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
operator|)
operator|&&
operator|(
name|GLACE_CFG
argument_list|(
name|plainGlace
argument_list|)
operator|==
name|GLACE_TRUE
operator|)
condition|)
block|{
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
operator|=
operator|(
name|Glace_MidGray
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|accImgSize
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the old pointer in case we need to reassign or free */
name|tmpPtr
operator|=
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
expr_stmt|;
name|newTmpImgSize
operator|=
operator|(
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|+
name|GLACE_IMG
argument_list|(
name|tmpImgCPad
argument_list|)
operator|)
operator|*
operator|(
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|+
name|GLACE_IMG
argument_list|(
name|tmpImgRPad
argument_list|)
operator|)
operator|*
name|GLACE_IMG
argument_list|(
name|tmpImgGraySize
argument_list|)
expr_stmt|;
comment|/* We allow a certain slack if the new image is slightly smaller    * than the old one.  Also, we allow greater shrinkage if the image    * is diagnostic, since the user will probably go back to the larger    * one later anyway.  Hence a base gray size of 4 bytes is assumed.    */
if|if
condition|(
name|GLACE_IMG
argument_list|(
name|tmpImgGraySize
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
condition|)
name|minBound
operator|=
literal|0.9
operator|*
operator|(
operator|(
name|float
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgGraySize
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
expr_stmt|;
else|else
name|minBound
operator|=
literal|0.9
expr_stmt|;
name|tmpPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|tmpPtr
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|tmpImgSize
argument_list|)
argument_list|,
name|newTmpImgSize
argument_list|,
literal|1
argument_list|,
name|minBound
argument_list|)
expr_stmt|;
comment|/*       (Glace_BigGray *) GLACE_IMG(tmpImgPtr) = (Glace_BigGray *) tmpPtr; */
comment|/*       (Glace_MidGray *) GLACE_IMG(tmpImgPtr) = (Glace_MidGray *) tmpPtr; */
comment|/*     if (GLACE_IMG(tmpImgGraySize) == GLACE_TMP_IMG_BIG)     {     (Glace_BigGray *) GLACE_IMG(tmpImgPtr) = (Glace_BigGray *) tmpPtr;     (Glace_MidGray *) GLACE_IMG(tmpImgPtr) = NULL;     }     else     {     (Glace_MidGray *) GLACE_IMG(tmpImgPtr) = (Glace_MidGray *) tmpPtr;     (Glace_BigGray *) GLACE_IMG(tmpImgPtr) = NULL;     }     */
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|=
name|tmpPtr
expr_stmt|;
comment|/* Assign the pointer to the accumulator used for output */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
condition|)
name|GLACE_IMG
argument_list|(
name|outAccImgPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
expr_stmt|;
else|else
name|GLACE_IMG
argument_list|(
name|outAccImgPtr
argument_list|)
operator|=
operator|(
name|Glace_MidGray
operator|*
operator|)
name|tmpPtr
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FreeImgArrays  */
end_comment

begin_function
name|void
DECL|function|Glace_FreeImgArrays (Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_FreeImgArrays
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
condition|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|accImgPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|accImgSize
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|tmpImgSize
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_AllocInputImgArrays  */
end_comment

begin_function
name|void
DECL|function|Glace_AllocInputImgArrays (Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_AllocInputImgArrays
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|int
name|bytesper
decl_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
name|bytesper
operator|=
literal|1
expr_stmt|;
else|else
name|bytesper
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|refimageMode
argument_list|)
operator|==
name|GLACE_SEPARATE
condition|)
name|GLACE_IMG
argument_list|(
name|refImgPtr
argument_list|)
operator|=
operator|(
name|Glace_Gray
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|refImgPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|refImgSize
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|bytesper
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_Gray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
else|else
name|GLACE_IMG
argument_list|(
name|refImgPtr
argument_list|)
operator|=
operator|(
name|Glace_Gray
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|refImgPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|refImgSize
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_Gray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
name|GLACE_IMG
argument_list|(
name|inImgPtr
argument_list|)
operator|=
operator|(
name|Glace_Gray
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|inImgPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|inImgSize
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|bytesper
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_Gray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FreeInputImgArrays  */
end_comment

begin_function
name|void
DECL|function|Glace_FreeInputImgArrays (Glace_ImgArrays * imgArraysPtr)
name|Glace_FreeInputImgArrays
parameter_list|(
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
if|if
condition|(
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
operator|!=
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
condition|)
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
operator|=
operator|(
name|Glace_Gray
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|refImgSize
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_Gray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
operator|=
operator|(
name|Glace_Gray
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_IMG
argument_list|(
name|inImgHBPtr
argument_list|)
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|inImgSize
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_Gray
argument_list|)
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* :*** General Memory Allocation ***:   * :FUNCTION: Glace_AllocClientData  */
end_comment

begin_function
name|Glace_ClientData
modifier|*
DECL|function|Glace_AllocClientData ()
name|Glace_AllocClientData
parameter_list|()
block|{
name|Glace_ClientData
modifier|*
name|clientData
decl_stmt|;
name|clientData
operator|=
operator|(
name|Glace_ClientData
operator|*
operator|)
name|GlaceWMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Glace_ClientData
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
operator|=
name|Glace_WDataAlloc
argument_list|()
expr_stmt|;
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
operator|=
operator|(
name|Glace_CfgInfo
operator|*
operator|)
name|GlaceWMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Glace_CfgInfo
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
operator|=
operator|(
name|Glace_TableInfo
operator|*
operator|)
name|GlaceWMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Glace_TableInfo
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
operator|=
operator|(
name|Glace_ImgArrays
operator|*
operator|)
name|GlaceWMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Glace_ImgArrays
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_CfgInfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_TableInfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_ImgArrays
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
operator|)
operator|->
name|wData
operator|=
operator|(
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
operator|)
operator|->
name|wData
operator|=
operator|(
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
operator|)
operator|->
name|wData
operator|=
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
expr_stmt|;
return|return
name|clientData
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FreeClientData  */
end_comment

begin_function
name|void
DECL|function|Glace_FreeClientData (Glace_ClientData * clientData)
name|Glace_FreeClientData
parameter_list|(
name|Glace_ClientData
modifier|*
name|clientData
parameter_list|)
block|{
name|GlaceWFree
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|GlaceWFree
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|GlaceWFree
argument_list|(
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|GlaceWFree
argument_list|(
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|)
expr_stmt|;
name|GlaceWFree
argument_list|(
name|clientData
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CallocReallocFree  */
end_comment

begin_function
name|char
modifier|*
DECL|function|Glace_CallocReallocFree (void * p,long * nObjPtr,long newNObj,size_t size,float minBound)
name|Glace_CallocReallocFree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|long
modifier|*
name|nObjPtr
parameter_list|,
name|long
name|newNObj
parameter_list|,
name|size_t
name|size
parameter_list|,
name|float
name|minBound
parameter_list|)
block|{
name|char
modifier|*
name|tmpPtr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|newNObj
operator|*
operator|(
operator|(
name|long
operator|)
name|size
operator|)
operator|)
operator|>
operator|*
name|nObjPtr
operator|)
operator|||
operator|(
operator|(
name|newNObj
operator|*
name|size
operator|)
operator|<
operator|(
operator|*
name|nObjPtr
operator|*
name|minBound
operator|)
operator|)
operator|||
operator|(
operator|(
name|newNObj
operator|*
name|size
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|nObjPtr
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|newNObj
operator|*
name|size
operator|)
operator|==
literal|0
condition|)
name|GlaceWFree
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*          tmpPtr = (char *) GlaceWRealloc (p, newNObj*size);*/
name|GlaceWFree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tmpPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|GlaceWMalloc
argument_list|(
name|newNObj
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newNObj
operator|*
name|size
operator|)
operator|!=
literal|0
condition|)
name|tmpPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|GlaceWMalloc
argument_list|(
name|newNObj
operator|*
name|size
argument_list|)
expr_stmt|;
operator|*
name|nObjPtr
operator|=
operator|(
name|newNObj
operator|*
name|size
operator|)
expr_stmt|;
block|}
else|else
name|tmpPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
name|tmpPtr
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* :*** Lookup Table and Term-Wise Stuff ***:   * :FUNCTION: Glace_AllocTables  */
end_comment

begin_decl_stmt
name|void
DECL|function|Glace_AllocTables (GLACE_OVAR (Glace_CfgInfo * cfgInfoPtr),Glace_TableInfo * tableInfoPtr)
name|Glace_AllocTables
argument_list|(
name|GLACE_OVAR
argument_list|(
name|Glace_CfgInfo
operator|*
name|cfgInfoPtr
argument_list|)
argument_list|,
name|Glace_TableInfo
operator|*
name|tableInfoPtr
argument_list|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
block|{
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
operator|==
name|NULL
condition|)
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
operator|=
operator|(
name|long
operator|*
operator|)
name|GlaceWCalloc
argument_list|(
name|GLACE_MAXMAXGRAY
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
operator|=
operator|(
name|Glace_FpSeries
operator|*
operator|)
name|GlaceWCalloc
argument_list|(
operator|(
name|GLACE_MAXMAXGRAY
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_FpSeries
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
operator|+
name|GLACE_MAXMAXGRAY
operator|+
literal|1
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
operator|+
name|GLACE_MAXMAXGRAY
operator|+
literal|1
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBL
argument_list|)
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
operator|+
name|GLACE_MAXMAXGRAY
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FreeTables  */
end_comment

begin_decl_stmt
name|void
DECL|function|Glace_FreeTables (GLACE_OVAR (Glace_CfgInfo * cfgInfoPtr),Glace_TableInfo * tableInfoPtr)
name|Glace_FreeTables
argument_list|(
name|GLACE_OVAR
argument_list|(
name|Glace_CfgInfo
operator|*
name|cfgInfoPtr
argument_list|)
argument_list|,
name|Glace_TableInfo
operator|*
name|tableInfoPtr
argument_list|)
block|{
name|GlaceWFree
argument_list|(
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
argument_list|)
expr_stmt|;
name|GlaceWFree
argument_list|(
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * :FUNCTION: Glace_SetForTerm  */
end_comment

begin_function
name|void
DECL|function|Glace_SetForTerm (Glace_TableInfo * tableInfoPtr,int k,Glace_TermTypes type)
name|Glace_SetForTerm
parameter_list|(
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|int
name|k
parameter_list|,
name|Glace_TermTypes
name|type
parameter_list|)
block|{
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
operator|=
name|k
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_SetTables  */
end_comment

begin_function
name|void
DECL|function|Glace_SetTables (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr)
name|Glace_SetTables
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|)
block|{
name|float
name|area
decl_stmt|;
name|int
name|filtShifts
decl_stmt|,
name|notFiltShifts
decl_stmt|,
name|abShifts
decl_stmt|;
name|float
name|filtFactor
decl_stmt|,
name|notFiltFactor
decl_stmt|,
name|abFactor
decl_stmt|;
comment|/*  int r;*/
name|double
name|waveFactor
decl_stmt|;
comment|/* Set the table tableInfoPtr so that, after filtering (or without    * filtering) the resulting field will have max magnitude    * AFTFILTVAL.  If DIRDIFF is used, this will be shifted down to    * sit in a two-byte integer instead.    *    * The filter must shift the values down by filtShifts as part    * of its processing.  */
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_DIRDIFF
operator|)
condition|)
block|{
name|filtFactor
operator|=
name|MAFT_FILTVAL
expr_stmt|;
name|filtShifts
operator|=
literal|0
expr_stmt|;
comment|/* We aim to produce a result in the accumulator field        * between -255 and +255.        *        * Hence, to get the `notfilt' tableInfoPtr        * required to multiply AFTFILTVAL        * by to get 255*heseries[k], we proceed as follows:        */
name|notFiltFactor
operator|=
name|frexp
argument_list|(
operator|(
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|)
operator|*
literal|255.0
operator|/
name|MAFT_FILTVAL
operator|/
name|NOT_FILTVAL
argument_list|,
operator|&
name|notFiltShifts
argument_list|)
operator|*
name|NOT_FILTVAL
expr_stmt|;
name|abFactor
operator|=
name|frexp
argument_list|(
operator|(
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|)
operator|*
literal|255.0
operator|/
name|MAFT_FILTVAL
operator|/
name|NOT_FILTVAL
argument_list|,
operator|&
name|abShifts
argument_list|)
operator|*
name|NOT_FILTVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_COS
condition|)
name|area
operator|=
operator|(
literal|2.0
operator|*
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|area
operator|=
operator|(
literal|2.0
operator|*
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|filtFactor
operator|=
name|frexp
argument_list|(
literal|1.0
operator|/
name|area
argument_list|,
operator|&
name|filtShifts
argument_list|)
operator|*
name|AFT_FILTVAL
expr_stmt|;
name|filtShifts
operator|=
operator|-
name|filtShifts
expr_stmt|;
name|notFiltFactor
operator|=
name|frexp
argument_list|(
operator|(
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|)
operator|*
literal|255.0
operator|/
name|AFT_FILTVAL
operator|/
name|NOT_FILTVAL
operator|+
name|FLT_MIN
argument_list|,
operator|&
name|notFiltShifts
argument_list|)
operator|*
name|NOT_FILTVAL
expr_stmt|;
name|abFactor
operator|=
name|frexp
argument_list|(
operator|(
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
operator|)
operator|*
literal|255.0
operator|/
name|AFT_FILTVAL
operator|/
name|NOT_FILTVAL
operator|+
name|FLT_MIN
argument_list|,
operator|&
name|abShifts
argument_list|)
operator|*
name|NOT_FILTVAL
expr_stmt|;
block|}
comment|/*     * The tableInfoPtr of 2 means that the effect of the addback does not    * overflow.  -2<= ( cos(...)-addback )<=1    *    * The idea of this is that the unfiltered (co)sine table is    * already in the right place, and that the range of the filtered    * field will occupy BIG_TMP_BITS bits for max postive number.    *    * Note that the notFiltShifts is the number of left shifts    * to generate a result in the range -255 to +255.     */
comment|/*    * NO NEED IF WE ADD FLT_MIN ABOVE *   if (notFiltFactor==0.0)     {       notFiltFactor=1.0;       notFiltShifts = (FORCE_NO_BIT_SHIFT);     }   if (abFactor==0.0)     {       abFactor=1.0;       abShifts = (FORCE_NO_BIT_SHIFT);     }     */
comment|/* GLACE_MAXMAXGRAY is prescale/2 of a half-wave    * (Fourier series truncation). */
name|waveFactor
operator|=
operator|(
literal|2
operator|*
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|GLACE_PI
operator|/
name|GLACE_MAXMAXGRAY
operator|*
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_SIN
condition|)
block|{
if|if
condition|(
name|abShifts
operator|<
name|notFiltShifts
condition|)
name|abFactor
operator|=
name|ldexp
argument_list|(
name|abFactor
argument_list|,
name|abShifts
operator|-
name|notFiltShifts
argument_list|)
expr_stmt|;
else|else
block|{
name|notFiltFactor
operator|=
name|ldexp
argument_list|(
name|notFiltFactor
argument_list|,
name|notFiltShifts
operator|-
name|abShifts
argument_list|)
expr_stmt|;
name|notFiltShifts
operator|=
name|abShifts
expr_stmt|;
block|}
block|}
comment|/*   if (GLACE_TRM(termType) == GLACE_COS)     for (r = 0; r<= GLACE_MAXMAXGRAY; r++)       {         GLACE_TRM(filtTable)[r] = filtFactor           * cos ((r - GLACE_CFG(inoffsetVal)) * waveFactor);         GLACE_TRM(notFiltTable)[r] = notFiltFactor           * sin ((r - GLACE_CFG(inoffsetVal)) * waveFactor);       }   else     for (r = 0; r<= GLACE_MAXMAXGRAY; r++)       { 	GLACE_TRM(filtTable)[r] = filtFactor 	  * sin ((r - GLACE_CFG(inoffsetVal)) * waveFactor); 	GLACE_TRM(notFiltTable)[r] = -1*((long) (notFiltFactor             * (cos ((r - GLACE_CFG(inoffsetVal)) * waveFactor))             - abFactor));       }   */
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_DIRDIFF
operator|)
condition|)
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|=
operator|(
operator|-
name|notFiltShifts
operator|-
name|MSHIFT
operator|+
name|OUT_BITS
operator|-
name|ACC_BITS
operator|)
expr_stmt|;
else|else
name|GLACE_TRM
argument_list|(
name|accShift
argument_list|)
operator|=
operator|(
operator|-
name|notFiltShifts
operator|-
name|BSHIFT
operator|+
name|OUT_BITS
operator|-
name|ACC_BITS
operator|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|filtFactor
argument_list|)
operator|=
name|filtFactor
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|filtShifts
argument_list|)
operator|=
name|filtShifts
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|notFiltFactor
argument_list|)
operator|=
name|notFiltFactor
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|notFiltShifts
argument_list|)
operator|=
name|notFiltShifts
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|abFactor
argument_list|)
operator|=
name|abFactor
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|abShifts
argument_list|)
operator|=
name|abShifts
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
operator|=
name|waveFactor
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FillTableForFilt  */
end_comment

begin_function
name|void
DECL|function|Glace_FillTableForFilt (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,float scale)
name|Glace_FillTableForFilt
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|float
name|scale
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|float
name|sfac
decl_stmt|;
name|sfac
operator|=
name|scale
operator|*
name|GLACE_TRM
argument_list|(
name|filtFactor
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_COS
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|r
index|]
operator|=
literal|0.5
operator|+
name|sfac
operator|*
name|cos
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|r
index|]
operator|=
literal|0.5
operator|+
name|sfac
operator|*
name|sin
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_COS
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
index|[
name|r
index|]
operator|=
name|sfac
operator|*
name|cos
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
index|[
name|r
index|]
operator|=
operator|-
name|sfac
operator|*
name|sin
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
index|[
name|r
index|]
operator|=
name|cos
argument_list|(
name|r
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
operator|/
literal|256
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBL
argument_list|)
index|[
name|r
index|]
operator|=
name|sin
argument_list|(
name|r
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
operator|/
literal|256
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
index|[
name|r
index|]
operator|=
name|sfac
operator|*
name|sin
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
index|[
name|r
index|]
operator|=
name|sfac
operator|*
name|cos
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
index|[
name|r
index|]
operator|=
name|cos
argument_list|(
name|r
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
operator|/
literal|256
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBL
argument_list|)
index|[
name|r
index|]
operator|=
name|sin
argument_list|(
name|r
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
operator|/
literal|256
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FillTableForNotFilt   */
end_comment

begin_function
name|void
DECL|function|Glace_FillTableForNotFilt (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr)
name|Glace_FillTableForNotFilt
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|float
name|sfac
decl_stmt|;
name|sfac
operator|=
name|GLACE_TRM
argument_list|(
name|notFiltFactor
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_COS
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|r
index|]
operator|=
literal|0.5
operator|+
name|sfac
operator|*
name|sin
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
name|r
index|]
operator|=
literal|0.5
operator|+
operator|-
literal|1
operator|*
operator|(
call|(
name|double
call|)
argument_list|(
name|sfac
operator|*
operator|(
name|cos
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
operator|)
operator|-
name|GLACE_TRM
argument_list|(
name|abFactor
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GLACE_TRM
argument_list|(
name|termType
argument_list|)
operator|==
name|GLACE_COS
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
index|[
name|r
index|]
operator|=
name|sfac
operator|*
name|cos
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
index|[
name|r
index|]
operator|=
operator|-
name|sfac
operator|*
name|sin
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|GLACE_MAXMAXGRAY
condition|;
name|r
operator|++
control|)
block|{
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
index|[
name|r
index|]
operator|=
name|sfac
operator|*
name|sin
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
index|[
name|r
index|]
operator|=
name|sfac
operator|*
name|cos
argument_list|(
operator|(
name|r
operator|-
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|)
operator|*
name|GLACE_TRM
argument_list|(
name|waveFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* Output accImgPtr */
end_comment

begin_comment
comment|/* :*** Overall Process ***:   * :FUNCTION: Glace_WindChk  */
end_comment

begin_function
name|void
DECL|function|Glace_WindChk (Glace_CfgInfo * cfgInfoPtr,int rows,int cols)
name|Glace_WindChk
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|unsigned
name|int
name|k
decl_stmt|;
name|char
name|message
index|[
name|MAX_MESSAGE_LEN
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_WINDOW
condition|)
for|for
control|(
name|k
operator|=
name|GLACE_CFG
argument_list|(
name|firstTerm
argument_list|)
init|;
name|k
operator|<=
operator|(
name|unsigned
operator|)
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|r
operator|=
literal|1
expr_stmt|;
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|>=
name|cols
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Sine window width (%3d:%5d) "
literal|"too large for image."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|>=
name|rows
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cosine window height (%3d:%5d) "
literal|"too large for image."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|>=
name|cols
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Sine window height (%3d:%5d) "
literal|"too large for image."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|>=
name|rows
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cosine window width (%3d:%5d) "
literal|"too large for image."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|<
literal|3
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Sine window width (%3d:%5d) "
literal|"too small."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|<
literal|3
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cosine window height (%3d:%5d) "
literal|"too small."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|<
literal|3
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Sine window height (%3d:%5d) "
literal|"too small."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|signed
call|)
argument_list|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|<
literal|3
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cosine window width (%3d:%5d) "
literal|"too small."
argument_list|,
name|k
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_TermlyReport  */
end_comment

begin_function
name|void
DECL|function|Glace_TermlyReport (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr)
name|Glace_TermlyReport
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|)
block|{
name|char
name|message
index|[
name|MAX_MESSAGE_LEN
index|]
decl_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_WINDOW
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%5u: %5d %5d %5d %5d  %12.6g %12.6g"
argument_list|,
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%5u: %5d %5d  %12.6g %12.6g"
argument_list|,
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_COSDIM
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_SINDIM
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|GLACE_TRM
argument_list|(
name|termNum
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_DiagGen  */
end_comment

begin_function
name|void
DECL|function|Glace_DiagGen (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_DiagGen
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|long
name|r
decl_stmt|;
name|Glace_Gray
modifier|*
name|hgP
decl_stmt|,
modifier|*
name|lgP
decl_stmt|;
name|Glace_MidGray
modifier|*
name|mgP
decl_stmt|,
modifier|*
name|ogP
decl_stmt|;
name|Glace_BigGray
modifier|*
name|bgP
decl_stmt|;
specifier|register
name|Glace_FpSeries
modifier|*
name|thisAH
decl_stmt|,
modifier|*
name|thisAL
decl_stmt|,
modifier|*
name|thisBH
decl_stmt|,
modifier|*
name|thisBL
decl_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSFILT
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSRAW
operator|)
condition|)
name|Glace_SetForTerm
argument_list|(
name|tableInfoPtr
argument_list|,
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
argument_list|,
name|GLACE_COS
argument_list|)
expr_stmt|;
else|else
name|Glace_SetForTerm
argument_list|(
name|tableInfoPtr
argument_list|,
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
argument_list|,
name|GLACE_SIN
argument_list|)
expr_stmt|;
name|Glace_TermlyReport
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_SetTables
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSFILT
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINFILT
operator|)
condition|)
block|{
name|Glace_FillTableForFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|Glace_CallFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINRAW
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSRAW
operator|)
condition|)
block|{
name|Glace_FillTableForFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
for|for
control|(
name|r
operator|=
literal|0
operator|,
name|hgP
operator|=
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
operator|,
name|mgP
operator|=
operator|(
name|Glace_MidGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
init|;
name|r
operator|<
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
condition|;
name|r
operator|++
operator|,
name|mgP
operator|++
operator|,
name|hgP
operator|++
control|)
operator|*
name|mgP
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
operator|*
name|hgP
index|]
expr_stmt|;
else|else
block|{
name|thisAH
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
expr_stmt|;
name|thisAL
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
expr_stmt|;
name|thisBH
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
expr_stmt|;
name|thisBL
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBL
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
operator|,
name|hgP
operator|=
name|GLACE_IMG
argument_list|(
name|refImgHBPtr
argument_list|)
operator|,
name|lgP
operator|=
name|GLACE_IMG
argument_list|(
name|refImgLBPtr
argument_list|)
operator|,
name|mgP
operator|=
operator|(
name|Glace_MidGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
init|;
name|r
operator|<
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
condition|;
name|r
operator|++
operator|,
name|mgP
operator|++
operator|,
name|hgP
operator|++
operator|,
name|lgP
operator|++
control|)
operator|*
name|mgP
operator|=
name|thisAH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisAL
index|[
operator|*
name|lgP
index|]
operator|+
name|thisBH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisBL
index|[
operator|*
name|lgP
index|]
operator|+
literal|0.5
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GLACE_IMG
argument_list|(
name|tmpImgGraySize
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
condition|)
for|for
control|(
name|r
operator|=
literal|0
operator|,
name|bgP
operator|=
operator|(
name|Glace_BigGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|outAccImgPtr
argument_list|)
init|;
name|r
operator|<
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
condition|;
name|r
operator|++
operator|,
name|bgP
operator|++
operator|,
name|ogP
operator|++
control|)
operator|*
name|ogP
operator|=
operator|(
operator|*
name|bgP
operator|)
operator|>>
operator|(
name|BIG_TMP_BITS
operator|-
name|ACC_BITS
operator|)
expr_stmt|;
else|else
for|for
control|(
name|r
operator|=
literal|0
operator|,
name|mgP
operator|=
operator|(
name|Glace_MidGray
operator|*
operator|)
name|GLACE_IMG
argument_list|(
name|tmpImgPtr
argument_list|)
operator|,
name|ogP
operator|=
name|GLACE_IMG
argument_list|(
name|outAccImgPtr
argument_list|)
init|;
name|r
operator|<
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
condition|;
name|r
operator|++
operator|,
name|mgP
operator|++
operator|,
name|ogP
operator|++
control|)
operator|*
name|ogP
operator|=
operator|(
operator|*
name|mgP
operator|)
operator|>>
operator|(
name|MID_TMP_BITS
operator|-
name|ACC_BITS
operator|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
condition|)
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_Process  */
end_comment

begin_function
name|void
DECL|function|Glace_Process (Glace_WData wData,Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|Glace_Process
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|unsigned
name|int
name|k
decl_stmt|;
name|Glace_WindChk
argument_list|(
name|cfgInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_InitAccIm
argument_list|(
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
condition|)
for|for
control|(
name|k
operator|=
name|GLACE_CFG
argument_list|(
name|firstTerm
argument_list|)
init|;
name|k
operator|<=
operator|(
name|unsigned
operator|)
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|Glace_SetForTerm
argument_list|(
name|tableInfoPtr
argument_list|,
name|k
argument_list|,
name|GLACE_COS
argument_list|)
expr_stmt|;
name|Glace_TermlyReport
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_SetTables
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_GenGen
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_SetForTerm
argument_list|(
name|tableInfoPtr
argument_list|,
name|k
argument_list|,
name|GLACE_SIN
argument_list|)
expr_stmt|;
name|Glace_SetTables
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_GenGen
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
condition|)
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|Glace_DiagGen
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_Output
argument_list|(
name|wData
argument_list|,
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* :*** Argument Parsing ***:   * :FUNCTION: GlaceArgError  */
end_comment

begin_function
name|int
DECL|function|GlaceArgError (Glace_WData wData,const char * message,char * argv[],int numArgs,int problemArg)
name|GlaceArgError
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
name|numArgs
parameter_list|,
name|int
name|problemArg
parameter_list|)
block|{
name|char
name|argErrStr
index|[
name|GLACE_STRMAX
operator|+
literal|201
index|]
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|spaceleft
decl_stmt|;
name|int
name|k
decl_stmt|;
name|sp
operator|=
operator|&
name|argErrStr
index|[
literal|0
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|sp
argument_list|,
name|message
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"\nargument number: %u\n\t\""
argument_list|,
name|problemArg
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|spaceleft
operator|=
name|GLACE_STRMAX
init|;
operator|(
name|k
operator|<
name|numArgs
operator|)
operator|&&
operator|(
name|spaceleft
operator|>
literal|0
operator|)
condition|;
name|k
operator|++
control|)
block|{
name|strncpy
argument_list|(
name|sp
argument_list|,
name|argv
index|[
name|problemArg
operator|+
name|k
index|]
argument_list|,
name|spaceleft
argument_list|)
expr_stmt|;
name|spaceleft
operator|-=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|sprintf
argument_list|(
operator|--
name|sp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
return|return
name|Glace_WError
argument_list|(
name|wData
argument_list|,
name|argErrStr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_ParseArgs  */
end_comment

begin_function
name|int
DECL|function|Glace_ParseArgs (Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr,int argc,char * argv[])
name|Glace_ParseArgs
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|argn
decl_stmt|;
name|char
modifier|*
name|usage
init|=
literal|"OPTIONS [pgmfile]\n"
literal|"\t-reset  (reset configuration: use first\n"
literal|"\t\twhen calling as a library. Ignore on command line)\n"
literal|"\t\tMandatory arguments:\n"
literal|"\t<wind-width><wind-height><# terms> | ...\n"
literal|"\t-windlistfile<f> | ...\n"
literal|"\t<d-dim><baseval><# terms> -ddimages<horiz-pgm><vert-pgm> | ...\n"
literal|"\t-ddimages<horiz-pgm><vert-pgm> -ddlistfile<f> | ...\n"
literal|"\t\tOptions:\n"
literal|"\t-factor<alpha> | -seriesfile<s>\n"
literal|"\t-doublep   * double precision\n"
literal|"\t-cc | -cg | -gg | -cgd | -ggd\n"
literal|"\t\t* inputletter-outputletter pair (colour/gray)\n"
literal|"\t\t  -gg[d] and -doublep: split input r-ignore, g-high, b-low\n"
literal|"\t\t  d-suffix for double-precision output (split rgb/ppm)\n"
comment|/*     "\t\tppm input, -gg or -gc , w/o -doublep: read as pgm\n"*/
literal|"\t\t  -cc is overidden to -cg for diagnostic output\n"
literal|"\t\t  -cc and -cg are overidden with pgm input\n"
literal|"\t-cosraw | -cosfilt | -sinraw | -sinfilt | -clip\n"
literal|"\t-quiet | -verbose\n"
literal|"\t-hamming\n"
literal|"\t-prescale<p>\n"
literal|"\t-zaddback<a> | -laddback<a>\n"
literal|"\t-passthru<a>\n"
literal|"\t-onlyheseries   * coefficient windowing\n"
literal|"\t-tolerance<tol>   * -1 disables\n"
literal|"\t-inoffset<v>\n"
literal|"\t-gauss<w>\n"
literal|"\t-refimage<pgmfile>\n"
literal|"\t-cumulation<min><max><num-points>  * c-function\n"
literal|"Options may come in any sensible order: valueless ones like"
literal|"-verbose must\nnot come last. "
literal|"They may be abbreviated.\n"
literal|"\t** Base values are ignored in dd filtering.\n"
decl_stmt|;
comment|/* Remaining letters: bejkmnuxy */
comment|/* Indicators to check if option already scanned.       These contain the index into argv of the relevant argument. */
name|int
name|vprescale
init|=
literal|0
decl_stmt|,
name|vaddback
init|=
literal|0
decl_stmt|,
name|vinoffset
init|=
literal|0
decl_stmt|,
name|vwlistfile
init|=
literal|0
decl_stmt|,
name|vdimensions
init|=
literal|0
decl_stmt|,
name|vseriesfile
init|=
literal|0
decl_stmt|,
name|vfactor
init|=
literal|0
decl_stmt|,
name|vddimages
init|=
literal|0
decl_stmt|,
name|vddlistfile
init|=
literal|0
decl_stmt|,
name|vtype
init|=
literal|0
decl_stmt|,
name|vtol
init|=
literal|0
decl_stmt|,
name|vrefimage
init|=
literal|0
decl_stmt|,
name|vgauss
init|=
literal|0
decl_stmt|,
name|vcfunc
init|=
literal|0
decl_stmt|,
name|vinput
init|=
literal|0
decl_stmt|,
name|voutput
init|=
literal|0
decl_stmt|,
name|vpassthru
init|=
literal|0
decl_stmt|;
comment|/* The following are just overruled by a later argument:     * sinraw, sinfilt, cosraw, cosfilt, verbose, quiet.     * hamming cannot be turned off later.     */
name|int
name|last_arg
decl_stmt|;
name|argn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|Glace_WUsage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
return|return
name|Glace_WErrorValue
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
return|;
block|}
do|do
block|{
name|last_arg
operator|=
name|argn
expr_stmt|;
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-reset"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|Glace_CfgInit
argument_list|(
name|cfgInfoPtr
argument_list|)
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-cosraw"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|vtype
operator|=
name|argn
operator|++
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|=
name|GLACE_COSRAW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-sinraw"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|vtype
operator|=
name|argn
operator|++
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|=
name|GLACE_SINRAW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-cosfilt"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|vtype
operator|=
name|argn
operator|++
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|=
name|GLACE_COSFILT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-sinfilt"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|vtype
operator|=
name|argn
operator|++
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|=
name|GLACE_SINFILT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-clip"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|vtype
operator|=
name|argn
operator|++
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|doClip
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|=
name|GLACE_NORMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-quiet"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
operator|=
name|GLACE_FALSE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-verbose"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-refimage"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|vrefimage
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-input"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|vinput
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-output"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|voutput
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-hamming"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|hammingCwind
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-prescale"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|vprescale
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-passthru"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vpassthru
operator|=
name|argn
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackMode
argument_list|)
operator|=
name|GLACE_COMMANDLINE
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-zaddback"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vaddback
operator|=
name|argn
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|=
name|GLACE_ZEROINPUT
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackMode
argument_list|)
operator|=
name|GLACE_COMMANDLINE
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-laddback"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vaddback
operator|=
name|argn
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|=
name|GLACE_LOCALMEAN
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackMode
argument_list|)
operator|=
name|GLACE_COMMANDLINE
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-onlyheseries"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|addbackCwind
argument_list|)
operator|=
name|GLACE_FALSE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-gauss"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|vgauss
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-inoffset"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vinoffset
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-factor"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vfactor
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-windlistfile"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vwlistfile
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-seriesfile"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vseriesfile
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-ddlistfile"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|vddlistfile
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-ddimages"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|vddimages
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-cumulation"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|vcfunc
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-tolerance"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|vtol
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-doublep"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-ggd"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|GLACE_GG
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
comment|/* PNM: default for PGM input 	    +    and use to force reading PPM as gray*/
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-gg"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|GLACE_GG
expr_stmt|;
name|argn
operator|++
expr_stmt|;
comment|/* PNM: default for PGM input 	    +    and use to force reading PPM as gray*/
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-cgd"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|GLACE_CG
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|argn
operator|++
expr_stmt|;
comment|/* PNM: use to force gray output*/
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-cg"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|GLACE_CG
expr_stmt|;
name|argn
operator|++
expr_stmt|;
comment|/* PNM: use to force gray output*/
block|}
elseif|else
if|if
condition|(
name|Glace_WKeyMatch
argument_list|(
name|argv
index|[
name|argn
index|]
argument_list|,
literal|"-cc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|GLACE_CC
expr_stmt|;
name|argn
operator|++
expr_stmt|;
comment|/* PNM: default for PPM input and hence irrelevant */
block|}
else|else
block|{
name|vdimensions
operator|=
name|argn
expr_stmt|;
name|argn
operator|+=
literal|3
expr_stmt|;
block|}
block|}
do|while
condition|(
name|argn
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
do|;
comment|/* Possiblities here: (note argc=#args +1)     *     * Last argument must not be single, eg -verbose     *     * Single final argument must be filename or `-':   argn==argc-1     * Standard input assumed otherwise:                argn==argc-1+1     * Error if we have overspilled:                    argn>argc-1+1     */
if|if
condition|(
name|argn
operator|>
operator|(
name|argc
operator|)
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Final option was missing a value."
argument_list|,
name|argv
argument_list|,
name|argc
operator|-
name|last_arg
argument_list|,
name|last_arg
argument_list|)
return|;
comment|/* Input stream is opened at end of this procedure, so that       earlier errors are indicated first. */
comment|/* ************************************************************ */
comment|/* Check types of operation. */
comment|/* DIAGNOSTIC (sinfilt etc. override -clip when coming after) */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|!=
name|GLACE_NORMAL
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|doClip
argument_list|)
operator|=
name|GLACE_FALSE
expr_stmt|;
block|}
comment|/* HETYPE */
if|if
condition|(
name|vfactor
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|vseriesfile
operator|>
literal|0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Option conflict: seriesfile with factor."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vseriesfile
argument_list|)
return|;
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|=
name|GLACE_FACTOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vseriesfile
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|=
name|GLACE_SERIES
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|sListfile
argument_list|)
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|vseriesfile
operator|+
literal|1
index|]
argument_list|,
literal|"rt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|sListfile
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Unable to open series list file."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vseriesfile
argument_list|)
return|;
block|}
comment|/* FILTMETHOD& DIMENSIONSRC */
if|if
condition|(
name|vddimages
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|vwlistfile
operator|>
literal|0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Option conflict: windlistfile with ddimages."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vwlistfile
argument_list|)
return|;
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|=
name|GLACE_DIRDIFF
expr_stmt|;
if|if
condition|(
name|vddlistfile
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|=
name|GLACE_LISTFILE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|dListfile
argument_list|)
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|vddlistfile
operator|+
literal|1
index|]
argument_list|,
literal|"rt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dListfile
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Unable to open window list file."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vddlistfile
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|vwlistfile
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|vddlistfile
operator|>
literal|0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Option conflict: ddlistfile"
literal|" with windlistfile."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vddlistfile
argument_list|)
return|;
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|=
name|GLACE_LISTFILE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|wListfile
argument_list|)
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|vwlistfile
operator|+
literal|1
index|]
argument_list|,
literal|"rt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|wListfile
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Unable to open window list file."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vwlistfile
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|vddlistfile
operator|>
literal|0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Option ddlistfile requires ddimages."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vddlistfile
argument_list|)
return|;
if|if
condition|(
name|vdimensions
operator|>
literal|0
condition|)
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_LISTFILE
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Option conflict: dimensions with a listfile."
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|vdimensions
argument_list|)
return|;
else|else
block|{
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|=
name|GLACE_COMMANDLINE
expr_stmt|;
comment|/* read window/dd parameters from next three args. */
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|vdimensions
index|]
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|vdimensions
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|vdimensions
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|<
literal|0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Number of terms must be a"
literal|" positive integer."
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|vdimensions
argument_list|)
return|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|wrapType
argument_list|)
operator|==
name|GLACE_TK_VER
condition|)
name|GLACE_CFG
argument_list|(
name|plainGlace
argument_list|)
operator|=
name|GLACE_FALSE
expr_stmt|;
else|else
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Number of terms must be"
literal|" greater than zero."
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|vdimensions
argument_list|)
return|;
block|}
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|plainGlace
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|>
name|GLACE_CFG_DEFAULT_NUM_TERMS
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"The maximum number of terms is 200."
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|vdimensions
argument_list|)
return|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_WINDOW
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
operator|<
literal|3
operator|||
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
operator|<
literal|3
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Dimensions integers must"
literal|" be greater than 2."
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|vdimensions
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
operator|<
literal|1
operator|||
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
operator|<
literal|0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Dimension>=1 and baseval>0."
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|vdimensions
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_MISSING
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Filter specification required."
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
name|vddlistfile
argument_list|)
return|;
comment|/* ************************************************************ */
comment|/* Extract argument information. */
comment|/* PRESCALE */
if|if
condition|(
name|vprescale
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|prescaleMode
argument_list|)
operator|=
name|GLACE_COMMANDLINE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vprescale
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|>
literal|2
operator|)
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Prescale argument should be between 0 and 2."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vprescale
argument_list|)
return|;
block|}
comment|/* FACTOR */
if|if
condition|(
name|vfactor
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|argv
index|[
name|vfactor
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|>
literal|1
condition|)
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|/
literal|100.0
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|<
literal|0.0
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|>
literal|1.0
operator|)
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Factor argument should be between 0 and 1."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vfactor
argument_list|)
return|;
block|}
comment|/* ADDBACK */
if|if
condition|(
name|vaddback
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vaddback
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
operator|<
literal|0.0
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
operator|>
literal|1.0
operator|)
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Addback argument should be between 0 and 1."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vaddback
argument_list|)
return|;
block|}
if|if
condition|(
name|vpassthru
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vpassthru
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|<
literal|0.0
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|>
literal|1.0
operator|)
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Passthru argument should be between 0 and 1."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vpassthru
argument_list|)
return|;
block|}
comment|/* INOFFSET */
if|if
condition|(
name|vinoffset
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|inoffsetMode
argument_list|)
operator|=
name|GLACE_COMMANDLINE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vinoffset
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|>
name|GLACE_MAXMAXGRAY
operator|)
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Input offset argument out of gray level range."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vinoffset
argument_list|)
return|;
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|>
operator|-
literal|0.000001
operator|)
operator|&&
operator|(
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|<
literal|1.000001
operator|)
condition|)
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|*
name|GLACE_MAXMAXGRAY
expr_stmt|;
block|}
comment|/* GAUSSIAN SMOOTHING */
if|if
condition|(
name|vgauss
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|gaussCwindWidth
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vgauss
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|gaussCwindWidth
argument_list|)
operator|<
literal|0.0
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Gaussian width argument must be nonnegative."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vgauss
argument_list|)
return|;
name|GLACE_CFG
argument_list|(
name|gaussCwind
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
block|}
comment|/* TOLERANCE */
if|if
condition|(
name|vtol
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|coeffTol
argument_list|)
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|argv
index|[
name|vtol
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* REFERENCE IMAGE */
if|if
condition|(
name|vrefimage
operator|>
literal|0
condition|)
block|{
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|argv
index|[
name|vrefimage
operator|+
literal|1
index|]
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|refImageHandle
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|refimageMode
argument_list|)
operator|=
name|GLACE_SEPARATE
expr_stmt|;
block|}
comment|/* CUMULATION FUNCTION */
if|if
condition|(
name|vcfunc
operator|>
literal|0
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|genCFunc
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|cFuncMin
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vcfunc
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|cFuncMax
argument_list|)
operator|=
name|atof
argument_list|(
name|argv
index|[
name|vcfunc
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|cFuncPoints
argument_list|)
operator|=
name|atol
argument_list|(
name|argv
index|[
name|vcfunc
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|cFuncPoints
argument_list|)
operator|<
literal|2
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Number of points in curve must be greater than 1."
argument_list|,
name|argv
argument_list|,
literal|4
argument_list|,
name|vcfunc
argument_list|)
return|;
block|}
comment|/* OPEN INPUT */
if|if
condition|(
name|argn
operator|<
name|argc
condition|)
comment|/* `-' = stdin */
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|argv
index|[
name|argn
index|]
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|inputImageHandle
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argn
operator|==
name|argc
condition|)
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|NULL
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|inputImageHandle
argument_list|)
argument_list|)
expr_stmt|;
comment|/* INPUT IMAGE */
if|if
condition|(
name|vinput
operator|>
literal|0
condition|)
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|argv
index|[
name|vinput
operator|+
literal|1
index|]
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|inputImageHandle
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OUTPUT IMAGE */
if|if
condition|(
name|voutput
operator|>
literal|0
condition|)
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|argv
index|[
name|voutput
operator|+
literal|1
index|]
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|outputImageHandle
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OPEN DIRECTION IMAGES */
if|if
condition|(
name|vddimages
operator|>
literal|0
condition|)
block|{
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|argv
index|[
name|vddimages
operator|+
literal|1
index|]
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|ddHImageHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_IMG
argument_list|(
name|ddHImageHandle
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Unable to open first (horiz) image direction file."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vddimages
argument_list|)
return|;
name|Glace_WOpenImage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|cfgInfoPtr
argument_list|,
name|argv
index|[
name|vddimages
operator|+
literal|2
index|]
argument_list|,
operator|&
name|GLACE_IMG
argument_list|(
name|ddVImageHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_IMG
argument_list|(
name|ddVImageHandle
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|GlaceArgError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Unable to open second (vert) image direction file."
argument_list|,
name|argv
argument_list|,
literal|2
argument_list|,
name|vddimages
argument_list|)
return|;
block|}
comment|/* ********************************************************************** */
return|return
name|Glace_WErrorValue
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* :*** Cumulation Function ***:   * :FUNCTION: Glace_CFuncGen  */
end_comment

begin_function
name|int
DECL|function|Glace_CFuncGen (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CFuncGen
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|char
name|outText
index|[
literal|20
index|]
decl_stmt|;
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|genCFunc
argument_list|)
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|!=
name|GLACE_CFG
argument_list|(
name|termsSerialised
argument_list|)
condition|)
return|return
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Series arrays not correctly allocated before call to"
literal|" cumulation\nfunction generator."
argument_list|)
return|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
condition|)
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Cumulation Function:\n"
literal|"    x     y    ideal-y\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GLACE_CFG
argument_list|(
name|cFuncPoints
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|i
operator|/
operator|(
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|cFuncPoints
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|GLACE_CFG
argument_list|(
name|cFuncMax
argument_list|)
operator|*
name|x
operator|+
name|GLACE_CFG
argument_list|(
name|cFuncMin
argument_list|)
operator|*
operator|(
literal|1
operator|-
name|x
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|outText
argument_list|,
literal|"%4g"
argument_list|,
operator|(
name|double
operator|)
name|x
argument_list|)
expr_stmt|;
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|outText
argument_list|)
expr_stmt|;
name|y
operator|=
name|Glace_CFuncPoint
argument_list|(
name|cfgInfoPtr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outText
argument_list|,
literal|" %6g"
argument_list|,
operator|(
name|double
operator|)
name|y
argument_list|)
expr_stmt|;
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|outText
argument_list|)
expr_stmt|;
name|y
operator|=
name|Glace_CFuncIdealPoint
argument_list|(
name|cfgInfoPtr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outText
argument_list|,
literal|" %6g\n"
argument_list|,
operator|(
name|double
operator|)
name|y
argument_list|)
expr_stmt|;
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
name|outText
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Glace_WErrorValue
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CFuncPoint  */
end_comment

begin_function
name|float
DECL|function|Glace_CFuncPoint (Glace_CfgInfo * cfgInfoPtr,float x)
name|Glace_CFuncPoint
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|float
name|x
parameter_list|)
block|{
name|float
name|y
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|y
operator|=
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|*
name|x
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|i
operator|++
control|)
name|y
operator|+=
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
index|[
name|i
index|]
operator|*
name|sin
argument_list|(
operator|(
name|i
operator|-
literal|0.5
operator|)
operator|*
name|GLACE_PI
operator|*
name|x
operator|*
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CFuncIdealPoint  */
end_comment

begin_function
name|float
DECL|function|Glace_CFuncIdealPoint (Glace_CfgInfo * cfgInfoPtr,float x)
name|Glace_CFuncIdealPoint
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|float
name|x
parameter_list|)
block|{
name|float
name|y
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|y
operator|=
name|x
operator|/
name|fabs
argument_list|(
name|x
argument_list|)
operator|*
name|pow
argument_list|(
literal|2
operator|*
name|fabs
argument_list|(
name|x
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*  * fwheGLACE_CFGs.c:  GLACE_CFGument handling for pgmfwhe.c  *  * See that file for details!  *  * Version 3.0, VI-97: J.Alex Stark  */
end_comment

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* :*** CONFIGURATION ***:   * :FUNCTION: Glace_CfgInit  */
end_comment

begin_function
name|void
DECL|function|Glace_CfgInit (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CfgInit
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|Glace_WData
name|wData
decl_stmt|;
name|wData
operator|=
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
expr_stmt|;
comment|/* The structure is pre-filled with zeros, and so       r->outputmethod = NORMAL; etc.. */
name|memset
argument_list|(
operator|(
name|cfgInfoPtr
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|Glace_CfgInfo
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackCwind
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|=
name|GLACE_CFG_DEFAULT_NUM_TERMS
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
operator|=
name|GLACE_MIDGRAY
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
operator|=
name|wData
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|wrapType
argument_list|)
operator|=
name|Glace_WWrapTell
argument_list|()
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|plainGlace
argument_list|)
operator|=
name|GLACE_TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CfgFreeSeriesVectors  */
end_comment

begin_function
name|void
DECL|function|Glace_CfgFreeSeriesVectors (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CfgFreeSeriesVectors
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
argument_list|,
operator|&
name|GLACE_CFG
argument_list|(
name|currentSeriesAllocation
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0.4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CfgAllocSeriesVectors  */
end_comment

begin_function
name|void
DECL|function|Glace_CfgAllocSeriesVectors (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CfgAllocSeriesVectors
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|int
name|newSeriesTerms
decl_stmt|;
comment|/* Note that we start the series from [1], and so the */
comment|/* round up to nearest ROUND_TERMS */
DECL|macro|ROUND_TERMS
define|#
directive|define
name|ROUND_TERMS
value|(10)
name|newSeriesTerms
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|/
name|ROUND_TERMS
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|ROUND_TERMS
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
operator|=
operator|(
name|double
operator|*
operator|)
name|Glace_CallocReallocFree
argument_list|(
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
argument_list|,
operator|&
name|GLACE_CFG
argument_list|(
name|currentSeriesAllocation
argument_list|)
argument_list|,
name|newSeriesTerms
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0.4
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|cwindSeries
argument_list|)
operator|=
operator|&
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
index|[
name|newSeriesTerms
index|]
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackSeries
argument_list|)
operator|=
operator|&
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
index|[
name|newSeriesTerms
operator|*
literal|2
index|]
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windCWSeries
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|GLACE_CFG
argument_list|(
name|heseriesSeries
argument_list|)
index|[
name|newSeriesTerms
operator|*
literal|3
index|]
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windCHSeries
argument_list|)
operator|=
operator|&
name|GLACE_CFG
argument_list|(
name|windCWSeries
argument_list|)
index|[
name|newSeriesTerms
index|]
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windSWSeries
argument_list|)
operator|=
operator|&
name|GLACE_CFG
argument_list|(
name|windCWSeries
argument_list|)
index|[
name|newSeriesTerms
operator|*
literal|2
index|]
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windSHSeries
argument_list|)
operator|=
operator|&
name|GLACE_CFG
argument_list|(
name|windCWSeries
argument_list|)
index|[
name|newSeriesTerms
operator|*
literal|3
index|]
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|termsSerialised
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CfgBeginToHeseries  */
end_comment

begin_function
name|void
DECL|function|Glace_CfgBeginToHeseries (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CfgBeginToHeseries
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|windw
decl_stmt|,
name|windh
decl_stmt|;
name|double
name|hamma
decl_stmt|,
name|hammb
decl_stmt|;
name|struct
name|Glace_HeseriesInfo
name|hsi
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|!=
name|GLACE_FACTOR
condition|)
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
operator|=
literal|0.0
expr_stmt|;
comment|/* SET TERM RANGE */
comment|/* if not normal we only output 1 term, ie the last */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
condition|)
name|GLACE_CFG
argument_list|(
name|firstTerm
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|GLACE_CFG
argument_list|(
name|firstTerm
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
expr_stmt|;
comment|/* PRESCALE */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|prescaleMode
argument_list|)
operator|==
name|GLACE_MISSING
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|==
name|GLACE_STANDARD
condition|)
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|=
literal|1.7
expr_stmt|;
else|else
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|=
literal|1.0
expr_stmt|;
block|}
comment|/* ADDBACK */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackMode
argument_list|)
operator|==
name|GLACE_MISSING
condition|)
block|{
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|=
name|GLACE_CFG_DEFAULT_A_WITH_F
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
operator|=
literal|0.0
expr_stmt|;
comment|/*GLACE_CFG(addbackFactor) = GLACE_CFG(heFactor);*/
block|}
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_WINDOW
condition|)
block|{
comment|/* WINDOW SIZES */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_LISTFILE
condition|)
block|{
comment|/* Now in pgm scan listfiles */
block|}
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_COMMANDLINE
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
operator|<
literal|3
operator|||
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
operator|<
literal|3
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Dimensions integers must be greater than 2."
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|<=
literal|0
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Number of terms must be a positive integer."
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|>
name|GLACE_CFG_DEFAULT_NUM_TERMS
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"The maximum number of terms is 200."
argument_list|)
expr_stmt|;
comment|/* convert to extent either side of pel */
name|windw
operator|=
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
operator|/
literal|2
expr_stmt|;
name|windh
operator|=
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|GLACE_CFG
argument_list|(
name|windCWSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|windw
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windSWSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|windw
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windCHSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|windh
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|windSHSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|windh
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
else|else
block|{
comment|/* DIRDIFF */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_LISTFILE
condition|)
block|{
comment|/* Now in pgm scan listfiles */
block|}
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_COMMANDLINE
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
operator|<
literal|1
operator|||
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
operator|<
literal|0
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Dimension>=1 and baseval>0."
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|<=
literal|0
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Number of terms must be a positive integer."
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|>
name|GLACE_CFG_DEFAULT_NUM_TERMS
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"The maximum number of terms is 200."
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_COSDIM
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_SINDIM
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|windBaseW
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_COSBV
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|GLACE_CFG_SINBV
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|windBaseH
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
comment|/* HE SERIES */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|==
name|GLACE_SERIES
condition|)
block|{
comment|/* Now in pgm scan listfiles */
block|}
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|==
name|GLACE_FACTOR
condition|)
block|{
name|Glace_HeseriesInit
argument_list|(
operator|&
name|hsi
argument_list|,
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|Glace_HeseriesVal
argument_list|(
operator|&
name|hsi
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|==
name|GLACE_HESERIES_ERRORFLAG
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Error in Fourier series evaluation."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|=
literal|4
operator|/
name|GLACE_PI
operator|/
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|hamma
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
operator|,
name|hamma
operator|*=
operator|-
literal|1
control|)
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|-=
name|hamma
operator|*
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|*
literal|16
operator|/
name|GLACE_PI
operator|/
name|GLACE_PI
operator|/
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
operator|/
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* HAMMING WINDOWING */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|hammingCwind
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
block|{
comment|/*     hamma = 1/(0.54 + 0.46*cos(GLACE_PI/(2*GLACE_CFG(numTerms))));*/
name|hamma
operator|=
literal|1.0
expr_stmt|;
name|hammb
operator|=
literal|0.46
operator|*
name|hamma
expr_stmt|;
name|hamma
operator|=
literal|0.54
operator|*
name|hamma
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|*
operator|(
name|hamma
operator|+
name|hammb
operator|*
name|cos
argument_list|(
name|GLACE_PI
operator|/
operator|(
literal|2
operator|*
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|)
operator|*
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* GAUSSIAN BLURRING */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|gaussCwind
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
block|{
name|hamma
operator|=
operator|-
literal|0.125
operator|*
name|GLACE_PI
operator|*
name|GLACE_PI
operator|/
name|GLACE_MAXMAXGRAY
operator|/
name|GLACE_MAXMAXGRAY
operator|*
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|gaussCwindWidth
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|gaussCwindWidth
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|*
name|exp
argument_list|(
name|hamma
operator|*
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
operator|*
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* TOLERANCE */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|coeffTol
argument_list|)
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
name|GLACE_CFG
argument_list|(
name|coeffTol
argument_list|)
operator|=
name|GLACE_TOL_DOUBLEP
expr_stmt|;
else|else
name|GLACE_CFG
argument_list|(
name|coeffTol
argument_list|)
operator|=
name|GLACE_TOL_SINGLEP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|==
name|GLACE_TRUE
operator|)
operator|&&
operator|(
name|GLACE_CFG
argument_list|(
name|doClip
argument_list|)
operator|==
name|GLACE_TRUE
operator|)
condition|)
name|Glace_WError
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"-clip option conflicts with double-precision output."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CfgHeseriesToAddback  */
end_comment

begin_function
name|void
DECL|function|Glace_CfgHeseriesToAddback (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CfgHeseriesToAddback
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|double
name|hamma
decl_stmt|;
comment|/* ADDBACK SERIES */
comment|/* NOTE: If, in later versions, different addback amounts can be       specified for each term, then a global factor is still       required for the output offset. */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|==
name|GLACE_ZEROINPUT
condition|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|==
name|GLACE_LOCALMEAN
condition|)
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|hamma
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
operator|,
name|hamma
operator|*=
operator|-
literal|1
control|)
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|hamma
operator|*
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
operator|*
literal|16
operator|/
name|GLACE_PI
operator|/
name|GLACE_PI
operator|/
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
operator|/
operator|(
literal|2
operator|*
name|j
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|==
name|GLACE_NONE
condition|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
operator|=
literal|0.0
expr_stmt|;
comment|/* APPLY COEFFICIENT WINDOW */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_CfgAddbackToEnd  */
end_comment

begin_function
name|void
DECL|function|Glace_CfgAddbackToEnd (Glace_CfgInfo * cfgInfoPtr)
name|Glace_CfgAddbackToEnd
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|float
name|total
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|!=
name|GLACE_NORMAL
operator|)
operator|||
operator|(
name|GLACE_CFG
argument_list|(
name|doClip
argument_list|)
operator|==
name|GLACE_TRUE
operator|)
operator|)
operator|&&
operator|(
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|==
name|GLACE_CC
operator|)
condition|)
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|GLACE_CG
expr_stmt|;
comment|/* APPLY COEFFICIENT WINDOW */
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackCwind
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
operator|=
name|GLACE_CFG
argument_list|(
name|cwindSeries
index|[
name|j
index|]
argument_list|)
operator|*
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* TRUNCATE PRECISION */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
operator|=
literal|1.0
operator|-
call|(
name|float
call|)
argument_list|(
literal|1.0
operator|-
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
operator|=
literal|1.0
operator|-
call|(
name|float
call|)
argument_list|(
literal|1.0
operator|-
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* TOLERANCE */
for|for
control|(
name|j
operator|=
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
operator|,
name|total
operator|=
literal|0.0
init|;
operator|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|total
operator|<
name|GLACE_CFG
argument_list|(
name|coeffTol
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|--
control|)
name|total
operator|+=
name|max
argument_list|(
name|abs
argument_list|(
name|GLACE_CFG
argument_list|(
name|heseriesSeries
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|,
name|abs
argument_list|(
name|GLACE_CFG
argument_list|(
name|addbackSeries
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|activeTerms
argument_list|)
operator|=
name|min
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
argument_list|)
expr_stmt|;
comment|/*++++++++++ VERBOSITY POINT ++++++++++*/
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|verbose
argument_list|)
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|==
name|GLACE_FACTOR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HE factor: %f.\n"
argument_list|,
name|GLACE_CFG
argument_list|(
name|heFactor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|==
name|GLACE_GG
condition|)
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gray input; "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Two-byte gray input; "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Colour input; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doubleout
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"two-byte gray output.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|==
name|GLACE_CC
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"colour output.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gray output.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Standard precision process.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Two-byte precision process.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|gaussCwind
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gaussian smoother width: %f.\n"
argument_list|,
name|GLACE_CFG
argument_list|(
name|gaussCwindWidth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|hammingCwind
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hamming windowing of HE series.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|refimageMode
argument_list|)
operator|==
name|GLACE_SEPARATE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using separate histogram reference image.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|dimensionSrc
argument_list|)
operator|==
name|GLACE_LISTFILE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Filter dimensions from listfile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|heType
argument_list|)
operator|==
name|GLACE_SERIES
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HE series coefficients from listfile.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Prescale: %f\tInput offset: %f.\n"
argument_list|,
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|prescaleVal
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|inoffsetVal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pass-thru, factor %f.\n"
argument_list|,
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|passthruFactor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|==
name|GLACE_ZEROINPUT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Addback: zero-input, factor %f, "
argument_list|,
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|==
name|GLACE_LOCALMEAN
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Addback: local-mean, factor %f, "
argument_list|,
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|addbackFactor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackType
argument_list|)
operator|!=
name|GLACE_NONE
condition|)
block|{
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|addbackCwind
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"coefficients windowed/blurred.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"coefficients NOT windowed/blurred.\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Coefficient tolerance %f; active terms %d.\n"
argument_list|,
operator|(
name|double
operator|)
name|GLACE_CFG
argument_list|(
name|coeffTol
argument_list|)
argument_list|,
name|GLACE_CFG
argument_list|(
name|activeTerms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINRAW
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIAGNOSTIC OUTPUT: Raw sine field.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSRAW
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIAGNOSTIC OUTPUT: Raw cosine field.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_SINFILT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIAGNOSTIC OUTPUT: Filtered sine field.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_COSFILT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIAGNOSTIC OUTPUT: Filtered cosine field.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doClip
argument_list|)
operator|==
name|GLACE_TRUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIAGNOSTIC OUTPUT: Clipping field.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|==
name|GLACE_WINDOW
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Window filtering.\n"
literal|"Term:  cos-w cos-h sin-w sin-h; series; addback.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Biased diffusion filtering.\n"
literal|"Term:  cos-d sin-d; series; addback.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* :*** SIGNED POWER-LAW HESERIES ***:    * :HEADER: (extras)  */
end_comment

begin_typedef
DECL|struct|GlaceZHeseriesInfo
typedef|typedef
struct|struct
name|GlaceZHeseriesInfo
block|{
DECL|member|heFactor
name|double
name|heFactor
decl_stmt|;
DECL|member|heFactorX
name|double
name|heFactorX
decl_stmt|;
comment|/* 2-heFactor             */
DECL|member|heGammaVal
name|double
name|heGammaVal
decl_stmt|;
comment|/* gamma(heFactorX)      */
DECL|member|heTwoPower
name|double
name|heTwoPower
decl_stmt|;
comment|/* 2^heFactorX           */
DECL|member|heSinVal
name|double
name|heSinVal
decl_stmt|;
comment|/* sin( heFactorX*pi/2 ) */
DECL|member|heBaseMag
name|double
name|heBaseMag
decl_stmt|;
comment|/* (1st coeff)/heTwoPower     */
comment|/* (this is kept so that relative errors      for other coefficients can be found.) */
DECL|member|dummy
name|char
name|dummy
index|[
name|GLACE_HESERIES_RESERVE
operator|-
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
decl_stmt|;
DECL|typedef|GlaceZHeseriesInfo
block|}
name|GlaceZHeseriesInfo
typedef|;
end_typedef

begin_define
DECL|macro|HE_FACTOR
define|#
directive|define
name|HE_FACTOR
value|((GlaceZHeseriesInfo *) heseriesPtr)->heFactor
end_define

begin_define
DECL|macro|HE_FACTOR_X
define|#
directive|define
name|HE_FACTOR_X
value|((GlaceZHeseriesInfo *) heseriesPtr)->heFactorX
end_define

begin_define
DECL|macro|HE_GAMMA_VAL
define|#
directive|define
name|HE_GAMMA_VAL
value|((GlaceZHeseriesInfo *) heseriesPtr)->heGammaVal
end_define

begin_define
DECL|macro|HE_TWO_POWER
define|#
directive|define
name|HE_TWO_POWER
value|((GlaceZHeseriesInfo *) heseriesPtr)->heTwoPower
end_define

begin_define
DECL|macro|HE_BASE_MAG
define|#
directive|define
name|HE_BASE_MAG
value|((GlaceZHeseriesInfo *) heseriesPtr)->heBaseMag
end_define

begin_define
DECL|macro|HE_GLACE_SIN_VAL
define|#
directive|define
name|HE_GLACE_SIN_VAL
value|((GlaceZHeseriesInfo *) heseriesPtr)->heSinVal
end_define

begin_comment
comment|/*  * :FUNCTION: Glace_HeseriesInit  */
end_comment

begin_function
name|void
DECL|function|Glace_HeseriesInit (Glace_HeseriesInfo * heseriesPtr,float heFactor)
name|Glace_HeseriesInit
parameter_list|(
name|Glace_HeseriesInfo
modifier|*
name|heseriesPtr
parameter_list|,
name|float
name|heFactor
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|g
decl_stmt|;
name|double
name|omega_sq
init|=
name|GLACE_PI
operator|*
name|GLACE_PI
operator|/
literal|4
decl_stmt|;
name|double
name|cstep
decl_stmt|,
name|cprod
decl_stmt|,
name|csum
decl_stmt|;
comment|/* simple bits */
name|HE_FACTOR
operator|=
name|heFactor
expr_stmt|;
name|HE_FACTOR_X
operator|=
literal|1
operator|+
name|heFactor
expr_stmt|;
comment|/*    * HE_GAMMA_VAL = gamma(HE_FACTOR_X)    * absolute error< 3e-7    *    * See Abramowitz& Stegun    */
name|x
operator|=
name|HE_FACTOR_X
operator|-
literal|1
expr_stmt|;
name|g
operator|=
operator|(
operator|(
literal|0.035868343
operator|*
name|x
operator|-
literal|0.193527818
operator|)
operator|*
name|x
operator|+
literal|0.482199394
operator|)
operator|*
name|x
expr_stmt|;
name|g
operator|=
operator|(
operator|(
name|g
operator|-
literal|0.756704078
operator|)
operator|*
name|x
operator|+
literal|0.918206857
operator|)
operator|*
name|x
operator|-
literal|0.897056937
expr_stmt|;
name|g
operator|=
operator|(
operator|(
name|g
operator|*
name|x
operator|+
literal|0.988205891
operator|)
operator|*
name|x
operator|-
literal|0.577191652
operator|)
operator|*
name|x
operator|+
literal|1
expr_stmt|;
name|HE_GAMMA_VAL
operator|=
name|g
expr_stmt|;
comment|/*    * HE_TWO_POWER = 2^HE_FACTOR_X    */
name|HE_TWO_POWER
operator|=
name|pow
argument_list|(
literal|2.0
argument_list|,
name|HE_FACTOR_X
argument_list|)
expr_stmt|;
comment|/*    * HE_BASE_MAG = 1st coefficient /HE_TWO_POWER    * Series development (only require every other term)    */
name|cstep
operator|=
name|HE_FACTOR_X
expr_stmt|;
name|cprod
operator|=
literal|1.0
operator|/
name|cstep
expr_stmt|;
name|csum
operator|=
name|cprod
expr_stmt|;
while|while
condition|(
name|fabs
argument_list|(
name|cprod
argument_list|)
operator|>
operator|(
literal|10.0
operator|*
name|DBL_EPSILON
operator|*
name|fabs
argument_list|(
name|csum
argument_list|)
operator|)
condition|)
block|{
name|cstep
operator|+=
literal|1.0
expr_stmt|;
name|cprod
operator|*=
operator|-
name|omega_sq
operator|/
name|cstep
expr_stmt|;
name|cstep
operator|+=
literal|1.0
expr_stmt|;
name|cprod
operator|/=
name|cstep
expr_stmt|;
name|csum
operator|+=
name|cprod
expr_stmt|;
block|}
empty_stmt|;
name|HE_BASE_MAG
operator|=
name|fabs
argument_list|(
name|csum
argument_list|)
expr_stmt|;
name|HE_GLACE_SIN_VAL
operator|=
name|sin
argument_list|(
name|GLACE_PI
operator|*
literal|0.5
operator|*
name|HE_FACTOR_X
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************** */
end_comment

begin_comment
comment|/* CALCULATE SINGLE VALUE */
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_HeseriesVal  */
end_comment

begin_function
name|double
DECL|function|Glace_HeseriesVal (Glace_HeseriesInfo * heseriesPtr,int k)
name|Glace_HeseriesVal
parameter_list|(
name|Glace_HeseriesInfo
modifier|*
name|heseriesPtr
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|double
name|p1r
decl_stmt|,
name|p1i
decl_stmt|,
name|p2r
decl_stmt|,
name|p2i
decl_stmt|,
name|q1r
decl_stmt|,
name|q1i
decl_stmt|,
name|q2r
decl_stmt|,
name|q2i
decl_stmt|,
name|omega
decl_stmt|,
name|cold
decl_stmt|,
name|cnew
decl_stmt|,
name|tolval
decl_stmt|,
name|n
decl_stmt|,
name|normfact
decl_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
comment|/*       Glace_WError("Invalid request of HE series coefficient.\n");       exit(1);       */
return|return
name|GLACE_HESERIES_ERRORFLAG
return|;
block|}
if|if
condition|(
name|k
operator|==
literal|1
condition|)
return|return
name|HE_BASE_MAG
operator|*
name|HE_TWO_POWER
return|;
else|else
block|{
name|tolval
operator|=
literal|10.0
operator|*
name|DBL_EPSILON
operator|*
name|HE_BASE_MAG
expr_stmt|;
name|omega
operator|=
operator|(
operator|(
name|double
operator|)
name|k
operator|-
literal|0.5
operator|)
operator|*
name|GLACE_PI
expr_stmt|;
name|p1r
operator|=
literal|0.0
expr_stmt|;
name|p1i
operator|=
literal|0.0
expr_stmt|;
name|p2r
operator|=
literal|1.0
expr_stmt|;
name|p2i
operator|=
literal|0.0
expr_stmt|;
name|q1r
operator|=
literal|1.0
expr_stmt|;
name|q1i
operator|=
literal|0.0
expr_stmt|;
name|q2r
operator|=
literal|0.0
expr_stmt|;
name|q2i
operator|=
name|omega
expr_stmt|;
name|cold
operator|=
literal|0.0
expr_stmt|;
name|cnew
operator|=
literal|1.0
expr_stmt|;
comment|/* make sure it gets off the ground. */
name|n
operator|=
literal|1.0
expr_stmt|;
name|normfact
operator|=
literal|1.0
expr_stmt|;
comment|/*        * NB convergence wrt real part is poor, but this will be swamped by         *  the addition of the gamma factor.        *    while ( abs (cold - cnew)> 10 * eps * abs(cnew) )& (n<100)        * Note that sometimes (especially, for example, heFactor 0.15)        *  the coefficient is near to zero.        */
while|while
condition|(
operator|(
name|fabs
argument_list|(
name|cold
operator|-
name|cnew
argument_list|)
operator|>
name|tolval
operator|)
operator|&&
operator|(
name|n
operator|<
literal|300.0
operator|)
condition|)
block|{
name|cold
operator|=
name|cnew
expr_stmt|;
name|p1r
operator|=
name|q1r
operator|+
name|p1r
operator|*
operator|(
name|n
operator|-
name|HE_FACTOR_X
operator|)
operator|*
name|normfact
expr_stmt|;
name|p1i
operator|=
name|q1i
operator|+
name|p1i
operator|*
operator|(
name|n
operator|-
name|HE_FACTOR_X
operator|)
operator|*
name|normfact
expr_stmt|;
name|p2r
operator|=
name|q2r
operator|+
name|p2r
operator|*
operator|(
name|n
operator|-
name|HE_FACTOR_X
operator|)
operator|*
name|normfact
expr_stmt|;
name|p2i
operator|=
name|q2i
operator|+
name|p2i
operator|*
operator|(
name|n
operator|-
name|HE_FACTOR_X
operator|)
operator|*
name|normfact
expr_stmt|;
name|q2r
operator|=
operator|-
name|p2i
operator|*
name|omega
operator|+
name|n
operator|*
name|q2r
expr_stmt|;
name|q2i
operator|=
name|p2r
operator|*
name|omega
operator|+
name|n
operator|*
name|q2i
expr_stmt|;
comment|/* simulate getting exponent to normalise. */
comment|/*      normfact = exp(round(-0.5*log(q2r*q2r+q2i*q2i)));*/
name|normfact
operator|=
literal|1.0
operator|/
name|sqrt
argument_list|(
name|q2r
operator|*
name|q2r
operator|+
name|q2i
operator|*
name|q2i
argument_list|)
expr_stmt|;
name|q2r
operator|=
name|q2r
operator|*
name|normfact
expr_stmt|;
name|q2i
operator|=
name|q2i
operator|*
name|normfact
expr_stmt|;
name|q1r
operator|=
operator|(
operator|-
name|p1i
operator|*
name|omega
operator|+
name|n
operator|*
name|q1r
operator|)
operator|*
name|normfact
expr_stmt|;
name|q1i
operator|=
operator|(
name|p1r
operator|*
name|omega
operator|+
name|n
operator|*
name|q1i
operator|)
operator|*
name|normfact
expr_stmt|;
name|cnew
operator|=
operator|(
name|q1r
operator|*
name|q2r
operator|+
name|q1i
operator|*
name|q2i
operator|)
operator|/
operator|(
name|q2r
operator|*
name|q2r
operator|+
name|q2i
operator|*
name|q2i
operator|)
expr_stmt|;
name|n
operator|=
name|n
operator|+
literal|1.0
expr_stmt|;
block|}
comment|/*        * y_cnew = incomplete_gamma(HE_FACTOR_X,i*omega)        *        * cnew is the required real part of an expression of y_cnew        *    y_cnew = 1 - exp(-i*omega + HE_FACTOR_X * log(i*omega))        *                     * cnew /gamma (HE_FACTOR_X);        *    x = -imag((incomplete_gamma(i*omega,HE_FACTOR_X))/        *                 (i^HE_FACTOR_X))...        *                 *gamma(hf)/omega^HE_FACTOR_X*2^HE_FACTOR_X;        */
return|return
operator|(
operator|(
literal|1.0
operator|-
literal|2.0
operator|*
name|fmod
argument_list|(
operator|(
name|double
operator|)
name|k
argument_list|,
literal|2.0
argument_list|)
operator|)
comment|/* (-1)^k */
operator|*
name|cnew
operator|+
name|HE_GLACE_SIN_VAL
operator|*
name|HE_GAMMA_VAL
operator|*
name|pow
argument_list|(
name|omega
argument_list|,
operator|-
name|HE_FACTOR_X
argument_list|)
operator|)
operator|*
name|HE_TWO_POWER
return|;
block|}
comment|/* k!=1 */
block|}
end_function

begin_comment
comment|/* :*** IMAGE FIELD FILTERING ***:    * :FUNCTION: GlaceWindTableFill (unused)  */
end_comment

begin_function
name|void
DECL|function|GlaceWindTableFill (Glace_BigGray * shifted_table,int row,int cols,Glace_Gray ** inImgHBPtrPtr,Glace_BigGray * outImgPtr)
name|GlaceWindTableFill
parameter_list|(
name|Glace_BigGray
modifier|*
name|shifted_table
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|cols
parameter_list|,
name|Glace_Gray
modifier|*
modifier|*
name|inImgHBPtrPtr
parameter_list|,
name|Glace_BigGray
modifier|*
name|outImgPtr
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|Glace_BigGray
modifier|*
name|iagP
decl_stmt|;
specifier|register
name|Glace_Gray
modifier|*
name|iigP
decl_stmt|;
for|for
control|(
name|c
operator|=
name|cols
operator|,
name|iigP
operator|=
name|inImgHBPtrPtr
index|[
name|row
index|]
operator|,
name|iagP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|row
operator|+
literal|1
operator|)
operator|*
name|cols
index|]
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|iagP
operator|++
operator|,
name|iigP
operator|++
control|)
operator|*
name|iagP
operator|=
name|shifted_table
index|[
operator|*
name|iigP
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * :FUNCTION: GlaceWindTableFillAll  */
end_comment

begin_function
name|void
DECL|function|GlaceWindTableFillAll (Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,int numPix,Glace_Gray * hPixPtr,Glace_Gray * lPixPtr,Glace_BigGray * outPixPtr)
name|GlaceWindTableFillAll
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
comment|/*register Glace_BigGray * shifted_table,*/
name|int
name|numPix
parameter_list|,
name|Glace_Gray
modifier|*
name|hPixPtr
parameter_list|,
name|Glace_Gray
modifier|*
name|lPixPtr
parameter_list|,
name|Glace_BigGray
modifier|*
name|outPixPtr
parameter_list|)
block|{
specifier|register
name|long
name|c
decl_stmt|;
specifier|register
name|Glace_BigGray
modifier|*
name|iagP
decl_stmt|;
specifier|register
name|Glace_Gray
modifier|*
name|hgP
decl_stmt|,
modifier|*
name|lgP
decl_stmt|;
specifier|register
name|Glace_FpSeries
modifier|*
name|thisAH
decl_stmt|,
modifier|*
name|thisAL
decl_stmt|,
modifier|*
name|thisBH
decl_stmt|,
modifier|*
name|thisBL
decl_stmt|;
name|long
modifier|*
name|thisTable
decl_stmt|;
name|thisTable
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|==
name|GLACE_FALSE
condition|)
for|for
control|(
name|c
operator|=
name|numPix
operator|,
name|hgP
operator|=
name|hPixPtr
operator|,
name|iagP
operator|=
name|outPixPtr
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|iagP
operator|++
operator|,
name|hgP
operator|++
control|)
operator|*
name|iagP
operator|=
name|thisTable
index|[
operator|*
name|hgP
index|]
expr_stmt|;
else|else
block|{
name|thisAH
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAH
argument_list|)
expr_stmt|;
name|thisAL
operator|=
name|GLACE_TRM
argument_list|(
name|seriesAL
argument_list|)
expr_stmt|;
name|thisBH
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBH
argument_list|)
expr_stmt|;
name|thisBL
operator|=
name|GLACE_TRM
argument_list|(
name|seriesBL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|numPix
operator|,
name|hgP
operator|=
name|hPixPtr
operator|,
name|lgP
operator|=
name|lPixPtr
operator|,
name|iagP
operator|=
name|outPixPtr
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|iagP
operator|++
operator|,
name|hgP
operator|++
operator|,
name|lgP
operator|++
control|)
operator|*
name|iagP
operator|=
name|thisAH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisAL
index|[
operator|*
name|lgP
index|]
operator|+
name|thisBH
index|[
operator|*
name|hgP
index|]
operator|*
name|thisBL
index|[
operator|*
name|lgP
index|]
operator|+
literal|0.5
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* outImgPtr is a vector (row) array of size (cols+1)*(rows+1)    of Glace_BigGrays */
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FiltWind  */
end_comment

begin_function
name|void
DECL|function|Glace_FiltWind (Glace_CfgInfo * cfgInfoPtr,Glace_Gray * inImgHBPtr,Glace_Gray * inImgLBPtr,Glace_BigGray * outImgPtr,int cols,int rows,Glace_TableInfo * tableInfoPtr,int width,int height)
name|Glace_FiltWind
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_Gray
modifier|*
name|inImgHBPtr
parameter_list|,
name|Glace_Gray
modifier|*
name|inImgLBPtr
parameter_list|,
name|Glace_BigGray
modifier|*
name|outImgPtr
parameter_list|,
comment|/*signed long *lTable,*/
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|second_shifts
decl_stmt|,
name|first_shifts
decl_stmt|;
comment|/*   Glace_BigGray            shifted_table[GLACE_MAXMAXGRAY+1];*/
name|Glace_BigGray
name|accumX
decl_stmt|;
name|Glace_BigGray
modifier|*
name|oagP
decl_stmt|;
specifier|register
name|Glace_BigGray
name|accum
decl_stmt|;
specifier|register
name|Glace_BigGray
modifier|*
name|obgP
decl_stmt|,
modifier|*
name|iagP
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|long
name|k
decl_stmt|;
if|if
condition|(
operator|(
literal|2
operator|*
name|width
operator|)
operator|>=
name|cols
condition|)
name|Glace_WError
argument_list|(
name|GLACE_TRM
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Window filter: window width too large."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
literal|2
operator|*
name|height
operator|)
operator|>=
name|rows
condition|)
name|Glace_WError
argument_list|(
name|GLACE_TRM
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|"Window filter: window height too large."
argument_list|)
expr_stmt|;
comment|/* The amount of down-shifting in preparation for the first      pass is analogous to that for filtShifts.  However, some of      scaling down has already been done in constructing the       table. */
name|frexp
argument_list|(
operator|(
literal|2
operator|*
name|width
operator|+
literal|1.0
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|GLACE_TRM
argument_list|(
name|filtFactor
argument_list|)
operator|)
operator|/
name|AFT_FILTVAL
argument_list|,
operator|&
name|first_shifts
argument_list|)
expr_stmt|;
comment|/* The shifts required before the second (vertical) pass: */
name|second_shifts
operator|=
name|GLACE_TRM
argument_list|(
name|filtShifts
argument_list|)
operator|-
name|first_shifts
expr_stmt|;
name|Glace_FillTableForFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|ldexp
argument_list|(
literal|1.0
argument_list|,
operator|-
name|first_shifts
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    for (r=0; r<=GLACE_MAXMAXGRAY; r++)       shifted_table[r] = lTable[r]>> first_shifts; */
name|GlaceWindTableFillAll
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|rows
operator|*
name|cols
argument_list|,
name|inImgHBPtr
argument_list|,
name|inImgLBPtr
argument_list|,
operator|&
name|outImgPtr
index|[
name|cols
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
block|{
comment|/* Copy row of input image using lookup table to output array,          but starting at location (1,1). */
comment|/*     GlaceWindTableFill(shifted_table,r,cols,inImgHBPtrPtr,outImgPtr);*/
comment|/* Add up first (2*width+1) columns in each row.          Put in zeroth column.  This is the output for the first          width+1 columns (0 to width). */
name|obgP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
index|]
expr_stmt|;
name|iagP
operator|=
name|obgP
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|(
literal|2
operator|*
name|width
operator|)
operator|+
literal|1
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|iagP
operator|++
control|)
name|accum
operator|+=
operator|*
name|iagP
expr_stmt|;
name|accumX
operator|=
name|accum
expr_stmt|;
comment|/* MAIN SCAN ACROSS */
comment|/* iagP is already pointing at the next one to add. */
for|for
control|(
name|c
operator|=
operator|(
name|cols
operator|-
literal|2
operator|*
name|width
operator|-
literal|1
operator|)
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|obgP
operator|++
operator|,
name|iagP
operator|++
control|)
block|{
comment|/* y(k) = y(k-1) + x(k+w) - x(k-w-1) */
name|accum
operator|=
name|accum
operator|+
operator|*
name|iagP
operator|-
operator|*
name|obgP
expr_stmt|;
operator|*
name|obgP
operator|=
name|accum
expr_stmt|;
block|}
name|iagP
operator|=
name|obgP
operator|-
literal|1
expr_stmt|;
comment|/* SHIFT& STORE */
comment|/* First the last output into the last w+1 entries. */
name|accum
operator|=
operator|*
name|iagP
operator|>>
name|second_shifts
expr_stmt|;
name|obgP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
operator|+
name|cols
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
name|width
operator|+
literal|1
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|obgP
operator|--
control|)
operator|*
name|obgP
operator|=
name|accum
expr_stmt|;
comment|/* Then cols-2*width-2 more */
name|iagP
operator|--
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|(
name|cols
operator|-
literal|2
operator|*
name|width
operator|-
literal|2
operator|)
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|iagP
operator|--
operator|,
name|obgP
operator|--
control|)
operator|*
name|obgP
operator|=
operator|*
name|iagP
operator|>>
name|second_shifts
expr_stmt|;
comment|/* Then the first/final w+1 */
comment|/*      accum = *oagP>> second_shifts;*/
name|accum
operator|=
name|accumX
operator|>>
name|second_shifts
expr_stmt|;
for|for
control|(
name|c
operator|=
name|width
operator|+
literal|1
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|obgP
operator|--
control|)
operator|*
name|obgP
operator|=
name|accum
expr_stmt|;
block|}
comment|/* FILTER DOWN COLUMNS */
comment|/* Sum first 2*height+1 rows */
name|memset
argument_list|(
name|outImgPtr
argument_list|,
literal|'\0'
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
argument_list|)
expr_stmt|;
name|iagP
operator|=
name|obgP
operator|=
name|outImgPtr
expr_stmt|;
comment|/* iagP only for compiler warnings */
for|for
control|(
name|c
operator|=
name|cols
operator|,
name|obgP
operator|=
name|outImgPtr
init|;
name|c
operator|!=
literal|0
condition|;
name|c
operator|--
operator|,
name|obgP
operator|++
control|)
block|{
name|accum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
operator|(
literal|2
operator|*
name|height
operator|+
literal|1
operator|)
operator|,
name|iagP
operator|=
name|obgP
operator|+
name|cols
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|accum
operator|+=
operator|*
name|iagP
expr_stmt|;
name|iagP
operator|+=
name|cols
expr_stmt|;
block|}
operator|*
name|obgP
operator|=
name|accum
expr_stmt|;
block|}
name|iagP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
literal|2
operator|*
name|height
operator|+
literal|2
operator|)
operator|*
name|cols
index|]
expr_stmt|;
comment|/* MAIN SCAN DOWN */
comment|/* iagP already points to next to add, obgP to in/output. */
comment|/* Just do one big loop instead of nesting. */
name|oagP
operator|=
name|outImgPtr
expr_stmt|;
for|for
control|(
name|k
operator|=
operator|(
name|cols
operator|*
operator|(
name|rows
operator|-
literal|2
operator|*
name|height
operator|-
literal|1
operator|)
operator|)
init|;
name|k
operator|!=
literal|0
condition|;
name|k
operator|--
operator|,
name|obgP
operator|++
operator|,
name|oagP
operator|++
operator|,
name|iagP
operator|++
control|)
block|{
name|accum
operator|=
operator|*
name|oagP
operator|+
operator|*
name|iagP
operator|-
operator|*
name|obgP
expr_stmt|;
comment|/* y(k) = y(k-1) + x(k+w) - x(k-w-1) */
operator|*
name|obgP
operator|=
name|accum
expr_stmt|;
block|}
comment|/* STORE BY COPYING */
comment|/* First the last output into the last h entries. */
for|for
control|(
name|r
operator|=
name|height
operator|,
name|obgP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|rows
operator|-
literal|1
operator|)
operator|*
name|cols
index|]
init|;
name|r
operator|!=
literal|0
condition|;
name|r
operator|--
operator|,
name|obgP
operator|-=
name|cols
control|)
name|memcpy
argument_list|(
name|obgP
argument_list|,
name|oagP
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
argument_list|)
expr_stmt|;
comment|/* middle section */
name|memmove
argument_list|(
operator|&
name|outImgPtr
index|[
name|height
operator|*
name|cols
index|]
argument_list|,
name|outImgPtr
argument_list|,
name|cols
operator|*
operator|(
name|rows
operator|-
literal|2
operator|*
name|height
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and first/final rows */
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<
name|height
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|outImgPtr
index|[
name|r
operator|*
name|cols
index|]
argument_list|,
name|outImgPtr
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_BigGray
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* outImgPtr is an image array of size (cols)*(rows+1) of Glace_MidGrays */
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_FiltDD  */
end_comment

begin_function
name|void
DECL|function|Glace_FiltDD (Glace_CfgInfo * cfgInfoPtr,Glace_Gray * inImgHBPtr,Glace_MidGray * outImgPtr,int cols,int rows,Glace_TableInfo * tableInfoPtr,Glace_Gray * hBiasArray,Glace_Gray * vBiasArray,int numPasses)
name|Glace_FiltDD
parameter_list|(
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_Gray
modifier|*
name|inImgHBPtr
parameter_list|,
name|Glace_MidGray
modifier|*
name|outImgPtr
parameter_list|,
comment|/*signed long *lTable,*/
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_Gray
modifier|*
name|hBiasArray
parameter_list|,
name|Glace_Gray
modifier|*
name|vBiasArray
parameter_list|,
name|int
name|numPasses
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|c
decl_stmt|,
name|k
decl_stmt|;
name|Glace_Gray
modifier|*
name|iigP
decl_stmt|;
name|Glace_MidGray
modifier|*
name|iagP
decl_stmt|,
modifier|*
name|oagP
decl_stmt|;
name|Glace_MidGray
modifier|*
name|ibgP
decl_stmt|;
name|Glace_Gray
modifier|*
name|hwgP
decl_stmt|,
modifier|*
name|vwgP
decl_stmt|;
name|Glace_BigGray
name|accum
init|=
literal|0
decl_stmt|;
name|Glace_BigGray
name|wgt
decl_stmt|;
name|Glace_FillTableForFilt
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|/* This may be broken */
if|#
directive|if
literal|0
block|GlaceWindTableFillAll(cfgInfoPtr,tableInfoPtr, rows*cols,                            inImgHBPtr, outImgPtr);
else|#
directive|else
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
comment|/* Copy row of input image using lookup table to output array. */
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|iigP
operator|=
operator|&
name|inImgHBPtr
index|[
name|cols
operator|*
name|r
index|]
operator|,
name|iagP
operator|=
operator|&
name|outImgPtr
index|[
name|r
operator|*
name|cols
index|]
init|;
name|c
operator|<
name|cols
condition|;
name|c
operator|++
operator|,
name|iagP
operator|++
operator|,
name|iigP
operator|++
control|)
operator|*
name|iagP
operator|=
name|GLACE_TRM
argument_list|(
name|seriesTable
argument_list|)
index|[
operator|*
name|iigP
index|]
expr_stmt|;
endif|#
directive|endif
name|memcpy
argument_list|(
operator|&
name|outImgPtr
index|[
name|rows
operator|*
name|cols
index|]
argument_list|,
operator|&
name|outImgPtr
index|[
operator|(
name|rows
operator|-
literal|1
operator|)
operator|*
name|cols
index|]
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numPasses
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|k
operator|%
literal|2
operator|)
condition|)
block|{
for|for
control|(
name|r
operator|=
name|rows
operator|-
literal|2
init|;
name|r
operator|>
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|iagP
operator|=
operator|&
name|outImgPtr
index|[
name|r
operator|*
name|cols
index|]
expr_stmt|;
name|oagP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
index|]
expr_stmt|;
operator|*
name|oagP
operator|=
operator|*
name|iagP
expr_stmt|;
name|oagP
operator|++
expr_stmt|;
name|iagP
operator|++
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
operator|,
name|ibgP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|-
literal|1
operator|)
operator|*
name|cols
index|]
operator|+
literal|1
operator|,
name|hwgP
operator|=
operator|&
name|hBiasArray
index|[
name|cols
operator|*
name|r
index|]
operator|,
name|vwgP
operator|=
operator|&
name|vBiasArray
index|[
name|cols
operator|*
name|r
index|]
init|;
name|c
operator|<
operator|(
name|cols
operator|-
literal|1
operator|)
condition|;
name|c
operator|++
operator|,
name|iagP
operator|++
operator|,
name|oagP
operator|++
operator|,
name|ibgP
operator|++
operator|,
name|hwgP
operator|++
operator|,
name|vwgP
operator|++
control|)
block|{
comment|/* Do everything *2048 */
name|accum
operator|=
operator|(
operator|(
name|Glace_BigGray
operator|)
operator|*
name|iagP
operator|)
operator|<<
literal|10
expr_stmt|;
name|wgt
operator|=
operator|(
operator|(
operator|(
name|Glace_BigGray
operator|)
operator|*
name|hwgP
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 1<= wgt<=511 */
name|accum
operator|+=
name|wgt
operator|*
operator|*
operator|(
name|iagP
operator|+
literal|1
operator|)
expr_stmt|;
name|accum
operator|+=
operator|(
literal|512
operator|-
name|wgt
operator|)
operator|*
operator|*
operator|(
name|iagP
operator|-
literal|1
operator|)
expr_stmt|;
name|wgt
operator|=
operator|(
operator|(
operator|(
name|Glace_BigGray
operator|)
operator|*
name|vwgP
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|accum
operator|+=
operator|*
name|ibgP
operator|*
operator|(
literal|512
operator|-
name|wgt
operator|)
expr_stmt|;
name|accum
operator|+=
operator|*
name|oagP
operator|*
name|wgt
expr_stmt|;
operator|*
name|oagP
operator|=
operator|(
name|accum
operator|>>
literal|11
operator|)
expr_stmt|;
block|}
operator|*
name|oagP
operator|=
operator|*
name|iagP
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|outImgPtr
index|[
name|cols
index|]
argument_list|,
name|outImgPtr
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<
operator|(
name|rows
operator|-
literal|1
operator|)
condition|;
name|r
operator|++
control|)
block|{
name|iagP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
index|]
expr_stmt|;
name|oagP
operator|=
operator|&
name|outImgPtr
index|[
name|r
operator|*
name|cols
index|]
expr_stmt|;
operator|*
name|oagP
operator|=
operator|*
name|iagP
expr_stmt|;
name|oagP
operator|++
expr_stmt|;
name|iagP
operator|++
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
operator|,
name|ibgP
operator|=
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|+
literal|2
operator|)
operator|*
name|cols
index|]
operator|+
literal|1
operator|,
name|hwgP
operator|=
operator|&
name|hBiasArray
index|[
name|cols
operator|*
name|r
index|]
operator|,
name|vwgP
operator|=
operator|&
name|vBiasArray
index|[
name|cols
operator|*
name|r
index|]
init|;
name|c
operator|<
operator|(
name|cols
operator|-
literal|1
operator|)
condition|;
name|c
operator|++
operator|,
name|iagP
operator|++
operator|,
name|oagP
operator|++
operator|,
name|ibgP
operator|++
operator|,
name|hwgP
operator|++
operator|,
name|vwgP
operator|++
control|)
block|{
comment|/* Do everything *2048 */
name|accum
operator|=
operator|(
operator|(
name|Glace_BigGray
operator|)
operator|*
name|iagP
operator|)
operator|<<
literal|10
expr_stmt|;
name|wgt
operator|=
operator|(
operator|(
operator|(
name|Glace_BigGray
operator|)
operator|*
name|hwgP
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 1<= wgt<=511 */
name|accum
operator|+=
name|wgt
operator|*
operator|*
operator|(
name|iagP
operator|+
literal|1
operator|)
expr_stmt|;
name|accum
operator|+=
operator|(
literal|512
operator|-
name|wgt
operator|)
operator|*
operator|*
operator|(
name|iagP
operator|-
literal|1
operator|)
expr_stmt|;
name|wgt
operator|=
operator|(
operator|(
operator|(
name|Glace_BigGray
operator|)
operator|*
name|vwgP
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|accum
operator|+=
operator|*
name|oagP
operator|*
operator|(
literal|512
operator|-
name|wgt
operator|)
expr_stmt|;
name|accum
operator|+=
operator|*
name|ibgP
operator|*
name|wgt
expr_stmt|;
operator|*
name|oagP
operator|=
operator|(
name|accum
operator|>>
literal|11
operator|)
expr_stmt|;
block|}
operator|*
name|oagP
operator|=
operator|*
name|iagP
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|outImgPtr
index|[
operator|(
name|rows
operator|-
literal|1
operator|)
operator|*
name|cols
index|]
argument_list|,
operator|&
name|outImgPtr
index|[
name|rows
operator|*
name|cols
index|]
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If number of passes is odd, image is left in shifted position.*/
if|if
condition|(
name|numPasses
operator|%
literal|2
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|outImgPtr
index|[
name|r
operator|*
name|cols
index|]
argument_list|,
operator|&
name|outImgPtr
index|[
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
index|]
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|Glace_MidGray
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

