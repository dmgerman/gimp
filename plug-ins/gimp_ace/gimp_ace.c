begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* :PREAMBLE: gimp_ace.c  * Adaptive Contrast Enhancement plug-in for the GIMP (v1.0)  * (A windowed histogram equalization using the Fourier-series based  * fast algorithm.)  * Based on J. Alex Stark's<stark@niss.org> GLACE system.   * GIMP Plug-in by Kevin Turner<kevint@poboxes.com> */
end_comment

begin_comment
comment|/*  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  See the file COPYING for details.  *  */
end_comment

begin_comment
comment|/* :HEADERS:   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* autostuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GLACE_GIMP
end_ifndef

begin_define
DECL|macro|GLACE_GIMP
define|#
directive|define
name|GLACE_GIMP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_comment
comment|/* i18n - gettext */
end_comment

begin_define
DECL|macro|_ (String)
define|#
directive|define
name|_
parameter_list|(
name|String
parameter_list|)
value|gettext (String)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|gettext_noop
end_ifdef

begin_define
DECL|macro|N_ (String)
define|#
directive|define
name|N_
parameter_list|(
name|String
parameter_list|)
value|gettext_noop (String)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|N_ (String)
define|#
directive|define
name|N_
parameter_list|(
name|String
parameter_list|)
value|(String)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gimp_ace.h"
end_include

begin_comment
comment|/* defines the AceValues struct */
end_comment

begin_include
include|#
directive|include
file|"color.h"
end_include

begin_comment
comment|/* This has the RGB -> Y conversion factors. 		      for the SeperateChannels */
end_comment

begin_comment
comment|/* :*** Prototypes ***:   */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|do_ace
parameter_list|(
name|gint32
name|drawable_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GlaceGimp_ReadImgArrays
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|,
name|GDrawable
modifier|*
name|drawable_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SeperateChannels
parameter_list|(
name|guchar
modifier|*
name|inbuf
parameter_list|,
specifier|const
name|gint
name|buflen
parameter_list|,
specifier|const
name|gboolean
name|TypeRGB
parameter_list|,
specifier|const
name|gboolean
name|HasAlpha
parameter_list|,
specifier|const
name|Glace_ColorMethods
name|color_method
parameter_list|,
name|guchar
modifier|*
modifier|*
name|rbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|gbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|bbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|Graybuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|xbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|ybuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|ymaxbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GlaceGimp_Process
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static void GlaceGimp_ScanListfiles (Glace_CfgInfo *cfgInfoPtr); */
end_comment

begin_comment
comment|/* :*** Definitions ***:  */
end_comment

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|acevals
specifier|static
name|AceValues
name|acevals
init|=
block|{
literal|1.0
block|,
comment|/* Strength (full) */
literal|0.0
block|,
comment|/* brightness adjust (none) */
literal|0.0
block|,
comment|/* foobarm (none) */
literal|0.0
block|,
comment|/* smoothing (none) */
literal|10
block|,
comment|/* iterations */
literal|25
block|,
comment|/* window size */
name|GLACE_COLOR_Yxy
block|,
comment|/* Color method */
name|TRUE
comment|/* link strength and brightness adjust in dialog. */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :*** MAIN ***:   */
end_comment

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_comment
comment|/* :FUNCTION: query   */
end_comment

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|params
index|[]
init|=
block|{
comment|/* Required params. */
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive=0x0, Noninteractive=0x1"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image_id"
block|,
literal|"(unused)"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable_id"
block|,
name|N_
argument_list|(
literal|"Drawable to affect"
argument_list|)
block|}
block|,
comment|/* Our params. */
block|{
name|PARAM_INT32
block|,
literal|"ace_argc"
block|,
literal|"ace argument count"
block|}
block|,
block|{
name|PARAM_STRINGARRAY
block|,
literal|"ace_argv"
block|,
literal|"ace argument vector"
block|}
block|,   }
decl_stmt|;
specifier|const
name|int
name|nparams
init|=
sizeof|sizeof
argument_list|(
name|params
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|GParamDef
argument_list|)
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_ace"
argument_list|,
name|_
argument_list|(
literal|"Adaptive Contrast Enhancement"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"FIXME: Write ACE help."
argument_list|)
argument_list|,
literal|"Alex Stark, Kevin Turner,"
argument_list|,
literal|"Alex Stark, Kevin Turner,"
argument_list|,
literal|"1998,1999"
argument_list|,
literal|"<Image>/Image/Colors/Auto/Adaptive Contrast"
argument_list|,
literal|"GRAY*, RGB*"
argument_list|,
comment|/*FIXME*/
name|PROC_PLUG_IN
argument_list|,
name|nparams
argument_list|,
comment|/* # Params */
literal|0
argument_list|,
comment|/* # return values */
name|params
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* GParamDef *return_vals */
block|}
end_function

begin_comment
comment|/* :FUNCTION: run  */
end_comment

begin_function
specifier|static
name|void
DECL|function|run (gchar * name,gint nparams,GParam * param,gint * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|retvals
index|[
literal|1
index|]
decl_stmt|;
name|gint
name|needparams
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
operator|*
name|return_vals
operator|=
name|retvals
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
name|retvals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
comment|/* Guilty until proven innocent. */
name|retvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
name|run_mode
operator|=
operator|(
name|GRunModeType
operator|)
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_NONINTERACTIVE
case|:
if|if
condition|(
name|nparams
operator|<
literal|3
operator|||
name|param
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|PARAM_INT32
operator|||
name|param
index|[
literal|1
index|]
operator|.
name|type
operator|!=
name|PARAM_IMAGE
operator|||
name|param
index|[
literal|2
index|]
operator|.
name|type
operator|!=
name|PARAM_DRAWABLE
condition|)
block|{
name|g_warning
argument_list|(
literal|"gimp_ace: Caller is on crack!  "
literal|"You're not passing me the parameters required for a plug-in.  "
literal|"The first three types should be %d, %d, %d; but I'm reading "
literal|"%d, %d, %d.\n"
argument_list|,
name|PARAM_INT32
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|PARAM_DRAWABLE
argument_list|,
name|param
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
name|param
index|[
literal|2
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param
index|[
literal|3
index|]
operator|.
name|type
operator|!=
name|PARAM_INT32
operator|||
name|param
index|[
literal|4
index|]
operator|.
name|type
operator|!=
name|PARAM_STRING
condition|)
block|{
name|g_warning
argument_list|(
literal|"gimp_ace: caller is passing ace_argc and ace_argv as "
literal|"types %d and %d, should be %d and %d.\n"
argument_list|,
name|param
index|[
literal|3
index|]
operator|.
name|type
argument_list|,
name|param
index|[
literal|4
index|]
operator|.
name|type
argument_list|,
name|PARAM_INT32
argument_list|,
name|PARAM_STRINGARRAY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* endif param.type */
comment|/* FIXME: do something intelligent with the parameters. */
break|break;
case|case
name|RUN_INTERACTIVE
case|:
name|retvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
name|gimp_get_data
argument_list|(
literal|"plug_in_ace"
argument_list|,
operator|&
name|acevals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ace_dialog
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|acevals
argument_list|)
condition|)
block|{
comment|/* No error, but dialog cancelled. */
name|retvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
return|return;
block|}
comment|/* else continue on and do antialias below. */
name|gimp_set_data
argument_list|(
literal|"plug_in_ace"
argument_list|,
operator|&
name|acevals
argument_list|,
sizeof|sizeof
argument_list|(
name|AceValues
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
name|gimp_get_data
argument_list|(
literal|"plug_in_ace"
argument_list|,
operator|&
name|acevals
argument_list|)
expr_stmt|;
break|break;
block|}
name|retvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
name|retvals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|do_ace
argument_list|(
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_drawable
argument_list|)
condition|?
name|STATUS_SUCCESS
else|:
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
end_function

begin_comment
comment|/* :*** Support Functions ***:   */
end_comment

begin_comment
comment|/* :FUNCTION: do_ace(gint32 drawable_id)  */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|do_ace (gint32 drawable_id)
name|do_ace
parameter_list|(
name|gint32
name|drawable_id
parameter_list|)
block|{
name|gchar
modifier|*
name|ace_argv
index|[]
init|=
block|{
literal|"-reset"
block|,
literal|"25"
block|,
literal|"25"
block|,
literal|"10"
block|,
literal|"-factor"
block|,
literal|"0.0"
block|,
comment|/* 1.0 is identity, 0.0 is full effect. */
literal|"-prescale"
block|,
literal|"1.0"
block|,
literal|"-gauss"
block|,
literal|"0"
block|,
literal|"-hamming"
block|,
literal|"-gg"
block|,
literal|"-passthru"
block|,
literal|"1.0"
block|,
literal|"-inoffset"
block|,
literal|"127.5"
block|,
literal|"-tol"
block|,
literal|"0.0"
block|}
decl_stmt|;
name|gint
name|ace_argc
init|=
literal|18
decl_stmt|;
comment|/* -reset 25 25 10 -cumu -1.2 1.2 361 -factor 1.0 -prescale 1.0 -gauss      0 -gg -passthru 1.0 -inoffset 127.5 -tol 0.0 -input inImg -output outImg1*/
comment|/* gchar *ace_argv[] =  { "-reset", "25", "25", "5", "-cumu", "-1.2",       "1.2", "361", "-factor", "0.0", "-prescale",      "1.0", "-gauss", "0", "-gg",       "-passthru", "1.00", "-inoffset", "127.5", "-tol", "0.0"}; */
name|Glace_ClientData
modifier|*
name|clientData
decl_stmt|;
name|GDrawable
modifier|*
name|drawable_ptr
init|=
name|gimp_drawable_get
argument_list|(
name|drawable_id
argument_list|)
decl_stmt|;
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Adaptive Contrast Enhancement:"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|g_message("gimp_ace PID: %d\n",getpid());       kill(getpid(),19);
endif|#
directive|endif
comment|/* I don't know what most of this does.      It's copied out of pnmace.c */
name|clientData
operator|=
name|Glace_AllocClientData
argument_list|()
expr_stmt|;
name|Glace_WInit
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_CfgInit
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_ParseArgs
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|,
name|ace_argc
argument_list|,
name|ace_argv
argument_list|)
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|heFactor
operator|=
literal|1.0
operator|-
name|acevals
operator|.
name|strength
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|passthruFactor
operator|=
literal|1.0
operator|-
name|acevals
operator|.
name|bradj
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|numTerms
operator|=
name|acevals
operator|.
name|iterations
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|windBaseW
operator|=
name|acevals
operator|.
name|wsize
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|windBaseH
operator|=
name|acevals
operator|.
name|wsize
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|coeffTol
operator|=
name|acevals
operator|.
name|coefftol
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|gaussCwindWidth
operator|=
name|acevals
operator|.
name|smoothing
expr_stmt|;
name|clientData
operator|->
name|cfgInfoPtr
operator|->
name|colorMethod
operator|=
name|acevals
operator|.
name|color_method
expr_stmt|;
name|GLACE_ERROR_EXIT
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_CfgAllocSeriesVectors
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME:  GlaceGimp_ScanListfiles ( GLACE_CDATA(cfgInfoPtr) ); */
name|GLACE_ERROR_EXIT
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_CfgBeginToHeseries
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_ERROR_EXIT
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_CfgHeseriesToAddback
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_CFuncGen
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This also allocs the input/ref/ddH/ddV image arrays */
comment|/* FIXME */
name|GlaceGimp_ReadImgArrays
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|,
name|drawable_ptr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_EXIT
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|0.1
argument_list|)
expr_stmt|;
name|Glace_CfgAddbackToEnd
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_AllocTables
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_DefaultTmpImg
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_AllocImgArrays
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|)
expr_stmt|;
name|GlaceGimp_Process
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_ERROR_EXIT
argument_list|(
name|GLACE_CDATA
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_CfgFreeSeriesVectors
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_FreeImgArrays
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|imgArraysPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_FreeTables
argument_list|(
name|GLACE_CDATA
argument_list|(
name|cfgInfoPtr
argument_list|)
argument_list|,
name|GLACE_CDATA
argument_list|(
name|tableInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_FreeClientData
argument_list|(
name|clientData
argument_list|)
expr_stmt|;
comment|/* GlaceGimp_CloseFile (stdout); */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* :FUNCTION: FIXME GlaceGimp_ReadImgArrays  * Assumptions: Input is one byte-per-pixel grayscale.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|GlaceGimp_ReadImgArrays (Glace_WData wData,Glace_CfgInfo * cfgInfoPtr,Glace_ImgArrays * imgArraysPtr,GDrawable * drawable_ptr)
name|GlaceGimp_ReadImgArrays
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|,
name|GDrawable
modifier|*
name|drawable_ptr
parameter_list|)
block|{
name|guchar
modifier|*
name|gimp_buf
init|=
name|NULL
decl_stmt|;
name|gint
name|gimp_size
decl_stmt|;
name|GPixelRgn
name|src_rgn
decl_stmt|;
name|gint
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
comment|/* Bounds of the selection */
comment|/* Nurb Nurb Oink. */
name|GLACE_IMG
argument_list|(
name|inImgPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|inImgCxPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|inImgCyPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|inImgCYMaxPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|inImgRPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|inImgGPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|inImgBPtr
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|WRAPPER
argument_list|(
name|drawable_ptr
argument_list|)
operator|=
name|drawable_ptr
expr_stmt|;
name|gimp_drawable_mask_bounds
argument_list|(
name|drawable_ptr
operator|->
name|id
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
operator|(
operator|(
operator|(
name|GlaceGimpData
operator|*
operator|)
name|wData
operator|)
operator|->
name|gimp_x0
operator|)
operator|=
name|x1
expr_stmt|;
operator|(
operator|(
operator|(
name|GlaceGimpData
operator|*
operator|)
name|wData
operator|)
operator|->
name|gimp_y0
operator|)
operator|=
name|y1
expr_stmt|;
operator|(
name|imgArraysPtr
operator|->
name|cols
operator|)
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
operator|(
name|imgArraysPtr
operator|->
name|rows
operator|)
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|WRAPPER
argument_list|(
name|drawable_ptr
argument_list|)
argument_list|,
name|WRAPPER
argument_list|(
name|gimp_x0
argument_list|)
argument_list|,
name|WRAPPER
argument_list|(
name|gimp_y0
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* skip some pixels on output so we can mix the alpha back in. */
name|GLACE_IMG
argument_list|(
name|pixelBytePad
argument_list|)
operator|=
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ptr
operator|->
name|id
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* This refers to precision, not number of channels. */
name|GLACE_IMG
argument_list|(
name|pixelSize
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gimp_size
operator|=
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
operator|*
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
operator|*
name|drawable_ptr
operator|->
name|bpp
expr_stmt|;
name|WRAPPER
argument_list|(
name|gimpImgPtr
argument_list|)
operator|=
name|gimp_buf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|gimp_size
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|src_rgn
argument_list|,
name|gimp_buf
argument_list|,
name|WRAPPER
argument_list|(
name|gimp_x0
argument_list|)
argument_list|,
name|WRAPPER
argument_list|(
name|gimp_y0
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|)
expr_stmt|;
name|imgArraysPtr
operator|->
name|inImgSize
operator|=
name|SeperateChannels
argument_list|(
name|gimp_buf
argument_list|,
name|gimp_size
argument_list|,
name|gimp_drawable_color
argument_list|(
name|drawable_ptr
operator|->
name|id
argument_list|)
argument_list|,
name|gimp_drawable_has_alpha
argument_list|(
name|drawable_ptr
operator|->
name|id
argument_list|)
argument_list|,
name|cfgInfoPtr
operator|->
name|colorMethod
argument_list|,
operator|&
name|imgArraysPtr
operator|->
name|inImgPtr
argument_list|,
comment|/* Greybuf (to process) */
operator|&
name|imgArraysPtr
operator|->
name|inImgRPtr
argument_list|,
comment|/* rbuf */
operator|&
name|imgArraysPtr
operator|->
name|inImgGPtr
argument_list|,
comment|/* gbuf */
operator|&
name|imgArraysPtr
operator|->
name|inImgBPtr
argument_list|,
comment|/* bbuf */
operator|&
name|imgArraysPtr
operator|->
name|inImgCxPtr
argument_list|,
comment|/* xbuf */
operator|&
name|imgArraysPtr
operator|->
name|inImgCyPtr
argument_list|,
comment|/* ybuf */
operator|&
name|imgArraysPtr
operator|->
name|inImgCYMaxPtr
argument_list|)
expr_stmt|;
comment|/* YMaxbuf */
name|imgArraysPtr
operator|->
name|refImgPtr
operator|=
name|imgArraysPtr
operator|->
name|inImgPtr
expr_stmt|;
name|imgArraysPtr
operator|->
name|refImgLBPtr
operator|=
name|imgArraysPtr
operator|->
name|refImgHBPtr
operator|=
name|imgArraysPtr
operator|->
name|inImgLBPtr
operator|=
name|imgArraysPtr
operator|->
name|inImgHBPtr
operator|=
name|imgArraysPtr
operator|->
name|inImgPtr
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|chrome
argument_list|)
operator|=
name|gimp_drawable_color
argument_list|(
name|drawable_ptr
operator|->
name|id
argument_list|)
condition|?
name|GLACE_CC
else|:
name|GLACE_GG
expr_stmt|;
comment|/* This is forced config stuff. */
comment|/*  if (GLACE_CFG(filtMethod) == GLACE_WINDOW) */
name|GLACE_CFG
argument_list|(
name|filtMethod
argument_list|)
operator|=
name|GLACE_WINDOW
expr_stmt|;
name|GLACE_IMG
argument_list|(
name|ddHImgPtr
argument_list|)
operator|=
name|GLACE_IMG
argument_list|(
name|ddVImgPtr
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|GLACE_CFG
argument_list|(
name|doublep
argument_list|)
operator|=
name|GLACE_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|SeperateChannels (guchar * inbuf,const gint buflen,const gboolean TypeRGB,const gboolean HasAlpha,const Glace_ColorMethods color_method,guchar ** Graybuf,guchar ** rbuf,guchar ** gbuf,guchar ** bbuf,guchar ** xbuf,guchar ** ybuf,guchar ** Ymaxbuf)
name|SeperateChannels
parameter_list|(
name|guchar
modifier|*
name|inbuf
parameter_list|,
specifier|const
name|gint
name|buflen
parameter_list|,
specifier|const
name|gboolean
name|TypeRGB
parameter_list|,
specifier|const
name|gboolean
name|HasAlpha
parameter_list|,
specifier|const
name|Glace_ColorMethods
name|color_method
parameter_list|,
name|guchar
modifier|*
modifier|*
name|Graybuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|rbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|gbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|bbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|xbuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|ybuf
parameter_list|,
name|guchar
modifier|*
modifier|*
name|Ymaxbuf
parameter_list|)
block|{
name|int
name|c
init|=
literal|0
decl_stmt|,
name|ic
init|=
literal|0
decl_stmt|,
name|bpp
decl_stmt|;
name|guchar
modifier|*
name|Grayfoo
decl_stmt|;
if|if
condition|(
operator|!
name|TypeRGB
operator|&&
operator|!
name|HasAlpha
condition|)
block|{
operator|*
name|Graybuf
operator|=
name|inbuf
expr_stmt|;
return|return
name|buflen
return|;
block|}
if|if
condition|(
operator|!
name|TypeRGB
operator|&&
name|HasAlpha
condition|)
block|{
if|if
condition|(
operator|(
name|buflen
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
name|g_error
argument_list|(
literal|"GRAYA with odd size %d?"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Graybuf
operator|==
name|NULL
condition|)
operator|*
name|Graybuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
literal|2
argument_list|)
expr_stmt|;
name|Grayfoo
operator|=
operator|*
name|Graybuf
expr_stmt|;
while|while
condition|(
name|ic
operator|<
name|buflen
condition|)
block|{
name|Grayfoo
index|[
name|c
index|]
operator|=
name|inbuf
index|[
name|ic
operator|++
index|]
expr_stmt|;
name|ic
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
comment|/* if GRAYA */
if|if
condition|(
name|TypeRGB
condition|)
block|{
name|guchar
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
name|guchar
modifier|*
name|xfoo
decl_stmt|,
modifier|*
name|yfoo
decl_stmt|,
modifier|*
name|Ymaxfoo
decl_stmt|;
name|guchar
modifier|*
name|rfoo
decl_stmt|,
modifier|*
name|bfoo
decl_stmt|,
modifier|*
name|gfoo
decl_stmt|;
name|bpp
operator|=
name|HasAlpha
condition|?
literal|4
else|:
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|%
name|bpp
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_error
argument_list|(
literal|"RGB: %d Alpha: %d.  I think bpp should be %d, but that"
literal|"doesn't make sense with size %d, as R = %d"
argument_list|,
name|TypeRGB
argument_list|,
name|HasAlpha
argument_list|,
name|bpp
argument_list|,
name|buflen
argument_list|,
name|buflen
operator|%
name|bpp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|Graybuf
operator|==
name|NULL
condition|)
operator|*
name|Graybuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
name|Grayfoo
operator|=
operator|*
name|Graybuf
expr_stmt|;
if|if
condition|(
name|color_method
operator|==
name|GLACE_COLOR_Yxy
condition|)
block|{
if|if
condition|(
operator|*
name|xbuf
operator|==
name|NULL
condition|)
operator|*
name|xbuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ybuf
operator|==
name|NULL
condition|)
operator|*
name|ybuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Ymaxbuf
operator|==
name|NULL
condition|)
operator|*
name|Ymaxbuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
name|xfoo
operator|=
operator|*
name|xbuf
expr_stmt|;
name|yfoo
operator|=
operator|*
name|ybuf
expr_stmt|;
name|Ymaxfoo
operator|=
operator|*
name|Ymaxbuf
expr_stmt|;
name|puts
argument_list|(
literal|"Seperating into Yxy"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|rbuf
operator|==
name|NULL
condition|)
operator|*
name|rbuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|gbuf
operator|==
name|NULL
condition|)
operator|*
name|gbuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bbuf
operator|==
name|NULL
condition|)
operator|*
name|bbuf
operator|=
name|g_new
argument_list|(
name|guchar
argument_list|,
name|buflen
operator|/
name|bpp
argument_list|)
expr_stmt|;
name|rfoo
operator|=
operator|*
name|rbuf
expr_stmt|;
name|gfoo
operator|=
operator|*
name|gbuf
expr_stmt|;
name|bfoo
operator|=
operator|*
name|bbuf
expr_stmt|;
name|puts
argument_list|(
literal|"Seperating into RGB"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ic
operator|<
name|buflen
condition|)
block|{
name|R
operator|=
name|inbuf
index|[
name|ic
operator|++
index|]
expr_stmt|;
name|G
operator|=
name|inbuf
index|[
name|ic
operator|++
index|]
expr_stmt|;
name|B
operator|=
name|inbuf
index|[
name|ic
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|HasAlpha
condition|)
name|ic
operator|++
expr_stmt|;
if|if
condition|(
name|color_method
operator|!=
name|GLACE_COLOR_Yxy
condition|)
block|{
name|rfoo
index|[
name|c
index|]
operator|=
name|R
expr_stmt|;
name|gfoo
index|[
name|c
index|]
operator|=
name|G
expr_stmt|;
name|bfoo
index|[
name|c
index|]
operator|=
name|B
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|R
operator|==
literal|0
operator|)
operator|&&
operator|(
name|G
operator|==
literal|0
operator|)
operator|&&
operator|(
name|B
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Black is a special case.  Choose values                              that won't make divide by 0 errors. */
name|Grayfoo
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|color_method
operator|==
name|GLACE_COLOR_Yxy
condition|)
block|{
name|xfoo
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|yfoo
index|[
name|c
index|]
operator|=
literal|255
expr_stmt|;
name|Ymaxfoo
index|[
name|c
index|]
operator|=
literal|255
expr_stmt|;
block|}
block|}
else|else
block|{
name|gfloat
name|X1
decl_stmt|,
name|Y1
decl_stmt|,
name|Z1
decl_stmt|;
name|gfloat
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|gfloat
name|rYmax
decl_stmt|,
name|gYmax
decl_stmt|,
name|bYmax
decl_stmt|;
comment|/* Calculate XYZ coordinates for original image. */
name|Y1
operator|=
name|Y_r
operator|*
name|R
operator|+
name|Y_g
operator|*
name|G
operator|+
name|Y_b
operator|*
name|B
expr_stmt|;
comment|/* This is the channel which is processed. */
name|Grayfoo
index|[
name|c
index|]
operator|=
name|Y1
expr_stmt|;
if|if
condition|(
name|color_method
operator|==
name|GLACE_COLOR_Yxy
condition|)
block|{
name|X1
operator|=
name|X_r
operator|*
name|R
operator|+
name|X_g
operator|*
name|G
operator|+
name|X_b
operator|*
name|B
expr_stmt|;
name|Z1
operator|=
name|Z_r
operator|*
name|R
operator|+
name|Z_g
operator|*
name|G
operator|+
name|Z_b
operator|*
name|B
expr_stmt|;
comment|/* Find chromacity xy coordinates. */
comment|/* Multiplied by 255 because we're not storing 				     them as floats from 0-1 but in an 8-bit 				     data type. */
name|xfoo
index|[
name|c
index|]
operator|=
name|x
operator|=
literal|255.0
operator|*
name|X1
operator|/
operator|(
name|X1
operator|+
name|Y1
operator|+
name|Z1
operator|)
expr_stmt|;
name|yfoo
index|[
name|c
index|]
operator|=
name|y
operator|=
literal|255.0
operator|*
name|Y1
operator|/
operator|(
name|X1
operator|+
name|Y1
operator|+
name|Z1
operator|)
expr_stmt|;
name|z
operator|=
literal|255.0
operator|-
name|x
operator|-
name|y
expr_stmt|;
comment|/* This calculates the maximum displayable 				     luminosity for this color. */
name|rYmax
operator|=
literal|255.0
operator|/
operator|(
operator|(
literal|1
operator|/
name|y
operator|)
operator|*
operator|(
name|R_x
operator|*
name|x
operator|+
name|R_z
operator|*
name|z
operator|)
operator|+
name|R_y
operator|)
expr_stmt|;
name|gYmax
operator|=
literal|255.0
operator|/
operator|(
operator|(
literal|1
operator|/
name|y
operator|)
operator|*
operator|(
name|G_x
operator|*
name|x
operator|+
name|G_z
operator|*
name|z
operator|)
operator|+
name|G_y
operator|)
expr_stmt|;
name|bYmax
operator|=
literal|255.0
operator|/
operator|(
operator|(
literal|1
operator|/
name|y
operator|)
operator|*
operator|(
name|B_x
operator|*
name|x
operator|+
name|B_z
operator|*
name|z
operator|)
operator|+
name|B_y
operator|)
expr_stmt|;
name|Ymaxfoo
index|[
name|c
index|]
operator|=
name|MIN
argument_list|(
name|MIN
argument_list|(
name|rYmax
argument_list|,
name|gYmax
argument_list|)
argument_list|,
name|bYmax
argument_list|)
expr_stmt|;
block|}
comment|/* endif Yxy */
block|}
comment|/* endif rgb != 0 */
name|c
operator|++
expr_stmt|;
block|}
comment|/* whend */
return|return
name|c
return|;
block|}
comment|/* endif rgb */
name|g_error
argument_list|(
literal|"Fell through SeperateChannels."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* SeperateChannels() */
end_comment

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/*  * :FUNCTION: Glace_Process  */
end_comment

begin_function
name|void
DECL|function|GlaceGimp_Process (Glace_WData wData,Glace_CfgInfo * cfgInfoPtr,Glace_TableInfo * tableInfoPtr,Glace_ImgArrays * imgArraysPtr)
name|GlaceGimp_Process
parameter_list|(
name|Glace_WData
name|wData
parameter_list|,
name|Glace_CfgInfo
modifier|*
name|cfgInfoPtr
parameter_list|,
name|Glace_TableInfo
modifier|*
name|tableInfoPtr
parameter_list|,
name|Glace_ImgArrays
modifier|*
name|imgArraysPtr
parameter_list|)
block|{
name|guint
name|k
decl_stmt|;
name|Glace_WindChk
argument_list|(
name|cfgInfoPtr
argument_list|,
name|GLACE_IMG
argument_list|(
name|cols
argument_list|)
argument_list|,
name|GLACE_IMG
argument_list|(
name|rows
argument_list|)
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_InitAccIm
argument_list|(
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLACE_CFG
argument_list|(
name|outputMethod
argument_list|)
operator|==
name|GLACE_NORMAL
condition|)
block|{
for|for
control|(
name|k
operator|=
name|GLACE_CFG
argument_list|(
name|firstTerm
argument_list|)
init|;
name|k
operator|<=
operator|(
name|unsigned
operator|)
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|Glace_SetForTerm
argument_list|(
name|tableInfoPtr
argument_list|,
name|k
argument_list|,
name|GLACE_COS
argument_list|)
expr_stmt|;
name|Glace_TermlyReport
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_SetTables
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_GenGen
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_SetForTerm
argument_list|(
name|tableInfoPtr
argument_list|,
name|k
argument_list|,
name|GLACE_SIN
argument_list|)
expr_stmt|;
name|Glace_SetTables
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|)
expr_stmt|;
name|Glace_GenGen
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_WMessage
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|0.10
operator|+
literal|0.90
operator|*
name|k
operator|/
name|GLACE_CFG
argument_list|(
name|numTerms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Glace_DiagGen
argument_list|(
name|cfgInfoPtr
argument_list|,
name|tableInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
block|}
name|GLACE_ERROR_CHECK
argument_list|(
name|GLACE_CFG
argument_list|(
name|wData
argument_list|)
argument_list|)
expr_stmt|;
name|Glace_Output
argument_list|(
name|wData
argument_list|,
name|cfgInfoPtr
argument_list|,
name|imgArraysPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* :FUNCTION: FIXME GlacePnm_ScanListfiles  */
end_comment

begin_comment
comment|/*static void GlaceGimp_ScanListfiles (Glace_CfgInfo *cfgInfoPtr) {   g_warning("GlaceGimp_ScanListFiles in gimp_ace.c not yet implemented.\n"); }*/
end_comment

begin_comment
comment|/*   GlaceGimp_CloseFile (stdout); */
end_comment

end_unit

