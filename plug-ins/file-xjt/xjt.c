begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xjt.c  *  * XJT (JPEG-TAR fileformat) loading and saving file filter for GIMP  *  -hof (Wolfgang Hofer)  *  * This filter requires UNIX tar and the "jpeglib" Library to run.  * For optional further compression you also should install  *  gzip and bzip2 compression Programs.  *  * IMPORTANT NOTE:  *   This plugin needs GIMP 1.1.18 or newer versions of the GIMP-core to run.  */
end_comment

begin_comment
comment|/* GIMP - The GNU Image Manipulation Program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software: you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/* TODO:  *  - support user units  *  - show continous progress while loading/saving  */
end_comment

begin_comment
comment|/* revision history:  * version 1.3.14a; 2003/06/03  hof: bugfix: using setlocale independent float conversion procedures  *                                   p_my_ascii_strtod (g_ascii_strtod()) and g_ascii_formatd()  * version 1.1.18a; 2000/03/07  hof: tattoo_state  * version 1.1.16a; 2000/02/04  hof: load paths continued, load tattos, load/save unit  * version 1.1.15b; 2000/01/28  hof: save/load paths  (load is not activated PDB-bug)  *                                   continued save/load parasites,  *                                   replaced static buffers by dynamic allocated memory (goodbye to sprintf)  * version 1.1.15a; 2000/01/23  hof: NLS_macros, save/load parasites, \" and \n characters in names  *                                   use G_DIR_SEPARATOR (but you still need UNIX tar to run this plugin)  *                                   older gimp releases (prior to 1.1.15) are not supported any more.  * version 1.02.00; 1999/03/16  hof: - save layer/channel Tattoos  *                                   - load/save image resolution added  *                                   - tolerate unknown properties with warnings  * version 1.01.00; 1998/11/22  hof: added load/save of guides  *                                   (you need gimp 1.1 to use this feature)  * version 1.00.00; 1998/10/29  hof: 1.st (pre) release  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_comment
comment|/* FIXME: #undef GTK_DISABLE_DEPRECATED */
end_comment

begin_undef
undef|#
directive|undef
name|GIMP_DISABLE_DEPRECATED
end_undef

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/* getpid() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XJT includes */
end_comment

begin_include
include|#
directive|include
file|"xjpeg.h"
end_include

begin_define
DECL|macro|LOAD_PROC
define|#
directive|define
name|LOAD_PROC
value|"file-xjt-load"
end_define

begin_define
DECL|macro|SAVE_PROC
define|#
directive|define
name|SAVE_PROC
value|"file-xjt-save"
end_define

begin_define
DECL|macro|PLUG_IN_BINARY
define|#
directive|define
name|PLUG_IN_BINARY
value|"flie-xjt"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_typedef
DECL|typedef|pid_t
typedef|typedef
name|int
name|pid_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|GIMP_XJ_IMAGE
define|#
directive|define
name|GIMP_XJ_IMAGE
value|"GIMP_XJ_IMAGE"
end_define

begin_define
DECL|macro|SCALE_WIDTH
define|#
directive|define
name|SCALE_WIDTH
value|125
end_define

begin_define
DECL|macro|XJT_ORIENTATION_HORIZONTAL
define|#
directive|define
name|XJT_ORIENTATION_HORIZONTAL
value|0
end_define

begin_define
DECL|macro|XJT_ORIENTATION_VERTICAL
define|#
directive|define
name|XJT_ORIENTATION_VERTICAL
value|1
end_define

begin_decl_stmt
DECL|variable|xjt_debug
specifier|static
name|gint
name|xjt_debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|g_pid
specifier|static
name|pid_t
name|g_pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|global_parasite_prop_lines
specifier|static
name|gchar
modifier|*
name|global_parasite_prop_lines
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|global_parasite_id
specifier|static
name|gint
name|global_parasite_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PROPERTY enums  *  (0-21 are ident with PropType values as used in xcf.c  *   the rest was added for xjt  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0103
block|{
DECL|enumerator|PROP_END
name|PROP_END
init|=
literal|0
block|,
DECL|enumerator|PROP_COLORMAP
name|PROP_COLORMAP
init|=
literal|1
block|,
DECL|enumerator|PROP_ACTIVE_LAYER
name|PROP_ACTIVE_LAYER
init|=
literal|2
block|,
DECL|enumerator|PROP_ACTIVE_CHANNEL
name|PROP_ACTIVE_CHANNEL
init|=
literal|3
block|,
DECL|enumerator|PROP_SELECTION
name|PROP_SELECTION
init|=
literal|4
block|,
DECL|enumerator|PROP_FLOATING_SELECTION
name|PROP_FLOATING_SELECTION
init|=
literal|5
block|,
DECL|enumerator|PROP_OPACITY
name|PROP_OPACITY
init|=
literal|6
block|,
DECL|enumerator|PROP_MODE
name|PROP_MODE
init|=
literal|7
block|,
DECL|enumerator|PROP_VISIBLE
name|PROP_VISIBLE
init|=
literal|8
block|,
DECL|enumerator|PROP_LINKED
name|PROP_LINKED
init|=
literal|9
block|,
DECL|enumerator|PROP_LOCK_ALPHA
name|PROP_LOCK_ALPHA
init|=
literal|10
block|,
DECL|enumerator|PROP_APPLY_MASK
name|PROP_APPLY_MASK
init|=
literal|11
block|,
DECL|enumerator|PROP_EDIT_MASK
name|PROP_EDIT_MASK
init|=
literal|12
block|,
DECL|enumerator|PROP_SHOW_MASK
name|PROP_SHOW_MASK
init|=
literal|13
block|,
DECL|enumerator|PROP_SHOW_MASKED
name|PROP_SHOW_MASKED
init|=
literal|14
block|,
DECL|enumerator|PROP_OFFSETS
name|PROP_OFFSETS
init|=
literal|15
block|,
DECL|enumerator|PROP_COLOR
name|PROP_COLOR
init|=
literal|16
block|,
DECL|enumerator|PROP_COMPRESSION
name|PROP_COMPRESSION
init|=
literal|17
block|,
DECL|enumerator|PROP_GUIDES
name|PROP_GUIDES
init|=
literal|18
block|,
DECL|enumerator|PROP_RESOLUTION
name|PROP_RESOLUTION
init|=
literal|19
block|,
DECL|enumerator|PROP_TATTOO
name|PROP_TATTOO
init|=
literal|20
block|,
DECL|enumerator|PROP_PARASITES
name|PROP_PARASITES
init|=
literal|21
block|,
DECL|enumerator|PROP_UNIT
name|PROP_UNIT
init|=
literal|22
block|,
DECL|enumerator|PROP_PATHS
name|PROP_PATHS
init|=
literal|23
block|,
DECL|enumerator|PROP_USER_UNIT
name|PROP_USER_UNIT
init|=
literal|24
block|,
DECL|enumerator|PROP_TATTOO_STATE
name|PROP_TATTOO_STATE
init|=
literal|85
block|,
DECL|enumerator|PROP_PATH_LOCKED
name|PROP_PATH_LOCKED
init|=
literal|86
block|,
DECL|enumerator|PROP_PATH_CURRENT
name|PROP_PATH_CURRENT
init|=
literal|87
block|,
DECL|enumerator|PROP_PATH_TYPE
name|PROP_PATH_TYPE
init|=
literal|88
block|,
DECL|enumerator|PROP_PATH_POINTS
name|PROP_PATH_POINTS
init|=
literal|89
block|,
DECL|enumerator|PROP_NAME
name|PROP_NAME
init|=
literal|90
block|,
DECL|enumerator|PROP_DIMENSION
name|PROP_DIMENSION
init|=
literal|91
block|,
DECL|enumerator|PROP_TYPE
name|PROP_TYPE
init|=
literal|92
block|,
DECL|enumerator|PROP_VERSION
name|PROP_VERSION
init|=
literal|93
block|,
DECL|enumerator|PROP_FLOATING_ATTACHED
name|PROP_FLOATING_ATTACHED
init|=
literal|94
block|,
DECL|enumerator|PROP_PARASITE_FLAGS
name|PROP_PARASITE_FLAGS
init|=
literal|95
block|,
DECL|enumerator|PROP_GIMP_VERSION
name|PROP_GIMP_VERSION
init|=
literal|96
block|,
DECL|enumerator|PROP_SYNTAX_ERROR
name|PROP_SYNTAX_ERROR
init|=
literal|99
DECL|typedef|t_proptype
block|}
name|t_proptype
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0203
block|{
DECL|enumerator|PTYP_NOT_SUPPORTED
name|PTYP_NOT_SUPPORTED
init|=
literal|0
block|,
DECL|enumerator|PTYP_BOOLEAN
name|PTYP_BOOLEAN
init|=
literal|1
block|,
DECL|enumerator|PTYP_INT
name|PTYP_INT
init|=
literal|2
block|,
DECL|enumerator|PTYP_FLT
name|PTYP_FLT
init|=
literal|3
block|,
DECL|enumerator|PTYP_STRING
name|PTYP_STRING
init|=
literal|4
block|,
DECL|enumerator|PTYP_2xINT
name|PTYP_2xINT
init|=
literal|5
block|,
DECL|enumerator|PTYP_3xINT
name|PTYP_3xINT
init|=
literal|6
block|,
DECL|enumerator|PTYP_2xFLT
name|PTYP_2xFLT
init|=
literal|7
block|,
DECL|enumerator|PTYP_3xFLT
name|PTYP_3xFLT
init|=
literal|8
block|,
DECL|enumerator|PTYP_FLIST
name|PTYP_FLIST
init|=
literal|9
DECL|typedef|t_param_typ
block|}
name|t_param_typ
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0303
block|{
DECL|enumerator|XJT_IMAGE_PARASITE
name|XJT_IMAGE_PARASITE
init|=
literal|0
block|,
DECL|enumerator|XJT_LAYER_PARASITE
name|XJT_LAYER_PARASITE
init|=
literal|1
block|,
DECL|enumerator|XJT_LAYER_MASK_PARASITE
name|XJT_LAYER_MASK_PARASITE
init|=
literal|2
block|,
DECL|enumerator|XJT_CHANNEL_PARASITE
name|XJT_CHANNEL_PARASITE
init|=
literal|3
DECL|typedef|t_parasitetype
block|}
name|t_parasitetype
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0403
block|{
DECL|enumerator|XJT_RGB
name|XJT_RGB
init|=
literal|0
block|,
DECL|enumerator|XJT_GRAY
name|XJT_GRAY
init|=
literal|1
comment|/* XJT_INDEXED = 2 */
comment|/* xjt does not support indexed images */
DECL|typedef|XJTImageBaseType
block|}
name|XJTImageBaseType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0503
block|{
DECL|enumerator|XJT_PATHTYPE_UNDEF
name|XJT_PATHTYPE_UNDEF
init|=
literal|0
block|,
DECL|enumerator|XJT_PATHTYPE_BEZIER
name|XJT_PATHTYPE_BEZIER
init|=
literal|1
DECL|typedef|XJTPathType
block|}
name|XJTPathType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0603
block|{
DECL|enumerator|XJT_UNIT_PIXEL
name|XJT_UNIT_PIXEL
init|=
literal|0
block|,
DECL|enumerator|XJT_UNIT_INCH
name|XJT_UNIT_INCH
init|=
literal|1
block|,
DECL|enumerator|XJT_UNIT_MM
name|XJT_UNIT_MM
init|=
literal|2
block|,
DECL|enumerator|XJT_UNIT_POINT
name|XJT_UNIT_POINT
init|=
literal|3
block|,
DECL|enumerator|XJT_UNIT_PICA
name|XJT_UNIT_PICA
init|=
literal|4
DECL|typedef|XJTUnitType
block|}
name|XJTUnitType
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c23167c0703
block|{
DECL|enumerator|XJT_NORMAL_MODE
name|XJT_NORMAL_MODE
init|=
literal|0
block|,
DECL|enumerator|XJT_DISSOLVE_MODE
name|XJT_DISSOLVE_MODE
init|=
literal|1
block|,
DECL|enumerator|XJT_BEHIND_MODE
name|XJT_BEHIND_MODE
init|=
literal|2
block|,
DECL|enumerator|XJT_MULTIPLY_MODE
name|XJT_MULTIPLY_MODE
init|=
literal|3
block|,
DECL|enumerator|XJT_SCREEN_MODE
name|XJT_SCREEN_MODE
init|=
literal|4
block|,
DECL|enumerator|XJT_OVERLAY_MODE
name|XJT_OVERLAY_MODE
init|=
literal|5
block|,
DECL|enumerator|XJT_DIFFERENCE_MODE
name|XJT_DIFFERENCE_MODE
init|=
literal|6
block|,
DECL|enumerator|XJT_ADDITION_MODE
name|XJT_ADDITION_MODE
init|=
literal|7
block|,
DECL|enumerator|XJT_SUBTRACT_MODE
name|XJT_SUBTRACT_MODE
init|=
literal|8
block|,
DECL|enumerator|XJT_DARKEN_ONLY_MODE
name|XJT_DARKEN_ONLY_MODE
init|=
literal|9
block|,
DECL|enumerator|XJT_LIGHTEN_ONLY_MODE
name|XJT_LIGHTEN_ONLY_MODE
init|=
literal|10
block|,
DECL|enumerator|XJT_HUE_MODE
name|XJT_HUE_MODE
init|=
literal|11
block|,
DECL|enumerator|XJT_SATURATION_MODE
name|XJT_SATURATION_MODE
init|=
literal|12
block|,
DECL|enumerator|XJT_COLOR_MODE
name|XJT_COLOR_MODE
init|=
literal|13
block|,
DECL|enumerator|XJT_VALUE_MODE
name|XJT_VALUE_MODE
init|=
literal|14
block|,
DECL|enumerator|XJT_DIVIDE_MODE
name|XJT_DIVIDE_MODE
init|=
literal|15
block|,
DECL|enumerator|XJT_DODGE_MODE
name|XJT_DODGE_MODE
init|=
literal|16
block|,
DECL|enumerator|XJT_BURN_MODE
name|XJT_BURN_MODE
init|=
literal|17
block|,
DECL|enumerator|XJT_HARDLIGHT_MODE
name|XJT_HARDLIGHT_MODE
init|=
literal|18
block|,
DECL|enumerator|XJT_SOFTLIGHT_MODE
name|XJT_SOFTLIGHT_MODE
init|=
literal|19
block|,
DECL|enumerator|XJT_GRAIN_EXTRACT_MODE
name|XJT_GRAIN_EXTRACT_MODE
init|=
literal|20
block|,
DECL|enumerator|XJT_GRAIN_MERGE_MODE
name|XJT_GRAIN_MERGE_MODE
init|=
literal|21
block|,
DECL|enumerator|XJT_COLOR_ERASE_MODE
name|XJT_COLOR_ERASE_MODE
init|=
literal|22
DECL|typedef|XJTLayerModeEffects
block|}
name|XJTLayerModeEffects
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0808
block|{
DECL|member|prop_id
name|t_proptype
name|prop_id
decl_stmt|;
DECL|member|prop_mnemonic
name|gchar
modifier|*
name|prop_mnemonic
decl_stmt|;
DECL|member|param_typ
name|t_param_typ
name|param_typ
decl_stmt|;
DECL|member|default_val1
name|gdouble
name|default_val1
decl_stmt|;
DECL|member|default_val2
name|gdouble
name|default_val2
decl_stmt|;
DECL|member|default_val3
name|gdouble
name|default_val3
decl_stmt|;
DECL|typedef|t_prop_table
block|}
name|t_prop_table
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0908
block|{
DECL|member|int_val1
name|gint32
name|int_val1
decl_stmt|;
DECL|member|int_val2
name|gint32
name|int_val2
decl_stmt|;
DECL|member|int_val3
name|gint32
name|int_val3
decl_stmt|;
DECL|member|flt_val1
name|gdouble
name|flt_val1
decl_stmt|;
DECL|member|flt_val2
name|gdouble
name|flt_val2
decl_stmt|;
DECL|member|flt_val3
name|gdouble
name|flt_val3
decl_stmt|;
DECL|member|num_fvals
name|gint32
name|num_fvals
decl_stmt|;
DECL|member|flt_val_list
name|gdouble
modifier|*
name|flt_val_list
decl_stmt|;
DECL|member|string_val
name|gchar
modifier|*
name|string_val
decl_stmt|;
DECL|typedef|t_param_prop
block|}
name|t_param_prop
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0a08
block|{
DECL|member|parasite_type
name|t_parasitetype
name|parasite_type
decl_stmt|;
DECL|member|parasite_id
name|gint32
name|parasite_id
decl_stmt|;
DECL|member|flags
name|gint32
name|flags
decl_stmt|;
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|obj_pos
name|gint32
name|obj_pos
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_parasite_props
block|}
name|t_parasite_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0b08
block|{
DECL|member|path_type
name|gint32
name|path_type
decl_stmt|;
DECL|member|path_locked
name|gint32
name|path_locked
decl_stmt|;
DECL|member|path_closed
name|gint32
name|path_closed
decl_stmt|;
DECL|member|current_flag
name|gint32
name|current_flag
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|num_points
name|gint32
name|num_points
decl_stmt|;
DECL|member|path_points
name|gdouble
modifier|*
name|path_points
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_path_props
block|}
name|t_path_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0c08
block|{
DECL|member|active_channel
name|gint
name|active_channel
decl_stmt|;
DECL|member|selection
name|gint
name|selection
decl_stmt|;
DECL|member|floating_attached
name|gint
name|floating_attached
decl_stmt|;
DECL|member|opacity
name|gdouble
name|opacity
decl_stmt|;
DECL|member|visible
name|gint
name|visible
decl_stmt|;
DECL|member|show_masked
name|gint
name|show_masked
decl_stmt|;
DECL|member|color_r
name|guchar
name|color_r
decl_stmt|;
DECL|member|color_g
name|guchar
name|color_g
decl_stmt|;
DECL|member|color_b
name|guchar
name|color_b
decl_stmt|;
DECL|member|offx
name|gint32
name|offx
decl_stmt|;
comment|/* do channels have offset ?? */
DECL|member|offy
name|gint32
name|offy
decl_stmt|;
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|channel_pos
name|gint
name|channel_pos
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_channel_props
block|}
name|t_channel_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0d08
block|{
DECL|member|active_layer
name|gint
name|active_layer
decl_stmt|;
DECL|member|floating_selection
name|gint
name|floating_selection
decl_stmt|;
DECL|member|floating_attached
name|gint
name|floating_attached
decl_stmt|;
DECL|member|opacity
name|gdouble
name|opacity
decl_stmt|;
DECL|member|mode
name|gint32
name|mode
decl_stmt|;
DECL|member|visible
name|gint
name|visible
decl_stmt|;
DECL|member|linked
name|gint
name|linked
decl_stmt|;
DECL|member|lock_alpha
name|gint
name|lock_alpha
decl_stmt|;
DECL|member|apply_mask
name|gint
name|apply_mask
decl_stmt|;
DECL|member|edit_mask
name|gint
name|edit_mask
decl_stmt|;
DECL|member|show_mask
name|gint
name|show_mask
decl_stmt|;
DECL|member|offx
name|gint32
name|offx
decl_stmt|;
DECL|member|offy
name|gint32
name|offy
decl_stmt|;
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|layer_pos
name|gint
name|layer_pos
decl_stmt|;
DECL|member|has_alpha
name|gint
name|has_alpha
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_layer_props
block|}
name|t_layer_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0e08
block|{
DECL|member|position
name|gint32
name|position
decl_stmt|;
DECL|member|orientation
name|gint8
name|orientation
decl_stmt|;
DECL|member|next
name|void
modifier|*
name|next
decl_stmt|;
DECL|typedef|t_guide_props
block|}
name|t_guide_props
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c23167c0f08
block|{
DECL|member|version
name|gchar
modifier|*
name|version
decl_stmt|;
DECL|member|gimp_major_version
name|gint
name|gimp_major_version
decl_stmt|;
DECL|member|gimp_minor_version
name|gint
name|gimp_minor_version
decl_stmt|;
DECL|member|gimp_micro_version
name|gint
name|gimp_micro_version
decl_stmt|;
DECL|member|image_type
name|GimpImageBaseType
name|image_type
decl_stmt|;
DECL|member|image_width
name|gint
name|image_width
decl_stmt|;
DECL|member|image_height
name|gint
name|image_height
decl_stmt|;
DECL|member|xresolution
name|gfloat
name|xresolution
decl_stmt|;
DECL|member|yresolution
name|gfloat
name|yresolution
decl_stmt|;
DECL|member|unit
name|GimpUnit
name|unit
decl_stmt|;
DECL|member|tattoo
name|gint32
name|tattoo
decl_stmt|;
DECL|member|tattoo_state
name|gint32
name|tattoo_state
decl_stmt|;
DECL|member|n_layers
name|gint
name|n_layers
decl_stmt|;
DECL|member|n_channels
name|gint
name|n_channels
decl_stmt|;
DECL|member|layer_props
name|t_layer_props
modifier|*
name|layer_props
decl_stmt|;
DECL|member|channel_props
name|t_channel_props
modifier|*
name|channel_props
decl_stmt|;
DECL|member|mask_props
name|t_channel_props
modifier|*
name|mask_props
decl_stmt|;
DECL|member|guide_props
name|t_guide_props
modifier|*
name|guide_props
decl_stmt|;
DECL|member|parasite_props
name|t_parasite_props
modifier|*
name|parasite_props
decl_stmt|;
DECL|member|path_props
name|t_path_props
modifier|*
name|path_props
decl_stmt|;
DECL|typedef|t_image_props
block|}
name|t_image_props
typedef|;
end_typedef

begin_define
DECL|macro|PROP_TABLE_ENTRIES
define|#
directive|define
name|PROP_TABLE_ENTRIES
value|35
end_define

begin_decl_stmt
DECL|variable|g_prop_table
specifier|static
name|t_prop_table
name|g_prop_table
index|[
name|PROP_TABLE_ENTRIES
index|]
init|=
block|{
comment|/* t_proptype              mnemonic   t_paramtyp             default values */
block|{
name|PROP_END
block|,
literal|"*"
block|,
name|PTYP_NOT_SUPPORTED
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_COLORMAP
block|,
literal|"*"
block|,
name|PTYP_NOT_SUPPORTED
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_ACTIVE_LAYER
block|,
literal|"acl"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_ACTIVE_CHANNEL
block|,
literal|"acc"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_SELECTION
block|,
literal|"sel"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_FLOATING_SELECTION
block|,
literal|"fsl"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_OPACITY
block|,
literal|"op"
block|,
name|PTYP_FLT
block|,
literal|100.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_MODE
block|,
literal|"md"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_VISIBLE
block|,
literal|"iv"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_LINKED
block|,
literal|"ln"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_LOCK_ALPHA
block|,
literal|"pt"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_APPLY_MASK
block|,
literal|"aml"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_EDIT_MASK
block|,
literal|"eml"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_SHOW_MASK
block|,
literal|"sml"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_SHOW_MASKED
block|,
literal|"smc"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_OFFSETS
block|,
literal|"o"
block|,
name|PTYP_2xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_COLOR
block|,
literal|"c"
block|,
name|PTYP_3xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_COMPRESSION
block|,
literal|"*"
block|,
name|PTYP_NOT_SUPPORTED
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_GUIDES
block|,
literal|"g"
block|,
name|PTYP_2xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_RESOLUTION
block|,
literal|"res"
block|,
name|PTYP_2xFLT
block|,
literal|72.0
block|,
literal|72.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_UNIT
block|,
literal|"unt"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_TATTOO
block|,
literal|"tto"
block|,
name|PTYP_INT
block|,
operator|-
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_TATTOO_STATE
block|,
literal|"tts"
block|,
name|PTYP_INT
block|,
operator|-
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PARASITES
block|,
literal|"pte"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PATH_POINTS
block|,
literal|"php"
block|,
name|PTYP_FLIST
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PATH_TYPE
block|,
literal|"pht"
block|,
name|PTYP_INT
block|,
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PATH_CURRENT
block|,
literal|"pha"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PATH_LOCKED
block|,
literal|"phl"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_PARASITE_FLAGS
block|,
literal|"ptf"
block|,
name|PTYP_INT
block|,
literal|1.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_FLOATING_ATTACHED
block|,
literal|"fa"
block|,
name|PTYP_BOOLEAN
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_NAME
block|,
literal|"n"
block|,
name|PTYP_STRING
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_DIMENSION
block|,
literal|"w/h"
block|,
name|PTYP_2xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_TYPE
block|,
literal|"typ"
block|,
name|PTYP_INT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_GIMP_VERSION
block|,
literal|"gimp"
block|,
name|PTYP_3xINT
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|,
block|{
name|PROP_VERSION
block|,
literal|"ver"
block|,
name|PTYP_STRING
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_xjt_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_xjt_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|save_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
specifier|const
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc  */
name|NULL
block|,
comment|/* quit_proc  */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|jsvals
specifier|static
name|t_JpegSaveVals
name|jsvals
init|=
block|{
literal|0.75
block|,
comment|/*  quality  */
literal|0.0
block|,
comment|/*  smoothing  */
literal|1
block|,
comment|/*  optimize  */
literal|0
comment|/*  clr_transparent */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|gint
DECL|function|p_invert (gint value)
name|p_invert
parameter_list|(
name|gint
name|value
parameter_list|)
block|{
return|return
operator|(
name|value
operator|)
condition|?
name|FALSE
else|:
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
DECL|function|p_system (const gchar * cmd)
name|int
name|p_system
parameter_list|(
specifier|const
name|gchar
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_rc2
decl_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"CMD: %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
comment|/* Shift 8 Bits gets Retcode of the executed Program */
name|l_rc2
operator|=
name|l_rc
operator|>>
literal|8
expr_stmt|;
name|g_printerr
argument_list|(
literal|"ERROR system: %s\nreturncodes %d %d"
argument_list|,
name|cmd
argument_list|,
name|l_rc
argument_list|,
name|l_rc2
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name of the file to load"
block|}
block|,   }
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
specifier|const
name|GimpParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run-mode"
block|,
literal|"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Input image"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"is ignored"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw-filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"quality"
block|,
literal|"Quality of saved image (0<= quality<= 1)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"smoothing"
block|,
literal|"Smoothing factor for saved image (0<= smoothing<= 1)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"optimize"
block|,
literal|"Optimization of entropy encoding parameters"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"clr-transparent"
block|,
literal|"set all full-transparent pixels to 0"
block|}
block|,   }
decl_stmt|;
name|gimp_install_procedure
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"loads files of the jpeg-tar file format"
argument_list|,
literal|"loads files of the jpeg-tar file format"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"2000-Mar-07"
argument_list|,
name|N_
argument_list|(
literal|"GIMP compressed XJT image"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_args
argument_list|)
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|load_return_vals
argument_list|)
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
name|LOAD_PROC
argument_list|,
literal|"xjt,xjtgz,xjtbz2"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"saves files in the jpeg-tar file format"
argument_list|,
literal|"saves files in the jpeg-tar file format"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"2000-Mar-07"
argument_list|,
name|N_
argument_list|(
literal|"GIMP compressed XJT image"
argument_list|)
argument_list|,
literal|"RGB*, GRAY*"
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|save_args
argument_list|)
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
name|SAVE_PROC
argument_list|,
literal|"xjt,xjtgz,xjtbz2"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (const gchar * name,gint nparams,const GimpParam * param,gint * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|gint
name|nparams
parameter_list|,
specifier|const
name|GimpParam
modifier|*
name|param
parameter_list|,
name|gint
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunMode
name|run_mode
decl_stmt|;
name|GimpPDBStatusType
name|status
init|=
name|GIMP_PDB_SUCCESS
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|l_env
decl_stmt|;
name|GError
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|g_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|xjt_debug
operator|=
name|FALSE
expr_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|l_env
operator|=
name|getenv
argument_list|(
literal|"XJT_DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_env
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_env
operator|!=
literal|'n'
operator|)
operator|&&
operator|(
operator|*
name|l_env
operator|!=
literal|'N'
operator|)
condition|)
name|xjt_debug
operator|=
name|TRUE
expr_stmt|;
block|}
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|LOAD_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_xjt_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SAVE_PROC
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|GIMP_RUN_INTERACTIVE
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|jsvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
if|if
condition|(
operator|!
name|save_dialog
argument_list|()
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CANCEL
expr_stmt|;
block|}
break|break;
case|case
name|GIMP_RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|8
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
else|else
block|{
name|jsvals
operator|.
name|quality
operator|=
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|jsvals
operator|.
name|smoothing
operator|=
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_float
expr_stmt|;
name|jsvals
operator|.
name|optimize
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|jsvals
operator|.
name|clr_transparent
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|jsvals
operator|.
name|quality
operator|<
literal|0.0
operator|||
name|jsvals
operator|.
name|quality
operator|>
literal|1.0
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsvals
operator|.
name|smoothing
operator|<
literal|0.0
operator|||
name|jsvals
operator|.
name|smoothing
operator|>
literal|1.0
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GIMP_RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|jsvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
if|if
condition|(
name|save_xjt_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|/*  Store mvals data  */
name|gimp_set_data
argument_list|(
name|SAVE_PROC
argument_list|,
operator|&
name|jsvals
argument_list|,
sizeof|sizeof
argument_list|(
name|t_JpegSaveVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|GIMP_PDB_SUCCESS
operator|&&
name|error
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STRING
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|=
name|error
operator|->
name|message
expr_stmt|;
block|}
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------  * p_my_ascii_strtod  * ------------------------  * call  g_ascii_strtod  * with XJT private modification:  *  g_ascii_strtod accepts both "." and "," as radix character (decimalpoint)  *  for float numbers (at least for GERMAN LANG)  *  because XJT PRP files have comma (,) seperated lists of float numbers this cant be accepted here.  *  the private version substitutes a '\0' character for the next comma  *  before calling g_ascii_strtod, and puts back the comma after the call  */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|p_my_ascii_strtod (gchar * nptr,gchar ** endptr)
name|p_my_ascii_strtod
parameter_list|(
name|gchar
modifier|*
name|nptr
parameter_list|,
name|gchar
modifier|*
modifier|*
name|endptr
parameter_list|)
block|{
name|gint
name|ii
decl_stmt|;
name|gint
name|ic
decl_stmt|;
name|gdouble
name|l_rc
decl_stmt|;
comment|/* check for comma (is a terminating character for the NON locale float string)     */
name|ii
operator|=
literal|0
expr_stmt|;
name|ic
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|nptr
condition|)
block|{
if|if
condition|(
name|nptr
index|[
name|ii
index|]
operator|==
literal|','
condition|)
block|{
name|ic
operator|=
name|ii
expr_stmt|;
name|nptr
index|[
name|ii
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* temporary use 0 as terminator for the call of g_ascii_strtod */
break|break;
block|}
if|if
condition|(
operator|(
name|nptr
index|[
name|ii
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|nptr
index|[
name|ii
index|]
operator|==
literal|' '
operator|)
operator|||
operator|(
name|nptr
index|[
name|ii
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
name|ii
operator|++
expr_stmt|;
block|}
name|l_rc
operator|=
name|g_ascii_strtod
argument_list|(
name|nptr
argument_list|,
name|endptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|>=
literal|0
condition|)
block|{
name|nptr
index|[
name|ii
index|]
operator|=
literal|','
expr_stmt|;
comment|/* restore the comma */
block|}
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_my_ascii_strtod */
end_comment

begin_comment
comment|/* -- type transformer routines XJT -- GIMP internal enums ----------------- */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|p_to_GimpOrientation (gint32 orientation)
name|p_to_GimpOrientation
parameter_list|(
name|gint32
name|orientation
parameter_list|)
block|{
return|return
operator|(
name|orientation
operator|==
name|XJT_ORIENTATION_VERTICAL
operator|)
condition|?
name|GIMP_ORIENTATION_VERTICAL
else|:
name|GIMP_ORIENTATION_HORIZONTAL
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|p_to_XJTOrientation (gint32 orientation)
name|p_to_XJTOrientation
parameter_list|(
name|gint32
name|orientation
parameter_list|)
block|{
return|return
operator|(
name|orientation
operator|==
name|GIMP_ORIENTATION_VERTICAL
operator|)
condition|?
name|XJT_ORIENTATION_VERTICAL
else|:
name|XJT_ORIENTATION_HORIZONTAL
return|;
block|}
end_function

begin_function
specifier|static
name|GimpLayerModeEffects
DECL|function|p_to_GimpLayerModeEffects (XJTLayerModeEffects intype)
name|p_to_GimpLayerModeEffects
parameter_list|(
name|XJTLayerModeEffects
name|intype
parameter_list|)
block|{
switch|switch
condition|(
name|intype
condition|)
block|{
case|case
name|XJT_NORMAL_MODE
case|:
return|return
name|GIMP_NORMAL_MODE
return|;
case|case
name|XJT_DISSOLVE_MODE
case|:
return|return
name|GIMP_DISSOLVE_MODE
return|;
case|case
name|XJT_BEHIND_MODE
case|:
return|return
name|GIMP_BEHIND_MODE
return|;
case|case
name|XJT_MULTIPLY_MODE
case|:
return|return
name|GIMP_MULTIPLY_MODE
return|;
case|case
name|XJT_SCREEN_MODE
case|:
return|return
name|GIMP_SCREEN_MODE
return|;
case|case
name|XJT_OVERLAY_MODE
case|:
return|return
name|GIMP_OVERLAY_MODE
return|;
case|case
name|XJT_DIFFERENCE_MODE
case|:
return|return
name|GIMP_DIFFERENCE_MODE
return|;
case|case
name|XJT_ADDITION_MODE
case|:
return|return
name|GIMP_ADDITION_MODE
return|;
case|case
name|XJT_SUBTRACT_MODE
case|:
return|return
name|GIMP_SUBTRACT_MODE
return|;
case|case
name|XJT_DARKEN_ONLY_MODE
case|:
return|return
name|GIMP_DARKEN_ONLY_MODE
return|;
case|case
name|XJT_LIGHTEN_ONLY_MODE
case|:
return|return
name|GIMP_LIGHTEN_ONLY_MODE
return|;
case|case
name|XJT_HUE_MODE
case|:
return|return
name|GIMP_HUE_MODE
return|;
case|case
name|XJT_SATURATION_MODE
case|:
return|return
name|GIMP_SATURATION_MODE
return|;
case|case
name|XJT_COLOR_MODE
case|:
return|return
name|GIMP_COLOR_MODE
return|;
case|case
name|XJT_VALUE_MODE
case|:
return|return
name|GIMP_VALUE_MODE
return|;
case|case
name|XJT_DIVIDE_MODE
case|:
return|return
name|GIMP_DIVIDE_MODE
return|;
case|case
name|XJT_DODGE_MODE
case|:
return|return
name|GIMP_DODGE_MODE
return|;
case|case
name|XJT_BURN_MODE
case|:
return|return
name|GIMP_BURN_MODE
return|;
case|case
name|XJT_HARDLIGHT_MODE
case|:
return|return
name|GIMP_HARDLIGHT_MODE
return|;
case|case
name|XJT_SOFTLIGHT_MODE
case|:
return|return
name|GIMP_SOFTLIGHT_MODE
return|;
case|case
name|XJT_GRAIN_EXTRACT_MODE
case|:
return|return
name|GIMP_GRAIN_EXTRACT_MODE
return|;
case|case
name|XJT_GRAIN_MERGE_MODE
case|:
return|return
name|GIMP_GRAIN_MERGE_MODE
return|;
case|case
name|XJT_COLOR_ERASE_MODE
case|:
return|return
name|GIMP_COLOR_ERASE_MODE
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"XJT file contains unknown layermode %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gint32
operator|)
name|intype
operator|>
operator|(
name|gint32
operator|)
name|XJT_DIVIDE_MODE
condition|)
block|{
return|return
operator|(
name|GimpLayerModeEffects
operator|)
name|intype
return|;
block|}
return|return
name|GIMP_NORMAL_MODE
return|;
block|}
end_function

begin_function
specifier|static
name|XJTLayerModeEffects
DECL|function|p_to_XJTLayerModeEffects (GimpLayerModeEffects intype)
name|p_to_XJTLayerModeEffects
parameter_list|(
name|GimpLayerModeEffects
name|intype
parameter_list|)
block|{
switch|switch
condition|(
name|intype
condition|)
block|{
case|case
name|GIMP_NORMAL_MODE
case|:
return|return
name|XJT_NORMAL_MODE
return|;
case|case
name|GIMP_DISSOLVE_MODE
case|:
return|return
name|XJT_DISSOLVE_MODE
return|;
case|case
name|GIMP_BEHIND_MODE
case|:
return|return
name|XJT_BEHIND_MODE
return|;
case|case
name|GIMP_MULTIPLY_MODE
case|:
return|return
name|XJT_MULTIPLY_MODE
return|;
case|case
name|GIMP_SCREEN_MODE
case|:
return|return
name|XJT_SCREEN_MODE
return|;
case|case
name|GIMP_OVERLAY_MODE
case|:
return|return
name|XJT_OVERLAY_MODE
return|;
case|case
name|GIMP_DIFFERENCE_MODE
case|:
return|return
name|XJT_DIFFERENCE_MODE
return|;
case|case
name|GIMP_ADDITION_MODE
case|:
return|return
name|XJT_ADDITION_MODE
return|;
case|case
name|GIMP_SUBTRACT_MODE
case|:
return|return
name|XJT_SUBTRACT_MODE
return|;
case|case
name|GIMP_DARKEN_ONLY_MODE
case|:
return|return
name|XJT_DARKEN_ONLY_MODE
return|;
case|case
name|GIMP_LIGHTEN_ONLY_MODE
case|:
return|return
name|XJT_LIGHTEN_ONLY_MODE
return|;
case|case
name|GIMP_HUE_MODE
case|:
return|return
name|XJT_HUE_MODE
return|;
case|case
name|GIMP_SATURATION_MODE
case|:
return|return
name|XJT_SATURATION_MODE
return|;
case|case
name|GIMP_COLOR_MODE
case|:
return|return
name|XJT_COLOR_MODE
return|;
case|case
name|GIMP_VALUE_MODE
case|:
return|return
name|XJT_VALUE_MODE
return|;
case|case
name|GIMP_DIVIDE_MODE
case|:
return|return
name|XJT_DIVIDE_MODE
return|;
case|case
name|GIMP_DODGE_MODE
case|:
return|return
name|XJT_DODGE_MODE
return|;
case|case
name|GIMP_BURN_MODE
case|:
return|return
name|XJT_BURN_MODE
return|;
case|case
name|GIMP_HARDLIGHT_MODE
case|:
return|return
name|XJT_HARDLIGHT_MODE
return|;
case|case
name|GIMP_SOFTLIGHT_MODE
case|:
return|return
name|XJT_SOFTLIGHT_MODE
return|;
case|case
name|GIMP_GRAIN_EXTRACT_MODE
case|:
return|return
name|XJT_GRAIN_EXTRACT_MODE
return|;
case|case
name|GIMP_GRAIN_MERGE_MODE
case|:
return|return
name|XJT_GRAIN_MERGE_MODE
return|;
case|case
name|GIMP_COLOR_ERASE_MODE
case|:
return|return
name|XJT_COLOR_ERASE_MODE
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Warning: unsupported layermode %d saved to XJT"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gint32
operator|)
name|intype
operator|>
operator|(
name|gint32
operator|)
name|XJT_DIVIDE_MODE
condition|)
block|{
return|return
operator|(
name|XJTLayerModeEffects
operator|)
name|intype
return|;
block|}
return|return
name|XJT_NORMAL_MODE
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|p_to_GimpPathType (XJTPathType intype)
name|p_to_GimpPathType
parameter_list|(
name|XJTPathType
name|intype
parameter_list|)
block|{
switch|switch
condition|(
name|intype
condition|)
block|{
case|case
name|XJT_PATHTYPE_UNDEF
case|:
return|return
literal|0
return|;
case|case
name|XJT_PATHTYPE_BEZIER
case|:
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"XJT file contains unknown pathtype %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gint32
operator|)
name|intype
operator|>
operator|(
name|gint32
operator|)
name|XJT_PATHTYPE_BEZIER
condition|)
block|{
return|return
operator|(
name|gint32
operator|)
name|intype
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|XJTPathType
DECL|function|p_to_XJTPathType (gint32 intype)
name|p_to_XJTPathType
parameter_list|(
name|gint32
name|intype
parameter_list|)
block|{
switch|switch
condition|(
name|intype
condition|)
block|{
case|case
literal|0
case|:
return|return
name|XJT_PATHTYPE_UNDEF
return|;
case|case
literal|1
case|:
return|return
name|XJT_PATHTYPE_BEZIER
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Warning: unsupported pathtype %d saved to XJT"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gint32
operator|)
name|intype
operator|>
operator|(
name|gint32
operator|)
name|XJT_PATHTYPE_BEZIER
condition|)
block|{
return|return
operator|(
operator|(
name|XJTPathType
operator|)
name|intype
operator|)
return|;
block|}
return|return
operator|(
name|XJT_PATHTYPE_UNDEF
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GimpUnit
DECL|function|p_to_GimpUnit (XJTUnitType intype)
name|p_to_GimpUnit
parameter_list|(
name|XJTUnitType
name|intype
parameter_list|)
block|{
switch|switch
condition|(
name|intype
condition|)
block|{
case|case
name|XJT_UNIT_PIXEL
case|:
return|return
operator|(
name|GIMP_UNIT_PIXEL
operator|)
return|;
case|case
name|XJT_UNIT_INCH
case|:
return|return
operator|(
name|GIMP_UNIT_INCH
operator|)
return|;
case|case
name|XJT_UNIT_MM
case|:
return|return
operator|(
name|GIMP_UNIT_MM
operator|)
return|;
case|case
name|XJT_UNIT_POINT
case|:
return|return
operator|(
name|GIMP_UNIT_POINT
operator|)
return|;
case|case
name|XJT_UNIT_PICA
case|:
return|return
operator|(
name|GIMP_UNIT_PICA
operator|)
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"XJT file contains unknown unittype %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gint32
operator|)
name|intype
operator|>
operator|(
name|gint32
operator|)
name|XJT_UNIT_PICA
condition|)
block|{
return|return
operator|(
operator|(
name|GimpUnit
operator|)
name|intype
operator|)
return|;
block|}
return|return
operator|(
name|GIMP_UNIT_PIXEL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|XJTUnitType
DECL|function|p_to_XJTUnitType (GimpUnit intype)
name|p_to_XJTUnitType
parameter_list|(
name|GimpUnit
name|intype
parameter_list|)
block|{
switch|switch
condition|(
name|intype
condition|)
block|{
case|case
name|GIMP_UNIT_PIXEL
case|:
return|return
operator|(
name|XJT_UNIT_PIXEL
operator|)
return|;
case|case
name|GIMP_UNIT_INCH
case|:
return|return
operator|(
name|XJT_UNIT_INCH
operator|)
return|;
case|case
name|GIMP_UNIT_MM
case|:
return|return
operator|(
name|XJT_UNIT_MM
operator|)
return|;
case|case
name|GIMP_UNIT_POINT
case|:
return|return
operator|(
name|XJT_UNIT_POINT
operator|)
return|;
case|case
name|GIMP_UNIT_PICA
case|:
return|return
operator|(
name|XJT_UNIT_PICA
operator|)
return|;
case|case
name|GIMP_UNIT_END
case|:
break|break;
case|case
name|GIMP_UNIT_PERCENT
case|:
break|break;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Warning: unsupported unittype %d saved to XJT"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gint32
operator|)
name|intype
operator|>
operator|(
name|gint32
operator|)
name|XJT_UNIT_PICA
condition|)
block|{
return|return
operator|(
operator|(
name|XJTUnitType
operator|)
name|intype
operator|)
return|;
block|}
return|return
operator|(
name|XJT_UNIT_PIXEL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------- SAVE DIALOG procedures  -------------------------- */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|save_dialog (void)
name|save_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|table
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkObject
modifier|*
name|scale_data
decl_stmt|;
name|gboolean
name|run
decl_stmt|;
name|gimp_ui_init
argument_list|(
name|PLUG_IN_BINARY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gimp_export_dialog_new
argument_list|(
name|_
argument_list|(
literal|"XJT"
argument_list|)
argument_list|,
name|PLUG_IN_BINARY
argument_list|,
literal|"file-xjt-save"
argument_list|)
expr_stmt|;
name|table
operator|=
name|gtk_table_new
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_table_set_col_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_table_set_row_spacings
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|gtk_container_set_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|table
argument_list|)
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|gimp_export_dialog_get_content_area
argument_list|(
name|dlg
argument_list|)
argument_list|)
argument_list|,
name|table
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"Optimize"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|jsvals
operator|.
name|optimize
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|jsvals
operator|.
name|optimize
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
name|_
argument_list|(
literal|"Clear transparent"
argument_list|)
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|jsvals
operator|.
name|clr_transparent
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
name|toggle
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|toggle
argument_list|,
literal|"toggled"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_toggle_button_update
argument_list|)
argument_list|,
operator|&
name|jsvals
operator|.
name|clr_transparent
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"Quality:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|jsvals
operator|.
name|quality
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|0.11
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|jsvals
operator|.
name|quality
argument_list|)
expr_stmt|;
name|scale_data
operator|=
name|gimp_scale_entry_new
argument_list|(
name|GTK_TABLE
argument_list|(
name|table
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|_
argument_list|(
literal|"Smoothing:"
argument_list|)
argument_list|,
name|SCALE_WIDTH
argument_list|,
literal|0
argument_list|,
name|jsvals
operator|.
name|smoothing
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|0.1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_signal_connect
argument_list|(
name|scale_data
argument_list|,
literal|"value-changed"
argument_list|,
name|G_CALLBACK
argument_list|(
name|gimp_double_adjustment_update
argument_list|)
argument_list|,
operator|&
name|jsvals
operator|.
name|smoothing
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|gimp_dialog_run
argument_list|(
name|GIMP_DIALOG
argument_list|(
name|dlg
argument_list|)
argument_list|)
operator|==
name|GTK_RESPONSE_OK
operator|)
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
return|return
name|run
return|;
block|}
end_function

begin_comment
comment|/* ---------------------- SAVE WORKER procedures  -------------------------- */
end_comment

begin_comment
comment|/* ============================================================================  * p_get_property_index  *   get index in g_prop_table by proptype (id)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_get_property_index (t_proptype proptype)
name|p_get_property_index
parameter_list|(
name|t_proptype
name|proptype
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|PROP_TABLE_ENTRIES
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|prop_id
operator|==
name|proptype
condition|)
block|{
return|return
name|l_idx
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* index of PROP_END -- not supported */
block|}
end_function

begin_comment
comment|/* end p_get_property_index */
end_comment

begin_comment
comment|/* ============================================================================  * p_float_to_str  *   create string from float.  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_float_to_str (gdouble flt_val)
name|p_float_to_str
parameter_list|(
name|gdouble
name|flt_val
parameter_list|)
block|{
name|gchar
name|l_dbl_str
index|[
name|G_ASCII_DTOSTR_BUF_SIZE
index|]
decl_stmt|;
name|gchar
modifier|*
name|l_str
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
comment|/* XJT float precision is limited to 5 digits */
comment|/* print setlocale independent float string */
name|g_ascii_formatd
argument_list|(
operator|&
name|l_dbl_str
index|[
literal|0
index|]
argument_list|,
name|G_ASCII_DTOSTR_BUF_SIZE
argument_list|,
literal|"%.5f"
argument_list|,
name|flt_val
argument_list|)
expr_stmt|;
name|l_str
operator|=
name|g_strdup
argument_list|(
name|l_dbl_str
argument_list|)
expr_stmt|;
comment|/* delete trailing '0' and '.' characters */
name|l_idx
operator|=
name|strlen
argument_list|(
name|l_str
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l_idx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l_str
index|[
name|l_idx
index|]
operator|!=
literal|'0'
condition|)
block|{
break|break;
block|}
name|l_str
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
name|l_idx
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|l_str
index|[
name|l_idx
index|]
operator|==
literal|'.'
condition|)
block|{
name|l_str
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|l_str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_namedup  *   copy name and make sure that double quote backslash and newline  *   characters are escaped by a backslash  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_namedup (const gchar * name)
name|p_namedup
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|l_str
decl_stmt|;
name|gchar
modifier|*
name|l_name
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|gint
name|l_len
decl_stmt|;
name|l_str
operator|=
name|name
expr_stmt|;
name|l_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|l_str
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_str
operator|==
literal|'\"'
operator|)
operator|||
operator|(
operator|*
name|l_str
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_str
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|l_len
operator|++
expr_stmt|;
block|}
name|l_str
operator|++
expr_stmt|;
name|l_len
operator|++
expr_stmt|;
block|}
name|l_name
operator|=
name|g_malloc
argument_list|(
name|l_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|l_str
operator|=
name|name
expr_stmt|;
name|l_ptr
operator|=
name|l_name
expr_stmt|;
while|while
condition|(
operator|*
name|l_str
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_str
operator|==
literal|'\"'
operator|)
operator|||
operator|(
operator|*
name|l_str
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_str
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|l_ptr
operator|=
literal|'\\'
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l_str
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|l_ptr
operator|=
literal|'n'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|l_ptr
operator|=
operator|*
name|l_str
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|l_ptr
operator|=
operator|*
name|l_str
expr_stmt|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|l_str
operator|++
expr_stmt|;
block|}
operator|*
name|l_ptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|l_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_write_prop_string  *   allocate buffer and  *   write out the property mnemonic to buffer  *   and parameter(s) according to the property type  *  *   wr_all_prp is used for debug only and causes to write out all properties  *   Normally (wr_all_prp == FALSE) properties are NOT written, if they are  *   equal to their default value.  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_write_prop_string (t_proptype proptype,t_param_prop * param,gint wr_all_prp)
name|p_write_prop_string
parameter_list|(
name|t_proptype
name|proptype
parameter_list|,
name|t_param_prop
modifier|*
name|param
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|int
name|l_prop_idx
decl_stmt|;
name|int
name|l_idp
decl_stmt|;
name|gchar
modifier|*
name|l_f1
decl_stmt|;
name|gchar
modifier|*
name|l_f2
decl_stmt|;
name|gchar
modifier|*
name|l_f3
decl_stmt|;
name|gchar
modifier|*
name|l_str
decl_stmt|;
name|gchar
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|l_prop_idx
operator|=
name|p_get_property_index
argument_list|(
name|proptype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|param_typ
condition|)
block|{
case|case
name|PTYP_BOOLEAN
case|:
comment|/* boolean properties are written if they are not FALSE */
if|if
condition|(
name|param
operator|->
name|int_val1
condition|)
block|{
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wr_all_prp
condition|)
block|{
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s!"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PTYP_INT
case|:
comment|/* int properties are written if they are not equal to default */
if|if
condition|(
operator|(
name|param
operator|->
name|int_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%d"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_FLT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|flt_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|l_f1
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val1
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|l_f1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_2xFLT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|flt_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|flt_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|l_f1
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val1
argument_list|)
expr_stmt|;
name|l_f2
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val2
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%s,%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|l_f1
argument_list|,
name|l_f2
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_3xFLT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|flt_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|flt_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|param
operator|->
name|flt_val3
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val3
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|l_f1
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val1
argument_list|)
expr_stmt|;
name|l_f2
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val2
argument_list|)
expr_stmt|;
name|l_f3
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val3
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%s,%s,%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|l_f1
argument_list|,
name|l_f2
argument_list|,
name|l_f3
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f2
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_FLIST
case|:
if|if
condition|(
name|param
operator|->
name|num_fvals
operator|>
literal|0
condition|)
block|{
name|l_f1
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%s"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|l_f1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_f1
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idp
operator|=
literal|1
init|;
name|l_idp
operator|<
name|param
operator|->
name|num_fvals
condition|;
name|l_idp
operator|++
control|)
block|{
name|l_f1
operator|=
name|p_float_to_str
argument_list|(
name|param
operator|->
name|flt_val_list
index|[
name|l_idp
index|]
argument_list|)
expr_stmt|;
name|l_str
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s,%s"
argument_list|,
name|buffer
argument_list|,
name|l_f1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|l_str
expr_stmt|;
name|g_free
argument_list|(
name|l_f1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PTYP_STRING
case|:
if|if
condition|(
name|param
operator|->
name|string_val
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|param
operator|->
name|string_val
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|l_str
operator|=
name|p_namedup
argument_list|(
name|param
operator|->
name|string_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_str
condition|)
block|{
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:\"%s\""
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
name|l_str
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PTYP_2xINT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|int_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|int_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%d,%d"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTYP_3xINT
case|:
if|if
condition|(
operator|(
name|param
operator|->
name|int_val1
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val1
operator|)
operator|||
operator|(
name|param
operator|->
name|int_val2
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val2
operator|)
operator|||
operator|(
name|param
operator|->
name|int_val3
operator|!=
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|default_val3
operator|)
operator|||
operator|(
name|wr_all_prp
operator|)
condition|)
block|{
name|buffer
operator|=
name|g_strdup_printf
argument_list|(
literal|" %s:%d,%d,%d"
argument_list|,
name|g_prop_table
index|[
name|l_prop_idx
index|]
operator|.
name|prop_mnemonic
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val2
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val3
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/*  PTYP_NOT_SUPPORTED */
break|break;
block|}
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|buffer
operator|=
name|g_strdup
argument_list|(
literal|"\0"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_write_prop_string */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_prop  *   write out the property mnemonic to file  *   and parameter(s) according to the property type  *  *   wr_all_prp is used for debug only and causes to write out all properties  *   Normally (wr_all_prp == FALSE) properties are NOT written, if they are  *   equal to their default value.  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_prop (FILE * fp,t_proptype proptype,t_param_prop * param,gint wr_all_prp)
name|p_write_prop
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|t_proptype
name|proptype
parameter_list|,
name|t_param_prop
modifier|*
name|param
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|gchar
modifier|*
name|l_buff
decl_stmt|;
name|l_buff
operator|=
name|p_write_prop_string
argument_list|(
name|proptype
argument_list|,
name|param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_buff
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|l_buff
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_parasite  *   write out one parasite by  *    - write property to PRP file  *    - write parasite data to parasite_file  *    - and prepare global_parasite_prop_lines  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_write_parasite (const gchar * dirname,FILE * fp,GimpParasite * parasite,gint wr_all_prp)
name|p_write_parasite
parameter_list|(
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|GimpParasite
modifier|*
name|parasite
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|gchar
modifier|*
name|l_new_parasite_prop_lines
decl_stmt|;
name|gchar
modifier|*
name|l_parasite_buff
decl_stmt|;
name|gchar
modifier|*
name|l_parasite_file
decl_stmt|;
name|gchar
modifier|*
name|l_buff
decl_stmt|;
name|gchar
modifier|*
name|l_buff2
decl_stmt|;
name|FILE
modifier|*
name|l_fp_pte
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
if|if
condition|(
name|parasite
operator|->
name|flags
operator|&
name|GIMP_PARASITE_PERSISTENT
condition|)
comment|/* check if GimpParasite should be saved */
block|{
name|global_parasite_id
operator|++
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|global_parasite_id
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_PARASITES
argument_list|,
operator|&
name|l_param
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add parasite line like this:       *     p2 n:"layer parasite A" ptf:1       * to global_parasite_prop_lines buffer.       * (the buffer is written as last block to the PRP file)       */
name|l_param
operator|.
name|string_val
operator|=
name|parasite
operator|->
name|name
expr_stmt|;
name|l_buff
operator|=
name|p_write_prop_string
argument_list|(
name|PROP_NAME
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|parasite
operator|->
name|flags
expr_stmt|;
name|l_buff2
operator|=
name|p_write_prop_string
argument_list|(
name|PROP_PARASITE_FLAGS
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_parasite_buff
operator|=
name|g_strdup_printf
argument_list|(
literal|"p%d%s%s\n"
argument_list|,
operator|(
name|int
operator|)
name|global_parasite_id
argument_list|,
name|l_buff
argument_list|,
name|l_buff2
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_buff
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_buff2
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_parasite_prop_lines
operator|==
name|NULL
condition|)
block|{
name|global_parasite_prop_lines
operator|=
name|g_strdup
argument_list|(
name|l_parasite_buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_new_parasite_prop_lines
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s"
argument_list|,
name|global_parasite_prop_lines
argument_list|,
name|l_parasite_buff
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|global_parasite_prop_lines
argument_list|)
expr_stmt|;
name|global_parasite_prop_lines
operator|=
name|l_new_parasite_prop_lines
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_parasite_buff
argument_list|)
expr_stmt|;
comment|/* write the parasite data to a file named p1.pte */
name|l_parasite_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cp%d.pte"
argument_list|,
name|dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
operator|(
name|int
operator|)
name|global_parasite_id
argument_list|)
expr_stmt|;
name|l_fp_pte
operator|=
name|g_fopen
argument_list|(
name|l_parasite_file
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp_pte
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|l_parasite_file
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_parasite_file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|fwrite
argument_list|(
name|parasite
operator|->
name|data
argument_list|,
name|parasite
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|l_fp_pte
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp_pte
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_parasite_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_write_image_paths (FILE * fp,gint32 image_id,gint wr_all_prp)
name|p_write_image_paths
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|gint32
name|l_idx
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|l_path_names
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|l_current_pathname
init|=
name|NULL
decl_stmt|;
name|gint32
name|l_num_paths
init|=
literal|0
decl_stmt|;
name|gdouble
modifier|*
name|l_path_points
decl_stmt|;
name|gint32
name|l_path_type
decl_stmt|;
name|gint32
name|l_path_closed
decl_stmt|;
name|gint32
name|l_num_points
init|=
literal|0
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|l_path_names
operator|=
name|gimp_path_list
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_num_paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_path_names
operator|==
name|NULL
condition|)
return|return;
name|l_current_pathname
operator|=
name|gimp_path_get_current
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_num_paths
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"p_write_image_paths NAME:%s:\n"
argument_list|,
name|l_path_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
name|l_path_type
operator|=
name|gimp_path_get_points
argument_list|(
name|image_id
argument_list|,
name|l_path_names
index|[
name|l_idx
index|]
argument_list|,
operator|&
name|l_path_closed
argument_list|,
operator|&
name|l_num_points
argument_list|,
operator|&
name|l_path_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_path_points
condition|)
block|{
comment|/* write PATH line identifier */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PATH"
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_to_XJTPathType
argument_list|(
name|l_path_type
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_PATH_TYPE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_path_get_tattoo
argument_list|(
name|image_id
argument_list|,
name|l_path_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TATTOO
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_path_get_locked
argument_list|(
name|image_id
argument_list|,
name|l_path_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_PATH_LOCKED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
name|l_path_names
index|[
name|l_idx
index|]
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_NAME
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* current path flag */
name|l_param
operator|.
name|int_val1
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|l_current_pathname
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|l_current_pathname
argument_list|,
name|l_path_names
index|[
name|l_idx
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l_param
operator|.
name|int_val1
operator|=
name|TRUE
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_PATH_CURRENT
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
block|}
block|}
name|l_param
operator|.
name|num_fvals
operator|=
name|l_num_points
expr_stmt|;
name|l_param
operator|.
name|flt_val_list
operator|=
name|l_path_points
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_PATH_POINTS
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_path_points
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_current_pathname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_path_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_write_image_parasites (const gchar * dirname,FILE * fp,gint32 image_id,gint wr_all_prp)
name|p_write_image_parasites
parameter_list|(
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|l_parasite
decl_stmt|;
name|gint32
name|l_idx
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|l_parasite_names
init|=
name|NULL
decl_stmt|;
name|gint32
name|l_num_parasites
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|gimp_image_parasite_list
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_num_parasites
argument_list|,
operator|&
name|l_parasite_names
argument_list|)
condition|)
return|return;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_num_parasites
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_parasite
operator|=
name|gimp_image_parasite_find
argument_list|(
name|image_id
argument_list|,
name|l_parasite_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_parasite
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"p_write_image_parasites NAME:%s:\n"
argument_list|,
name|l_parasite_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
name|p_write_parasite
argument_list|(
name|dirname
argument_list|,
name|fp
argument_list|,
name|l_parasite
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_parasite_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_write_drawable_parasites (const gchar * dirname,FILE * fp,gint32 drawable_id,gint wr_all_prp)
name|p_write_drawable_parasites
parameter_list|(
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|gint32
name|drawable_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|GimpParasite
modifier|*
name|l_parasite
decl_stmt|;
name|gint32
name|l_idx
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|l_parasite_names
init|=
name|NULL
decl_stmt|;
name|gint32
name|l_num_parasites
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|gimp_drawable_parasite_list
argument_list|(
name|drawable_id
argument_list|,
operator|&
name|l_num_parasites
argument_list|,
operator|&
name|l_parasite_names
argument_list|)
condition|)
return|return;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_num_parasites
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_parasite
operator|=
name|gimp_drawable_parasite_find
argument_list|(
name|drawable_id
argument_list|,
name|l_parasite_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_parasite
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"p_write_drawable_parasites NAME:%s:\n"
argument_list|,
name|l_parasite_names
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
name|p_write_parasite
argument_list|(
name|dirname
argument_list|,
name|fp
argument_list|,
name|l_parasite
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_parasite_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_write_layer_prp  *   write out all properties of the given layer  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_layer_prp (const gchar * dirname,FILE * fp,const gchar * layer_shortname,gint32 image_id,gint32 layer_id,gint wr_all_prp)
name|p_write_layer_prp
parameter_list|(
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|gchar
modifier|*
name|layer_shortname
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|layer_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|t_param_prop
name|l_param
decl_stmt|;
name|gint
name|l_ofsx
decl_stmt|,
name|l_ofsy
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|layer_shortname
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|layer_id
operator|==
name|gimp_image_get_active_layer
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_ACTIVE_LAYER
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_is_floating_sel
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_FLOATING_SELECTION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* check if floating selection is attached to this layer */
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|layer_id
operator|==
name|gimp_image_floating_sel_attached_to
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_FLOATING_ATTACHED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|flt_val1
operator|=
name|gimp_layer_get_opacity
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OPACITY
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|gint32
operator|)
name|p_to_XJTLayerModeEffects
argument_list|(
name|gimp_layer_get_mode
argument_list|(
name|layer_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_MODE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_invert
argument_list|(
name|gimp_drawable_get_visible
argument_list|(
name|layer_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_VISIBLE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_drawable_get_linked
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_LINKED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_lock_alpha
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_LOCK_ALPHA
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_apply_mask
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_APPLY_MASK
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_edit_mask
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_EDIT_MASK
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_layer_get_show_mask
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_SHOW_MASK
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layer_id
argument_list|,
operator|&
name|l_ofsx
argument_list|,
operator|&
name|l_ofsy
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_ofsx
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_ofsy
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OFFSETS
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_drawable_get_tattoo
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TATTOO
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
name|gimp_drawable_get_name
argument_list|(
name|layer_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_NAME
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|p_write_drawable_parasites
argument_list|(
name|dirname
argument_list|,
name|fp
argument_list|,
name|layer_id
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_layer_prp */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_channel_prp  *   write out all properties of the given channel  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_channel_prp (const gchar * dirname,FILE * fp,const gchar * channel_shortname,gint32 image_id,gint32 channel_id,gint wr_all_prp)
name|p_write_channel_prp
parameter_list|(
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|gchar
modifier|*
name|channel_shortname
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|channel_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|t_param_prop
name|l_param
decl_stmt|;
name|gint
name|l_ofsx
decl_stmt|,
name|l_ofsy
decl_stmt|;
name|GimpRGB
name|color
decl_stmt|;
name|guchar
name|l_r
decl_stmt|,
name|l_g
decl_stmt|,
name|l_b
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|channel_shortname
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|channel_id
operator|==
name|gimp_image_get_active_channel
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_ACTIVE_CHANNEL
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|channel_id
operator|==
name|gimp_image_get_selection
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
comment|/* TRUE/FALSE */
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_SELECTION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* check if floating selection is attached to this channel */
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|channel_id
operator|==
name|gimp_image_floating_sel_attached_to
argument_list|(
name|image_id
argument_list|)
operator|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_FLOATING_ATTACHED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|flt_val1
operator|=
name|gimp_channel_get_opacity
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OPACITY
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|p_invert
argument_list|(
name|gimp_drawable_get_visible
argument_list|(
name|channel_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_VISIBLE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_channel_get_show_masked
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_SHOW_MASKED
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_channel_get_color
argument_list|(
name|channel_id
argument_list|,
operator|&
name|color
argument_list|)
expr_stmt|;
name|gimp_rgb_get_uchar
argument_list|(
operator|&
name|color
argument_list|,
operator|&
name|l_r
argument_list|,
operator|&
name|l_g
argument_list|,
operator|&
name|l_b
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_r
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_g
expr_stmt|;
name|l_param
operator|.
name|int_val3
operator|=
name|l_b
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_COLOR
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|channel_id
argument_list|,
operator|&
name|l_ofsx
argument_list|,
operator|&
name|l_ofsy
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_ofsx
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_ofsy
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_OFFSETS
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_drawable_get_tattoo
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TATTOO
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
name|gimp_drawable_get_name
argument_list|(
name|channel_id
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_NAME
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|p_write_drawable_parasites
argument_list|(
name|dirname
argument_list|,
name|fp
argument_list|,
name|channel_id
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_channel_prp */
end_comment

begin_comment
comment|/* ============================================================================  * p_write_image_prp  *   write out the properties of the image  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_write_image_prp (const gchar * dirname,FILE * fp,gint32 image_id,gint wr_all_prp)
name|p_write_image_prp
parameter_list|(
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint
name|wr_all_prp
parameter_list|)
block|{
name|GimpImageBaseType
name|l_image_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|gdouble
name|l_xresolution
decl_stmt|,
name|l_yresolution
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|gint32
name|l_guide_id
decl_stmt|;
comment|/* get info about the image */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_image_type
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|GIMP_XJ_IMAGE
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|string_val
operator|=
literal|"1.3.11"
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_VERSION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|GIMP_MAJOR_VERSION
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|GIMP_MINOR_VERSION
expr_stmt|;
name|l_param
operator|.
name|int_val3
operator|=
name|GIMP_MICRO_VERSION
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_GIMP_VERSION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val1
operator|=
name|l_width
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|l_height
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_DIMENSION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|gimp_image_get_resolution
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_xresolution
argument_list|,
operator|&
name|l_yresolution
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|flt_val1
operator|=
name|l_xresolution
expr_stmt|;
name|l_param
operator|.
name|flt_val2
operator|=
name|l_yresolution
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_RESOLUTION
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* write unit */
name|l_param
operator|.
name|int_val1
operator|=
name|p_to_XJTUnitType
argument_list|(
name|gimp_image_get_unit
argument_list|(
name|image_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_UNIT
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* write tattoo_state */
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_image_get_tattoo_state
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_param
operator|.
name|int_val1
operator|>
literal|0
condition|)
block|{
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TATTOO_STATE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
block|}
comment|/* write guides */
name|l_guide_id
operator|=
name|gimp_image_find_next_guide
argument_list|(
name|image_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get 1.st guide */
while|while
condition|(
name|l_guide_id
operator|>
literal|0
condition|)
block|{
comment|/* get position and orientation for the current guide ID */
name|l_param
operator|.
name|int_val1
operator|=
name|gimp_image_get_guide_position
argument_list|(
name|image_id
argument_list|,
name|l_guide_id
argument_list|)
expr_stmt|;
name|l_param
operator|.
name|int_val2
operator|=
name|p_to_XJTOrientation
argument_list|(
name|gimp_image_get_guide_orientation
argument_list|(
name|image_id
argument_list|,
name|l_guide_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_GUIDES
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
comment|/* findnext returns 0 if no (more) guides there       * (or -1 if no PDB interface is available)       */
name|l_guide_id
operator|=
name|gimp_image_find_next_guide
argument_list|(
name|image_id
argument_list|,
name|l_guide_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_image_type
operator|==
name|GIMP_GRAY
condition|)
block|{
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|gint32
operator|)
name|XJT_GRAY
expr_stmt|;
block|}
else|else
block|{
name|l_param
operator|.
name|int_val1
operator|=
operator|(
name|gint32
operator|)
name|XJT_RGB
expr_stmt|;
block|}
name|p_write_prop
argument_list|(
name|fp
argument_list|,
name|PROP_TYPE
argument_list|,
operator|&
name|l_param
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|p_write_image_parasites
argument_list|(
name|dirname
argument_list|,
name|fp
argument_list|,
name|image_id
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|p_write_image_paths
argument_list|(
name|fp
argument_list|,
name|image_id
argument_list|,
name|wr_all_prp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_write_image_prp */
end_comment

begin_comment
comment|/* ---------------------- SAVE  -------------------------- */
end_comment

begin_function
specifier|static
name|gint
DECL|function|save_xjt_image (const gchar * filename,gint32 image_id,gint32 drawable_id,GError ** error)
name|save_xjt_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|drawable_id
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_len
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|gchar
modifier|*
name|l_dirname
decl_stmt|;
name|gchar
modifier|*
name|l_prop_file
decl_stmt|;
name|gchar
modifier|*
name|l_jpg_file
decl_stmt|;
name|gchar
modifier|*
name|l_cmd
decl_stmt|;
name|FILE
modifier|*
name|l_fp_prp
decl_stmt|;
name|GimpImageBaseType
name|l_image_type
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
modifier|*
name|l_channels_list
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint
name|l_nchannels
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_channel_id
decl_stmt|;
name|gint32
name|l_selection_channel_id
decl_stmt|;
name|int
name|l_sel
decl_stmt|;
name|gint32
name|l_x1
decl_stmt|,
name|l_x2
decl_stmt|,
name|l_y1
decl_stmt|,
name|l_y2
decl_stmt|;
name|gboolean
name|non_empty
decl_stmt|;
name|gint
name|l_wr_all_prp
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init retcode to Errorstate */
name|l_fp_prp
operator|=
name|NULL
expr_stmt|;
name|l_layers_list
operator|=
name|NULL
expr_stmt|;
name|l_channels_list
operator|=
name|NULL
expr_stmt|;
name|l_dirname
operator|=
name|NULL
expr_stmt|;
name|l_prop_file
operator|=
name|NULL
expr_stmt|;
name|l_jpg_file
operator|=
name|NULL
expr_stmt|;
name|l_wr_all_prp
operator|=
name|FALSE
expr_stmt|;
comment|/* FALSE write only non-default properties                               * TRUE  write all properties (should be used for DEBUG only)                               */
name|global_parasite_id
operator|=
literal|0
expr_stmt|;
name|global_parasite_prop_lines
operator|=
name|NULL
expr_stmt|;
comment|/* get info about the image */
name|l_image_type
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_image_type
condition|)
block|{
case|case
name|GIMP_RGB
case|:
case|case
name|GIMP_GRAY
case|:
break|break;
case|case
name|GIMP_INDEXED
case|:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot operate on indexed color images."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
default|default:
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Cannot operate on unknown image types."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Saving '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create temporary directory */
name|l_dirname
operator|=
name|gimp_temp_name
argument_list|(
literal|".tmpdir"
argument_list|)
expr_stmt|;
name|l_prop_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cPRP"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mkdir
argument_list|(
name|l_dirname
argument_list|,
literal|0777
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not create working folder '%s': %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|l_dirname
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* create property file PRP */
name|l_fp_prp
operator|=
name|g_fopen
argument_list|(
name|l_prop_file
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp_prp
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|l_prop_file
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* write image properties */
name|p_write_image_prp
argument_list|(
name|l_dirname
argument_list|,
name|l_fp_prp
argument_list|,
name|image_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
comment|/* foreach layer do */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_nlayers
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_layer_id
operator|=
name|l_layers_list
index|[
name|l_idx
index|]
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"Layer [%d] id=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|)
expr_stmt|;
comment|/* save layer as jpeg file */
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cl%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving layer to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|JSVM_DRAWABLE
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
comment|/* write out the layer properties */
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|l_layer_id
argument_list|)
condition|)
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"L%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"l%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
block|}
name|p_write_layer_prp
argument_list|(
name|l_dirname
argument_list|,
name|l_fp_prp
argument_list|,
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
comment|/* check, and save alpha channel */
if|if
condition|(
name|gimp_drawable_has_alpha
argument_list|(
name|l_layer_id
argument_list|)
condition|)
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cla%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving alpha-channel to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|JSVM_ALPHA
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
block|}
comment|/* check and save layer_mask channel */
name|l_channel_id
operator|=
name|gimp_layer_get_mask
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_id
operator|>=
literal|0
condition|)
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%clm%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving layer-mask to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|JSVM_DRAWABLE
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
comment|/* write out the layer_mask (== channel) properties */
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"m%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
name|p_write_channel_prp
argument_list|(
name|l_dirname
argument_list|,
name|l_fp_prp
argument_list|,
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end foreach layer */
comment|/* check and see if we have to save out the selection */
name|l_sel
operator|=
literal|0
expr_stmt|;
name|l_selection_channel_id
operator|=
name|gimp_image_get_selection
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gimp_selection_bounds
argument_list|(
name|image_id
argument_list|,
operator|&
name|non_empty
argument_list|,
operator|&
name|l_x1
argument_list|,
operator|&
name|l_y1
argument_list|,
operator|&
name|l_x2
argument_list|,
operator|&
name|l_y2
argument_list|)
operator|)
operator|&&
operator|(
name|l_selection_channel_id
operator|>=
literal|0
operator|)
condition|)
block|{
name|l_sel
operator|=
literal|1
expr_stmt|;
block|}
name|l_channels_list
operator|=
name|gimp_image_get_channels
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_nchannels
argument_list|)
expr_stmt|;
comment|/* foreach channel do */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_nchannels
operator|+
name|l_sel
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|l_idx
operator|<
name|l_nchannels
condition|)
name|l_channel_id
operator|=
name|l_channels_list
index|[
name|l_idx
index|]
expr_stmt|;
else|else
name|l_channel_id
operator|=
name|l_selection_channel_id
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"channel [%d] id=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|int
operator|)
name|l_channel_id
argument_list|)
expr_stmt|;
comment|/* save channel as jpeg file */
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cc%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: saving channel to file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|!=
name|xjpg_save_drawable
argument_list|(
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|JSVM_DRAWABLE
argument_list|,
operator|&
name|jsvals
argument_list|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
comment|/* write out the channel properties */
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"c%d"
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
name|p_write_channel_prp
argument_list|(
name|l_dirname
argument_list|,
name|l_fp_prp
argument_list|,
name|l_jpg_file
argument_list|,
name|image_id
argument_list|,
name|l_channel_id
argument_list|,
name|l_wr_all_prp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
block|}
comment|/* end foreach channel */
if|if
condition|(
name|global_parasite_prop_lines
operator|!=
name|NULL
condition|)
block|{
comment|/* have to add parasite lines at end of PRP file */
name|fprintf
argument_list|(
name|l_fp_prp
argument_list|,
literal|"%s"
argument_list|,
name|global_parasite_prop_lines
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|l_fp_prp
argument_list|)
expr_stmt|;
name|l_fp_prp
operator|=
name|NULL
expr_stmt|;
comment|/* store properties and  all layers and cannels in a     * tar archive with filename.tar     */
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"cd %s; tar -cf \"%s\" *; cd .."
argument_list|,
name|l_dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_len
operator|>
literal|3
operator|)
operator|&&
operator|(
name|l_rc
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* call optional extracompression programs gzip or bzip2       * (depends on filename's extension)       *       * used gzip options: (bzip2 uses the same options)       *     -c --stdout --to-stdout       *          Write  output  on  standard  output       *     -f --force       *           Force compression or decompression even if the file       */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|3
index|]
argument_list|,
literal|"bz2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"bzip2 -cf \"%s\">\"%s.tmp_bz2\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"mv \"%s.tmp_bz2\" \"%s\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|2
index|]
argument_list|,
literal|"gz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"gzip -cf<\"%s\">\"%s.tmp_gz\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"mv \"%s.tmp_gz\" \"%s\""
argument_list|,
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|l_fp_prp
condition|)
block|{
name|fclose
argument_list|(
name|l_fp_prp
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_channels_list
argument_list|)
expr_stmt|;
comment|/* remove the temorary directory */
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"rm -rf \"%s\""
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xjt_debug
condition|)
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_dirname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_prop_file
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* ---------------------- LOAD WORKER procedures  -------------------------- */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_layer_prop  *   allocate new layer_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_layer_props
modifier|*
DECL|function|p_new_layer_prop (void)
name|p_new_layer_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|t_layer_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_layer_props
argument_list|)
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|active_layer
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_ACTIVE_LAYER
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|floating_selection
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_FLOATING_SELECTION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_FLOATING_ATTACHED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|opacity
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OPACITY
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|mode
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_MODE
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_VISIBLE
argument_list|)
index|]
operator|.
name|default_val1
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|linked
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_LINKED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|lock_alpha
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_LOCK_ALPHA
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|apply_mask
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_APPLY_MASK
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|edit_mask
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_EDIT_MASK
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|show_mask
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_SHOW_MASK
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offx
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|layer_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|l_new_prop
operator|->
name|has_alpha
operator|=
name|FALSE
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|l_new_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_new_layer_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_channel_prop  *   allocate new channel_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_channel_props
modifier|*
DECL|function|p_new_channel_prop (void)
name|p_new_channel_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|t_channel_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_channel_props
argument_list|)
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|active_channel
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_ACTIVE_CHANNEL
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|selection
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_SELECTION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_FLOATING_ATTACHED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|opacity
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OPACITY
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_VISIBLE
argument_list|)
index|]
operator|.
name|default_val1
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|show_masked
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_SHOW_MASKED
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offx
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_OFFSETS
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|color_r
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_COLOR
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|color_g
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_COLOR
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|color_b
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_COLOR
argument_list|)
index|]
operator|.
name|default_val3
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|channel_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|l_new_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_new_channel_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_guide_prop  *   allocate new guide_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_guide_props
modifier|*
DECL|function|p_new_guide_prop (void)
name|p_new_guide_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|t_guide_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_guide_props
argument_list|)
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|position
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|orientation
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|l_new_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_new_guide_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_parasite_prop  *   allocate new parasite_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_parasite_props
modifier|*
DECL|function|p_new_parasite_prop (void)
name|p_new_parasite_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|t_parasite_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_parasite_props
argument_list|)
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|parasite_type
operator|=
name|XJT_IMAGE_PARASITE
expr_stmt|;
name|l_new_prop
operator|->
name|parasite_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_new_prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|obj_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|l_new_prop
operator|->
name|flags
operator|=
name|GIMP_PARASITE_PERSISTENT
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|l_new_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_new_parasite_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_path_prop  *   allocate new parasite_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_path_props
modifier|*
DECL|function|p_new_path_prop (void)
name|p_new_path_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|t_path_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_path_props
argument_list|)
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|path_type
operator|=
name|p_to_GimpPathType
argument_list|(
name|XJT_PATHTYPE_BEZIER
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|path_locked
operator|=
name|FALSE
expr_stmt|;
name|l_new_prop
operator|->
name|path_closed
operator|=
name|FALSE
expr_stmt|;
name|l_new_prop
operator|->
name|current_flag
operator|=
name|FALSE
expr_stmt|;
name|l_new_prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|path_points
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|l_new_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_new_path_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_new_image_prop  *   allocate new layer_properties element and init with default values  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_image_props
modifier|*
DECL|function|p_new_image_prop (void)
name|p_new_image_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|t_image_props
modifier|*
name|l_new_prop
decl_stmt|;
name|l_new_prop
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_image_props
argument_list|)
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|image_type
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TYPE
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|image_width
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_DIMENSION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|image_height
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_DIMENSION
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|xresolution
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_RESOLUTION
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|yresolution
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_RESOLUTION
argument_list|)
index|]
operator|.
name|default_val2
expr_stmt|;
name|l_new_prop
operator|->
name|unit
operator|=
name|p_to_GimpUnit
argument_list|(
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_UNIT
argument_list|)
index|]
operator|.
name|default_val1
argument_list|)
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|tattoo_state
operator|=
name|g_prop_table
index|[
name|p_get_property_index
argument_list|(
name|PROP_TATTOO_STATE
argument_list|)
index|]
operator|.
name|default_val1
expr_stmt|;
name|l_new_prop
operator|->
name|n_layers
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|n_channels
operator|=
literal|0
expr_stmt|;
name|l_new_prop
operator|->
name|layer_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|channel_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|mask_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|guide_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|parasite_props
operator|=
name|NULL
expr_stmt|;
name|l_new_prop
operator|->
name|path_props
operator|=
name|NULL
expr_stmt|;
return|return
name|l_new_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_new_image_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_skip_blanks  *  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_skip_blanks (gchar * scan_ptr)
name|p_skip_blanks
parameter_list|(
name|gchar
modifier|*
name|scan_ptr
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|scan_ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|scan_ptr
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|scan_ptr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|scan_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_scann_token  *   scan one token with its parameter(s)  *   return pointer to character behind the last scanned byte.  *  * Check prop_id for PROP_END             (no more tokens found)  *               for PROP_SYNTAX_ERROR    (illegal token/params detected)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_scann_token (gchar * scan_ptr,t_param_prop * param,t_proptype * prop_id)
name|p_scann_token
parameter_list|(
name|gchar
modifier|*
name|scan_ptr
parameter_list|,
name|t_param_prop
modifier|*
name|param
parameter_list|,
name|t_proptype
modifier|*
name|prop_id
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
name|int
name|l_ids
decl_stmt|;
name|int
name|l_max_line_len
decl_stmt|;
name|int
name|l_num_fvals
decl_stmt|;
name|gchar
modifier|*
name|l_token
decl_stmt|;
name|gchar
modifier|*
name|l_string_buff
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|gchar
modifier|*
name|l_ptr2
decl_stmt|;
comment|/* check for end of property line */
if|if
condition|(
operator|(
operator|*
name|scan_ptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|scan_ptr
operator|==
literal|'\n'
operator|)
condition|)
block|{
operator|*
name|prop_id
operator|=
name|PROP_END
expr_stmt|;
return|return
operator|(
name|scan_ptr
operator|)
return|;
block|}
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
name|l_max_line_len
operator|=
name|strlen
argument_list|(
name|scan_ptr
argument_list|)
expr_stmt|;
name|l_token
operator|=
name|g_malloc
argument_list|(
name|l_max_line_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* extract current token at scann_ptr position */
name|l_ptr
operator|=
name|scan_ptr
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
operator|(
name|l_max_line_len
operator|-
literal|1
operator|)
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|':'
operator|)
condition|)
block|{
break|break;
block|}
name|l_token
index|[
name|l_idx
index|]
operator|=
operator|(
operator|*
name|l_ptr
operator|)
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
name|l_token
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT:TOKEN:%s:"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
comment|/* check if token is one of the supported mnemonics */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|PROP_TABLE_ENTRIES
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|==
name|PTYP_NOT_SUPPORTED
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
literal|0
operator|!=
name|strcmp
argument_list|(
name|l_token
argument_list|,
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|prop_mnemonic
argument_list|)
condition|)
block|{
continue|continue;
block|}
operator|*
name|prop_id
operator|=
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|prop_id
expr_stmt|;
comment|/* scann parameters according to detected property type */
switch|switch
condition|(
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
condition|)
block|{
case|case
name|PTYP_BOOLEAN
case|:
name|param
operator|->
name|int_val1
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|':'
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (bool property %s terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'!'
condition|)
comment|/* inverter character */
block|{
name|param
operator|->
name|int_val1
operator|=
name|FALSE
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTYP_3xINT
case|:
case|case
name|PTYP_2xINT
case|:
case|case
name|PTYP_INT
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (int property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
else|else
block|{
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|int_val1
operator|=
name|strtol
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Scan 1.st integer (base = 10) */
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (int property %s :integer value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PTYP_2xINT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
operator|||
operator|(
name|PTYP_3xINT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (int property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|int_val2
operator|=
name|strtol
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan 2.nd integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (int property %s : 2.nd integer value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTYP_3xINT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (int property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|int_val3
operator|=
name|strtol
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan 3.rd integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (int property %s : 3.rd integer value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
operator|(
name|int
operator|)
name|param
operator|->
name|int_val3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PTYP_3xFLT
case|:
case|case
name|PTYP_2xFLT
case|:
case|case
name|PTYP_FLT
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (float property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
else|else
block|{
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|flt_val1
operator|=
name|p_my_ascii_strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (float property %s :float value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%f"
argument_list|,
name|param
operator|->
name|flt_val1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PTYP_2xFLT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
operator|||
operator|(
name|PTYP_3xFLT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (float property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|flt_val2
operator|=
name|p_my_ascii_strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (float property %s : 2.nd float value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%f"
argument_list|,
name|param
operator|->
name|flt_val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTYP_3xFLT
operator|==
name|g_prop_table
index|[
name|l_idx
index|]
operator|.
name|param_typ
condition|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (float property %s comma missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|flt_val3
operator|=
name|p_my_ascii_strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (float property %s : 3.rd float value missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|",%f"
argument_list|,
name|param
operator|->
name|flt_val3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PTYP_FLIST
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (floatlist property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
else|else
block|{
name|l_ptr
operator|++
expr_stmt|;
comment|/* counting ',' to guess how much values are in the list */
name|l_num_fvals
operator|=
literal|1
expr_stmt|;
name|l_ptr2
operator|=
name|l_ptr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr2
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|l_ptr2
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|l_ptr2
operator|==
literal|','
condition|)
block|{
name|l_num_fvals
operator|++
expr_stmt|;
block|}
name|l_ptr2
operator|++
expr_stmt|;
block|}
name|param
operator|->
name|num_fvals
operator|=
literal|0
expr_stmt|;
name|param
operator|->
name|flt_val_list
operator|=
name|g_malloc0
argument_list|(
sizeof|sizeof
argument_list|(
name|gdouble
argument_list|)
operator|*
name|l_num_fvals
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|param
operator|->
name|flt_val_list
index|[
name|param
operator|->
name|num_fvals
index|]
operator|=
name|p_my_ascii_strtod
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_ptr2
condition|)
block|{
if|if
condition|(
name|param
operator|->
name|num_fvals
operator|==
literal|0
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (floatlist property %s :no float value found)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
break|break;
block|}
name|l_ptr
operator|=
name|l_ptr2
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%f char:%c\n"
argument_list|,
name|param
operator|->
name|flt_val_list
index|[
name|param
operator|->
name|num_fvals
index|]
argument_list|,
operator|*
name|l_ptr
argument_list|)
expr_stmt|;
name|param
operator|->
name|num_fvals
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr2
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|l_ptr2
operator|!=
literal|'\n'
operator|)
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (floatlist property %s :list contains illegal character: %c)\n"
argument_list|,
name|l_token
argument_list|,
operator|*
name|l_ptr
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
break|break;
block|}
name|l_ptr
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PTYP_STRING
case|:
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|':'
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (string property %s not terminated with :)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|!=
literal|'\"'
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (string property %s starting \" is missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
name|l_ptr
operator|++
expr_stmt|;
name|l_string_buff
operator|=
name|g_malloc
argument_list|(
name|l_max_line_len
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|l_ids
operator|=
literal|0
init|;
name|l_ids
operator|<
operator|(
name|l_max_line_len
operator|-
literal|2
operator|)
condition|;
name|l_ids
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|l_ptr
index|[
literal|1
index|]
operator|==
literal|'\"'
condition|)
block|{
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
literal|'\"'
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|l_ptr
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
block|{
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
literal|'\n'
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|l_ptr
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
literal|'\\'
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
continue|continue;
block|}
name|l_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|'\"'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
operator|*
name|l_ptr
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
name|l_string_buff
index|[
name|l_ids
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\"'
condition|)
block|{
name|l_ptr
operator|++
expr_stmt|;
name|param
operator|->
name|string_val
operator|=
name|g_strdup
argument_list|(
name|l_string_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|param
operator|->
name|string_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP syntax error (string property %s terminating \" is missing)\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_string_buff
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_printerr
argument_list|(
literal|"XJT: ** Warning ** PRP file with unsupported property %s\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
operator|*
name|prop_id
operator|=
name|PROP_SYNTAX_ERROR
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* advance l_ptr to next Blank    * (this is needed to skip unknown tokens    */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'\0'
operator|)
condition|)
block|{
break|break;
block|}
name|l_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|prop_id
operator|==
name|PROP_SYNTAX_ERROR
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: ** Warning ** PRP file skipping property: %s\n"
argument_list|,
name|l_token
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_token
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_scann_token */
end_comment

begin_comment
comment|/* ============================================================================  * p_find_parasite  *   if the parasite_props list has an item with parasite_id  *   return the pointer to the matching item,  *   else return NULL (no matching item found)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_parasite_props
modifier|*
DECL|function|p_find_parasite (t_parasite_props * parasite_props,gint32 parasite_id)
name|p_find_parasite
parameter_list|(
name|t_parasite_props
modifier|*
name|parasite_props
parameter_list|,
name|gint32
name|parasite_id
parameter_list|)
block|{
name|t_parasite_props
modifier|*
name|l_prop
decl_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT: p_find_parasite search parasite_id (1): %d\n"
argument_list|,
operator|(
name|int
operator|)
name|parasite_id
argument_list|)
expr_stmt|;
name|l_prop
operator|=
name|parasite_props
expr_stmt|;
while|while
condition|(
name|l_prop
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT: p_find_parasite (2) listid=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_prop
operator|->
name|parasite_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_prop
operator|->
name|parasite_id
operator|==
name|parasite_id
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT: p_find_parasite (3) listid=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_prop
operator|->
name|parasite_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_prop
operator|)
return|;
block|}
name|l_prop
operator|=
operator|(
name|t_parasite_props
operator|*
operator|)
name|l_prop
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT: p_find_parasite (4) NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_create_and_attach_parasite  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_create_and_attach_parasite (gint32 gimp_obj_id,const gchar * dirname,t_parasite_props * parasite_props)
name|p_create_and_attach_parasite
parameter_list|(
name|gint32
name|gimp_obj_id
parameter_list|,
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|t_parasite_props
modifier|*
name|parasite_props
parameter_list|)
block|{
name|gchar
modifier|*
name|l_parasite_file
decl_stmt|;
name|GimpParasite
name|l_parasite
decl_stmt|;
name|struct
name|stat
name|l_stat_buf
decl_stmt|;
name|FILE
modifier|*
name|l_fp_pte
decl_stmt|;
comment|/* create filename dirname/p1.pte  1 == parasite_id */
name|l_parasite_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cp%d.pte"
argument_list|,
name|dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
operator|(
name|int
operator|)
name|parasite_props
operator|->
name|parasite_id
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|g_stat
argument_list|(
name|l_parasite_file
argument_list|,
operator|&
name|l_stat_buf
argument_list|)
condition|)
block|{
comment|/* stat error (file does not exist) */
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|l_parasite_file
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|l_fp_pte
operator|=
name|g_fopen
argument_list|(
name|l_parasite_file
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp_pte
operator|==
name|NULL
condition|)
block|{
name|g_message
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for reading: %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|l_parasite_file
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|g_free
argument_list|(
name|l_parasite_file
argument_list|)
expr_stmt|;
name|l_parasite
operator|.
name|size
operator|=
name|l_stat_buf
operator|.
name|st_size
expr_stmt|;
name|l_parasite
operator|.
name|data
operator|=
name|g_malloc
argument_list|(
name|l_parasite
operator|.
name|size
argument_list|)
expr_stmt|;
name|l_parasite
operator|.
name|flags
operator|=
name|parasite_props
operator|->
name|flags
operator||
name|GIMP_PARASITE_PERSISTENT
expr_stmt|;
if|if
condition|(
name|parasite_props
operator|->
name|name
condition|)
block|{
name|l_parasite
operator|.
name|name
operator|=
name|g_strdup
argument_list|(
name|parasite_props
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_parasite
operator|.
name|name
operator|=
name|g_strdup
argument_list|(
literal|"\0"
argument_list|)
expr_stmt|;
block|}
comment|/* read the parasitedata from file */
name|fread
argument_list|(
name|l_parasite
operator|.
name|data
argument_list|,
name|l_parasite
operator|.
name|size
argument_list|,
literal|1
argument_list|,
name|l_fp_pte
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp_pte
argument_list|)
expr_stmt|;
comment|/* attach the parasite to gimp_obj_id    * (is an Image or drawable id depending on parasite_type)    */
if|if
condition|(
name|parasite_props
operator|->
name|parasite_type
operator|==
name|XJT_IMAGE_PARASITE
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT:   gimp_image_parasite_attach  name:%s\n"
argument_list|,
name|l_parasite
operator|.
name|name
argument_list|)
expr_stmt|;
name|gimp_image_parasite_attach
argument_list|(
name|gimp_obj_id
argument_list|,
operator|&
name|l_parasite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT:   gimp_drawable_parasite_attach  name:%s\n"
argument_list|,
name|l_parasite
operator|.
name|name
argument_list|)
expr_stmt|;
name|gimp_drawable_parasite_attach
argument_list|(
name|gimp_obj_id
argument_list|,
operator|&
name|l_parasite
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_parasite
operator|.
name|data
condition|)
name|g_free
argument_list|(
name|l_parasite
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_parasite
operator|.
name|name
condition|)
name|g_free
argument_list|(
name|l_parasite
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/*OK */
block|}
end_function

begin_comment
comment|/* end p_create_and_attach_parasite */
end_comment

begin_comment
comment|/* ============================================================================  * p_check_and_add_parasite  *   find parasite by type and pos (obj_pos)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_check_and_add_parasite (gint32 gimp_obj_id,const gchar * dirname,t_parasite_props * parasite_props,gint32 pos,t_parasitetype parasite_type)
name|p_check_and_add_parasite
parameter_list|(
name|gint32
name|gimp_obj_id
parameter_list|,
specifier|const
name|gchar
modifier|*
name|dirname
parameter_list|,
name|t_parasite_props
modifier|*
name|parasite_props
parameter_list|,
name|gint32
name|pos
parameter_list|,
name|t_parasitetype
name|parasite_type
parameter_list|)
block|{
name|t_parasite_props
modifier|*
name|l_prop
decl_stmt|;
name|l_prop
operator|=
name|parasite_props
expr_stmt|;
while|while
condition|(
name|l_prop
condition|)
block|{
if|if
condition|(
operator|(
name|l_prop
operator|->
name|parasite_type
operator|==
name|parasite_type
operator|)
operator|&&
operator|(
name|l_prop
operator|->
name|obj_pos
operator|==
name|pos
operator|)
condition|)
block|{
name|p_create_and_attach_parasite
argument_list|(
name|gimp_obj_id
argument_list|,
name|dirname
argument_list|,
name|l_prop
argument_list|)
expr_stmt|;
block|}
name|l_prop
operator|=
operator|(
name|t_parasite_props
operator|*
operator|)
name|l_prop
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end p_check_and_add_parasite */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_layer_prop  *   scann one inputline for layer properties (also used for layer_mask props)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_scann_layer_prop (gchar * scan_ptr,t_image_props * image_prop)
name|p_scann_layer_prop
parameter_list|(
name|gchar
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|t_layer_props
modifier|*
name|l_new_prop
decl_stmt|;
name|t_parasite_props
modifier|*
name|l_parasite_prop
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|l_new_prop
operator|=
name|p_new_layer_prop
argument_list|()
expr_stmt|;
comment|/* add the new element to the layer_props list */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|layer_props
expr_stmt|;
name|image_prop
operator|->
name|layer_props
operator|=
name|l_new_prop
expr_stmt|;
if|if
condition|(
operator|*
name|scan_ptr
operator|==
literal|'L'
condition|)
block|{
name|l_new_prop
operator|->
name|has_alpha
operator|=
name|TRUE
expr_stmt|;
block|}
name|l_new_prop
operator|->
name|layer_pos
operator|=
name|strtol
argument_list|(
operator|&
name|scan_ptr
index|[
literal|1
index|]
argument_list|,
operator|&
name|l_ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|scan_ptr
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP file layer# missing, scanned bad line:\n%s\n"
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_ACTIVE_LAYER
case|:
name|l_new_prop
operator|->
name|active_layer
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_SELECTION
case|:
name|l_new_prop
operator|->
name|floating_selection
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_ATTACHED
case|:
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|l_new_prop
operator|->
name|opacity
operator|=
name|l_param
operator|.
name|flt_val1
expr_stmt|;
break|break;
case|case
name|PROP_MODE
case|:
name|l_new_prop
operator|->
name|mode
operator|=
name|p_to_GimpLayerModeEffects
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_LINKED
case|:
name|l_new_prop
operator|->
name|linked
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_LOCK_ALPHA
case|:
name|l_new_prop
operator|->
name|lock_alpha
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_APPLY_MASK
case|:
name|l_new_prop
operator|->
name|apply_mask
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_EDIT_MASK
case|:
name|l_new_prop
operator|->
name|edit_mask
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASK
case|:
name|l_new_prop
operator|->
name|show_mask
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
name|l_new_prop
operator|->
name|offx
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
break|break;
case|case
name|PROP_NAME
case|:
name|l_new_prop
operator|->
name|name
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|l_new_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_PARASITES
case|:
name|l_parasite_prop
operator|=
name|p_find_parasite
argument_list|(
name|image_prop
operator|->
name|parasite_props
argument_list|,
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_parasite_prop
operator|==
name|NULL
condition|)
block|{
name|l_parasite_prop
operator|=
name|p_new_parasite_prop
argument_list|()
expr_stmt|;
name|l_parasite_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|parasite_props
expr_stmt|;
name|image_prop
operator|->
name|parasite_props
operator|=
name|l_parasite_prop
expr_stmt|;
block|}
if|if
condition|(
name|l_parasite_prop
condition|)
block|{
name|l_parasite_prop
operator|->
name|parasite_id
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_parasite_prop
operator|->
name|parasite_type
operator|=
name|XJT_LAYER_PARASITE
expr_stmt|;
name|l_parasite_prop
operator|->
name|obj_pos
operator|=
name|l_new_prop
operator|->
name|layer_pos
expr_stmt|;
block|}
break|break;
default|default :
comment|/* g_printerr ("XJT: PRP file scanned bad line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_layer_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_channel_prop  *   scann one inputline for channel properties (also used for layer_mask props)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_scann_channel_prop (const gchar * scan_ptr,t_image_props * image_prop)
name|p_scann_channel_prop
parameter_list|(
specifier|const
name|gchar
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|t_channel_props
modifier|*
name|l_new_prop
decl_stmt|;
name|t_parasite_props
modifier|*
name|l_parasite_prop
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|t_parasitetype
name|l_parasite_type
decl_stmt|;
name|l_new_prop
operator|=
name|p_new_channel_prop
argument_list|()
expr_stmt|;
name|l_new_prop
operator|->
name|channel_pos
operator|=
name|strtol
argument_list|(
operator|&
name|scan_ptr
index|[
literal|1
index|]
argument_list|,
operator|&
name|l_ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|scan_ptr
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP file channel# missing, scanned bad line:\n%s\n"
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check if it is layer_mask or channel */
if|if
condition|(
operator|*
name|scan_ptr
operator|==
literal|'m'
condition|)
block|{
comment|/* add the new element to the mask_props list of the image */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|mask_props
expr_stmt|;
name|image_prop
operator|->
name|mask_props
operator|=
name|l_new_prop
expr_stmt|;
name|l_parasite_type
operator|=
name|XJT_LAYER_MASK_PARASITE
expr_stmt|;
block|}
else|else
block|{
comment|/* add the new element to the channel_props list of the image */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|channel_props
expr_stmt|;
name|image_prop
operator|->
name|channel_props
operator|=
name|l_new_prop
expr_stmt|;
name|l_parasite_type
operator|=
name|XJT_CHANNEL_PARASITE
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_ACTIVE_CHANNEL
case|:
name|l_new_prop
operator|->
name|active_channel
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_SELECTION
case|:
name|l_new_prop
operator|->
name|selection
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_FLOATING_ATTACHED
case|:
name|l_new_prop
operator|->
name|floating_attached
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OPACITY
case|:
name|l_new_prop
operator|->
name|opacity
operator|=
name|l_param
operator|.
name|flt_val1
expr_stmt|;
break|break;
case|case
name|PROP_VISIBLE
case|:
name|l_new_prop
operator|->
name|visible
operator|=
name|p_invert
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_SHOW_MASKED
case|:
name|l_new_prop
operator|->
name|show_masked
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_OFFSETS
case|:
name|l_new_prop
operator|->
name|offx
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_new_prop
operator|->
name|offy
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
break|break;
case|case
name|PROP_COLOR
case|:
name|l_new_prop
operator|->
name|color_r
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_new_prop
operator|->
name|color_g
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
name|l_new_prop
operator|->
name|color_b
operator|=
name|l_param
operator|.
name|int_val3
expr_stmt|;
break|break;
case|case
name|PROP_NAME
case|:
name|l_new_prop
operator|->
name|name
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|l_new_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_PARASITES
case|:
name|l_parasite_prop
operator|=
name|p_find_parasite
argument_list|(
name|image_prop
operator|->
name|parasite_props
argument_list|,
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_parasite_prop
operator|==
name|NULL
condition|)
block|{
name|l_parasite_prop
operator|=
name|p_new_parasite_prop
argument_list|()
expr_stmt|;
name|l_parasite_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|parasite_props
expr_stmt|;
name|image_prop
operator|->
name|parasite_props
operator|=
name|l_parasite_prop
expr_stmt|;
block|}
if|if
condition|(
name|l_parasite_prop
condition|)
block|{
name|l_parasite_prop
operator|->
name|parasite_id
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_parasite_prop
operator|->
name|parasite_type
operator|=
name|l_parasite_type
expr_stmt|;
name|l_parasite_prop
operator|->
name|obj_pos
operator|=
name|l_new_prop
operator|->
name|channel_pos
expr_stmt|;
block|}
break|break;
default|default :
comment|/* g_printerr ("XJT: PRP file scanned bad line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_channel_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_image_prop  *  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_scann_image_prop (gchar * scan_ptr,t_image_props * image_prop)
name|p_scann_image_prop
parameter_list|(
name|gchar
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|t_guide_props
modifier|*
name|l_guide_prop
decl_stmt|;
name|t_parasite_props
modifier|*
name|l_parasite_prop
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|scan_ptr
argument_list|,
name|GIMP_XJ_IMAGE
argument_list|,
name|strlen
argument_list|(
name|GIMP_XJ_IMAGE
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP file %s identstring missing, scanned bad line:\n%s\n"
argument_list|,
name|GIMP_XJ_IMAGE
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_ptr
operator|=
operator|&
name|scan_ptr
index|[
name|strlen
argument_list|(
name|GIMP_XJ_IMAGE
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_VERSION
case|:
name|image_prop
operator|->
name|version
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_GIMP_VERSION
case|:
name|image_prop
operator|->
name|gimp_major_version
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|image_prop
operator|->
name|gimp_minor_version
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
name|image_prop
operator|->
name|gimp_micro_version
operator|=
name|l_param
operator|.
name|int_val3
expr_stmt|;
break|break;
case|case
name|PROP_TYPE
case|:
switch|switch
condition|(
name|l_param
operator|.
name|int_val1
condition|)
block|{
case|case
name|XJT_RGB
case|:
name|image_prop
operator|->
name|image_type
operator|=
name|GIMP_RGB
expr_stmt|;
break|break;
case|case
name|XJT_GRAY
case|:
name|image_prop
operator|->
name|image_type
operator|=
name|GIMP_GRAY
expr_stmt|;
break|break;
default|default:
name|g_printerr
argument_list|(
literal|"XJT: PRP unsupported image_type %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
break|break;
case|case
name|PROP_DIMENSION
case|:
name|image_prop
operator|->
name|image_width
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|image_prop
operator|->
name|image_height
operator|=
name|l_param
operator|.
name|int_val2
expr_stmt|;
break|break;
case|case
name|PROP_UNIT
case|:
name|image_prop
operator|->
name|unit
operator|=
name|p_to_GimpUnit
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_GUIDES
case|:
name|l_guide_prop
operator|=
name|p_new_guide_prop
argument_list|()
expr_stmt|;
if|if
condition|(
name|l_guide_prop
condition|)
block|{
name|l_guide_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|guide_props
expr_stmt|;
name|image_prop
operator|->
name|guide_props
operator|=
name|l_guide_prop
expr_stmt|;
name|l_guide_prop
operator|->
name|position
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_guide_prop
operator|->
name|orientation
operator|=
name|p_to_GimpOrientation
argument_list|(
name|l_param
operator|.
name|int_val2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_PARASITES
case|:
name|l_parasite_prop
operator|=
name|p_find_parasite
argument_list|(
name|image_prop
operator|->
name|parasite_props
argument_list|,
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_parasite_prop
operator|==
name|NULL
condition|)
block|{
name|l_parasite_prop
operator|=
name|p_new_parasite_prop
argument_list|()
expr_stmt|;
name|l_parasite_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|parasite_props
expr_stmt|;
name|image_prop
operator|->
name|parasite_props
operator|=
name|l_parasite_prop
expr_stmt|;
block|}
if|if
condition|(
name|l_parasite_prop
condition|)
block|{
name|l_parasite_prop
operator|->
name|parasite_id
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
name|l_parasite_prop
operator|->
name|parasite_type
operator|=
name|XJT_IMAGE_PARASITE
expr_stmt|;
name|l_parasite_prop
operator|->
name|obj_pos
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|PROP_RESOLUTION
case|:
name|image_prop
operator|->
name|xresolution
operator|=
name|l_param
operator|.
name|flt_val1
expr_stmt|;
name|image_prop
operator|->
name|yresolution
operator|=
name|l_param
operator|.
name|flt_val2
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|image_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO_STATE
case|:
name|image_prop
operator|->
name|tattoo_state
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
default|default :
comment|/* g_printerr ("XJT: Warning PRP unexpected token in line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_image_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_parasite_prop  *   scann one inputline for parasite properties  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_scann_parasite_prop (const gchar * scan_ptr,t_image_props * image_prop)
name|p_scann_parasite_prop
parameter_list|(
specifier|const
name|gchar
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|t_parasite_props
modifier|*
name|l_new_prop
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|gint32
name|l_parasite_id
decl_stmt|;
name|l_parasite_id
operator|=
name|strtol
argument_list|(
operator|&
name|scan_ptr
index|[
literal|1
index|]
argument_list|,
operator|&
name|l_ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*  Scan integer (base = 10)  */
if|if
condition|(
name|l_ptr
operator|==
name|scan_ptr
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP file parasite# missing, scanned bad line:\n%s\n"
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_new_prop
operator|=
name|p_find_parasite
argument_list|(
name|image_prop
operator|->
name|parasite_props
argument_list|,
name|l_parasite_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_new_prop
operator|==
name|NULL
condition|)
block|{
name|l_new_prop
operator|=
name|p_new_parasite_prop
argument_list|()
expr_stmt|;
comment|/* add the new element to the parasite_props list of the image */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|parasite_props
expr_stmt|;
name|image_prop
operator|->
name|parasite_props
operator|=
name|l_new_prop
expr_stmt|;
block|}
if|if
condition|(
name|l_new_prop
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|l_new_prop
operator|->
name|parasite_id
operator|=
name|l_parasite_id
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_NAME
case|:
name|l_new_prop
operator|->
name|name
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_PARASITE_FLAGS
case|:
name|l_new_prop
operator|->
name|flags
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
default|default :
comment|/* g_printerr ("XJT: PRP file scanned bad line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_parasite_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_scann_path_prop  *   scann one inputline for path properties  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_scann_path_prop (gchar * scan_ptr,t_image_props * image_prop)
name|p_scann_path_prop
parameter_list|(
name|gchar
modifier|*
name|scan_ptr
parameter_list|,
name|t_image_props
modifier|*
name|image_prop
parameter_list|)
block|{
name|t_path_props
modifier|*
name|l_new_prop
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|t_param_prop
name|l_param
decl_stmt|;
name|t_proptype
name|l_prop_id
decl_stmt|;
name|l_new_prop
operator|=
name|p_new_path_prop
argument_list|()
expr_stmt|;
comment|/* add the new element to the path_props list */
name|l_new_prop
operator|->
name|next
operator|=
name|image_prop
operator|->
name|path_props
expr_stmt|;
name|image_prop
operator|->
name|path_props
operator|=
name|l_new_prop
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|scan_ptr
argument_list|,
literal|"PATH"
argument_list|,
name|strlen
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_printerr
argument_list|(
literal|"XJT: PRP scanned bad line:\n%s\n"
argument_list|,
name|scan_ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_ptr
operator|=
name|scan_ptr
operator|+
name|strlen
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_scann_token
argument_list|(
name|l_ptr
argument_list|,
operator|&
name|l_param
argument_list|,
operator|&
name|l_prop_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_prop_id
condition|)
block|{
case|case
name|PROP_END
case|:
return|return
literal|0
return|;
break|break;
case|case
name|PROP_PATH_TYPE
case|:
name|l_new_prop
operator|->
name|path_type
operator|=
name|p_to_GimpPathType
argument_list|(
name|l_param
operator|.
name|int_val1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_PATH_LOCKED
case|:
name|l_new_prop
operator|->
name|path_locked
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_TATTOO
case|:
name|l_new_prop
operator|->
name|tattoo
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_NAME
case|:
name|l_new_prop
operator|->
name|name
operator|=
name|l_param
operator|.
name|string_val
expr_stmt|;
break|break;
case|case
name|PROP_PATH_CURRENT
case|:
name|l_new_prop
operator|->
name|current_flag
operator|=
name|l_param
operator|.
name|int_val1
expr_stmt|;
break|break;
case|case
name|PROP_PATH_POINTS
case|:
name|l_new_prop
operator|->
name|num_points
operator|=
name|l_param
operator|.
name|num_fvals
expr_stmt|;
name|l_new_prop
operator|->
name|path_points
operator|=
name|l_param
operator|.
name|flt_val_list
expr_stmt|;
break|break;
default|default :
comment|/* g_printerr ("XJT: PRP file scanned bad line:\n%s\n", scan_ptr); */
comment|/* return -1; */
comment|/* skip unknow tokens */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_scann_path_prop */
end_comment

begin_comment
comment|/* ============================================================================  * p_add_paths  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_add_paths (gint32 image_id,t_path_props * path_props)
name|p_add_paths
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|t_path_props
modifier|*
name|path_props
parameter_list|)
block|{
name|gchar
modifier|*
name|l_current_pathname
init|=
name|NULL
decl_stmt|;
name|t_path_props
modifier|*
name|l_prop
decl_stmt|;
name|l_prop
operator|=
name|path_props
expr_stmt|;
while|while
condition|(
name|l_prop
condition|)
block|{
if|if
condition|(
name|l_prop
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT: p_add_path name:%s num_points:%d\n"
argument_list|,
name|l_prop
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|l_prop
operator|->
name|num_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT:                :path_type %d point[0]:%f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_prop
operator|->
name|path_type
argument_list|,
operator|(
name|float
operator|)
name|l_prop
operator|->
name|path_points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_prop
operator|->
name|current_flag
condition|)
block|{
name|l_current_pathname
operator|=
name|l_prop
operator|->
name|name
expr_stmt|;
block|}
name|gimp_path_set_points
argument_list|(
name|image_id
argument_list|,
name|l_prop
operator|->
name|name
argument_list|,
name|l_prop
operator|->
name|path_type
argument_list|,
name|l_prop
operator|->
name|num_points
argument_list|,
name|l_prop
operator|->
name|path_points
argument_list|)
expr_stmt|;
name|gimp_path_set_locked
argument_list|(
name|image_id
argument_list|,
name|l_prop
operator|->
name|name
argument_list|,
name|l_prop
operator|->
name|path_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_prop
operator|->
name|tattoo
operator|>=
literal|0
condition|)
block|{
name|gimp_path_set_tattoo
argument_list|(
name|image_id
argument_list|,
name|l_prop
operator|->
name|name
argument_list|,
name|l_prop
operator|->
name|tattoo
argument_list|)
expr_stmt|;
block|}
block|}
name|l_prop
operator|=
operator|(
name|t_path_props
operator|*
operator|)
name|l_prop
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|l_current_pathname
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT: p_add_path current:%s\n"
argument_list|,
name|l_current_pathname
argument_list|)
expr_stmt|;
name|gimp_path_set_current
argument_list|(
name|image_id
argument_list|,
name|l_current_pathname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end p_add_paths */
end_comment

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_load_linefile (const gchar * filename,gint32 * len)
name|p_load_linefile
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|gint32
modifier|*
name|len
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|gchar
modifier|*
name|l_file_buff
decl_stmt|;
name|gint32
name|l_idx
decl_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
comment|/* get file length */
if|if
condition|(
literal|0
operator|!=
name|g_stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|stat_buf
operator|.
name|st_size
expr_stmt|;
name|l_file_buff
operator|=
name|g_malloc0
argument_list|(
operator|*
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* read file into buffer */
name|l_fp
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fread
argument_list|(
name|l_file_buff
argument_list|,
operator|*
name|len
argument_list|,
literal|1
argument_list|,
name|l_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
comment|/* replace all '\n' characters by '\0' */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
operator|*
name|len
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|l_file_buff
index|[
name|l_idx
index|]
operator|==
literal|'\n'
condition|)
block|{
name|l_file_buff
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l_file_buff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|p_next_lineindex (const gchar * file_buff,gint32 max_len,gint32 pos)
name|p_next_lineindex
parameter_list|(
specifier|const
name|gchar
modifier|*
name|file_buff
parameter_list|,
name|gint32
name|max_len
parameter_list|,
name|gint32
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|pos
operator|<
name|max_len
condition|)
block|{
if|if
condition|(
name|file_buff
index|[
name|pos
index|]
operator|==
literal|'\0'
condition|)
block|{
name|pos
operator|++
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|pos
operator|>=
name|max_len
operator|)
condition|?
operator|-
literal|1
else|:
name|pos
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_load_prop_file  *   read all properties from file "PRP"  *   and return the information in a t_image_props stucture  * ============================================================================  */
end_comment

begin_function
specifier|static
name|t_image_props
modifier|*
DECL|function|p_load_prop_file (const gchar * prop_filename,GError ** error)
name|p_load_prop_file
parameter_list|(
specifier|const
name|gchar
modifier|*
name|prop_filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gint32
name|l_filesize
decl_stmt|;
name|gint32
name|l_line_idx
decl_stmt|;
name|gchar
modifier|*
name|l_file_buff
decl_stmt|;
name|gchar
modifier|*
name|l_line_ptr
decl_stmt|;
name|gchar
modifier|*
name|l_ptr
decl_stmt|;
name|t_image_props
modifier|*
name|l_image_prop
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"p_load_prop_file: %s\n"
argument_list|,
name|prop_filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_image_prop
operator|=
name|p_new_image_prop
argument_list|()
expr_stmt|;
name|l_file_buff
operator|=
name|p_load_linefile
argument_list|(
name|prop_filename
argument_list|,
operator|&
name|l_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_file_buff
operator|==
name|NULL
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error: Could not read XJT property file '%s'."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|prop_filename
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|l_filesize
operator|==
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|G_FILE_ERROR_FAILED
argument_list|,
name|_
argument_list|(
literal|"Error: XJT property file '%s' is empty."
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|prop_filename
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* parse 1.st line (image properties) */
name|l_line_idx
operator|=
literal|0
expr_stmt|;
name|l_line_ptr
operator|=
name|l_file_buff
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"\nXJT:PRP_LINE:%s:\n"
argument_list|,
name|l_line_ptr
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_scann_image_prop
argument_list|(
name|l_line_ptr
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|l_line_idx
operator|=
name|p_next_lineindex
argument_list|(
name|l_file_buff
argument_list|,
name|l_filesize
argument_list|,
name|l_line_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_line_idx
operator|<
literal|0
condition|)
block|{
break|break;
comment|/* end of file */
block|}
name|l_line_ptr
operator|=
operator|&
name|l_file_buff
index|[
name|l_line_idx
index|]
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"\nXJT:PRP_LINE:%s:\n"
argument_list|,
name|l_line_ptr
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
name|p_skip_blanks
argument_list|(
operator|&
name|l_line_ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* skip commentlines */
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* skip empty lines */
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* skip empty lines */
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|'l'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'L'
operator|)
condition|)
block|{
name|l_rc
operator|=
name|p_scann_layer_prop
argument_list|(
name|l_line_ptr
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
name|l_image_prop
operator|->
name|n_layers
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
literal|'c'
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
literal|'m'
operator|)
condition|)
block|{
name|l_rc
operator|=
name|p_scann_channel_prop
argument_list|(
name|l_line_ptr
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
name|l_image_prop
operator|->
name|n_channels
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'p'
condition|)
block|{
name|l_rc
operator|=
name|p_scann_parasite_prop
argument_list|(
name|l_line_ptr
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'P'
condition|)
block|{
name|l_rc
operator|=
name|p_scann_path_prop
argument_list|(
name|l_line_ptr
argument_list|,
name|l_image_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_printerr
argument_list|(
literal|"XJT: Warning, undefined PRP line scanned:\n%s\n"
argument_list|,
name|l_line_ptr
argument_list|)
expr_stmt|;
comment|/* goto cleanup; */
block|}
block|}
block|}
block|}
block|}
name|cleanup
label|:
name|g_free
argument_list|(
name|l_file_buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
condition|?
name|NULL
else|:
name|l_image_prop
return|;
block|}
end_function

begin_comment
comment|/* end p_load_prop_file */
end_comment

begin_comment
comment|/* ---------------------- LOAD  -------------------------- */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|load_xjt_image (const gchar * filename,GError ** error)
name|load_xjt_image
parameter_list|(
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_len
decl_stmt|;
name|gchar
modifier|*
name|l_dirname
decl_stmt|;
name|gchar
modifier|*
name|l_prop_file
decl_stmt|;
name|gchar
modifier|*
name|l_jpg_file
decl_stmt|;
name|gchar
modifier|*
name|l_cmd
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
modifier|*
name|l_channels_list
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_channel_id
decl_stmt|;
name|gint32
name|l_image_id
decl_stmt|;
name|gint32
name|l_fsel_attached_to_id
decl_stmt|;
comment|/* the drawable id where the floating selection is attached to */
name|gint32
name|l_fsel_id
decl_stmt|;
comment|/* the drawable id of the floating selection itself */
name|gint32
name|l_active_layer_id
decl_stmt|;
name|gint32
name|l_active_channel_id
decl_stmt|;
name|t_image_props
modifier|*
name|l_image_prp_ptr
decl_stmt|;
name|t_layer_props
modifier|*
name|l_layer_prp_ptr
decl_stmt|;
name|t_channel_props
modifier|*
name|l_channel_prp_ptr
decl_stmt|;
name|t_guide_props
modifier|*
name|l_guide_prp_ptr
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init retcode to Errorstate */
name|l_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_layers_list
operator|=
name|NULL
expr_stmt|;
name|l_channels_list
operator|=
name|NULL
expr_stmt|;
name|l_image_prp_ptr
operator|=
name|NULL
expr_stmt|;
name|l_dirname
operator|=
name|NULL
expr_stmt|;
name|l_prop_file
operator|=
name|NULL
expr_stmt|;
name|l_jpg_file
operator|=
name|NULL
expr_stmt|;
name|l_active_layer_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_active_channel_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_fsel_attached_to_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1  assume fsel is not available (and not attached to any drawable) */
name|l_fsel_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1  assume there is no floating selection */
name|gimp_progress_init_printf
argument_list|(
name|_
argument_list|(
literal|"Opening '%s'"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create temporary directory */
name|l_dirname
operator|=
name|gimp_temp_name
argument_list|(
literal|".tmpdir"
argument_list|)
expr_stmt|;
name|l_prop_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cPRP"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mkdir
argument_list|(
name|l_dirname
argument_list|,
literal|0777
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_set_error
argument_list|(
name|error
argument_list|,
name|G_FILE_ERROR
argument_list|,
name|g_file_error_from_errno
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Could not create working folder '%s': %s"
argument_list|)
argument_list|,
name|gimp_filename_to_utf8
argument_list|(
name|l_dirname
argument_list|)
argument_list|,
name|g_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* prepare for extract tar files directly from filename into l_dirname */
if|if
condition|(
operator|(
operator|*
name|filename
operator|==
name|G_DIR_SEPARATOR
operator|)
operator|||
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* filename with absolute path */
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"cd %s; tar -xf \"%s\"; cd .."
argument_list|,
name|l_dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* filename with relative path */
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"cd %s; tar -xf \"..%c%s\" *; cd .."
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|l_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_len
operator|>
literal|3
condition|)
block|{
comment|/* call optional extracompression programs gzip or bzip2        * (depends on filename's extension)        *        * used gzip options: (bzip2 uses the same options)        *     -c --stdout --to-stdout        *          Write  output  on  standard  output        *     -d --decompress --uncompress        *          Decompress.        *     -f --force        *           Force compression or decompression even if the file        */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|3
index|]
argument_list|,
literal|"bz2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"bunzip2<\"%s\">\"%s%carc.tar\""
argument_list|,
name|filename
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"cd %s; tar -xf arc.tar; cd .."
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|filename
index|[
name|l_len
operator|-
literal|2
index|]
argument_list|,
literal|"gz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"gzip -cdf<\"%s\">\"%s%carc.tar\""
argument_list|,
name|filename
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"cd %s; tar -xf arc.tar; cd .."
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now we can extract the unpacked tar archive */
name|l_rc
operator|=
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* check and read Property file (PRP must exist in each xjt archive) */
name|l_image_prp_ptr
operator|=
name|p_load_prop_file
argument_list|(
name|l_prop_file
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_image_prp_ptr
operator|==
name|NULL
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* create new image (with type and size values from the Property file) */
name|l_image_id
operator|=
name|gimp_image_new
argument_list|(
name|l_image_prp_ptr
operator|->
name|image_width
argument_list|,
name|l_image_prp_ptr
operator|->
name|image_height
argument_list|,
name|l_image_prp_ptr
operator|->
name|image_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_image_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|gimp_image_set_filename
argument_list|(
name|l_image_id
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_image_set_resolution
argument_list|(
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|xresolution
argument_list|,
name|l_image_prp_ptr
operator|->
name|yresolution
argument_list|)
expr_stmt|;
name|gimp_image_set_unit
argument_list|(
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|unit
argument_list|)
expr_stmt|;
name|p_check_and_add_parasite
argument_list|(
name|l_image_id
argument_list|,
name|l_dirname
argument_list|,
name|l_image_prp_ptr
operator|->
name|parasite_props
argument_list|,
literal|0
argument_list|,
name|XJT_IMAGE_PARASITE
argument_list|)
expr_stmt|;
comment|/* load all layers */
for|for
control|(
name|l_layer_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|layer_props
init|;
name|l_layer_prp_ptr
operator|!=
name|NULL
condition|;
name|l_layer_prp_ptr
operator|=
operator|(
name|t_layer_props
operator|*
operator|)
name|l_layer_prp_ptr
operator|->
name|next
control|)
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cl%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
operator|(
name|int
operator|)
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading layer from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
name|l_layer_id
operator|=
name|xjpg_load_layer
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|image_type
argument_list|,
name|l_layer_prp_ptr
operator|->
name|name
argument_list|,
name|l_layer_prp_ptr
operator|->
name|opacity
argument_list|,
name|l_layer_prp_ptr
operator|->
name|mode
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|floating_selection
condition|)
block|{
name|l_fsel_id
operator|=
name|l_layer_id
expr_stmt|;
comment|/* this layer is the floating selection */
block|}
else|else
block|{
comment|/* add the layer on top of the images layerstak */
name|gimp_image_add_layer
argument_list|(
name|l_image_id
argument_list|,
name|l_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|floating_attached
condition|)
block|{
name|l_fsel_attached_to_id
operator|=
name|l_layer_id
expr_stmt|;
comment|/* the floating selection is attached to this layer */
block|}
block|}
comment|/* check for alpha channel */
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|has_alpha
condition|)
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cla%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
operator|(
name|int
operator|)
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading alpha-channel from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjpg_load_layer_alpha
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
name|l_layer_id
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
block|}
comment|/* adjust offsets and other layerproperties */
name|gimp_layer_set_offsets
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|offx
argument_list|,
name|l_layer_prp_ptr
operator|->
name|offy
argument_list|)
expr_stmt|;
name|gimp_drawable_set_visible
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|visible
argument_list|)
expr_stmt|;
name|gimp_drawable_set_linked
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|linked
argument_list|)
expr_stmt|;
name|gimp_layer_set_lock_alpha
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|lock_alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|tattoo
operator|>=
literal|0
condition|)
block|{
name|gimp_drawable_set_tattoo
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|tattoo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_layer_prp_ptr
operator|->
name|active_layer
condition|)
block|{
name|l_active_layer_id
operator|=
name|l_layer_id
expr_stmt|;
block|}
comment|/* Handle layer parasites */
name|p_check_and_add_parasite
argument_list|(
name|l_layer_id
argument_list|,
name|l_dirname
argument_list|,
name|l_image_prp_ptr
operator|->
name|parasite_props
argument_list|,
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|,
name|XJT_LAYER_PARASITE
argument_list|)
expr_stmt|;
comment|/* search for the properties of the layermask */
for|for
control|(
name|l_channel_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|mask_props
init|;
name|l_channel_prp_ptr
operator|!=
name|NULL
condition|;
name|l_channel_prp_ptr
operator|=
operator|(
name|t_channel_props
operator|*
operator|)
name|l_channel_prp_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|channel_pos
operator|==
name|l_layer_prp_ptr
operator|->
name|layer_pos
condition|)
block|{
comment|/* layermask properties found: load the layermask */
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%clm%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
operator|(
name|int
operator|)
name|l_layer_prp_ptr
operator|->
name|layer_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading layer-mask from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
name|l_channel_id
operator|=
name|gimp_layer_create_mask
argument_list|(
name|l_layer_id
argument_list|,
literal|0
comment|/* mask_type 0 = WHITE_MASK */
argument_list|)
expr_stmt|;
comment|/* load should overwrite the layer_mask with data from jpeg file */
name|l_channel_id
operator|=
name|xjpg_load_channel
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|name
argument_list|,
name|l_channel_prp_ptr
operator|->
name|opacity
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_r
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_g
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_b
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_id
operator|>=
literal|0
condition|)
block|{
comment|/* attach the layer_mask to the layer (with identical offsets) */
name|gimp_layer_add_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_channel_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|floating_attached
condition|)
block|{
name|l_fsel_attached_to_id
operator|=
name|l_channel_id
expr_stmt|;
comment|/* the floating selection is attached to this layer_mask */
block|}
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|tattoo
operator|>=
literal|0
condition|)
block|{
name|gimp_drawable_set_tattoo
argument_list|(
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|tattoo
argument_list|)
expr_stmt|;
block|}
comment|/* gimp_layer_set_offsets(l_channel_id, l_layer_prp_ptr->offx, l_layer_prp_ptr->offy); */
name|gimp_layer_set_apply_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|apply_mask
argument_list|)
expr_stmt|;
name|gimp_layer_set_edit_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|edit_mask
argument_list|)
expr_stmt|;
name|gimp_layer_set_show_mask
argument_list|(
name|l_layer_id
argument_list|,
name|l_layer_prp_ptr
operator|->
name|show_mask
argument_list|)
expr_stmt|;
comment|/* Handle layermask parasites */
name|p_check_and_add_parasite
argument_list|(
name|l_channel_id
argument_list|,
name|l_dirname
argument_list|,
name|l_image_prp_ptr
operator|->
name|parasite_props
argument_list|,
name|l_channel_prp_ptr
operator|->
name|channel_pos
argument_list|,
name|XJT_LAYER_MASK_PARASITE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* end search for layermask */
block|}
comment|/* load all channels */
for|for
control|(
name|l_channel_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|channel_props
init|;
name|l_channel_prp_ptr
operator|!=
name|NULL
condition|;
name|l_channel_prp_ptr
operator|=
operator|(
name|t_channel_props
operator|*
operator|)
name|l_channel_prp_ptr
operator|->
name|next
control|)
block|{
name|l_jpg_file
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%cc%d.jpg"
argument_list|,
name|l_dirname
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
operator|(
name|int
operator|)
name|l_channel_prp_ptr
operator|->
name|channel_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: loading channel from file %s\n"
argument_list|,
name|l_jpg_file
argument_list|)
expr_stmt|;
name|l_channel_id
operator|=
name|xjpg_load_channel
argument_list|(
name|l_jpg_file
argument_list|,
name|l_image_id
argument_list|,
operator|-
literal|1
argument_list|,
name|l_channel_prp_ptr
operator|->
name|name
argument_list|,
name|l_channel_prp_ptr
operator|->
name|opacity
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_r
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_g
argument_list|,
name|l_channel_prp_ptr
operator|->
name|color_b
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Handle channel parasites */
name|p_check_and_add_parasite
argument_list|(
name|l_channel_id
argument_list|,
name|l_dirname
argument_list|,
name|l_image_prp_ptr
operator|->
name|parasite_props
argument_list|,
name|l_channel_prp_ptr
operator|->
name|channel_pos
argument_list|,
name|XJT_CHANNEL_PARASITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|tattoo
operator|>=
literal|0
condition|)
block|{
name|gimp_drawable_set_tattoo
argument_list|(
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|tattoo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|selection
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: SELECTION loaded channel id = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_channel_id
argument_list|)
expr_stmt|;
name|gimp_selection_load
argument_list|(
name|l_channel_id
argument_list|)
expr_stmt|;
comment|/* delete the channel after load into selection */
name|gimp_drawable_delete
argument_list|(
name|l_channel_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add channel on top of the channelstack */
name|gimp_image_add_channel
argument_list|(
name|l_image_id
argument_list|,
name|l_channel_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust offsets and other channelproperties */
name|gimp_drawable_set_visible
argument_list|(
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|visible
argument_list|)
expr_stmt|;
name|gimp_channel_set_show_masked
argument_list|(
name|l_channel_id
argument_list|,
name|l_channel_prp_ptr
operator|->
name|show_masked
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|floating_attached
condition|)
block|{
name|l_fsel_attached_to_id
operator|=
name|l_channel_id
expr_stmt|;
comment|/* the floating_selection is attached to this channel */
block|}
if|if
condition|(
name|l_channel_prp_ptr
operator|->
name|active_channel
condition|)
block|{
name|l_active_channel_id
operator|=
name|l_channel_id
expr_stmt|;
block|}
block|}
block|}
comment|/* attach the floating selection... */
if|if
condition|(
operator|(
name|l_fsel_id
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|l_fsel_attached_to_id
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"XJT-DEBUG: attaching floating_selection id=%d to id %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_fsel_id
argument_list|,
operator|(
name|int
operator|)
name|l_fsel_attached_to_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_floating_sel_attach
argument_list|(
name|l_fsel_id
argument_list|,
name|l_fsel_attached_to_id
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* in case of error add floating_selection like an ordinary layer            * (if patches are not installed you'll get the error for sure)            */
name|printf
argument_list|(
literal|"XJT: floating_selection is added as top-layer (attach failed)\n"
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|l_image_id
argument_list|,
name|l_fsel_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set active layer/channel */
if|if
condition|(
name|l_active_channel_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"SET active channel\n"
argument_list|)
expr_stmt|;
name|gimp_image_set_active_channel
argument_list|(
name|l_image_id
argument_list|,
name|l_active_channel_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_active_layer_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|xjt_debug
condition|)
name|printf
argument_list|(
literal|"SET active layer\n"
argument_list|)
expr_stmt|;
name|gimp_image_set_active_layer
argument_list|(
name|l_image_id
argument_list|,
name|l_active_layer_id
argument_list|)
expr_stmt|;
block|}
comment|/* set guides */
for|for
control|(
name|l_guide_prp_ptr
operator|=
name|l_image_prp_ptr
operator|->
name|guide_props
init|;
name|l_guide_prp_ptr
operator|!=
name|NULL
condition|;
name|l_guide_prp_ptr
operator|=
operator|(
name|t_guide_props
operator|*
operator|)
name|l_guide_prp_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l_guide_prp_ptr
operator|->
name|orientation
operator|==
name|GIMP_ORIENTATION_HORIZONTAL
condition|)
name|gimp_image_add_hguide
argument_list|(
name|l_image_id
argument_list|,
name|l_guide_prp_ptr
operator|->
name|position
argument_list|)
expr_stmt|;
else|else
name|gimp_image_add_vguide
argument_list|(
name|l_image_id
argument_list|,
name|l_guide_prp_ptr
operator|->
name|position
argument_list|)
expr_stmt|;
block|}
comment|/* create paths */
if|if
condition|(
name|l_image_prp_ptr
operator|->
name|path_props
condition|)
block|{
name|p_add_paths
argument_list|(
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|path_props
argument_list|)
expr_stmt|;
block|}
comment|/* set tattoo_state */
if|if
condition|(
name|l_image_prp_ptr
operator|->
name|tattoo_state
operator|>
literal|0
condition|)
block|{
name|gimp_image_set_tattoo_state
argument_list|(
name|l_image_id
argument_list|,
name|l_image_prp_ptr
operator|->
name|tattoo_state
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_channels_list
argument_list|)
expr_stmt|;
comment|/* remove the temorary directory */
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"rm -rf \"%s\""
argument_list|,
name|l_dirname
argument_list|)
expr_stmt|;
name|p_system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_dirname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_prop_file
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_jpg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
return|return
name|l_image_id
return|;
comment|/* all done OK */
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_image_id
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

