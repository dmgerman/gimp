begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_range_ops.c  * 1997.11.06 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * This Module contains implementation of range based frame operations.  * - gap_range_to_multilayer   * - gap_range_flatten  * - gap_range_layer_del  * - gap_range_conv  * - gap_anim_scale  * - gap_anim_resize  * - gap_anim_crop  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history  * 1.1.9a   1999/09/21   hof: bugfix RUN_NONINTERACTIVE did not work in  *                            plug_in_gap_range_convert  *                            plug_in_gap_range_layer_del  *                            plug_in_gap_range_flatten  * 1.1.8    1999/08/31   hof: frames convert: save subsequent frames  *                            with rumode RUN_WITH_LAST_VALS   * 0.97.00; 1998/10/19   hof: gap_range_to_multilayer: extended layer selection  * 0.96.03; 1998/08/31   hof: gap_range_to_multilayer: all params available  *                            in non-interactive runmode  * 0.96.02; 1998/08/05   hof: - p_frames_to_multilayer added framerate support  * 0.96.00; 1998/07/01   hof: - added scale, resize and crop   *                              (affects full range == all anim frames)  *                            - now using gap_arr_dialog.h  * 0.94.01; 1998/04/28   hof: added flatten_mode to plugin: gap_range_to_multilayer  * 0.92.00  1998.01.10   hof: bugfix in p_frames_to_multilayer  *                            layers need alpha (to be raise/lower able)   * 0.90.00               first development release  */
end_comment

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_layer_copy.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_match.h"
end_include

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_resi_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_mod_layer.h"
end_include

begin_include
include|#
directive|include
file|"gap_range_ops.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_comment
comment|/* ============================================================================  * p_anim_sizechange_dialog  *   dialog window with 2 (or 4) entry fields  *   where the user can select the new Anim Frame (Image)-Size  *   (if cnt == 4 additional Inputfields for offests are available)  * return -1  in case of cancel or any error  *            (include check for change of current frame)  * return positve (0 or layerstack position) if everythig OK  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_anim_sizechange_dialog (t_anim_info * ainfo_ptr,t_gap_asiz asiz_mode,long * size_x,long * size_y,long * offs_x,long * offs_y)
name|p_anim_sizechange_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|t_gap_asiz
name|asiz_mode
parameter_list|,
name|long
modifier|*
name|size_x
parameter_list|,
name|long
modifier|*
name|size_y
parameter_list|,
name|long
modifier|*
name|offs_x
parameter_list|,
name|long
modifier|*
name|offs_y
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|gint
name|cnt
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|char
name|hline
index|[
literal|100
index|]
decl_stmt|;
name|gint
name|l_width
decl_stmt|;
name|gint
name|l_height
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
comment|/* get info about the image (size is common to all frames) */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"New Width :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
literal|1024
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
operator|=
name|l_width
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"New Height :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
literal|1024
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
name|l_height
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Offest X :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
name|l_width
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Offest Y :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|int_max
operator|=
name|l_height
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|asiz_mode
condition|)
block|{
case|case
name|ASIZ_CROP
case|:
name|title
operator|=
name|_
argument_list|(
literal|"Crop AnimFrames (all)"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hline
argument_list|,
name|_
argument_list|(
literal|"Crop (original %dx%d)"
argument_list|)
argument_list|,
name|l_width
argument_list|,
name|l_height
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
name|l_width
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
name|l_height
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|cnt
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ASIZ_RESIZE
case|:
name|title
operator|=
name|_
argument_list|(
literal|"Resize AnimFrames (all)"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hline
argument_list|,
name|_
argument_list|(
literal|"Resize (original %dx%d)"
argument_list|)
argument_list|,
name|l_width
argument_list|,
name|l_height
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
operator|-
name|l_width
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|int_min
operator|=
operator|-
name|l_height
expr_stmt|;
name|cnt
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|title
operator|=
name|_
argument_list|(
literal|"Scale AnimFrames (all)"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hline
argument_list|,
name|_
argument_list|(
literal|"Scale (original %dx%d)"
argument_list|)
argument_list|,
name|l_width
argument_list|,
name|l_height
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* array dialog can handle all asiz_mode type (and is already prepared for)    * BUT: RESIZE and SCALE should use the same dialogs as used in gimp    *      on single Images.    *      Therfore I made a procedure p_resi_dialog    */
if|if
condition|(
name|asiz_mode
operator|==
name|ASIZ_CROP
condition|)
block|{
name|l_rc
operator|=
name|p_array_dialog
argument_list|(
name|title
argument_list|,
name|hline
argument_list|,
name|cnt
argument_list|,
name|argv
argument_list|)
expr_stmt|;
operator|*
name|size_x
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|size_y
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|offs_x
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|offs_y
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|3
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
comment|/* Clip size down to image borders */
if|if
condition|(
operator|(
operator|*
name|size_x
operator|+
operator|*
name|offs_x
operator|)
operator|>
name|l_width
condition|)
block|{
operator|*
name|size_x
operator|=
name|l_width
operator|-
operator|*
name|offs_x
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|size_y
operator|+
operator|*
name|offs_y
operator|)
operator|>
name|l_height
condition|)
block|{
operator|*
name|size_y
operator|=
name|l_height
operator|-
operator|*
name|offs_y
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_rc
operator|=
name|p_resi_dialog
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|asiz_mode
argument_list|,
name|title
argument_list|,
name|size_x
argument_list|,
name|size_y
argument_list|,
name|offs_x
argument_list|,
name|offs_y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* OK */
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_anim_sizechange_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_range_dialog  *   dialog window with 2 (or 3) entry fields  *   where the user can select a frame range (FROM TO)  *   (if cnt == 3 additional Layerstackposition)  * return -1  in case of cancel or any error  *            (include check for change of current frame)  * return positve (0 or layerstack position) if everythig OK  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_range_dialog (t_anim_info * ainfo_ptr,long * range_from,long * range_to,char * title,char * hline,gint cnt)
name|p_range_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
modifier|*
name|range_from
parameter_list|,
name|long
modifier|*
name|range_to
parameter_list|,
name|char
modifier|*
name|title
parameter_list|,
name|char
modifier|*
name|hline
parameter_list|,
name|gint
name|cnt
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|3
condition|)
name|cnt
operator|=
literal|2
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Layerstack :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
literal|99
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|title
argument_list|,
name|hline
argument_list|,
name|cnt
argument_list|,
name|argv
argument_list|)
condition|)
block|{
operator|*
name|range_from
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|range_to
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_range_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_convert_dialog  *  *   return  0 .. OK   *          -1 .. in case of Error or cancel  * ============================================================================  */
end_comment

begin_function
specifier|static
name|long
DECL|function|p_convert_dialog (t_anim_info * ainfo_ptr,long * range_from,long * range_to,long * flatten,GImageType * dest_type,gint32 * dest_colors,gint32 * dest_dither,char * basename,gint len_base,char * extension,gint len_ext)
name|p_convert_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
modifier|*
name|range_from
parameter_list|,
name|long
modifier|*
name|range_to
parameter_list|,
name|long
modifier|*
name|flatten
parameter_list|,
name|GImageType
modifier|*
name|dest_type
parameter_list|,
name|gint32
modifier|*
name|dest_colors
parameter_list|,
name|gint32
modifier|*
name|dest_dither
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|gint
name|len_base
parameter_list|,
name|char
modifier|*
name|extension
parameter_list|,
name|gint
name|len_ext
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|9
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|radio_args
index|[
literal|4
index|]
init|=
block|{
name|N_
argument_list|(
literal|"KEEP_TYPE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Conv to RGB"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Conv to GRAY"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Conv to INDEXED"
argument_list|)
block|}
decl_stmt|;
specifier|static
name|int
name|gettextize_loop
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|gettextize_loop
operator|<
literal|4
condition|;
name|gettextize_loop
operator|++
control|)
name|radio_args
index|[
name|gettextize_loop
index|]
operator|=
name|gettext
argument_list|(
name|radio_args
index|[
name|gettextize_loop
index|]
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From Frame:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"first handled frame"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To   Frame:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"last handled frame"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"\nSelect destination fileformat by extension\noptionally convert imagetype\n"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Basename:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"basename of the resulting frames       \n(0001.ext is added)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|text_buf_len
operator|=
name|len_base
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|text_buf_ret
operator|=
name|basename
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|4
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Extension:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"extension of resulting frames       \n(is also used to define Fileformat)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|text_buf_len
operator|=
name|len_ext
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|text_buf_ret
operator|=
name|extension
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Imagetype :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Convert to, or keep imagetype           \n(most fileformats cant handle all types)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_argc
operator|=
literal|4
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_argv
operator|=
name|radio_args
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_ret
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|6
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Flatten  :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Flatten all resulting frames               \n(most fileformats need flattened frames)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|7
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Colors  :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Number of resulting Colors               \n(ignored if not converted to indexed)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_min
operator|=
literal|2
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_max
operator|=
literal|256
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
operator|=
literal|255
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|8
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Dither  :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Enable Floyd-Steinberg dithering      \n(ignored if not converted to indexed)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|_
argument_list|(
literal|"Convert Frames to other Formats"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Convert Settings :"
argument_list|)
argument_list|,
literal|9
argument_list|,
name|argv
argument_list|)
condition|)
block|{
operator|*
name|range_from
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|range_to
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|argv
index|[
literal|5
index|]
operator|.
name|radio_ret
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dest_type
operator|=
name|RGB
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|dest_type
operator|=
name|GRAY
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|dest_type
operator|=
name|INDEXED
expr_stmt|;
break|break;
default|default:
operator|*
name|dest_type
operator|=
literal|9444
expr_stmt|;
break|break;
block|}
operator|*
name|flatten
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|dest_colors
operator|=
call|(
name|gint32
call|)
argument_list|(
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|dest_dither
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|8
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_convert_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_range_to_multilayer_dialog  *   dialog window with 4 entry fields  *   where the user can select a frame range (FROM TO)  * return -1  in case of cancel or any error  *            (include check for change of current frame)  * return positve (0 or layerstack position) if everythig OK  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_range_to_multilayer_dialog (t_anim_info * ainfo_ptr,long * range_from,long * range_to,long * flatten_mode,long * bg_visible,long * framrate,char * frame_basename,gint len_frame_basename,char * title,char * hline,gint32 * sel_mode,gint32 * sel_case,gint32 * sel_invert,char * sel_pattern)
name|p_range_to_multilayer_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
modifier|*
name|range_from
parameter_list|,
name|long
modifier|*
name|range_to
parameter_list|,
name|long
modifier|*
name|flatten_mode
parameter_list|,
name|long
modifier|*
name|bg_visible
parameter_list|,
name|long
modifier|*
name|framrate
parameter_list|,
name|char
modifier|*
name|frame_basename
parameter_list|,
name|gint
name|len_frame_basename
parameter_list|,
name|char
modifier|*
name|title
parameter_list|,
name|char
modifier|*
name|hline
parameter_list|,
name|gint32
modifier|*
name|sel_mode
parameter_list|,
name|gint32
modifier|*
name|sel_case
parameter_list|,
name|gint32
modifier|*
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|radio_args
index|[
literal|4
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Expand as necessary"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Clipped to image"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Clipped to bottom layer"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Flattened image"
argument_list|)
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|radio_help
index|[
literal|4
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Resulting Layer Size is made of the outline-rectangle \nof all visible layers (may differ from frame to frame)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Resulting Layer Size is the frame size"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Resulting Layer Size is the size of the bottom layer\n(may differ from frame to frame)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Resulting Layer Size is the frame size     \ntransparent parts are filled with BG color"
argument_list|)
block|}
decl_stmt|;
comment|/* Layer select modes */
specifier|static
name|char
modifier|*
name|sel_args
index|[
literal|7
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Pattern is equal to LayerName"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is Start of LayerName"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is End of Layername"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is a Part of LayerName"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is LayerstackNumber List"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is REVERSE-stack List"
argument_list|)
block|,
name|N_
argument_list|(
literal|"All Visible (ignore Pattern)"
argument_list|)
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|sel_help
index|[
literal|7
index|]
init|=
block|{
name|N_
argument_list|(
literal|"select all Layers where Layername is equal to Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"select all Layers where Layername starts with Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"select all Layers where Layername ends up with Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"select all Layers where Layername contains Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"select Layerstack positions.\n0, 4-5, 8\nwhere 0 == Top-layer"
argument_list|)
block|,
name|N_
argument_list|(
literal|"select Layerstack positions.\n0, 4-5, 8\nwhere 0 == BG-layer"
argument_list|)
block|,
name|N_
argument_list|(
literal|"select all visible Layers"
argument_list|)
block|}
decl_stmt|;
specifier|static
name|int
name|gettextize_radio
init|=
literal|0
decl_stmt|,
name|gettextize_sel
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|gettextize_radio
operator|<
literal|4
condition|;
name|gettextize_radio
operator|++
control|)
block|{
name|radio_args
index|[
name|gettextize_radio
index|]
operator|=
name|gettext
argument_list|(
name|radio_args
index|[
name|gettextize_radio
index|]
argument_list|)
expr_stmt|;
name|radio_help
index|[
name|gettextize_radio
index|]
operator|=
name|gettext
argument_list|(
name|radio_help
index|[
name|gettextize_radio
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|gettextize_sel
operator|<
literal|4
condition|;
name|gettextize_sel
operator|++
control|)
block|{
name|sel_args
index|[
name|gettextize_sel
index|]
operator|=
name|gettext
argument_list|(
name|sel_args
index|[
name|gettextize_sel
index|]
argument_list|)
expr_stmt|;
name|sel_help
index|[
name|gettextize_sel
index|]
operator|=
name|gettext
argument_list|(
name|sel_help
index|[
name|gettextize_sel
index|]
argument_list|)
expr_stmt|;
block|}
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"first handled frame"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"last handled frame"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Layer Basename:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Basename for all Layers    \n[####] is replaced by frame number"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|text_buf_len
operator|=
name|len_frame_basename
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|text_buf_ret
operator|=
name|frame_basename
expr_stmt|;
comment|/* Framerate is not used any longer */
comment|/*     p_init_arr_arg(&argv[3], WGT_INT_PAIR);   argv[3].constraint = FALSE;   argv[3].label_txt = "Framerate :";   argv[3].help_txt  = "Framedelay in ms";   argv[3].int_min   = (gint)0;   argv[3].int_max   = (gint)300;   argv[3].int_ret   = (gint)50;  */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
literal|" "
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|4
index|]
argument_list|,
name|WGT_RADIO
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Layer Mergemode :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_argc
operator|=
literal|4
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_argv
operator|=
name|radio_args
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_help_argv
operator|=
name|radio_help
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Exclude BG-Layer"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Exclude the BG-Layers    \nin all handled frames\nregardless to selection"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
comment|/* 1: exclude BG Layer from all selections */
comment|/* Layer select mode RADIO buttons */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|6
index|]
argument_list|,
name|WGT_RADIO
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Select Layer(s):"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_argc
operator|=
literal|7
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_argv
operator|=
name|sel_args
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_help_argv
operator|=
name|sel_help
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_ret
operator|=
literal|6
expr_stmt|;
comment|/* Layer select pattern string */
name|sprintf
argument_list|(
name|sel_pattern
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|7
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Select Pattern:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
literal|7
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"String to identify layer names    \nor layerstack position numbers\n0,3-5"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|text_buf_len
operator|=
name|MAX_LAYERNAME
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|text_buf_ret
operator|=
name|sel_pattern
expr_stmt|;
comment|/* case sensitive checkbutton */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|8
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Case sensitive"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Lowercase and UPPERCASE letters are considered as different"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
comment|/* invert selection checkbutton */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|9
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Invert Selection"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Use all unselected Layers"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|title
argument_list|,
name|hline
argument_list|,
literal|10
argument_list|,
name|argv
argument_list|)
condition|)
block|{
operator|*
name|range_from
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|range_to
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|framrate
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|3
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|flatten_mode
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|4
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
operator|==
literal|0
condition|)
operator|*
name|bg_visible
operator|=
literal|1
expr_stmt|;
comment|/* 1: use BG like any Layer */
else|else
operator|*
name|bg_visible
operator|=
literal|0
expr_stmt|;
comment|/* 0: exclude (ignore) BG Layer */
operator|*
name|sel_mode
operator|=
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
expr_stmt|;
comment|/*     [7] sel_pattern  */
operator|*
name|sel_case
operator|=
name|argv
index|[
literal|8
index|]
operator|.
name|int_ret
expr_stmt|;
operator|*
name|sel_invert
operator|=
name|argv
index|[
literal|9
index|]
operator|.
name|int_ret
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_range_to_multilayer_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_frames_to_multilayer  * returns   image_id of the new created multilayer image  *           (or -1 on error)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|p_frames_to_multilayer (t_anim_info * ainfo_ptr,long range_from,long range_to,long flatten_mode,long bg_visible,long framerate,char * frame_basename,gint32 sel_mode,gint32 sel_case,gint32 sel_invert,char * sel_pattern)
name|p_frames_to_multilayer
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|long
name|flatten_mode
parameter_list|,
name|long
name|bg_visible
parameter_list|,
name|long
name|framerate
parameter_list|,
name|char
modifier|*
name|frame_basename
parameter_list|,
name|gint32
name|sel_mode
parameter_list|,
name|gint32
name|sel_case
parameter_list|,
name|gint32
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|)
block|{
name|GImageType
name|l_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|long
name|l_cur_frame_nr
decl_stmt|;
name|long
name|l_step
decl_stmt|,
name|l_begin
decl_stmt|,
name|l_end
decl_stmt|;
name|long
name|l_vidx
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint32
name|l_new_image_id
decl_stmt|;
name|gint32
name|l_cp_layer_id
decl_stmt|;
name|gint32
name|l_tmp_layer_id
decl_stmt|;
name|gint
name|l_src_offset_x
decl_stmt|,
name|l_src_offset_y
decl_stmt|;
comment|/* layeroffsets as they were in src_image */
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint
name|l_visible
decl_stmt|;
name|gint
name|l_nvisible
decl_stmt|;
name|gint
name|l_nlayers_result
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
specifier|static
name|char
name|l_layername
index|[
literal|256
index|]
decl_stmt|;
name|t_LayliElem
modifier|*
name|l_layli_ptr
decl_stmt|;
name|gint32
name|l_sel_cnt
decl_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
name|l_nlayers_result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Creating Layer-Animated Image .."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l_tmp_layer_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* get info about the image (size and type is common to all frames) */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_type
operator|=
name|gimp_image_base_type
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_new_image_id
operator|=
name|gimp_image_new
argument_list|(
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|)
expr_stmt|;
name|l_visible
operator|=
name|TRUE
expr_stmt|;
comment|/* only the 1.st layer should be visible */
name|l_begin
operator|=
name|range_from
expr_stmt|;
name|l_end
operator|=
name|range_to
expr_stmt|;
if|if
condition|(
name|range_from
operator|>
name|range_to
condition|)
block|{
name|l_step
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* operate in descending (reverse) order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_from
operator|)
operator|-
name|range_to
operator|)
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_from
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_step
operator|=
literal|1
expr_stmt|;
comment|/* operate in ascending order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_to
operator|)
operator|-
name|range_from
operator|)
expr_stmt|;
if|if
condition|(
name|range_from
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_to
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
block|}
name|l_cur_frame_nr
operator|=
name|l_begin
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* build the frame name */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* load current frame into temporary image */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* get informations (id, visible, selected) about all layers */
name|l_layli_ptr
operator|=
name|p_alloc_layli
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_sel_cnt
argument_list|,
operator|&
name|l_nlayers
argument_list|,
name|sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
name|sel_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|l_nvisible
operator|=
name|l_sel_cnt
expr_stmt|;
comment|/* count visible Layers == all selected layers */
for|for
control|(
name|l_vidx
operator|=
literal|0
init|;
name|l_vidx
operator|<
name|l_nlayers
condition|;
name|l_vidx
operator|++
control|)
block|{
comment|/* set all selected layers visible, all others invisible */
name|l_tmp_layer_id
operator|=
name|l_layli_ptr
index|[
name|l_vidx
index|]
operator|.
name|layer_id
expr_stmt|;
name|gimp_layer_set_visible
argument_list|(
name|l_tmp_layer_id
argument_list|,
name|l_layli_ptr
index|[
name|l_vidx
index|]
operator|.
name|selected
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bg_visible
operator|==
literal|0
operator|)
operator|&&
operator|(
name|l_vidx
operator|==
operator|(
name|l_nlayers
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* set BG_Layer invisible */
name|gimp_layer_set_visible
argument_list|(
name|l_tmp_layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
index|[
name|l_vidx
index|]
operator|.
name|selected
condition|)
block|{
name|l_nvisible
operator|--
expr_stmt|;
block|}
block|}
block|}
name|g_free
argument_list|(
name|l_layli_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flatten_mode
operator|>=
name|FLAM_MERG_EXPAND
operator|)
operator|&&
operator|(
name|flatten_mode
operator|<=
name|FLAM_MERG_CLIP_BG
operator|)
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"p_frames_to_multilayer: %d MERGE visible layers=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|flatten_mode
argument_list|,
operator|(
name|int
operator|)
name|l_nvisible
argument_list|)
expr_stmt|;
comment|/* merge all visible Layers */
if|if
condition|(
name|l_nvisible
operator|>
literal|1
condition|)
name|gimp_image_merge_visible_layers
argument_list|(
name|l_tmp_image_id
argument_list|,
name|flatten_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"p_frames_to_multilayer: %d FLATTEN\n"
argument_list|,
operator|(
name|int
operator|)
name|flatten_mode
argument_list|)
expr_stmt|;
comment|/* flatten temporary image (reduce to single layer) */
name|gimp_image_flatten
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* copy (the only visible) layer from temporary image */
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|l_vidx
operator|=
literal|0
init|;
name|l_vidx
operator|<
name|l_nlayers
condition|;
name|l_vidx
operator|++
control|)
block|{
name|l_tmp_layer_id
operator|=
name|l_layers_list
index|[
name|l_vidx
index|]
expr_stmt|;
comment|/* stop at 1.st visible layer (this should be the only visible layer) */
if|if
condition|(
name|gimp_layer_get_visible
argument_list|(
name|l_tmp_layer_id
argument_list|)
condition|)
break|break;
comment|/* stop at 1.st layer if image was flattened */
if|if
condition|(
operator|(
name|flatten_mode
operator|<
name|FLAM_MERG_EXPAND
operator|)
operator|||
operator|(
name|flatten_mode
operator|>
name|FLAM_MERG_CLIP_BG
operator|)
condition|)
break|break;
block|}
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_vidx
operator|<
name|l_nlayers
condition|)
block|{
name|l_cp_layer_id
operator|=
name|p_my_layer_copy
argument_list|(
name|l_new_image_id
argument_list|,
name|l_tmp_layer_id
argument_list|,
literal|100.0
argument_list|,
comment|/* Opacity */
literal|0
argument_list|,
comment|/* NORMAL */
operator|&
name|l_src_offset_x
argument_list|,
operator|&
name|l_src_offset_y
argument_list|)
expr_stmt|;
comment|/* add the copied layer to current destination image */
name|gimp_image_add_layer
argument_list|(
name|l_new_image_id
argument_list|,
name|l_cp_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_set_offsets
argument_list|(
name|l_cp_layer_id
argument_list|,
name|l_src_offset_x
argument_list|,
name|l_src_offset_y
argument_list|)
expr_stmt|;
name|l_nlayers_result
operator|++
expr_stmt|;
comment|/* add aplha channel to all layers          * (without alpha raise and lower would not work on that layers)          */
name|gimp_layer_add_alpha
argument_list|(
name|l_cp_layer_id
argument_list|)
expr_stmt|;
comment|/* set name and visibility */
if|if
condition|(
name|frame_basename
operator|==
name|NULL
condition|)
name|frame_basename
operator|=
literal|"frame_[####]"
expr_stmt|;
if|if
condition|(
operator|*
name|frame_basename
operator|==
literal|'\0'
condition|)
name|frame_basename
operator|=
literal|"frame_[####]"
expr_stmt|;
name|p_substitute_framenr
argument_list|(
operator|&
name|l_layername
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_layername
argument_list|)
argument_list|,
name|frame_basename
argument_list|,
operator|(
name|long
operator|)
name|l_cur_frame_nr
argument_list|)
expr_stmt|;
name|gimp_layer_set_name
argument_list|(
name|l_cp_layer_id
argument_list|,
operator|&
name|l_layername
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gimp_layer_set_visible
argument_list|(
name|l_cp_layer_id
argument_list|,
name|l_visible
argument_list|)
expr_stmt|;
name|l_visible
operator|=
name|FALSE
expr_stmt|;
comment|/* all further layers are set invisible */
block|}
comment|/* else: tmp image has no visible layers, ignore that frame */
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
comment|/* advance to next frame */
if|if
condition|(
name|l_cur_frame_nr
operator|==
name|l_end
condition|)
break|break;
name|l_cur_frame_nr
operator|+=
name|l_step
expr_stmt|;
block|}
name|p_prevent_empty_image
argument_list|(
name|l_new_image_id
argument_list|)
expr_stmt|;
return|return
name|l_new_image_id
return|;
name|error
label|:
name|gimp_image_delete
argument_list|(
name|l_new_image_id
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* end p_frames_to_multilayer */
end_comment

begin_comment
comment|/* ============================================================================  * gap_range_to_multilayer  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_range_to_multilayer (GRunModeType run_mode,gint32 image_id,long range_from,long range_to,long flatten_mode,long bg_visible,long framerate,char * frame_basename,int frame_basename_len,gint32 sel_mode,gint32 sel_case,gint32 sel_invert,char * sel_pattern)
name|gint32
name|gap_range_to_multilayer
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|long
name|flatten_mode
parameter_list|,
name|long
name|bg_visible
parameter_list|,
name|long
name|framerate
parameter_list|,
name|char
modifier|*
name|frame_basename
parameter_list|,
name|int
name|frame_basename_len
parameter_list|,
name|gint32
name|sel_mode
parameter_list|,
name|gint32
name|sel_case
parameter_list|,
name|gint32
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|)
block|{
name|gint32
name|new_image_id
decl_stmt|;
name|gint32
name|l_rc
decl_stmt|;
name|long
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gint32
name|l_sel_mode
decl_stmt|;
name|gint32
name|l_sel_case
decl_stmt|;
name|gint32
name|l_sel_invert
decl_stmt|;
name|char
name|l_sel_pattern
index|[
name|MAX_LAYERNAME
index|]
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|strcpy
argument_list|(
name|frame_basename
argument_list|,
literal|"frame_[####]"
argument_list|)
expr_stmt|;
name|framerate
operator|=
literal|0
expr_stmt|;
name|l_rc
operator|=
name|p_range_to_multilayer_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|,
operator|&
name|flatten_mode
argument_list|,
operator|&
name|bg_visible
argument_list|,
operator|&
name|framerate
argument_list|,
name|frame_basename
argument_list|,
name|frame_basename_len
argument_list|,
name|_
argument_list|(
literal|"Frames to Image"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Create Multilayer-Image from Frames"
argument_list|)
argument_list|,
operator|&
name|l_sel_mode
argument_list|,
operator|&
name|sel_case
argument_list|,
operator|&
name|sel_invert
argument_list|,
operator|&
name|l_sel_pattern
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_sel_mode
operator|=
name|sel_mode
expr_stmt|;
name|l_sel_case
operator|=
name|sel_case
expr_stmt|;
name|l_sel_invert
operator|=
name|sel_invert
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|l_sel_pattern
index|[
literal|0
index|]
argument_list|,
name|sel_pattern
argument_list|,
sizeof|sizeof
argument_list|(
name|l_sel_pattern
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_sel_pattern
index|[
sizeof|sizeof
argument_list|(
name|l_sel_pattern
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|new_image_id
operator|=
name|p_frames_to_multilayer
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|,
name|flatten_mode
argument_list|,
name|bg_visible
argument_list|,
name|framerate
argument_list|,
name|frame_basename
argument_list|,
name|l_sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
operator|&
name|l_sel_pattern
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gimp_display_new
argument_list|(
name|new_image_id
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|new_image_id
expr_stmt|;
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_range_to_multilayer */
end_comment

begin_comment
comment|/* ============================================================================  * p_type_convert  *   convert image to desired type (reduce to dest_colors for INDEXED type)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_type_convert (gint32 image_id,GImageType dest_type,gint32 dest_colors,gint32 dest_dither)
name|p_type_convert
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|GImageType
name|dest_type
parameter_list|,
name|gint32
name|dest_colors
parameter_list|,
name|gint32
name|dest_dither
parameter_list|)
block|{
name|GParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_params
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|INDEXED
case|:
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: p_type_convert to INDEXED ncolors=%d'\n"
argument_list|,
operator|(
name|int
operator|)
name|dest_colors
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_indexed"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|dest_dither
argument_list|,
comment|/* value 1== floyd-steinberg */
name|PARAM_INT32
argument_list|,
name|dest_colors
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRAY
case|:
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: p_type_convert to GRAY'\n"
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_grayscale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
break|break;
case|case
name|RGB
case|:
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: p_type_convert to RGB'\n"
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_rgb"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: p_type_convert AS_IT_IS (dont convert)'\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
block|}
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|FALSE
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_type_convert */
end_comment

begin_comment
comment|/* ============================================================================  * p_frames_convert  *    convert frames (multiple images) into desired fileformat and type  *    (flatten the images if desired)  *  *   if save_proc_name == NULL  *   then   use xcf save (and flatten image)  *          and new_basename and new_extension  *  * returns   value>= 0 if all is ok   *           (or -1 on error)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_frames_convert (t_anim_info * ainfo_ptr,long range_from,long range_to,char * save_proc_name,char * new_basename,char * new_extension,int flatten,GImageType dest_type,gint32 dest_colors,gint32 dest_dither)
name|p_frames_convert
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|char
modifier|*
name|save_proc_name
parameter_list|,
name|char
modifier|*
name|new_basename
parameter_list|,
name|char
modifier|*
name|new_extension
parameter_list|,
name|int
name|flatten
parameter_list|,
name|GImageType
name|dest_type
parameter_list|,
name|gint32
name|dest_colors
parameter_list|,
name|gint32
name|dest_dither
parameter_list|)
block|{
name|GRunModeType
name|l_run_mode
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|long
name|l_cur_frame_nr
decl_stmt|;
name|long
name|l_step
decl_stmt|,
name|l_begin
decl_stmt|,
name|l_end
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
name|char
modifier|*
name|l_sav_name
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|gint
name|l_overwrite_mode
decl_stmt|;
specifier|static
name|t_but_arg
name|l_argv
index|[
literal|3
index|]
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_overwrite_mode
operator|=
literal|0
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
name|l_run_mode
operator|=
name|ainfo_ptr
operator|->
name|run_mode
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
if|if
condition|(
name|save_proc_name
operator|==
name|NULL
condition|)
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Flattening Frames .."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Converting Frames .."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l_begin
operator|=
name|range_from
expr_stmt|;
name|l_end
operator|=
name|range_to
expr_stmt|;
if|if
condition|(
name|range_from
operator|>
name|range_to
condition|)
block|{
name|l_step
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* operate in descending (reverse) order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_from
operator|)
operator|-
name|range_to
operator|)
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_from
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_step
operator|=
literal|1
expr_stmt|;
comment|/* operate in ascending order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_to
operator|)
operator|-
name|range_from
operator|)
expr_stmt|;
if|if
condition|(
name|range_from
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_to
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
block|}
name|l_cur_frame_nr
operator|=
name|l_begin
expr_stmt|;
while|while
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
comment|/* build the frame name */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* load current frame */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l_nlayers
operator|>
literal|1
operator|)
operator|&&
operator|(
name|flatten
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: p_frames_convert flatten tmp image'\n"
argument_list|)
expr_stmt|;
comment|/* flatten current frame image (reduce to single layer) */
name|gimp_image_flatten
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
comment|/* save back the current frame with same name */
if|if
condition|(
name|save_proc_name
operator|==
name|NULL
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_proc_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dest_type
operator|!=
name|gimp_image_base_type
argument_list|(
name|l_tmp_image_id
argument_list|)
condition|)
block|{
comment|/* have to convert to desired type (RGB, INDEXED, GRAYSCALE) */
name|p_type_convert
argument_list|(
name|l_tmp_image_id
argument_list|,
name|dest_type
argument_list|,
name|dest_colors
argument_list|,
name|dest_dither
argument_list|)
expr_stmt|;
block|}
comment|/* build the name for output image */
name|l_sav_name
operator|=
name|p_alloc_fname
argument_list|(
name|new_basename
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|new_extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_sav_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|p_file_exists
argument_list|(
name|l_sav_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|l_overwrite_mode
operator|<
literal|1
condition|)
block|{
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"OVERWRITE frame"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"OVERWRITE all"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|1
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"CANCEL"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|l_overwrite_mode
operator|=
name|p_buttons_dialog
argument_list|(
name|_
argument_list|(
literal|"GAP Question"
argument_list|)
argument_list|,
name|l_sav_name
argument_list|,
literal|3
argument_list|,
name|l_argv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_overwrite_mode
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* save with selected save procedure              * (regardless if image was flattened or not)              */
name|l_rc
operator|=
name|p_save_named_image
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_sav_name
argument_list|,
name|l_run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|_
argument_list|(
literal|"Convert Frames: SAVE operation FAILED\n- desired save plugin cant handle type\n- or desired save plugin not available\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_run_mode
operator|=
name|RUN_WITH_LAST_VALS
expr_stmt|;
comment|/* for all further calls */
block|}
name|g_free
argument_list|(
name|l_sav_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
comment|/* advance to next frame */
if|if
condition|(
operator|(
name|l_cur_frame_nr
operator|==
name|l_end
operator|)
operator|||
operator|(
name|l_rc
operator|<
literal|0
operator|)
condition|)
break|break;
name|l_cur_frame_nr
operator|+=
name|l_step
expr_stmt|;
block|}
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_frames_convert */
end_comment

begin_comment
comment|/* ============================================================================  * p_image_sizechange  *     scale, resize or crop one image  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_image_sizechange (gint32 image_id,t_gap_asiz asiz_mode,long size_x,long size_y,long offs_x,long offs_y)
name|int
name|p_image_sizechange
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|t_gap_asiz
name|asiz_mode
parameter_list|,
name|long
name|size_x
parameter_list|,
name|long
name|size_y
parameter_list|,
name|long
name|offs_x
parameter_list|,
name|long
name|offs_y
parameter_list|)
block|{
name|GParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
switch|switch
condition|(
name|asiz_mode
condition|)
block|{
case|case
name|ASIZ_CROP
case|:
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_crop"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|size_x
argument_list|,
name|PARAM_INT32
argument_list|,
name|size_y
argument_list|,
name|PARAM_INT32
argument_list|,
name|offs_x
argument_list|,
name|PARAM_INT32
argument_list|,
name|offs_y
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASIZ_RESIZE
case|:
name|gimp_image_resize
argument_list|(
name|image_id
argument_list|,
operator|(
name|guint
operator|)
name|size_x
argument_list|,
operator|(
name|guint
operator|)
name|size_y
argument_list|,
operator|(
name|gint
operator|)
name|offs_x
argument_list|,
operator|(
name|gint
operator|)
name|offs_y
argument_list|)
expr_stmt|;
break|break;
default|default:
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|size_x
argument_list|,
name|PARAM_INT32
argument_list|,
name|size_y
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end p_image_sizechange */
end_comment

begin_comment
comment|/* ============================================================================  * p_anim_sizechange  *     scale, resize or crop all frames in the animation  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_anim_sizechange (t_anim_info * ainfo_ptr,t_gap_asiz asiz_mode,long size_x,long size_y,long offs_x,long offs_y)
name|gint32
name|p_anim_sizechange
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|t_gap_asiz
name|asiz_mode
parameter_list|,
name|long
name|size_x
parameter_list|,
name|long
name|size_y
parameter_list|,
name|long
name|offs_x
parameter_list|,
name|long
name|offs_y
parameter_list|)
block|{
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|long
name|l_cur_frame_nr
decl_stmt|;
name|long
name|l_step
decl_stmt|,
name|l_begin
decl_stmt|,
name|l_end
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
name|GParam
modifier|*
name|l_params
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_params
operator|=
name|NULL
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
switch|switch
condition|(
name|asiz_mode
condition|)
block|{
case|case
name|ASIZ_CROP
case|:
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Cropping all Animation Frames .."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASIZ_RESIZE
case|:
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Resizing all Animation Frames .."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Scaling all Animation Frames .."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* get info about the image (size and type is common to all frames) */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|l_step
operator|=
literal|1
expr_stmt|;
comment|/* operate in ascending order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|l_end
operator|)
operator|-
name|l_begin
operator|)
expr_stmt|;
name|l_cur_frame_nr
operator|=
name|l_begin
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* build the frame name */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* load current frame into temporary image */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|l_rc
operator|=
name|p_image_sizechange
argument_list|(
name|l_tmp_image_id
argument_list|,
name|asiz_mode
argument_list|,
name|size_x
argument_list|,
name|size_y
argument_list|,
name|offs_x
argument_list|,
name|offs_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
break|break;
comment|/* save back the current frame with same name */
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
break|break;
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
comment|/* advance to next frame */
if|if
condition|(
name|l_cur_frame_nr
operator|==
name|l_end
condition|)
break|break;
name|l_cur_frame_nr
operator|+=
name|l_step
expr_stmt|;
block|}
comment|/* end while loop over all frames*/
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end  p_anim_sizechange */
end_comment

begin_comment
comment|/* ============================================================================  * gap_range_flatten  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_range_flatten (GRunModeType run_mode,gint32 image_id,long range_from,long range_to)
name|int
name|gap_range_flatten
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|long
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_range_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|,
name|_
argument_list|(
literal|"Flatten Frames"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Select Frame Range"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_frames_convert
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_range_flatten */
end_comment

begin_comment
comment|/* ============================================================================  * p_frames_layer_del  * returns   image_id of the new created multilayer image  *           (or -1 on error)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_frames_layer_del (t_anim_info * ainfo_ptr,long range_from,long range_to,long position)
name|p_frames_layer_del
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|long
name|position
parameter_list|)
block|{
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|long
name|l_cur_frame_nr
decl_stmt|;
name|long
name|l_step
decl_stmt|,
name|l_begin
decl_stmt|,
name|l_end
decl_stmt|;
name|gint32
name|l_tmp_layer_id
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
specifier|static
name|char
name|l_buff
index|[
literal|50
index|]
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|sprintf
argument_list|(
name|l_buff
argument_list|,
name|_
argument_list|(
literal|"Removing Layer (pos:%ld) from Frames .."
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|l_buff
argument_list|)
expr_stmt|;
block|}
comment|/* get info about the image (size and type is common to all frames) */
name|l_begin
operator|=
name|range_from
expr_stmt|;
name|l_end
operator|=
name|range_to
expr_stmt|;
if|if
condition|(
name|range_from
operator|>
name|range_to
condition|)
block|{
name|l_step
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* operate in descending (reverse) order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_from
operator|)
operator|-
name|range_to
operator|)
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_from
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_step
operator|=
literal|1
expr_stmt|;
comment|/* operate in ascending order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_to
operator|)
operator|-
name|range_from
operator|)
expr_stmt|;
if|if
condition|(
name|range_from
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_to
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
block|}
name|l_cur_frame_nr
operator|=
name|l_begin
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* build the frame name */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* load current frame */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* remove layer[position] */
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|!=
name|NULL
condition|)
block|{
comment|/* findout layer id of the requestetd position within layerstack */
if|if
condition|(
name|position
operator|<
name|l_nlayers
condition|)
name|l_tmp_layer_id
operator|=
name|l_layers_list
index|[
name|position
index|]
expr_stmt|;
else|else
name|l_tmp_layer_id
operator|=
name|l_layers_list
index|[
name|l_nlayers
operator|-
literal|1
index|]
expr_stmt|;
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
comment|/* check for last layer (MUST NOT be deleted !) */
if|if
condition|(
name|l_nlayers
operator|>
literal|1
condition|)
block|{
comment|/* remove and delete requested layer */
name|gimp_image_remove_layer
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_tmp_layer_id
argument_list|)
expr_stmt|;
comment|/*  gimp_layer_delete(l_tmp_layer_id); */
comment|/* gives sigsegv ERROR */
comment|/* A: gimp_image_remove_layer does automatic delete           *    if layer is not attched to any image          * B: gimp_layer_delete has a BUG          */
comment|/* save current frame */
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
comment|/* advance to next frame */
if|if
condition|(
operator|(
name|l_cur_frame_nr
operator|==
name|l_end
operator|)
operator|||
operator|(
name|l_rc
operator|<
literal|0
operator|)
condition|)
break|break;
name|l_cur_frame_nr
operator|+=
name|l_step
expr_stmt|;
block|}
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_frames_layer_del */
end_comment

begin_comment
comment|/* ============================================================================  * gap_range_layer_del  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_range_layer_del (GRunModeType run_mode,gint32 image_id,long range_from,long range_to,long position)
name|int
name|gap_range_layer_del
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|long
name|position
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|long
name|l_position
decl_stmt|;
name|long
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_position
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_range_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|,
name|_
argument_list|(
literal|"Delete Layers in Frames"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Select Frame Range& Position"
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|l_position
operator|=
name|l_rc
expr_stmt|;
block|}
else|else
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
name|l_position
operator|=
name|position
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_frames_layer_del
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|,
name|l_position
argument_list|)
expr_stmt|;
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_range_layer_del */
end_comment

begin_comment
comment|/* ============================================================================  * gap_range_conv  *   convert frame range to any gimp supported fileformat  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_range_conv (GRunModeType run_mode,gint32 image_id,long range_from,long range_to,long flatten,GImageType dest_type,gint32 dest_colors,gint32 dest_dither,char * basename,char * extension)
name|gint32
name|gap_range_conv
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|long
name|flatten
parameter_list|,
name|GImageType
name|dest_type
parameter_list|,
name|gint32
name|dest_colors
parameter_list|,
name|gint32
name|dest_dither
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|char
modifier|*
name|extension
parameter_list|)
block|{
name|gint32
name|l_rc
decl_stmt|;
name|long
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|long
name|l_flatten
decl_stmt|;
name|gint32
name|l_dest_colors
decl_stmt|;
name|gint32
name|l_dest_dither
decl_stmt|;
name|GImageType
name|l_dest_type
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|char
name|l_save_proc_name
index|[
literal|128
index|]
decl_stmt|;
name|char
name|l_basename
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|l_basename_ptr
decl_stmt|;
name|long
name|l_number
decl_stmt|;
name|char
name|l_extension
index|[
literal|32
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|l_save_proc_name
argument_list|,
literal|"gimp_file_save"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|l_extension
argument_list|,
literal|".tif"
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|l_basename
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|,
sizeof|sizeof
argument_list|(
name|l_basename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_basename
index|[
sizeof|sizeof
argument_list|(
name|l_basename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_flatten
operator|=
literal|1
expr_stmt|;
comment|/* p_convert_dialog : select destination type           * to find out extension           */
name|l_rc
operator|=
name|p_convert_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|,
operator|&
name|l_flatten
argument_list|,
operator|&
name|l_dest_type
argument_list|,
operator|&
name|l_dest_colors
argument_list|,
operator|&
name|l_dest_dither
argument_list|,
operator|&
name|l_basename
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_basename
argument_list|)
argument_list|,
operator|&
name|l_extension
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_extension
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
name|l_flatten
operator|=
name|flatten
expr_stmt|;
name|l_dest_type
operator|=
name|dest_type
expr_stmt|;
name|l_dest_colors
operator|=
name|dest_colors
expr_stmt|;
name|l_dest_dither
operator|=
name|dest_dither
expr_stmt|;
if|if
condition|(
name|basename
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|l_basename
argument_list|,
name|basename
argument_list|,
sizeof|sizeof
argument_list|(
name|l_basename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_basename
index|[
sizeof|sizeof
argument_list|(
name|l_basename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|l_extension
argument_list|,
name|extension
argument_list|,
sizeof|sizeof
argument_list|(
name|l_extension
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_extension
index|[
sizeof|sizeof
argument_list|(
name|l_extension
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
comment|/* cut off extension and trailing frame number */
name|l_basename_ptr
operator|=
name|p_alloc_basename
argument_list|(
operator|&
name|l_basename
index|[
literal|0
index|]
argument_list|,
operator|&
name|l_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_basename_ptr
operator|==
name|NULL
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l_rc
operator|=
name|p_frames_convert
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|,
name|l_save_proc_name
argument_list|,
name|l_basename_ptr
argument_list|,
name|l_extension
argument_list|,
name|l_flatten
argument_list|,
name|l_dest_type
argument_list|,
name|l_dest_colors
argument_list|,
name|l_dest_dither
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_basename_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_range_conv */
end_comment

begin_comment
comment|/* ============================================================================  * gap_anim_sizechange  *    scale, resize or crop all anim_frame images of the animation  *    (depending on asiz_mode)  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_anim_sizechange (GRunModeType run_mode,t_gap_asiz asiz_mode,gint32 image_id,long size_x,long size_y,long offs_x,long offs_y)
name|int
name|gap_anim_sizechange
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|t_gap_asiz
name|asiz_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|size_x
parameter_list|,
name|long
name|size_y
parameter_list|,
name|long
name|offs_x
parameter_list|,
name|long
name|offs_y
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|long
name|l_size_x
decl_stmt|,
name|l_size_y
decl_stmt|;
name|long
name|l_offs_x
decl_stmt|,
name|l_offs_y
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_anim_sizechange_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
name|asiz_mode
argument_list|,
operator|&
name|l_size_x
argument_list|,
operator|&
name|l_size_y
argument_list|,
operator|&
name|l_offs_x
argument_list|,
operator|&
name|l_offs_y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_size_x
operator|=
name|size_x
expr_stmt|;
name|l_size_y
operator|=
name|size_y
expr_stmt|;
name|l_offs_x
operator|=
name|offs_x
expr_stmt|;
name|l_offs_y
operator|=
name|offs_y
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
comment|/* we have to resize the current anim frame image in gimp's ram             *(from where we were invoked)             * Note: All anim frames on disc and the current one in ram             *       must fit in size and type, to allow further animation operations.             *       (Restriction of duplicate_into)             */
name|l_rc
operator|=
name|p_image_sizechange
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|asiz_mode
argument_list|,
name|l_size_x
argument_list|,
name|l_size_y
argument_list|,
name|l_offs_x
argument_list|,
name|l_offs_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
comment|/* sizechange for all anim frames on disk */
name|l_rc
operator|=
name|p_anim_sizechange
argument_list|(
name|ainfo_ptr
argument_list|,
name|asiz_mode
argument_list|,
name|l_size_x
argument_list|,
name|l_size_y
argument_list|,
name|l_offs_x
argument_list|,
name|l_offs_y
argument_list|)
expr_stmt|;
block|}
comment|/* p_load_named_frame(ainfo_ptr->image_id, ainfo_ptr->old_filename); */
comment|/* dont need to reload, because the same sizechange operation was             * applied both to ram-image and dikfile             *             * But we must clear all undo steps.              * (If the user could undo the sizechange on the current image,             *  it would not fit to the other frames on disk.)             */
name|gimp_image_undo_enable
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
comment|/* clear undo stack */
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_anim_sizechange */
end_comment

end_unit

