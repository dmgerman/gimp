begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_filter_iterators.c  *  * 1998.01.29 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * This Module contains:  * - Implementation of XXX_Iterator_ALT Procedures   *     for those Plugins  of the gimp.1.1.9 release  *     - that can operate on a single drawable,  *     - and have paramters for varying.  *  * for now i made some Iterator Plugins using the ending _ALT,  * If New plugins were added to the gimp, or existing ones were updated,  * the Authors should supply original _Iterator Procedures  * (without the _ALT ending)  * This Procedures are then used instead of my (Hacked _ALT) versions.  * to modify the settings for the plugin when called step by step  * on animated multilayer Images.  * without name conflicts.  *  * The 2.nd section of this file was generated by gap_filter_codegen.c:p_gen_code_iter_ALT  * using the PDB at version gimp 1.1.9 as base.  * Unforunately, some of the plugins are using datastructures  * to store their "Last Values"  * that are differnt from its calling parameters (as described in the PDB)  * Therfore I had to adjust (edit by hand) the generted structures to fit the  * plugins internal settings.  *  * Common things to all Iteratur Plugins:  * Interface:   run_mode        # is always GIMP_RUN_NONINTERACTIVE  *              total_steps     # total number of handled layers (drawables)  *              current_step    # current layer (beginning wit 0)  *                               has type gdouble for later extensions  *                               to non-linear iterations.  *                               the iterator always computes linear inbetween steps,  *                               but the (central) caller may fake step 1.2345 in the future  *                               for logaritmic iterations or userdefined curves.  *  * Naming Convention:   *    Iterators must have the name of the plugin (PDB proc_name), whose values  *    are iterated, with Suffix   *      "_Iterator"        or  *      "_Iterator_ALT"    (if not provided within the original Plugin's sources)  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Change Log:  * version gimp 1.1.17b  2000.02.22  hof: - removed limit PLUGIN_DATA_SIZE  * 1999.11.16 hof: added p_delta_gintdrawable  * 1999.06.21 hof: removed Colorify iterator  * 1999.03.14 hof: added iterators for gimp 1.1.3 prerelease  *                 iterator code reorganized in _iter_ALT.inc Files  * 1998.06.12 hof: added p_delta_drawable (Iterate layers in the layerstack)  *                 this enables to apply an animated bumpmap.  * 1998.01.29 hof: 1st release  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_filter.h"
end_include

begin_include
include|#
directive|include
file|"gap_filter_iterators.h"
end_include

begin_decl_stmt
DECL|variable|g_plugin_data_from
specifier|static
name|gchar
modifier|*
name|g_plugin_data_from
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|g_plugin_data_to
specifier|static
name|gchar
modifier|*
name|g_plugin_data_to
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|gchar
modifier|*
DECL|function|p_alloc_plugin_data (char * key)
name|p_alloc_plugin_data
parameter_list|(
name|char
modifier|*
name|key
parameter_list|)
block|{
name|int
name|l_len
decl_stmt|;
name|gchar
modifier|*
name|l_plugin_data
decl_stmt|;
name|l_len
operator|=
name|gimp_get_data_size
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_len
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: no stored data found for Key %s\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|l_plugin_data
operator|=
name|g_malloc0
argument_list|(
name|l_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG  Key:%s  plugin_data length %d\n"
argument_list|,
name|key
argument_list|,
operator|(
name|int
operator|)
name|l_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_plugin_data
operator|)
return|;
block|}
end_function

begin_typedef
DECL|struct|__anon28c8dee70108
typedef|typedef
struct|struct
block|{
DECL|member|color
name|guchar
name|color
index|[
literal|3
index|]
decl_stmt|;
DECL|typedef|t_color
block|}
name|t_color
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon28c8dee70208
typedef|typedef
struct|struct
block|{
DECL|member|color
name|gint
name|color
index|[
literal|3
index|]
decl_stmt|;
DECL|typedef|t_gint_color
block|}
name|t_gint_color
typedef|;
end_typedef

begin_comment
comment|/* ----------------------------------------------------------------------   * iterator functions for basic datatypes  * (were called from the generated procedures)  * ----------------------------------------------------------------------   */
end_comment

begin_function
DECL|function|p_delta_long (long * val,long val_from,long val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_long
parameter_list|(
name|long
modifier|*
name|val
parameter_list|,
name|long
name|val_from
parameter_list|,
name|long
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: p_delta_long from: %ld to: %ld curr: %ld    delta: %f\n"
argument_list|,
name|val_from
argument_list|,
name|val_to
argument_list|,
operator|*
name|val
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_short (short * val,short val_from,short val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_short
parameter_list|(
name|short
modifier|*
name|val
parameter_list|,
name|short
name|val_from
parameter_list|,
name|short
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_int (int * val,int val_from,int val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_int
parameter_list|(
name|int
modifier|*
name|val
parameter_list|,
name|int
name|val_from
parameter_list|,
name|int
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_gint (gint * val,gint val_from,gint val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_gint
parameter_list|(
name|gint
modifier|*
name|val
parameter_list|,
name|gint
name|val_from
parameter_list|,
name|gint
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_char (char * val,char val_from,char val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_char
parameter_list|(
name|char
modifier|*
name|val
parameter_list|,
name|char
name|val_from
parameter_list|,
name|char
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_guchar (guchar * val,char val_from,char val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_guchar
parameter_list|(
name|guchar
modifier|*
name|val
parameter_list|,
name|char
name|val_from
parameter_list|,
name|char
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_gdouble (double * val,double val_from,double val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_gdouble
parameter_list|(
name|double
modifier|*
name|val
parameter_list|,
name|double
name|val_from
parameter_list|,
name|double
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: p_delta_gdouble total: %d  from: %f to: %f curr: %f    delta: %f\n"
argument_list|,
operator|(
name|int
operator|)
name|total_steps
argument_list|,
name|val_from
argument_list|,
name|val_to
argument_list|,
operator|*
name|val
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_gfloat (gfloat * val,gfloat val_from,gfloat val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_gfloat
parameter_list|(
name|gfloat
modifier|*
name|val
parameter_list|,
name|gfloat
name|val_from
parameter_list|,
name|gfloat
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: p_delta_gfloat total: %d  from: %f to: %f curr: %f    delta: %f\n"
argument_list|,
operator|(
name|int
operator|)
name|total_steps
argument_list|,
name|val_from
argument_list|,
name|val_to
argument_list|,
operator|*
name|val
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_float (float * val,float val_from,float val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_float
parameter_list|(
name|float
modifier|*
name|val
parameter_list|,
name|float
name|val_from
parameter_list|,
name|float
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|-
name|val_from
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|val_from
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: p_delta_gdouble total: %d  from: %f to: %f curr: %f    delta: %f\n"
argument_list|,
operator|(
name|int
operator|)
name|total_steps
argument_list|,
name|val_from
argument_list|,
name|val_to
argument_list|,
operator|*
name|val
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_color (t_color * val,t_color * val_from,t_color * val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_color
parameter_list|(
name|t_color
modifier|*
name|val
parameter_list|,
name|t_color
modifier|*
name|val_from
parameter_list|,
name|t_color
modifier|*
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
literal|3
condition|;
name|l_idx
operator|++
control|)
block|{
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|->
name|color
index|[
name|l_idx
index|]
operator|-
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
name|val
operator|->
name|color
index|[
name|l_idx
index|]
operator|=
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: p_delta_color[%d] total: %d  from: %d to: %d curr: %d    delta: %f  current_step: %f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|int
operator|)
name|total_steps
argument_list|,
operator|(
name|int
operator|)
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
argument_list|,
operator|(
name|int
operator|)
name|val_to
operator|->
name|color
index|[
name|l_idx
index|]
argument_list|,
operator|(
name|int
operator|)
name|val
operator|->
name|color
index|[
name|l_idx
index|]
argument_list|,
name|delta
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|p_delta_gint_color (t_gint_color * val,t_gint_color * val_from,t_gint_color * val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_gint_color
parameter_list|(
name|t_gint_color
modifier|*
name|val
parameter_list|,
name|t_gint_color
modifier|*
name|val_from
parameter_list|,
name|t_gint_color
modifier|*
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
literal|3
condition|;
name|l_idx
operator|++
control|)
block|{
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|->
name|color
index|[
name|l_idx
index|]
operator|-
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
name|val
operator|->
name|color
index|[
name|l_idx
index|]
operator|=
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
operator|+
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|p_delta_drawable (gint32 * val,gint32 val_from,gint32 val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_drawable
parameter_list|(
name|gint32
modifier|*
name|val
parameter_list|,
name|gint32
name|val_from
parameter_list|,
name|gint32
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint
name|l_idx
decl_stmt|,
name|l_idx_from
decl_stmt|,
name|l_idx_to
decl_stmt|;
if|if
condition|(
operator|(
name|val_from
operator|<
literal|0
operator|)
operator|||
operator|(
name|val_to
operator|<
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|l_tmp_image_id
operator|=
name|gimp_drawable_image_id
argument_list|(
name|val_from
argument_list|)
expr_stmt|;
comment|/* check if from and to values are both valid drawables within the same image */
if|if
condition|(
operator|(
name|l_tmp_image_id
operator|>
literal|0
operator|)
operator|&&
operator|(
name|l_tmp_image_id
operator|=
name|gimp_drawable_image_id
argument_list|(
name|val_to
argument_list|)
operator|)
condition|)
block|{
name|l_idx_from
operator|=
operator|-
literal|1
expr_stmt|;
name|l_idx_to
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* check the layerstack index of from and to drawable */
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
name|l_nlayers
operator|-
literal|1
init|;
name|l_idx
operator|>=
literal|0
condition|;
name|l_idx
operator|--
control|)
block|{
if|if
condition|(
name|l_layers_list
index|[
name|l_idx
index|]
operator|==
name|val_from
condition|)
name|l_idx_from
operator|=
name|l_idx
expr_stmt|;
if|if
condition|(
name|l_layers_list
index|[
name|l_idx
index|]
operator|==
name|val_to
condition|)
name|l_idx_to
operator|=
name|l_idx
expr_stmt|;
if|if
condition|(
operator|(
name|l_idx_from
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|l_idx_to
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* OK found both index values, iterate the index (proceed to next layer) */
name|p_delta_gint
argument_list|(
operator|&
name|l_idx
argument_list|,
name|l_idx_from
argument_list|,
name|l_idx_to
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|l_layers_list
index|[
name|l_idx
index|]
expr_stmt|;
break|break;
block|}
block|}
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_delta_gintdrawable (gint * val,gint val_from,gint val_to,gint32 total_steps,gdouble current_step)
name|p_delta_gintdrawable
parameter_list|(
name|gint
modifier|*
name|val
parameter_list|,
name|gint
name|val_from
parameter_list|,
name|gint
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|gint32
name|l_val
decl_stmt|,
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|l_val
operator|=
operator|*
name|val
expr_stmt|;
name|l_from
operator|=
name|val_from
expr_stmt|;
name|l_to
operator|=
name|val_to
expr_stmt|;
name|p_delta_drawable
argument_list|(
operator|&
name|l_val
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|l_val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  * iterator UTILITIES for Gck Vectors, Material and Light Sewttings  * ----------------------------------------------------------------------  */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28c8dee70308
block|{
DECL|member|color
name|double
name|color
index|[
literal|4
index|]
decl_stmt|;
comment|/* r,g,b,a */
DECL|typedef|t_GckRGB
block|}
name|t_GckRGB
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28c8dee70408
block|{
DECL|member|coord
name|double
name|coord
index|[
literal|3
index|]
decl_stmt|;
comment|/* x,y,z; */
DECL|typedef|t_GckVector3
block|}
name|t_GckVector3
typedef|;
end_typedef

begin_typedef
DECL|enum|__anon28c8dee70503
typedef|typedef
enum|enum
block|{
DECL|enumerator|POINT_LIGHT
name|POINT_LIGHT
block|,
DECL|enumerator|DIRECTIONAL_LIGHT
name|DIRECTIONAL_LIGHT
block|,
DECL|enumerator|SPOT_LIGHT
name|SPOT_LIGHT
block|,
DECL|enumerator|NO_LIGHT
name|NO_LIGHT
DECL|typedef|t_LightType
block|}
name|t_LightType
typedef|;
end_typedef

begin_typedef
DECL|enum|__anon28c8dee70603
typedef|typedef
enum|enum
block|{
DECL|enumerator|IMAGE_BUMP
name|IMAGE_BUMP
block|,
DECL|enumerator|WAVES_BUMP
name|WAVES_BUMP
DECL|typedef|t_MapType
block|}
name|t_MapType
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28c8dee70708
block|{
DECL|member|ambient_int
name|gdouble
name|ambient_int
decl_stmt|;
DECL|member|diffuse_int
name|gdouble
name|diffuse_int
decl_stmt|;
DECL|member|diffuse_ref
name|gdouble
name|diffuse_ref
decl_stmt|;
DECL|member|specular_ref
name|gdouble
name|specular_ref
decl_stmt|;
DECL|member|highlight
name|gdouble
name|highlight
decl_stmt|;
DECL|member|color
name|t_GckRGB
name|color
decl_stmt|;
DECL|typedef|t_MaterialSettings
block|}
name|t_MaterialSettings
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon28c8dee70808
block|{
DECL|member|type
name|t_LightType
name|type
decl_stmt|;
DECL|member|position
name|t_GckVector3
name|position
decl_stmt|;
DECL|member|direction
name|t_GckVector3
name|direction
decl_stmt|;
DECL|member|color
name|t_GckRGB
name|color
decl_stmt|;
DECL|member|intensity
name|gdouble
name|intensity
decl_stmt|;
DECL|typedef|t_LightSettings
block|}
name|t_LightSettings
typedef|;
end_typedef

begin_function
DECL|function|p_delta_GckRGB (t_GckRGB * val,t_GckRGB * val_from,t_GckRGB * val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_GckRGB
parameter_list|(
name|t_GckRGB
modifier|*
name|val
parameter_list|,
name|t_GckRGB
modifier|*
name|val_from
parameter_list|,
name|t_GckRGB
modifier|*
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
literal|4
condition|;
name|l_idx
operator|++
control|)
block|{
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|->
name|color
index|[
name|l_idx
index|]
operator|-
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
name|val
operator|->
name|color
index|[
name|l_idx
index|]
operator|=
name|val_from
operator|->
name|color
index|[
name|l_idx
index|]
operator|+
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|p_delta_GckVector3 (t_GckVector3 * val,t_GckVector3 * val_from,t_GckVector3 * val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_GckVector3
parameter_list|(
name|t_GckVector3
modifier|*
name|val
parameter_list|,
name|t_GckVector3
modifier|*
name|val_from
parameter_list|,
name|t_GckVector3
modifier|*
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
if|if
condition|(
name|total_steps
operator|<
literal|1
condition|)
return|return;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
literal|3
condition|;
name|l_idx
operator|++
control|)
block|{
name|delta
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|val_to
operator|->
name|coord
index|[
name|l_idx
index|]
operator|-
name|val_from
operator|->
name|coord
index|[
name|l_idx
index|]
argument_list|)
operator|/
operator|(
name|double
operator|)
name|total_steps
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|total_steps
operator|-
name|current_step
operator|)
expr_stmt|;
name|val
operator|->
name|coord
index|[
name|l_idx
index|]
operator|=
name|val_from
operator|->
name|coord
index|[
name|l_idx
index|]
operator|+
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|p_delta_MaterialSettings (t_MaterialSettings * val,t_MaterialSettings * val_from,t_MaterialSettings * val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_MaterialSettings
parameter_list|(
name|t_MaterialSettings
modifier|*
name|val
parameter_list|,
name|t_MaterialSettings
modifier|*
name|val_from
parameter_list|,
name|t_MaterialSettings
modifier|*
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
name|p_delta_gdouble
argument_list|(
operator|&
name|val
operator|->
name|ambient_int
argument_list|,
name|val_from
operator|->
name|ambient_int
argument_list|,
name|val_to
operator|->
name|ambient_int
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_gdouble
argument_list|(
operator|&
name|val
operator|->
name|diffuse_int
argument_list|,
name|val_from
operator|->
name|diffuse_int
argument_list|,
name|val_to
operator|->
name|diffuse_int
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_gdouble
argument_list|(
operator|&
name|val
operator|->
name|diffuse_ref
argument_list|,
name|val_from
operator|->
name|diffuse_ref
argument_list|,
name|val_to
operator|->
name|diffuse_ref
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_gdouble
argument_list|(
operator|&
name|val
operator|->
name|specular_ref
argument_list|,
name|val_from
operator|->
name|specular_ref
argument_list|,
name|val_to
operator|->
name|specular_ref
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_gdouble
argument_list|(
operator|&
name|val
operator|->
name|highlight
argument_list|,
name|val_from
operator|->
name|highlight
argument_list|,
name|val_to
operator|->
name|highlight
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_GckRGB
argument_list|(
operator|&
name|val
operator|->
name|color
argument_list|,
operator|&
name|val_from
operator|->
name|color
argument_list|,
operator|&
name|val_to
operator|->
name|color
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_delta_LightSettings (t_LightSettings * val,t_LightSettings * val_from,t_LightSettings * val_to,gint32 total_steps,gdouble current_step)
specifier|static
name|void
name|p_delta_LightSettings
parameter_list|(
name|t_LightSettings
modifier|*
name|val
parameter_list|,
name|t_LightSettings
modifier|*
name|val_from
parameter_list|,
name|t_LightSettings
modifier|*
name|val_to
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|)
block|{
comment|/* no delta is done for LightType */
name|p_delta_GckVector3
argument_list|(
operator|&
name|val
operator|->
name|position
argument_list|,
operator|&
name|val_from
operator|->
name|position
argument_list|,
operator|&
name|val_to
operator|->
name|position
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_GckVector3
argument_list|(
operator|&
name|val
operator|->
name|direction
argument_list|,
operator|&
name|val_from
operator|->
name|direction
argument_list|,
operator|&
name|val_to
operator|->
name|direction
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_GckRGB
argument_list|(
operator|&
name|val
operator|->
name|color
argument_list|,
operator|&
name|val_from
operator|->
name|color
argument_list|,
operator|&
name|val_to
operator|->
name|color
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
name|p_delta_gdouble
argument_list|(
operator|&
name|val
operator|->
name|intensity
argument_list|,
name|val_from
operator|->
name|intensity
argument_list|,
name|val_to
operator|->
name|intensity
argument_list|,
name|total_steps
argument_list|,
name|current_step
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------- 2.nd Section  * ----------------------------------------  * INCLUDE the generated p_XXX_iter_ALT procedures  * ----------------------------------------  * ----------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_Twist_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_alienmap_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_applylens_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_blur_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_bump_map_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_convmatrix_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_depth_merge_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_despeckle_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_emboss_iter_ALT.inc"
end_include

begin_comment
comment|/*  #include "iter_ALT/mod/plug_in_exchange_iter_ALT.inc" */
end_comment

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_flame_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_lighting_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_map_object_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_maze_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_nlfilt_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_nova_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_oilify_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_pagecurl_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_papertile_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_plasma_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_polar_coords_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_sample_colorize_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_sinus_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_solid_noise_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/mod/plug_in_sparkle_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_CentralReflection_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_anamorphose_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_blur2_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_encript_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_figures_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_gflare_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_holes_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_julia_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_magic_eye_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_mandelbrot_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_randomize_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_refract_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_struc_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_tileit_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_universal_filter_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/old/plug_in_warp_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_CML_explorer_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_alpha2color_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_blinds_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_borderaverage_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_checkerboard_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_color_map_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_colorify_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_cubism_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_destripe_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_diffraction_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_displace_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_edge_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_engrave_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_flarefx_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_fractal_trace_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_gauss_iir_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_gauss_iir2_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_gauss_rle_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_gauss_rle2_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_gfig_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_glasstile_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_grid_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_jigsaw_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_mblur_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_mosaic_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_newsprint_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_noisify_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_pixelize_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_randomize_hurl_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_randomize_pick_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_randomize_slur_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_ripple_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_rotate_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_scatter_hsv_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_sharpen_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_shift_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_spread_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_video_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_vpropagate_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_waves_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_whirl_pinch_iter_ALT.inc"
end_include

begin_include
include|#
directive|include
file|"iter_ALT/gen/plug_in_wind_iter_ALT.inc"
end_include

begin_comment
comment|/* table of proc_names and funtion pointers to iter_ALT procedures */
end_comment

begin_comment
comment|/* del ... Deleted (does not make sense to animate)  * +   ... generated code did not work (changed manually)  */
end_comment

begin_decl_stmt
DECL|variable|g_iter_ALT_tab
specifier|static
name|t_iter_ALT_tab
name|g_iter_ALT_tab
index|[]
init|=
block|{
comment|/*  { "Colorify",  p_Colorify_iter_ALT }                                          */
comment|/*, { "perl_fu_blowinout",  p_perl_fu_blowinout_iter_ALT }                        */
comment|/*, { "perl_fu_feedback",  p_perl_fu_feedback_iter_ALT }                          */
comment|/*, { "perl_fu_prep4gif",  p_perl_fu_prep4gif_iter_ALT }                          */
comment|/*, { "perl_fu_scratches",  p_perl_fu_scratches_iter_ALT }                        */
comment|/*, { "perl_fu_terraltext",  p_perl_fu_terraltext_iter_ALT }                      */
comment|/*, { "perl_fu_tex_string_to_float",  p_perl_fu_tex_string_to_float_iter_ALT }    */
comment|/*, { "perl_fu_webify",  p_perl_fu_webify_iter_ALT }                              */
comment|/*, { "perl_fu_windify",  p_perl_fu_windify_iter_ALT }                            */
comment|/*, { "perl_fu_xach_blocks",  p_perl_fu_xach_blocks_iter_ALT }                    */
comment|/*, { "perl_fu_xach_shadows",  p_perl_fu_xach_shadows_iter_ALT }                  */
comment|/*, { "perl_fu_xachvision",  p_perl_fu_xachvision_iter_ALT }                      */
block|{
literal|"plug_in_CML_explorer"
block|,
name|p_plug_in_CML_explorer_iter_ALT
block|}
block|,
block|{
literal|"plug_in_CentralReflection"
block|,
name|p_plug_in_CentralReflection_iter_ALT
block|}
block|,
block|{
literal|"plug_in_Twist"
block|,
name|p_plug_in_Twist_iter_ALT
block|}
block|,
block|{
literal|"plug_in_alienmap"
block|,
name|p_plug_in_alienmap_iter_ALT
block|}
comment|/*, { "plug_in_align_layers",  p_plug_in_align_layers_iter_ALT }                  */
block|,
block|{
literal|"plug_in_alpha2color"
block|,
name|p_plug_in_alpha2color_iter_ALT
block|}
block|,
block|{
literal|"plug_in_anamorphose"
block|,
name|p_plug_in_anamorphose_iter_ALT
block|}
comment|/*, { "plug_in_animationoptimize",  p_plug_in_animationoptimize_iter_ALT }        */
comment|/*, { "plug_in_animationplay",  p_plug_in_animationplay_iter_ALT }                */
comment|/*, { "plug_in_animationunoptimize",  p_plug_in_animationunoptimize_iter_ALT }    */
comment|/*, { "plug_in_apply_canvas",  p_plug_in_apply_canvas_iter_ALT }                  */
block|,
block|{
literal|"plug_in_applylens"
block|,
name|p_plug_in_applylens_iter_ALT
block|}
comment|/*, { "plug_in_autocrop",  p_plug_in_autocrop_iter_ALT }                          */
comment|/*, { "plug_in_autostretch_hsv",  p_plug_in_autostretch_hsv_iter_ALT }            */
block|,
block|{
literal|"plug_in_blinds"
block|,
name|p_plug_in_blinds_iter_ALT
block|}
block|,
block|{
literal|"plug_in_blur"
block|,
name|p_plug_in_blur_iter_ALT
block|}
block|,
block|{
literal|"plug_in_blur2"
block|,
name|p_plug_in_blur2_iter_ALT
block|}
comment|/*, { "plug_in_blur_randomize",  p_plug_in_blur_randomize_iter_ALT }              */
block|,
block|{
literal|"plug_in_borderaverage"
block|,
name|p_plug_in_borderaverage_iter_ALT
block|}
block|,
block|{
literal|"plug_in_bump_map"
block|,
name|p_plug_in_bump_map_iter_ALT
block|}
comment|/*, { "plug_in_c_astretch",  p_plug_in_c_astretch_iter_ALT }                      */
block|,
block|{
literal|"plug_in_checkerboard"
block|,
name|p_plug_in_checkerboard_iter_ALT
block|}
comment|/*, { "plug_in_color_adjust",  p_plug_in_color_adjust_iter_ALT }                  */
block|,
block|{
literal|"plug_in_color_map"
block|,
name|p_plug_in_color_map_iter_ALT
block|}
block|,
block|{
literal|"plug_in_colorify"
block|,
name|p_plug_in_colorify_iter_ALT
block|}
comment|/*, { "plug_in_compose",  p_plug_in_compose_iter_ALT }                            */
block|,
block|{
literal|"plug_in_convmatrix"
block|,
name|p_plug_in_convmatrix_iter_ALT
block|}
block|,
block|{
literal|"plug_in_cubism"
block|,
name|p_plug_in_cubism_iter_ALT
block|}
comment|/*, { "plug_in_decompose",  p_plug_in_decompose_iter_ALT }                        */
comment|/*, { "plug_in_deinterlace",  p_plug_in_deinterlace_iter_ALT }                    */
block|,
block|{
literal|"plug_in_depth_merge"
block|,
name|p_plug_in_depth_merge_iter_ALT
block|}
block|,
block|{
literal|"plug_in_despeckle"
block|,
name|p_plug_in_despeckle_iter_ALT
block|}
block|,
block|{
literal|"plug_in_destripe"
block|,
name|p_plug_in_destripe_iter_ALT
block|}
block|,
block|{
literal|"plug_in_diffraction"
block|,
name|p_plug_in_diffraction_iter_ALT
block|}
block|,
block|{
literal|"plug_in_displace"
block|,
name|p_plug_in_displace_iter_ALT
block|}
comment|/*, { "plug_in_ditherize",  p_plug_in_ditherize_iter_ALT }                        */
block|,
block|{
literal|"plug_in_edge"
block|,
name|p_plug_in_edge_iter_ALT
block|}
block|,
block|{
literal|"plug_in_emboss"
block|,
name|p_plug_in_emboss_iter_ALT
block|}
block|,
block|{
literal|"plug_in_encript"
block|,
name|p_plug_in_encript_iter_ALT
block|}
block|,
block|{
literal|"plug_in_engrave"
block|,
name|p_plug_in_engrave_iter_ALT
block|}
comment|/*    , { "plug_in_exchange",  p_plug_in_exchange_iter_ALT } */
comment|/*, { "plug_in_export_palette",  p_plug_in_export_palette_iter_ALT }              */
block|,
block|{
literal|"plug_in_figures"
block|,
name|p_plug_in_figures_iter_ALT
block|}
comment|/*, { "plug_in_film",  p_plug_in_film_iter_ALT }                                  */
comment|/*, { "plug_in_filter_pack",  p_plug_in_filter_pack_iter_ALT }                    */
block|,
block|{
literal|"plug_in_flame"
block|,
name|p_plug_in_flame_iter_ALT
block|}
block|,
block|{
literal|"plug_in_flarefx"
block|,
name|p_plug_in_flarefx_iter_ALT
block|}
block|,
block|{
literal|"plug_in_fractal_trace"
block|,
name|p_plug_in_fractal_trace_iter_ALT
block|}
block|,
block|{
literal|"plug_in_gauss_iir"
block|,
name|p_plug_in_gauss_iir_iter_ALT
block|}
block|,
block|{
literal|"plug_in_gauss_iir2"
block|,
name|p_plug_in_gauss_iir2_iter_ALT
block|}
block|,
block|{
literal|"plug_in_gauss_rle"
block|,
name|p_plug_in_gauss_rle_iter_ALT
block|}
block|,
block|{
literal|"plug_in_gauss_rle2"
block|,
name|p_plug_in_gauss_rle2_iter_ALT
block|}
block|,
block|{
literal|"plug_in_gfig"
block|,
name|p_plug_in_gfig_iter_ALT
block|}
block|,
block|{
literal|"plug_in_gflare"
block|,
name|p_plug_in_gflare_iter_ALT
block|}
block|,
block|{
literal|"plug_in_glasstile"
block|,
name|p_plug_in_glasstile_iter_ALT
block|}
comment|/*, { "plug_in_gradmap",  p_plug_in_gradmap_iter_ALT }                            */
block|,
block|{
literal|"plug_in_grid"
block|,
name|p_plug_in_grid_iter_ALT
block|}
comment|/*, { "plug_in_guillotine",  p_plug_in_guillotine_iter_ALT }                      */
block|,
block|{
literal|"plug_in_holes"
block|,
name|p_plug_in_holes_iter_ALT
block|}
comment|/*, { "plug_in_hot",  p_plug_in_hot_iter_ALT }                                    */
comment|/*, { "plug_in_ifs_compose",  p_plug_in_ifs_compose_iter_ALT }                    */
comment|/*, { "plug_in_illusion",  p_plug_in_illusion_iter_ALT }                          */
comment|/*, { "plug_in_image_rot270",  p_plug_in_image_rot270_iter_ALT }                  */
comment|/*, { "plug_in_image_rot90",  p_plug_in_image_rot90_iter_ALT }                    */
comment|/*, { "plug_in_iwarp",  p_plug_in_iwarp_iter_ALT }                                */
block|,
block|{
literal|"plug_in_jigsaw"
block|,
name|p_plug_in_jigsaw_iter_ALT
block|}
block|,
block|{
literal|"plug_in_julia"
block|,
name|p_plug_in_julia_iter_ALT
block|}
comment|/*, { "plug_in_laplace",  p_plug_in_laplace_iter_ALT }                            */
comment|/*, { "plug_in_layer_rot270",  p_plug_in_layer_rot270_iter_ALT }                  */
comment|/*, { "plug_in_layer_rot90",  p_plug_in_layer_rot90_iter_ALT }                    */
comment|/*, { "plug_in_layers_import",  p_plug_in_layers_import_iter_ALT }                */
comment|/*, { "plug_in_lic",  p_plug_in_lic_iter_ALT }                                    */
block|,
block|{
literal|"plug_in_lighting"
block|,
name|p_plug_in_lighting_iter_ALT
block|}
block|,
block|{
literal|"plug_in_magic_eye"
block|,
name|p_plug_in_magic_eye_iter_ALT
block|}
comment|/*, { "plug_in_mail_image",  p_plug_in_mail_image_iter_ALT }                      */
comment|/*, { "plug_in_make_seamless",  p_plug_in_make_seamless_iter_ALT }                */
block|,
block|{
literal|"plug_in_mandelbrot"
block|,
name|p_plug_in_mandelbrot_iter_ALT
block|}
block|,
block|{
literal|"plug_in_map_object"
block|,
name|p_plug_in_map_object_iter_ALT
block|}
comment|/*, { "plug_in_max_rgb",  p_plug_in_max_rgb_iter_ALT }                            */
block|,
block|{
literal|"plug_in_maze"
block|,
name|p_plug_in_maze_iter_ALT
block|}
block|,
block|{
literal|"plug_in_mblur"
block|,
name|p_plug_in_mblur_iter_ALT
block|}
block|,
block|{
literal|"plug_in_mosaic"
block|,
name|p_plug_in_mosaic_iter_ALT
block|}
block|,
block|{
literal|"plug_in_newsprint"
block|,
name|p_plug_in_newsprint_iter_ALT
block|}
block|,
block|{
literal|"plug_in_nlfilt"
block|,
name|p_plug_in_nlfilt_iter_ALT
block|}
block|,
block|{
literal|"plug_in_noisify"
block|,
name|p_plug_in_noisify_iter_ALT
block|}
comment|/*, { "plug_in_normalize",  p_plug_in_normalize_iter_ALT }                        */
block|,
block|{
literal|"plug_in_nova"
block|,
name|p_plug_in_nova_iter_ALT
block|}
block|,
block|{
literal|"plug_in_oilify"
block|,
name|p_plug_in_oilify_iter_ALT
block|}
block|,
block|{
literal|"plug_in_pagecurl"
block|,
name|p_plug_in_pagecurl_iter_ALT
block|}
block|,
block|{
literal|"plug_in_papertile"
block|,
name|p_plug_in_papertile_iter_ALT
block|}
block|,
block|{
literal|"plug_in_pixelize"
block|,
name|p_plug_in_pixelize_iter_ALT
block|}
block|,
block|{
literal|"plug_in_plasma"
block|,
name|p_plug_in_plasma_iter_ALT
block|}
block|,
block|{
literal|"plug_in_polar_coords"
block|,
name|p_plug_in_polar_coords_iter_ALT
block|}
comment|/*, { "plug_in_qbist",  p_plug_in_qbist_iter_ALT }                                */
block|,
block|{
literal|"plug_in_randomize"
block|,
name|p_plug_in_randomize_iter_ALT
block|}
block|,
block|{
literal|"plug_in_randomize_hurl"
block|,
name|p_plug_in_randomize_hurl_iter_ALT
block|}
block|,
block|{
literal|"plug_in_randomize_pick"
block|,
name|p_plug_in_randomize_pick_iter_ALT
block|}
block|,
block|{
literal|"plug_in_randomize_slur"
block|,
name|p_plug_in_randomize_slur_iter_ALT
block|}
block|,
block|{
literal|"plug_in_refract"
block|,
name|p_plug_in_refract_iter_ALT
block|}
block|,
block|{
literal|"plug_in_ripple"
block|,
name|p_plug_in_ripple_iter_ALT
block|}
block|,
block|{
literal|"plug_in_rotate"
block|,
name|p_plug_in_rotate_iter_ALT
block|}
block|,
block|{
literal|"plug_in_sample_colorize"
block|,
name|p_plug_in_sample_colorize_iter_ALT
block|}
block|,
block|{
literal|"plug_in_scatter_hsv"
block|,
name|p_plug_in_scatter_hsv_iter_ALT
block|}
comment|/*, { "plug_in_semiflatten",  p_plug_in_semiflatten_iter_ALT }                    */
block|,
block|{
literal|"plug_in_sharpen"
block|,
name|p_plug_in_sharpen_iter_ALT
block|}
block|,
block|{
literal|"plug_in_shift"
block|,
name|p_plug_in_shift_iter_ALT
block|}
block|,
block|{
literal|"plug_in_sinus"
block|,
name|p_plug_in_sinus_iter_ALT
block|}
comment|/*, { "plug_in_small_tiles",  p_plug_in_small_tiles_iter_ALT }                    */
comment|/*, { "plug_in_smooth_palette",  p_plug_in_smooth_palette_iter_ALT }              */
comment|/*, { "plug_in_sobel",  p_plug_in_sobel_iter_ALT }                                */
block|,
block|{
literal|"plug_in_solid_noise"
block|,
name|p_plug_in_solid_noise_iter_ALT
block|}
block|,
block|{
literal|"plug_in_sparkle"
block|,
name|p_plug_in_sparkle_iter_ALT
block|}
block|,
block|{
literal|"plug_in_spread"
block|,
name|p_plug_in_spread_iter_ALT
block|}
block|,
block|{
literal|"plug_in_struc"
block|,
name|p_plug_in_struc_iter_ALT
block|}
comment|/*, { "plug_in_the_egg",  p_plug_in_the_egg_iter_ALT }                            */
comment|/*, { "plug_in_threshold_alpha",  p_plug_in_threshold_alpha_iter_ALT }            */
comment|/*, { "plug_in_tile",  p_plug_in_tile_iter_ALT }                                  */
block|,
block|{
literal|"plug_in_tileit"
block|,
name|p_plug_in_tileit_iter_ALT
block|}
block|,
block|{
literal|"plug_in_universal_filter"
block|,
name|p_plug_in_universal_filter_iter_ALT
block|}
block|,
block|{
literal|"plug_in_video"
block|,
name|p_plug_in_video_iter_ALT
block|}
comment|/*, { "plug_in_vinvert",  p_plug_in_vinvert_iter_ALT }                            */
block|,
block|{
literal|"plug_in_vpropagate"
block|,
name|p_plug_in_vpropagate_iter_ALT
block|}
block|,
block|{
literal|"plug_in_warp"
block|,
name|p_plug_in_warp_iter_ALT
block|}
block|,
block|{
literal|"plug_in_waves"
block|,
name|p_plug_in_waves_iter_ALT
block|}
block|,
block|{
literal|"plug_in_whirl_pinch"
block|,
name|p_plug_in_whirl_pinch_iter_ALT
block|}
block|,
block|{
literal|"plug_in_wind"
block|,
name|p_plug_in_wind_iter_ALT
block|}
comment|/*, { "plug_in_zealouscrop",  p_plug_in_zealouscrop_iter_ALT }                    */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end g_iter_ALT_tab */
end_comment

begin_define
DECL|macro|MAX_ITER_ALT
define|#
directive|define
name|MAX_ITER_ALT
value|( sizeof(g_iter_ALT_tab) / sizeof(t_iter_ALT_tab) )
end_define

begin_comment
comment|/* ----------------------------------------------------------------------   * install (query) iterators_ALT  * ----------------------------------------------------------------------   */
end_comment

begin_function
DECL|function|p_install_proc_iter_ALT (char * name)
specifier|static
name|void
name|p_install_proc_iter_ALT
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|gchar
modifier|*
name|l_iter_proc_name
decl_stmt|;
name|gchar
modifier|*
name|l_blurb_text
decl_stmt|;
specifier|static
name|GimpParamDef
name|args_iter
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"total_steps"
block|,
literal|"total number of steps (# of layers-1 to apply the related plug-in)"
block|}
block|,
block|{
name|GIMP_PDB_FLOAT
block|,
literal|"current_step"
block|,
literal|"current (for linear iterations this is the layerstack position, otherwise some value inbetween)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"len_struct"
block|,
literal|"length of stored data structure with id is equal to the plug_in  proc_name"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GimpParamDef
modifier|*
name|return_vals
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|nreturn_vals
init|=
literal|0
decl_stmt|;
name|l_iter_proc_name
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s_Iterator_ALT"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|l_blurb_text
operator|=
name|g_strdup_printf
argument_list|(
literal|"This extension calculates the modified values for one iterationstep for the call of %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
name|l_iter_proc_name
argument_list|,
name|l_blurb_text
argument_list|,
literal|""
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"Feb. 2000"
argument_list|,
name|NULL
argument_list|,
comment|/* do not appear in menus */
name|NULL
argument_list|,
name|GIMP_EXTENSION
argument_list|,
name|G_N_ELEMENTS
argument_list|(
name|args_iter
argument_list|)
argument_list|,
name|nreturn_vals
argument_list|,
name|args_iter
argument_list|,
name|return_vals
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_iter_proc_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_blurb_text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|gap_query_iterators_ALT ()
name|void
name|gap_query_iterators_ALT
parameter_list|()
block|{
name|int
name|l_idx
decl_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|MAX_ITER_ALT
condition|;
name|l_idx
operator|++
control|)
block|{
name|p_install_proc_iter_ALT
argument_list|(
name|g_iter_ALT_tab
index|[
name|l_idx
index|]
operator|.
name|proc_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------   * run iterators_ALT  * ----------------------------------------------------------------------   */
end_comment

begin_function
DECL|function|gap_run_iterators_ALT (char * name,GimpRunModeType run_mode,gint32 total_steps,gdouble current_step,gint32 len_struct)
name|gint
name|gap_run_iterators_ALT
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|total_steps
parameter_list|,
name|gdouble
name|current_step
parameter_list|,
name|gint32
name|len_struct
parameter_list|)
block|{
name|gint
name|l_rc
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|char
modifier|*
name|l_name
decl_stmt|;
name|int
name|l_cut
decl_stmt|;
name|l_name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|l_cut
operator|=
name|strlen
argument_list|(
name|l_name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"_Iterator_ALT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_cut
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: gap_run_iterators_ALT: proc_name ending _Iterator_ALT missing%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|l_name
index|[
name|l_cut
index|]
argument_list|,
literal|"_Iterator_ALT"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: gap_run_iterators_ALT: proc_name ending _Iterator_ALT missing%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_name
index|[
name|l_cut
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* cut off "_Iterator_ALT" from l_name end */
comment|/* allocate from/to plugin_data buffers     * as big as needed for the current plugin named l_name    */
name|g_plugin_data_from
operator|=
name|p_alloc_plugin_data
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
name|g_plugin_data_to
operator|=
name|p_alloc_plugin_data
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g_plugin_data_from
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g_plugin_data_to
operator|!=
name|NULL
operator|)
condition|)
block|{
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|MAX_ITER_ALT
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|l_name
argument_list|,
name|g_iter_ALT_tab
index|[
name|l_idx
index|]
operator|.
name|proc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: gap_run_iterators_ALT: FOUND %s\n"
argument_list|,
name|l_name
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|(
name|g_iter_ALT_tab
index|[
name|l_idx
index|]
operator|.
name|proc_func
operator|)
operator|(
name|run_mode
operator|,
name|total_steps
operator|,
name|current_step
operator|,
name|len_struct
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: gap_run_iterators_ALT: NOT FOUND proc_name=%s (%s)\n"
argument_list|,
name|name
argument_list|,
name|l_name
argument_list|)
expr_stmt|;
comment|/* free from/to plugin_data buffers */
if|if
condition|(
name|g_plugin_data_from
condition|)
name|g_free
argument_list|(
name|g_plugin_data_from
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_plugin_data_to
condition|)
name|g_free
argument_list|(
name|g_plugin_data_to
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

end_unit

