begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_pdb_calls.c  *  * this module contains calls of procedures in the GIMPs Procedural Database  *   * IMPORTANT Notes:  *   some Procedures have changed their Interface from GIMP 1.0.2 to GIMP 1.1  *   in that cases the procedure parameters are checked and the call is done  *   in 1.0.2 or 1.1 style repectivly.  *  *   some of these procedures are not available in the official GIMP 1.0.2 releases  *   (and prior releases)  *  *   The missing procedures (except guides) are available as patches to the gimp core.  *   If you dont install the patches GAP will NOT work on GIMP 1.0.2 and older versions.  *  * GIMP 1.1 will provide all the procedures to run GAP at full fuctionality.  * There are no Patches required to run GAP in the latest GIMP 1.1  * development version  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history:  * version 0.98.00; 1998/11/28  hof: 1.st (pre) release (GAP port to GIMP 1.1)  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_pdb_calls.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ============================================================================  * p_pdb_procedure_available  *   if requested procedure is available in the PDB return the number of args  *      (0 upto n) that are needed to call the procedure.  *   if not available return -1  * ============================================================================  */
end_comment

begin_function
DECL|function|p_pdb_procedure_available (char * proc_name)
name|gint
name|p_pdb_procedure_available
parameter_list|(
name|char
modifier|*
name|proc_name
parameter_list|)
block|{
comment|/* Note: It would be nice to call "gimp_layer_get_linked" direct,     *       but there is not such an Interface in gimp 0.99.16     * Workaround:     *   I did a patch to implement the "gimp_layer_get_linked"     *   procedure, and call it via PDB call if available.     *   if not available FALSE is returned.     */
name|int
name|l_nparams
decl_stmt|;
name|int
name|l_nreturn_vals
decl_stmt|;
name|int
name|l_proc_type
decl_stmt|;
name|char
modifier|*
name|l_proc_blurb
decl_stmt|;
name|char
modifier|*
name|l_proc_help
decl_stmt|;
name|char
modifier|*
name|l_proc_author
decl_stmt|;
name|char
modifier|*
name|l_proc_copyright
decl_stmt|;
name|char
modifier|*
name|l_proc_date
decl_stmt|;
name|GParamDef
modifier|*
name|l_params
decl_stmt|;
name|GParamDef
modifier|*
name|l_return_vals
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
comment|/* Query the gimp application's procedural database    *  regarding a particular procedure.    */
if|if
condition|(
name|gimp_query_procedure
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_proc_blurb
argument_list|,
operator|&
name|l_proc_help
argument_list|,
operator|&
name|l_proc_author
argument_list|,
operator|&
name|l_proc_copyright
argument_list|,
operator|&
name|l_proc_date
argument_list|,
operator|&
name|l_proc_type
argument_list|,
operator|&
name|l_nparams
argument_list|,
operator|&
name|l_nreturn_vals
argument_list|,
operator|&
name|l_params
argument_list|,
operator|&
name|l_return_vals
argument_list|)
condition|)
block|{
comment|/* procedure found in PDB */
return|return
operator|(
name|l_nparams
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Warning: Procedure %s not found.\n"
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* end p_pdb_procedure_available */
end_comment

begin_comment
comment|/* ---------------------- PDB procedure calls  -------------------------- */
end_comment

begin_comment
comment|/* ============================================================================  * p_get_gimp_selection_bounds  *     * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_get_gimp_selection_bounds (gint32 image_id,gint32 * x1,gint32 * y1,gint32 * x2,gint32 * y2)
name|p_get_gimp_selection_bounds
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
modifier|*
name|x1
parameter_list|,
name|gint32
modifier|*
name|y1
parameter_list|,
name|gint32
modifier|*
name|x2
parameter_list|,
name|gint32
modifier|*
name|y2
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_get_sel_bounds_proc
init|=
literal|"gimp_selection_bounds"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_get_sel_bounds_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_get_sel_bounds_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
operator|*
name|x1
operator|=
name|return_vals
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|y1
operator|=
name|return_vals
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|x2
operator|=
name|return_vals
index|[
literal|4
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|y2
operator|=
name|return_vals
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed staus=%d\n"
argument_list|,
name|l_get_sel_bounds_proc
argument_list|,
operator|(
name|int
operator|)
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Error: Procedure %s not found.\n"
argument_list|,
name|l_get_sel_bounds_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_get_gimp_selection_bounds */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_selection_load  *     * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_gimp_selection_load (gint32 image_id,gint32 channel_id)
name|p_gimp_selection_load
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|channel_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_sel_load
init|=
literal|"gimp_selection_load"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|int
name|l_nparams
decl_stmt|;
name|l_nparams
operator|=
name|p_pdb_procedure_available
argument_list|(
name|l_sel_load
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_nparams
operator|>=
literal|0
condition|)
block|{
comment|/* check if it can take exactly one channel_id as input (gimp1.1) */
if|if
condition|(
name|l_nparams
operator|==
literal|1
condition|)
block|{
comment|/* use the new Interface (Gimp 1.1 style)           * (1.1 knows the image_id where the channel belongs to)           */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_sel_load
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_CHANNEL
argument_list|,
name|channel_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use the old Interface (Gimp 1.0.2 style) */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_sel_load
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_CHANNEL
argument_list|,
name|channel_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed status=%d\n"
argument_list|,
name|l_sel_load
argument_list|,
operator|(
name|int
operator|)
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Error: Procedure %s not found.\n"
argument_list|,
name|l_sel_load
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_selection_load */
end_comment

begin_comment
comment|/* ============================================================================  * p_layer_set_linked  *   set linked state of the layer  * ============================================================================  */
end_comment

begin_function
name|int
DECL|function|p_layer_set_linked (gint32 layer_id,gint32 new_state)
name|p_layer_set_linked
parameter_list|(
name|gint32
name|layer_id
parameter_list|,
name|gint32
name|new_state
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_set_linked_proc
init|=
literal|"gimp_layer_set_linked"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_set_linked_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_set_linked_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_LAYER
argument_list|,
name|layer_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|new_state
argument_list|,
comment|/* TRUE or FALSE */
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: p_layer_set_linked to state %d failed\n"
argument_list|,
operator|(
name|int
operator|)
name|new_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. (Layer Can not be set to linked)\n"
argument_list|,
name|l_set_linked_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_layer_set_linked */
end_comment

begin_comment
comment|/* ============================================================================  * p_layer_get_linked  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_layer_get_linked (gint32 layer_id)
name|gint
name|p_layer_get_linked
parameter_list|(
name|gint32
name|layer_id
parameter_list|)
block|{
comment|/* Note: The Procedure "gimp_layer_get_linked" is part of GIMP 1.1     *       but there is not such an Interface in gimp 1.0.2     */
specifier|static
name|char
modifier|*
name|l_get_linked_proc
init|=
literal|"gimp_layer_get_linked"
decl_stmt|;
name|int
name|l_nparams
decl_stmt|;
name|int
name|l_nreturn_vals
decl_stmt|;
name|int
name|l_proc_type
decl_stmt|;
name|char
modifier|*
name|l_proc_blurb
decl_stmt|;
name|char
modifier|*
name|l_proc_help
decl_stmt|;
name|char
modifier|*
name|l_proc_author
decl_stmt|;
name|char
modifier|*
name|l_proc_copyright
decl_stmt|;
name|char
modifier|*
name|l_proc_date
decl_stmt|;
name|GParamDef
modifier|*
name|l_params
decl_stmt|;
name|GParamDef
modifier|*
name|l_return_vals
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|gint32
name|is_linked
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
comment|/* Query the gimp application's procedural database    *  regarding a particular procedure.    */
if|if
condition|(
name|gimp_query_procedure
argument_list|(
name|l_get_linked_proc
argument_list|,
operator|&
name|l_proc_blurb
argument_list|,
operator|&
name|l_proc_help
argument_list|,
operator|&
name|l_proc_author
argument_list|,
operator|&
name|l_proc_copyright
argument_list|,
operator|&
name|l_proc_date
argument_list|,
operator|&
name|l_proc_type
argument_list|,
operator|&
name|l_nparams
argument_list|,
operator|&
name|l_nreturn_vals
argument_list|,
operator|&
name|l_params
argument_list|,
operator|&
name|l_return_vals
argument_list|)
condition|)
block|{
comment|/* procedure found in PDB */
comment|/* check if it can take exactly one layerid as input       * and give one result int32 parameter (TRUE/FALSE)       */
if|if
condition|(
name|l_nparams
operator|!=
literal|1
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|PARAM_LAYER
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_nreturn_vals
operator|!=
literal|1
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_return_vals
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|PARAM_INT32
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/*  free the query information  */
name|g_free
argument_list|(
name|l_proc_blurb
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_help
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_author
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_copyright
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_date
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_return_vals
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: Procedure %s has unexpected Interface. (Can not operate on linked layers)\n"
argument_list|,
name|l_get_linked_proc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"expected: 1, 1, PARAM_LAYER = %d  PARAM_INT32 = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|PARAM_LAYER
argument_list|,
operator|(
name|int
operator|)
name|PARAM_INT32
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l_nparams = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_nparams
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l_nreturn_vals = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_nreturn_vals
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l_params[0].type = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_params
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l_return_vals[0].type = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_return_vals
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Warning: Procedure %s not found. (Can not operate on linked layers)\n"
argument_list|,
name|l_get_linked_proc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* run the procedure */
name|is_linked
operator|=
name|FALSE
expr_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_get_linked_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_LAYER
argument_list|,
name|layer_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
name|is_linked
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|is_linked
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_gimp_image_floating_sel_attached_to  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_image_floating_sel_attached_to (gint32 image_id)
name|gint32
name|p_gimp_image_floating_sel_attached_to
parameter_list|(
name|gint32
name|image_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_fsel_attached_to_proc
init|=
literal|"gimp_image_floating_sel_attached_to"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_fsel_attached_to_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_fsel_attached_to_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_drawable
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_fsel_attached_to_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_fsel_attached_to_proc
argument_list|,
literal|"(cant find out drawable where f-sel is attached to)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_image_floating_sel_attached_to */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_floating_sel_attach  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_floating_sel_attach (gint32 layer_id,gint32 drawable_id)
name|gint
name|p_gimp_floating_sel_attach
parameter_list|(
name|gint32
name|layer_id
parameter_list|,
name|gint32
name|drawable_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_fsel_attach_proc
init|=
literal|"gimp_floating_sel_attach"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_fsel_attach_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_fsel_attach_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_LAYER
argument_list|,
name|layer_id
argument_list|,
name|PARAM_DRAWABLE
argument_list|,
name|drawable_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_fsel_attach_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_fsel_attach_proc
argument_list|,
literal|"(cannot attach floating selection)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_floating_sel_attach */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_floating_sel_rigor  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_floating_sel_rigor (gint32 layer_id,gint32 undo)
name|gint
name|p_gimp_floating_sel_rigor
parameter_list|(
name|gint32
name|layer_id
parameter_list|,
name|gint32
name|undo
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_fsel_rigor_proc
init|=
literal|"gimp_floating_sel_rigor"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_fsel_rigor_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_fsel_rigor_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_LAYER
argument_list|,
name|layer_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|undo
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_fsel_rigor_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_fsel_rigor_proc
argument_list|,
literal|"(cannot attach floating selection)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_floating_sel_rigor */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_floating_sel_relax  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_floating_sel_relax (gint32 layer_id,gint32 undo)
name|gint
name|p_gimp_floating_sel_relax
parameter_list|(
name|gint32
name|layer_id
parameter_list|,
name|gint32
name|undo
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_fsel_relax_proc
init|=
literal|"gimp_floating_sel_relax"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_fsel_relax_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_fsel_relax_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_LAYER
argument_list|,
name|layer_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|undo
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_fsel_relax_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_fsel_relax_proc
argument_list|,
literal|"(cannot attach floating selection)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_floating_sel_relax */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_image_add_guide  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_image_add_guide (gint32 image_id,gint32 position,gint32 orientation)
name|gint32
name|p_gimp_image_add_guide
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|position
parameter_list|,
name|gint32
name|orientation
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_add_guide_proc
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
literal|0
condition|)
comment|/* in GIMP 1.1 we could use (orientation == ORIENTATION_VERTICAL) */
block|{
name|l_add_guide_proc
operator|=
literal|"gimp_image_add_vguide"
expr_stmt|;
block|}
else|else
block|{
name|l_add_guide_proc
operator|=
literal|"gimp_image_add_hguide"
expr_stmt|;
block|}
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_add_guide_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_add_guide_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|position
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
return|;
comment|/* return the guide ID */
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_add_guide_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_add_guide_proc
argument_list|,
literal|"(cannot add guide)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_image_add_guide */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_image_findnext_guide  *  * This procedure takes an image and a guide_id as input and finds the guide_id  * of the successor of the given guide_id in the image's Guide list.  * If the supplied guide_id is 0, the procedure will return the first Guide.  * The procedure will return 0 if given the final guide_id as an argument   * or the image has no guides.  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_image_findnext_guide (gint32 image_id,gint32 guide_id)
name|gint32
name|p_gimp_image_findnext_guide
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|guide_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_findnext_guide_proc
init|=
literal|"gimp_image_find_next_guide"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_findnext_guide_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_findnext_guide_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|guide_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
return|;
comment|/* return the next guide ID */
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_findnext_guide_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_findnext_guide_proc
argument_list|,
literal|"(if image has guides they are not saved)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_image_findnext_guide */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_image_get_guide_position  *  * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_image_get_guide_position (gint32 image_id,gint32 guide_id)
name|gint32
name|p_gimp_image_get_guide_position
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|guide_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_get_guide_pos_proc
init|=
literal|"gimp_image_get_guide_position"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_get_guide_pos_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_get_guide_pos_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|guide_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
return|;
comment|/* return the guide position */
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_get_guide_pos_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_get_guide_pos_proc
argument_list|,
literal|"(cannot save guides)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_image_get_guide_position */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_image_get_guide_orientation  *  * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_image_get_guide_orientation (gint32 image_id,gint32 guide_id)
name|gint32
name|p_gimp_image_get_guide_orientation
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|guide_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_get_guide_pos_orient
init|=
literal|"gimp_image_get_guide_orientation"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_get_guide_pos_orient
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_get_guide_pos_orient
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|guide_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
return|;
comment|/* return the guide orientation */
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_get_guide_pos_orient
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_get_guide_pos_orient
argument_list|,
literal|"(cannot save guides)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_image_get_guide_orientation */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_image_delete_guide  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_image_delete_guide (gint32 image_id,gint32 guide_id)
name|gint32
name|p_gimp_image_delete_guide
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|guide_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_delete_guide_proc
init|=
literal|"gimp_image_delete_guide"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_delete_guide_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_delete_guide_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|guide_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
return|;
comment|/* return the next guide ID */
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_delete_guide_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_delete_guide_proc
argument_list|,
literal|"(cant remove old guides)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_image_delete_guide */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_selection_none  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_selection_none (gint32 image_id)
name|gint
name|p_gimp_selection_none
parameter_list|(
name|gint32
name|image_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_sel_none_proc
init|=
literal|"gimp_selection_none"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_sel_none_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_sel_none_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_sel_none_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_sel_none_proc
argument_list|,
literal|"(cannot remove selection)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_selection_none */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_rotate  *  PDB call of 'gimp_rotate'  * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_rotate (gint32 image_id,gint32 drawable_id,gint32 interpolation,gdouble angle_deg)
name|gint
name|p_gimp_rotate
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|drawable_id
parameter_list|,
name|gint32
name|interpolation
parameter_list|,
name|gdouble
name|angle_deg
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_rotate_proc
init|=
literal|"gimp_rotate"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|gdouble
name|l_angle_rad
decl_stmt|;
name|int
name|l_nparams
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_angle_rad
operator|=
operator|(
name|angle_deg
operator|*
literal|3.14159
operator|)
operator|/
literal|180.0
expr_stmt|;
name|l_nparams
operator|=
name|p_pdb_procedure_available
argument_list|(
name|l_rotate_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_nparams
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|l_nparams
operator|==
literal|3
condition|)
block|{
comment|/* use the new Interface (Gimp 1.1 style)           * (1.1 knows the image_id where the drawable belongs to)           */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_rotate_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_DRAWABLE
argument_list|,
name|drawable_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|interpolation
argument_list|,
name|PARAM_FLOAT
argument_list|,
name|l_angle_rad
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use the old Interface (Gimp 1.0.2 style) */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_rotate_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_DRAWABLE
argument_list|,
name|drawable_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|interpolation
argument_list|,
name|PARAM_FLOAT
argument_list|,
name|l_angle_rad
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"gap: %s call failed %d\n"
argument_list|,
name|l_rotate_proc
argument_list|,
operator|(
name|int
operator|)
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
argument_list|)
expr_stmt|;
block|}
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Error: Procedure %s not found.\n"
argument_list|,
name|l_rotate_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_rotate */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_channel_ops_duplicate  *   call gimp_channel_ops_duplicate via procedural database  *   (i could not find a direct call interface in gimp0.99.15)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_channel_ops_duplicate (gint32 image_ID)
name|gint32
name|p_gimp_channel_ops_duplicate
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|gint32
name|new_image_ID
decl_stmt|;
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_channel_ops_duplicate"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
name|new_image_ID
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
name|new_image_ID
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|return_vals
argument_list|,
name|nreturn_vals
argument_list|)
expr_stmt|;
return|return
name|new_image_ID
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_channel_ops_duplicate */
end_comment

begin_comment
comment|/* ============================================================================  * p_gimp_drawable_set_image  *     * ============================================================================  */
end_comment

begin_function
DECL|function|p_gimp_drawable_set_image (gint32 drawable_id,gint32 image_id)
name|gint
name|p_gimp_drawable_set_image
parameter_list|(
name|gint32
name|drawable_id
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_drawable_set_img_proc
init|=
literal|"gimp_drawable_set_image"
decl_stmt|;
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
if|if
condition|(
name|p_pdb_procedure_available
argument_list|(
name|l_drawable_set_img_proc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
name|l_drawable_set_img_proc
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_DRAWABLE
argument_list|,
name|drawable_id
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_id
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GAP: Error: PDB call of %s failed\n"
argument_list|,
name|l_drawable_set_img_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"GAP: Warning: Procedure %s not found. %s\n"
argument_list|,
name|l_drawable_set_img_proc
argument_list|,
literal|"(cannot attach floating selection)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gimp_drawable_set_image */
end_comment

end_unit

