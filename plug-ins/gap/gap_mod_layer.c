begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_mod_layer.c  * 1998.10.14 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * This Module contains:  * modify Layer (perform actions (like raise, set visible, apply filter)  *               - foreach selected layer  *               - in each frame of the selected framerange)  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history:  * gimp   1.1.29b;   2000/11/30  hof: use g_snprintf  * gimp   1.1.28a;   2000/11/05  hof: check for GIMP_PDB_SUCCESS (not for FALSE)  * gimp   1.1.6;     1999/06/21  hof: bugix: wrong iterator total_steps and direction  * gimp   1.1.15.1;  1999/05/08  hof: bugix (dont mix GimpImageType with GimpImageBaseType)  * version 0.98.00   1998.11.27  hof: - use new module gap_pdb_calls.h  * version 0.97.00   1998.10.19  hof: - created module  */
end_comment

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_filter.h"
end_include

begin_include
include|#
directive|include
file|"gap_filter_pdb.h"
end_include

begin_include
include|#
directive|include
file|"gap_pdb_calls.h"
end_include

begin_include
include|#
directive|include
file|"gap_match.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_range_ops.h"
end_include

begin_include
include|#
directive|include
file|"gap_mod_layer.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_comment
comment|/* ============================================================================  * p_layer_modify_dialog  *   retcode      *               0   ... Generate Paramfile  *               1   ... Generate Paramfile and start mpeg_encode  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_layer_modify_dialog (t_anim_info * ainfo_ptr,gint32 * range_from,gint32 * range_to,gint32 * action_mode,gint32 * sel_mode,gint32 * sel_case,gint32 * sel_invert,char * sel_pattern,char * new_layername)
name|int
name|p_layer_modify_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|gint32
modifier|*
name|range_from
parameter_list|,
name|gint32
modifier|*
name|range_to
parameter_list|,
name|gint32
modifier|*
name|action_mode
parameter_list|,
name|gint32
modifier|*
name|sel_mode
parameter_list|,
name|gint32
modifier|*
name|sel_case
parameter_list|,
name|gint32
modifier|*
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|,
name|char
modifier|*
name|new_layername
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|9
index|]
decl_stmt|;
specifier|static
name|t_but_arg
name|b_argv
index|[
literal|2
index|]
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
comment|/* Layer select modes */
specifier|static
name|char
modifier|*
name|sel_args
index|[
literal|7
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Pattern is equal to LayerName"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is Start of LayerName"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is End of Layername"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is a Part of LayerName"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is LayerstackNumber List"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Pattern is REVERSE-stack List"
argument_list|)
block|,
name|N_
argument_list|(
literal|"All Visible (ignore Pattern)"
argument_list|)
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|sel_help
index|[
literal|7
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Select all Layers where Layername is equal to Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Select all Layers where Layername starts with Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Select all Layers where Layername ends up with Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Select all Layers where Layername contains Pattern"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Select Layerstack positions.\n0, 4-5, 8\nwhere 0 == Top-layer"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Select Layerstack positions.\n0, 4-5, 8\nwhere 0 == BG-layer"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Select all visible Layers"
argument_list|)
block|}
decl_stmt|;
comment|/* action items what to do with the selected layer(s) */
specifier|static
name|char
modifier|*
name|action_args
index|[
literal|13
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Set Layer(s) visible"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set Layer(s) invisible"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set Layer(s) linked"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set Layer(s) unlinked"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Raise Layer(s)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Lower Layer(s)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Merge Layer(s) expand as necessary"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Merge Layer(s) clipped to image"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Merge Layer(s) clipped to bg-layer"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Apply filter on Layer(s)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Duplicate Layer(s)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Delete Layer(s)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Rename Layer(s)"
argument_list|)
block|}
decl_stmt|;
comment|/*                                                                      static char *action_help[13]  = {"set all selected layers visible",                                   "set all selected layers  invisible",                                   "set all selected layers  linked",                                   "set all selected layers  unlinked",                                   "raise all selected layers",                                   "lower all selected layers",                                   "merge expand as necessary",                                   "merge clipped to image",                                   "merge clipped to bg-layer",                                   "APPLY FILTER to all selected layers",                                   "duplicate all selected layers",                                   "delete REMOVES all selected layers",                                   "rename all selected layers\nto NewLayername."                                   }; */
name|int
name|get_textize_loop
decl_stmt|;
for|for
control|(
name|get_textize_loop
operator|=
literal|0
init|;
name|get_textize_loop
operator|<
literal|7
condition|;
name|get_textize_loop
operator|++
control|)
block|{
name|sel_args
index|[
name|get_textize_loop
index|]
operator|=
name|gettext
argument_list|(
name|sel_args
index|[
name|get_textize_loop
index|]
argument_list|)
expr_stmt|;
name|sel_help
index|[
name|get_textize_loop
index|]
operator|=
name|gettext
argument_list|(
name|sel_help
index|[
name|get_textize_loop
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|get_textize_loop
operator|=
literal|0
init|;
name|get_textize_loop
operator|<
literal|13
condition|;
name|get_textize_loop
operator|++
control|)
name|action_args
index|[
name|get_textize_loop
index|]
operator|=
name|gettext
argument_list|(
name|action_args
index|[
name|get_textize_loop
index|]
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* the 3 Action Buttons */
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|GTK_STOCK_OK
expr_stmt|;
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|GTK_STOCK_CANCEL
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Perform function on one or more Layer(s)\nin all frames of the selected frame range\n"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From Frame:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"first handled frame"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To Frame:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"last handled frame"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
comment|/* Layer select mode RADIO buttons */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_RADIO
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Select Layer(s):"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_argc
operator|=
literal|7
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_argv
operator|=
name|sel_args
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_help_argv
operator|=
name|sel_help
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_ret
operator|=
literal|4
expr_stmt|;
comment|/* Layer select pattern string */
name|sel_pattern
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|sel_pattern
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|4
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Select Pattern:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
literal|4
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"String to identify layer names    \nor layerstack position numbers\n0,3-5"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|text_buf_len
operator|=
name|MAX_LAYERNAME
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|text_buf_ret
operator|=
name|sel_pattern
expr_stmt|;
comment|/* case sensitive checkbutton */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Case sensitive"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Lowercase and UPPERCASE letters are considered as different"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
comment|/* invert selection checkbutton */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|6
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Invert Selection"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Perform actions on all unselected Layers"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
comment|/* desired action to perform OPTIONMENU  */
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|7
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Function:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|radio_argc
operator|=
literal|13
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|radio_argv
operator|=
name|action_args
expr_stmt|;
comment|/* argv[7].radio_help_argv = action_help */
name|argv
index|[
literal|7
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Function to be performed on all selected layers"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|radio_ret
operator|=
literal|0
expr_stmt|;
comment|/* a new name for the handled Layer(s) */
operator|*
name|new_layername
operator|=
literal|'\0'
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|8
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"New Layername:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
literal|8
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"New Layername for all handled layers \n[####] is replaced by frame number\n(is used on function rename only)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|text_buf_len
operator|=
name|MAX_LAYERNAME
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|text_buf_ret
operator|=
name|new_layername
expr_stmt|;
name|l_rc
operator|=
name|p_array_std_dialog
argument_list|(
name|_
argument_list|(
literal|"Frames Modify"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Settings"
argument_list|)
argument_list|,
literal|9
argument_list|,
name|argv
argument_list|,
comment|/* widget array */
literal|2
argument_list|,
name|b_argv
argument_list|,
comment|/* button array */
literal|0
argument_list|)
expr_stmt|;
comment|/* return the entered values */
operator|*
name|range_from
operator|=
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
expr_stmt|;
operator|*
name|range_to
operator|=
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
expr_stmt|;
operator|*
name|sel_mode
operator|=
name|argv
index|[
literal|3
index|]
operator|.
name|int_ret
expr_stmt|;
comment|/*     [4] sel_pattern  */
operator|*
name|sel_case
operator|=
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
expr_stmt|;
operator|*
name|sel_invert
operator|=
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
expr_stmt|;
operator|*
name|action_mode
operator|=
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
expr_stmt|;
comment|/*     [8] l_new_layername */
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_layer_modify_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_pitstop_dialog  *   return -1  on CANCEL  *           0  on Continue (OK)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_pitstop_dialog (gint text_flag,char * filter_procname)
name|p_pitstop_dialog
parameter_list|(
name|gint
name|text_flag
parameter_list|,
name|char
modifier|*
name|filter_procname
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|l_env
decl_stmt|;
name|gchar
modifier|*
name|l_msg
decl_stmt|;
specifier|static
name|t_but_arg
name|l_but_argv
index|[
literal|2
index|]
decl_stmt|;
name|gint
name|l_but_argc
decl_stmt|;
name|gint
name|l_argc
decl_stmt|;
specifier|static
name|t_arr_arg
name|l_argv
index|[
literal|1
index|]
decl_stmt|;
name|gint
name|l_continue
decl_stmt|;
name|l_but_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Continue"
argument_list|)
expr_stmt|;
name|l_but_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_but_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|GTK_STOCK_CANCEL
expr_stmt|;
name|l_but_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|l_but_argc
operator|=
literal|2
expr_stmt|;
name|l_argc
operator|=
literal|0
expr_stmt|;
comment|/* optional dialog between both calls (to see the effect of 1.call) */
name|l_env
operator|=
name|g_getenv
argument_list|(
literal|"GAP_FILTER_PITSTOP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_env
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_env
operator|==
literal|'N'
operator|)
operator|||
operator|(
operator|*
name|l_env
operator|==
literal|'n'
operator|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* continue without question */
block|}
block|}
if|if
condition|(
name|text_flag
operator|==
literal|0
condition|)
block|{
name|l_msg
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"2nd call of %s\n(define end-settings)"
argument_list|)
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_msg
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Non-Interactive call of %s\n(for all selected layers)"
argument_list|)
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
block|}
name|l_continue
operator|=
name|p_array_std_dialog
argument_list|(
name|_
argument_list|(
literal|"Animated Filter apply"
argument_list|)
argument_list|,
name|l_msg
argument_list|,
name|l_argc
argument_list|,
name|l_argv
argument_list|,
name|l_but_argc
argument_list|,
name|l_but_argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_continue
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_pitstop_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_get_1st_selected  *   return index of the 1.st selected layer  *   or -1 if no selection was found  * ============================================================================  */
end_comment

begin_function
name|int
DECL|function|p_get_1st_selected (t_LayliElem * layli_ptr,gint nlayers)
name|p_get_1st_selected
parameter_list|(
name|t_LayliElem
modifier|*
name|layli_ptr
parameter_list|,
name|gint
name|nlayers
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|nlayers
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|!=
name|FALSE
condition|)
block|{
return|return
operator|(
name|l_idx
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_get_1st_selected */
end_comment

begin_comment
comment|/* ============================================================================  * p_alloc_layli  * returns   pointer to a new allocated image_id of the new created multilayer image  *           (or NULL on error)  * ============================================================================  */
end_comment

begin_function
name|t_LayliElem
modifier|*
DECL|function|p_alloc_layli (gint32 image_id,gint32 * l_sel_cnt,gint * nlayers,gint32 sel_mode,gint32 sel_case,gint32 sel_invert,char * sel_pattern)
name|p_alloc_layli
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
modifier|*
name|l_sel_cnt
parameter_list|,
name|gint
modifier|*
name|nlayers
parameter_list|,
name|gint32
name|sel_mode
parameter_list|,
name|gint32
name|sel_case
parameter_list|,
name|gint32
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|)
block|{
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_idx
decl_stmt|;
name|t_LayliElem
modifier|*
name|l_layli_ptr
decl_stmt|;
name|char
modifier|*
name|l_layername
decl_stmt|;
operator|*
name|l_sel_cnt
operator|=
literal|0
expr_stmt|;
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
name|nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l_layli_ptr
operator|=
name|g_new0
argument_list|(
name|t_LayliElem
argument_list|,
operator|(
operator|*
name|nlayers
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
operator|==
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
operator|(
operator|*
name|nlayers
operator|)
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_layer_id
operator|=
name|l_layers_list
index|[
name|l_idx
index|]
expr_stmt|;
name|l_layername
operator|=
name|gimp_layer_get_name
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
operator|=
name|l_layer_id
expr_stmt|;
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|visible
operator|=
name|gimp_layer_get_visible
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|=
name|p_match_layer
argument_list|(
name|l_idx
argument_list|,
name|l_layername
argument_list|,
name|sel_pattern
argument_list|,
name|sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
operator|*
name|nlayers
argument_list|,
name|l_layer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|!=
name|FALSE
condition|)
block|{
operator|(
operator|*
name|l_sel_cnt
operator|)
operator|++
expr_stmt|;
comment|/* count all selected layers */
block|}
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"gap: p_alloc_layli [%d] id:%d, sel:%d %s\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|,
operator|(
name|int
operator|)
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
argument_list|,
name|l_layername
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_layername
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_layli_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_alloc_layli */
end_comment

begin_comment
comment|/* ============================================================================  * p_prevent_empty_image  *    check if the resulting image has at least one layer  *    (gimp 1.0.0 tends to crash on layerless images)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_prevent_empty_image (gint32 image_id)
name|void
name|p_prevent_empty_image
parameter_list|(
name|gint32
name|image_id
parameter_list|)
block|{
name|GimpImageBaseType
name|l_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
block|}
else|else
name|l_nlayers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l_nlayers
operator|==
literal|0
condition|)
block|{
comment|/* the resulting image has no layer, add a transparent dummy layer */
comment|/* get info about the image */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_type
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_type
operator|=
operator|(
name|l_type
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* convert from GimpImageBaseType to GimpImageType */
comment|/* add a transparent dummy layer */
name|l_layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|image_id
argument_list|,
literal|"dummy"
argument_list|,
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|,
literal|0.0
argument_list|,
comment|/* Opacity full transparent */
literal|0
argument_list|)
expr_stmt|;
comment|/* NORMAL */
name|gimp_image_add_layer
argument_list|(
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end p_prevent_empty_image */
end_comment

begin_comment
comment|/* ============================================================================  * p_raise_layer  *   raise layer (check if possible before)  *   (without the check each failed attempt would open an inf window)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_raise_layer (gint32 image_id,gint32 layer_id,t_LayliElem * layli_ptr,gint nlayers)
name|p_raise_layer
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|layer_id
parameter_list|,
name|t_LayliElem
modifier|*
name|layli_ptr
parameter_list|,
name|gint
name|nlayers
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|layer_id
argument_list|)
condition|)
return|return;
comment|/* has no alpha channel */
if|if
condition|(
name|layli_ptr
index|[
literal|0
index|]
operator|.
name|layer_id
operator|==
name|layer_id
condition|)
return|return;
comment|/* is already on top */
name|gimp_image_raise_layer
argument_list|(
name|image_id
argument_list|,
name|layer_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_raise_layer */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_lower_layer (gint32 image_id,gint32 layer_id,t_LayliElem * layli_ptr,gint nlayers)
name|p_lower_layer
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|layer_id
parameter_list|,
name|t_LayliElem
modifier|*
name|layli_ptr
parameter_list|,
name|gint
name|nlayers
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|layer_id
argument_list|)
condition|)
return|return;
comment|/* has no alpha channel */
if|if
condition|(
name|layli_ptr
index|[
name|nlayers
operator|-
literal|1
index|]
operator|.
name|layer_id
operator|==
name|layer_id
condition|)
return|return;
comment|/* is already on bottom */
if|if
condition|(
name|nlayers
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|layli_ptr
index|[
name|nlayers
operator|-
literal|2
index|]
operator|.
name|layer_id
operator|==
name|layer_id
operator|)
operator|&&
operator|(
operator|!
name|gimp_drawable_has_alpha
argument_list|(
name|layli_ptr
index|[
name|nlayers
operator|-
literal|1
index|]
operator|.
name|layer_id
argument_list|)
operator|)
condition|)
block|{
comment|/* the layer is one step above a "bottom-layer without alpha" */
return|return;
block|}
block|}
name|gimp_image_lower_layer
argument_list|(
name|image_id
argument_list|,
name|layer_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_lower_layer */
end_comment

begin_comment
comment|/* ============================================================================  * p_apply_action  *  *    perform function (defined by action_mode)  *    on all selcted layer(s)  *     * returns   0 if all done OK  *           (or -1 on error)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_apply_action (gint32 image_id,gint32 action_mode,t_LayliElem * layli_ptr,gint nlayers,gint32 sel_cnt,long from,long to,long curr,char * new_layername,char * filter_procname)
name|p_apply_action
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|gint32
name|action_mode
parameter_list|,
name|t_LayliElem
modifier|*
name|layli_ptr
parameter_list|,
name|gint
name|nlayers
parameter_list|,
name|gint32
name|sel_cnt
parameter_list|,
name|long
name|from
parameter_list|,
name|long
name|to
parameter_list|,
name|long
name|curr
parameter_list|,
name|char
modifier|*
name|new_layername
parameter_list|,
name|char
modifier|*
name|filter_procname
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_new_layer_id
decl_stmt|;
name|gint
name|l_merge_mode
decl_stmt|;
name|gint
name|l_vis_result
decl_stmt|;
name|char
name|l_name_buff
index|[
name|MAX_LAYERNAME
index|]
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gap: p_apply_action START\n"
argument_list|)
expr_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_merge_mode
operator|=
operator|-
literal|44
expr_stmt|;
comment|/* none of the flatten modes */
if|if
condition|(
name|action_mode
operator|==
name|ACM_MERGE_EXPAND
condition|)
name|l_merge_mode
operator|=
name|FLAM_MERG_EXPAND
expr_stmt|;
if|if
condition|(
name|action_mode
operator|==
name|ACM_MERGE_IMG
condition|)
name|l_merge_mode
operator|=
name|FLAM_MERG_CLIP_IMG
expr_stmt|;
if|if
condition|(
name|action_mode
operator|==
name|ACM_MERGE_BG
condition|)
name|l_merge_mode
operator|=
name|FLAM_MERG_CLIP_BG
expr_stmt|;
comment|/* merge actions require one call per image */
if|if
condition|(
name|l_merge_mode
operator|!=
operator|(
operator|-
literal|44
operator|)
condition|)
block|{
if|if
condition|(
name|sel_cnt
operator|<
literal|2
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* OK, nothing to merge */
block|}
name|l_vis_result
operator|=
name|FALSE
expr_stmt|;
comment|/* set selected layers visible, all others invisible for merge */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|nlayers
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|==
name|FALSE
condition|)
block|{
name|gimp_layer_set_visible
argument_list|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gimp_layer_get_visible
argument_list|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
argument_list|)
condition|)
block|{
comment|/* result will we visible if at least one of the 	     * selected layers was visible before 	     */
name|l_vis_result
operator|=
name|TRUE
expr_stmt|;
block|}
name|gimp_layer_set_visible
argument_list|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* merge all visible layers (i.e. all selected layers) */
name|l_layer_id
operator|=
name|gimp_image_merge_visible_layers
argument_list|(
name|image_id
argument_list|,
name|l_merge_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_vis_result
operator|==
name|FALSE
condition|)
block|{
name|gimp_layer_set_visible
argument_list|(
name|l_layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* if new_layername is available use that name       * for the new merged layer       */
if|if
condition|(
operator|!
name|p_is_empty
argument_list|(
name|new_layername
argument_list|)
condition|)
block|{
name|p_substitute_framenr
argument_list|(
operator|&
name|l_name_buff
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_name_buff
argument_list|)
argument_list|,
name|new_layername
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|gimp_layer_set_name
argument_list|(
name|l_layer_id
argument_list|,
operator|&
name|l_name_buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* restore visibility flags after merge */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|nlayers
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|==
name|FALSE
condition|)
block|{
name|gimp_layer_set_visible
argument_list|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
argument_list|,
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|visible
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* -----------------------------*/
comment|/* non-merge actions require calls foreach selected layer */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
operator|(
name|l_idx
operator|<
name|nlayers
operator|)
operator|&&
operator|(
name|l_rc
operator|==
literal|0
operator|)
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_layer_id
operator|=
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
expr_stmt|;
comment|/* apply function defined by action_mode */
if|if
condition|(
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|!=
name|FALSE
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gap: p_apply_action on selected LayerID:%d layerstack:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action_mode
condition|)
block|{
case|case
name|ACM_SET_VISIBLE
case|:
name|gimp_layer_set_visible
argument_list|(
name|l_layer_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_SET_INVISIBLE
case|:
name|gimp_layer_set_visible
argument_list|(
name|l_layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_SET_LINKED
case|:
name|l_rc
operator|=
name|p_layer_set_linked
argument_list|(
name|l_layer_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_SET_UNLINKED
case|:
name|l_rc
operator|=
name|p_layer_set_linked
argument_list|(
name|l_layer_id
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_RAISE
case|:
name|p_raise_layer
argument_list|(
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|layli_ptr
argument_list|,
name|nlayers
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_LOWER
case|:
name|p_lower_layer
argument_list|(
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|layli_ptr
argument_list|,
name|nlayers
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_APPLY_FILTER
case|:
name|l_rc
operator|=
name|p_call_plugin
argument_list|(
name|filter_procname
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|GIMP_RUN_WITH_LAST_VALS
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gap: p_apply_action FILTER:%s rc =%d\n"
argument_list|,
name|filter_procname
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_DUPLICATE
case|:
name|l_new_layer_id
operator|=
name|gimp_layer_copy
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_id
argument_list|,
name|l_new_layer_id
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_is_empty
argument_list|(
name|new_layername
argument_list|)
condition|)
block|{
name|p_substitute_framenr
argument_list|(
operator|&
name|l_name_buff
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_name_buff
argument_list|)
argument_list|,
name|new_layername
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|gimp_layer_set_name
argument_list|(
name|l_new_layer_id
argument_list|,
operator|&
name|l_name_buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACM_DELETE
case|:
name|gimp_image_remove_layer
argument_list|(
name|image_id
argument_list|,
name|l_layer_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACM_RENAME
case|:
name|p_substitute_framenr
argument_list|(
operator|&
name|l_name_buff
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_name_buff
argument_list|)
argument_list|,
name|new_layername
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|gimp_layer_set_name
argument_list|(
name|l_layer_id
argument_list|,
operator|&
name|l_name_buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_apply_action */
end_comment

begin_comment
comment|/* ============================================================================  * p_do_filter_dialogs  *    additional dialog steps  *    a) gap_pdb_browser (select the filter)  *    b) 1st interactive filtercall  *    c) 1st pitstop dialog  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_do_filter_dialogs (t_anim_info * ainfo_ptr,gint32 image_id,gint32 * dpy_id,t_LayliElem * layli_ptr,gint nlayers,char * filter_procname,int filt_len,gint * plugin_data_len,t_apply_mode * apply_mode)
name|p_do_filter_dialogs
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
modifier|*
name|dpy_id
parameter_list|,
name|t_LayliElem
modifier|*
name|layli_ptr
parameter_list|,
name|gint
name|nlayers
parameter_list|,
name|char
modifier|*
name|filter_procname
parameter_list|,
name|int
name|filt_len
parameter_list|,
name|gint
modifier|*
name|plugin_data_len
parameter_list|,
name|t_apply_mode
modifier|*
name|apply_mode
parameter_list|)
block|{
name|t_gap_db_browse_result
name|l_browser_result
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
specifier|static
name|char
name|l_key_from
index|[
literal|512
index|]
decl_stmt|;
specifier|static
name|gint
name|l_gtk_init
init|=
name|TRUE
decl_stmt|;
comment|/* gkt_init at 1.st call */
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_gtk_init
operator|=
name|FALSE
expr_stmt|;
comment|/* gtk_init was done in 1.st modify dialog before */
block|}
comment|/* GAP-PDB-Browser Dialog */
comment|/* ---------------------- */
if|if
condition|(
name|gap_db_browser_dialog
argument_list|(
name|_
argument_list|(
literal|"Select Filter for Animated frames-apply"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Apply Constant"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Apply Varying"
argument_list|)
argument_list|,
name|p_constraint_proc
argument_list|,
name|p_constraint_proc_sel1
argument_list|,
name|p_constraint_proc_sel2
argument_list|,
operator|&
name|l_browser_result
argument_list|,
name|l_gtk_init
comment|/* do not call gtk_init */
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: gap_db_browser_dialog cancelled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_arr_gtk_init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* disable the initial gtk_init in gap_arr_dialog's                           * (gtk_init was done before)                           */
name|strncpy
argument_list|(
name|filter_procname
argument_list|,
name|l_browser_result
operator|.
name|selected_proc_name
argument_list|,
name|filt_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|filter_procname
index|[
name|filt_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|l_browser_result
operator|.
name|button_nr
operator|==
literal|1
condition|)
operator|*
name|apply_mode
operator|=
name|PTYP_VARYING_LINEAR
expr_stmt|;
else|else
operator|*
name|apply_mode
operator|=
name|PAPP_CONSTANT
expr_stmt|;
comment|/* 1.st INTERACTIV Filtercall dialog */
comment|/* --------------------------------- */
comment|/* check for the Plugin */
name|l_rc
operator|=
name|p_procedure_available
argument_list|(
name|filter_procname
argument_list|,
name|PTYP_CAN_OPERATE_ON_DRAWABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Plugin not available or wrong type %s\n"
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* get 1.st selected layer (of 1.st handled frame in range ) */
name|l_idx
operator|=
name|p_get_1st_selected
argument_list|(
name|layli_ptr
argument_list|,
name|nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_idx
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: No layer selected in 1.st handled frame\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|l_layer_id
operator|=
name|layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
expr_stmt|;
comment|/* open a view for the 1.st handled frame */
operator|*
name|dpy_id
operator|=
name|gimp_display_new
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_call_plugin
argument_list|(
name|filter_procname
argument_list|,
name|image_id
argument_list|,
name|l_layer_id
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|)
expr_stmt|;
comment|/* OOPS: cant delete the display here, because    *       closing the last display seems to free up    *       at least parts of the image,    *       and causes crashes if the image_id is used    *       in further gimp procedures    */
comment|/* gimp_display_delete(*dpy_id); */
comment|/* get values, then store with suffix "_ITER_FROM" */
operator|*
name|plugin_data_len
operator|=
name|p_get_data
argument_list|(
name|filter_procname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|plugin_data_len
operator|>
literal|0
condition|)
block|{
name|g_snprintf
argument_list|(
name|l_key_from
argument_list|,
sizeof|sizeof
argument_list|(
name|l_key_from
argument_list|)
argument_list|,
literal|"%s_ITER_FROM"
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
name|p_set_data
argument_list|(
name|l_key_from
argument_list|,
operator|*
name|plugin_data_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|apply_mode
operator|!=
name|PTYP_VARYING_LINEAR
condition|)
block|{
return|return
operator|(
name|p_pitstop_dialog
argument_list|(
literal|1
argument_list|,
name|filter_procname
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_do_filter_dialogs */
end_comment

begin_comment
comment|/* ============================================================================  * p_do_2nd_filter_dialogs  *    d) [ 2nd interactive filtercall  *    e)   2nd pitstop dialog ]  *  *   (temporary) open the last frame of the range  *   get its 1.st selected laye  *   and do the Interctive Filtercall (to get the end-values)  *  * then close everything (without save).  * (the last frame will be processed later, with all its selected layers)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_do_2nd_filter_dialogs (char * filter_procname,t_apply_mode l_apply_mode,char * last_frame_filename,gint32 sel_mode,gint32 sel_case,gint32 sel_invert,char * sel_pattern)
name|p_do_2nd_filter_dialogs
parameter_list|(
name|char
modifier|*
name|filter_procname
parameter_list|,
name|t_apply_mode
name|l_apply_mode
parameter_list|,
name|char
modifier|*
name|last_frame_filename
parameter_list|,
name|gint32
name|sel_mode
parameter_list|,
name|gint32
name|sel_case
parameter_list|,
name|gint32
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|)
block|{
name|gint32
name|l_layer_id
decl_stmt|;
name|gint32
name|l_dpy_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
specifier|static
name|char
name|l_key_to
index|[
literal|512
index|]
decl_stmt|;
specifier|static
name|char
name|l_key_from
index|[
literal|512
index|]
decl_stmt|;
name|gint32
name|l_last_image_id
decl_stmt|;
name|t_LayliElem
modifier|*
name|l_layli_ptr
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
name|l_sel_cnt
decl_stmt|;
name|gint
name|l_plugin_data_len
decl_stmt|;
name|l_layli_ptr
operator|=
name|NULL
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* assume cancel or error */
name|l_last_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_dpy_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 2.nd INTERACTIV Filtercall dialog */
comment|/* --------------------------------- */
if|if
condition|(
name|last_frame_filename
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* there is no 2.nd frame for 2.nd filter call */
block|}
if|if
condition|(
name|p_pitstop_dialog
argument_list|(
literal|0
argument_list|,
name|filter_procname
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* load last frame into temporary image */
name|l_last_image_id
operator|=
name|p_load_image
argument_list|(
name|last_frame_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_last_image_id
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* get informations (id, visible, selected) about all layers */
name|l_layli_ptr
operator|=
name|p_alloc_layli
argument_list|(
name|l_last_image_id
argument_list|,
operator|&
name|l_sel_cnt
argument_list|,
operator|&
name|l_nlayers
argument_list|,
name|sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
name|sel_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* get 1.st selected layer (of last handled frame in range ) */
name|l_idx
operator|=
name|p_get_1st_selected
argument_list|(
name|l_layli_ptr
argument_list|,
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_idx
operator|<
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|_
argument_list|(
literal|"GAP Modify: No layer selected in last handled frame"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|l_layer_id
operator|=
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|layer_id
expr_stmt|;
comment|/* open a view for the last handled frame */
name|l_dpy_id
operator|=
name|gimp_display_new
argument_list|(
name|l_last_image_id
argument_list|)
expr_stmt|;
comment|/* 2.nd INTERACTIV Filtercall dialog */
comment|/* --------------------------------- */
name|l_rc
operator|=
name|p_call_plugin
argument_list|(
name|filter_procname
argument_list|,
name|l_last_image_id
argument_list|,
name|l_layer_id
argument_list|,
name|GIMP_RUN_INTERACTIVE
argument_list|)
expr_stmt|;
comment|/* get values, then store with suffix "_ITER_TO" */
name|l_plugin_data_len
operator|=
name|p_get_data
argument_list|(
name|filter_procname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_plugin_data_len
operator|<=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|g_snprintf
argument_list|(
name|l_key_to
argument_list|,
sizeof|sizeof
argument_list|(
name|l_key_to
argument_list|)
argument_list|,
literal|"%s_ITER_TO"
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
name|p_set_data
argument_list|(
name|l_key_to
argument_list|,
name|l_plugin_data_len
argument_list|)
expr_stmt|;
comment|/* get FROM values */
name|g_snprintf
argument_list|(
name|l_key_from
argument_list|,
sizeof|sizeof
argument_list|(
name|l_key_from
argument_list|)
argument_list|,
literal|"%s_ITER_FROM"
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
name|l_plugin_data_len
operator|=
name|p_get_data
argument_list|(
name|l_key_from
argument_list|)
expr_stmt|;
name|p_set_data
argument_list|(
name|filter_procname
argument_list|,
name|l_plugin_data_len
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_pitstop_dialog
argument_list|(
literal|1
argument_list|,
name|filter_procname
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|l_dpy_id
operator|>=
literal|0
condition|)
name|gimp_display_delete
argument_list|(
name|l_dpy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_last_image_id
operator|>=
literal|0
condition|)
name|gimp_image_delete
argument_list|(
name|l_last_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|l_layli_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_do_2nd_filter_dialogs */
end_comment

begin_comment
comment|/* ============================================================================  * p_frames_modify  *  *   foreach frame of the range (given by range_from and range_to)  *   perform function defined by action_mode  *   on all selected layer(s) described by sel_mode, sel_case  *                                         sel_invert and sel_pattern  * returns   0 if all done OK  *           (or -1 on error or cancel)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint32
DECL|function|p_frames_modify (t_anim_info * ainfo_ptr,long range_from,long range_to,gint32 action_mode,gint32 sel_mode,gint32 sel_case,gint32 sel_invert,char * sel_pattern,char * new_layername)
name|p_frames_modify
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|,
name|gint32
name|action_mode
parameter_list|,
name|gint32
name|sel_mode
parameter_list|,
name|gint32
name|sel_case
parameter_list|,
name|gint32
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|,
name|char
modifier|*
name|new_layername
parameter_list|)
block|{
name|long
name|l_cur_frame_nr
decl_stmt|;
name|long
name|l_step
decl_stmt|,
name|l_begin
decl_stmt|,
name|l_end
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint32
name|l_dpy_id
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|gint32
name|l_sel_cnt
decl_stmt|;
name|t_LayliElem
modifier|*
name|l_layli_ptr
decl_stmt|;
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|gint
name|l_plugin_data_len
decl_stmt|;
name|char
name|l_filter_procname
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|l_plugin_iterator
decl_stmt|;
name|gdouble
name|l_cur_step
decl_stmt|;
name|gint
name|l_total_steps
decl_stmt|;
name|t_apply_mode
name|l_apply_mode
decl_stmt|;
name|char
modifier|*
name|l_last_frame_filename
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gap: p_frames_modify START, action_mode=%d  sel_mode=%d case=%d, invert=%d patt:%s:\n"
argument_list|,
operator|(
name|int
operator|)
name|action_mode
argument_list|,
operator|(
name|int
operator|)
name|sel_mode
argument_list|,
operator|(
name|int
operator|)
name|sel_case
argument_list|,
operator|(
name|int
operator|)
name|sel_invert
argument_list|,
name|sel_pattern
argument_list|)
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Modifying Frames/Layer(s)..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l_begin
operator|=
name|range_from
expr_stmt|;
name|l_end
operator|=
name|range_to
expr_stmt|;
name|l_tmp_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_layli_ptr
operator|=
name|NULL
expr_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_plugin_iterator
operator|=
name|NULL
expr_stmt|;
name|l_plugin_data_len
operator|=
literal|0
expr_stmt|;
name|l_apply_mode
operator|=
name|PAPP_CONSTANT
expr_stmt|;
name|l_dpy_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_last_frame_filename
operator|=
name|NULL
expr_stmt|;
comment|/* init step direction */
if|if
condition|(
name|range_from
operator|>
name|range_to
condition|)
block|{
name|l_step
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* operate in descending (reverse) order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_from
operator|)
operator|-
name|range_to
operator|)
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_from
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
name|l_total_steps
operator|=
name|l_begin
operator|-
name|l_end
expr_stmt|;
block|}
else|else
block|{
name|l_step
operator|=
literal|1
expr_stmt|;
comment|/* operate in ascending order */
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|range_to
operator|)
operator|-
name|range_from
operator|)
expr_stmt|;
if|if
condition|(
name|range_from
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|l_begin
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
if|if
condition|(
name|range_to
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_end
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
name|l_total_steps
operator|=
name|l_end
operator|-
name|l_begin
expr_stmt|;
block|}
name|l_cur_step
operator|=
name|l_total_steps
expr_stmt|;
name|l_cur_frame_nr
operator|=
name|l_begin
expr_stmt|;
while|while
condition|(
literal|1
condition|)
comment|/* loop foreach frame in range */
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"p_frames_modify While l_cur_frame_nr = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_cur_frame_nr
argument_list|)
expr_stmt|;
comment|/* build the frame name */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* load current frame into temporary image */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* get informations (id, visible, selected) about all layers */
name|l_layli_ptr
operator|=
name|p_alloc_layli
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_sel_cnt
argument_list|,
operator|&
name|l_nlayers
argument_list|,
name|sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
name|sel_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gap: p_frames_modify: cant alloc layer info list\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|l_cur_frame_nr
operator|==
name|l_begin
operator|)
operator|&&
operator|(
name|action_mode
operator|==
name|ACM_APPLY_FILTER
operator|)
condition|)
block|{
comment|/* ------------- 1.st frame: extra dialogs for APPLY_FILTER ---------- */
if|if
condition|(
name|l_sel_cnt
operator|<
literal|1
condition|)
block|{
name|p_msg_win
argument_list|(
name|GIMP_RUN_INTERACTIVE
argument_list|,
name|_
argument_list|(
literal|"No selected Layer in start frame"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|l_begin
operator|!=
name|l_end
condition|)
block|{
name|l_last_frame_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_end
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
block|}
comment|/* additional dialog steps  a) gap_pdb_browser (select the filter)        *                          b) 1st interactive filtercall        *                          c) 1st pitstop dialog        *                          d) [ 2nd interactive filtercall        *                          e)   2nd pitstop dialog ]        */
name|l_rc
operator|=
name|p_do_filter_dialogs
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_tmp_image_id
argument_list|,
operator|&
name|l_dpy_id
argument_list|,
name|l_layli_ptr
argument_list|,
name|l_nlayers
argument_list|,
operator|&
name|l_filter_procname
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_filter_procname
argument_list|)
argument_list|,
operator|&
name|l_plugin_data_len
argument_list|,
operator|&
name|l_apply_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_last_frame_filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|l_rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|l_apply_mode
operator|==
name|PTYP_VARYING_LINEAR
operator|)
condition|)
block|{
name|l_rc
operator|=
name|p_do_2nd_filter_dialogs
argument_list|(
operator|&
name|l_filter_procname
index|[
literal|0
index|]
argument_list|,
name|l_apply_mode
argument_list|,
name|l_last_frame_filename
argument_list|,
name|sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
name|sel_pattern
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_last_frame_filename
argument_list|)
expr_stmt|;
name|l_last_frame_filename
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* the 1st selected layer has been filtered        * in the INTERACTIVE call b)        * therefore we unselect this layer, to avoid        * a 2nd processing        */
name|l_idx
operator|=
name|p_get_1st_selected
argument_list|(
name|l_layli_ptr
argument_list|,
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_idx
operator|>=
literal|0
condition|)
block|{
name|l_layli_ptr
index|[
name|l_idx
index|]
operator|.
name|selected
operator|=
name|FALSE
expr_stmt|;
name|l_sel_cnt
operator|--
expr_stmt|;
block|}
comment|/* check for matching Iterator PluginProcedures */
if|if
condition|(
name|l_apply_mode
operator|==
name|PTYP_VARYING_LINEAR
condition|)
block|{
name|l_plugin_iterator
operator|=
name|p_get_iterator_proc
argument_list|(
operator|&
name|l_filter_procname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* perform function (defined by action_mode) on selcted layer(s) */
name|l_rc
operator|=
name|p_apply_action
argument_list|(
name|l_tmp_image_id
argument_list|,
name|action_mode
argument_list|,
name|l_layli_ptr
argument_list|,
name|l_nlayers
argument_list|,
name|l_sel_cnt
argument_list|,
name|l_begin
argument_list|,
name|l_end
argument_list|,
name|l_cur_frame_nr
argument_list|,
name|new_layername
argument_list|,
operator|&
name|l_filter_procname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gap: p_frames_modify p_apply-action failed. rc=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* free layli info table for the current frame */
if|if
condition|(
name|l_layli_ptr
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|l_layli_ptr
argument_list|)
expr_stmt|;
name|l_layli_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* check if the resulting image has at least one layer */
name|p_prevent_empty_image
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
comment|/* save current frame with same name */
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"gap: p_frames_modify save frame %d failed.\n"
argument_list|,
operator|(
name|int
operator|)
name|l_cur_frame_nr
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
name|l_rc
operator|=
literal|0
expr_stmt|;
comment|/* iterator call (for filter apply with varying values) */
if|if
condition|(
operator|(
name|action_mode
operator|==
name|ACM_APPLY_FILTER
operator|)
operator|&&
operator|(
name|l_plugin_iterator
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|l_apply_mode
operator|==
name|PTYP_VARYING_LINEAR
operator|)
condition|)
block|{
name|l_cur_step
operator|-=
literal|1.0
expr_stmt|;
comment|/* call plugin-specific iterator, to modify          * the plugin's last_values          */
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: calling iterator %s  current frame:%d\n"
argument_list|,
name|l_plugin_iterator
argument_list|,
operator|(
name|int
operator|)
name|l_cur_frame_nr
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
name|l_plugin_iterator
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_total_steps
argument_list|,
comment|/* total steps  */
name|GIMP_PDB_FLOAT
argument_list|,
operator|(
name|gdouble
operator|)
name|l_cur_step
argument_list|,
comment|/* current step */
name|GIMP_PDB_INT32
argument_list|,
name|l_plugin_data_len
argument_list|,
comment|/* length of stored data struct */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|!=
name|GIMP_PDB_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: iterator %s  failed\n"
argument_list|,
name|l_plugin_iterator
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
block|}
comment|/* close display (if open) */
if|if
condition|(
name|l_dpy_id
operator|>=
literal|0
condition|)
block|{
name|gimp_display_delete
argument_list|(
name|l_dpy_id
argument_list|)
expr_stmt|;
name|l_dpy_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
comment|/* advance to next frame */
if|if
condition|(
name|l_cur_frame_nr
operator|==
name|l_end
condition|)
break|break;
name|l_cur_frame_nr
operator|+=
name|l_step
expr_stmt|;
block|}
comment|/* end while(1)  loop foreach frame in range */
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"p_frames_modify End OK\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gap: p_frames_modify exit with Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_dpy_id
operator|>=
literal|0
condition|)
block|{
name|gimp_display_delete
argument_list|(
name|l_dpy_id
argument_list|)
expr_stmt|;
name|l_dpy_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_tmp_image_id
operator|>=
literal|0
condition|)
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layli_ptr
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|l_layli_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_plugin_iterator
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|l_plugin_iterator
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* end p_frames_modify */
end_comment

begin_comment
comment|/* ============================================================================  * gap_mod_layer  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_mod_layer (GimpRunModeType run_mode,gint32 image_id,gint32 range_from,gint32 range_to,gint32 action_mode,gint32 sel_mode,gint32 sel_case,gint32 sel_invert,char * sel_pattern,char * new_layername)
name|gint
name|gap_mod_layer
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|range_from
parameter_list|,
name|gint32
name|range_to
parameter_list|,
name|gint32
name|action_mode
parameter_list|,
name|gint32
name|sel_mode
parameter_list|,
name|gint32
name|sel_case
parameter_list|,
name|gint32
name|sel_invert
parameter_list|,
name|char
modifier|*
name|sel_pattern
parameter_list|,
name|char
modifier|*
name|new_layername
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gint32
name|l_from
decl_stmt|;
name|gint32
name|l_to
decl_stmt|;
name|gint32
name|l_action_mode
decl_stmt|;
name|gint32
name|l_sel_mode
decl_stmt|;
name|gint32
name|l_sel_case
decl_stmt|;
name|gint32
name|l_sel_invert
decl_stmt|;
name|char
name|l_sel_pattern
index|[
name|MAX_LAYERNAME
index|]
decl_stmt|;
name|char
name|l_new_layername
index|[
name|MAX_LAYERNAME
index|]
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_layer_modify_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|,
operator|&
name|l_action_mode
argument_list|,
operator|&
name|l_sel_mode
argument_list|,
operator|&
name|sel_case
argument_list|,
operator|&
name|sel_invert
argument_list|,
operator|&
name|l_sel_pattern
index|[
literal|0
index|]
argument_list|,
operator|&
name|l_new_layername
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
name|l_action_mode
operator|=
name|action_mode
expr_stmt|;
name|l_sel_mode
operator|=
name|sel_mode
expr_stmt|;
name|l_sel_case
operator|=
name|sel_case
expr_stmt|;
name|l_sel_invert
operator|=
name|sel_invert
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|l_sel_pattern
index|[
literal|0
index|]
argument_list|,
name|sel_pattern
argument_list|,
sizeof|sizeof
argument_list|(
name|l_sel_pattern
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_sel_pattern
index|[
sizeof|sizeof
argument_list|(
name|l_sel_pattern
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|l_new_layername
index|[
literal|0
index|]
argument_list|,
name|new_layername
argument_list|,
sizeof|sizeof
argument_list|(
name|l_new_layername
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_new_layername
index|[
sizeof|sizeof
argument_list|(
name|l_new_layername
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_frames_modify
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|,
name|l_action_mode
argument_list|,
name|l_sel_mode
argument_list|,
name|sel_case
argument_list|,
name|sel_invert
argument_list|,
operator|&
name|l_sel_pattern
index|[
literal|0
index|]
argument_list|,
operator|&
name|l_new_layername
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

end_unit

