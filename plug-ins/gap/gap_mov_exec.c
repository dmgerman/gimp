begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_mov_exec.c  * 1997.11.06 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * Move : procedures for copying source layer(s) to multiple frames  * (varying Koordinates, opacity, size ...)  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history:  * gimp    1.1.29b; 2000/11/20  hof: FRAME based Stepmodes, bugfixes for path calculation  * gimp    1.1.23a; 2000/06/03  hof: bugfix anim_preview< 100% did not work  *                                   (the layer tattoos in a duplicated image may differ from the original !!)  * gimp    1.1.20a; 2000/04/25  hof: support for keyframes, anim_preview  * version 0.93.04              hof: Window with Info Message if no Source Image was selected in MovePath  * version 0.90.00;             hof: 1.st (pre) release 14.Dec.1997  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_layer_copy.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_mov_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_mov_exec.h"
end_include

begin_include
include|#
directive|include
file|"gap_pdb_calls.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_function_decl
specifier|static
name|gint
name|p_mov_call_render
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|,
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|gint
name|apv_layerstack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p_mov_advance_src_layer
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|int
name|src_stepmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p_mov_advance_src_frame
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|p_mov_execute
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
name|p_calc_angle
parameter_list|(
name|gint
name|p1x
parameter_list|,
name|gint
name|p1y
parameter_list|,
name|gint
name|p2x
parameter_list|,
name|gint
name|p2y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gdouble
name|p_rotatate_less_than_180
parameter_list|(
name|gdouble
name|angle
parameter_list|,
name|gdouble
name|angle_new
parameter_list|,
name|gint
modifier|*
name|turns
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ============================================================================  * p_mov_call_render  *  load current frame, render and save back to disk  *  for animted_preview  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_mov_call_render (t_mov_data * mov_ptr,t_mov_current * cur_ptr,gint apv_layerstack)
name|p_mov_call_render
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|,
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|gint
name|apv_layerstack
parameter_list|)
block|{
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|char
modifier|*
name|l_fname
decl_stmt|;
name|char
modifier|*
name|l_name
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|mov_ptr
operator|->
name|dst_ainfo_ptr
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
operator|<
literal|0
condition|)
block|{
comment|/* We are generating the Animation on the ORIGINAL FRAMES */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* load next frame to render */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* call render procedure for current image */
if|if
condition|(
literal|0
operator|==
name|p_mov_render
argument_list|(
name|l_tmp_image_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
condition|)
block|{
comment|/* if OK: save the rendered frame back to disk */
if|if
condition|(
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|<
literal|0
condition|)
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We are generating an ANIMATED PREVIEW multilayer image */
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_src_frame
operator|>=
literal|0
condition|)
block|{
comment|/* anim preview uses one constant (prescaled) frame */
name|l_tmp_image_id
operator|=
name|p_gimp_channel_ops_duplicate
argument_list|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_src_frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* anim preview exact mode uses original frames */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scalex
operator|!=
literal|100.0
operator|)
operator|||
operator|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scaley
operator|!=
literal|100.0
operator|)
condition|)
block|{
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|gint32
name|l_size_x
decl_stmt|,
name|l_size_y
decl_stmt|;
name|l_size_x
operator|=
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_size_y
operator|=
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_x
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_y
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* call render procedure for current image */
if|if
condition|(
literal|0
operator|==
name|p_mov_render
argument_list|(
name|l_tmp_image_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
condition|)
block|{
comment|/* if OK and optional save to gap_paste-buffer */
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
operator|!=
name|NULL
condition|)
block|{
name|l_fname
operator|=
name|p_alloc_fname
argument_list|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
literal|".xcf"
argument_list|)
expr_stmt|;
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
block|}
comment|/* flatten the rendered frame */
name|l_layer_id
operator|=
name|gimp_image_flatten
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_id
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_call_render: flattened layer_id:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|)
expr_stmt|;
comment|/* hof: 	 * if invisible layers are flattened on an empty image 	 * we do not get a resulting layer (returned l_layer_id == -1) 	 * 	 *  I'm not sure if is this a bug, but here is a workaround: 	 * 	 * In that case I add a dummy layer 1x1 pixel (at offest -1,-1) 	 * and flatten again, and it works (tested with gimp-1.1.19) 	 */
name|l_layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|l_tmp_image_id
argument_list|,
literal|"dummy"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
call|(
name|gint
call|)
argument_list|(
name|gimp_image_base_type
argument_list|(
name|l_tmp_image_id
argument_list|)
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
literal|100.0
argument_list|,
comment|/* Opacity full opaque */
literal|0
argument_list|)
expr_stmt|;
comment|/* NORMAL */
name|gimp_image_add_layer
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_set_offsets
argument_list|(
name|l_layer_id
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_layer_id
operator|=
name|gimp_image_flatten
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
name|gimp_layer_add_alpha
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_call_render: flattened layer_id:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p_mov_call_render: tmp_image_id:%d  apv_mlayer_image:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
block|}
comment|/* set layername (including delay for the framerate) */
name|l_name
operator|=
name|g_strdup_printf
argument_list|(
literal|"frame_%04d (%dms)"
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|1000
operator|/
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_framerate
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_layer_set_name
argument_list|(
name|l_layer_id
argument_list|,
name|l_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
comment|/* remove (its only) layer from source */
name|gimp_image_remove_layer
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_layer_id
argument_list|)
expr_stmt|;
comment|/* and set the dst_image as it's new Master */
name|p_gimp_drawable_set_image
argument_list|(
name|l_layer_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
comment|/* add the layer to the anim preview multilayer image */
name|gimp_image_add_layer
argument_list|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|,
name|l_layer_id
argument_list|,
name|apv_layerstack
argument_list|)
expr_stmt|;
block|}
else|else
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_call_render */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_advance_src_layer  * advance layer index according to stepmode  * ============================================================================  */
end_comment

begin_function
DECL|function|p_mov_advance_src_layer (t_mov_current * cur_ptr,int src_stepmode)
name|void
name|p_mov_advance_src_layer
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|int
name|src_stepmode
parameter_list|)
block|{
specifier|static
name|int
name|l_ping
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_advance_src_layer: stepmode=%d last_layer=%d idx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|src_stepmode
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_last_layer
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_layer_idx
argument_list|)
expr_stmt|;
comment|/* note: top layer has index 0    *       therfore reverse loops have to count up    */
if|if
condition|(
operator|(
name|cur_ptr
operator|->
name|src_last_layer
operator|>
literal|0
operator|)
operator|&&
operator|(
name|src_stepmode
operator|!=
name|GAP_STEP_NONE
operator|)
condition|)
block|{
switch|switch
condition|(
name|src_stepmode
condition|)
block|{
case|case
name|GAP_STEP_ONCE_REV
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_ONCE
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_PING_PONG
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|+=
name|l_ping
expr_stmt|;
if|if
condition|(
name|l_ping
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|1
expr_stmt|;
name|l_ping
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
operator|-
literal|1
expr_stmt|;
name|l_ping
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GAP_STEP_LOOP_REV
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_LOOP
case|:
default|default:
name|cur_ptr
operator|->
name|src_layer_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end  p_advance_src_layer */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_advance_src_frame  *   advance chached image to next source frame according to FRAME based pvals->stepmode  * ============================================================================  */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_mov_advance_src_frame (t_mov_current * cur_ptr,t_mov_values * pvals)
name|p_mov_advance_src_frame
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
block|{
specifier|static
name|int
name|l_ping
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|pvals
operator|->
name|src_stepmode
operator|!=
name|GAP_STEP_FRAME_NONE
condition|)
block|{
if|if
condition|(
name|pvals
operator|->
name|cache_ainfo_ptr
operator|==
name|NULL
condition|)
block|{
name|pvals
operator|->
name|cache_ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|pvals
operator|->
name|src_image_id
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
operator|<
literal|0
condition|)
block|{
name|p_dir_ainfo
argument_list|(
name|pvals
operator|->
name|cache_ainfo_ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_advance_src_frame: stepmode=%d frame_cnt=%d first_frame=%d last_frame=%d idx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|src_stepmode
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|frame_cnt
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_frame_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|frame_cnt
operator|>
literal|1
operator|)
operator|&&
operator|(
name|pvals
operator|->
name|src_stepmode
operator|!=
name|GAP_STEP_FRAME_NONE
operator|)
condition|)
block|{
switch|switch
condition|(
name|pvals
operator|->
name|src_stepmode
condition|)
block|{
case|case
name|GAP_STEP_FRAME_ONCE_REV
case|:
name|cur_ptr
operator|->
name|src_frame_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_frame_idx
operator|<
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_FRAME_ONCE
case|:
name|cur_ptr
operator|->
name|src_frame_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_frame_idx
operator|>
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_FRAME_PING_PONG
case|:
name|cur_ptr
operator|->
name|src_frame_idx
operator|+=
name|l_ping
expr_stmt|;
if|if
condition|(
name|l_ping
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_frame_idx
operator|<
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
operator|+
literal|1
expr_stmt|;
name|l_ping
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_frame_idx
operator|>
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
operator|-
literal|1
expr_stmt|;
name|l_ping
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GAP_STEP_FRAME_LOOP_REV
case|:
name|cur_ptr
operator|->
name|src_frame_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_frame_idx
operator|<
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_FRAME_LOOP
case|:
default|default:
name|cur_ptr
operator|->
name|src_frame_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_frame_idx
operator|>
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|pvals
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
break|break;
block|}
name|p_fetch_src_frame
argument_list|(
name|pvals
argument_list|,
name|cur_ptr
operator|->
name|src_frame_idx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end  p_advance_src_frame */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_execute  * Copy layer(s) from Sourceimage to given destination frame range,  * varying koordinates and opacity of the copied layer.  * To each affected destination frame exactly one copy of a source layer is added.  * The source layer is iterated through all layers of the sourceimage  * according to stemmode parameter.  * For the placement the layers act as if their size is equal to their  * Sourceimages size.  * ============================================================================  */
end_comment

begin_comment
comment|/* TODO: add keyframe support */
end_comment

begin_function
name|long
DECL|function|p_mov_execute (t_mov_data * mov_ptr)
name|p_mov_execute
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|)
block|{
comment|/* MIX_VALUE  0.0<= factor<= 1.0  *  result is a  for factor 0.0  *            b  for factor 1.0  *            mix for factors inbetween  */
DECL|macro|MIX_VALUE (factor,a,b)
define|#
directive|define
name|MIX_VALUE
parameter_list|(
name|factor
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|((a * (1.0 - factor)) +  (b * factor))
name|gint
name|l_idx
decl_stmt|;
name|t_mov_current
name|l_current_data
decl_stmt|;
name|t_mov_current
modifier|*
name|cur_ptr
decl_stmt|;
name|t_mov_values
modifier|*
name|val_ptr
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|;
name|gdouble
name|l_fpl
decl_stmt|;
comment|/* frames_per_line */
name|gdouble
name|l_flt_posfactor
decl_stmt|;
name|long
name|l_frame_step
decl_stmt|;
name|gdouble
name|l_frames
decl_stmt|;
name|long
name|l_cnt
decl_stmt|;
name|long
name|l_points
decl_stmt|;
name|long
name|l_ptidx
decl_stmt|;
name|long
name|l_prev_keyptidx
decl_stmt|;
name|long
name|l_fridx
decl_stmt|;
name|gdouble
name|l_flt_count
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint
name|l_idk
decl_stmt|;
name|gint
name|l_prev_keyframe
decl_stmt|;
name|gint
name|l_apv_layerstack
decl_stmt|;
name|gdouble
name|l_flt_timing
index|[
name|GAP_MOV_MAX_POINT
index|]
decl_stmt|;
comment|/* timing table in relative frame numbers (0.0 == the first handled frame) */
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_image_id
operator|<
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|_
argument_list|(
literal|"No Source Image was selected.\n"
literal|"Please open a 2nd Image of the same type before opening Move Path."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_apv_layerstack
operator|=
literal|0
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
operator|<
literal|0
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Copying Layers into Frames..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Generating Animated Preview..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: values got from dialog:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apv_mlayer_image: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apv_mode: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apv_scale x: %f y:%f\n"
argument_list|,
operator|(
name|float
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scalex
argument_list|,
operator|(
name|float
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scaley
argument_list|)
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
condition|)
block|{
name|printf
argument_list|(
literal|"apv_gap_paste_buf: %s\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"apv_gap_paste_buf: ** IS NULL ** (do not copy to paste buffer)\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"src_image_id :%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_layer_id :%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_handle :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_handle
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_stepmode :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_stepmode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_paintmode :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_paintmode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clip_to_img :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|clip_to_img
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_range_start :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_range_start
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_range_end :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_range_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_layerstack :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_layerstack
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"p_x[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p_y[%d] : :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opacity[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|opacity
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"w_resize[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|w_resize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"h_resize[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|h_resize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rotation[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keyframe[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keyframe_abs[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|l_rc
operator|=
literal|0
expr_stmt|;
name|cur_ptr
operator|=
operator|&
name|l_current_data
expr_stmt|;
name|val_ptr
operator|=
name|mov_ptr
operator|->
name|val_ptr
expr_stmt|;
comment|/* set offsets (in cur_ptr)  according to handle mode and src_img dimension */
name|p_set_handle_offsets
argument_list|(
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
comment|/* test for invers range */
if|if
condition|(
name|val_ptr
operator|->
name|dst_range_start
operator|>
name|val_ptr
operator|->
name|dst_range_end
condition|)
block|{
comment|/* step down */
name|l_frame_step
operator|=
operator|-
literal|1
expr_stmt|;
name|l_cnt
operator|=
literal|1
operator|+
operator|(
name|val_ptr
operator|->
name|dst_range_start
operator|-
name|val_ptr
operator|->
name|dst_range_end
operator|)
expr_stmt|;
block|}
else|else
block|{
name|l_frame_step
operator|=
literal|1
expr_stmt|;
name|l_cnt
operator|=
literal|1
operator|+
operator|(
name|val_ptr
operator|->
name|dst_range_end
operator|-
name|val_ptr
operator|->
name|dst_range_start
operator|)
expr_stmt|;
block|}
name|l_frames
operator|=
operator|(
name|gdouble
operator|)
name|l_cnt
expr_stmt|;
comment|/* nr. of affected frames */
name|l_points
operator|=
name|val_ptr
operator|->
name|point_idx_max
operator|+
literal|1
expr_stmt|;
comment|/* nr. of available points */
if|if
condition|(
name|l_points
operator|>
name|l_frames
condition|)
block|{
comment|/* cut off some points if we got more than frames */
name|l_points
operator|=
name|l_cnt
expr_stmt|;
block|}
if|if
condition|(
name|l_points
operator|<
literal|2
condition|)
block|{
comment|/* copy point[0] to point [1] because we need at least 2        * points for the algorithms below to work.         * (simulates a line with lenght 0, to move along)        */
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: added a 2nd Point\n"
argument_list|)
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
literal|1
index|]
operator|.
name|p_x
operator|=
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_x
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
literal|1
index|]
operator|.
name|p_y
operator|=
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_y
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
literal|1
index|]
operator|.
name|opacity
operator|=
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|opacity
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
literal|1
index|]
operator|.
name|w_resize
operator|=
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|w_resize
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
literal|1
index|]
operator|.
name|h_resize
operator|=
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|h_resize
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
literal|1
index|]
operator|.
name|rotation
operator|=
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|rotation
expr_stmt|;
name|l_points
operator|=
literal|2
expr_stmt|;
block|}
name|cur_ptr
operator|->
name|dst_frame_nr
operator|=
name|val_ptr
operator|->
name|dst_range_start
expr_stmt|;
name|cur_ptr
operator|->
name|src_layers
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_stepmode
operator|<
name|GAP_STEP_FRAME
condition|)
block|{
name|cur_ptr
operator|->
name|src_layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|val_ptr
operator|->
name|src_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR (in p_mov_execute): Got no layers from SrcImage\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|l_nlayers
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR (in p_mov_execute): Source Image has no layers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cur_ptr
operator|->
name|src_last_layer
operator|=
name|l_nlayers
operator|-
literal|1
expr_stmt|;
comment|/* findout index of src_layer_id */
for|for
control|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
init|;
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
name|l_nlayers
condition|;
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
control|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
index|[
name|cur_ptr
operator|->
name|src_layer_idx
index|]
operator|==
name|val_ptr
operator|->
name|src_layer_id
condition|)
break|break;
block|}
name|cur_ptr
operator|->
name|src_last_layer
operator|=
name|l_nlayers
operator|-
literal|1
expr_stmt|;
comment|/* index of last layer */
block|}
else|else
block|{
comment|/* for FRAME stepmodes we use flattened Sorce frames       * (instead of one multilayer source image )       */
name|p_fetch_src_frame
argument_list|(
name|val_ptr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* negative value fetches the selected frame number */
name|cur_ptr
operator|->
name|src_frame_idx
operator|=
name|val_ptr
operator|->
name|cache_ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
if|if
condition|(
operator|(
name|val_ptr
operator|->
name|cache_ainfo_ptr
operator|->
name|first_frame_nr
operator|<
literal|0
operator|)
operator|&&
operator|(
name|val_ptr
operator|->
name|src_stepmode
operator|!=
name|GAP_STEP_FRAME_NONE
operator|)
condition|)
block|{
name|p_dir_ainfo
argument_list|(
name|val_ptr
operator|->
name|cache_ainfo_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* set offsets (in cur_ptr)  according to handle mode and cache_tmp_img dimension */
name|p_set_handle_offsets
argument_list|(
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
block|}
name|cur_ptr
operator|->
name|currX
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_x
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_y
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|opacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|w_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|h_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|rotation
expr_stmt|;
comment|/* RENDER add current src_layer to current frame */
name|l_rc
operator|=
name|p_mov_call_render
argument_list|(
name|mov_ptr
argument_list|,
name|cur_ptr
argument_list|,
name|l_apv_layerstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: l_points=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_points
argument_list|)
expr_stmt|;
comment|/* how many frames are affected from one line of the moving path */
name|l_fpl
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|l_frames
operator|-
literal|1.0
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
name|l_points
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: initial l_fpl=%f\n"
argument_list|,
name|l_fpl
argument_list|)
expr_stmt|;
comment|/* calculate l_flt_timing controlpoint timing table considering keyframes */
name|l_prev_keyptidx
operator|=
literal|0
expr_stmt|;
name|l_prev_keyframe
operator|=
literal|0
expr_stmt|;
name|l_flt_timing
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|l_flt_timing
index|[
name|l_points
operator|-
literal|1
index|]
operator|=
name|l_frames
operator|-
literal|1
expr_stmt|;
name|l_flt_count
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|l_ptidx
operator|=
literal|1
init|;
name|l_ptidx
operator|<
name|l_points
operator|-
literal|1
condition|;
name|l_ptidx
operator|++
control|)
block|{
comment|/* search for keyframes */
if|if
condition|(
name|l_ptidx
operator|>
name|l_prev_keyptidx
condition|)
block|{
for|for
control|(
name|l_idk
operator|=
name|l_ptidx
init|;
name|l_idk
operator|<
name|l_points
condition|;
name|l_idk
operator|++
control|)
block|{
if|if
condition|(
name|l_idk
operator|==
name|l_points
operator|-
literal|1
condition|)
block|{
comment|/* last point is always an implicite  keyframe */
name|l_fpl
operator|=
operator|(
call|(
name|gdouble
call|)
argument_list|(
operator|(
name|l_frames
operator|-
literal|1
operator|)
operator|-
name|l_prev_keyframe
argument_list|)
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
operator|(
name|l_idk
operator|-
name|l_ptidx
operator|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|l_prev_keyframe
operator|=
name|l_frames
operator|-
literal|1
expr_stmt|;
name|l_prev_keyptidx
operator|=
name|l_idk
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: last point is implicite keyframe l_fpl=%f\n"
argument_list|,
name|l_fpl
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
operator|>
literal|0
condition|)
block|{
comment|/* found a keyframe, have to recalculate frames_per_line */
name|l_fpl
operator|=
operator|(
call|(
name|gdouble
call|)
argument_list|(
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
operator|-
name|l_prev_keyframe
argument_list|)
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
operator|(
name|l_idk
operator|-
name|l_ptidx
operator|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|l_prev_keyframe
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
expr_stmt|;
name|l_prev_keyptidx
operator|=
name|l_idk
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: keyframe l_fpl=%f\n"
argument_list|,
name|l_fpl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|l_flt_count
operator|+=
name|l_fpl
expr_stmt|;
name|l_flt_timing
index|[
name|l_ptidx
index|]
operator|=
name|l_flt_count
expr_stmt|;
if|if
condition|(
name|l_fpl
operator|<
literal|1.0
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: ** Error frames per line at point[%d] = %f  (is less than 1.0 !!)\n"
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
argument_list|,
operator|(
name|float
operator|)
name|l_fpl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: --- CONTROLPOINT relative frametiming TABLE -----\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_ptidx
operator|=
literal|0
init|;
name|l_ptidx
operator|<
name|l_points
condition|;
name|l_ptidx
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: l_flt_timing[%02d] = %f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
argument_list|,
operator|(
name|float
operator|)
name|l_flt_timing
index|[
name|l_ptidx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* loop for each frame within the range (may step up or down) */
name|l_ptidx
operator|=
literal|1
expr_stmt|;
name|cur_ptr
operator|->
name|dst_frame_nr
operator|=
name|val_ptr
operator|->
name|dst_range_start
expr_stmt|;
for|for
control|(
name|l_fridx
operator|=
literal|1
init|;
name|l_fridx
operator|<
name|l_cnt
condition|;
name|l_fridx
operator|++
control|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"\np_mov_execute: l_fridx=%ld, l_flt_timing[l_ptidx]=%f, l_rc=%d l_ptidx=%d, l_prev_keyptidx=%d\n"
argument_list|,
name|l_fridx
argument_list|,
operator|(
name|float
operator|)
name|l_flt_timing
index|[
name|l_ptidx
index|]
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
argument_list|,
operator|(
name|int
operator|)
name|l_prev_keyptidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
break|break;
comment|/* advance frame_nr, (1st frame was done outside this loop) */
name|cur_ptr
operator|->
name|dst_frame_nr
operator|+=
name|l_frame_step
expr_stmt|;
comment|/* +1  or -1 */
if|if
condition|(
operator|(
name|gdouble
operator|)
name|l_fridx
operator|>
name|l_flt_timing
index|[
name|l_ptidx
index|]
condition|)
block|{
comment|/* change deltas for next line of the move path */
if|if
condition|(
name|l_ptidx
operator|<
name|l_points
operator|-
literal|1
condition|)
block|{
name|l_ptidx
operator|++
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: advance to controlpoint l_ptidx=%d, l_flt_timing[l_ptidx]=%f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
argument_list|,
operator|(
name|float
operator|)
name|l_flt_timing
index|[
name|l_ptidx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: ** ERROR overflow l_ptidx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
argument_list|)
expr_stmt|;
block|}
block|}
name|l_fpl
operator|=
operator|(
name|l_flt_timing
index|[
name|l_ptidx
index|]
operator|-
name|l_flt_timing
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|)
expr_stmt|;
comment|/* float frames per line */
if|if
condition|(
name|l_fpl
operator|!=
literal|0.0
condition|)
block|{
name|l_flt_posfactor
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|l_fridx
operator|-
name|l_flt_timing
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|)
operator|/
name|l_fpl
expr_stmt|;
block|}
else|else
block|{
name|l_flt_posfactor
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: ** ERROR l_fpl is 0.0 frames per line\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: l_fpl=%f, l_flt_posfactor=%f\n"
argument_list|,
operator|(
name|float
operator|)
name|l_fpl
argument_list|,
operator|(
name|float
operator|)
name|l_flt_posfactor
argument_list|)
expr_stmt|;
name|l_flt_posfactor
operator|=
name|CLAMP
argument_list|(
name|l_flt_posfactor
argument_list|,
literal|0.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currX
operator|=
name|MIX_VALUE
argument_list|(
name|l_flt_posfactor
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_x
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|p_x
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|=
name|MIX_VALUE
argument_list|(
name|l_flt_posfactor
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_y
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|=
name|MIX_VALUE
argument_list|(
name|l_flt_posfactor
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|opacity
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|opacity
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|=
name|MIX_VALUE
argument_list|(
name|l_flt_posfactor
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|w_resize
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|w_resize
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|=
name|MIX_VALUE
argument_list|(
name|l_flt_posfactor
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|h_resize
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|h_resize
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|=
name|MIX_VALUE
argument_list|(
name|l_flt_posfactor
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|rotation
argument_list|,
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ROTATE [%02d] %d    [%02d] %d       MIX: %f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|rotation
argument_list|,
operator|(
name|int
operator|)
name|l_ptidx
argument_list|,
operator|(
name|int
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|rotation
argument_list|,
operator|(
name|float
operator|)
name|cur_ptr
operator|->
name|currRotation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val_ptr
operator|->
name|src_stepmode
operator|<
name|GAP_STEP_FRAME
condition|)
block|{
comment|/* advance settings for next src layer */
name|p_mov_advance_src_layer
argument_list|(
name|cur_ptr
argument_list|,
name|val_ptr
operator|->
name|src_stepmode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* advance settings for next source frame */
name|p_mov_advance_src_frame
argument_list|(
name|cur_ptr
argument_list|,
name|val_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_frame_step
operator|<
literal|0
condition|)
block|{
comment|/* if we step down, we have to insert the layer 	  * as lowest layer in the existing layerstack 	  * of the animated preview multilayer image. 	  * (if we step up, we always use 0 as l_apv_layerstack, 	  *  that means always insert on top of the layerstack) 	  */
name|l_apv_layerstack
operator|++
expr_stmt|;
block|}
comment|/* RENDER add current src_layer to current frame */
name|l_rc
operator|=
name|p_mov_call_render
argument_list|(
name|mov_ptr
argument_list|,
name|cur_ptr
argument_list|,
name|l_apv_layerstack
argument_list|)
expr_stmt|;
comment|/* show progress */
if|if
condition|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|=
operator|(
name|gdouble
operator|)
name|l_fridx
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|l_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|cur_ptr
operator|->
name|src_layers
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|src_layers
operator|=
name|NULL
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_execute */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_anim_preview  *   Generate an animate preview for the move path  * ============================================================================  */
end_comment

begin_function
name|gint32
DECL|function|p_mov_anim_preview (t_mov_values * pvals_orig,t_anim_info * ainfo_ptr,gint preview_frame_nr)
name|p_mov_anim_preview
parameter_list|(
name|t_mov_values
modifier|*
name|pvals_orig
parameter_list|,
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|gint
name|preview_frame_nr
parameter_list|)
block|{
name|t_mov_data
name|apv_mov_data
decl_stmt|;
name|t_mov_values
name|apv_mov_vals
decl_stmt|;
name|t_mov_data
modifier|*
name|l_mov_ptr
decl_stmt|;
name|t_mov_values
modifier|*
name|l_pvals
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
name|gint32
name|l_size_x
decl_stmt|,
name|l_size_y
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint32
name|l_tmp_frame_id
decl_stmt|;
name|gint32
name|l_mlayer_image_id
decl_stmt|;
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|GimpImageBaseType
name|l_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|gint32
name|l_stackpos
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_src_layers
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|l_mov_ptr
operator|=
operator|&
name|apv_mov_data
expr_stmt|;
name|l_pvals
operator|=
operator|&
name|apv_mov_vals
expr_stmt|;
comment|/* copy settings */
name|memcpy
argument_list|(
name|l_pvals
argument_list|,
name|pvals_orig
argument_list|,
sizeof|sizeof
argument_list|(
name|t_mov_values
argument_list|)
argument_list|)
expr_stmt|;
name|l_mov_ptr
operator|->
name|val_ptr
operator|=
name|l_pvals
expr_stmt|;
name|l_mov_ptr
operator|->
name|dst_ainfo_ptr
operator|=
name|ainfo_ptr
expr_stmt|;
comment|/* init local cached src image for anim preview generation.    * (never mix cached src image for normal and anim preview    *  because anim previews are often scaled down)    */
name|l_pvals
operator|->
name|cache_src_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_pvals
operator|->
name|cache_tmp_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_pvals
operator|->
name|cache_tmp_layer_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_pvals
operator|->
name|cache_frame_number
operator|=
operator|-
literal|1
expr_stmt|;
name|l_pvals
operator|->
name|cache_ainfo_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* -1 assume no tmp_image (use unscaled original source) */
name|l_tmp_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_stackpos
operator|=
literal|0
expr_stmt|;
comment|/* Scale (down) needed ? */
if|if
condition|(
operator|(
name|l_pvals
operator|->
name|apv_scalex
operator|!=
literal|100.0
operator|)
operator|||
operator|(
name|l_pvals
operator|->
name|apv_scaley
operator|!=
literal|100.0
operator|)
condition|)
block|{
comment|/* scale the controlpoint koords */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|l_pvals
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
operator|=
operator|(
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
operator|=
operator|(
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
block|}
comment|/* for the FRAME based step modes we cant Scale here,      * we have to scale later (at fetch time of the frame)      */
if|if
condition|(
name|l_pvals
operator|->
name|src_stepmode
operator|<
name|GAP_STEP_FRAME
condition|)
block|{
comment|/* copy and scale the source object image */
name|l_tmp_image_id
operator|=
name|p_gimp_channel_ops_duplicate
argument_list|(
name|pvals_orig
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
name|l_pvals
operator|->
name|src_image_id
operator|=
name|l_tmp_image_id
expr_stmt|;
name|l_size_x
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
name|l_size_y
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_x
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_y
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
comment|/* findout the src_layer id in the scaled copy by stackpos index */
name|l_pvals
operator|->
name|src_layer_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_src_layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|pvals_orig
operator|->
name|src_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_src_layers
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: p_mov_anim_preview GOT no src_layers (original image_id %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|pvals_orig
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|l_stackpos
operator|=
literal|0
init|;
name|l_stackpos
operator|<
name|l_nlayers
condition|;
name|l_stackpos
operator|++
control|)
block|{
if|if
condition|(
name|l_src_layers
index|[
name|l_stackpos
index|]
operator|==
name|pvals_orig
operator|->
name|src_layer_id
condition|)
break|break;
block|}
name|g_free
argument_list|(
name|l_src_layers
argument_list|)
expr_stmt|;
name|l_src_layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|l_tmp_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_src_layers
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: p_mov_anim_preview GOT no src_layers (scaled copy image_id %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_pvals
operator|->
name|src_layer_id
operator|=
name|l_src_layers
index|[
name|l_stackpos
index|]
expr_stmt|;
name|g_free
argument_list|(
name|l_src_layers
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: orig  src_image_id:%d src_layer:%d, stackpos:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|pvals_orig
operator|->
name|src_image_id
argument_list|,
operator|(
name|int
operator|)
name|pvals_orig
operator|->
name|src_layer_id
argument_list|,
operator|(
name|int
operator|)
name|l_stackpos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Scaled src_image_id:%d scaled_src_layer:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: src_image_id %d (orig:%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|src_image_id
argument_list|,
operator|(
name|int
operator|)
name|pvals_orig
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* create the animated preview multilayer image in (scaled) framesize */
name|l_width
operator|=
operator|(
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_height
operator|=
operator|(
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
name|l_type
operator|=
name|gimp_image_base_type
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_mlayer_image_id
operator|=
name|gimp_image_new
argument_list|(
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|)
expr_stmt|;
name|l_pvals
operator|->
name|apv_mlayer_image
operator|=
name|l_mlayer_image_id
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: apv_mlayer_image %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
block|}
comment|/* APV_MODE (Wich frames to use in the preview?)  */
switch|switch
condition|(
name|l_pvals
operator|->
name|apv_mode
condition|)
block|{
name|gchar
modifier|*
name|l_filename
decl_stmt|;
case|case
name|GAP_APV_QUICK
case|:
comment|/* use an empty dummy frame for all frames */
name|l_tmp_frame_id
operator|=
name|gimp_image_new
argument_list|(
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|GAP_APV_ONE_FRAME
case|:
comment|/* use only one frame in the preview */
name|l_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|preview_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_tmp_frame_id
operator|=
name|p_load_image
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_pvals
operator|->
name|apv_scalex
operator|!=
literal|100.0
operator|)
operator|||
operator|(
name|l_pvals
operator|->
name|apv_scaley
operator|!=
literal|100.0
operator|)
condition|)
block|{
name|l_size_x
operator|=
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_frame_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_size_y
operator|=
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_frame_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_frame_id
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_x
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_y
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* GAP_APV_EXACT */
comment|/* read the original frames for the preview (slow) */
name|l_tmp_frame_id
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|l_pvals
operator|->
name|apv_src_frame
operator|=
name|l_tmp_frame_id
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: apv_src_frame %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|apv_src_frame
argument_list|)
expr_stmt|;
block|}
comment|/* EXECUTE move path in preview Mode */
comment|/* --------------------------------- */
name|l_rc
operator|=
name|p_mov_execute
argument_list|(
name|l_mov_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_pvals
operator|->
name|cache_tmp_image_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: DELETE cache_tmp_image_id:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|cache_tmp_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* destroy the cached frame image */
name|gimp_image_delete
argument_list|(
name|l_pvals
operator|->
name|cache_tmp_image_id
argument_list|)
expr_stmt|;
name|l_pvals
operator|->
name|cache_tmp_image_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* add a display for the animated preview multilayer image */
name|gimp_display_new
argument_list|(
name|l_mlayer_image_id
argument_list|)
expr_stmt|;
comment|/* delete the scaled copy of the src image (if there is one) */
if|if
condition|(
name|l_tmp_image_id
operator|>=
literal|0
condition|)
block|{
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* delete the (scaled) dummy frames (if there is one) */
if|if
condition|(
name|l_tmp_frame_id
operator|>=
literal|0
condition|)
block|{
name|gimp_image_delete
argument_list|(
name|l_tmp_frame_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_mlayer_image_id
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_anim_preview */
end_comment

begin_comment
comment|/* ============================================================================  * p_con_keyframe  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_conv_keyframe_to_rel (gint abs_keyframe,t_mov_values * pvals)
name|p_conv_keyframe_to_rel
parameter_list|(
name|gint
name|abs_keyframe
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
block|{
if|if
condition|(
name|pvals
operator|->
name|dst_range_start
operator|<=
name|pvals
operator|->
name|dst_range_end
condition|)
block|{
return|return
operator|(
name|abs_keyframe
operator|-
name|pvals
operator|->
name|dst_range_start
operator|)
return|;
block|}
return|return
operator|(
name|pvals
operator|->
name|dst_range_start
operator|-
name|abs_keyframe
operator|)
return|;
block|}
end_function

begin_function
name|gint
DECL|function|p_conv_keyframe_to_abs (gint rel_keyframe,t_mov_values * pvals)
name|p_conv_keyframe_to_abs
parameter_list|(
name|gint
name|rel_keyframe
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
block|{
if|if
condition|(
name|pvals
operator|->
name|dst_range_start
operator|<=
name|pvals
operator|->
name|dst_range_end
condition|)
block|{
return|return
operator|(
name|rel_keyframe
operator|+
name|pvals
operator|->
name|dst_range_start
operator|)
return|;
block|}
return|return
operator|(
name|pvals
operator|->
name|dst_range_start
operator|-
name|rel_keyframe
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_gap_save_pointfile  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_gap_save_pointfile (char * filename,t_mov_values * pvals)
name|p_gap_save_pointfile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# GAP file contains saved Move Path Point Table\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d  %d  # current_point  points\n"
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point_idx
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point_idx_max
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# x  y   width height opacity rotation [rel_keyframe]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|pvals
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l_idx
operator|>
literal|0
operator|)
operator|&&
operator|(
name|l_idx
operator|<
name|pvals
operator|->
name|point_idx_max
operator|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|>
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%04d %04d  %03d %03d  %03d %d %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|w_resize
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|h_resize
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|opacity
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
argument_list|,
operator|(
name|int
operator|)
name|p_conv_keyframe_to_rel
argument_list|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|,
name|pvals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%04d %04d  %03d %03d  %03d %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|w_resize
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|h_resize
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|opacity
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_gap_load_pointfile  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_gap_load_pointfile (char * filename,t_mov_values * pvals)
name|p_gap_load_pointfile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
block|{
DECL|macro|POINT_REC_MAX
define|#
directive|define
name|POINT_REC_MAX
value|128
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
name|char
name|l_buff
index|[
name|POINT_REC_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|gint
name|l_cnt
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|gint
name|l_v1
decl_stmt|,
name|l_v2
decl_stmt|,
name|l_v3
decl_stmt|,
name|l_v4
decl_stmt|,
name|l_v5
decl_stmt|,
name|l_v6
decl_stmt|,
name|l_v7
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|l_rc
operator|)
return|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|l_idx
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|fgets
argument_list|(
name|l_buff
argument_list|,
name|POINT_REC_MAX
argument_list|,
name|l_fp
argument_list|)
condition|)
block|{
comment|/* skip leading blanks */
name|l_ptr
operator|=
name|l_buff
expr_stmt|;
while|while
condition|(
operator|*
name|l_ptr
operator|==
literal|' '
condition|)
block|{
name|l_ptr
operator|++
expr_stmt|;
block|}
comment|/* check if line empty or comment only (starts with '#') */
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
operator|*
name|l_ptr
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|l_ptr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|l_cnt
operator|=
name|sscanf
argument_list|(
name|l_ptr
argument_list|,
literal|"%d%d%d%d%d%d%d"
argument_list|,
operator|&
name|l_v1
argument_list|,
operator|&
name|l_v2
argument_list|,
operator|&
name|l_v3
argument_list|,
operator|&
name|l_v4
argument_list|,
operator|&
name|l_v5
argument_list|,
operator|&
name|l_v6
argument_list|,
operator|&
name|l_v7
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_idx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|l_cnt
operator|<
literal|2
operator|)
operator|||
operator|(
name|l_v2
operator|>
name|GAP_MOV_MAX_POINT
operator|)
operator|||
operator|(
name|l_v1
operator|>
name|l_v2
operator|)
condition|)
block|{
break|break;
block|}
name|pvals
operator|->
name|point_idx
operator|=
name|l_v1
expr_stmt|;
name|pvals
operator|->
name|point_idx_max
operator|=
name|l_v2
operator|-
literal|1
expr_stmt|;
name|l_idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|l_cnt
operator|!=
literal|6
operator|)
operator|&&
operator|(
name|l_cnt
operator|!=
literal|7
operator|)
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* have to call p_reset_points() when called from dialog window */
break|break;
block|}
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
operator|=
name|l_v1
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
operator|=
name|l_v2
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|w_resize
operator|=
name|l_v3
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|h_resize
operator|=
name|l_v4
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|opacity
operator|=
name|l_v5
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
operator|=
name|l_v6
expr_stmt|;
if|if
condition|(
operator|(
name|l_cnt
operator|==
literal|7
operator|)
operator|&&
operator|(
name|l_idx
operator|>
literal|0
operator|)
condition|)
block|{
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|=
name|l_v7
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
operator|=
name|p_conv_keyframe_to_abs
argument_list|(
name|l_v7
argument_list|,
name|pvals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
operator|=
literal|0
expr_stmt|;
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|=
literal|0
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l_idx
operator|>
name|pvals
operator|->
name|point_idx_max
condition|)
break|break;
block|}
block|}
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_idx
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
comment|/* OK if we found at least one valid Controlpoint in the file */
block|}
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * procedured for calculating angels  *   (used in rotate_follow option)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gdouble
DECL|function|p_calc_angle (gint p1x,gint p1y,gint p2x,gint p2y)
name|p_calc_angle
parameter_list|(
name|gint
name|p1x
parameter_list|,
name|gint
name|p1y
parameter_list|,
name|gint
name|p2x
parameter_list|,
name|gint
name|p2y
parameter_list|)
block|{
comment|/* calculate angle in degree    * how to rotate an object that follows the line between p1 and p2    */
name|gdouble
name|l_a
decl_stmt|;
name|gdouble
name|l_b
decl_stmt|;
name|gdouble
name|l_angle_rad
decl_stmt|;
name|gdouble
name|l_angle
decl_stmt|;
name|l_a
operator|=
name|p2x
operator|-
name|p1x
expr_stmt|;
name|l_b
operator|=
operator|(
name|p2y
operator|-
name|p1y
operator|)
operator|*
operator|(
operator|-
literal|1.0
operator|)
expr_stmt|;
if|if
condition|(
name|l_a
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l_b
operator|<
literal|0
condition|)
block|{
name|l_angle
operator|=
literal|90.0
expr_stmt|;
block|}
else|else
block|{
name|l_angle
operator|=
literal|270.0
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_angle_rad
operator|=
name|atan
argument_list|(
name|l_b
operator|/
name|l_a
argument_list|)
expr_stmt|;
name|l_angle
operator|=
operator|(
name|l_angle_rad
operator|*
literal|180.0
operator|)
operator|/
literal|3.14159
expr_stmt|;
if|if
condition|(
name|l_a
operator|<
literal|0
condition|)
block|{
name|l_angle
operator|=
literal|180
operator|-
name|l_angle
expr_stmt|;
block|}
else|else
block|{
name|l_angle
operator|=
name|l_angle
operator|*
operator|(
operator|-
literal|1.0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_calc_angle: p1(%d/%d) p2(%d/%d)  a=%f, b=%f, angle=%f\n"
argument_list|,
operator|(
name|int
operator|)
name|p1x
argument_list|,
operator|(
name|int
operator|)
name|p1y
argument_list|,
operator|(
name|int
operator|)
name|p2x
argument_list|,
operator|(
name|int
operator|)
name|p2y
argument_list|,
operator|(
name|float
operator|)
name|l_a
argument_list|,
operator|(
name|float
operator|)
name|l_b
argument_list|,
operator|(
name|float
operator|)
name|l_angle
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_angle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gdouble
DECL|function|p_rotatate_less_than_180 (gdouble angle,gdouble angle_new,gint * turns)
name|p_rotatate_less_than_180
parameter_list|(
name|gdouble
name|angle
parameter_list|,
name|gdouble
name|angle_new
parameter_list|,
name|gint
modifier|*
name|turns
parameter_list|)
block|{
comment|/* if an object  follows a circular path and does more than one turn    * there comes a point where it flips from say 265 degree to -85 degree.    *    * if there are more (say 3) frames between the controlpoints,    * the object performs an unexpected rotation effect because the iteration    * from 265 to -85  is done  in a sequence like this: 265.0, 148.6, 32.3, -85.0    *    * we can avoid this by preventing angle changes of more than 180 degree.    * in such a case this procedure adjusts the new_angle from -85 to 275    * that results in oterations like this: 265.0, 268.3, 271.6, 275.0    */
name|gint
name|l_diff
decl_stmt|;
name|gint
name|l_turns
decl_stmt|;
name|l_diff
operator|=
name|angle
operator|-
operator|(
name|angle_new
operator|+
operator|(
operator|*
name|turns
operator|*
literal|360
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_diff
operator|>=
operator|-
literal|180
operator|)
operator|&&
operator|(
name|l_diff
operator|<
literal|180
operator|)
condition|)
block|{
return|return
operator|(
name|angle_new
operator|+
operator|(
operator|*
name|turns
operator|*
literal|360
operator|)
operator|)
return|;
block|}
name|l_diff
operator|=
operator|(
name|angle
operator|-
name|angle_new
operator|)
expr_stmt|;
if|if
condition|(
name|l_diff
operator|<
literal|0
condition|)
block|{
name|l_turns
operator|=
operator|(
name|l_diff
operator|/
literal|360
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l_turns
operator|=
operator|(
name|l_diff
operator|/
literal|360
operator|)
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|turns
operator|=
name|l_turns
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_rotatate_less_than_180: turns %d angle_new:%f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_turns
argument_list|,
operator|(
name|float
operator|)
name|angle_new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|angle_new
operator|+
operator|(
name|l_turns
operator|*
literal|360
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_calculate_rotate_follow  * ============================================================================  */
end_comment

begin_function
name|void
DECL|function|p_calculate_rotate_follow (t_mov_values * pvals,gint32 startangle)
name|p_calculate_rotate_follow
parameter_list|(
name|t_mov_values
modifier|*
name|pvals
parameter_list|,
name|gint32
name|startangle
parameter_list|)
block|{
name|gint
name|l_idx
decl_stmt|;
name|gdouble
name|l_startangle
decl_stmt|;
name|gdouble
name|l_angle_1
decl_stmt|;
name|gdouble
name|l_angle_2
decl_stmt|;
name|gdouble
name|l_angle_new
decl_stmt|;
name|gdouble
name|l_angle
decl_stmt|;
name|gint
name|l_turns
decl_stmt|;
name|l_startangle
operator|=
name|startangle
expr_stmt|;
if|if
condition|(
name|pvals
operator|->
name|point_idx_max
operator|>
literal|1
condition|)
block|{
name|l_angle
operator|=
literal|0.0
expr_stmt|;
name|l_turns
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|pvals
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|l_idx
operator|==
literal|0
condition|)
block|{
name|l_angle
operator|=
name|p_calc_angle
argument_list|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|+
literal|1
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|+
literal|1
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l_idx
operator|==
name|pvals
operator|->
name|point_idx_max
condition|)
block|{
name|l_angle_new
operator|=
name|p_calc_angle
argument_list|(
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|-
literal|1
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|-
literal|1
index|]
operator|.
name|p_y
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_angle_1
operator|=
name|p_calc_angle
argument_list|(
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|-
literal|1
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|-
literal|1
index|]
operator|.
name|p_y
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
name|l_angle_2
operator|=
name|p_calc_angle
argument_list|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|+
literal|1
index|]
operator|.
name|p_x
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
operator|+
literal|1
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_angle_1
operator|==
literal|0
operator|)
operator|&&
operator|(
name|l_angle_2
operator|==
literal|180
operator|)
condition|)
block|{
name|l_angle_new
operator|=
literal|270
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|l_angle_1
operator|==
literal|90
operator|)
operator|&&
operator|(
name|l_angle_2
operator|==
literal|270
operator|)
condition|)
block|{
name|l_angle_new
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|l_angle_new
operator|=
operator|(
name|l_angle_1
operator|+
name|l_angle_2
operator|)
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|l_angle_1
operator|<
literal|0
operator|)
operator|&&
operator|(
name|l_angle_2
operator|>=
literal|180
operator|)
operator|)
operator|||
operator|(
operator|(
name|l_angle_2
operator|<
literal|0
operator|)
operator|&&
operator|(
name|l_angle_1
operator|>=
literal|180
operator|)
operator|)
condition|)
block|{
name|l_angle_new
operator|+=
literal|180
expr_stmt|;
block|}
block|}
name|l_angle
operator|=
name|p_rotatate_less_than_180
argument_list|(
name|l_angle
argument_list|,
name|l_angle_new
argument_list|,
operator|&
name|l_turns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ROT Follow [%03d] angle = %f\n"
argument_list|,
operator|(
name|int
operator|)
name|l_idx
argument_list|,
operator|(
name|float
operator|)
name|l_angle
argument_list|)
expr_stmt|;
block|}
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
operator|=
name|l_startangle
operator|+
name|l_angle
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_calculate_rotate_follow */
end_comment

begin_comment
comment|/* ============================================================================  * p_gap_chk_keyframes  *   check if controlpoints and keyframe settings are OK  *   return pointer to errormessage on Errors  *      contains "\0" if no errors are found  * ============================================================================  */
end_comment

begin_function
DECL|function|p_gap_chk_keyframes (t_mov_values * pvals)
name|gchar
modifier|*
name|p_gap_chk_keyframes
parameter_list|(
name|t_mov_values
modifier|*
name|pvals
parameter_list|)
block|{
name|gint
name|l_affected_frames
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
name|gint
name|l_errcount
decl_stmt|;
name|gint
name|l_prev_keyframe
decl_stmt|;
name|gint
name|l_prev_frame
decl_stmt|;
name|gchar
modifier|*
name|l_err
decl_stmt|;
name|gchar
modifier|*
name|l_err_lbltext
decl_stmt|;
name|l_affected_frames
operator|=
literal|1
operator|+
name|MAX
argument_list|(
name|pvals
operator|->
name|dst_range_start
argument_list|,
name|pvals
operator|->
name|dst_range_end
argument_list|)
operator|-
name|MIN
argument_list|(
name|pvals
operator|->
name|dst_range_start
argument_list|,
name|pvals
operator|->
name|dst_range_end
argument_list|)
expr_stmt|;
name|l_errcount
operator|=
literal|0
expr_stmt|;
name|l_prev_keyframe
operator|=
literal|0
expr_stmt|;
name|l_prev_frame
operator|=
literal|0
expr_stmt|;
name|l_err_lbltext
operator|=
name|g_strdup
argument_list|(
literal|"\0"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|pvals
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
operator|!=
literal|0
condition|)
block|{
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|=
name|p_conv_keyframe_to_rel
argument_list|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|,
name|pvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|>
name|l_affected_frames
operator|-
literal|2
condition|)
block|{
name|l_err
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"\nError: Keyframe %d at point [%d] higher or equal than last handled frame"
argument_list|)
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|,
name|l_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l_err_lbltext
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s"
argument_list|,
name|l_err_lbltext
argument_list|,
name|l_err
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_err
argument_list|)
expr_stmt|;
name|l_errcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|<
name|l_prev_frame
condition|)
block|{
name|l_err
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"\nError: Keyframe %d at point [%d] leaves not enough space (frames)"
literal|"\nfor the previous controlpoints"
argument_list|)
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|,
name|l_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l_err_lbltext
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s"
argument_list|,
name|l_err_lbltext
argument_list|,
name|l_err
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_err
argument_list|)
expr_stmt|;
name|l_errcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
operator|<=
name|l_prev_keyframe
condition|)
block|{
name|l_err
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"\nError: Keyframe %d is not in sequence at point [%d]"
argument_list|)
argument_list|,
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|,
name|l_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l_err_lbltext
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s"
argument_list|,
name|l_err_lbltext
argument_list|,
name|l_err
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_err
argument_list|)
expr_stmt|;
name|l_errcount
operator|++
expr_stmt|;
block|}
name|l_prev_keyframe
operator|=
name|pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
expr_stmt|;
if|if
condition|(
name|l_prev_keyframe
operator|>
name|l_prev_frame
condition|)
block|{
name|l_prev_frame
operator|=
name|l_prev_keyframe
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_prev_frame
operator|++
expr_stmt|;
if|if
condition|(
name|l_prev_frame
operator|+
literal|1
operator|>
name|l_affected_frames
condition|)
block|{
name|l_err
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"\nError: controlpoint [%d] is out of handled framerange"
argument_list|)
argument_list|,
name|l_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l_err_lbltext
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s"
argument_list|,
name|l_err_lbltext
argument_list|,
name|l_err
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_err
argument_list|)
expr_stmt|;
name|l_errcount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_errcount
operator|>
literal|10
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|pvals
operator|->
name|point_idx_max
operator|+
literal|1
operator|>
name|l_affected_frames
condition|)
block|{
name|l_err
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"\nError: more controlpoints (%d) than handled frames (%d)"
literal|"\nplease reduce controlpoints or select more frames"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|pvals
operator|->
name|point_idx_max
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|)
name|l_affected_frames
argument_list|)
expr_stmt|;
name|l_err_lbltext
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s"
argument_list|,
name|l_err_lbltext
argument_list|,
name|l_err
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_err
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_err_lbltext
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_gap_chk_keyframes */
end_comment

begin_comment
comment|/* ============================================================================  * p_check_move_path_params  *   check the parameters for noninteractive call of MovePath  *   return 0 (OK)  or -1 (Error)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_check_move_path_params (t_mov_data * mov_data)
name|p_check_move_path_params
parameter_list|(
name|t_mov_data
modifier|*
name|mov_data
parameter_list|)
block|{
name|gchar
modifier|*
name|l_err_lbltext
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
comment|/* assume OK */
comment|/* range params valid ? */
if|if
condition|(
name|MIN
argument_list|(
name|mov_data
operator|->
name|val_ptr
operator|->
name|dst_range_start
argument_list|,
name|mov_data
operator|->
name|val_ptr
operator|->
name|dst_range_end
argument_list|)
operator|<
name|mov_data
operator|->
name|dst_ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|printf
argument_list|(
literal|"Error: Range starts before first frame number %d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_data
operator|->
name|dst_ainfo_ptr
operator|->
name|first_frame_nr
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|MAX
argument_list|(
name|mov_data
operator|->
name|val_ptr
operator|->
name|dst_range_start
argument_list|,
name|mov_data
operator|->
name|val_ptr
operator|->
name|dst_range_end
argument_list|)
operator|>
name|mov_data
operator|->
name|dst_ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|printf
argument_list|(
literal|"Error: Range ends after last frame number %d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_data
operator|->
name|dst_ainfo_ptr
operator|->
name|last_frame_nr
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* is there a valid source object ? */
if|if
condition|(
name|mov_data
operator|->
name|val_ptr
operator|->
name|src_layer_id
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error: the passed src_layer_id %d  is invalid\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_data
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimp_drawable_is_layer
argument_list|(
name|mov_data
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
condition|)
block|{
name|mov_data
operator|->
name|val_ptr
operator|->
name|src_image_id
operator|=
name|gimp_layer_get_image_id
argument_list|(
name|mov_data
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Error: the passed src_layer_id %d  is no Layer\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_data
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* keyframes OK ? */
name|l_err_lbltext
operator|=
name|p_gap_chk_keyframes
argument_list|(
name|mov_data
operator|->
name|val_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l_err_lbltext
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Error in Keyframe settings: %s\n"
argument_list|,
name|l_err_lbltext
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_err_lbltext
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_check_move_path_params */
end_comment

begin_comment
comment|/* ============================================================================  * gap_move_path  * ============================================================================  */
end_comment

begin_function
name|int
DECL|function|gap_move_path (GimpRunModeType run_mode,gint32 image_id,t_mov_values * pvals,gchar * pointfile,gint rotation_follow,gint32 startangle)
name|gap_move_path
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|t_mov_values
modifier|*
name|pvals
parameter_list|,
name|gchar
modifier|*
name|pointfile
parameter_list|,
name|gint
name|rotation_follow
parameter_list|,
name|gint32
name|startangle
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|t_mov_data
name|l_mov_data
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
name|l_mov_data
operator|.
name|val_ptr
operator|=
name|pvals
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|l_mov_data
operator|.
name|val_ptr
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|l_mov_data
operator|.
name|val_ptr
operator|->
name|cache_src_image_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l_mov_data
operator|.
name|dst_ainfo_ptr
operator|=
name|ainfo_ptr
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_NONINTERACTIVE
condition|)
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
comment|/* get controlpoints from pointfile */
if|if
condition|(
name|pointfile
operator|!=
name|NULL
condition|)
block|{
name|l_rc
operator|=
name|p_gap_load_pointfile
argument_list|(
name|pointfile
argument_list|,
name|pvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Execution Error: could not load MovePath controlpoints from file: %s\n"
argument_list|,
name|pointfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_check_move_path_params
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
block|}
comment|/* Automatic calculation of rotation values */
if|if
condition|(
operator|(
name|rotation_follow
operator|>
literal|0
operator|)
operator|&&
operator|(
name|l_rc
operator|==
literal|0
operator|)
condition|)
block|{
name|p_calculate_rotate_follow
argument_list|(
name|pvals
argument_list|,
name|startangle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Dialog for GIMP_RUN_INTERACTIVE  	    * (and for GIMP_RUN_WITH_LAST_VALS that is not really supported here) 	    */
name|l_rc
operator|=
name|p_move_dialog
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_mov_execute
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
comment|/* go back to the frame_nr where move operation was started from */
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_mov_data
operator|.
name|val_ptr
operator|->
name|cache_tmp_image_id
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"gap_move: DELETE cache_tmp_image_id:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_mov_data
operator|.
name|val_ptr
operator|->
name|cache_tmp_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* destroy the cached frame image */
name|gimp_image_delete
argument_list|(
name|l_mov_data
operator|.
name|val_ptr
operator|->
name|cache_tmp_image_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_move_path */
end_comment

end_unit

