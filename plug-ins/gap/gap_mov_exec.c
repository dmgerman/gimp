begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_mov_exec.c  * 1997.11.06 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * Move : procedures for copying source layer(s) to multiple frames  * (varying Koordinates, opacity, size ...)  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history:  * version 0.93.04              hof: Window with Info Message if no Source Image was selected in MovePath  * version 0.90.00;             hof: 1.st (pre) release 14.Dec.1997  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_layer_copy.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_mov_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_mov_exec.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_function_decl
specifier|static
name|int
name|p_mov_call_render
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|,
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p_mov_advance_src_layer
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|int
name|src_stepmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|p_mov_execute
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ============================================================================  * p_mov_call_render  *  load current frame, render and save back to disk  * ============================================================================  */
end_comment

begin_function
DECL|function|p_mov_call_render (t_mov_data * mov_ptr,t_mov_current * cur_ptr)
name|int
name|p_mov_call_render
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|,
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|)
block|{
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|mov_ptr
operator|->
name|dst_ainfo_ptr
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* load next frame to render */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* call render procedure for current image */
if|if
condition|(
literal|0
operator|==
name|p_mov_render
argument_list|(
name|l_tmp_image_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
condition|)
block|{
comment|/* if OK: save the rendered frame back to disk */
if|if
condition|(
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|<
literal|0
condition|)
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_call_render */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_advance_src_layer  * advance layer index according to stepmode  * ============================================================================  */
end_comment

begin_function
DECL|function|p_mov_advance_src_layer (t_mov_current * cur_ptr,int src_stepmode)
name|void
name|p_mov_advance_src_layer
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|int
name|src_stepmode
parameter_list|)
block|{
specifier|static
name|int
name|l_ping
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_advance_src_layer: stepmode=%d last_layer=%d idx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|src_stepmode
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_last_layer
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_layer_idx
argument_list|)
expr_stmt|;
comment|/* note: top layer has index 0    *       therfore reverse loops have to count up    */
if|if
condition|(
operator|(
name|cur_ptr
operator|->
name|src_last_layer
operator|>
literal|0
operator|)
operator|&&
operator|(
name|src_stepmode
operator|!=
name|GAP_STEP_NONE
operator|)
condition|)
block|{
switch|switch
condition|(
name|src_stepmode
condition|)
block|{
case|case
name|GAP_STEP_ONCE_REV
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_ONCE
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_PING_PONG
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|+=
name|l_ping
expr_stmt|;
if|if
condition|(
name|l_ping
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|1
expr_stmt|;
name|l_ping
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
operator|-
literal|1
expr_stmt|;
name|l_ping
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GAP_STEP_LOOP_REV
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_LOOP
case|:
default|default:
name|cur_ptr
operator|->
name|src_layer_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end  p_advance_src_layer */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_execute  * Copy layer(s) from Sourceimage to given destination frame range,  * varying koordinates and opacity of the copied layer.  * To each affected destination frame exactly one is added.  * The source layer is iterated through all layers of the sourceimage  * according to stemmode parameter.  * For the placement the layers act as if their size is equal to their  * Sourceimages size.  * ============================================================================  */
end_comment

begin_function
DECL|function|p_mov_execute (t_mov_data * mov_ptr)
name|long
name|p_mov_execute
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
name|t_mov_current
name|l_current_data
decl_stmt|;
name|t_mov_current
modifier|*
name|cur_ptr
decl_stmt|;
name|t_mov_values
modifier|*
name|val_ptr
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|;
name|gdouble
name|l_fpl
decl_stmt|;
comment|/* frames_per_line */
name|long
name|l_fpl2
decl_stmt|;
comment|/* frames_per_line  rounded to integer*/
name|long
name|l_frame_step
decl_stmt|;
name|gdouble
name|l_frames
decl_stmt|;
name|long
name|l_cnt
decl_stmt|;
name|long
name|l_points
decl_stmt|;
name|long
name|l_ptidx
decl_stmt|;
name|long
name|l_fridx
decl_stmt|;
name|gdouble
name|l_flt_count
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|int
name|l_nlayers
decl_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_image_id
operator|<
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|_
argument_list|(
literal|"No Source Image was selected\n(Please open a 2nd Image of the same type before opening Move Path)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Copying Layers into Frames .."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: values got from dialog:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_image_id :%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_layer_id :%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_handle :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_handle
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_stepmode :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_stepmode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_paintmode :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_paintmode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clip_to_img :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|clip_to_img
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_range_start :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_range_start
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_range_end :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_range_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_layerstack :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_layerstack
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"p_x[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p_y[%d] : :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opacity[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|opacity
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"w_resize[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|w_resize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"h_resize[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|h_resize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rotation[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|l_rc
operator|=
literal|0
expr_stmt|;
name|cur_ptr
operator|=
operator|&
name|l_current_data
expr_stmt|;
name|val_ptr
operator|=
name|mov_ptr
operator|->
name|val_ptr
expr_stmt|;
comment|/* set offsets (in cur_ptr)  according to handle mode and src_img dimension */
name|p_set_handle_offsets
argument_list|(
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
comment|/* test for invers range */
if|if
condition|(
name|val_ptr
operator|->
name|dst_range_start
operator|>
name|val_ptr
operator|->
name|dst_range_end
condition|)
block|{
comment|/* step down */
name|l_frame_step
operator|=
operator|-
literal|1
expr_stmt|;
name|l_cnt
operator|=
literal|1
operator|+
operator|(
name|val_ptr
operator|->
name|dst_range_start
operator|-
name|val_ptr
operator|->
name|dst_range_end
operator|)
expr_stmt|;
block|}
else|else
block|{
name|l_frame_step
operator|=
literal|1
expr_stmt|;
name|l_cnt
operator|=
literal|1
operator|+
operator|(
name|val_ptr
operator|->
name|dst_range_end
operator|-
name|val_ptr
operator|->
name|dst_range_start
operator|)
expr_stmt|;
block|}
name|l_frames
operator|=
operator|(
name|gdouble
operator|)
name|l_cnt
expr_stmt|;
comment|/* nr. of affected frames */
name|l_points
operator|=
name|val_ptr
operator|->
name|point_idx_max
operator|+
literal|1
expr_stmt|;
comment|/* nr. of available points */
if|if
condition|(
name|l_points
operator|>
name|l_frames
condition|)
block|{
comment|/* cut off some points if we got more than frames */
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_x
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_x
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_y
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_y
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|opacity
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|opacity
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|w_resize
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|w_resize
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|h_resize
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|h_resize
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|rotation
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|rotation
expr_stmt|;
name|l_points
operator|=
name|l_cnt
expr_stmt|;
block|}
name|cur_ptr
operator|->
name|dst_frame_nr
operator|=
name|val_ptr
operator|->
name|dst_range_start
expr_stmt|;
name|cur_ptr
operator|->
name|src_layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|val_ptr
operator|->
name|src_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR (in p_mov_execute): Got no layers from SrcImage\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|l_nlayers
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR (in p_mov_execute): Source Image has no layers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cur_ptr
operator|->
name|src_last_layer
operator|=
name|l_nlayers
operator|-
literal|1
expr_stmt|;
comment|/* findout index of src_layer_id */
for|for
control|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
init|;
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
name|l_nlayers
condition|;
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
control|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
index|[
name|cur_ptr
operator|->
name|src_layer_idx
index|]
operator|==
name|val_ptr
operator|->
name|src_layer_id
condition|)
break|break;
block|}
name|cur_ptr
operator|->
name|src_last_layer
operator|=
name|l_nlayers
operator|-
literal|1
expr_stmt|;
comment|/* index of last layer */
name|cur_ptr
operator|->
name|currX
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_x
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_y
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|opacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|w_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|h_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|rotation
expr_stmt|;
comment|/* RENDER add current src_layer to current frame */
name|l_rc
operator|=
name|p_mov_call_render
argument_list|(
name|mov_ptr
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
comment|/* how many frames are affected from one line of the moving path */
name|l_fpl
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|l_frames
operator|-
literal|1.0
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
name|l_points
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|l_fpl2
operator|=
operator|(
name|l_fpl
operator|+
literal|0.5
operator|)
expr_stmt|;
name|l_ptidx
operator|=
literal|1
expr_stmt|;
name|l_flt_count
operator|=
literal|0.0
expr_stmt|;
comment|/* loop for each frame within the range (may step up or down) */
name|cur_ptr
operator|->
name|dst_frame_nr
operator|=
name|val_ptr
operator|->
name|dst_range_start
expr_stmt|;
for|for
control|(
name|l_fridx
operator|=
literal|1
init|;
name|l_fridx
operator|<
name|l_cnt
condition|;
name|l_fridx
operator|++
control|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: l_fridx=%ld, l_flt_count=%f, l_rc=%d\n"
argument_list|,
name|l_fridx
argument_list|,
name|l_flt_count
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
break|break;
comment|/* advance frame_nr, (1st frame was done outside this loop) */
name|cur_ptr
operator|->
name|dst_frame_nr
operator|+=
name|l_frame_step
expr_stmt|;
comment|/* +1  or -1 */
if|if
condition|(
operator|(
name|gdouble
operator|)
name|l_fridx
operator|>
name|l_flt_count
condition|)
block|{
comment|/* re-adjust current values. (only to avoid rounding errors)           * current values should already contain the point values[l_ptidx]           */
name|cur_ptr
operator|->
name|currX
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_x
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_y
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|opacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|w_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|h_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|rotation
expr_stmt|;
comment|/* change deltas for next line of the move path */
name|cur_ptr
operator|->
name|deltaX
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|p_x
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_x
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaY
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|p_y
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_y
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaOpacity
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|opacity
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|opacity
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaWidth
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|w_resize
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|w_resize
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaHeight
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|h_resize
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|h_resize
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaRotation
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|rotation
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|rotation
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|l_ptidx
operator|++
expr_stmt|;
name|l_flt_count
operator|+=
name|l_fpl
expr_stmt|;
block|}
comment|/* advance settings for next frame */
name|p_mov_advance_src_layer
argument_list|(
name|cur_ptr
argument_list|,
name|val_ptr
operator|->
name|src_stepmode
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currX
operator|+=
name|cur_ptr
operator|->
name|deltaX
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|+=
name|cur_ptr
operator|->
name|deltaY
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|+=
name|cur_ptr
operator|->
name|deltaOpacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|+=
name|cur_ptr
operator|->
name|deltaWidth
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|+=
name|cur_ptr
operator|->
name|deltaHeight
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|+=
name|cur_ptr
operator|->
name|deltaRotation
expr_stmt|;
comment|/* RENDER add current src_layer to current frame */
name|l_rc
operator|=
name|p_mov_call_render
argument_list|(
name|mov_ptr
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
comment|/* show progress */
if|if
condition|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|=
operator|(
name|gdouble
operator|)
name|l_fridx
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|l_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|cur_ptr
operator|->
name|src_layers
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_execute */
end_comment

begin_comment
comment|/* ============================================================================  * gap_move  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_move (GRunModeType run_mode,gint32 image_id)
name|int
name|gap_move
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|t_mov_data
name|l_mov_data
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
name|l_mov_data
operator|.
name|val_ptr
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_mov_values
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|l_mov_data
operator|.
name|val_ptr
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|l_mov_data
operator|.
name|dst_ainfo_ptr
operator|=
name|ainfo_ptr
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_move_dialog
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* run NON_INTERACTIVE not implemented (define args) */
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_mov_execute
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
comment|/* go back to the frame_nr where move operation was started from */
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|g_free
argument_list|(
name|l_mov_data
operator|.
name|val_ptr
argument_list|)
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_move */
end_comment

end_unit

