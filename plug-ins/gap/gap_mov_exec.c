begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_mov_exec.c  * 1997.11.06 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * Move : procedures for copying source layer(s) to multiple frames  * (varying Koordinates, opacity, size ...)  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history:  * gimp    1.1.20a; 2000/04/25  hof: support for keyframes, anim_preview  * version 0.93.04              hof: Window with Info Message if no Source Image was selected in MovePath  * version 0.90.00;             hof: 1.st (pre) release 14.Dec.1997  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_layer_copy.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_mov_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_mov_exec.h"
end_include

begin_include
include|#
directive|include
file|"gap_pdb_calls.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_function_decl
specifier|static
name|gint
name|p_mov_call_render
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|,
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|gint
name|apv_layerstack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p_mov_advance_src_layer
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|int
name|src_stepmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|p_mov_execute
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ============================================================================  * p_mov_call_render  *  load current frame, render and save back to disk  *  for animted_preview  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|p_mov_call_render (t_mov_data * mov_ptr,t_mov_current * cur_ptr,gint apv_layerstack)
name|p_mov_call_render
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|,
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|gint
name|apv_layerstack
parameter_list|)
block|{
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint32
name|l_layer_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|char
modifier|*
name|l_fname
decl_stmt|;
name|char
modifier|*
name|l_name
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|mov_ptr
operator|->
name|dst_ainfo_ptr
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
operator|<
literal|0
condition|)
block|{
comment|/* We are generating the Animation on the ORIGINAL FRAMES */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* load next frame to render */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* call render procedure for current image */
if|if
condition|(
literal|0
operator|==
name|p_mov_render
argument_list|(
name|l_tmp_image_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
condition|)
block|{
comment|/* if OK: save the rendered frame back to disk */
if|if
condition|(
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|<
literal|0
condition|)
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We are generating an ANIMATED PREVIEW multilayer image */
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_src_frame
operator|>=
literal|0
condition|)
block|{
comment|/* anim preview uses one constant (prescaled) frame */
name|l_tmp_image_id
operator|=
name|p_gimp_channel_ops_duplicate
argument_list|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_src_frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* anim preview exact mode uses original frames */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scalex
operator|!=
literal|100.0
operator|)
operator|||
operator|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scaley
operator|!=
literal|100.0
operator|)
condition|)
block|{
name|GParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|gint32
name|l_size_x
decl_stmt|,
name|l_size_y
decl_stmt|;
name|l_size_x
operator|=
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_size_y
operator|=
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|l_size_x
argument_list|,
name|PARAM_INT32
argument_list|,
name|l_size_y
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* call render procedure for current image */
if|if
condition|(
literal|0
operator|==
name|p_mov_render
argument_list|(
name|l_tmp_image_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
condition|)
block|{
comment|/* if OK and optional save to gap_paste-buffer */
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
operator|!=
name|NULL
condition|)
block|{
name|l_fname
operator|=
name|p_alloc_fname
argument_list|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
argument_list|,
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
literal|".xcf"
argument_list|)
expr_stmt|;
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
block|}
comment|/* flatten the rendered frame */
name|l_layer_id
operator|=
name|gimp_image_flatten
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layer_id
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_call_render: flattened layer_id:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|)
expr_stmt|;
comment|/* hof: 	 * if invisible layers are flattened on an empty image 	 * we do not get a resulting layer (returned l_layer_id == -1) 	 * 	 *  I'm not sure if is this a bug, but here is a workaround: 	 * 	 * In that case I add a dummy layer 1x1 pixel (at offest -1,-1) 	 * and flatten again, and it works (tested with gimp-1.1.19) 	 */
name|l_layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|l_tmp_image_id
argument_list|,
literal|"dummy"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
call|(
name|gint
call|)
argument_list|(
name|gimp_image_base_type
argument_list|(
name|l_tmp_image_id
argument_list|)
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
literal|100.0
argument_list|,
comment|/* Opacity full opaque */
literal|0
argument_list|)
expr_stmt|;
comment|/* NORMAL */
name|gimp_image_add_layer
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_set_offsets
argument_list|(
name|l_layer_id
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_layer_id
operator|=
name|gimp_image_flatten
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
name|gimp_layer_add_alpha
argument_list|(
name|l_layer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_call_render: flattened layer_id:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_layer_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p_mov_call_render: tmp_image_id:%d  apv_mlayer_image:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
block|}
comment|/* set layername (including delay for the framerate) */
name|l_name
operator|=
name|g_strdup_printf
argument_list|(
literal|"frame_%04d (%dms)"
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|dst_frame_nr
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|1000
operator|/
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_framerate
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_layer_set_name
argument_list|(
name|l_layer_id
argument_list|,
name|l_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_name
argument_list|)
expr_stmt|;
comment|/* remove (its only) layer from source */
name|gimp_image_remove_layer
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_layer_id
argument_list|)
expr_stmt|;
comment|/* and set the dst_image as it's new Master */
name|p_gimp_drawable_set_image
argument_list|(
name|l_layer_id
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
comment|/* add the layer to the anim preview multilayer image */
name|gimp_image_add_layer
argument_list|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|,
name|l_layer_id
argument_list|,
name|apv_layerstack
argument_list|)
expr_stmt|;
block|}
else|else
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_call_render */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_advance_src_layer  * advance layer index according to stepmode  * ============================================================================  */
end_comment

begin_function
DECL|function|p_mov_advance_src_layer (t_mov_current * cur_ptr,int src_stepmode)
name|void
name|p_mov_advance_src_layer
parameter_list|(
name|t_mov_current
modifier|*
name|cur_ptr
parameter_list|,
name|int
name|src_stepmode
parameter_list|)
block|{
specifier|static
name|int
name|l_ping
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_advance_src_layer: stepmode=%d last_layer=%d idx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|src_stepmode
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_last_layer
argument_list|,
operator|(
name|int
operator|)
name|cur_ptr
operator|->
name|src_layer_idx
argument_list|)
expr_stmt|;
comment|/* note: top layer has index 0    *       therfore reverse loops have to count up    */
if|if
condition|(
operator|(
name|cur_ptr
operator|->
name|src_last_layer
operator|>
literal|0
operator|)
operator|&&
operator|(
name|src_stepmode
operator|!=
name|GAP_STEP_NONE
operator|)
condition|)
block|{
switch|switch
condition|(
name|src_stepmode
condition|)
block|{
case|case
name|GAP_STEP_ONCE_REV
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_ONCE
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_PING_PONG
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|+=
name|l_ping
expr_stmt|;
if|if
condition|(
name|l_ping
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|1
expr_stmt|;
name|l_ping
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
operator|-
literal|1
expr_stmt|;
name|l_ping
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GAP_STEP_LOOP_REV
case|:
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|>
name|cur_ptr
operator|->
name|src_last_layer
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GAP_STEP_LOOP
case|:
default|default:
name|cur_ptr
operator|->
name|src_layer_idx
operator|--
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
literal|0
condition|)
block|{
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
name|cur_ptr
operator|->
name|src_last_layer
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end  p_advance_src_layer */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_execute  * Copy layer(s) from Sourceimage to given destination frame range,  * varying koordinates and opacity of the copied layer.  * To each affected destination frame exactly one copy of a source layer is added.  * The source layer is iterated through all layers of the sourceimage  * according to stemmode parameter.  * For the placement the layers act as if their size is equal to their  * Sourceimages size.  * ============================================================================  */
end_comment

begin_comment
comment|/* TODO: add keyframe support */
end_comment

begin_function
name|long
DECL|function|p_mov_execute (t_mov_data * mov_ptr)
name|p_mov_execute
parameter_list|(
name|t_mov_data
modifier|*
name|mov_ptr
parameter_list|)
block|{
name|gint
name|l_idx
decl_stmt|;
name|t_mov_current
name|l_current_data
decl_stmt|;
name|t_mov_current
modifier|*
name|cur_ptr
decl_stmt|;
name|t_mov_values
modifier|*
name|val_ptr
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|;
name|gdouble
name|l_fpl
decl_stmt|;
comment|/* frames_per_line */
name|long
name|l_fpl2
decl_stmt|;
comment|/* frames_per_line  rounded to integer*/
name|long
name|l_frame_step
decl_stmt|;
name|gdouble
name|l_frames
decl_stmt|;
name|long
name|l_cnt
decl_stmt|;
name|long
name|l_points
decl_stmt|;
name|long
name|l_ptidx
decl_stmt|;
name|long
name|l_prev_keyptidx
decl_stmt|;
name|long
name|l_fridx
decl_stmt|;
name|gdouble
name|l_flt_count
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint
name|l_idk
decl_stmt|;
name|gint
name|l_prev_keyframe
decl_stmt|;
name|gint
name|l_apv_layerstack
decl_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_image_id
operator|<
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|_
argument_list|(
literal|"No Source Image was selected.\n"
literal|"Please open a 2nd Image of the same type before opening Move Path."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_apv_layerstack
operator|=
literal|0
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
operator|<
literal|0
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Copying Layers into Frames..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Generating Animated Preview..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_execute: values got from dialog:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apv_mlayer_image: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apv_mode: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apv_scale x: %f y:%f\n"
argument_list|,
operator|(
name|float
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scalex
argument_list|,
operator|(
name|float
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_scaley
argument_list|)
expr_stmt|;
if|if
condition|(
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
condition|)
block|{
name|printf
argument_list|(
literal|"apv_gap_paste_buf: %s\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|apv_gap_paste_buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"apv_gap_paste_buf: ** IS NULL ** (do not copy to paste buffer)\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"src_image_id :%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_layer_id :%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_handle :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_handle
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_stepmode :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_stepmode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src_paintmode :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|src_paintmode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clip_to_img :%d\n"
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|clip_to_img
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_range_start :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_range_start
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_range_end :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_range_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst_layerstack :%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|dst_layerstack
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"p_x[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p_y[%d] : :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opacity[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|opacity
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"w_resize[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|w_resize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"h_resize[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|h_resize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rotation[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keyframe[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keyframe_abs[%d] :%d\n"
argument_list|,
name|l_idx
argument_list|,
name|mov_ptr
operator|->
name|val_ptr
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|keyframe_abs
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|l_rc
operator|=
literal|0
expr_stmt|;
name|cur_ptr
operator|=
operator|&
name|l_current_data
expr_stmt|;
name|val_ptr
operator|=
name|mov_ptr
operator|->
name|val_ptr
expr_stmt|;
comment|/* set offsets (in cur_ptr)  according to handle mode and src_img dimension */
name|p_set_handle_offsets
argument_list|(
name|val_ptr
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
comment|/* test for invers range */
if|if
condition|(
name|val_ptr
operator|->
name|dst_range_start
operator|>
name|val_ptr
operator|->
name|dst_range_end
condition|)
block|{
comment|/* step down */
name|l_frame_step
operator|=
operator|-
literal|1
expr_stmt|;
name|l_cnt
operator|=
literal|1
operator|+
operator|(
name|val_ptr
operator|->
name|dst_range_start
operator|-
name|val_ptr
operator|->
name|dst_range_end
operator|)
expr_stmt|;
block|}
else|else
block|{
name|l_frame_step
operator|=
literal|1
expr_stmt|;
name|l_cnt
operator|=
literal|1
operator|+
operator|(
name|val_ptr
operator|->
name|dst_range_end
operator|-
name|val_ptr
operator|->
name|dst_range_start
operator|)
expr_stmt|;
block|}
name|l_frames
operator|=
operator|(
name|gdouble
operator|)
name|l_cnt
expr_stmt|;
comment|/* nr. of affected frames */
name|l_points
operator|=
name|val_ptr
operator|->
name|point_idx_max
operator|+
literal|1
expr_stmt|;
comment|/* nr. of available points */
if|if
condition|(
name|l_points
operator|>
name|l_frames
condition|)
block|{
comment|/* cut off some points if we got more than frames */
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_x
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_x
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_y
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|p_y
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|opacity
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|opacity
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|w_resize
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|w_resize
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|h_resize
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|h_resize
expr_stmt|;
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|rotation
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_cnt
index|]
operator|.
name|rotation
expr_stmt|;
name|l_points
operator|=
name|l_cnt
expr_stmt|;
block|}
name|cur_ptr
operator|->
name|dst_frame_nr
operator|=
name|val_ptr
operator|->
name|dst_range_start
expr_stmt|;
name|cur_ptr
operator|->
name|src_layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|val_ptr
operator|->
name|src_image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR (in p_mov_execute): Got no layers from SrcImage\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|l_nlayers
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR (in p_mov_execute): Source Image has no layers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cur_ptr
operator|->
name|src_last_layer
operator|=
name|l_nlayers
operator|-
literal|1
expr_stmt|;
comment|/* findout index of src_layer_id */
for|for
control|(
name|cur_ptr
operator|->
name|src_layer_idx
operator|=
literal|0
init|;
name|cur_ptr
operator|->
name|src_layer_idx
operator|<
name|l_nlayers
condition|;
name|cur_ptr
operator|->
name|src_layer_idx
operator|++
control|)
block|{
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
index|[
name|cur_ptr
operator|->
name|src_layer_idx
index|]
operator|==
name|val_ptr
operator|->
name|src_layer_id
condition|)
break|break;
block|}
name|cur_ptr
operator|->
name|src_last_layer
operator|=
name|l_nlayers
operator|-
literal|1
expr_stmt|;
comment|/* index of last layer */
name|cur_ptr
operator|->
name|currX
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_x
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|p_y
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|opacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|w_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|h_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
literal|0
index|]
operator|.
name|rotation
expr_stmt|;
comment|/* RENDER add current src_layer to current frame */
name|l_rc
operator|=
name|p_mov_call_render
argument_list|(
name|mov_ptr
argument_list|,
name|cur_ptr
argument_list|,
name|l_apv_layerstack
argument_list|)
expr_stmt|;
comment|/* how many frames are affected from one line of the moving path */
name|l_fpl
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|l_frames
operator|-
literal|1.0
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
name|l_points
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|l_fpl2
operator|=
operator|(
name|l_fpl
operator|+
literal|0.5
operator|)
expr_stmt|;
name|l_ptidx
operator|=
literal|1
expr_stmt|;
name|l_prev_keyptidx
operator|=
literal|0
expr_stmt|;
name|l_flt_count
operator|=
literal|0.0
expr_stmt|;
name|l_prev_keyframe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: initial l_fpl=%f, l_fpl2=%d\n"
argument_list|,
name|l_fpl
argument_list|,
operator|(
name|int
operator|)
name|l_fpl2
argument_list|)
expr_stmt|;
comment|/* loop for each frame within the range (may step up or down) */
name|cur_ptr
operator|->
name|dst_frame_nr
operator|=
name|val_ptr
operator|->
name|dst_range_start
expr_stmt|;
for|for
control|(
name|l_fridx
operator|=
literal|1
init|;
name|l_fridx
operator|<
name|l_cnt
condition|;
name|l_fridx
operator|++
control|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"\np_mov_execute: l_fridx=%ld, l_flt_count=%f, l_rc=%d\n"
argument_list|,
name|l_fridx
argument_list|,
name|l_flt_count
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
break|break;
comment|/* advance frame_nr, (1st frame was done outside this loop) */
name|cur_ptr
operator|->
name|dst_frame_nr
operator|+=
name|l_frame_step
expr_stmt|;
comment|/* +1  or -1 */
if|if
condition|(
operator|(
name|gdouble
operator|)
name|l_fridx
operator|>
name|l_flt_count
condition|)
block|{
comment|/* re-adjust current values. (only to avoid rounding errors)           * current values should already contain the point values[l_ptidx]           */
name|cur_ptr
operator|->
name|currX
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_x
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_y
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|opacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|w_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|h_resize
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|=
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|rotation
expr_stmt|;
comment|/* check if there are controlpoints fixed to keyframes */
if|if
condition|(
name|l_ptidx
operator|>
name|l_prev_keyptidx
condition|)
block|{
for|for
control|(
name|l_idk
operator|=
name|l_ptidx
init|;
name|l_idk
operator|<
name|l_points
condition|;
name|l_idk
operator|++
control|)
block|{
if|if
condition|(
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
operator|>
literal|0
condition|)
block|{
comment|/* found a keyframe, have to recalculate frames_per_line */
name|l_fpl
operator|=
operator|(
call|(
name|gdouble
call|)
argument_list|(
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
operator|-
name|l_prev_keyframe
argument_list|)
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
operator|(
name|l_idk
operator|-
name|l_ptidx
operator|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|l_fpl2
operator|=
operator|(
name|l_fpl
operator|+
literal|0.5
operator|)
expr_stmt|;
name|l_prev_keyframe
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
expr_stmt|;
name|l_prev_keyptidx
operator|=
name|l_idk
expr_stmt|;
comment|/* l_flt_count = (gdouble)l_fridx - l_fpl; */
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: keyframe l_fpl=%f, l_fpl2=%d\n"
argument_list|,
name|l_fpl
argument_list|,
operator|(
name|int
operator|)
name|l_fpl2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|l_idk
operator|==
name|l_points
operator|-
literal|1
operator|)
operator|&&
operator|(
name|l_prev_keyframe
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* last point is an implicite keyframe (if any keyframe was used ) */
name|l_fpl
operator|=
operator|(
call|(
name|gdouble
call|)
argument_list|(
name|l_frames
operator|-
name|l_prev_keyframe
operator|-
literal|1
argument_list|)
operator|)
operator|/
operator|(
call|(
name|gdouble
call|)
argument_list|(
operator|(
name|l_idk
operator|-
name|l_ptidx
operator|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|l_fpl2
operator|=
operator|(
name|l_fpl
operator|+
literal|0.5
operator|)
expr_stmt|;
name|l_prev_keyframe
operator|=
name|val_ptr
operator|->
name|point
index|[
name|l_idk
index|]
operator|.
name|keyframe
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_mov_execute: last frame l_fpl=%f, l_fpl2=%d\n"
argument_list|,
name|l_fpl
argument_list|,
operator|(
name|int
operator|)
name|l_fpl2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* change deltas for next line of the move path */
name|cur_ptr
operator|->
name|deltaX
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|p_x
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_x
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaY
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|p_y
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|p_y
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaOpacity
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|opacity
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|opacity
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaWidth
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|w_resize
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|w_resize
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaHeight
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|h_resize
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|h_resize
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|cur_ptr
operator|->
name|deltaRotation
operator|=
operator|(
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
index|]
operator|.
name|rotation
operator|-
operator|(
name|gdouble
operator|)
name|val_ptr
operator|->
name|point
index|[
name|l_ptidx
operator|-
literal|1
index|]
operator|.
name|rotation
operator|)
operator|/
operator|(
name|gdouble
operator|)
name|l_fpl2
expr_stmt|;
name|l_ptidx
operator|++
expr_stmt|;
name|l_flt_count
operator|+=
name|l_fpl
expr_stmt|;
block|}
comment|/* advance settings for next frame */
name|p_mov_advance_src_layer
argument_list|(
name|cur_ptr
argument_list|,
name|val_ptr
operator|->
name|src_stepmode
argument_list|)
expr_stmt|;
name|cur_ptr
operator|->
name|currX
operator|+=
name|cur_ptr
operator|->
name|deltaX
expr_stmt|;
name|cur_ptr
operator|->
name|currY
operator|+=
name|cur_ptr
operator|->
name|deltaY
expr_stmt|;
name|cur_ptr
operator|->
name|currOpacity
operator|+=
name|cur_ptr
operator|->
name|deltaOpacity
expr_stmt|;
name|cur_ptr
operator|->
name|currWidth
operator|+=
name|cur_ptr
operator|->
name|deltaWidth
expr_stmt|;
name|cur_ptr
operator|->
name|currHeight
operator|+=
name|cur_ptr
operator|->
name|deltaHeight
expr_stmt|;
name|cur_ptr
operator|->
name|currRotation
operator|+=
name|cur_ptr
operator|->
name|deltaRotation
expr_stmt|;
if|if
condition|(
name|l_frame_step
operator|<
literal|0
condition|)
block|{
comment|/* if we step down, we have to insert the layer 	  * as lowest layer in the existing layerstack 	  * of the animated preview multilayer image. 	  * (if we step up, we always use 0 as l_apv_layerstack, 	  *  that means always insert on top of the layerstack) 	  */
name|l_apv_layerstack
operator|++
expr_stmt|;
block|}
comment|/* RENDER add current src_layer to current frame */
name|l_rc
operator|=
name|p_mov_call_render
argument_list|(
name|mov_ptr
argument_list|,
name|cur_ptr
argument_list|,
name|l_apv_layerstack
argument_list|)
expr_stmt|;
comment|/* show progress */
if|if
condition|(
name|mov_ptr
operator|->
name|dst_ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|=
operator|(
name|gdouble
operator|)
name|l_fridx
operator|/
call|(
name|gdouble
call|)
argument_list|(
name|l_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_ptr
operator|->
name|src_layers
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|cur_ptr
operator|->
name|src_layers
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_execute */
end_comment

begin_comment
comment|/* ============================================================================  * p_mov_anim_preview  *   Generate an animate preview for the move path  * ============================================================================  */
end_comment

begin_function
name|gint32
DECL|function|p_mov_anim_preview (t_mov_values * pvals_orig,t_anim_info * ainfo_ptr,gint preview_frame_nr)
name|p_mov_anim_preview
parameter_list|(
name|t_mov_values
modifier|*
name|pvals_orig
parameter_list|,
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|gint
name|preview_frame_nr
parameter_list|)
block|{
name|t_mov_data
name|apv_mov_data
decl_stmt|;
name|t_mov_values
name|apv_mov_vals
decl_stmt|;
name|t_mov_data
modifier|*
name|l_mov_ptr
decl_stmt|;
name|t_mov_values
modifier|*
name|l_pvals
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
name|gint32
name|l_size_x
decl_stmt|,
name|l_size_y
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint32
name|l_tmp_frame_id
decl_stmt|;
name|gint32
name|l_mlayer_image_id
decl_stmt|;
name|GParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|GImageType
name|l_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|gint32
name|l_tattoo
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|l_mov_ptr
operator|=
operator|&
name|apv_mov_data
expr_stmt|;
name|l_pvals
operator|=
operator|&
name|apv_mov_vals
expr_stmt|;
comment|/* copy settings */
name|memcpy
argument_list|(
name|l_pvals
argument_list|,
name|pvals_orig
argument_list|,
sizeof|sizeof
argument_list|(
name|t_mov_values
argument_list|)
argument_list|)
expr_stmt|;
name|l_mov_ptr
operator|->
name|val_ptr
operator|=
name|l_pvals
expr_stmt|;
name|l_mov_ptr
operator|->
name|dst_ainfo_ptr
operator|=
name|ainfo_ptr
expr_stmt|;
comment|/* -1 assume no tmp_image (use unscaled original source) */
name|l_tmp_image_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Scale (down) needed ? */
if|if
condition|(
operator|(
name|l_pvals
operator|->
name|apv_scalex
operator|!=
literal|100.0
operator|)
operator|||
operator|(
name|l_pvals
operator|->
name|apv_scaley
operator|!=
literal|100.0
operator|)
condition|)
block|{
comment|/* scale the controlpoint koords */
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<=
name|l_pvals
operator|->
name|point_idx_max
condition|;
name|l_idx
operator|++
control|)
block|{
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
operator|=
operator|(
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_x
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
operator|=
operator|(
name|l_pvals
operator|->
name|point
index|[
name|l_idx
index|]
operator|.
name|p_y
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
block|}
comment|/* copy and scale the source object image */
name|l_tmp_image_id
operator|=
name|p_gimp_channel_ops_duplicate
argument_list|(
name|pvals_orig
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
name|l_pvals
operator|->
name|src_image_id
operator|=
name|l_tmp_image_id
expr_stmt|;
name|l_size_x
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
name|l_size_y
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|l_size_x
argument_list|,
name|PARAM_INT32
argument_list|,
name|l_size_y
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
comment|/* find the selected src_layer by tattoo in the copy of src_image */
name|l_tattoo
operator|=
name|gimp_layer_get_tattoo
argument_list|(
name|pvals_orig
operator|->
name|src_layer_id
argument_list|)
expr_stmt|;
name|l_pvals
operator|->
name|src_layer_id
operator|=
name|gimp_image_get_layer_by_tattoo
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_tattoo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: src_image_id %d (orig:%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|src_image_id
argument_list|,
operator|(
name|int
operator|)
name|pvals_orig
operator|->
name|src_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* create the animated preview multilayer image in (scaled) framesize */
name|l_width
operator|=
operator|(
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_height
operator|=
operator|(
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
name|l_type
operator|=
name|gimp_image_base_type
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_mlayer_image_id
operator|=
name|gimp_image_new
argument_list|(
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|)
expr_stmt|;
name|l_pvals
operator|->
name|apv_mlayer_image
operator|=
name|l_mlayer_image_id
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: apv_mlayer_image %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|apv_mlayer_image
argument_list|)
expr_stmt|;
block|}
comment|/* APV_MODE (Wich frames to use in the preview?)  */
switch|switch
condition|(
name|l_pvals
operator|->
name|apv_mode
condition|)
block|{
name|gchar
modifier|*
name|l_filename
decl_stmt|;
case|case
name|GAP_APV_QUICK
case|:
comment|/* use an empty dummy frame for all frames */
name|l_tmp_frame_id
operator|=
name|gimp_image_new
argument_list|(
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|GAP_APV_ONE_FRAME
case|:
comment|/* use only one frame in the preview */
name|l_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|preview_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_tmp_frame_id
operator|=
name|p_load_image
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_pvals
operator|->
name|apv_scalex
operator|!=
literal|100.0
operator|)
operator|||
operator|(
name|l_pvals
operator|->
name|apv_scaley
operator|!=
literal|100.0
operator|)
condition|)
block|{
name|l_size_x
operator|=
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_frame_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scalex
operator|)
operator|/
literal|100
expr_stmt|;
name|l_size_y
operator|=
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_frame_id
argument_list|)
operator|*
name|l_pvals
operator|->
name|apv_scaley
operator|)
operator|/
literal|100
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|l_tmp_frame_id
argument_list|,
name|PARAM_INT32
argument_list|,
name|l_size_x
argument_list|,
name|PARAM_INT32
argument_list|,
name|l_size_y
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* GAP_APV_EXACT */
comment|/* read the original frames for the preview (slow) */
name|l_tmp_frame_id
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|l_pvals
operator|->
name|apv_src_frame
operator|=
name|l_tmp_frame_id
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"p_mov_anim_preview: apv_src_frame %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_pvals
operator|->
name|apv_src_frame
argument_list|)
expr_stmt|;
block|}
comment|/* EXECUTE move path in preview Mode */
comment|/* --------------------------------- */
name|l_rc
operator|=
name|p_mov_execute
argument_list|(
name|l_mov_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* add a display for the animated preview multilayer image */
name|gimp_display_new
argument_list|(
name|l_mlayer_image_id
argument_list|)
expr_stmt|;
comment|/* delete the scaled copy of the src image (if there is one) */
if|if
condition|(
name|l_tmp_image_id
operator|>=
literal|0
condition|)
block|{
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* delete the (scaled) dummy frames (if there is one) */
if|if
condition|(
name|l_tmp_frame_id
operator|>=
literal|0
condition|)
block|{
name|gimp_image_delete
argument_list|(
name|l_tmp_frame_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_mlayer_image_id
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_mov_anim_preview */
end_comment

begin_comment
comment|/* ============================================================================  * gap_move  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_move (GRunModeType run_mode,gint32 image_id)
name|int
name|gap_move
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|t_mov_data
name|l_mov_data
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
name|l_mov_data
operator|.
name|val_ptr
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_mov_values
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|l_mov_data
operator|.
name|val_ptr
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|l_mov_data
operator|.
name|dst_ainfo_ptr
operator|=
name|ainfo_ptr
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_move_dialog
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* run NON_INTERACTIVE not implemented (define args) */
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_mov_execute
argument_list|(
operator|&
name|l_mov_data
argument_list|)
expr_stmt|;
comment|/* go back to the frame_nr where move operation was started from */
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|g_free
argument_list|(
name|l_mov_data
operator|.
name|val_ptr
argument_list|)
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_move */
end_comment

end_unit

