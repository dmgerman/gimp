begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_decode_xanim.c  * 1999.11.22 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * This Module contains:  *  *        GIMP/GAP-frontend interface for XANIM exporting edition from loki entertainmaint  *         Call xanim exporting edition (the loki version)  *         To split any xanim supported video into  *         anim frames (single images on disk)  *         Audio can also be extracted.  *  *        xanim  exporting edition is available at:  *            Web:        http://heroine.linuxbox.com/toys.html  *                        http://www.lokigames.com/development/smjpeg.php3  *            download:   http://heroine.linuxbox.com/xanim_exporting_edition.tar.gz  *                        http://www.lokigames.com/development/download/smjpeg/xanim2801-loki090899.tar.gz  *            Send comments or questions to smjpeg@lokigames.com.  *  * Warning: This Module needs UNIX environment to run.  *   It uses programs and commands that are NOT available  *   on other Operating Systems (Win95, NT ...)  *  *     - xanim              2.80 exporting edition with extensions from loki entertainment.  *                          set environment GAP_XANIM_PROG to configure where to find xanim  *                          (default: search xanim in your PATH)  *     - grep               (UNIX command)  *     - rm                 (UNIX command is used to delete by wildcard (expanded by /bin/sh)  *                                and to delete a directory with all files  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history  * 1.1.14a;  1999/11/22  hof: fixed gcc warning (too many arguments for format)  * 1.1.13a;  1999/11/22  hof: first release  */
end_comment

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
DECL|macro|S_ISDIR (m)
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
DECL|macro|S_ISREG (m)
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_decode_xanim.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_decl_stmt
DECL|variable|global_xanim_input_dir
specifier|static
name|char
modifier|*
name|global_xanim_input_dir
init|=
literal|"input"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|global_xanim_prog
name|char
name|global_xanim_prog
index|[
literal|500
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|global_errlist
name|char
name|global_errlist
index|[
literal|500
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|global_delete_number
name|gint32
name|global_delete_number
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|MKDIR_MODE
define|#
directive|define
name|MKDIR_MODE
value|(S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH )
end_define

begin_comment
comment|/* ============================================================================  * p_xanim_info  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_xanim_info (char * errlist)
name|p_xanim_info
parameter_list|(
name|char
modifier|*
name|errlist
parameter_list|)
block|{
name|t_arr_arg
name|argv
index|[
literal|20
index|]
decl_stmt|;
name|t_but_arg
name|b_argv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_idx
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Conditions to run the xanim based video split"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|""
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"1.) xanim 2.80.0 exporting edition (the loki version)"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"    must be installed somewhere in your PATH"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"    you can get xanim exporting edition at"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    http://heroine.linuxbox.com/toys.html"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    http://www.lokigames.com/development/download/smjpeg/xanim2801-loki090899.tar.gz"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|""
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"2.) if your xanim exporting edition is not in your PATH or is not named xanim"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"    you have to set Environment variable GAP_XANIM_PROG "
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"    to your xanim exporting program and restart gimp"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|""
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"An ERROR occured while trying to call xanim:"
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"--------------------------------------------"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|errlist
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
comment|/* the  Action Button */
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"CANCEL"
argument_list|)
expr_stmt|;
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_rc
operator|=
name|p_array_std_dialog
argument_list|(
name|_
argument_list|(
literal|"XANIM Information"
argument_list|)
argument_list|,
literal|""
argument_list|,
name|l_idx
argument_list|,
name|argv
argument_list|,
comment|/* widget array */
literal|1
argument_list|,
name|b_argv
argument_list|,
comment|/* button array */
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_xanim_info */
end_comment

begin_comment
comment|/* ============================================================================  * p_xanim_dialog  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_xanim_dialog (gint32 * first_frame,gint32 * last_frame,char * filename,gint32 len_filename,char * basename,gint32 len_basename,t_gap_xa_formats * Format,gint32 * extract_video,gint32 * extract_audio,gint32 * jpeg_quality,gint32 * autoload,gint32 * run_xanim_asynchron)
name|p_xanim_dialog
parameter_list|(
name|gint32
modifier|*
name|first_frame
parameter_list|,
name|gint32
modifier|*
name|last_frame
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|len_filename
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|gint32
name|len_basename
parameter_list|,
name|t_gap_xa_formats
modifier|*
name|Format
parameter_list|,
name|gint32
modifier|*
name|extract_video
parameter_list|,
name|gint32
modifier|*
name|extract_audio
parameter_list|,
name|gint32
modifier|*
name|jpeg_quality
parameter_list|,
name|gint32
modifier|*
name|autoload
parameter_list|,
name|gint32
modifier|*
name|run_xanim_asynchron
parameter_list|)
block|{
DECL|macro|XADIALOG_NUM_ARGS
define|#
directive|define
name|XADIALOG_NUM_ARGS
value|11
specifier|static
name|t_arr_arg
name|argv
index|[
name|XADIALOG_NUM_ARGS
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|radio_args
index|[
literal|3
index|]
init|=
block|{
name|N_
argument_list|(
literal|"XCF"
argument_list|)
block|,
name|N_
argument_list|(
literal|"PPM"
argument_list|)
block|,
name|N_
argument_list|(
literal|"JPEG"
argument_list|)
block|}
decl_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Video:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Name of a videofile to READ by xanim\n"
literal|"frames are extracted from the videofile\n"
literal|"and written to seprate diskfiles\n"
literal|"xanim exporting edition is required"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|text_buf_len
operator|=
name|len_filename
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|text_buf_ret
operator|=
name|filename
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|entry_width
operator|=
literal|250
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Framenumber of 1.st frame to extract"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
literal|9999
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To :"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Framenumber of last frame to extract"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
literal|9999
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|9999
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Framenames:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Basename for the AnimFrames to write on disk\n"
literal|"(framenumber and extension is added)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|text_buf_len
operator|=
name|len_basename
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|text_buf_ret
operator|=
name|basename
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|entry_width
operator|=
literal|250
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|4
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Format"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Fileformat for the extracted AnimFrames\n"
literal|"(xcf is extracted as ppm and converted to xcf)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_argc
operator|=
literal|3
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_argv
operator|=
name|radio_args
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|radio_ret
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Extract Frames"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Enable extraction of Frames"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|6
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Extract Audio"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Enable extraction of audio to raw audiofile\n"
literal|"(frame range limits are ignored for audio)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|7
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Jpeg Quality:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Quality for resulting jpeg frames\n"
literal|"(is ignored when other formats are used)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_max
operator|=
literal|100
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
operator|=
literal|90
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|8
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"\nWarning: xanim 2.80 has just limited MPEG support\n"
literal|"most of the frames (type P and B) will be skipped"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|9
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Open"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Open the 1.st one of the extracted frames"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|10
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Run asynchronously"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Run xanim asynchronously and delete unwanted frames\n"
literal|"(out of the specified range) while xanim is still running"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|_
argument_list|(
literal|"Split any Xanim readable Video to Frames"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Select Frame range"
argument_list|)
argument_list|,
name|XADIALOG_NUM_ARGS
argument_list|,
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|<
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
condition|)
block|{
operator|*
name|first_frame
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|last_frame
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first_frame
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|last_frame
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
block|}
operator|*
name|Format
operator|=
call|(
name|t_gap_xa_formats
call|)
argument_list|(
name|argv
index|[
literal|4
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|extract_video
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|extract_audio
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|6
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|jpeg_quality
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|autoload
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|9
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|run_xanim_asynchron
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|10
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* OK */
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
comment|/* Cancel */
block|}
block|}
end_function

begin_comment
comment|/* end p_xanim_dialog */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_overwrite_dialog (char * filename,gint overwrite_mode)
name|p_overwrite_dialog
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint
name|overwrite_mode
parameter_list|)
block|{
specifier|static
name|t_but_arg
name|l_argv
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|t_arr_arg
name|argv
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|filename
argument_list|)
condition|)
block|{
if|if
condition|(
name|overwrite_mode
operator|<
literal|1
condition|)
block|{
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"OVERWRITE frame"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"OVERWRITE all"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|1
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"CANCEL"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|filename
expr_stmt|;
return|return
operator|(
name|p_array_std_dialog
argument_list|(
name|_
argument_list|(
literal|"GAP Question"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"File already exists:"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|l_argv
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|overwrite_mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_build_xanim_framename (char * framename,gint32 frame_nr,char * ext)
name|p_build_xanim_framename
parameter_list|(
name|char
modifier|*
name|framename
parameter_list|,
name|gint32
name|frame_nr
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|sprintf
argument_list|(
name|framename
argument_list|,
literal|"%s/frame%d.%s"
argument_list|,
name|global_xanim_input_dir
argument_list|,
operator|(
name|int
operator|)
name|frame_nr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_build_gap_framename (char * framename,gint32 frame_nr,char * basename,char * ext)
name|p_build_gap_framename
parameter_list|(
name|char
modifier|*
name|framename
parameter_list|,
name|gint32
name|frame_nr
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|sprintf
argument_list|(
name|framename
argument_list|,
literal|"%s%04d.%s"
argument_list|,
name|basename
argument_list|,
operator|(
name|int
operator|)
name|frame_nr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|p_is_directory (char * fname)
name|p_is_directory
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|stat
name|l_stat_buf
decl_stmt|;
comment|/* get File status */
if|if
condition|(
literal|0
operator|!=
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|l_stat_buf
argument_list|)
condition|)
block|{
comment|/* stat error (file does not exist) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|l_stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_is_directory  */
end_comment

begin_function
name|void
DECL|function|p_dirname (char * fname)
name|p_dirname
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|l_idx
decl_stmt|;
name|l_idx
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l_idx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fname
index|[
name|l_idx
index|]
operator|==
name|G_DIR_SEPARATOR
condition|)
block|{
name|fname
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|l_idx
operator|--
expr_stmt|;
block|}
operator|*
name|fname
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_init_xanim_global_name ()
name|p_init_xanim_global_name
parameter_list|()
block|{
name|char
modifier|*
name|l_env
decl_stmt|;
name|l_env
operator|=
name|g_getenv
argument_list|(
literal|"GAP_XANIM_PROG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_env
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|global_xanim_prog
argument_list|,
name|l_env
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|global_xanim_prog
argument_list|,
literal|"xanim"
argument_list|)
expr_stmt|;
comment|/* default name */
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|p_convert_frames (gint32 frame_from,gint32 frame_to,char * basename,char * ext,char * ext2)
name|p_convert_frames
parameter_list|(
name|gint32
name|frame_from
parameter_list|,
name|gint32
name|frame_to
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|,
name|char
modifier|*
name|ext2
parameter_list|)
block|{
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|char
name|l_first_xa_frame
index|[
literal|200
index|]
decl_stmt|;
comment|/* load 1.st one of those frames generated by xanim  */
name|p_build_xanim_framename
argument_list|(
name|l_first_xa_frame
argument_list|,
name|frame_from
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|l_first_xa_frame
argument_list|)
expr_stmt|;
comment|/* convert the xanim frames (from ppm) to xcf fileformat     * (the gap module for range convert is not linked to the frontends     *  main program, therefore i call the convert procedure by PDB-interface)     */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"plug_in_gap_range_convert2"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_INT32
argument_list|,
name|RUN_NONINTERACTIVE
argument_list|,
comment|/* runmode  */
name|PARAM_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|PARAM_DRAWABLE
argument_list|,
literal|0
argument_list|,
comment|/* (unused)  */
name|PARAM_INT32
argument_list|,
name|frame_from
argument_list|,
name|PARAM_INT32
argument_list|,
name|frame_to
argument_list|,
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
comment|/* dont flatten */
name|PARAM_INT32
argument_list|,
literal|4444
argument_list|,
comment|/* dest type (keep type) */
name|PARAM_INT32
argument_list|,
literal|256
argument_list|,
comment|/* colors (unused)  */
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
comment|/* no dither (unused)  */
name|PARAM_STRING
argument_list|,
name|ext2
argument_list|,
comment|/* extension for dest. filetype  */
name|PARAM_STRING
argument_list|,
name|basename
argument_list|,
comment|/* basename for dest. filetype  */
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
comment|/* (unused)  */
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
comment|/* (unused)  */
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
comment|/* (unused)  */
name|PARAM_STRING
argument_list|,
literal|"none"
argument_list|,
comment|/* (unused) palettename */
name|PARAM_END
argument_list|)
expr_stmt|;
comment|/* destroy the tmp image */
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|!=
name|STATUS_SUCCESS
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* OK */
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|p_find_max_xanim_frame (gint32 from_nr,char * ext)
name|p_find_max_xanim_frame
parameter_list|(
name|gint32
name|from_nr
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|gint32
name|l_high
decl_stmt|;
name|gint32
name|l_max_found
decl_stmt|;
name|gint32
name|l_nr
decl_stmt|;
name|gint32
name|l_delta
decl_stmt|;
name|char
name|l_frame
index|[
literal|500
index|]
decl_stmt|;
name|l_nr
operator|=
name|from_nr
expr_stmt|;
name|l_max_found
operator|=
literal|0
expr_stmt|;
name|l_high
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
literal|1
operator|==
literal|1
condition|)
block|{
name|p_build_xanim_framename
argument_list|(
name|l_frame
argument_list|,
name|l_nr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG find_MAX :%s\n"
argument_list|,
name|l_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|l_frame
argument_list|)
condition|)
block|{
name|l_max_found
operator|=
name|l_nr
expr_stmt|;
name|l_delta
operator|=
operator|(
name|l_high
operator|-
name|l_nr
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|l_delta
operator|==
literal|0
condition|)
block|{
name|l_delta
operator|=
literal|1
expr_stmt|;
block|}
name|l_nr
operator|=
name|l_max_found
operator|+
name|l_delta
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l_nr
operator|==
name|from_nr
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* no frames found */
if|if
condition|(
name|l_nr
operator|<
name|l_high
condition|)
block|{
name|l_high
operator|=
name|l_nr
expr_stmt|;
name|l_nr
operator|=
name|l_max_found
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|l_max_found
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* end p_find_max_xanim_frame */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_rename_frames (gint32 frame_from,gint32 frame_to,char * basename,char * ext)
name|p_rename_frames
parameter_list|(
name|gint32
name|frame_from
parameter_list|,
name|gint32
name|frame_to
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|gint32
name|l_use_mv
decl_stmt|;
name|gint32
name|l_frame_nr
decl_stmt|;
name|gint32
name|l_max_found
decl_stmt|;
name|char
name|l_src_frame
index|[
literal|500
index|]
decl_stmt|;
name|char
name|l_dst_frame
index|[
literal|500
index|]
decl_stmt|;
name|gint
name|l_overwrite_mode
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_rename_frames:\n"
argument_list|)
expr_stmt|;
name|l_use_mv
operator|=
name|TRUE
expr_stmt|;
name|l_overwrite_mode
operator|=
literal|0
expr_stmt|;
name|l_max_found
operator|=
name|p_find_max_xanim_frame
argument_list|(
name|frame_from
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_max_found
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"cant find any extracted frames,\n%s\nmaybe xanim has failed or was canclled"
argument_list|)
argument_list|,
name|l_src_frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|l_frame_nr
operator|=
name|frame_from
expr_stmt|;
while|while
condition|(
name|l_frame_nr
operator|<=
name|frame_to
condition|)
block|{
name|p_build_xanim_framename
argument_list|(
name|l_src_frame
argument_list|,
name|l_frame_nr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|p_build_gap_framename
argument_list|(
name|l_dst_frame
argument_list|,
name|l_frame_nr
argument_list|,
name|basename
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_file_exists
argument_list|(
name|l_src_frame
argument_list|)
condition|)
block|{
break|break;
comment|/* srcfile not found, stop */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|l_src_frame
argument_list|,
name|l_dst_frame
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* check overwrite if Destination frame already exsts */
name|l_overwrite_mode
operator|=
name|p_overwrite_dialog
argument_list|(
name|l_dst_frame
argument_list|,
name|l_overwrite_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_overwrite_mode
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"frames are not extracted, because overwrite of %s was cancelled"
argument_list|)
argument_list|,
name|l_dst_frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|remove
argument_list|(
name|l_dst_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|l_dst_frame
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"failed to overwrite %s (check permissions ?)"
argument_list|)
argument_list|,
name|l_dst_frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|l_use_mv
condition|)
block|{
name|rename
argument_list|(
name|l_src_frame
argument_list|,
name|l_dst_frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_file_exists
argument_list|(
name|l_dst_frame
argument_list|)
condition|)
block|{
name|p_file_copy
argument_list|(
name|l_src_frame
argument_list|,
name|l_dst_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|l_dst_frame
argument_list|)
condition|)
block|{
name|l_use_mv
operator|=
name|FALSE
expr_stmt|;
comment|/* if destination is on another device use copy-remove strategy */
name|remove
argument_list|(
name|l_src_frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"failed to write %s (check permissions ?)"
argument_list|)
argument_list|,
name|l_dst_frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|l_frame_nr
operator|++
expr_stmt|;
if|if
condition|(
name|l_max_found
operator|>
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|l_frame_nr
operator|/
operator|(
name|gdouble
operator|)
name|l_max_found
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_rename_frames */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_delete_frames (gint32 max_tries,gint32 frame_from,gint32 frame_to,char * ext)
name|p_delete_frames
parameter_list|(
name|gint32
name|max_tries
parameter_list|,
name|gint32
name|frame_from
parameter_list|,
name|gint32
name|frame_to
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
comment|/* this procedure is performed repeatedly while polling the xanim process    * and after xanim process has (or was) terminated to clean up unwanted frames.    */
name|gint32
name|l_tries
decl_stmt|;
name|gint32
name|l_next_number
decl_stmt|;
name|char
name|l_framename
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_delete_frames: cleaning up unwanted frames (max=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|max_tries
argument_list|)
expr_stmt|;
name|l_tries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|global_delete_number
operator|<
name|frame_from
operator|)
operator|&&
operator|(
name|l_tries
operator|<
name|max_tries
operator|)
condition|)
block|{
name|l_next_number
operator|=
name|global_delete_number
operator|+
literal|1
expr_stmt|;
name|p_build_xanim_framename
argument_list|(
name|l_framename
argument_list|,
name|l_next_number
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|l_framename
argument_list|)
condition|)
block|{
comment|/* if xanim has already written the next frame 	 * we can delete the previous (unwanted) frame now 	 */
name|p_build_xanim_framename
argument_list|(
name|l_framename
argument_list|,
name|global_delete_number
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"delete frame: %s\n"
argument_list|,
name|l_framename
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_framename
argument_list|)
expr_stmt|;
name|global_delete_number
operator|=
name|l_next_number
expr_stmt|;
block|}
name|l_tries
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end p_delete_frames */
end_comment

begin_function
specifier|static
name|void
DECL|function|p_poll (pid_t xanim_pid,char * one_past_last_frame,gint32 frame_from,gint32 frame_to,char * ext)
name|p_poll
parameter_list|(
name|pid_t
name|xanim_pid
parameter_list|,
name|char
modifier|*
name|one_past_last_frame
parameter_list|,
name|gint32
name|frame_from
parameter_list|,
name|gint32
name|frame_to
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
comment|/* loop as long as the Xanim Process is alive */
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"poll started on xanim pid: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|xanim_pid
argument_list|)
expr_stmt|;
comment|/* kill  with signal 0 checks only if the process is alive (no signal is sent)    *       returns 0 if alive, 1 if no process with given pid found.    */
while|while
condition|(
literal|0
operator|==
name|kill
argument_list|(
name|xanim_pid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* sleep 1 second, and let xanim write some frames */
if|if
condition|(
name|p_file_exists
argument_list|(
name|one_past_last_frame
argument_list|)
condition|)
block|{
comment|/* if the last desired frame is written         * we can stop (kill with signal 9) the xanim process.         */
name|kill
argument_list|(
name|xanim_pid
argument_list|,
literal|9
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for max unwanted frames and delete (upto 20 of them) */
name|p_delete_frames
argument_list|(
literal|20
argument_list|,
name|frame_from
argument_list|,
name|frame_to
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"poll ended on xanim pid: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|xanim_pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end p_poll */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_grep (char * pattern,char * file)
name|p_grep
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|char
name|l_cmd
index|[
literal|300
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"grep -c '%s' \"%s\">/dev/null"
argument_list|,
name|pattern
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* pattern found */
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* pattern NOT found */
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|p_check_xanim ()
name|p_check_xanim
parameter_list|()
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_grep_counter1
decl_stmt|;
name|int
name|l_grep_counter2
decl_stmt|;
name|int
name|l_grep_counter3
decl_stmt|;
name|char
name|l_cmd
index|[
literal|300
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|l_xanim_help_output
init|=
literal|"tmp_xanim_help.output"
decl_stmt|;
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|l_xanim_help_output
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
literal|"no write permission for current directory"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"dummy"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
comment|/* execute xanim with -h option and     * store its output in a file.    */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"%s -h 2>&1>>%s"
argument_list|,
name|global_xanim_prog
argument_list|,
name|l_xanim_help_output
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DEBUG: executed :%s\n  Retcode: %d\n"
argument_list|,
name|l_cmd
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_rc
operator|==
literal|127
operator|)
operator|||
operator|(
name|l_rc
operator|==
operator|(
literal|127
operator|<<
literal|8
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"could not execute %s (check if xanim is installed)"
argument_list|)
argument_list|,
name|global_xanim_prog
argument_list|)
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|p_file_exists
argument_list|(
name|l_xanim_help_output
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"%s does not look like xanim"
argument_list|)
argument_list|,
name|global_xanim_prog
argument_list|)
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
comment|/* check the help output of xanim (using grep) */
name|l_grep_counter1
operator|=
literal|0
expr_stmt|;
comment|/* l_grep_counter1 += p_grep("anim", l_xanim_help_output); */
comment|/* check for the exporting options */
name|l_grep_counter2
operator|=
literal|0
expr_stmt|;
name|l_grep_counter2
operator|+=
name|p_grep
argument_list|(
literal|"Ea"
argument_list|,
name|l_xanim_help_output
argument_list|)
expr_stmt|;
name|l_grep_counter2
operator|+=
name|p_grep
argument_list|(
literal|"Ee"
argument_list|,
name|l_xanim_help_output
argument_list|)
expr_stmt|;
name|l_grep_counter2
operator|+=
name|p_grep
argument_list|(
literal|"Eq"
argument_list|,
name|l_xanim_help_output
argument_list|)
expr_stmt|;
comment|/* check for the loki version that is able to write single frames */
name|l_grep_counter3
operator|=
literal|0
expr_stmt|;
name|l_grep_counter3
operator|+=
name|p_grep
argument_list|(
literal|"Write video to input/frameN.EXT"
argument_list|,
name|l_xanim_help_output
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_xanim_help_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_grep_counter2
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"The xanim program on your system \"%s\"\ndoes not support the exporting options Ea, Ee, Eq"
argument_list|)
argument_list|,
name|global_xanim_prog
argument_list|)
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
if|if
condition|(
name|l_grep_counter3
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"The xanim program on your system \"%s\"\ndoes not support exporting of single frames"
argument_list|)
argument_list|,
name|global_xanim_prog
argument_list|)
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* OK, xanim output looks like expected */
block|}
end_function

begin_comment
comment|/* end p_check_xanim */
end_comment

begin_function
specifier|static
name|pid_t
DECL|function|p_start_xanim_process (gint32 first_frame,gint32 last_frame,char * filename,t_gap_xa_formats Format,gint32 extract_video,gint32 extract_audio,gint32 jpeg_quality,char * one_past_last_frame,gint32 run_xanim_asynchron)
name|p_start_xanim_process
parameter_list|(
name|gint32
name|first_frame
parameter_list|,
name|gint32
name|last_frame
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|t_gap_xa_formats
name|Format
parameter_list|,
name|gint32
name|extract_video
parameter_list|,
name|gint32
name|extract_audio
parameter_list|,
name|gint32
name|jpeg_quality
parameter_list|,
name|char
modifier|*
name|one_past_last_frame
parameter_list|,
name|gint32
name|run_xanim_asynchron
parameter_list|)
block|{
name|char
name|l_cmd
index|[
literal|300
index|]
decl_stmt|;
name|char
name|l_buf
index|[
literal|40
index|]
decl_stmt|;
name|pid_t
name|l_xanim_pid
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|FILE
modifier|*
name|l_fp
decl_stmt|;
specifier|static
name|char
modifier|*
name|l_xanim_startscript
init|=
literal|"tmp_xanim_startscript.sh"
decl_stmt|;
specifier|static
name|char
modifier|*
name|l_xanim_pidfile
init|=
literal|"tmp_xanim_pidfile"
decl_stmt|;
name|l_xanim_pid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* allocate and prepare args for the xanim call */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"%s +f "
argument_list|,
name|global_xanim_prog
argument_list|)
expr_stmt|;
comment|/* programname */
if|if
condition|(
name|extract_audio
condition|)
block|{
name|strcat
argument_list|(
name|l_cmd
argument_list|,
literal|"+Ea "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extract_video
condition|)
block|{
name|strcat
argument_list|(
name|l_cmd
argument_list|,
literal|"+v "
argument_list|)
expr_stmt|;
comment|/* +v is verbose mode */
switch|switch
condition|(
name|Format
condition|)
block|{
case|case
name|XAENC_PPMRAW
case|:
name|strcat
argument_list|(
name|l_cmd
argument_list|,
literal|"+Ee "
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAENC_JPEG
case|:
name|sprintf
argument_list|(
name|l_buf
argument_list|,
literal|"+Eq%d "
argument_list|,
operator|(
name|int
operator|)
name|jpeg_quality
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|l_cmd
argument_list|,
name|l_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|l_cmd
argument_list|,
literal|"+Ee "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* additional option "Pause after N Frames" is used,       * to stop xanim exporting frames beyond the requested limit       */
if|if
condition|(
name|run_xanim_asynchron
condition|)
block|{
name|sprintf
argument_list|(
name|l_buf
argument_list|,
literal|"+Zp%d "
argument_list|,
call|(
name|int
call|)
argument_list|(
name|last_frame
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|l_cmd
argument_list|,
name|l_buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* add the videofilename as last parameter */
name|strcat
argument_list|(
name|l_cmd
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_xanim_asynchron
condition|)
block|{
comment|/* asynchron start */
name|remove
argument_list|(
name|l_xanim_pidfile
argument_list|)
expr_stmt|;
comment|/* generate a shelscript */
name|l_fp
operator|=
name|fopen
argument_list|(
name|l_xanim_startscript
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#!/bin/sh\n"
argument_list|)
expr_stmt|;
comment|/* fprintf(l_fp, "(%s ; touch %s)&\n" */
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%s& # ; touch %s)&\n"
argument_list|,
name|l_cmd
comment|/* start xanim as background process */
argument_list|,
name|one_past_last_frame
comment|/* and create a dummy frame when xanim is done */
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"XANIM_PID=$!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"echo \"$XANIM_PID # XANIM_PID\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"echo \"$XANIM_PID # XANIM_PID\"> \"%s\"\n"
argument_list|,
name|l_xanim_pidfile
argument_list|)
expr_stmt|;
comment|/* we pass the xanim pid in a file,            * exitcodes are truncated to 8 bit           * by the system call           */
comment|/* fprintf(l_fp, "exit $XANIM_PID\n"); */
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|l_xanim_startscript
argument_list|,
name|MKDIR_MODE
argument_list|)
expr_stmt|;
block|}
name|l_rc
operator|=
name|system
argument_list|(
name|l_xanim_startscript
argument_list|)
expr_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|l_xanim_pidfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fscanf
argument_list|(
name|l_fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|l_rc
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
name|l_xanim_pid
operator|=
operator|(
name|pid_t
operator|)
name|l_rc
expr_stmt|;
block|}
name|remove
argument_list|(
name|l_xanim_startscript
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_xanim_pidfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"ASYNCHRON CALL: %s\nl_xanim_pid:%d\n"
argument_list|,
name|l_cmd
argument_list|,
operator|(
name|int
operator|)
name|l_xanim_pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* synchron start (blocks until xanim process has finished */
name|l_rc
operator|=
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_rc
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
name|l_xanim_pid
operator|=
literal|0
expr_stmt|;
else|else
name|l_xanim_pid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"ASYNCHRON CALL: %s\nretcode:%d (%d)\n"
argument_list|,
name|l_cmd
argument_list|,
operator|(
name|int
operator|)
name|l_rc
argument_list|,
operator|(
name|int
operator|)
name|l_xanim_pid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_xanim_pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_start_xanim_process */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|THIS_IS_A_COMMENT_EXEC_DID_NOT_WORK_AND_LEAVES_A_ZOMBIE_PROCESS
end_ifdef

begin_function
specifier|static
name|pid_t
DECL|function|p_start_xanim_process_exec (gint32 first_frame,gint32 last_frame,char * filename,t_gap_xa_formats Format,gint32 extract_video,gint32 extract_audio,gint32 jpeg_quality)
name|p_start_xanim_process_exec
parameter_list|(
name|gint32
name|first_frame
parameter_list|,
name|gint32
name|last_frame
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|t_gap_xa_formats
name|Format
parameter_list|,
name|gint32
name|extract_video
parameter_list|,
name|gint32
name|extract_audio
parameter_list|,
name|gint32
name|jpeg_quality
parameter_list|)
block|{
name|char
modifier|*
name|args
index|[
literal|20
index|]
decl_stmt|;
name|char
name|l_buf
index|[
literal|40
index|]
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|pid_t
name|l_xanim_pid
decl_stmt|;
comment|/* allocate and prepare args for the xanim call */
name|l_idx
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
name|global_xanim_prog
argument_list|)
expr_stmt|;
comment|/* programname */
name|l_idx
operator|++
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
literal|"+f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extract_audio
condition|)
block|{
name|l_idx
operator|++
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
literal|"+Ea"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extract_video
condition|)
block|{
name|l_idx
operator|++
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
literal|"+v"
argument_list|)
expr_stmt|;
comment|/* +v is verbose mode */
name|l_idx
operator|++
expr_stmt|;
switch|switch
condition|(
name|Format
condition|)
block|{
case|case
name|XAENC_PPMRAW
case|:
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
literal|"+Ee"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAENC_JPEG
case|:
name|sprintf
argument_list|(
name|l_buf
argument_list|,
literal|"+Eq%d"
argument_list|,
operator|(
name|int
operator|)
name|jpeg_quality
argument_list|)
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
name|l_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
literal|"+Ee"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* additional option "Pause after N Frames" is used,       * to stop xanim exporting frames beyond the requested limit       */
name|l_idx
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|l_buf
argument_list|,
literal|"+Zp%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|last_frame
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
name|l_buf
argument_list|)
expr_stmt|;
block|}
comment|/* add the videofilename as last parameter */
name|l_idx
operator|++
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|g_strdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|args
index|[
name|l_idx
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* terminate args list with a NULL pointer */
name|l_xanim_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|l_xanim_pid
operator|==
literal|0
condition|)
block|{
comment|/* here we are in the forked child process        * execute xanim        */
name|execvp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* this point should never be reached */
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_xanim_pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_start_xanim_process */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ============================================================================  * gap_xanim_decode  * ============================================================================  */
end_comment

begin_function
name|gint32
DECL|function|gap_xanim_decode (GRunModeType run_mode)
name|gap_xanim_decode
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|)
block|{
name|gint32
name|l_rc
decl_stmt|;
name|gint32
name|first_frame
decl_stmt|;
name|gint32
name|last_frame
decl_stmt|;
name|char
name|filename
index|[
literal|200
index|]
decl_stmt|;
name|char
name|basename
index|[
literal|200
index|]
decl_stmt|;
name|char
name|extension
index|[
literal|20
index|]
decl_stmt|;
name|char
name|extension2
index|[
literal|20
index|]
decl_stmt|;
name|t_gap_xa_formats
name|Format
decl_stmt|;
name|gint32
name|extract_audio
decl_stmt|;
name|gint32
name|extract_video
decl_stmt|;
name|gint32
name|jpeg_quality
decl_stmt|;
name|gint32
name|autoload
decl_stmt|;
name|gint32
name|run_xanim_asynchron
decl_stmt|;
name|char
name|l_cmd
index|[
literal|300
index|]
decl_stmt|;
name|char
name|l_one_past_last_frame
index|[
literal|200
index|]
decl_stmt|;
name|char
name|l_first_to_laod
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|l_dst_dir
decl_stmt|;
name|pid_t
name|l_xanim_pid
decl_stmt|;
name|int
name|l_input_dir_created_by_myself
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_input_dir_created_by_myself
operator|=
name|FALSE
expr_stmt|;
name|global_errlist
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_init_xanim_global_name
argument_list|()
expr_stmt|;
name|filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|basename
index|[
literal|0
index|]
argument_list|,
literal|"frame_"
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_xanim_dialog
argument_list|(
operator|&
name|first_frame
argument_list|,
operator|&
name|last_frame
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
name|basename
argument_list|,
sizeof|sizeof
argument_list|(
name|basename
argument_list|)
argument_list|,
operator|&
name|Format
argument_list|,
operator|&
name|extract_video
argument_list|,
operator|&
name|extract_audio
argument_list|,
operator|&
name|jpeg_quality
argument_list|,
operator|&
name|autoload
argument_list|,
operator|&
name|run_xanim_asynchron
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|p_file_exists
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"videofile %s not existent or empty\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|l_rc
operator|=
name|p_check_xanim
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|Format
condition|)
block|{
case|case
name|XAENC_PPMRAW
case|:
name|strcpy
argument_list|(
name|extension
argument_list|,
literal|"ppm"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|extension2
argument_list|,
literal|".ppm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAENC_JPEG
case|:
name|strcpy
argument_list|(
name|extension
argument_list|,
literal|"jpg"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|extension2
argument_list|,
literal|".jpg"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|extension
argument_list|,
literal|"ppm"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|extension2
argument_list|,
literal|".xcf"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p_build_xanim_framename
argument_list|(
name|l_one_past_last_frame
argument_list|,
name|last_frame
operator|+
literal|1
argument_list|,
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|extract_video
condition|)
block|{
comment|/* for the frames we need a directory named "input" */
if|if
condition|(
name|p_is_directory
argument_list|(
name|global_xanim_input_dir
argument_list|)
condition|)
block|{
comment|/* the input directory already exists,             * remove frames             */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"rm -f %s/*.%s"
argument_list|,
name|global_xanim_input_dir
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* create input directory (needed by xanim to store the frames) */
name|mkdir
argument_list|(
name|global_xanim_input_dir
argument_list|,
name|MKDIR_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_is_directory
argument_list|(
name|global_xanim_input_dir
argument_list|)
condition|)
block|{
name|l_input_dir_created_by_myself
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"could not create %s directory\n"
literal|"(that is required for xanim frame export)"
argument_list|)
argument_list|,
name|global_xanim_input_dir
argument_list|)
expr_stmt|;
name|l_rc
operator|=
literal|10
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"extracting frames..."
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|0.1
argument_list|)
expr_stmt|;
comment|/* fake some progress */
comment|/* note:       *  we cant show realistic progress for the extracting process       *  because we know nothing about videofileformat and how much frames       *  are realy stored in the videofile.       *       *  one guess could assume, that xanim will write 0 upto last_frame       *  to disk, and check for the frames that the xanim process creates.       *  The periodically checking can be done in the poll procedure for asynchron       *  startmode only.       */
name|l_xanim_pid
operator|=
name|p_start_xanim_process
argument_list|(
name|first_frame
argument_list|,
name|last_frame
argument_list|,
name|filename
argument_list|,
name|Format
argument_list|,
name|extract_video
argument_list|,
name|extract_audio
argument_list|,
name|jpeg_quality
argument_list|,
name|l_one_past_last_frame
argument_list|,
name|run_xanim_asynchron
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_xanim_pid
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"could not start xanim process\n(program=%s)"
argument_list|)
argument_list|,
name|global_xanim_prog
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|run_xanim_asynchron
condition|)
block|{
name|p_poll
argument_list|(
name|l_xanim_pid
argument_list|,
name|l_one_past_last_frame
argument_list|,
name|first_frame
argument_list|,
name|last_frame
argument_list|,
name|extension
argument_list|)
expr_stmt|;
block|}
name|p_delete_frames
argument_list|(
literal|99999
argument_list|,
name|first_frame
argument_list|,
name|last_frame
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_one_past_last_frame
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_find_max_xanim_frame
argument_list|(
name|first_frame
argument_list|,
name|extension
argument_list|)
operator|<
name|first_frame
condition|)
block|{
name|sprintf
argument_list|(
name|global_errlist
argument_list|,
name|_
argument_list|(
literal|"cant find any extracted frames,\n"
literal|"xanim has failed or was canclled"
argument_list|)
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* if destination directorypart does not exist, try to create it */
name|l_dst_dir
operator|=
name|g_strdup
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|p_dirname
argument_list|(
name|l_dst_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l_dst_dir
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|p_is_directory
argument_list|(
name|l_dst_dir
argument_list|)
condition|)
block|{
name|mkdir
argument_list|(
name|l_dst_dir
argument_list|,
name|MKDIR_MODE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|extension
argument_list|,
operator|&
name|extension2
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"renaming frames..."
argument_list|)
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_rename_frames
argument_list|(
name|first_frame
argument_list|,
name|last_frame
argument_list|,
name|basename
argument_list|,
name|extension
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"converting frames..."
argument_list|)
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_convert_frames
argument_list|(
name|first_frame
argument_list|,
name|last_frame
argument_list|,
name|basename
argument_list|,
name|extension
argument_list|,
name|extension2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_input_dir_created_by_myself
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|l_dst_dir
argument_list|,
name|global_xanim_input_dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* remove input dir with all files */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"rm -rf \"%s\""
argument_list|,
name|global_xanim_input_dir
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_dst_dir
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|global_errlist
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p_xanim_info
argument_list|(
literal|"ERROR: could not execute xanim"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_xanim_info
argument_list|(
name|global_errlist
argument_list|)
expr_stmt|;
block|}
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|autoload
condition|)
block|{
comment|/* load first frame and add a display */
name|p_build_gap_framename
argument_list|(
name|l_first_to_laod
argument_list|,
name|first_frame
argument_list|,
name|basename
argument_list|,
operator|&
name|extension2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_load_image
argument_list|(
name|l_first_to_laod
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
name|gimp_display_new
argument_list|(
name|l_rc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end  gap_xanim_decode */
end_comment

end_unit

