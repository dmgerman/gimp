begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_range_ops.c  * 1997.11.06 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * This Module contains   * - gap_split_image  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history  * gimp   1.1.15.1;  1999/05/08  hof: bugix (dont mix GDrawableType with GImageType)  * 0.96.00; 1998/07/01   hof: - added scale, resize and crop   *                              (affects full range == all anim frames)  *                            - now using gap_arr_dialog.h  * 0.94.01; 1998/04/28   hof: added flatten_mode to plugin: gap_range_to_multilayer  * 0.92.00  1998.01.10   hof: bugfix in p_frames_to_multilayer  *                            layers need alpha (to be raise/lower able)   * 0.90.00               first development release  */
end_comment

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_layer_copy.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_comment
comment|/* ============================================================================  * p_split_image  *  * returns   value>= 0 if all is ok  return the image_id of   *                      the new created image (the last handled anim frame)  *           (or -1 on error)  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_split_image (t_anim_info * ainfo_ptr,char * new_extension,gint invers,gint no_alpha)
name|p_split_image
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|char
modifier|*
name|new_extension
parameter_list|,
name|gint
name|invers
parameter_list|,
name|gint
name|no_alpha
parameter_list|)
block|{
name|GImageType
name|l_type
decl_stmt|;
name|guint
name|l_width
decl_stmt|,
name|l_height
decl_stmt|;
name|GRunModeType
name|l_run_mode
decl_stmt|;
name|gint32
name|l_new_image_id
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|gint32
name|l_src_layer_id
decl_stmt|;
name|gint32
name|l_cp_layer_id
decl_stmt|;
name|gint
name|l_src_offset_x
decl_stmt|,
name|l_src_offset_y
decl_stmt|;
comment|/* layeroffsets as they were in src_image */
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
name|char
modifier|*
name|l_sav_name
decl_stmt|;
name|gint32
name|l_rc
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|long
name|l_layer_idx
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
name|l_run_mode
operator|=
name|ainfo_ptr
operator|->
name|run_mode
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|gimp_progress_init
argument_list|(
literal|"Splitting into Frames .."
argument_list|)
expr_stmt|;
block|}
name|l_new_image_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* get info about the image  */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_type
operator|=
name|gimp_image_base_type
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|!=
name|NULL
condition|)
block|{
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
name|l_nlayers
operator|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_nlayers
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|l_new_image_id
operator|>=
literal|0
condition|)
block|{
comment|/* destroy the tmp image (it was saved to disk before) */
name|gimp_image_delete
argument_list|(
name|l_new_image_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invers
operator|==
name|TRUE
condition|)
name|l_layer_idx
operator|=
name|l_idx
expr_stmt|;
else|else
name|l_layer_idx
operator|=
operator|(
name|l_nlayers
operator|-
literal|1
operator|)
operator|-
name|l_idx
expr_stmt|;
name|l_src_layer_id
operator|=
name|l_layers_list
index|[
name|l_layer_idx
index|]
expr_stmt|;
comment|/* create new image */
name|l_new_image_id
operator|=
name|gimp_image_new
argument_list|(
name|l_width
argument_list|,
name|l_height
argument_list|,
name|l_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_new_image_id
operator|<
literal|0
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* copy the layer */
name|l_cp_layer_id
operator|=
name|p_my_layer_copy
argument_list|(
name|l_new_image_id
argument_list|,
name|l_src_layer_id
argument_list|,
literal|100.0
argument_list|,
comment|/* Opacity */
literal|0
argument_list|,
comment|/* NORMAL */
operator|&
name|l_src_offset_x
argument_list|,
operator|&
name|l_src_offset_y
argument_list|)
expr_stmt|;
comment|/* add the copied layer to current destination image */
name|gimp_image_add_layer
argument_list|(
name|l_new_image_id
argument_list|,
name|l_cp_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_set_offsets
argument_list|(
name|l_cp_layer_id
argument_list|,
name|l_src_offset_x
argument_list|,
name|l_src_offset_y
argument_list|)
expr_stmt|;
comment|/* delete alpha channel ? */
if|if
condition|(
name|no_alpha
operator|==
name|TRUE
condition|)
block|{
comment|/* add a dummy layer (flatten needs at least 2 layers) */
name|l_cp_layer_id
operator|=
name|gimp_layer_new
argument_list|(
name|l_new_image_id
argument_list|,
literal|"dummy"
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
comment|/* width, height */
operator|(
operator|(
name|l_type
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
argument_list|,
comment|/* convert from GImageType to GDrawableType, and add alpha */
literal|0.0
argument_list|,
comment|/* Opacity full transparent */
literal|0
argument_list|)
expr_stmt|;
comment|/* NORMAL */
name|gimp_image_add_layer
argument_list|(
name|l_new_image_id
argument_list|,
name|l_cp_layer_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_image_flatten
argument_list|(
name|l_new_image_id
argument_list|)
expr_stmt|;
block|}
comment|/* build the name for output image */
name|l_sav_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
operator|(
name|l_idx
operator|+
literal|1
operator|)
argument_list|,
comment|/* start at 1 (not at 0) */
name|new_extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_sav_name
operator|!=
name|NULL
condition|)
block|{
comment|/* save with selected save procedure           * (regardless if image was flattened or not)           */
name|l_rc
operator|=
name|p_save_named_image
argument_list|(
name|l_new_image_id
argument_list|,
name|l_sav_name
argument_list|,
name|l_run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
literal|"Split Frames: SAVE operation FAILED\n- desired save plugin cant handle type\n- or desired save plugin not available\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|l_run_mode
operator|=
name|RUN_NONINTERACTIVE
expr_stmt|;
comment|/* for all further calls */
comment|/* set image name */
name|gimp_image_set_filename
argument_list|(
name|l_new_image_id
argument_list|,
name|l_sav_name
argument_list|)
expr_stmt|;
comment|/* prepare return value */
name|l_rc
operator|=
name|l_new_image_id
expr_stmt|;
name|g_free
argument_list|(
name|l_sav_name
argument_list|)
expr_stmt|;
block|}
comment|/* save as frame */
comment|/* show progress bar */
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
block|}
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_split_image */
end_comment

begin_comment
comment|/* ============================================================================  * p_split_dialog  *  *   return  0 (OK)   *          or  -1 in case of Error or cancel  * ============================================================================  */
end_comment

begin_function
specifier|static
name|long
DECL|function|p_split_dialog (t_anim_info * ainfo_ptr,gint * inverse_order,gint * no_alpha,char * extension,gint len_ext)
name|p_split_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|gint
modifier|*
name|inverse_order
parameter_list|,
name|gint
modifier|*
name|no_alpha
parameter_list|,
name|char
modifier|*
name|extension
parameter_list|,
name|gint
name|len_ext
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n%s\n(%s_0001.%s)\n"
argument_list|,
literal|"Make a frame (diskfile) from each Layer"
argument_list|,
literal|"frames are named: base_nr.extension"
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
literal|"Extension:"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
literal|"extension of resulting frames       \n(is also used to define Fileformat)"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|text_buf_len
operator|=
name|len_ext
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|text_buf_ret
operator|=
name|extension
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
literal|"Inverse Order :"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
literal|"Start frame 0001 at Top Layer"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
literal|"Flatten :"
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|help_txt
operator|=
literal|"Remove Alpha Channel in resulting Frames,    \ntransparent parts are filled with BG color"
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|int_ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
literal|"Split Image into Frames"
argument_list|,
literal|"Split Settings :"
argument_list|,
literal|4
argument_list|,
name|argv
argument_list|)
condition|)
block|{
operator|*
name|inverse_order
operator|=
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
expr_stmt|;
operator|*
name|no_alpha
operator|=
name|argv
index|[
literal|3
index|]
operator|.
name|int_ret
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_split_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * gap_split_image  *    Split one (multilayer) image into anim-frames  *    one frame per layer.  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_split_image (GRunModeType run_mode,gint32 image_id,gint32 inverse_order,gint32 no_alpha,char * extension)
name|int
name|gap_split_image
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|gint32
name|inverse_order
parameter_list|,
name|gint32
name|no_alpha
parameter_list|,
name|char
modifier|*
name|extension
parameter_list|)
block|{
name|gint32
name|l_new_image_id
decl_stmt|;
name|gint32
name|l_rc
decl_stmt|;
name|gint32
name|l_inverse_order
decl_stmt|;
name|gint32
name|l_no_alpha
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|char
name|l_extension
index|[
literal|32
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|l_extension
argument_list|,
literal|".xcf"
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ainfo_ptr
operator|->
name|frame_cnt
operator|!=
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|run_mode
argument_list|,
literal|"OPERATION CANCELLED\nThis image is already an AnimFrame\nTry again on a Duplicate\n(image/channel ops/duplicate)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_rc
operator|=
name|p_split_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_inverse_order
argument_list|,
operator|&
name|l_no_alpha
argument_list|,
operator|&
name|l_extension
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_extension
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_inverse_order
operator|=
name|inverse_order
expr_stmt|;
name|l_no_alpha
operator|=
name|no_alpha
expr_stmt|;
name|strncpy
argument_list|(
name|l_extension
argument_list|,
name|extension
argument_list|,
sizeof|sizeof
argument_list|(
name|l_extension
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_extension
index|[
sizeof|sizeof
argument_list|(
name|l_extension
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
name|l_new_image_id
operator|=
name|p_split_image
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_extension
argument_list|,
name|l_inverse_order
argument_list|,
name|l_no_alpha
argument_list|)
expr_stmt|;
comment|/* create a display for the new created image             * (it is the first or the last frame of the              *  new created animation sequence)             */
name|gimp_display_new
argument_list|(
name|l_new_image_id
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|l_new_image_id
expr_stmt|;
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end   gap_split_image */
end_comment

end_unit

