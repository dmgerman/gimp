begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_decode_mpeg.c */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * Plugin to load MPEG movies. (C) 1997-99 Adam D. Moss  *           GAP modifications (C) 1999    Wolfgang Hofer  *  * v1.1 - by Adam D. Moss, adam@gimp.org, adam@foxbox.org  * Requires mpeg_lib by Gregory P. Ward.  See notes below for  * obtaining and patching mpeg_lib.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*******************************************************************  * USING MPEG_LIB WITH THIS PLUGIN:  mpeg_lib 1.2.1 can be found   *  * at ftp://ftp.mni.mcgill.ca/pub/mpeg/ - however, mpeg_lib 1.2.x  *  * contains a bug in end-of-stream reporting, which will cause it  *  * to crash in conjunction with this plugin.  I enclose a simple   *  * patch below which fixes the problem (or at least the symptom.;))*  *******************************************************************  *    Addendum: mpeg_lib 1.3.0 is now released and much better!    *  *******************************************************************  *     mpeg_lib 1.3.1  is available at: 	                   *  *     http://starship.python.net/~gward/mpeglib	           *  *******************************************************************/
end_comment

begin_comment
comment|/******************************************************************* *** wrapper.c   Tue Oct 10 22:08:39 1995 --- ../mpeg_lib2/wrapper.c      Sat Sep 20 20:29:46 1997 *************** *** 392,394 ****             "copying from %08X to %08X\n", CurrentImage, Frame); !    memcpy (Frame, CurrentImage, ImageInfo.Size);      return (!MovieDone); --- 392,397 ----             "copying from %08X to %08X\n", CurrentImage, Frame); ! !    if (!MovieDone) !       memcpy (Frame, CurrentImage, ImageInfo.Size); !      return (!MovieDone); *******************************************************************/
end_comment

begin_comment
comment|/*  * Changelog:  *  * 2000/02/07 v1.1.16a:  hof: replaced sprintf by g_strdup_printf  * 2000/01/06 v1.1.14a:  hof: save thumbnails .xvpics p_gimp_file_save_thumbnail  *                       store framerate in video_info file  * 1999/11/25 v1.1.11.b: Initial release. [hof]   *                       (based on plug-ins/common/mpeg.c v1.1 99/05/31 by Adam D. Moss)  */
end_comment

begin_comment
comment|/* UNIX system includes */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_pdb_calls.h"
end_include

begin_comment
comment|/* Includes for extra LIBS */
end_comment

begin_include
include|#
directive|include
file|"mpeg.h"
end_include

begin_decl_stmt
DECL|variable|gap_debug
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|gap_debug
comment|/* ==0  ... dont print debug infos */
end_comment

begin_comment
comment|/*  for i18n  */
end_comment

begin_decl_stmt
DECL|variable|dummy_entries
specifier|static
name|gchar
name|G_GNUC_UNUSED
modifier|*
name|dummy_entries
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"<Image>/Video/Split Video to Frames"
argument_list|)
block|,
name|N_
argument_list|(
literal|"<Toolbox>/Xtns/Split Video to Frames"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GimpParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|first_frame
parameter_list|,
name|gint32
name|last_frame
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|gint32
name|autoload
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_range_dialog
parameter_list|(
name|gint32
modifier|*
name|first_frame
parameter_list|,
name|gint32
modifier|*
name|last_frame
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|len_filename
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|gint32
name|len_basename
parameter_list|,
name|gint32
modifier|*
name|autoload
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GimpPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GimpParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"(unused)"
block|}
block|,
block|{
name|GIMP_PDB_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"(unused)"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"first_frame"
block|,
literal|"1st frame to extract (starting at number 1)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"last_frame"
block|,
literal|"last frame to extract (use 0 to load all remaining frames)"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"animframe_basename"
block|,
literal|"The name for the single frames _0001.xcf is added"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"autoload"
block|,
literal|"TRUE: load 1.st extracted frame on success"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GimpParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|GIMP_PDB_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nload_return_vals
init|=
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|GimpParamDef
name|ext_args
index|[]
init|=
block|{
block|{
name|GIMP_PDB_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"first_frame"
block|,
literal|"1st frame to extract (starting at number 1)"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"last_frame"
block|,
literal|"last frame to extract (use 0 to load all remaining frames)"
block|}
block|,
block|{
name|GIMP_PDB_STRING
block|,
literal|"animframe_basename"
block|,
literal|"The name for the single frames _0001.xcf is added"
block|}
block|,
block|{
name|GIMP_PDB_INT32
block|,
literal|"autoload"
block|,
literal|"TRUE: load 1.st extracted frame on success"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|next_args
init|=
sizeof|sizeof
argument_list|(
name|ext_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ext_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|INIT_I18N
argument_list|()
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_gap_decode_mpeg"
argument_list|,
literal|"Split MPEG1 movies into animframes and load 1st frame"
argument_list|,
literal|"Split MPEG1 movies into single frames (image files on disk) and load 1st frame. audio tracks are ignored"
argument_list|,
literal|"Wolfgang Hofer (hof@hotbot.com)"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"2000/01/01"
argument_list|,
name|N_
argument_list|(
literal|"<Image>/Video/Split Video to Frames/MPEG1"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_PLUGIN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"extension_gap_decode_mpeg"
argument_list|,
literal|"Split MPEG1 movies into animframes and load 1st frame"
argument_list|,
literal|"Split MPEG1 movies into single frames (image files on disk) and load 1st frame. audio tracks are ignored"
argument_list|,
literal|"Wolfgang Hofer (hof@hotbot.com)"
argument_list|,
literal|"Wolfgang Hofer"
argument_list|,
literal|"2000/01/01"
argument_list|,
name|N_
argument_list|(
literal|"<Toolbox>/Xtns/Split Video to Frames/MPEG1"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|GIMP_EXTENSION
argument_list|,
name|next_args
argument_list|,
name|nload_return_vals
argument_list|,
name|ext_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (char * name,int nparams,GimpParam * param,int * nreturn_vals,GimpParam ** return_vals)
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GimpParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GimpParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GimpParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GimpRunModeType
name|run_mode
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|first_frame
decl_stmt|,
name|last_frame
decl_stmt|;
name|gint32
name|autoload
decl_stmt|;
name|gint32
name|l_rc
decl_stmt|;
name|char
name|l_frames_basename
index|[
literal|500
index|]
decl_stmt|;
name|char
name|l_filename
index|[
literal|500
index|]
decl_stmt|;
name|int
name|l_par
decl_stmt|;
name|image_ID
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|autoload
operator|=
name|FALSE
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_CALLING_ERROR
expr_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"plug_in_gap_decode_mpeg"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"extension_gap_decode_mpeg"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|l_filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|l_frames_basename
index|[
literal|0
index|]
argument_list|,
literal|"frame_"
argument_list|)
expr_stmt|;
name|l_par
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"plug_in_gap_decode_mpeg"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l_par
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|nparams
operator|>
name|l_par
condition|)
block|{
if|if
condition|(
name|param
index|[
name|l_par
operator|+
literal|0
index|]
operator|.
name|data
operator|.
name|d_string
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|l_filename
argument_list|,
name|param
index|[
name|l_par
operator|+
literal|0
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
sizeof|sizeof
argument_list|(
name|l_filename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l_filename
index|[
sizeof|sizeof
argument_list|(
name|l_filename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|l_rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_NONINTERACTIVE
condition|)
block|{
name|l_filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nparams
operator|!=
operator|(
name|l_par
operator|+
literal|6
operator|)
condition|)
block|{
name|l_rc
operator|=
literal|1
expr_stmt|;
comment|/* calling error */
block|}
else|else
block|{
name|first_frame
operator|=
name|param
index|[
name|l_par
operator|+
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|last_frame
operator|=
name|param
index|[
name|l_par
operator|+
literal|3
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|param
index|[
name|l_par
operator|+
literal|4
index|]
operator|.
name|data
operator|.
name|d_string
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|l_frames_basename
argument_list|,
name|param
index|[
name|l_par
operator|+
literal|4
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
block|}
name|autoload
operator|=
name|param
index|[
name|l_par
operator|+
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_rc
operator|=
name|load_range_dialog
argument_list|(
operator|&
name|first_frame
argument_list|,
operator|&
name|last_frame
argument_list|,
operator|&
name|l_filename
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_filename
argument_list|)
argument_list|,
operator|&
name|l_frames_basename
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|l_frames_basename
argument_list|)
argument_list|,
operator|&
name|autoload
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|last_frame
operator|>
literal|0
operator|)
operator|&&
operator|(
name|last_frame
operator|<
name|first_frame
operator|)
condition|)
block|{
comment|/* swap, because load_image works only from lower to higher frame number */
name|image_ID
operator|=
name|load_image
argument_list|(
operator|&
name|l_filename
index|[
literal|0
index|]
argument_list|,
name|last_frame
argument_list|,
name|first_frame
argument_list|,
operator|&
name|l_frames_basename
index|[
literal|0
index|]
argument_list|,
name|autoload
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
operator|&
name|l_filename
index|[
literal|0
index|]
argument_list|,
name|first_frame
argument_list|,
name|last_frame
argument_list|,
operator|&
name|l_frames_basename
index|[
literal|0
index|]
argument_list|,
name|autoload
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_SUCCESS
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|GIMP_PDB_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|GIMP_PDB_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end run */
end_comment

begin_function
DECL|function|p_does_exist (char * fname)
name|int
name|p_does_exist
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|stat
name|l_stat_buf
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|l_stat_buf
argument_list|)
condition|)
block|{
comment|/* stat error (file does not exist) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_does_exist */
end_comment

begin_function
specifier|static
name|gint
DECL|function|p_overwrite_dialog (char * filename,gint overwrite_mode)
name|p_overwrite_dialog
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint
name|overwrite_mode
parameter_list|)
block|{
specifier|static
name|t_but_arg
name|l_argv
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|t_arr_arg
name|argv
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|p_does_exist
argument_list|(
name|filename
argument_list|)
condition|)
block|{
if|if
condition|(
name|overwrite_mode
operator|<
literal|1
condition|)
block|{
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Overwrite Frame"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Overwrite All"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|1
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|filename
expr_stmt|;
return|return
operator|(
name|p_array_std_dialog
argument_list|(
name|_
argument_list|(
literal|"GAP Question"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"File already exists"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
name|l_argv
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|overwrite_mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|MPEG_frame_period_ms (gint mpeg_rate_code,char * basename)
name|MPEG_frame_period_ms
parameter_list|(
name|gint
name|mpeg_rate_code
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|)
block|{
name|gint
name|l_rc
decl_stmt|;
name|gdouble
name|l_framerate
decl_stmt|;
name|t_video_info
modifier|*
name|vin_ptr
decl_stmt|;
name|vin_ptr
operator|=
name|p_get_video_info
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_framerate
operator|=
literal|24.0
expr_stmt|;
switch|switch
condition|(
name|mpeg_rate_code
condition|)
block|{
case|case
literal|1
case|:
name|l_rc
operator|=
literal|44
expr_stmt|;
name|l_framerate
operator|=
literal|23.976
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|l_rc
operator|=
literal|42
expr_stmt|;
name|l_framerate
operator|=
literal|24.0
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|l_rc
operator|=
literal|40
expr_stmt|;
name|l_framerate
operator|=
literal|25.0
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|l_rc
operator|=
literal|33
expr_stmt|;
name|l_framerate
operator|=
literal|29.97
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|l_rc
operator|=
literal|33
expr_stmt|;
name|l_framerate
operator|=
literal|30.0
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|l_rc
operator|=
literal|20
expr_stmt|;
name|l_framerate
operator|=
literal|50.0
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|l_rc
operator|=
literal|17
expr_stmt|;
name|l_framerate
operator|=
literal|59.94
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|l_rc
operator|=
literal|17
expr_stmt|;
name|l_framerate
operator|=
literal|60.0
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* ? */
default|default:
name|printf
argument_list|(
literal|"mpeg: warning - this MPEG has undefined timing.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vin_ptr
condition|)
block|{
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
name|vin_ptr
operator|->
name|framerate
operator|=
name|l_framerate
expr_stmt|;
name|p_set_video_info
argument_list|(
name|vin_ptr
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|vin_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
DECL|function|p_build_gap_framename (gint32 frame_nr,char * basename,char * ext)
name|p_build_gap_framename
parameter_list|(
name|gint32
name|frame_nr
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|char
modifier|*
name|framename
decl_stmt|;
name|framename
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%04d.%s"
argument_list|,
name|basename
argument_list|,
operator|(
name|int
operator|)
name|frame_nr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
name|framename
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (char * filename,gint32 first_frame,gint32 last_frame,char * basename,gint32 autoload)
name|load_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|first_frame
parameter_list|,
name|gint32
name|last_frame
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|gint32
name|autoload
parameter_list|)
block|{
name|GimpPixelRgn
name|pixel_rgn
decl_stmt|;
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
name|first_image_ID
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gint32
name|layer_ID
decl_stmt|;
name|gchar
modifier|*
name|temp
decl_stmt|;
name|Boolean
name|moreframes
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|framenumber
decl_stmt|,
name|delay
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|guchar
modifier|*
name|data
decl_stmt|;
name|gint
name|wwidth
decl_stmt|,
name|wheight
decl_stmt|;
name|gint
name|l_visible
decl_stmt|;
name|gint
name|l_overwrite_mode
decl_stmt|;
comment|/* mpeg structure */
name|ImageDesc
name|img
decl_stmt|;
name|gchar
modifier|*
name|layername
init|=
name|NULL
decl_stmt|;
name|gchar
modifier|*
name|framename
init|=
name|NULL
decl_stmt|;
name|first_image_ID
operator|=
operator|-
literal|1
expr_stmt|;
name|l_overwrite_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|p_does_exist
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error: file %s not found\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|framename
operator|=
name|p_build_gap_framename
argument_list|(
name|first_frame
argument_list|,
name|basename
argument_list|,
literal|"xcf"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|g_malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|gimp_quit
argument_list|()
expr_stmt|;
name|g_free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Decoding MPEG Movie..."
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mpeg: fopen failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|SetMPEGOption
argument_list|(
name|MPEG_DITHER
argument_list|,
name|FULL_COLOR_DITHER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OpenMPEG
argument_list|(
name|fp
argument_list|,
operator|&
name|img
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mpeg: OpenMPEG failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|g_malloc
argument_list|(
name|img
operator|.
name|Size
argument_list|)
expr_stmt|;
name|delay
operator|=
name|MPEG_frame_period_ms
argument_list|(
name|img
operator|.
name|PictureRate
argument_list|,
name|basename
argument_list|)
expr_stmt|;
comment|/*   printf("<%d : %d>  %dx%d - d%d - bmp%d - ps%d - s%d\n", 	 img.PictureRate, delay, 	 img.Width,img.Height,img.Depth,img.BitmapPad,img.PixelSize,img.Size); 	 */
if|if
condition|(
name|img
operator|.
name|PixelSize
operator|!=
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"mpeg: Hmm, sorry, funny PixelSize (%d) in MPEG.  Aborting.\n"
argument_list|,
name|img
operator|.
name|PixelSize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|img
operator|.
name|BitmapPad
operator|!=
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"mpeg: Hmm, sorry, funny BitmapPad (%d) in MPEG.  Aborting.\n"
argument_list|,
name|img
operator|.
name|BitmapPad
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|wwidth
operator|=
name|img
operator|.
name|Width
expr_stmt|;
name|wheight
operator|=
name|img
operator|.
name|Height
expr_stmt|;
name|l_visible
operator|=
name|TRUE
expr_stmt|;
comment|/* loaded layer should be visible */
name|moreframes
operator|=
name|TRUE
expr_stmt|;
name|framenumber
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|moreframes
condition|)
block|{
name|g_free
argument_list|(
name|framename
argument_list|)
expr_stmt|;
name|framename
operator|=
name|p_build_gap_framename
argument_list|(
name|framenumber
argument_list|,
name|basename
argument_list|,
literal|"xcf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_frame
operator|>
literal|0
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|gdouble
operator|)
name|framenumber
operator|/
operator|(
name|gdouble
operator|)
name|last_frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* toggle progressbar, because we dont know how much frames to handle         * until its all done         */
name|gimp_progress_update
argument_list|(
operator|(
name|framenumber
operator|&
literal|1
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
block|}
comment|/* libmpeg - at least the version I have (1.2) - is faulty        in its reporting of whether there are remaining frames...        the sample MPEG it comes with is the only one that it seems        able to detect the end of, and even then it doesn't notice        until it's too late, so we may lose the last frame, or        crash... sigh.         A patch to mpeg_lib 1.2.x is included in the header of this        plugin.         */
name|moreframes
operator|=
name|GetMPEGFrame
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|moreframes
condition|)
break|break;
comment|/* stop if desired range is loaded       * (negative last_frame ==> load until last frame)      */
if|if
condition|(
operator|(
name|framenumber
operator|>
name|last_frame
operator|)
operator|&&
operator|(
name|last_frame
operator|>
literal|0
operator|)
condition|)
break|break;
comment|/* ignore frames before first_frame */
if|if
condition|(
name|framenumber
operator|>=
name|first_frame
condition|)
block|{
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|wwidth
argument_list|,
name|wheight
argument_list|,
name|RGB
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|framename
argument_list|)
expr_stmt|;
if|if
condition|(
name|framenumber
operator|==
name|first_frame
condition|)
block|{
name|first_image_ID
operator|=
name|image_ID
expr_stmt|;
block|}
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|layername
operator|=
name|g_strdup_printf
argument_list|(
literal|"Frame %d (%dms)"
argument_list|,
name|framenumber
argument_list|,
name|delay
argument_list|)
expr_stmt|;
else|else
name|layername
operator|=
name|g_strdup_printf
argument_list|(
literal|"Frame %d"
argument_list|,
name|framenumber
argument_list|)
expr_stmt|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|layername
argument_list|,
name|wwidth
argument_list|,
name|wheight
argument_list|,
name|GIMP_RGBA_IMAGE
argument_list|,
literal|100
argument_list|,
name|GIMP_NORMAL_MODE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layername
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_set_visible
argument_list|(
name|layer_ID
argument_list|,
name|l_visible
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
comment|/* conveniently for us, mpeg_lib returns pixels padded           to 32-bit boundaries (is that true for all archs?).  So we           only have to fill in the alpha channel. */
for|for
control|(
name|i
operator|=
operator|(
name|wwidth
operator|*
name|wheight
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|#
directive|if
name|G_BYTE_ORDER
operator|==
name|G_BIG_ENDIAN
name|unsigned
name|char
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|r
operator|=
name|data
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
expr_stmt|;
name|g
operator|=
name|data
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
expr_stmt|;
name|b
operator|=
name|data
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|g
expr_stmt|;
name|data
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|r
expr_stmt|;
endif|#
directive|endif
name|data
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|wwidth
argument_list|,
name|wheight
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* save each image as frame to disk */
block|{
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|l_overwrite_mode
operator|=
name|p_overwrite_dialog
argument_list|(
name|framename
argument_list|,
name|l_overwrite_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_overwrite_mode
operator|<
literal|0
condition|)
block|{
comment|/* fake no more frames if CANCEL was pressed in the Overwrite dialog */
name|moreframes
operator|=
name|FALSE
expr_stmt|;
name|autoload
operator|=
name|FALSE
expr_stmt|;
comment|/* drop image and do not open on CANCEL */
block|}
else|else
block|{
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_xcf_save"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|GIMP_PDB_DRAWABLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|framename
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|framename
argument_list|,
comment|/* raw name ? */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|p_gimp_file_save_thumbnail
argument_list|(
name|image_ID
argument_list|,
name|framename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|first_image_ID
operator|!=
name|image_ID
operator|)
operator|||
operator|(
operator|!
name|autoload
operator|)
condition|)
block|{
name|gimp_image_delete
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
block|}
block|}
name|framenumber
operator|++
expr_stmt|;
block|}
name|CloseMPEG
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoload
condition|)
block|{
name|gimp_display_new
argument_list|(
name|first_image_ID
argument_list|)
expr_stmt|;
return|return
name|first_image_ID
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_range_dialog (gint32 * first_frame,gint32 * last_frame,char * filename,gint32 len_filename,char * basename,gint32 len_basename,gint32 * autoload)
name|load_range_dialog
parameter_list|(
name|gint32
modifier|*
name|first_frame
parameter_list|,
name|gint32
modifier|*
name|last_frame
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|len_filename
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|gint32
name|len_basename
parameter_list|,
name|gint32
modifier|*
name|autoload
parameter_list|)
block|{
DECL|macro|ARGC_DIALOG
define|#
directive|define
name|ARGC_DIALOG
value|6
specifier|static
name|t_arr_arg
name|argv
index|[
name|ARGC_DIALOG
index|]
decl_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Video"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Name of the MPEG1 videofile to READ.\n"
literal|"Frames are extracted from the videofile\n"
literal|"and written to seperate diskfiles.\n"
literal|"Audiotracks in the videofile are ignored."
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|text_buf_len
operator|=
name|len_filename
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|text_buf_ret
operator|=
name|filename
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|entry_width
operator|=
literal|250
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Framenumber of 1st frame to extract"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
literal|9999
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|umin
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|entry_width
operator|=
literal|80
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Framenumber of last frame to extract"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
literal|9999
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|9999
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|umin
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|entry_width
operator|=
literal|80
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Framenames:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Basename for the AnimFrames to write on disk\n"
literal|"(framenumber and .xcf is added)"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|text_buf_len
operator|=
name|len_basename
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|text_buf_ret
operator|=
name|basename
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|entry_width
operator|=
literal|250
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|4
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"Open"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Open the 1st one of the extracted frames"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_LABEL_LEFT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"\nWARNING: Do not attempt to split other files than MPEG1 videos.\n"
literal|"Before you proceed, you should save all open images."
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|_
argument_list|(
literal|"Split MPEG1 Video to Frames"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Select Frame Range"
argument_list|)
argument_list|,
name|ARGC_DIALOG
argument_list|,
name|argv
argument_list|)
condition|)
block|{
operator|*
name|first_frame
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|last_frame
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|autoload
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|4
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* OK */
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
comment|/* Cancel */
block|}
block|}
end_function

end_unit

