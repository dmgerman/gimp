begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_mpege.c  * 1998.07.04 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * This Module contains:  * - gap_mpeg_encode  *        GIMP/GAP-frontend interfaces for 2 MPEG encoder Programs  *  *        1) mpeg_encode 1.5   *             the free Berkeley MPEG-1 encoder  *        2) mpeg2encode   *             MPEG-2 and MPEG-1 Encoder / Decoder, Version 1.2  *             (MPEG Software Simulation Group)  *                 Web:      http://www.mpeg.org/MSSG/  *                 FTP:      ftp://ftp.mpeg.org/pub/mpeg/mssg/  *                 E-mail:   mssg@mpeg.org  (author contact)  *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history  * 0.99.00; 1999/03/15   hof: prepared for win/dos filename conventions  * 0.96.00; 1998/07/08   hof: first release  */
end_comment

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_mpege.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_define
DECL|macro|MBUF_SIZE
define|#
directive|define
name|MBUF_SIZE
value|128
end_define

begin_typedef
DECL|struct|t_mpg_par
typedef|typedef
struct|struct
name|t_mpg_par
block|{
DECL|member|from
name|gint
name|from
decl_stmt|;
DECL|member|to
name|gint
name|to
decl_stmt|;
DECL|member|bitrate
name|gint
name|bitrate
decl_stmt|;
DECL|member|outfile
name|char
modifier|*
name|outfile
decl_stmt|;
DECL|member|parfile
name|char
modifier|*
name|parfile
decl_stmt|;
DECL|member|startscript
name|char
modifier|*
name|startscript
decl_stmt|;
DECL|member|ext
name|char
modifier|*
name|ext
decl_stmt|;
comment|/* members used in mpeg_encode only: */
DECL|member|const_bitrate
name|gint
name|const_bitrate
decl_stmt|;
DECL|member|iqscale
name|gint
name|iqscale
decl_stmt|;
DECL|member|pqscale
name|gint
name|pqscale
decl_stmt|;
DECL|member|bqscale
name|gint
name|bqscale
decl_stmt|;
DECL|member|pattern
name|char
modifier|*
name|pattern
decl_stmt|;
DECL|member|framerate
name|char
modifier|*
name|framerate
decl_stmt|;
DECL|member|psearch
name|char
modifier|*
name|psearch
decl_stmt|;
DECL|member|bsearch
name|char
modifier|*
name|bsearch
decl_stmt|;
comment|/* members used in mpeg2encode only: */
DECL|member|frate
name|gint
name|frate
decl_stmt|;
DECL|member|videoformat
name|gint
name|videoformat
decl_stmt|;
DECL|member|mpegtype
name|gint
name|mpegtype
decl_stmt|;
DECL|typedef|t_mpg_par
block|}
name|t_mpg_par
typedef|;
end_typedef

begin_comment
comment|/* ============================================================================  * p_mpege_info  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_mpege_info (t_anim_info * ainfo_ptr,char * errlist,t_gap_mpeg_encoder encoder)
name|int
name|p_mpege_info
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|char
modifier|*
name|errlist
parameter_list|,
name|t_gap_mpeg_encoder
name|encoder
parameter_list|)
block|{
name|t_arr_arg
name|argv
index|[
literal|13
index|]
decl_stmt|;
name|t_but_arg
name|b_argv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_idx
operator|=
literal|0
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"Conditions to run mpeg_encode 1.5:"
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"Conditions to run mpeg2encode 1.2:"
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|""
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"1.) mpeg_encode 1.5 must be installed"
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"1.) mpeg2encode 1.2 must be installed"
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    you can get mpeg_encode at"
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    you can get mpeg2encode at http://www.mpeg.org/MSSG"
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    ftp://mm-ftp.cs.berkeley.edu/pub/multimedia/mpeg/bmt1r1.tar.gz"
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"   or at ftp://ftp.mpeg.org/pub/mpeg/mssg "
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"2.) You need a series of single Images on disk (AnimFrames)"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    all with fileformat JPEG (or YUV or PNM or PPM)"
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"   all with fileformat PPM (or YUV)"
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    (use 'Frames Convert' from the AnimFrames Menu"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    or 'Split Img to Frames' from the AnimFrames Menu)"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"3.) All Images must have the same size,"
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG_ENCODE
condition|)
block|{
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    width and height must be a multiple of 16"
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"    (use Scale or Crop from the AnimFrames Menu)"
expr_stmt|;
block|}
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
name|errlist
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
comment|/* the  Action Button */
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
literal|"CANCEL"
expr_stmt|;
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
literal|"OK"
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_rc
operator|=
name|p_array_std_dialog
argument_list|(
literal|"MPEG_ENCODE Information"
argument_list|,
literal|""
argument_list|,
name|l_idx
argument_list|,
name|argv
argument_list|,
comment|/* widget array */
literal|2
argument_list|,
name|b_argv
argument_list|,
comment|/* button array */
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_mpege_info */
end_comment

begin_comment
comment|/* ============================================================================  * p_mpege_dialog  *   retcode    -1   ... on cancel  *               0   ... Generate Paramfile  *               1   ... Generate Paramfile and start mpeg_encode  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_mpege_dialog (t_anim_info * ainfo_ptr,t_mpg_par * mp_ptr,t_gap_mpeg_encoder encoder)
name|int
name|p_mpege_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|t_mpg_par
modifier|*
name|mp_ptr
parameter_list|,
name|t_gap_mpeg_encoder
name|encoder
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|15
index|]
decl_stmt|;
specifier|static
name|t_but_arg
name|b_argv
index|[
literal|3
index|]
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
specifier|static
name|char
name|l_buf
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
specifier|static
name|char
name|l_startscript
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
specifier|static
name|char
name|l_parfile
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
specifier|static
name|char
name|l_outfile
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
specifier|static
name|char
name|l_pattern
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|frate_args
index|[
literal|8
index|]
init|=
block|{
literal|"23.976"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"29.97"
block|,
literal|"30"
block|,
literal|"50"
block|,
literal|"59.94"
block|,
literal|"60"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|psearch_args
index|[
literal|3
index|]
init|=
block|{
literal|"EXHAUSTIVE"
block|,
literal|"SUBSAMPLE"
block|,
literal|"LOGARITHMIC"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bsearch_args
index|[
literal|3
index|]
init|=
block|{
literal|"SIMPLE"
block|,
literal|"CROSS2"
block|,
literal|"EXHAUSTIVE"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|video_args
index|[
literal|5
index|]
init|=
block|{
literal|"Comp"
block|,
literal|"PAL"
block|,
literal|"NTSC"
block|,
literal|"SECAM"
block|,
literal|"MAC"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|mpeg_args
index|[
literal|2
index|]
init|=
block|{
literal|"MPEG1"
block|,
literal|"MPEG2"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|mpeg_help
index|[
literal|2
index|]
init|=
block|{
literal|"generate MPEG1 (ISO/IEC 11172-2) stream"
block|,
literal|"generate MPEG2 (ISO/IEC DIS 13818-2) stream"
block|}
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* the 3 Action Buttons */
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
literal|"Cancel"
expr_stmt|;
name|b_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
literal|"GenParams"
expr_stmt|;
name|b_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|b_argv
index|[
literal|2
index|]
operator|.
name|but_txt
operator|=
literal|"Gen + Encode"
expr_stmt|;
name|b_argv
index|[
literal|2
index|]
operator|.
name|but_val
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|l_outfile
argument_list|,
literal|"%s.mpg"
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_parfile
argument_list|,
literal|"%s.par_mpg"
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|l_startscript
argument_list|,
literal|"%s.sh"
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_LABEL
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
operator|&
name|l_buf
index|[
literal|0
index|]
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
literal|"From Frame:"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
literal|"first handled frame"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
literal|"To   Frame:"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
literal|"last handled frame"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|3
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|label_txt
operator|=
literal|"Framerate :"
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|help_txt
operator|=
literal|"framerate in frames/second"
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_argc
operator|=
literal|8
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_argv
operator|=
name|frate_args
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_ret
operator|=
literal|4
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|4
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|label_txt
operator|=
literal|"Bitrate:"
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|help_txt
operator|=
literal|"used for constant bitrates (bit/sec)                  \n(low rate gives good compression + bad quality)"
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|int_min
operator|=
literal|500000
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|int_step
operator|=
literal|100000
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|int_max
operator|=
literal|9000000
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|.
name|int_ret
operator|=
literal|3000000
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG_ENCODE
condition|)
name|l_idx
operator|=
literal|12
expr_stmt|;
else|else
name|l_idx
operator|=
literal|7
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"Outputfile:"
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
name|l_idx
index|]
operator|.
name|help_txt
operator|=
literal|"Name of the resulting MPEG outputfile"
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|text_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|l_outfile
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|text_buf_ret
operator|=
operator|&
name|l_outfile
index|[
literal|0
index|]
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"Paramfile:"
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
name|l_idx
index|]
operator|.
name|help_txt
operator|=
literal|"Name of the Encoder-Parameterfile\n(is generated)"
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|text_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|l_parfile
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|text_buf_ret
operator|=
operator|&
name|l_parfile
index|[
literal|0
index|]
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
name|l_idx
index|]
argument_list|,
name|WGT_FILESEL
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|label_txt
operator|=
literal|"Startscript:"
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
name|l_idx
index|]
operator|.
name|help_txt
operator|=
literal|"Name of the Startscript           \n(is generated/executed)"
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|text_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|l_startscript
argument_list|)
expr_stmt|;
name|argv
index|[
name|l_idx
index|]
operator|.
name|text_buf_ret
operator|=
operator|&
name|l_startscript
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|encoder
operator|==
name|MPEG_ENCODE
condition|)
block|{
name|sprintf
argument_list|(
name|l_buf
argument_list|,
literal|"Generate parameterfile for mpeg_encode 1.5\n(the freely distributed Berkeley MPEG-1 Video  Encoder.)\n"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_TOGGLE
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
literal|"Constant Bitrate :"
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|help_txt
operator|=
literal|"Iqnore I/P/QSCALE values and use constant bit-rate)"
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|l_pattern
argument_list|,
literal|"IBBPBBPBBPBBPBBP"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|6
index|]
argument_list|,
name|WGT_TEXT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|label_txt
operator|=
literal|"Pattern:"
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|entry_width
operator|=
literal|140
expr_stmt|;
comment|/* pixel */
name|argv
index|[
literal|6
index|]
operator|.
name|help_txt
operator|=
literal|"How to encode MPEG framesequence (I/P/B frames)"
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|text_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|l_pattern
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|text_buf_ret
operator|=
operator|&
name|l_pattern
index|[
literal|0
index|]
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|7
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|label_txt
operator|=
literal|"IQSCALE:"
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|help_txt
operator|=
literal|"Quality scale for I-Frames                       \n(1 = best quality, 31 = best comression)"
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_max
operator|=
literal|31
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
operator|=
literal|2
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|8
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|label_txt
operator|=
literal|"PQSCALE:"
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|help_txt
operator|=
literal|"Quality scale for P-Frames                  \n(1 = best quality, 31 = best comression)"
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|int_max
operator|=
literal|31
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|.
name|int_ret
operator|=
literal|5
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|9
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|label_txt
operator|=
literal|"BQSCALE:"
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|help_txt
operator|=
literal|"Quality scale for B-Frames                  \n(1 = best quality, 31 = best comression)"
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|int_min
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|int_max
operator|=
literal|31
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|.
name|int_ret
operator|=
literal|9
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|10
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|label_txt
operator|=
literal|"P-Search :"
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|help_txt
operator|=
literal|"Search Algorithmus used for P-frames"
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|radio_argc
operator|=
literal|3
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|radio_argv
operator|=
name|psearch_args
expr_stmt|;
name|argv
index|[
literal|10
index|]
operator|.
name|radio_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|11
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|11
index|]
operator|.
name|label_txt
operator|=
literal|"B-Search :"
expr_stmt|;
name|argv
index|[
literal|11
index|]
operator|.
name|help_txt
operator|=
literal|"Search Algorithmus used for B-frames"
expr_stmt|;
name|argv
index|[
literal|11
index|]
operator|.
name|radio_argc
operator|=
literal|3
expr_stmt|;
name|argv
index|[
literal|11
index|]
operator|.
name|radio_argv
operator|=
name|bsearch_args
expr_stmt|;
name|argv
index|[
literal|11
index|]
operator|.
name|radio_ret
operator|=
literal|1
expr_stmt|;
name|l_rc
operator|=
name|p_array_std_dialog
argument_list|(
literal|"Gen MPEG_ENCODE Parameters"
argument_list|,
literal|"Encode Values"
argument_list|,
literal|15
argument_list|,
name|argv
argument_list|,
comment|/* widget array */
literal|3
argument_list|,
name|b_argv
argument_list|,
comment|/* button array */
literal|0
argument_list|)
expr_stmt|;
name|mp_ptr
operator|->
name|const_bitrate
operator|=
name|argv
index|[
literal|5
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|iqscale
operator|=
name|argv
index|[
literal|7
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|pqscale
operator|=
name|argv
index|[
literal|8
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|bqscale
operator|=
name|argv
index|[
literal|9
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|psearch
operator|=
name|psearch_args
index|[
name|argv
index|[
literal|10
index|]
operator|.
name|radio_ret
index|]
expr_stmt|;
name|mp_ptr
operator|->
name|bsearch
operator|=
name|bsearch_args
index|[
name|argv
index|[
literal|11
index|]
operator|.
name|radio_ret
index|]
expr_stmt|;
block|}
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
name|sprintf
argument_list|(
name|l_buf
argument_list|,
literal|"Generate parameterfile for mpeg2encode 1.2\n(MPEG-2 Video  Encoder.)\n"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|5
index|]
argument_list|,
name|WGT_RADIO
argument_list|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|label_txt
operator|=
literal|"MPEG-type :"
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_argc
operator|=
literal|2
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_argv
operator|=
name|mpeg_args
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_help_argv
operator|=
name|mpeg_help
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|.
name|radio_ret
operator|=
literal|1
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|6
index|]
argument_list|,
name|WGT_OPTIONMENU
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|label_txt
operator|=
literal|"Videoformat :"
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|help_txt
operator|=
literal|"Videoformat"
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_argc
operator|=
literal|5
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_argv
operator|=
name|video_args
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|.
name|radio_ret
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|.
name|radio_argc
operator|=
literal|5
expr_stmt|;
comment|/* framerates above 30 ar not allowed in mpeg2encode */
name|l_rc
operator|=
name|p_array_std_dialog
argument_list|(
literal|"Gen MPEG2ENCODE Parameters"
argument_list|,
literal|"Encode Values"
argument_list|,
literal|10
argument_list|,
name|argv
argument_list|,
comment|/* widget array */
literal|3
argument_list|,
name|b_argv
argument_list|,
comment|/* button array */
literal|0
argument_list|)
expr_stmt|;
name|mp_ptr
operator|->
name|mpegtype
operator|=
name|argv
index|[
literal|5
index|]
operator|.
name|radio_ret
expr_stmt|;
name|mp_ptr
operator|->
name|videoformat
operator|=
name|argv
index|[
literal|6
index|]
operator|.
name|radio_ret
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|<=
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
condition|)
block|{
name|mp_ptr
operator|->
name|from
operator|=
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|to
operator|=
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
expr_stmt|;
block|}
else|else
block|{
name|mp_ptr
operator|->
name|from
operator|=
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|to
operator|=
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
expr_stmt|;
block|}
name|mp_ptr
operator|->
name|frate
operator|=
name|argv
index|[
literal|3
index|]
operator|.
name|radio_ret
operator|+
literal|1
expr_stmt|;
name|mp_ptr
operator|->
name|framerate
operator|=
name|frate_args
index|[
name|argv
index|[
literal|3
index|]
operator|.
name|radio_ret
index|]
expr_stmt|;
name|mp_ptr
operator|->
name|bitrate
operator|=
name|argv
index|[
literal|4
index|]
operator|.
name|int_ret
expr_stmt|;
name|mp_ptr
operator|->
name|pattern
operator|=
operator|&
name|l_pattern
index|[
literal|0
index|]
expr_stmt|;
name|mp_ptr
operator|->
name|outfile
operator|=
operator|&
name|l_outfile
index|[
literal|0
index|]
expr_stmt|;
name|mp_ptr
operator|->
name|parfile
operator|=
operator|&
name|l_parfile
index|[
literal|0
index|]
expr_stmt|;
name|mp_ptr
operator|->
name|startscript
operator|=
operator|&
name|l_startscript
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_mpege_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * p_mpege_extension_check  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_mpege_extension_check (t_anim_info * ainfo_ptr)
name|char
modifier|*
name|p_mpege_extension_check
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
comment|/* list of direct supported fileformats of mpeg_encode */
specifier|static
name|char
modifier|*
name|base_file_formats
index|[
literal|7
index|]
init|=
block|{
literal|"\0"
block|,
literal|"JPEG"
block|,
literal|"PNM"
block|,
literal|"PPM"
block|,
literal|"JMOVIE"
block|,
literal|"Y"
literal|"YUV"
block|}
decl_stmt|;
name|int
name|l_ffidx
decl_stmt|;
name|l_ffidx
operator|=
literal|0
expr_stmt|;
comment|/* undefined */
if|if
condition|(
name|ainfo_ptr
operator|->
name|extension
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".jpg"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".jpeg"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".JPG"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".JPEG"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".pnm"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".PNM"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".ppm"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".PPM"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".yuv"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".YUV"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|6
expr_stmt|;
block|}
return|return
operator|(
name|base_file_formats
index|[
name|l_ffidx
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_mpege_extension_check */
end_comment

begin_function
specifier|static
DECL|function|p_mpeg2_extension_check (t_anim_info * ainfo_ptr)
name|int
name|p_mpeg2_extension_check
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
name|int
name|l_ffidx
decl_stmt|;
name|l_ffidx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* format not supported */
if|if
condition|(
name|ainfo_ptr
operator|->
name|extension
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".ppm"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".PPM"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".yuv"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".YUV"
argument_list|)
operator|==
literal|0
condition|)
name|l_ffidx
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|l_ffidx
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_mpege_extension_check */
end_comment

begin_comment
comment|/* ============================================================================  * p_mpeg2encode_gen_parfile  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_mpeg2encode_gen_parfile (t_anim_info * ainfo_ptr,t_mpg_par * mp_ptr)
name|int
name|p_mpeg2encode_gen_parfile
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|t_mpg_par
modifier|*
name|mp_ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|int
name|l_base_ffidx
decl_stmt|;
name|gint
name|l_width
decl_stmt|;
name|gint
name|l_height
decl_stmt|;
name|char
modifier|*
name|l_dirname_ptr
decl_stmt|;
name|char
modifier|*
name|l_basename_ptr
decl_stmt|;
name|char
name|l_basename_buff
index|[
literal|1024
index|]
decl_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|mp_ptr
operator|->
name|parfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cant open MPEG Paramfile %s for write\n"
argument_list|,
name|mp_ptr
operator|->
name|parfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_base_ffidx
operator|=
name|p_mpeg2_extension_check
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
comment|/* check if ainfo_ptr->basename contains directory part */
name|strcpy
argument_list|(
name|l_basename_buff
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|l_dirname_ptr
operator|=
literal|"."
expr_stmt|;
name|l_basename_ptr
operator|=
operator|&
name|l_basename_buff
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
name|strlen
argument_list|(
name|l_basename_buff
argument_list|)
operator|-
literal|1
init|;
name|l_idx
operator|>=
literal|0
condition|;
name|l_idx
operator|--
control|)
block|{
if|if
condition|(
name|l_basename_buff
index|[
name|l_idx
index|]
operator|==
name|G_DIR_SEPARATOR
condition|)
block|{
name|l_basename_buff
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
name|l_basename_ptr
operator|=
operator|&
name|l_basename_buff
index|[
name|l_idx
operator|+
literal|1
index|]
expr_stmt|;
name|l_dirname_ptr
operator|=
operator|&
name|l_basename_buff
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
comment|/* get info about the image (size is common to all frames) */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp_ptr
operator|->
name|mpegtype
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"MPEG-1 stream %s frames/sec\n"
argument_list|,
name|mp_ptr
operator|->
name|framerate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"MPEG-2 stream %s frames/sec\n"
argument_list|,
name|mp_ptr
operator|->
name|framerate
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%s_%%04d   /* name of source files */\n"
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"-         /* name of reconstructed images (\"-\": don't store) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"-         /* name of intra quant matrix file     (\"-\": default matrix) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"-         /* name of non intra quant matrix file (\"-\": default matrix) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"-         /* name of statistics file (\"-\": stdout ) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d         /* input picture file format: 0=*.Y,*.U,*.V, 1=*.yuv, 2=*.ppm */\n"
argument_list|,
name|l_base_ffidx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d       /* number of frames */\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mp_ptr
operator|->
name|to
operator|-
name|mp_ptr
operator|->
name|from
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d         /* number of first frame */\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|from
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"00:00:00:00 /* timecode of first frame */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"12        /* N (# of frames in GOP) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"3         /* M (I/P frame distance) */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp_ptr
operator|->
name|mpegtype
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1         /* ISO/IEC 11172-2 stream */\n"
argument_list|)
expr_stmt|;
comment|/* MPEG1 */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* ISO/IEC 11172-2 stream */\n"
argument_list|)
expr_stmt|;
comment|/* MPEG2 */
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* 0:frame pictures, 1:field pictures */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d       /* horizontal_size */\n"
argument_list|,
operator|(
name|int
operator|)
name|l_width
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d       /* vertical_size */\n"
argument_list|,
operator|(
name|int
operator|)
name|l_height
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"2         /* aspect_ratio_information 1=square pel, 2=4:3, 3=16:9, 4=2.11:1 */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d         /* frame_rate_code 1=23.976, 2=24, 3=25, 4=29.97, 5=30 frames/sec. */\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|frate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d.0 /* bit_rate (bits/s) */\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|bitrate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"112       /* vbv_buffer_size (in multiples of 16 kbit) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* low_delay  */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* constrained_parameters_flag */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"4         /* Profile ID: Simple = 5, Main = 4, SNR = 3, Spatial = 2, High = 1 */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"8         /* Level ID:   Low = 10, Main = 8, High 1440 = 6, High = 4          */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* progressive_sequence */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1         /* chroma_format: 1=4:2:0, 2=4:2:2, 3=4:4:4 */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d         /* video_format: 0=comp., 1=PAL, 2=NTSC, 3=SECAM, 4=MAC, 5=unspec. */\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|videoformat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"5         /* color_primaries */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"5         /* transfer_characteristics */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"5         /* matrix_coefficients */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d       /* display_horizontal_size */\n"
argument_list|,
operator|(
name|int
operator|)
name|l_width
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d       /* display_vertical_size */\n"
argument_list|,
operator|(
name|int
operator|)
name|l_height
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* intra_dc_precision (0: 8 bit, 1: 9 bit, 2: 10 bit, 3: 11 bit */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1         /* top_field_first */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0 0 0     /* frame_pred_frame_dct (I P B) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0 0 0     /* concealment_motion_vectors (I P B) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1 1 1     /* q_scale_type  (I P B) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1 0 0     /* intra_vlc_format (I P B)*/\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0 0 0     /* alternate_scan (I P B) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* repeat_first_field */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* progressive_frame */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* P distance between complete intra slice refresh */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: r (reaction parameter) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: avg_act (initial average activity) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: Xi (initial I frame global complexity measure) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: Xp (initial P frame global complexity measure) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: Xb (initial B frame global complexity measure) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: d0i (initial I frame virtual buffer fullness) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: d0p (initial P frame virtual buffer fullness) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"0         /* rate control: d0b (initial B frame virtual buffer fullness) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"2 2 11 11 /* P:  forw_hor_f_code forw_vert_f_code search_width/height */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1 1 3  3  /* B1: forw_hor_f_code forw_vert_f_code search_width/height */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1 1 7  7  /* B1: back_hor_f_code back_vert_f_code search_width/height */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1 1 7  7  /* B2: forw_hor_f_code forw_vert_f_code search_width/height */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"1 1 3  3  /* B2: back_hor_f_code back_vert_f_code search_width/height */\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
comment|/* generate a startscript */
name|l_fp
operator|=
name|fopen
argument_list|(
name|mp_ptr
operator|->
name|startscript
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cant open Startscript %s for write\n"
argument_list|,
name|mp_ptr
operator|->
name|startscript
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#!/bin/sh\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"mpeg2encode %s %s\n"
argument_list|,
name|mp_ptr
operator|->
name|parfile
argument_list|,
name|mp_ptr
operator|->
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"echo 'mpeg2encode done.'\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"read DUMMY\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_mpeg_encode_gen_parfile  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_mpeg_encode_gen_parfile (t_anim_info * ainfo_ptr,t_mpg_par * mp_ptr)
name|int
name|p_mpeg_encode_gen_parfile
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|t_mpg_par
modifier|*
name|mp_ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|gint
name|l_width
decl_stmt|;
name|gint
name|l_height
decl_stmt|;
name|char
modifier|*
name|l_dirname_ptr
decl_stmt|;
name|char
modifier|*
name|l_basename_ptr
decl_stmt|;
name|char
name|l_basename_buff
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|l_base_file_format
decl_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|mp_ptr
operator|->
name|parfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cant open MPEG Paramfile %s for write\n"
argument_list|,
name|mp_ptr
operator|->
name|parfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_base_file_format
operator|=
name|p_mpege_extension_check
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
comment|/* check if ainfo_ptr->basename contains directory part */
name|strcpy
argument_list|(
name|l_basename_buff
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|l_dirname_ptr
operator|=
literal|"."
expr_stmt|;
name|l_basename_ptr
operator|=
operator|&
name|l_basename_buff
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
name|strlen
argument_list|(
name|l_basename_buff
argument_list|)
operator|-
literal|1
init|;
name|l_idx
operator|>=
literal|0
condition|;
name|l_idx
operator|--
control|)
block|{
if|if
condition|(
name|l_basename_buff
index|[
name|l_idx
index|]
operator|==
name|G_DIR_SEPARATOR
condition|)
block|{
name|l_basename_buff
index|[
name|l_idx
index|]
operator|=
literal|'\0'
expr_stmt|;
name|l_basename_ptr
operator|=
operator|&
name|l_basename_buff
index|[
name|l_idx
operator|+
literal|1
index|]
expr_stmt|;
name|l_dirname_ptr
operator|=
operator|&
name|l_basename_buff
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
comment|/* get info about the image (size is common to all frames) */
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# MPEG_ENCODE Parameterfile (generated by GIMP Plugin gap_mpege)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# any line beginning with # is a comment\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# no line should be longer than 255 characters\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# general format of each line is:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#<option><spaces and/or tabs><value>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# lines can generally be in any order\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# an exception is the option 'INPUT' which must be followed by input\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# files in the order in which they must appear, followed by END_INPUT\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# Also, if you use the `command` method of generating input file names,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# the command will only be executed in the INPUT_DIR if INPUT_DIR preceeds\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# the INPUT parameter.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#<option> MUST be in UPPER CASE\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"PATTERN    %s\n"
argument_list|,
name|mp_ptr
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"OUTPUT     %s\n\n"
argument_list|,
name|mp_ptr
operator|->
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# mpeg_encode really only accepts 3 different file formats, but using a\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# conversion statement it can effectively handle ANY file format\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# You must specify the type of the input files.  The choices are:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#    YUV, PPM, JMOVIE, Y, JPEG, PNM\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#	(must be upper case)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l_base_file_format
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"BASE_FILE_FORMAT   PPM\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"BASE_FILE_FORMAT   %s\n\n"
argument_list|,
name|l_base_file_format
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# if YUV format (or using parallel version), must provide width and height\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# YUV_SIZE	widthxheight\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# this option is ignored if BASE_FILE_FORMAT is not YUV and you're running\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# on just one machine\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"YUV_SIZE   %dx%d\n\n"
argument_list|,
operator|(
name|int
operator|)
name|l_width
argument_list|,
operator|(
name|int
operator|)
name|l_height
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# If you are using YUV, there are different supported file formats.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# EYUV or UCB are the same as previous versions of this encoder.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# (All the Y's, then U's then V's, in 4:2:0 subsampling.)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# Other formats, such as Abekas, Phillips, or a general format are\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# permissible, the general format is a string of Y's, U's, and V's\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# to specify the file order.\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"INPUT_FORMAT UCB\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# the conversion statement\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# Each occurrence of '*' will be replaced by the input file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# e.g., if you have a bunch of GIF files, then this might be:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#	INPUT_CONVERT	giftoppm *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# e.g., if you have a bunch of files like a.Y a.U a.V, etc., then:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#	INPUT_CONVERT	cat *.Y *.U *.V\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# e.g., if you are grabbing from laser disc you might have something like\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#	INPUT_CONVERT	goto frame *; grabppm\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# 'INPUT_CONVERT *' means the files are already in the base file format\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|l_base_file_format
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"INPUT_CONVERT %stoppm *\n\n"
argument_list|,
name|mp_ptr
operator|->
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"INPUT_CONVERT *\n\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# number of frames in a GOP.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# since each GOP must have at least one I-frame, the encoder will find the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# the first I-frame after GOP_SIZE frames to start the next GOP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# later, will add more flexible GOP signalling\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"GOP_SIZE	%d\n"
argument_list|,
name|strlen
argument_list|(
name|mp_ptr
operator|->
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# number of slices in a frame\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# 1 is a good number.  another possibility is the number of macroblock rows\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# (which is the height divided by 16)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"SLICES_PER_FRAME	1\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# directory to get all input files from (makes this file easier to read)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"INPUT_DIR	%s\n"
argument_list|,
name|l_dirname_ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# There are a bunch of ways to specify the input files.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# from a simple one-per-line listing, to the following \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# way of numbering them.  See the manual for more information.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"INPUT\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# '*' is replaced by the numbers 01, 02, 03, 04\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# if I instead do [01-11], it would be 01, 02, ..., 09, 10, 11\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# if I instead do [1-11], it would be 1, 2, 3, ..., 9, 10, 11\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# if I instead do [1-11+3], it would be 1, 4, 7, 10\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# the program assumes none of your input files has a name ending in ']'\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# if you do, too bad!!!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%s_*.%s  [%04d-%04d]\n"
argument_list|,
name|l_basename_ptr
argument_list|,
name|mp_ptr
operator|->
name|ext
argument_list|,
name|mp_ptr
operator|->
name|from
argument_list|,
name|mp_ptr
operator|->
name|to
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# can have more files here if you want...there is no limit on the number\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# of files\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"END_INPUT\n\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# Many of the remaining options have to do with the motion search and qscale\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# FULL or HALF -- must be upper case\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"PIXEL		HALF\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# means +/- this many pixels for both P and B frame searches\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# specify two numbers if you wish to serc different ranges in the two.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"RANGE		10\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# this must be one of {EXHAUSTIVE, SUBSAMPLE, LOGARITHMIC}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"PSEARCH_ALG	%s\n\n"
argument_list|,
name|mp_ptr
operator|->
name|psearch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# this must be one of {SIMPLE, CROSS2, EXHAUSTIVE}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# note that EXHAUSTIVE is really, really, really slow\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"BSEARCH_ALG	%s\n\n"
argument_list|,
name|mp_ptr
operator|->
name|bsearch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# these specify the q-scale for I, P, and B frames\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# (values must be between 1 and 31)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# These are the Qscale values for the entire frame in variable bit-rate\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# mode, and starting points (but not important) for constant bit rate\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"IQSCALE		%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|iqscale
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"PQSCALE		%d\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|pqscale
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"BQSCALE		%d\n\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|bqscale
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# this must be ORIGINAL or DECODED\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"REFERENCE_FRAME	ORIGINAL\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# for parallel parameters see parallel.param in the exmaples subdirectory\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# if you want constant bit-rate mode, specify it as follows (number is bits/sec):\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp_ptr
operator|->
name|const_bitrate
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"BIT_RATE  %d\n\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|bitrate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#BIT_RATE  %d\n\n"
argument_list|,
operator|(
name|int
operator|)
name|mp_ptr
operator|->
name|bitrate
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# To specify the buffer size (327680 is default, measused in bits, for 16bit words)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"BUFFER_SIZE 3276800\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# The frame rate is the number of frames/second (legal values:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# 23.976, 24, 25, 29.97, 30, 50 ,59.94, 60\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"FRAME_RATE %s\n\n"
argument_list|,
name|mp_ptr
operator|->
name|framerate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# There are many more options, see the users manual for examples....\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# ASPECT_RATIO, USER_DATA, GAMMA, IQTABLE, etc.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
comment|/* generate a startscript */
name|l_fp
operator|=
name|fopen
argument_list|(
name|mp_ptr
operator|->
name|startscript
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cant open Startscript %s for write\n"
argument_list|,
name|mp_ptr
operator|->
name|startscript
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#!/bin/sh\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"mpeg_encode %s\n"
argument_list|,
name|mp_ptr
operator|->
name|parfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"echo 'mpeg_encode done.'\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"read DUMMY\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end p_mpege_gen_parfile */
end_comment

begin_comment
comment|/* ============================================================================  * p_mpege_gen_parfile  * ============================================================================  */
end_comment

begin_function
specifier|static
DECL|function|p_mpege_gen_parfile (t_anim_info * ainfo_ptr,t_mpg_par * mp_ptr,t_gap_mpeg_encoder encoder)
name|int
name|p_mpege_gen_parfile
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|t_mpg_par
modifier|*
name|mp_ptr
parameter_list|,
name|t_gap_mpeg_encoder
name|encoder
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|char
name|l_cmd
index|[
literal|256
index|]
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|encoder
condition|)
block|{
case|case
name|MPEG_ENCODE
case|:
name|l_rc
operator|=
name|p_mpeg_encode_gen_parfile
argument_list|(
name|ainfo_ptr
argument_list|,
name|mp_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPEG2ENCODE
case|:
name|l_rc
operator|=
name|p_mpeg2encode_gen_parfile
argument_list|(
name|ainfo_ptr
argument_list|,
name|mp_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l_rc
operator|>=
literal|0
condition|)
block|{
comment|/* make startscript executable */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"chmod a+x %s"
argument_list|,
name|mp_ptr
operator|->
name|startscript
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * gap_mpeg_encode  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_mpeg_encode (GRunModeType run_mode,gint32 image_id,t_gap_mpeg_encoder encoder)
name|int
name|gap_mpeg_encode
parameter_list|(
name|GRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|t_gap_mpeg_encoder
name|encoder
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|int
name|l_genmode
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|t_mpg_par
name|mp_par
decl_stmt|;
name|gint
name|l_width
decl_stmt|;
name|gint
name|l_height
decl_stmt|;
name|char
modifier|*
name|l_base_file_format
decl_stmt|;
name|char
name|l_errlist
index|[
literal|512
index|]
decl_stmt|;
name|char
name|l_cmd
index|[
literal|256
index|]
decl_stmt|;
name|gint
name|l_base_ffidx
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_genmode
operator|=
literal|0
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_base_file_format
operator|=
name|p_mpege_extension_check
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
name|l_base_ffidx
operator|=
name|p_mpeg2_extension_check
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
name|l_width
operator|=
name|gimp_image_width
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_height
operator|=
name|gimp_image_height
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|)
expr_stmt|;
name|l_errlist
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp_par
operator|.
name|ext
operator|=
literal|"\0"
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|extension
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|ainfo_ptr
operator|->
name|extension
operator|==
literal|'.'
condition|)
name|mp_par
operator|.
name|ext
operator|=
operator|&
name|ainfo_ptr
operator|->
name|extension
index|[
literal|1
index|]
expr_stmt|;
else|else
name|mp_par
operator|.
name|ext
operator|=
name|ainfo_ptr
operator|->
name|extension
expr_stmt|;
block|}
if|if
condition|(
name|encoder
operator|==
name|MPEG_ENCODE
condition|)
block|{
if|if
condition|(
operator|*
name|l_base_file_format
operator|==
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|l_errlist
argument_list|,
literal|"\nWARNING: mpeg_encode does not support Fileformat "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|l_errlist
argument_list|,
name|mp_par
operator|.
name|ext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l_width
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|l_errlist
argument_list|,
literal|"\nERROR: width not a multiple of 16"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l_height
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|l_errlist
argument_list|,
literal|"\nERROR: height not a multiple of 16"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encoder
operator|==
name|MPEG2ENCODE
condition|)
block|{
if|if
condition|(
name|l_base_ffidx
operator|<
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|l_errlist
argument_list|,
literal|"\nWARNING: mpeg2encode does not support Fileformat "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|l_errlist
argument_list|,
name|mp_par
operator|.
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ainfo_ptr
operator|->
name|frame_cnt
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|l_errlist
argument_list|,
literal|"\nERROR: invoked from a single image, animframe required"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l_rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|l_errlist
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* show warnings and errors (the user can decide to cancel or to continue) */
name|l_rc
operator|=
name|p_mpege_info
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_errlist
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|RUN_INTERACTIVE
condition|)
block|{
name|l_genmode
operator|=
name|p_mpege_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|mp_par
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_genmode
operator|<
literal|0
condition|)
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|l_rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sorry folks, NON_INTERACTIVE call .. not implemented yet\n"
argument_list|)
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
name|l_rc
operator|=
name|p_mpege_gen_parfile
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|mp_par
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l_genmode
operator|==
literal|1
condition|)
block|{
comment|/* execute mpeg encoder startscript in an xterm window */
name|sprintf
argument_list|(
name|l_cmd
argument_list|,
literal|"xterm -e %s&"
argument_list|,
name|mp_par
operator|.
name|startscript
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: could not execute mpeg_encode (not installed or not in PATH)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_mpeg_encode */
end_comment

end_unit

