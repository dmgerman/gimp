begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_lib.c  * 1997.11.18 hof (Wolfgang Hofer)  *  * GAP ... Gimp Animation Plugins  *  * basic anim functions:  *   Delete, Duplicate, Exchange, Shift   *   Next, Prev, First, Last, Goto  *   *  */
end_comment

begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* revision history:  * 1.1.28a; 2000/11/05   hof: check for GIMP_PDB_SUCCESS (not for FALSE)  * 1.1.20a; 2000/04/25   hof: new: p_get_video_paste_name p_vid_edit_clear  * 1.1.17b; 2000/02/27   hof: bug/style fixes  * 1.1.14a; 1999/12/18   hof: handle .xvpics on fileops (copy, rename and delete)  *                            new: p_get_frame_nr,  * 1.1.9a;  1999/09/14   hof: handle frame filenames with framenumbers  *                            that are not the 4digit style. (like frame1.xcf)  * 1.1.8a;  1999/08/31   hof: for AnimFrame Filtypes != XCF:  *                            p_decide_save_as does save INTERACTIVE at 1.st time  *                            and uses GIMP_RUN_WITH_LAST_VALS for subsequent calls  *                            (this enables to set Fileformat specific save-Parameters  *                            at least at the 1.st call, using the save dialog  *                            of the selected (by gimp_file_save) file_save procedure.  *                            in NONINTERACTIVE mode we have no access to  *                            the Fileformat specific save-Parameters  *          1999/07/22   hof: accept anim framenames without underscore '_'  *                            (suggested by Samuel Meder)  * 0.99.00; 1999/03/15   hof: prepared for win/dos filename conventions  * 0.98.00; 1998/11/30   hof: started Port to GIMP 1.1:  *                               exchange of Images (by next frame) is now handled in the  *                               new module: gap_exchange_image.c  * 0.96.02; 1998/07/30   hof: extended gap_dup (duplicate range instead of singele frame)  *                            added gap_shift  * 0.96.00               hof: - now using gap_arr_dialog.h  * 0.95.00               hof:  increased duplicate frames limit from 50 to 99  * 0.93.01               hof: fixup bug when frames are not in the current directory  * 0.90.00;              hof: 1.st (pre) release  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* SYSTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DIRENT_H
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
DECL|macro|S_ISDIR (m)
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
DECL|macro|S_ISREG (m)
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|G_OS_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_comment
comment|/* For _mkdir() */
end_comment

begin_define
DECL|macro|mkdir (path,mode)
define|#
directive|define
name|mkdir
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
value|_mkdir(path)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GAP includes */
end_comment

begin_include
include|#
directive|include
file|"gap_layer_copy.h"
end_include

begin_include
include|#
directive|include
file|"gap_lib.h"
end_include

begin_include
include|#
directive|include
file|"gap_pdb_calls.h"
end_include

begin_include
include|#
directive|include
file|"gap_arr_dialog.h"
end_include

begin_include
include|#
directive|include
file|"gap_exchange_image.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==0  ... dont print debug infos */
end_comment

begin_comment
comment|/* ------------------------------------------ */
end_comment

begin_comment
comment|/* forward  working procedures */
end_comment

begin_comment
comment|/* ------------------------------------------ */
end_comment

begin_function_decl
specifier|static
name|int
name|p_save_old_frame
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|p_rename_frame
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|from_nr
parameter_list|,
name|long
name|to_nr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|p_delete_frame
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|nr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|p_del
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|p_decide_save_as
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|char
modifier|*
name|sav_name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ============================================================================  * p_alloc_fname_thumbnail  *   return the thumbnail name (in .xvpics subdir)  *   for the given filename  * ============================================================================  */
end_comment

begin_function
name|char
modifier|*
DECL|function|p_alloc_fname_thumbnail (char * name)
name|p_alloc_fname_thumbnail
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|l_len
decl_stmt|;
name|int
name|l_idx
decl_stmt|;
name|char
modifier|*
name|l_str
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|g_strdup
argument_list|(
literal|"\0"
argument_list|)
operator|)
return|;
block|}
name|l_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|l_str
operator|=
name|g_malloc
argument_list|(
name|l_len
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|l_str
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_len
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|l_idx
operator|=
name|l_len
operator|-
literal|1
init|;
name|l_idx
operator|>
literal|0
condition|;
name|l_idx
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|name
index|[
name|l_idx
index|]
operator|==
name|G_DIR_SEPARATOR
operator|)
operator|||
operator|(
name|name
index|[
name|l_idx
index|]
operator|==
name|DIR_ROOT
operator|)
condition|)
block|{
name|l_idx
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|sprintf
argument_list|(
operator|&
name|l_str
index|[
name|l_idx
index|]
argument_list|,
literal|".xvpics%s%s"
argument_list|,
name|G_DIR_SEPARATOR_S
argument_list|,
operator|&
name|name
index|[
name|l_idx
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_alloc_fname_thumbnail: thumbname=%s:\n"
argument_list|,
name|l_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_strdup_*_underscore  *   duplicate string and if last char is no underscore add one at end.  *   duplicate string and delete last char if it is the underscore  * ============================================================================  */
end_comment

begin_function
name|char
modifier|*
DECL|function|p_strdup_add_underscore (char * name)
name|p_strdup_add_underscore
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|l_len
decl_stmt|;
name|char
modifier|*
name|l_str
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|g_strdup
argument_list|(
literal|"\0"
argument_list|)
operator|)
return|;
block|}
name|l_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|l_str
operator|=
name|g_malloc
argument_list|(
name|l_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|l_str
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
index|[
name|l_len
operator|-
literal|1
index|]
operator|!=
literal|'_'
condition|)
block|{
name|l_str
index|[
name|l_len
index|]
operator|=
literal|'_'
expr_stmt|;
name|l_str
index|[
name|l_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l_str
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
DECL|function|p_strdup_del_underscore (char * name)
name|p_strdup_del_underscore
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|l_len
decl_stmt|;
name|char
modifier|*
name|l_str
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|g_strdup
argument_list|(
literal|"\0"
argument_list|)
operator|)
return|;
block|}
name|l_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|l_str
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l_str
index|[
name|l_len
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|l_str
index|[
name|l_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l_str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_msg_win  *   print a message both to stderr  *   and to a gimp info window with OK button (only when run INTERACTIVE)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_msg_win (GimpRunModeType run_mode,char * msg)
name|void
name|p_msg_win
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|static
name|t_but_arg
name|l_argv
index|[
literal|1
index|]
decl_stmt|;
name|int
name|l_argc
decl_stmt|;
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_argc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
if|if
condition|(
operator|*
name|msg
condition|)
block|{
name|fwrite
argument_list|(
name|msg
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
name|p_buttons_dialog
argument_list|(
name|_
argument_list|(
literal|"GAP Message"
argument_list|)
argument_list|,
name|msg
argument_list|,
name|l_argc
argument_list|,
name|l_argv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end  p_msg_win */
end_comment

begin_comment
comment|/* ============================================================================  * p_file_exists  *  * return 0  ... file does not exist, or is not accessable by user,  *               or is empty,  *               or is not a regular file  *        1  ... file exists  * ============================================================================  */
end_comment

begin_function
DECL|function|p_file_exists (char * fname)
name|int
name|p_file_exists
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|stat
name|l_stat_buf
decl_stmt|;
name|long
name|l_len
decl_stmt|;
comment|/* File Laenge ermitteln */
if|if
condition|(
literal|0
operator|!=
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|l_stat_buf
argument_list|)
condition|)
block|{
comment|/* stat error (file does not exist) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|l_stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|l_len
operator|=
operator|(
name|long
operator|)
name|l_stat_buf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|l_len
operator|<
literal|1
condition|)
block|{
comment|/* File is empty*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_file_exists */
end_comment

begin_comment
comment|/* ============================================================================  * p_image_file_copy  *    (copy the imagefile and its thumbnail)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_image_file_copy (char * fname,char * fname_copy)
name|int
name|p_image_file_copy
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|fname_copy
parameter_list|)
block|{
name|char
modifier|*
name|l_from_fname_thumbnail
decl_stmt|;
name|char
modifier|*
name|l_to_fname_thumbnail
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_from_fname_thumbnail
operator|=
name|p_alloc_fname_thumbnail
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|l_to_fname_thumbnail
operator|=
name|p_alloc_fname_thumbnail
argument_list|(
name|fname_copy
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_file_copy
argument_list|(
name|fname
argument_list|,
name|fname_copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_from_fname_thumbnail
operator|)
operator|&&
operator|(
name|l_to_fname_thumbnail
operator|)
condition|)
block|{
name|p_file_copy
argument_list|(
name|l_from_fname_thumbnail
argument_list|,
name|l_to_fname_thumbnail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_from_fname_thumbnail
condition|)
name|g_free
argument_list|(
name|l_from_fname_thumbnail
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_to_fname_thumbnail
condition|)
name|g_free
argument_list|(
name|l_to_fname_thumbnail
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_file_copy  * ============================================================================  */
end_comment

begin_function
DECL|function|p_file_copy (char * fname,char * fname_copy)
name|int
name|p_file_copy
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|fname_copy
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|char
modifier|*
name|l_buffer
decl_stmt|;
name|struct
name|stat
name|l_stat_buf
decl_stmt|;
name|long
name|l_len
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_file_copy src:%s dst:%s\n"
argument_list|,
name|fname
argument_list|,
name|fname_copy
argument_list|)
expr_stmt|;
comment|/* File Laenge ermitteln */
if|if
condition|(
literal|0
operator|!=
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|l_stat_buf
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stat error on '%s'\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_len
operator|=
operator|(
name|long
operator|)
name|l_stat_buf
operator|.
name|st_size
expr_stmt|;
comment|/* Buffer allocate */
name|l_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|g_malloc0
argument_list|(
operator|(
name|size_t
operator|)
name|l_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_buffer
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file_copy: calloc error (%ld Bytes not available)\n"
argument_list|,
name|l_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* load File into Buffer */
name|l_fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* open read */
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"open(read) error on '%s'\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_buffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fread
argument_list|(
name|l_buffer
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|l_len
argument_list|,
name|l_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|fname_copy
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* open write */
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file_copy: open(write) error on '%s' \n"
argument_list|,
name|fname_copy
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_buffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|l_len
operator|>
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|l_buffer
argument_list|,
name|l_len
argument_list|,
literal|1
argument_list|,
name|l_fp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* all done OK */
block|}
end_function

begin_comment
comment|/* end p_file_copy */
end_comment

begin_comment
comment|/* ============================================================================  * p_delete_frame  * ============================================================================  */
end_comment

begin_function
DECL|function|p_delete_frame (t_anim_info * ainfo_ptr,long nr)
name|int
name|p_delete_frame
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|nr
parameter_list|)
block|{
name|char
modifier|*
name|l_fname
decl_stmt|;
name|char
modifier|*
name|l_fname_thumbnail
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_fname
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fname
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|l_fname_thumbnail
operator|=
name|p_alloc_fname_thumbnail
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fname_thumbnail
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nDEBUG p_delete_frame: %s\n"
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|remove
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nDEBUG p_delete_frame: %s\n"
argument_list|,
name|l_fname_thumbnail
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_fname_thumbnail
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_fname_thumbnail
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_delete_frame */
end_comment

begin_comment
comment|/* ============================================================================  * p_rename_frame  * ============================================================================  */
end_comment

begin_function
DECL|function|p_rename_frame (t_anim_info * ainfo_ptr,long from_nr,long to_nr)
name|int
name|p_rename_frame
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|from_nr
parameter_list|,
name|long
name|to_nr
parameter_list|)
block|{
name|char
modifier|*
name|l_from_fname
decl_stmt|;
name|char
modifier|*
name|l_to_fname
decl_stmt|;
name|char
modifier|*
name|l_from_fname_thumbnail
decl_stmt|;
name|char
modifier|*
name|l_to_fname_thumbnail
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_from_fname
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|from_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_from_fname
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|l_to_fname
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|to_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_to_fname
operator|==
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|l_from_fname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|l_from_fname_thumbnail
operator|=
name|p_alloc_fname_thumbnail
argument_list|(
name|l_from_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_from_fname_thumbnail
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|l_to_fname_thumbnail
operator|=
name|p_alloc_fname_thumbnail
argument_list|(
name|l_to_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_to_fname_thumbnail
operator|==
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|l_from_fname_thumbnail
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nDEBUG p_rename_frame: %s ..to.. %s\n"
argument_list|,
name|l_from_fname
argument_list|,
name|l_to_fname
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|rename
argument_list|(
name|l_from_fname
argument_list|,
name|l_to_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nDEBUG p_rename_frame: %s ..to.. %s\n"
argument_list|,
name|l_from_fname_thumbnail
argument_list|,
name|l_to_fname_thumbnail
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|l_from_fname_thumbnail
argument_list|,
name|l_to_fname_thumbnail
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_from_fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_to_fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_from_fname_thumbnail
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_to_fname_thumbnail
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_rename_frame */
end_comment

begin_comment
comment|/* ============================================================================  * p_alloc_basename  *  * build the basename from an images name  * Extension and trailing digits ("0000.xcf") are cut off.  * return name or NULL (if malloc fails)  * Output: number contains the integer representation of the stripped off  *         number String. (or 0 if there was none)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_alloc_basename (char * imagename,long * number)
name|char
modifier|*
name|p_alloc_basename
parameter_list|(
name|char
modifier|*
name|imagename
parameter_list|,
name|long
modifier|*
name|number
parameter_list|)
block|{
name|char
modifier|*
name|l_fname
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|long
name|l_idx
decl_stmt|;
operator|*
name|number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|imagename
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l_fname
operator|=
operator|(
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|strlen
argument_list|(
name|imagename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* copy from imagename */
name|strcpy
argument_list|(
name|l_fname
argument_list|,
name|imagename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG p_alloc_basename  source: '%s'\n"
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
comment|/* cut off extension */
name|l_ptr
operator|=
operator|&
name|l_fname
index|[
name|strlen
argument_list|(
name|l_fname
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|l_ptr
operator|!=
name|l_fname
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
name|G_DIR_SEPARATOR
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
name|DIR_ROOT
operator|)
condition|)
block|{
break|break;
block|}
comment|/* dont run into dir part */
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'.'
condition|)
block|{
operator|*
name|l_ptr
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|l_ptr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG p_alloc_basename (ext_off): '%s'\n"
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
comment|/* cut off trailing digits (0000) */
name|l_ptr
operator|=
operator|&
name|l_fname
index|[
name|strlen
argument_list|(
name|l_fname
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|!=
name|l_fname
condition|)
name|l_ptr
operator|--
expr_stmt|;
name|l_idx
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|l_ptr
operator|!=
name|l_fname
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|l_ptr
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|number
operator|+=
operator|(
operator|(
operator|*
name|l_ptr
operator|-
literal|'0'
operator|)
operator|*
name|l_idx
operator|)
expr_stmt|;
name|l_idx
operator|=
name|l_idx
operator|*
literal|10
expr_stmt|;
operator|*
name|l_ptr
operator|=
literal|'\0'
expr_stmt|;
name|l_ptr
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* do not cut off underscore any longer */
comment|/*        * if(*l_ptr == '_')        * {         *    *l_ptr = '\0';        * }        */
break|break;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG p_alloc_basename  result:'%s'\n"
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_fname
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_alloc_basename */
end_comment

begin_comment
comment|/* ============================================================================  * p_alloc_extension  *  * input: a filename  * returns: a copy of the filename extension (incl "." )  *          if the filename has no extension, a pointer to  *          an empty string is returned ("\0")  *          NULL if allocate mem for extension failed.  * ============================================================================  */
end_comment

begin_function
DECL|function|p_alloc_extension (char * imagename)
name|char
modifier|*
name|p_alloc_extension
parameter_list|(
name|char
modifier|*
name|imagename
parameter_list|)
block|{
name|int
name|l_exlen
decl_stmt|;
name|char
modifier|*
name|l_ext
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|l_exlen
operator|=
literal|0
expr_stmt|;
name|l_ptr
operator|=
operator|&
name|imagename
index|[
name|strlen
argument_list|(
name|imagename
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|l_ptr
operator|!=
name|imagename
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
name|G_DIR_SEPARATOR
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
name|DIR_ROOT
operator|)
condition|)
block|{
break|break;
block|}
comment|/* dont run into dir part */
if|if
condition|(
operator|*
name|l_ptr
operator|==
literal|'.'
condition|)
block|{
name|l_exlen
operator|=
name|strlen
argument_list|(
name|l_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|l_ptr
operator|--
expr_stmt|;
block|}
name|l_ext
operator|=
name|g_malloc0
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|l_exlen
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ext
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|l_exlen
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|l_ext
argument_list|,
name|l_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_ext
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_alloc_fname  *  * build the name of a frame using "basename_0000.ext"  *   * return name or NULL (if malloc fails)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_alloc_fname (char * basename,long nr,char * extension)
name|char
modifier|*
name|p_alloc_fname
parameter_list|(
name|char
modifier|*
name|basename
parameter_list|,
name|long
name|nr
parameter_list|,
name|char
modifier|*
name|extension
parameter_list|)
block|{
name|gchar
modifier|*
name|l_fname
decl_stmt|;
name|gint
name|l_leading_zeroes
decl_stmt|;
name|gint
name|l_len
decl_stmt|;
name|long
name|l_nr_chk
decl_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l_len
operator|=
operator|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
name|strlen
argument_list|(
name|extension
argument_list|)
operator|+
literal|10
operator|)
expr_stmt|;
name|l_fname
operator|=
operator|(
name|char
operator|*
operator|)
name|g_malloc
argument_list|(
name|l_len
argument_list|)
expr_stmt|;
name|l_leading_zeroes
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|1000
condition|)
block|{
comment|/* try to figure out if the frame numbers are in         * 4-digit style, with leading zeroes  "frame_0001.xcf"         * or not                              "frame_1.xcf"         */
name|l_nr_chk
operator|=
name|nr
expr_stmt|;
while|while
condition|(
name|l_nr_chk
operator|>=
literal|0
condition|)
block|{
comment|/* check if frame is on disk with 4-digit style framenumber */
name|g_snprintf
argument_list|(
name|l_fname
argument_list|,
name|l_len
argument_list|,
literal|"%s%04ld%s"
argument_list|,
name|basename
argument_list|,
name|l_nr_chk
argument_list|,
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|l_fname
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* now check for filename without leading zeroes in the framenumber */
name|g_snprintf
argument_list|(
name|l_fname
argument_list|,
name|l_len
argument_list|,
literal|"%s%ld%s"
argument_list|,
name|basename
argument_list|,
name|l_nr_chk
argument_list|,
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_file_exists
argument_list|(
name|l_fname
argument_list|)
condition|)
block|{
name|l_leading_zeroes
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|l_nr_chk
operator|--
expr_stmt|;
comment|/* if the frames nr and nr-1  were not found           * try to check frames 1 and 0           * to limit down the loop to max 4 cycles           */
if|if
condition|(
operator|(
name|l_nr_chk
operator|==
name|nr
operator|-
literal|2
operator|)
operator|&&
operator|(
name|l_nr_chk
operator|>
literal|1
operator|)
condition|)
block|{
name|l_nr_chk
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|l_leading_zeroes
operator|=
name|FALSE
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_leading_zeroes
condition|)
name|l_fname
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%04ld%s"
argument_list|,
name|basename
argument_list|,
name|nr
argument_list|,
name|extension
argument_list|)
expr_stmt|;
else|else
name|l_fname
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%ld%s"
argument_list|,
name|basename
argument_list|,
name|nr
argument_list|,
name|extension
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_fname
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_alloc_fname */
end_comment

begin_comment
comment|/* ============================================================================  * p_alloc_ainfo  *  * allocate and init an ainfo structure from the given image.  * ============================================================================  */
end_comment

begin_function
DECL|function|p_alloc_ainfo (gint32 image_id,GimpRunModeType run_mode)
name|t_anim_info
modifier|*
name|p_alloc_ainfo
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|GimpRunModeType
name|run_mode
parameter_list|)
block|{
name|t_anim_info
modifier|*
name|l_ainfo_ptr
decl_stmt|;
name|l_ainfo_ptr
operator|=
operator|(
name|t_anim_info
operator|*
operator|)
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_anim_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ainfo_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l_ainfo_ptr
operator|->
name|basename
operator|=
name|NULL
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|new_filename
operator|=
name|NULL
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|extension
operator|=
name|NULL
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|image_id
operator|=
name|image_id
expr_stmt|;
comment|/* get current gimp images name  */
name|l_ainfo_ptr
operator|->
name|old_filename
operator|=
name|gimp_image_get_filename
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ainfo_ptr
operator|->
name|old_filename
operator|==
name|NULL
condition|)
block|{
name|l_ainfo_ptr
operator|->
name|old_filename
operator|=
name|g_strdup
argument_list|(
literal|"frame_0001.xcf"
argument_list|)
expr_stmt|;
comment|/* assign a defaultname */
name|gimp_image_set_filename
argument_list|(
name|image_id
argument_list|,
name|l_ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
block|}
name|l_ainfo_ptr
operator|->
name|basename
operator|=
name|p_alloc_basename
argument_list|(
name|l_ainfo_ptr
operator|->
name|old_filename
argument_list|,
operator|&
name|l_ainfo_ptr
operator|->
name|frame_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|l_ainfo_ptr
operator|->
name|basename
condition|)
block|{
name|p_free_ainfo
argument_list|(
operator|&
name|l_ainfo_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l_ainfo_ptr
operator|->
name|extension
operator|=
name|p_alloc_extension
argument_list|(
name|l_ainfo_ptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|curr_frame_nr
operator|=
name|l_ainfo_ptr
operator|->
name|frame_nr
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|first_frame_nr
operator|=
operator|-
literal|1
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|last_frame_nr
operator|=
operator|-
literal|1
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|frame_cnt
operator|=
literal|0
expr_stmt|;
name|l_ainfo_ptr
operator|->
name|run_mode
operator|=
name|run_mode
expr_stmt|;
return|return
operator|(
name|l_ainfo_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_init_ainfo */
end_comment

begin_comment
comment|/* ============================================================================  * p_dir_ainfo  *  * fill in more items into the given ainfo structure.  * - first_frame_nr  * - last_frame_nr  * - frame_cnt  *  * to get this information, the directory entries have to be checked  * ============================================================================  */
end_comment

begin_function
DECL|function|p_dir_ainfo (t_anim_info * ainfo_ptr)
name|int
name|p_dir_ainfo
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
name|char
modifier|*
name|l_dirname
decl_stmt|;
name|char
modifier|*
name|l_dirname_ptr
decl_stmt|;
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|char
modifier|*
name|l_exptr
decl_stmt|;
name|char
modifier|*
name|l_dummy
decl_stmt|;
comment|/* int            l_cmp_len;   */
name|DIR
modifier|*
name|l_dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|l_dp
decl_stmt|;
name|long
name|l_nr
decl_stmt|;
name|long
name|l_maxnr
decl_stmt|;
name|long
name|l_minnr
decl_stmt|;
name|short
name|l_dirflag
decl_stmt|;
name|char
name|dirname_buff
index|[
literal|1024
index|]
decl_stmt|;
name|l_dirname
operator|=
name|g_malloc
argument_list|(
name|strlen
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_dirname
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ainfo_ptr
operator|->
name|frame_cnt
operator|=
literal|0
expr_stmt|;
name|l_dirp
operator|=
name|NULL
expr_stmt|;
name|l_minnr
operator|=
literal|99999999
expr_stmt|;
name|l_maxnr
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|l_dirname
argument_list|,
name|ainfo_ptr
operator|->
name|basename
argument_list|)
expr_stmt|;
name|l_ptr
operator|=
operator|&
name|l_dirname
index|[
name|strlen
argument_list|(
name|l_dirname
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|l_ptr
operator|!=
name|l_dirname
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|l_ptr
operator|==
name|G_DIR_SEPARATOR
operator|)
operator|||
operator|(
operator|*
name|l_ptr
operator|==
name|DIR_ROOT
operator|)
condition|)
block|{
operator|*
name|l_ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* split the string into dirpath 0 basename */
name|l_ptr
operator|++
expr_stmt|;
break|break;
comment|/* stop at char behind the slash */
block|}
name|l_ptr
operator|--
expr_stmt|;
block|}
comment|/* l_cmp_len = strlen(l_ptr); */
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG p_dir_ainfo: BASENAME:%s\n"
argument_list|,
name|l_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ptr
operator|==
name|l_dirname
condition|)
block|{
name|l_dirname_ptr
operator|=
literal|"."
expr_stmt|;
name|l_dirflag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|l_dirname
operator|==
literal|'\0'
condition|)
block|{
name|l_dirname_ptr
operator|=
name|G_DIR_SEPARATOR_S
expr_stmt|;
name|l_dirflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l_dirname_ptr
operator|=
name|l_dirname
expr_stmt|;
name|l_dirflag
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG p_dir_ainfo: DIRNAME:%s\n"
argument_list|,
name|l_dirname_ptr
argument_list|)
expr_stmt|;
name|l_dirp
operator|=
name|opendir
argument_list|(
name|l_dirname_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l_dirp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR p_dir_ainfo: cant read directory %s\n"
argument_list|,
name|l_dirname_ptr
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|l_dp
operator|=
name|readdir
argument_list|(
name|l_dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* if(gap_debug) fprintf(stderr, "DEBUG p_dir_ainfo: l_dp->d_name:%s\n", l_dp->d_name); */
comment|/* findout extension of the directory entry name */
name|l_exptr
operator|=
operator|&
name|l_dp
operator|->
name|d_name
index|[
name|strlen
argument_list|(
name|l_dp
operator|->
name|d_name
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|l_exptr
operator|!=
name|l_dp
operator|->
name|d_name
condition|)
block|{
if|if
condition|(
operator|*
name|l_exptr
operator|==
name|G_DIR_SEPARATOR
condition|)
block|{
break|break;
block|}
comment|/* dont run into dir part */
if|if
condition|(
operator|*
name|l_exptr
operator|==
literal|'.'
condition|)
block|{
break|break;
block|}
name|l_exptr
operator|--
expr_stmt|;
block|}
comment|/* l_exptr now points to the "." of the direntry (or to its begin if has no ext) */
comment|/* now check for equal extension */
if|if
condition|(
operator|(
operator|*
name|l_exptr
operator|==
literal|'.'
operator|)
operator|&&
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_exptr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
operator|)
condition|)
block|{
comment|/* build full pathname (to check if file exists) */
switch|switch
condition|(
name|l_dirflag
condition|)
block|{
case|case
literal|0
case|:
name|g_snprintf
argument_list|(
name|dirname_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|dirname_buff
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|l_dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|g_snprintf
argument_list|(
name|dirname_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|dirname_buff
argument_list|)
argument_list|,
literal|"%c%s"
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|l_dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* UNIX:  "/dir/file"              * DOS:   "drv:\dir\file"              */
name|g_snprintf
argument_list|(
name|dirname_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|dirname_buff
argument_list|)
argument_list|,
literal|"%s%c%s"
argument_list|,
name|l_dirname_ptr
argument_list|,
name|G_DIR_SEPARATOR
argument_list|,
name|l_dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|1
operator|==
name|p_file_exists
argument_list|(
name|dirname_buff
argument_list|)
condition|)
comment|/* check for regular file */
block|{
comment|/* get basename and frame number of the directory entry */
name|l_dummy
operator|=
name|p_alloc_basename
argument_list|(
name|l_dp
operator|->
name|d_name
argument_list|,
operator|&
name|l_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_dummy
operator|!=
name|NULL
condition|)
block|{
comment|/* check for files, with equal basename (frames)                 * (length must be greater than basepart+extension                 * because of the frame_nr part "0000")                 */
if|if
condition|(
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_ptr
argument_list|,
name|l_dummy
argument_list|)
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|l_dp
operator|->
name|d_name
argument_list|)
operator|>
name|strlen
argument_list|(
name|l_dummy
argument_list|)
operator|+
name|strlen
argument_list|(
name|l_exptr
argument_list|)
operator|)
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG p_dir_ainfo:  %s NR=%ld\n"
argument_list|,
name|l_dp
operator|->
name|d_name
argument_list|,
name|l_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_nr
operator|>
name|l_maxnr
condition|)
name|l_maxnr
operator|=
name|l_nr
expr_stmt|;
if|if
condition|(
name|l_nr
operator|<
name|l_minnr
condition|)
name|l_minnr
operator|=
name|l_nr
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_dummy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|closedir
argument_list|(
name|l_dirp
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_dirname
argument_list|)
expr_stmt|;
comment|/* set first_frame_nr and last_frame_nr (found as "_0099" in diskfile namepart) */
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|=
name|l_maxnr
expr_stmt|;
name|ainfo_ptr
operator|->
name|first_frame_nr
operator|=
name|l_minnr
expr_stmt|;
return|return
literal|0
return|;
comment|/* OK */
block|}
end_function

begin_comment
comment|/* end p_dir_ainfo */
end_comment

begin_comment
comment|/* ============================================================================  * p_free_ainfo  *  * free ainfo and its allocated stuff  * ============================================================================  */
end_comment

begin_function
DECL|function|p_free_ainfo (t_anim_info ** ainfo)
name|void
name|p_free_ainfo
parameter_list|(
name|t_anim_info
modifier|*
modifier|*
name|ainfo
parameter_list|)
block|{
name|t_anim_info
modifier|*
name|aptr
decl_stmt|;
if|if
condition|(
operator|(
name|aptr
operator|=
operator|*
name|ainfo
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|aptr
operator|->
name|basename
condition|)
name|g_free
argument_list|(
name|aptr
operator|->
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
operator|->
name|extension
condition|)
name|g_free
argument_list|(
name|aptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
operator|->
name|new_filename
condition|)
name|g_free
argument_list|(
name|aptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
operator|->
name|old_filename
condition|)
name|g_free
argument_list|(
name|aptr
operator|->
name|old_filename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_get_frame_nr  * ============================================================================  */
end_comment

begin_function
name|long
DECL|function|p_get_frame_nr_from_name (char * fname)
name|p_get_frame_nr_from_name
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|long
name|number
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|basename
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|basename
operator|=
name|p_alloc_basename
argument_list|(
name|fname
argument_list|,
operator|&
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0
condition|)
return|return
operator|(
name|number
operator|)
return|;
if|if
condition|(
name|fname
index|[
name|len
index|]
operator|==
literal|'0'
condition|)
return|return
operator|(
name|number
operator|)
return|;
comment|/*  *   if(fname[len]  == '_')  *   {  *     if(fname[len+1]  == '0') return(TRUE);  *   }  */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|long
DECL|function|p_get_frame_nr (gint32 image_id)
name|p_get_frame_nr
parameter_list|(
name|gint32
name|image_id
parameter_list|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|long
name|number
decl_stmt|;
name|number
operator|=
operator|-
literal|1
expr_stmt|;
name|fname
operator|=
name|gimp_image_get_filename
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
name|number
operator|=
name|p_get_frame_nr_from_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|number
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ============================================================================  * p_chk_framechange  *  * check if the current frame nr has changed.   * useful after dialogs, because the user may have renamed the current image  * (using save as)  * while the gap-plugin's dialog was open.  * return: 0 .. OK  *        -1 .. Changed (or error occured)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_chk_framechange (t_anim_info * ainfo_ptr)
name|int
name|p_chk_framechange
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
name|int
name|l_rc
decl_stmt|;
name|t_anim_info
modifier|*
name|l_ainfo_ptr
decl_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|==
name|l_ainfo_ptr
operator|->
name|curr_frame_nr
condition|)
block|{
name|l_rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|_
argument_list|(
literal|"OPERATION CANCELLED.\n"
literal|"Current frame changed while dialog was open."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|l_ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_chk_framechange */
end_comment

begin_comment
comment|/* ============================================================================  * p_chk_framerange  *  * check ainfo struct if there is a framerange (of at least one frame)  * return: 0 .. OK  *        -1 .. No frames there (print error)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_chk_framerange (t_anim_info * ainfo_ptr)
name|int
name|p_chk_framerange
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
if|if
condition|(
name|ainfo_ptr
operator|->
name|frame_cnt
operator|==
literal|0
condition|)
block|{
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|_
argument_list|(
literal|"OPERATION CANCELLED.\n"
literal|"GAP-plugins works only with filenames\n"
literal|"that end with _0001.xcf.\n"
literal|"==> Rename your image, then try again."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end p_chk_framerange */
end_comment

begin_comment
comment|/* ============================================================================  * p_gzip  *   gzip or gunzip the file to a temporary file.  *   zip == "zip"    compress  *   zip == "unzip"  decompress  *   return a pointer to the temporary created (by gzip) file.  *          NULL  in case of errors  * ============================================================================  */
end_comment

begin_function
DECL|function|p_gzip (char * orig_name,char * new_name,char * zip)
name|char
modifier|*
name|p_gzip
parameter_list|(
name|char
modifier|*
name|orig_name
parameter_list|,
name|char
modifier|*
name|new_name
parameter_list|,
name|char
modifier|*
name|zip
parameter_list|)
block|{
name|gchar
modifier|*
name|l_cmd
decl_stmt|;
name|gchar
modifier|*
name|l_tmpname
decl_stmt|;
name|gint
name|l_rc
decl_stmt|,
name|l_rc2
decl_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|l_cmd
operator|=
name|NULL
expr_stmt|;
name|l_tmpname
operator|=
name|new_name
expr_stmt|;
comment|/* used gzip options:    *     -c --stdout --to-stdout    *          Write  output  on  standard  output    *     -d --decompress --uncompress    *          Decompress.    *     -f --force    *           Force compression or decompression even if the file    */
if|if
condition|(
operator|*
name|zip
operator|==
literal|'u'
condition|)
block|{
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"gzip -cfd<\"%s\">\"%s\""
argument_list|,
name|orig_name
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_cmd
operator|=
name|g_strdup_printf
argument_list|(
literal|"gzip -cf<\"%s\">\"%s\""
argument_list|,
name|orig_name
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"system: %s\n"
argument_list|,
name|l_cmd
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|system
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|!=
literal|0
condition|)
block|{
comment|/* Shift 8 Bits gets Retcode of the executed Program */
name|l_rc2
operator|=
name|l_rc
operator|>>
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR system: %s\nreturncodes %d %d"
argument_list|,
name|l_cmd
argument_list|,
name|l_rc
argument_list|,
name|l_rc2
argument_list|)
expr_stmt|;
name|l_tmpname
operator|=
name|NULL
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_cmd
argument_list|)
expr_stmt|;
return|return
name|l_tmpname
return|;
block|}
end_function

begin_comment
comment|/* end p_gzip */
end_comment

begin_comment
comment|/* ============================================================================  * p_decide_save_as  *   decide what to to, when attempt to save a frame in any image format   *  (other than xcf)  *   Let the user decide if the frame is to save "as it is" or "flattened"  *   ("as it is" will save only the backround layer in most fileformat types)  *   The SAVE_AS_MODE is stored , and reused  *   (without displaying the dialog) on subsequent calls.  *  *   return -1  ... CANCEL (do not save)  *           0  ... save the image (may be flattened)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_decide_save_as (gint32 image_id,char * sav_name)
name|int
name|p_decide_save_as
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|char
modifier|*
name|sav_name
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|l_msg
decl_stmt|;
specifier|static
name|char
name|l_save_as_name
index|[
literal|80
index|]
decl_stmt|;
specifier|static
name|t_but_arg
name|l_argv
index|[
literal|3
index|]
decl_stmt|;
name|int
name|l_argc
decl_stmt|;
name|int
name|l_save_as_mode
decl_stmt|;
name|GimpRunModeType
name|l_run_mode
decl_stmt|;
name|l_msg
operator|=
name|_
argument_list|(
literal|"You are using a file format != xcf\n"
literal|"Save Operations may result\n"
literal|"in loss of layer information."
argument_list|)
expr_stmt|;
comment|/* check if there are SAVE_AS_MODE settings (from privious calls within one gimp session) */
name|l_save_as_mode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* g_snprintf(l_save_as_name, sizeof(l_save_as_name), "plug_in_gap_plugins_SAVE_AS_MODE_%d", (int)image_id);*/
name|g_snprintf
argument_list|(
name|l_save_as_name
argument_list|,
sizeof|sizeof
argument_list|(
name|l_save_as_name
argument_list|)
argument_list|,
literal|"plug_in_gap_plugins_SAVE_AS_MODE"
argument_list|)
expr_stmt|;
name|gimp_get_data
argument_list|(
name|l_save_as_name
argument_list|,
operator|&
name|l_save_as_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_save_as_mode
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* no defined value found (this is the 1.st call for this image_id)      * ask what to do with a 3 Button dialog      */
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|0
index|]
operator|.
name|but_val
operator|=
operator|-
literal|1
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Save Flattened"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|1
index|]
operator|.
name|but_val
operator|=
literal|1
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_txt
operator|=
name|_
argument_list|(
literal|"Save As Is"
argument_list|)
expr_stmt|;
name|l_argv
index|[
literal|2
index|]
operator|.
name|but_val
operator|=
literal|0
expr_stmt|;
name|l_argc
operator|=
literal|3
expr_stmt|;
name|l_save_as_mode
operator|=
name|p_buttons_dialog
argument_list|(
name|_
argument_list|(
literal|"GAP Question"
argument_list|)
argument_list|,
name|l_msg
argument_list|,
name|l_argc
argument_list|,
name|l_argv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: decide SAVE_AS_MODE %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_save_as_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_save_as_mode
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|l_run_mode
operator|=
name|GIMP_RUN_INTERACTIVE
expr_stmt|;
block|}
else|else
block|{
name|l_run_mode
operator|=
name|GIMP_RUN_WITH_LAST_VALS
expr_stmt|;
block|}
name|gimp_set_data
argument_list|(
name|l_save_as_name
argument_list|,
operator|&
name|l_save_as_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|l_save_as_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_save_as_mode
operator|==
literal|1
condition|)
block|{
name|gimp_image_flatten
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p_save_named_image
argument_list|(
name|image_id
argument_list|,
name|sav_name
argument_list|,
name|l_run_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_decide_save_as */
end_comment

begin_comment
comment|/* ============================================================================  * p_save_named_image  * ============================================================================  */
end_comment

begin_function
DECL|function|p_save_named_image (gint32 image_id,char * sav_name,GimpRunModeType run_mode)
name|gint32
name|p_save_named_image
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|char
modifier|*
name|sav_name
parameter_list|,
name|GimpRunModeType
name|run_mode
parameter_list|)
block|{
name|GimpDrawable
modifier|*
name|l_drawable
decl_stmt|;
name|gint
name|l_nlayers
decl_stmt|;
name|gint32
modifier|*
name|l_layers_list
decl_stmt|;
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: before   p_save_named_image: '%s'\n"
argument_list|,
name|sav_name
argument_list|)
expr_stmt|;
name|l_layers_list
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_nlayers
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_layers_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|l_drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|l_layers_list
index|[
name|l_nlayers
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* use the background layer */
if|if
condition|(
name|l_drawable
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: p_save_named_image gimp_drawable_get failed '%s' nlayers=%d\n"
argument_list|,
name|sav_name
argument_list|,
operator|(
name|int
operator|)
name|l_nlayers
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_file_save"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|run_mode
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_id
argument_list|,
name|GIMP_PDB_DRAWABLE
argument_list|,
name|l_drawable
operator|->
name|id
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|sav_name
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|sav_name
argument_list|,
comment|/* raw name ? */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: after    p_save_named_image: '%s' nlayers=%d image=%d drw=%d run_mode=%d\n"
argument_list|,
name|sav_name
argument_list|,
operator|(
name|int
operator|)
name|l_nlayers
argument_list|,
operator|(
name|int
operator|)
name|image_id
argument_list|,
operator|(
name|int
operator|)
name|l_drawable
operator|->
name|id
argument_list|,
operator|(
name|int
operator|)
name|run_mode
argument_list|)
expr_stmt|;
name|p_gimp_file_save_thumbnail
argument_list|(
name|image_id
argument_list|,
name|sav_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_layers_list
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|!=
name|GIMP_PDB_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: p_save_named_image  gimp_file_save failed '%s'\n"
argument_list|,
name|sav_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"HOF gimp_file_save returned GIMP_PDB_SUCCESS\n"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
return|return
name|image_id
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_save_named_image */
end_comment

begin_comment
comment|/* ============================================================================  * p_save_named_frame  *  save frame into temporary image,  *  on success rename it to desired framename.  *  (this is done, to avoid corrupted frames on disk in case of  *   crash in one of the save procedures)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_save_named_frame (gint32 image_id,char * sav_name)
name|int
name|p_save_named_frame
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|char
modifier|*
name|sav_name
parameter_list|)
block|{
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|char
modifier|*
name|l_ext
decl_stmt|;
name|char
modifier|*
name|l_tmpname
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|int
name|l_gzip
decl_stmt|;
name|int
name|l_xcf
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_tmpname
operator|=
name|NULL
expr_stmt|;
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_gzip
operator|=
literal|0
expr_stmt|;
comment|/* dont zip */
name|l_xcf
operator|=
literal|0
expr_stmt|;
comment|/* assume no xcf format */
comment|/* check extension to decide if savd file will be zipped */
name|l_ext
operator|=
name|p_alloc_extension
argument_list|(
name|sav_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ext
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_ext
argument_list|,
literal|".xcf"
argument_list|)
condition|)
block|{
name|l_xcf
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_ext
argument_list|,
literal|".xcfgz"
argument_list|)
condition|)
block|{
name|l_gzip
operator|=
literal|1
expr_stmt|;
comment|/* zip it */
name|l_xcf
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_ext
argument_list|,
literal|".gz"
argument_list|)
condition|)
block|{
name|l_gzip
operator|=
literal|1
expr_stmt|;
comment|/* zip it */
block|}
comment|/* find a temp name     * that resides on the same filesystem as sav_name    * and has the same extension as the original sav_name     */
name|l_tmpname
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s.gtmp%s"
argument_list|,
name|sav_name
argument_list|,
name|l_ext
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|p_file_exists
argument_list|(
name|l_tmpname
argument_list|)
condition|)
block|{
comment|/* FILE exists: let gimp find another temp name */
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_temp_name"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
operator|&
name|l_ext
index|[
literal|1
index|]
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_params
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|!=
name|NULL
condition|)
block|{
name|l_tmpname
operator|=
name|l_params
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|l_ext
operator|=
name|g_getenv
argument_list|(
literal|"GAP_NO_SAVE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ext
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: GAP_NO_SAVE is set: save is skipped: '%s'\n"
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
comment|/* free if it was a temporary name */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: before   p_save_named_frame: '%s'\n"
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_xcf
operator|!=
literal|0
condition|)
block|{
comment|/* save current frame as xcf image      * xcf_save does operate on the complete image,      * the drawable is ignored. (we can supply a dummy value)      */
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_xcf_save"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|image_id
argument_list|,
name|GIMP_PDB_DRAWABLE
argument_list|,
literal|0
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|l_tmpname
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|l_tmpname
argument_list|,
comment|/* raw name ? */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: after   xcf  p_save_named_frame: '%s'\n"
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|GIMP_PDB_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"HOF gimp_xcf_save returned GIMP_PDB_SUCCESS\n"
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|image_id
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* let gimp try to save (and detect filetype by extension)       * Note: the most imagefileformats do not support multilayer       *       images, and extra channels       *       the result may not contain the whole imagedata       *       * To Do: Should warn the user at 1.st attempt to do this.       */
name|l_rc
operator|=
name|p_decide_save_as
argument_list|(
name|image_id
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_rc
operator|<
literal|0
condition|)
block|{
name|remove
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
comment|/* free temporary name */
return|return
name|l_rc
return|;
block|}
if|if
condition|(
name|l_gzip
operator|==
literal|0
condition|)
block|{
comment|/* remove sav_name, then rename tmpname ==> sav_name */
name|remove
argument_list|(
name|sav_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rename
argument_list|(
name|l_tmpname
argument_list|,
name|sav_name
argument_list|)
condition|)
block|{
comment|/* if tempname is located on another filesystem (errno == EXDEV)          * rename will not work.          * so lets try a  copy ; remove sequence          */
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: p_save_named_frame: RENAME 2nd try\n"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|p_file_copy
argument_list|(
name|l_tmpname
argument_list|,
name|sav_name
argument_list|)
condition|)
block|{
name|remove
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR in p_save_named_frame: cant rename %s to %s\n"
argument_list|,
name|l_tmpname
argument_list|,
name|sav_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* ZIP tmpname ==> sav_name */
if|if
condition|(
name|NULL
operator|!=
name|p_gzip
argument_list|(
name|l_tmpname
argument_list|,
name|sav_name
argument_list|,
literal|"zip"
argument_list|)
condition|)
block|{
comment|/* OK zip created compressed file named sav_name         * now delete the uncompressed l_tempname         */
name|remove
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
block|}
block|}
name|p_gimp_file_save_thumbnail
argument_list|(
name|image_id
argument_list|,
name|sav_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
comment|/* free temporary name */
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* end p_save_named_frame */
end_comment

begin_comment
comment|/* ============================================================================  * p_save_old_frame  * ============================================================================  */
end_comment

begin_function
DECL|function|p_save_old_frame (t_anim_info * ainfo_ptr)
name|int
name|p_save_old_frame
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
comment|/* (here we should check if image has unsaved changes    * before save)    */
if|if
condition|(
literal|1
condition|)
block|{
return|return
operator|(
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_save_old_frame */
end_comment

begin_comment
comment|/* ============================================================================  * p_load_image  * load image of any type by filename, and return its image id  * (or -1 in case of errors)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_load_image (char * lod_name)
name|gint32
name|p_load_image
parameter_list|(
name|char
modifier|*
name|lod_name
parameter_list|)
block|{
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|char
modifier|*
name|l_ext
decl_stmt|;
name|char
modifier|*
name|l_tmpname
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_tmpname
operator|=
name|NULL
expr_stmt|;
name|l_ext
operator|=
name|p_alloc_extension
argument_list|(
name|lod_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_ext
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_ext
argument_list|,
literal|".xcfgz"
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|l_ext
argument_list|,
literal|".gz"
argument_list|)
operator|)
condition|)
block|{
comment|/* find a temp name */
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_temp_name"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
operator|&
name|l_ext
index|[
literal|1
index|]
argument_list|,
comment|/* extension */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_params
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|!=
name|NULL
condition|)
block|{
comment|/* try to unzip file, before loading it */
name|l_tmpname
operator|=
name|p_gzip
argument_list|(
name|lod_name
argument_list|,
name|l_params
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
literal|"unzip"
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
block|}
else|else
name|l_tmpname
operator|=
name|lod_name
expr_stmt|;
name|g_free
argument_list|(
name|l_ext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_tmpname
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: before   p_load_image: '%s'\n"
argument_list|,
name|l_tmpname
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_file_load"
argument_list|,
comment|/* "gimp_xcf_load" */
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|GIMP_RUN_NONINTERACTIVE
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|l_tmpname
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
name|l_tmpname
argument_list|,
comment|/* raw name ? */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|l_tmp_image_id
operator|=
name|l_params
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: after    p_load_image: '%s' id=%d\n\n"
argument_list|,
name|l_tmpname
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmpname
operator|!=
name|lod_name
condition|)
block|{
name|remove
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_tmpname
argument_list|)
expr_stmt|;
comment|/* free if it was a temporary name */
block|}
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
return|return
name|l_tmp_image_id
return|;
block|}
end_function

begin_comment
comment|/* end p_load_image */
end_comment

begin_comment
comment|/* ============================================================================  * p_load_named_frame  * load new frame, replacing the existing image  * file must be of same type and size  * ============================================================================  */
end_comment

begin_function
DECL|function|p_load_named_frame (gint32 image_id,char * lod_name)
name|int
name|p_load_named_frame
parameter_list|(
name|gint32
name|image_id
parameter_list|,
name|char
modifier|*
name|lod_name
parameter_list|)
block|{
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|int
name|l_rc
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|lod_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: after    p_load_named_frame: '%s' id=%d  new_id=%d\n\n"
argument_list|,
name|lod_name
argument_list|,
operator|(
name|int
operator|)
name|image_id
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_tmp_image_id
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* replace image_id with the content of l_tmp_image_id */
if|if
condition|(
name|p_exchange_image
argument_list|(
name|image_id
argument_list|,
name|l_tmp_image_id
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* in case of errors the image will be trashed */
name|image_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* delete the temporary image (old content of the original image) */
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_load_named_frame: BEFORE gimp_image_delete %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|)
expr_stmt|;
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_load_named_frame: AFTER gimp_image_delete %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_tmp_image_id
argument_list|)
expr_stmt|;
comment|/* use the original lod_name */
name|gimp_image_set_filename
argument_list|(
name|image_id
argument_list|,
name|lod_name
argument_list|)
expr_stmt|;
comment|/* dont consider image dirty after load */
name|gimp_image_clean_all
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
return|return
name|image_id
return|;
block|}
end_function

begin_comment
comment|/* end p_load_named_frame */
end_comment

begin_comment
comment|/* ============================================================================  * p_replace_image  *  * make new_filename of next file to load, check if that file does exist on disk  * then save current image and replace it, by loading the new_filename  * ============================================================================  */
end_comment

begin_function
DECL|function|p_replace_image (t_anim_info * ainfo_ptr)
name|int
name|p_replace_image
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|)
block|{
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
literal|0
operator|==
name|p_file_exists
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p_save_old_frame
argument_list|(
name|ainfo_ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
operator|(
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_replace_image */
end_comment

begin_comment
comment|/* ============================================================================  * p_del  *  * delete cnt frames starting at current  * all following frames are renamed (renumbered down by cnt)   * ============================================================================  */
end_comment

begin_function
DECL|function|p_del (t_anim_info * ainfo_ptr,long cnt)
name|int
name|p_del
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|cnt
parameter_list|)
block|{
name|long
name|l_lo
decl_stmt|,
name|l_hi
decl_stmt|,
name|l_curr
decl_stmt|,
name|l_idx
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG  p_del\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|l_curr
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|+
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|-
name|l_curr
operator|)
operator|<
name|cnt
condition|)
block|{
comment|/* limt cnt to last existing frame */
name|cnt
operator|=
literal|1
operator|+
name|ainfo_ptr
operator|->
name|frame_cnt
operator|-
name|l_curr
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>=
name|ainfo_ptr
operator|->
name|frame_cnt
condition|)
block|{
comment|/* dont want to delete all frames        * so we have to leave a rest of one frame        */
name|cnt
operator|--
expr_stmt|;
block|}
name|l_idx
operator|=
name|l_curr
expr_stmt|;
while|while
condition|(
name|l_idx
operator|<
operator|(
name|l_curr
operator|+
name|cnt
operator|)
condition|)
block|{
name|p_delete_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_idx
argument_list|)
expr_stmt|;
name|l_idx
operator|++
expr_stmt|;
block|}
comment|/* rename (renumber) all frames with number greater than current     */
name|l_lo
operator|=
name|l_curr
expr_stmt|;
name|l_hi
operator|=
name|l_curr
operator|+
name|cnt
expr_stmt|;
while|while
condition|(
name|l_hi
operator|<=
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_hi
argument_list|,
name|l_lo
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|tmp_errtxt
decl_stmt|;
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|l_hi
argument_list|,
name|l_lo
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_lo
operator|++
expr_stmt|;
name|l_hi
operator|++
expr_stmt|;
block|}
comment|/* calculate how much frames are left */
name|ainfo_ptr
operator|->
name|frame_cnt
operator|-=
name|cnt
expr_stmt|;
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
operator|+
name|ainfo_ptr
operator|->
name|frame_cnt
operator|-
literal|1
expr_stmt|;
comment|/* set current position to previous frame (if there is one) */
if|if
condition|(
name|l_curr
operator|>
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|l_curr
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
block|}
comment|/* make filename, then load the new current frame */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
return|return
operator|(
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* end p_del */
end_comment

begin_comment
comment|/* ============================================================================  * p_dup  *  * all following frames are renamed (renumbered up by cnt)   * current frame is duplicated (cnt) times  * ============================================================================  */
end_comment

begin_function
DECL|function|p_dup (t_anim_info * ainfo_ptr,long cnt,long range_from,long range_to)
name|int
name|p_dup
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|cnt
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|)
block|{
name|long
name|l_lo
decl_stmt|,
name|l_hi
decl_stmt|;
name|long
name|l_cnt2
decl_stmt|;
name|long
name|l_step
decl_stmt|;
name|long
name|l_src_nr
decl_stmt|,
name|l_src_nr_min
decl_stmt|,
name|l_src_nr_max
decl_stmt|;
name|char
modifier|*
name|l_dup_name
decl_stmt|;
name|char
modifier|*
name|l_curr_name
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG  p_dup fr:%d to:%d cnt:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|range_from
argument_list|,
operator|(
name|int
operator|)
name|range_to
argument_list|,
operator|(
name|int
operator|)
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|l_curr_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
comment|/* save current frame  */
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|l_curr_name
argument_list|)
expr_stmt|;
comment|/* use a new name (0001.xcf Konvention) */
name|gimp_image_set_filename
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|l_curr_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_curr_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|range_from
operator|<
literal|0
operator|)
operator|&&
operator|(
name|range_to
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* set range to one single current frame        * (used for the old non_interactive PDB-interface without range params)        */
name|range_from
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|range_to
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
block|}
comment|/* clip range */
if|if
condition|(
name|range_from
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
name|range_from
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
if|if
condition|(
name|range_to
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
name|range_to
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
if|if
condition|(
name|range_from
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
name|range_from
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
name|range_to
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|range_from
condition|)
block|{
comment|/* invers range */
name|l_cnt2
operator|=
operator|(
operator|(
name|range_from
operator|-
name|range_to
operator|)
operator|+
literal|1
operator|)
operator|*
name|cnt
expr_stmt|;
name|l_step
operator|=
operator|-
literal|1
expr_stmt|;
name|l_src_nr_max
operator|=
name|range_from
expr_stmt|;
name|l_src_nr_min
operator|=
name|range_to
expr_stmt|;
block|}
else|else
block|{
name|l_cnt2
operator|=
operator|(
operator|(
name|range_to
operator|-
name|range_from
operator|)
operator|+
literal|1
operator|)
operator|*
name|cnt
expr_stmt|;
name|l_step
operator|=
literal|1
expr_stmt|;
name|l_src_nr_max
operator|=
name|range_to
expr_stmt|;
name|l_src_nr_min
operator|=
name|range_from
expr_stmt|;
block|}
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG  p_dup fr:%d to:%d cnt2:%d l_src_nr_max:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|range_from
argument_list|,
operator|(
name|int
operator|)
name|range_to
argument_list|,
operator|(
name|int
operator|)
name|l_cnt2
argument_list|,
operator|(
name|int
operator|)
name|l_src_nr_max
argument_list|)
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Duplicating frames..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* rename (renumber) all frames with number greater than current     */
name|l_lo
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|l_hi
operator|=
name|l_lo
operator|+
name|l_cnt2
expr_stmt|;
while|while
condition|(
name|l_lo
operator|>
name|l_src_nr_max
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_lo
argument_list|,
name|l_hi
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|tmp_errtxt
decl_stmt|;
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|l_lo
argument_list|,
name|l_hi
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_lo
operator|--
expr_stmt|;
name|l_hi
operator|--
expr_stmt|;
block|}
name|l_percentage_step
operator|=
literal|1.0
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|l_hi
operator|)
operator|-
name|l_src_nr_max
operator|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
comment|/* copy cnt duplicates */
name|l_src_nr
operator|=
name|range_to
expr_stmt|;
while|while
condition|(
name|l_hi
operator|>
name|l_src_nr_max
condition|)
block|{
name|l_curr_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_src_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_dup_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_hi
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_dup_name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|l_curr_name
operator|!=
name|NULL
operator|)
condition|)
block|{
name|p_image_file_copy
argument_list|(
name|l_curr_name
argument_list|,
name|l_dup_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_dup_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_curr_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
name|l_src_nr
operator|-=
name|l_step
expr_stmt|;
if|if
condition|(
name|l_src_nr
operator|<
name|l_src_nr_min
condition|)
name|l_src_nr
operator|=
name|l_src_nr_max
expr_stmt|;
if|if
condition|(
name|l_src_nr
operator|>
name|l_src_nr_max
condition|)
name|l_src_nr
operator|=
name|l_src_nr_min
expr_stmt|;
name|l_hi
operator|--
expr_stmt|;
block|}
comment|/* restore current position */
name|ainfo_ptr
operator|->
name|frame_cnt
operator|+=
name|l_cnt2
expr_stmt|;
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
operator|+
name|ainfo_ptr
operator|->
name|frame_cnt
operator|-
literal|1
expr_stmt|;
comment|/* load from the "new" current frame */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_dup */
end_comment

begin_comment
comment|/* ============================================================================  * p_exchg  *  * save current frame, exchange its name with destination frame on disk   * and reload current frame (now has contents of dest. and vice versa)  * ============================================================================  */
end_comment

begin_function
DECL|function|p_exchg (t_anim_info * ainfo_ptr,long dest)
name|int
name|p_exchg
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|dest
parameter_list|)
block|{
name|long
name|l_tmp_nr
decl_stmt|;
name|gchar
modifier|*
name|tmp_errtxt
decl_stmt|;
name|l_tmp_nr
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|+
literal|4
expr_stmt|;
comment|/* use a free frame_nr for temp name */
if|if
condition|(
operator|(
name|dest
operator|<
literal|1
operator|)
operator|||
operator|(
name|dest
operator|==
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|old_filename
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* rename (renumber) frames */
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|dest
argument_list|,
name|l_tmp_nr
argument_list|)
condition|)
block|{
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|dest
argument_list|,
name|l_tmp_nr
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|dest
argument_list|)
condition|)
block|{
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_tmp_nr
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|)
condition|)
block|{
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|l_tmp_nr
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* load from the "new" current frame */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_exchg */
end_comment

begin_comment
comment|/* ============================================================================  * p_shift  *  * all frmaes in the given range are renumbered (shifted)  * according to cnt:  *  example:  cnt == 1 :  range before 3, 4, 5, 6, 7  *                        range after  4, 5, 6, 7, 3  * ============================================================================  */
end_comment

begin_function
specifier|static
name|int
DECL|function|p_shift (t_anim_info * ainfo_ptr,long cnt,long range_from,long range_to)
name|p_shift
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
name|cnt
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|)
block|{
name|long
name|l_lo
decl_stmt|,
name|l_hi
decl_stmt|,
name|l_curr
decl_stmt|,
name|l_dst
decl_stmt|;
name|long
name|l_upper
decl_stmt|;
name|long
name|l_shift
decl_stmt|;
name|gchar
modifier|*
name|l_curr_name
decl_stmt|;
name|gchar
modifier|*
name|tmp_errtxt
decl_stmt|;
name|gdouble
name|l_percentage
decl_stmt|,
name|l_percentage_step
decl_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG  p_shift fr:%d to:%d cnt:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|range_from
argument_list|,
operator|(
name|int
operator|)
name|range_to
argument_list|,
operator|(
name|int
operator|)
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_from
operator|==
name|range_to
condition|)
return|return
operator|-
literal|1
return|;
comment|/* clip range */
if|if
condition|(
name|range_from
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
name|range_from
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
if|if
condition|(
name|range_to
operator|>
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
name|range_to
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
if|if
condition|(
name|range_from
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
name|range_from
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|ainfo_ptr
operator|->
name|first_frame_nr
condition|)
name|range_to
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
if|if
condition|(
name|range_to
operator|<
name|range_from
condition|)
block|{
name|l_lo
operator|=
name|range_to
expr_stmt|;
name|l_hi
operator|=
name|range_from
expr_stmt|;
block|}
else|else
block|{
name|l_lo
operator|=
name|range_from
expr_stmt|;
name|l_hi
operator|=
name|range_to
expr_stmt|;
block|}
comment|/* limit shift  amount to number of frames in range */
name|l_shift
operator|=
name|cnt
operator|%
operator|(
name|l_hi
operator|-
name|l_lo
operator|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG  p_shift shift:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_shift
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|l_curr_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
comment|/* save current frame  */
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|l_curr_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_curr_name
argument_list|)
expr_stmt|;
name|l_percentage
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Renumber Framesequence..."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* rename (renumber) all frames (using high numbers)     */
name|l_upper
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|+
literal|100
expr_stmt|;
name|l_percentage_step
operator|=
literal|0.5
operator|/
operator|(
operator|(
literal|1.0
operator|+
name|l_lo
operator|)
operator|-
name|l_hi
operator|)
expr_stmt|;
for|for
control|(
name|l_curr
operator|=
name|l_lo
init|;
name|l_curr
operator|<=
name|l_hi
condition|;
name|l_curr
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_curr
argument_list|,
name|l_curr
operator|+
name|l_upper
argument_list|)
condition|)
block|{
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|l_lo
argument_list|,
name|l_hi
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* rename (renumber) all frames (using desied destination numbers)     */
name|l_dst
operator|=
name|l_lo
operator|+
name|l_shift
expr_stmt|;
if|if
condition|(
name|l_dst
operator|>
name|l_hi
condition|)
block|{
name|l_dst
operator|-=
operator|(
name|l_lo
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|l_dst
operator|<
name|l_lo
condition|)
block|{
name|l_dst
operator|+=
operator|(
operator|(
name|l_hi
operator|-
name|l_lo
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
for|for
control|(
name|l_curr
operator|=
name|l_upper
operator|+
name|l_lo
init|;
name|l_curr
operator|<=
name|l_upper
operator|+
name|l_hi
condition|;
name|l_curr
operator|++
control|)
block|{
if|if
condition|(
name|l_dst
operator|>
name|l_hi
condition|)
block|{
name|l_dst
operator|=
name|l_lo
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_curr
argument_list|,
name|l_dst
argument_list|)
condition|)
block|{
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|l_lo
argument_list|,
name|l_hi
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ainfo_ptr
operator|->
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_percentage
operator|+=
name|l_percentage_step
expr_stmt|;
name|gimp_progress_update
argument_list|(
name|l_percentage
argument_list|)
expr_stmt|;
block|}
name|l_dst
operator|++
expr_stmt|;
block|}
comment|/* load from the "new" current frame */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end p_shift */
end_comment

begin_comment
comment|/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
end_comment

begin_comment
comment|/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
end_comment

begin_comment
comment|/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
end_comment

begin_comment
comment|/* ============================================================================  * gap_next gap_prev  *  * store the current Gimp Image to the current anim Frame  * and load it from the next/prev anim Frame on disk.  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_next (GimpRunModeType run_mode,gint32 image_id)
name|int
name|gap_next
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|+
literal|1
expr_stmt|;
name|rc
operator|=
name|p_replace_image
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_next */
end_comment

begin_function
DECL|function|gap_prev (GimpRunModeType run_mode,gint32 image_id)
name|int
name|gap_prev
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|-
literal|1
expr_stmt|;
name|rc
operator|=
name|p_replace_image
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_prev */
end_comment

begin_comment
comment|/* ============================================================================  * gap_first  gap_last  *  * store the current Gimp Image to the current anim Frame  * and load it from the first/last anim Frame on disk.  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_first (GimpRunModeType run_mode,gint32 image_id)
name|int
name|gap_first
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|rc
operator|=
name|p_replace_image
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_first */
end_comment

begin_function
DECL|function|gap_last (GimpRunModeType run_mode,gint32 image_id)
name|int
name|gap_last
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|rc
operator|=
name|p_replace_image
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_last */
end_comment

begin_comment
comment|/* ============================================================================  * gap_goto  *   * store the current Gimp Image to disk  * and load it from the anim Frame on disk that has the specified frame Nr.  * GIMP_RUN_INTERACTIVE:  *    show dialogwindow where user can enter the destination frame Nr.  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_goto (GimpRunModeType run_mode,gint32 image_id,int nr)
name|int
name|gap_goto
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|int
name|nr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|long
name|l_dest
decl_stmt|;
name|gchar
modifier|*
name|l_hline
decl_stmt|;
name|gchar
modifier|*
name|l_title
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_title
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Goto Frame (%ld/%ld)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|frame_cnt
argument_list|)
expr_stmt|;
name|l_hline
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Destination Frame Number (%ld  - %ld)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|first_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|last_frame_nr
argument_list|)
expr_stmt|;
name|l_dest
operator|=
name|p_slider_dialog
argument_list|(
name|l_title
argument_list|,
name|l_hline
argument_list|,
name|_
argument_list|(
literal|"Number:"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ainfo_ptr
operator|->
name|first_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|last_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_hline
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_dest
operator|<
literal|0
condition|)
block|{
comment|/* Cancel button: go back to current frame */
name|l_dest
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_dest
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_dest
operator|=
name|nr
expr_stmt|;
block|}
if|if
condition|(
name|l_dest
operator|>=
literal|0
condition|)
block|{
name|ainfo_ptr
operator|->
name|frame_nr
operator|=
name|l_dest
expr_stmt|;
name|rc
operator|=
name|p_replace_image
argument_list|(
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_goto */
end_comment

begin_comment
comment|/* ============================================================================  * gap_del  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_del (GimpRunModeType run_mode,gint32 image_id,int nr)
name|int
name|gap_del
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|int
name|nr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|long
name|l_cnt
decl_stmt|;
name|long
name|l_max
decl_stmt|;
name|gchar
modifier|*
name|l_hline
decl_stmt|;
name|gchar
modifier|*
name|l_title
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_title
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Delete Frames (%ld/%ld)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|frame_cnt
argument_list|)
expr_stmt|;
name|l_hline
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Delete Frames from %ld to (number)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|)
expr_stmt|;
name|l_max
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
if|if
condition|(
name|l_max
operator|==
name|ainfo_ptr
operator|->
name|curr_frame_nr
condition|)
block|{
comment|/* bugfix: the slider needs a maximum> minimum            *         (if not an error is printed, and            *          a default range 0 to 100 is displayed)            */
name|l_max
operator|++
expr_stmt|;
block|}
name|l_cnt
operator|=
name|p_slider_dialog
argument_list|(
name|l_title
argument_list|,
name|l_hline
argument_list|,
name|_
argument_list|(
literal|"Number:"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|l_max
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_hline
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_cnt
operator|>=
literal|0
condition|)
block|{
name|l_cnt
operator|=
literal|1
operator|+
name|l_cnt
operator|-
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_cnt
operator|=
name|nr
expr_stmt|;
block|}
if|if
condition|(
name|l_cnt
operator|>=
literal|0
condition|)
block|{
comment|/* delete l_cnt number of frames (-1 CANCEL button) */
name|rc
operator|=
name|p_del
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_cnt
argument_list|)
expr_stmt|;
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_del */
end_comment

begin_comment
comment|/* ============================================================================  * p_dup_dialog  *  * ============================================================================  */
end_comment

begin_function
DECL|function|p_dup_dialog (t_anim_info * ainfo_ptr,long * range_from,long * range_to)
name|int
name|p_dup_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
modifier|*
name|range_from
parameter_list|,
name|long
modifier|*
name|range_to
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|gchar
modifier|*
name|l_title
decl_stmt|;
name|l_title
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Duplicate Frames (%ld/%ld)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|frame_cnt
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Source Range starts at this framenumber"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Source Range ends at this framenumber"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"N times:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|FALSE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
literal|99
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|umin
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|umax
operator|=
literal|9999
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Copy selected Range n-times  \n(you may type in Values> 99)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|l_title
argument_list|,
name|_
argument_list|(
literal|"Duplicate Frame Range"
argument_list|)
argument_list|,
literal|3
argument_list|,
name|argv
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
operator|*
name|range_from
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|range_to
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
return|;
block|}
else|else
block|{
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_dup_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * gap_dup  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_dup (GimpRunModeType run_mode,gint32 image_id,int nr,long range_from,long range_to)
name|int
name|gap_dup
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|int
name|nr
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|long
name|l_cnt
decl_stmt|,
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l_cnt
operator|=
name|p_dup_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
operator|)
operator|||
operator|(
name|l_cnt
operator|<
literal|1
operator|)
condition|)
block|{
name|l_cnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_cnt
operator|=
name|nr
expr_stmt|;
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
block|}
if|if
condition|(
name|l_cnt
operator|>
literal|0
condition|)
block|{
comment|/* make l_cnt duplicate frames (on disk) */
name|rc
operator|=
name|p_dup
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_cnt
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|)
expr_stmt|;
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_dup */
end_comment

begin_comment
comment|/* ============================================================================  * gap_exchg  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_exchg (GimpRunModeType run_mode,gint32 image_id,int nr)
name|int
name|gap_exchg
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|int
name|nr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|long
name|l_dest
decl_stmt|;
name|long
name|l_initial
decl_stmt|;
name|gchar
modifier|*
name|l_title
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|l_initial
operator|=
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_chk_framerange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
if|if
condition|(
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|<
name|ainfo_ptr
operator|->
name|last_frame_nr
condition|)
block|{
name|l_initial
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l_initial
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
block|}
name|l_title
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Exchange current Frame (%ld)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|)
expr_stmt|;
name|l_dest
operator|=
name|p_slider_dialog
argument_list|(
name|l_title
argument_list|,
name|_
argument_list|(
literal|"With Frame (number)"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Number:"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ainfo_ptr
operator|->
name|first_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|last_frame_nr
argument_list|,
name|l_initial
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_dest
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_dest
operator|=
name|nr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|l_dest
operator|>=
name|ainfo_ptr
operator|->
name|first_frame_nr
operator|)
operator|&&
operator|(
name|l_dest
operator|<=
name|ainfo_ptr
operator|->
name|last_frame_nr
operator|)
condition|)
block|{
comment|/* excange current frames with destination frame (on disk) */
name|rc
operator|=
name|p_exchg
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_dest
argument_list|)
expr_stmt|;
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_exchg */
end_comment

begin_comment
comment|/* ============================================================================  * p_shift_dialog  *  * ============================================================================  */
end_comment

begin_function
DECL|function|p_shift_dialog (t_anim_info * ainfo_ptr,long * range_from,long * range_to)
name|int
name|p_shift_dialog
parameter_list|(
name|t_anim_info
modifier|*
name|ainfo_ptr
parameter_list|,
name|long
modifier|*
name|range_from
parameter_list|,
name|long
modifier|*
name|range_to
parameter_list|)
block|{
specifier|static
name|t_arr_arg
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|gchar
modifier|*
name|l_title
decl_stmt|;
name|l_title
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Framesequence Shift (%ld/%ld)"
argument_list|)
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|frame_cnt
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"From:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Affected Range starts at this framenumber"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"To:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_min
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|first_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Affected Range ends at this framenumber"
argument_list|)
expr_stmt|;
name|p_init_arr_arg
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|WGT_INT_PAIR
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|label_txt
operator|=
name|_
argument_list|(
literal|"N-Shift:"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|constraint
operator|=
name|TRUE
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_min
operator|=
operator|-
literal|1
operator|*
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_max
operator|=
operator|(
name|gint
operator|)
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|.
name|help_txt
operator|=
name|_
argument_list|(
literal|"Renumber the affected framesequence     \n(numbers are shifted in circle by N)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|p_array_dialog
argument_list|(
name|l_title
argument_list|,
name|_
argument_list|(
literal|"Framesequence shift"
argument_list|)
argument_list|,
literal|3
argument_list|,
name|argv
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
operator|*
name|range_from
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|0
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
operator|*
name|range_to
operator|=
call|(
name|long
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
operator|.
name|int_ret
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|argv
index|[
literal|2
index|]
operator|.
name|int_ret
argument_list|)
return|;
block|}
else|else
block|{
name|g_free
argument_list|(
name|l_title
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* end p_shift_dialog */
end_comment

begin_comment
comment|/* ============================================================================  * gap_shift  * ============================================================================  */
end_comment

begin_function
DECL|function|gap_shift (GimpRunModeType run_mode,gint32 image_id,int nr,long range_from,long range_to)
name|int
name|gap_shift
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|int
name|nr
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|long
name|l_cnt
decl_stmt|,
name|l_from
decl_stmt|,
name|l_to
decl_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|run_mode
operator|==
name|GIMP_RUN_INTERACTIVE
condition|)
block|{
name|l_cnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
name|l_cnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|l_cnt
operator|=
name|p_shift_dialog
argument_list|(
name|ainfo_ptr
argument_list|,
operator|&
name|l_from
argument_list|,
operator|&
name|l_to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0
operator|!=
name|p_chk_framechange
argument_list|(
name|ainfo_ptr
argument_list|)
operator|)
operator|||
operator|(
name|l_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|l_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_cnt
operator|=
name|nr
expr_stmt|;
name|l_from
operator|=
name|range_from
expr_stmt|;
name|l_to
operator|=
name|range_to
expr_stmt|;
block|}
if|if
condition|(
name|l_cnt
operator|!=
literal|0
condition|)
block|{
comment|/* shift framesquence by l_cnt frames            * (rename all frames in the given range on disk)           */
name|rc
operator|=
name|p_shift
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_cnt
argument_list|,
name|l_from
argument_list|,
name|l_to
argument_list|)
expr_stmt|;
block|}
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_shift */
end_comment

begin_comment
comment|/* ============================================================================  * gap_video_paste Buffer procedures  * ============================================================================  */
end_comment

begin_function
name|gchar
modifier|*
DECL|function|p_get_video_paste_basename (void)
name|p_get_video_paste_basename
parameter_list|(
name|void
parameter_list|)
block|{
name|gchar
modifier|*
name|l_basename
decl_stmt|;
name|l_basename
operator|=
name|p_gimp_gimprc_query
argument_list|(
literal|"video-paste-basename"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_basename
operator|==
name|NULL
condition|)
block|{
name|l_basename
operator|=
name|g_strdup
argument_list|(
literal|"gap_video_pastebuffer_"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l_basename
operator|)
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|p_get_video_paste_dir (void)
name|p_get_video_paste_dir
parameter_list|(
name|void
parameter_list|)
block|{
name|gchar
modifier|*
name|l_dir
decl_stmt|;
name|gint
name|l_len
decl_stmt|;
name|l_dir
operator|=
name|p_gimp_gimprc_query
argument_list|(
literal|"video-paste-dir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_dir
operator|==
name|NULL
condition|)
block|{
name|l_dir
operator|=
name|g_strdup
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
block|}
comment|/* if dir is configured with trailing dir seprator slash    * then cut it off    */
name|l_len
operator|=
name|strlen
argument_list|(
name|l_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l_dir
index|[
name|l_len
operator|-
literal|1
index|]
operator|==
name|G_DIR_SEPARATOR
operator|)
operator|&&
operator|(
name|l_len
operator|>
literal|1
operator|)
condition|)
block|{
name|l_dir
index|[
name|l_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|l_dir
operator|)
return|;
block|}
end_function

begin_function
name|gchar
modifier|*
DECL|function|p_get_video_paste_name (void)
name|p_get_video_paste_name
parameter_list|(
name|void
parameter_list|)
block|{
name|gchar
modifier|*
name|l_dir
decl_stmt|;
name|gchar
modifier|*
name|l_basename
decl_stmt|;
name|gchar
modifier|*
name|l_video_name
decl_stmt|;
name|gchar
modifier|*
name|l_dir_thumb
decl_stmt|;
name|l_dir
operator|=
name|p_get_video_paste_dir
argument_list|()
expr_stmt|;
name|l_basename
operator|=
name|p_get_video_paste_basename
argument_list|()
expr_stmt|;
name|l_video_name
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s%s"
argument_list|,
name|l_dir
argument_list|,
name|G_DIR_SEPARATOR_S
argument_list|,
name|l_basename
argument_list|)
expr_stmt|;
name|l_dir_thumb
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s%s"
argument_list|,
name|l_dir
argument_list|,
name|G_DIR_SEPARATOR_S
argument_list|,
literal|".xvpics"
argument_list|)
expr_stmt|;
name|mkdir
argument_list|(
name|l_dir_thumb
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_dir
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_basename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_dir_thumb
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_get_video_paste_name: %s\n"
argument_list|,
name|l_video_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_video_name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|p_clear_or_count_video_paste (gint delete_flag)
name|p_clear_or_count_video_paste
parameter_list|(
name|gint
name|delete_flag
parameter_list|)
block|{
name|gchar
modifier|*
name|l_dir
decl_stmt|;
name|gchar
modifier|*
name|l_basename
decl_stmt|;
name|gchar
modifier|*
name|l_filename
decl_stmt|;
name|gchar
modifier|*
name|l_fname_thumbnail
decl_stmt|;
name|gint
name|l_len
decl_stmt|;
name|gint32
name|l_framecount
decl_stmt|;
name|DIR
modifier|*
name|l_dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|l_dp
decl_stmt|;
name|l_dir
operator|=
name|p_get_video_paste_dir
argument_list|()
expr_stmt|;
name|l_dirp
operator|=
name|opendir
argument_list|(
name|l_dir
argument_list|)
expr_stmt|;
name|l_framecount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|l_dirp
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR p_vid_edit_clear: cant read directory %s\n"
argument_list|,
name|l_dir
argument_list|)
expr_stmt|;
name|l_framecount
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l_basename
operator|=
name|p_get_video_paste_basename
argument_list|()
expr_stmt|;
name|l_len
operator|=
name|strlen
argument_list|(
name|l_basename
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|l_dp
operator|=
name|readdir
argument_list|(
name|l_dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|l_basename
argument_list|,
name|l_dp
operator|->
name|d_name
argument_list|,
name|l_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l_filename
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%s%s"
argument_list|,
name|l_dir
argument_list|,
name|G_DIR_SEPARATOR_S
argument_list|,
name|l_dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|p_file_exists
argument_list|(
name|l_filename
argument_list|)
condition|)
comment|/* check for regular file */
block|{
comment|/* delete all files in the video paste directory 	      * with names matching the basename part 	      */
name|l_framecount
operator|++
expr_stmt|;
if|if
condition|(
name|delete_flag
condition|)
block|{
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"p_vid_edit_clear: remove file %s\n"
argument_list|,
name|l_filename
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
comment|/* also delete thumbnail */
name|l_fname_thumbnail
operator|=
name|p_alloc_fname_thumbnail
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|l_fname_thumbnail
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_fname_thumbnail
argument_list|)
expr_stmt|;
block|}
block|}
name|g_free
argument_list|(
name|l_filename
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|l_dirp
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_basename
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|l_framecount
operator|)
return|;
block|}
end_function

begin_function
name|gint32
DECL|function|p_vid_edit_clear (void)
name|p_vid_edit_clear
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|p_clear_or_count_video_paste
argument_list|(
name|TRUE
argument_list|)
operator|)
return|;
comment|/* delete frames */
block|}
end_function

begin_function
name|gint32
DECL|function|p_vid_edit_framecount ()
name|p_vid_edit_framecount
parameter_list|()
block|{
return|return
operator|(
name|p_clear_or_count_video_paste
argument_list|(
name|FALSE
argument_list|)
operator|)
return|;
comment|/* delete_flag is off, just count frames */
block|}
end_function

begin_comment
comment|/* ============================================================================  * gap_vid_edit_copy  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|gap_vid_edit_copy (GimpRunModeType run_mode,gint32 image_id,long range_from,long range_to)
name|gap_vid_edit_copy
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|range_from
parameter_list|,
name|long
name|range_to
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gchar
modifier|*
name|l_curr_name
decl_stmt|;
name|gchar
modifier|*
name|l_fname
decl_stmt|;
name|gchar
modifier|*
name|l_fname_copy
decl_stmt|;
name|gchar
modifier|*
name|l_basename
decl_stmt|;
name|gint32
name|l_frame_nr
decl_stmt|;
name|gint32
name|l_cnt_range
decl_stmt|;
name|gint32
name|l_cnt2
decl_stmt|;
name|gint32
name|l_idx
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|>=
name|MIN
argument_list|(
name|range_to
argument_list|,
name|range_from
argument_list|)
operator|)
operator|&&
operator|(
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|<=
name|MAX
argument_list|(
name|range_to
argument_list|,
name|range_from
argument_list|)
operator|)
condition|)
block|{
comment|/* current frame is in the affected range      * so we have to save current frame to file      */
name|l_curr_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|l_curr_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_curr_name
argument_list|)
expr_stmt|;
block|}
name|l_basename
operator|=
name|p_get_video_paste_name
argument_list|()
expr_stmt|;
name|l_cnt2
operator|=
name|p_vid_edit_framecount
argument_list|()
expr_stmt|;
comment|/* count frames in the video paste buffer */
name|l_frame_nr
operator|=
literal|1
operator|+
name|l_cnt2
expr_stmt|;
comment|/* start at one, or continue (append) at end +1 */
name|l_cnt_range
operator|=
literal|1
operator|+
name|MAX
argument_list|(
name|range_to
argument_list|,
name|range_from
argument_list|)
operator|-
name|MIN
argument_list|(
name|range_to
argument_list|,
name|range_from
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|0
init|;
name|l_idx
operator|<
name|l_cnt_range
condition|;
name|l_idx
operator|++
control|)
block|{
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|l_fname
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|MIN
argument_list|(
name|range_to
argument_list|,
name|range_from
argument_list|)
operator|+
name|l_idx
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_fname_copy
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%04ld.xcf"
argument_list|,
name|l_basename
argument_list|,
operator|(
name|long
operator|)
name|l_frame_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ainfo_ptr
operator|->
name|extension
argument_list|,
literal|".xcf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|p_image_file_copy
argument_list|(
name|l_fname
argument_list|,
name|l_fname_copy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* convert other fileformats to xcf before saving to video paste buffer */
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
name|rc
operator|=
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_fname_copy
argument_list|)
expr_stmt|;
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_fname_copy
argument_list|)
expr_stmt|;
name|l_frame_nr
operator|++
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_vid_edit_copy */
end_comment

begin_comment
comment|/* ============================================================================  * p_custom_palette_file  *   write a gimp palette file  * ============================================================================  */
end_comment

begin_function
DECL|function|p_custom_palette_file (char * filename,guchar * rgb,gint count)
specifier|static
name|gint
name|p_custom_palette_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|guchar
modifier|*
name|rgb
parameter_list|,
name|gint
name|count
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"GIMP Palette\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"# this file will be overwritten each time when video frames are converted to INDEXED\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"%d %d %d\tUnknown\n"
argument_list|,
name|rgb
index|[
literal|0
index|]
argument_list|,
name|rgb
index|[
literal|1
index|]
argument_list|,
name|rgb
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end p_custom_palette_file */
end_comment

begin_comment
comment|/* ============================================================================  * gap_vid_edit_paste  * ============================================================================  */
end_comment

begin_function
name|gint
DECL|function|gap_vid_edit_paste (GimpRunModeType run_mode,gint32 image_id,long paste_mode)
name|gap_vid_edit_paste
parameter_list|(
name|GimpRunModeType
name|run_mode
parameter_list|,
name|gint32
name|image_id
parameter_list|,
name|long
name|paste_mode
parameter_list|)
block|{
DECL|macro|CUSTOM_PALETTE_NAME
define|#
directive|define
name|CUSTOM_PALETTE_NAME
value|"gap_cmap"
name|int
name|rc
decl_stmt|;
name|t_anim_info
modifier|*
name|ainfo_ptr
decl_stmt|;
name|gchar
modifier|*
name|l_curr_name
decl_stmt|;
name|gchar
modifier|*
name|l_fname
decl_stmt|;
name|gchar
modifier|*
name|l_fname_copy
decl_stmt|;
name|gchar
modifier|*
name|l_basename
decl_stmt|;
name|gint32
name|l_frame_nr
decl_stmt|;
name|gint32
name|l_dst_frame_nr
decl_stmt|;
name|gint32
name|l_cnt2
decl_stmt|;
name|gint32
name|l_lo
decl_stmt|,
name|l_hi
decl_stmt|;
name|gint32
name|l_insert_frame_nr
decl_stmt|;
name|gint32
name|l_tmp_image_id
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|GimpImageBaseType
name|l_orig_basetype
decl_stmt|;
name|l_cnt2
operator|=
name|p_vid_edit_framecount
argument_list|()
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"gap_vid_edit_paste: paste_mode %d found %d frames to paste\n"
argument_list|,
operator|(
name|int
operator|)
name|paste_mode
argument_list|,
operator|(
name|int
operator|)
name|l_cnt2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_cnt2
operator|<
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* video paste buffer is empty */
block|}
name|ainfo_ptr
operator|=
name|p_alloc_ainfo
argument_list|(
name|image_id
argument_list|,
name|run_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainfo_ptr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
literal|0
operator|!=
name|p_dir_ainfo
argument_list|(
name|ainfo_ptr
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rc
operator|=
literal|0
expr_stmt|;
name|l_insert_frame_nr
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
expr_stmt|;
if|if
condition|(
name|paste_mode
operator|!=
name|VID_PASTE_INSERT_AFTER
condition|)
block|{
comment|/* we have to save current frame to file */
name|l_curr_name
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|p_save_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|l_curr_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_curr_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paste_mode
operator|!=
name|VID_PASTE_REPLACE
condition|)
block|{
if|if
condition|(
name|paste_mode
operator|==
name|VID_PASTE_INSERT_AFTER
condition|)
block|{
name|l_insert_frame_nr
operator|=
name|ainfo_ptr
operator|->
name|curr_frame_nr
operator|+
literal|1
expr_stmt|;
block|}
comment|/* rename (renumber) all frames with number greater (or greater equal)  than current       */
name|l_lo
operator|=
name|ainfo_ptr
operator|->
name|last_frame_nr
expr_stmt|;
name|l_hi
operator|=
name|l_lo
operator|+
name|l_cnt2
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"gap_vid_edit_paste: l_insert_frame_nr %d l_lo:%d l_hi:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_insert_frame_nr
argument_list|,
operator|(
name|int
operator|)
name|l_lo
argument_list|,
operator|(
name|int
operator|)
name|l_hi
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|l_lo
operator|>=
name|l_insert_frame_nr
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|p_rename_frame
argument_list|(
name|ainfo_ptr
argument_list|,
name|l_lo
argument_list|,
name|l_hi
argument_list|)
condition|)
block|{
name|gchar
modifier|*
name|tmp_errtxt
decl_stmt|;
name|tmp_errtxt
operator|=
name|g_strdup_printf
argument_list|(
name|_
argument_list|(
literal|"Error: could not rename frame %ld to %ld"
argument_list|)
argument_list|,
name|l_lo
argument_list|,
name|l_hi
argument_list|)
expr_stmt|;
name|p_msg_win
argument_list|(
name|ainfo_ptr
operator|->
name|run_mode
argument_list|,
name|tmp_errtxt
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_errtxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_lo
operator|--
expr_stmt|;
name|l_hi
operator|--
expr_stmt|;
block|}
block|}
name|l_basename
operator|=
name|p_get_video_paste_name
argument_list|()
expr_stmt|;
name|l_dst_frame_nr
operator|=
name|l_insert_frame_nr
expr_stmt|;
for|for
control|(
name|l_frame_nr
operator|=
literal|1
init|;
name|l_frame_nr
operator|<=
name|l_cnt2
condition|;
name|l_frame_nr
operator|++
control|)
block|{
name|l_fname
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|l_dst_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|l_fname_copy
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%04ld.xcf"
argument_list|,
name|l_basename
argument_list|,
operator|(
name|long
operator|)
name|l_frame_nr
argument_list|)
expr_stmt|;
name|l_tmp_image_id
operator|=
name|p_load_image
argument_list|(
name|l_fname_copy
argument_list|)
expr_stmt|;
comment|/* check size and resize if needed */
if|if
condition|(
operator|(
name|gimp_image_width
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|!=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
operator|)
operator|||
operator|(
name|gimp_image_height
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|!=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
operator|)
condition|)
block|{
name|GimpParam
modifier|*
name|l_params
decl_stmt|;
name|gint
name|l_retvals
decl_stmt|;
name|gint32
name|l_size_x
decl_stmt|,
name|l_size_y
decl_stmt|;
name|l_size_x
operator|=
name|gimp_image_width
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
name|l_size_y
operator|=
name|gimp_image_height
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: scale to size %d %d\n"
argument_list|,
operator|(
name|int
operator|)
name|l_size_x
argument_list|,
operator|(
name|int
operator|)
name|l_size_y
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_image_scale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_x
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
name|l_size_y
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
block|}
comment|/* check basetype and convert if needed */
name|l_orig_basetype
operator|=
name|gimp_image_base_type
argument_list|(
name|image_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimp_image_base_type
argument_list|(
name|l_tmp_image_id
argument_list|)
operator|!=
name|l_orig_basetype
condition|)
block|{
switch|switch
condition|(
name|l_orig_basetype
condition|)
block|{
name|gchar
modifier|*
name|l_palette_filename
decl_stmt|;
name|gchar
modifier|*
name|l_gimp_dir
decl_stmt|;
name|guchar
modifier|*
name|l_cmap
decl_stmt|;
name|gint
name|l_ncolors
decl_stmt|;
comment|/* convert tmp image to dest type */
case|case
name|GIMP_INDEXED
case|:
name|l_cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_id
argument_list|,
operator|&
name|l_ncolors
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: convert to INDEXED %d colors\n"
argument_list|,
operator|(
name|int
operator|)
name|l_ncolors
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_gimprc_query"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_STRING
argument_list|,
literal|"gimp_dir"
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|l_gimp_dir
operator|=
name|g_strdup
argument_list|(
name|l_params
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|l_params
argument_list|,
name|l_retvals
argument_list|)
expr_stmt|;
name|l_palette_filename
operator|=
name|g_strdup_printf
argument_list|(
literal|"%s%spalettes%s%s"
argument_list|,
name|l_gimp_dir
argument_list|,
name|G_DIR_SEPARATOR_S
argument_list|,
name|G_DIR_SEPARATOR_S
argument_list|,
name|CUSTOM_PALETTE_NAME
argument_list|)
expr_stmt|;
name|l_rc
operator|=
name|p_custom_palette_file
argument_list|(
name|l_palette_filename
argument_list|,
name|l_cmap
argument_list|,
name|l_ncolors
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_rc
operator|==
literal|0
condition|)
block|{
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_palette_refresh"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|l_params
argument_list|,
name|l_retvals
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_indexed"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|GIMP_PDB_INT32
argument_list|,
literal|1
argument_list|,
comment|/* dither  value 1== floyd-steinberg */
name|GIMP_PDB_INT32
argument_list|,
literal|4
argument_list|,
comment|/* palette_type 4 == CUSTOM_PALETTE */
name|GIMP_PDB_INT32
argument_list|,
name|l_ncolors
argument_list|,
comment|/* number of colors */
name|GIMP_PDB_INT32
argument_list|,
literal|0
argument_list|,
comment|/* alpha_dither */
name|GIMP_PDB_INT32
argument_list|,
literal|0
argument_list|,
comment|/* remove_unused */
name|GIMP_PDB_STRING
argument_list|,
name|CUSTOM_PALETTE_NAME
argument_list|,
comment|/* name of the custom palette */
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|l_params
argument_list|,
name|l_retvals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ERROR: gap_vid_edit_paste: could not save custom palette %s\n"
argument_list|,
name|l_palette_filename
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|l_cmap
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_palette_filename
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_gimp_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_GRAY
case|:
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: convert to GRAY'\n"
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_grayscale"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|l_params
argument_list|,
name|l_retvals
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_RGB
case|:
if|if
condition|(
name|gap_debug
condition|)
name|printf
argument_list|(
literal|"DEBUG: convert to RGB'\n"
argument_list|)
expr_stmt|;
name|l_params
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_rgb"
argument_list|,
operator|&
name|l_retvals
argument_list|,
name|GIMP_PDB_IMAGE
argument_list|,
name|l_tmp_image_id
argument_list|,
name|GIMP_PDB_END
argument_list|)
expr_stmt|;
name|gimp_destroy_params
argument_list|(
name|l_params
argument_list|,
name|l_retvals
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"DEBUG: unknown image type\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
block|}
name|rc
operator|=
name|p_save_named_frame
argument_list|(
name|l_tmp_image_id
argument_list|,
name|l_fname
argument_list|)
expr_stmt|;
name|gimp_image_delete
argument_list|(
name|l_tmp_image_id
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_fname
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_fname_copy
argument_list|)
expr_stmt|;
name|l_dst_frame_nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rc
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|paste_mode
operator|!=
name|VID_PASTE_INSERT_AFTER
operator|)
condition|)
block|{
comment|/* load from the "new" current frame */
if|if
condition|(
name|ainfo_ptr
operator|->
name|new_filename
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
name|ainfo_ptr
operator|->
name|new_filename
operator|=
name|p_alloc_fname
argument_list|(
name|ainfo_ptr
operator|->
name|basename
argument_list|,
name|ainfo_ptr
operator|->
name|curr_frame_nr
argument_list|,
name|ainfo_ptr
operator|->
name|extension
argument_list|)
expr_stmt|;
name|rc
operator|=
name|p_load_named_frame
argument_list|(
name|ainfo_ptr
operator|->
name|image_id
argument_list|,
name|ainfo_ptr
operator|->
name|new_filename
argument_list|)
expr_stmt|;
block|}
name|p_free_ainfo
argument_list|(
operator|&
name|ainfo_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end gap_vid_edit_paste */
end_comment

end_unit

