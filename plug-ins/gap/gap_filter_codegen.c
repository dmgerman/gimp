begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gap_filter_codegen.c  *  * GAP ... Gimp Animation Plugins  *  * This Module contains:  * - GAP_filter  codegenerator procedures for _iterator_ALT procedures  *   * Note: this code is only used in debug mode,  *       (for developers (Hackers) to generate code templates  *       for _iterator_ALT  or _Iterator procedures.)  */
end_comment

begin_comment
comment|/* revision history:  * version 0.99.00  1999.03.14  hof: Codegeneration of File ./gen_filter_iter_code.c  *                                   splittet into single Files XX_iter_ALT.inc  *                                   bugfixes in code generation  * version 0.95.04  1998.06.12  hof: p_delta_drawable (enable use of layerstack anims in drawable iteration)  * version 0.93.00              hof: generate Iterator Source  *                                   in one single file (per plugin), ready to compile  * version 0.91.01; Tue Dec 23  hof: 1.st (pre) release  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* SYTEM (UNIX) includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GIMP includes */
end_comment

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* GAP includes */
end_comment

begin_comment
comment|/* int gap_debug = 1; */
end_comment

begin_comment
comment|/* print debug infos */
end_comment

begin_comment
comment|/* int gap_debug = 0; */
end_comment

begin_comment
comment|/* 0: dont print debug infos */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|gap_debug
decl_stmt|;
end_decl_stmt

begin_function_decl
name|gint
name|p_gen_code_iter
parameter_list|(
name|char
modifier|*
name|proc_name
parameter_list|)
function_decl|;
end_function_decl

begin_define
DECL|macro|GEN_FORWARDFILE_NAME
define|#
directive|define
name|GEN_FORWARDFILE_NAME
value|"gen_filter_iter_forward.c"
end_define

begin_define
DECL|macro|GEN_TABFILE_NAME
define|#
directive|define
name|GEN_TABFILE_NAME
value|"gen_filter_iter_tab.c"
end_define

begin_function
DECL|function|p_remove_codegen_files ()
name|void
name|p_remove_codegen_files
parameter_list|()
block|{
name|remove
argument_list|(
name|GEN_FORWARDFILE_NAME
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|GEN_TABFILE_NAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"overwrite  file: %s\n"
argument_list|,
name|GEN_FORWARDFILE_NAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"overwrite  file: %s\n"
argument_list|,
name|GEN_TABFILE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
DECL|function|p_type_to_string (GimpPDBArgType t)
name|p_type_to_string
parameter_list|(
name|GimpPDBArgType
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|GIMP_PDB_INT32
case|:
return|return
literal|"long     "
return|;
case|case
name|GIMP_PDB_INT16
case|:
return|return
literal|"short    "
return|;
case|case
name|GIMP_PDB_INT8
case|:
return|return
literal|"char     "
return|;
case|case
name|GIMP_PDB_FLOAT
case|:
return|return
literal|"gdouble  "
return|;
case|case
name|GIMP_PDB_STRING
case|:
return|return
literal|"char     *"
return|;
case|case
name|GIMP_PDB_INT32ARRAY
case|:
return|return
literal|"INT32ARRAY"
return|;
case|case
name|GIMP_PDB_INT16ARRAY
case|:
return|return
literal|"INT16ARRAY"
return|;
case|case
name|GIMP_PDB_INT8ARRAY
case|:
return|return
literal|"INT8ARRAY"
return|;
case|case
name|GIMP_PDB_FLOATARRAY
case|:
return|return
literal|"FLOATARRAY"
return|;
case|case
name|GIMP_PDB_STRINGARRAY
case|:
return|return
literal|"STRINGARRAY"
return|;
case|case
name|GIMP_PDB_COLOR
case|:
return|return
literal|"t_color  "
return|;
case|case
name|GIMP_PDB_REGION
case|:
return|return
literal|"REGION"
return|;
case|case
name|GIMP_PDB_DISPLAY
case|:
return|return
literal|"gint32   "
return|;
case|case
name|GIMP_PDB_IMAGE
case|:
return|return
literal|"gint32   "
return|;
case|case
name|GIMP_PDB_LAYER
case|:
return|return
literal|"gint32   "
return|;
case|case
name|GIMP_PDB_CHANNEL
case|:
return|return
literal|"gint32   "
return|;
case|case
name|GIMP_PDB_DRAWABLE
case|:
return|return
literal|"gint32   "
return|;
case|case
name|GIMP_PDB_SELECTION
case|:
return|return
literal|"SELECTION"
return|;
case|case
name|GIMP_PDB_BOUNDARY
case|:
return|return
literal|"BOUNDARY"
return|;
case|case
name|GIMP_PDB_PATH
case|:
return|return
literal|"PATH"
return|;
case|case
name|GIMP_PDB_STATUS
case|:
return|return
literal|"STATUS"
return|;
case|case
name|GIMP_PDB_END
case|:
return|return
literal|"END"
return|;
default|default:
return|return
literal|"UNKNOWN?"
return|;
block|}
block|}
end_function

begin_function
DECL|function|p_get_gendate (char * gendate)
specifier|static
name|void
name|p_get_gendate
parameter_list|(
name|char
modifier|*
name|gendate
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|l_t
decl_stmt|;
name|long
name|l_ti
decl_stmt|;
name|l_ti
operator|=
name|time
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
comment|/* Get UNIX time */
name|l_t
operator|=
name|localtime
argument_list|(
operator|&
name|l_ti
argument_list|)
expr_stmt|;
comment|/* konvert time to tm struct */
name|sprintf
argument_list|(
name|gendate
argument_list|,
literal|"%02d.%02d.%02d %02d:%02d"
argument_list|,
name|l_t
operator|->
name|tm_mday
argument_list|,
name|l_t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|l_t
operator|->
name|tm_year
argument_list|,
name|l_t
operator|->
name|tm_hour
argument_list|,
name|l_t
operator|->
name|tm_min
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|p_clean_name (char * name,char * clean_name)
name|p_clean_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|clean_name
parameter_list|)
block|{
name|char
modifier|*
name|l_ptr
decl_stmt|;
name|l_ptr
operator|=
name|clean_name
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|name
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'%'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'='
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|';'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'^'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|','
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'['
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'{'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'}'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'('
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|')'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'$'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'<'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'|'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'>'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'?'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'~'
operator|)
condition|)
block|{
operator|*
name|l_ptr
operator|=
literal|'_'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|l_ptr
operator|=
operator|*
name|name
expr_stmt|;
block|}
name|name
operator|++
expr_stmt|;
name|l_ptr
operator|++
expr_stmt|;
block|}
operator|*
name|l_ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_gen_code_iter_ALT (char * proc_name)
name|gint
name|p_gen_code_iter_ALT
parameter_list|(
name|char
modifier|*
name|proc_name
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
name|gint
name|l_nparams
decl_stmt|;
name|gint
name|l_nreturn_vals
decl_stmt|;
name|GimpPDBProcType
name|l_proc_type
decl_stmt|;
name|gchar
modifier|*
name|l_proc_blurb
decl_stmt|;
name|gchar
modifier|*
name|l_proc_help
decl_stmt|;
name|gchar
modifier|*
name|l_proc_author
decl_stmt|;
name|gchar
modifier|*
name|l_proc_copyright
decl_stmt|;
name|gchar
modifier|*
name|l_proc_date
decl_stmt|;
name|GimpParamDef
modifier|*
name|l_params
decl_stmt|;
name|GimpParamDef
modifier|*
name|l_return_vals
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|gchar
name|l_filename
index|[
literal|512
index|]
decl_stmt|;
name|gchar
name|l_gendate
index|[
literal|30
index|]
decl_stmt|;
name|gchar
name|l_clean_proc_name
index|[
literal|256
index|]
decl_stmt|;
name|gchar
name|l_clean_par_name
index|[
literal|256
index|]
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|p_get_gendate
argument_list|(
operator|&
name|l_gendate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Query the gimp application's procedural database    *  regarding a particular procedure.    */
if|if
condition|(
name|gimp_procedural_db_proc_info
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_proc_blurb
argument_list|,
operator|&
name|l_proc_help
argument_list|,
operator|&
name|l_proc_author
argument_list|,
operator|&
name|l_proc_copyright
argument_list|,
operator|&
name|l_proc_date
argument_list|,
operator|&
name|l_proc_type
argument_list|,
operator|&
name|l_nparams
argument_list|,
operator|&
name|l_nreturn_vals
argument_list|,
operator|&
name|l_params
argument_list|,
operator|&
name|l_return_vals
argument_list|)
condition|)
block|{
name|p_clean_name
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_clean_proc_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* procedure found in PDB */
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: found in PDB %s author: %s copyright: %s\n"
argument_list|,
name|proc_name
argument_list|,
name|l_proc_author
argument_list|,
name|l_proc_copyright
argument_list|)
expr_stmt|;
comment|/* check if plugin can be a typical one, that works on one drawable */
if|if
condition|(
name|l_proc_type
operator|!=
name|GIMP_PLUGIN
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_nparams
operator|<
literal|3
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|GIMP_PDB_INT32
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|1
index|]
operator|.
name|type
operator|!=
name|GIMP_PDB_IMAGE
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|2
index|]
operator|.
name|type
operator|!=
name|GIMP_PDB_DRAWABLE
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|l_filename
argument_list|,
literal|"%s_iter_ALT.inc"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|l_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * p_%s_iter_ALT \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"gint p_%s_iter_ALT(GimpRunModeType run_mode, gint32 total_steps, gdouble current_step, gint32 len_struct) \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    typedef struct t_%s_Vals \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|3
init|;
name|l_idx
operator|<
name|l_nparams
condition|;
name|l_idx
operator|++
control|)
block|{
name|p_clean_name
argument_list|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|name
argument_list|,
operator|&
name|l_clean_par_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"      %s %s;\n"
argument_list|,
name|p_type_to_string
argument_list|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    } t_%s_Vals; \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    t_%s_Vals  buf, *buf_from, *buf_to; \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(len_struct != sizeof(t_%s_Vals)) \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"      fprintf(stderr, \"ERROR: p_\%s_iter_ALT  stored Data missmatch in size %%d != %%d\\n\",   \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                       (int)len_struct, sizeof(t_%s_Vals) ); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"      return -1;  /* ERROR */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gimp_get_data(\"%s_ITER_FROM\", g_plugin_data_from); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gimp_get_data(\"%s_ITER_TO\",   g_plugin_data_to); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    buf_from = (t_%s_Vals *)&g_plugin_data_from[0]; \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    buf_to   = (t_%s_Vals *)&g_plugin_data_to[0]; \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    memcpy(&buf, buf_from, sizeof(buf));\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|3
init|;
name|l_idx
operator|<
name|l_nparams
condition|;
name|l_idx
operator|++
control|)
block|{
name|p_clean_name
argument_list|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|name
argument_list|,
operator|&
name|l_clean_par_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|GIMP_PDB_INT32
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_long(&buf.%s, buf_from->%s, buf_to->%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_short(&buf.%s, buf_from->%s, buf_to->%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_char(&buf.%s, buf_from->%s, buf_to->%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOAT
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_gdouble(&buf.%s, buf_from->%s, buf_to->%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_COLOR
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_color(&buf.%s,&buf_from->%s,&buf_to->%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_DRAWABLE
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_drawable(&buf.%s, buf_from->%s, buf_to->%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gimp_set_data(\"%s\",&buf, sizeof(buf)); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    return 0; /* OK */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
block|}
comment|/*  free the query information  */
name|g_free
argument_list|(
name|l_proc_blurb
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_help
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_author
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_copyright
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_date
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_return_vals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
name|p_gen_code_iter
argument_list|(
name|proc_name
argument_list|)
expr_stmt|;
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* p_gen_code_iter_ALT */
end_comment

begin_function
DECL|function|p_gen_forward_iter_ALT (char * proc_name)
name|gint
name|p_gen_forward_iter_ALT
parameter_list|(
name|char
modifier|*
name|proc_name
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|char
name|l_clean_proc_name
index|[
literal|256
index|]
decl_stmt|;
name|p_clean_name
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_clean_proc_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|GEN_FORWARDFILE_NAME
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static gint p_%s_iter_ALT (GimpRunModeType run_mode, gint32 total_steps, gdouble current_step, gint32 len_struct);\n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
DECL|function|p_gen_tab_iter_ALT (char * proc_name)
name|gint
name|p_gen_tab_iter_ALT
parameter_list|(
name|char
modifier|*
name|proc_name
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|char
name|l_clean_proc_name
index|[
literal|256
index|]
decl_stmt|;
name|p_clean_name
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_clean_proc_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|GEN_TABFILE_NAME
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"   , { \"%s\",  p_%s_iter_ALT }\n"
argument_list|,
name|l_clean_proc_name
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate _Itrerator Procedure all in one .c file,  * ready to compile  */
end_comment

begin_function
DECL|function|p_gen_code_iter (char * proc_name)
name|gint
name|p_gen_code_iter
parameter_list|(
name|char
modifier|*
name|proc_name
parameter_list|)
block|{
name|FILE
modifier|*
name|l_fp
decl_stmt|;
name|gint
name|l_idx
decl_stmt|;
name|gint
name|l_nparams
decl_stmt|;
name|gint
name|l_nreturn_vals
decl_stmt|;
name|GimpPDBProcType
name|l_proc_type
decl_stmt|;
name|gchar
modifier|*
name|l_proc_blurb
decl_stmt|;
name|gchar
modifier|*
name|l_proc_help
decl_stmt|;
name|gchar
modifier|*
name|l_proc_author
decl_stmt|;
name|gchar
modifier|*
name|l_proc_copyright
decl_stmt|;
name|gchar
modifier|*
name|l_proc_date
decl_stmt|;
name|GimpParamDef
modifier|*
name|l_params
decl_stmt|;
name|GimpParamDef
modifier|*
name|l_return_vals
decl_stmt|;
name|gint
name|l_rc
decl_stmt|;
name|gchar
name|l_filename
index|[
literal|512
index|]
decl_stmt|;
name|gchar
name|l_gendate
index|[
literal|30
index|]
decl_stmt|;
name|gchar
name|l_clean_proc_name
index|[
literal|256
index|]
decl_stmt|;
name|gchar
name|l_clean_par_name
index|[
literal|256
index|]
decl_stmt|;
name|l_rc
operator|=
literal|0
expr_stmt|;
name|p_get_gendate
argument_list|(
operator|&
name|l_gendate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Query the gimp application's procedural database    *  regarding a particular procedure.    */
if|if
condition|(
name|gimp_procedural_db_proc_info
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_proc_blurb
argument_list|,
operator|&
name|l_proc_help
argument_list|,
operator|&
name|l_proc_author
argument_list|,
operator|&
name|l_proc_copyright
argument_list|,
operator|&
name|l_proc_date
argument_list|,
operator|&
name|l_proc_type
argument_list|,
operator|&
name|l_nparams
argument_list|,
operator|&
name|l_nreturn_vals
argument_list|,
operator|&
name|l_params
argument_list|,
operator|&
name|l_return_vals
argument_list|)
condition|)
block|{
name|p_clean_name
argument_list|(
name|proc_name
argument_list|,
operator|&
name|l_clean_proc_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* procedure found in PDB */
if|if
condition|(
name|gap_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: found in PDB %s\n"
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
comment|/* check if plugin can be a typical one, that works on one drawable */
if|if
condition|(
name|l_proc_type
operator|!=
name|GIMP_PLUGIN
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_nparams
operator|<
literal|3
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|GIMP_PDB_INT32
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|1
index|]
operator|.
name|type
operator|!=
name|GIMP_PDB_IMAGE
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_params
index|[
literal|2
index|]
operator|.
name|type
operator|!=
name|GIMP_PDB_DRAWABLE
condition|)
block|{
name|l_rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|l_filename
argument_list|,
literal|"%s_iter.c"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|l_fp
operator|=
name|fopen
argument_list|(
name|l_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* %s\n"
argument_list|,
name|l_filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * generated by gap_filter_codegen.c\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * generation date:  %s\n"
argument_list|,
name|l_gendate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * generation source Gimp PDB entry name: %s\n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *                            version   : %s\n"
argument_list|,
name|l_proc_date
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * The generated code will not work if the internal data stucture\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * (used to store and retrieve \"LastValues\") is different to the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * PDB Calling Interface.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * In that case you will get an Error message like that:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *       ERROR: xxxx_Iterator stored Data missmatch in size N != M\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *    if the Iterator is called. \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *    (via \"Filter all Layers\" using \"Apply Varying\" Button)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *    When you get this Error, you should change this generated code.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" *  \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* SYTEM (UNIX) includes */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#include<stdio.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#include<string.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#include<stdlib.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* GIMP includes */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#include \"gtk/gtk.h\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"#include \"libgimp/gimp.h\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"typedef struct { guchar color[3]; } t_color; \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"typedef struct { gint color[3]; }   t_gint_color; \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void query(void); \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void run(char *name, int nparam, GimpParam *param, int *nretvals, GimpParam **retvals); \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"GimpPlugInInfo PLUG_IN_INFO = \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  NULL,  /* init_proc */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  NULL,  /* quit_proc */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  query, /* query_proc */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  run,   /* run_proc */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}; \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * iterator functions for basic datatypes \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_long(long *val, long val_from, long val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    *val  = val_from + delta;  \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_short(short *val, short val_from, short val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    *val  = val_from + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_gint(gint *val, gint val_from, gint val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    *val  = val_from + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_char(char *val, char val_from, char val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    *val  = val_from + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_gdouble(double *val, double val_from, double val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    *val  = val_from + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_float(float *val, float val_from, float val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    *val  = val_from + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_color(t_color *val, t_color *val_from, t_color *val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    int l_idx;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    for(l_idx = 0; l_idx< 3; l_idx++)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       delta = ((double)(val_to->color[l_idx] - val_from->color[l_idx]) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       val->color[l_idx]  = val_from->color[l_idx] + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_gint_color(t_gint_color *val, t_gint_color *val_from, t_gint_color *val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    double     delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    int l_idx;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(total_steps< 1) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    for(l_idx = 0; l_idx< 3; l_idx++)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       delta = ((double)(val_to->color[l_idx] - val_from->color[l_idx]) / (double)total_steps) * ((double)total_steps - current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       val->color[l_idx]  = val_from->color[l_idx] + delta;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void p_delta_drawable(gint32 *val, gint32 val_from, gint32 val_to, gint32 total_steps, gdouble current_step)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gint    l_nlayers;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gint32 *l_layers_list;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gint32  l_tmp_image_id;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gint    l_idx, l_idx_from, l_idx_to;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    l_tmp_image_id = gimp_drawable_image_id(val_from);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    /* check if from and to values are both valid drawables within the same image */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if ((l_tmp_image_id> 0)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"&&  (l_tmp_image_id = gimp_drawable_image_id(val_to)))\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       l_idx_from = -1;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       l_idx_to   = -1;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       /* check the layerstack index of from and to drawable */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       l_layers_list = gimp_image_get_layers(l_tmp_image_id,&l_nlayers);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       for (l_idx = l_nlayers -1; l_idx>= 0; l_idx--)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"          if( l_layers_list[l_idx] == val_from ) l_idx_from = l_idx;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"          if( l_layers_list[l_idx] == val_to )   l_idx_to   = l_idx;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"          if((l_idx_from != -1)&& (l_idx_to != -1))\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"          {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"            /* OK found both index values, iterate the index (proceed to next layer) */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"            p_delta_gint(&l_idx, l_idx_from, l_idx_to, total_steps, current_step);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"            *val = l_layers_list[l_idx];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"            break;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"          }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       g_free (l_layers_list);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * p_%s_iter \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"gint p_%s_iter(GimpRunModeType run_mode, gint32 total_steps, gdouble current_step, gint32 len_struct) \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    typedef struct t_%s_Vals \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|3
init|;
name|l_idx
operator|<
name|l_nparams
condition|;
name|l_idx
operator|++
control|)
block|{
name|p_clean_name
argument_list|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|name
argument_list|,
operator|&
name|l_clean_par_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"      %s %s;\n"
argument_list|,
name|p_type_to_string
argument_list|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    } t_%s_Vals; \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    t_%s_Vals  buf, buf_from, buf_to; \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(len_struct != sizeof(t_%s_Vals)) \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"      fprintf(stderr, \"ERROR: p_\%s_iter  stored Data missmatch in size %%d != %%d\\n\",   \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                       (int)len_struct, sizeof(t_%s_Vals) ); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"      return -1;  /* ERROR */ \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gimp_get_data(\"%s_ITER_FROM\",&buf_from); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gimp_get_data(\"%s_ITER_TO\",&buf_to); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    memcpy(&buf,&buf_from, sizeof(buf));\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|l_idx
operator|=
literal|3
init|;
name|l_idx
operator|<
name|l_nparams
condition|;
name|l_idx
operator|++
control|)
block|{
name|p_clean_name
argument_list|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|name
argument_list|,
operator|&
name|l_clean_par_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_params
index|[
name|l_idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|GIMP_PDB_INT32
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_long(&buf.%s, buf_from.%s, buf_to.%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT16
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_short(&buf.%s, buf_from.%s, buf_to.%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_INT8
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_char(&buf.%s, buf_from.%s, buf_to.%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_FLOAT
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_gdouble(&buf.%s, buf_from.%s, buf_to.%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_COLOR
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_color(&buf.%s,&buf_from.%s,&buf_to.%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GIMP_PDB_DRAWABLE
case|:
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    p_delta_drawable(&buf.%s, buf_from.%s, buf_to.%s, total_steps, current_step);\n"
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|,
name|l_clean_par_name
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    gimp_set_data(\"%s\",&buf, sizeof(buf)); \n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    return 0; /* OK */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"MAIN ()\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * install (query) _Iterator\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void query ()\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  char l_blurb_text[300];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  static GimpParamDef args_iter[] =\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {GIMP_PDB_INT32, \"run_mode\", \"non-interactive\"},\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {GIMP_PDB_INT32, \"total_steps\", \"total number of steps (# of layers-1 to apply the related plug-in)\"},\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {GIMP_PDB_FLOAT, \"current_step\", \"current (for linear iterations this is the layerstack position, otherwise some value inbetween)\"},\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {GIMP_PDB_INT32, \"len_struct\", \"length of stored data structure with id is equal to the plug_in  proc_name\"},\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  };\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  static int nargs_iter = sizeof(args_iter) / sizeof(args_iter[0]);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  static GimpParamDef *return_vals = NULL;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  static int nreturn_vals = 0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  sprintf(l_blurb_text, \"This extension calculates the modified values for one iterationstep for the call of %s\");\n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  gimp_install_procedure(\"%s_Iterator\",\n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         l_blurb_text,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         \"\",\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         \"Wolfgang Hofer\",\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         \"Wolfgang Hofer\",\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         \"%s\",\n"
argument_list|,
name|l_gendate
argument_list|)
expr_stmt|;
comment|/* generation date */
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         NULL,    /* do not appear in menus */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         NULL,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         GIMP_EXTENSION,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         nargs_iter, nreturn_vals,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"                         args_iter, return_vals);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"/* ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * run Iterator\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" * ----------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"static void\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"run (char    *name,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"     int      n_params,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"     GimpParam  *param,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"     int     *nreturn_vals,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"     GimpParam **return_vals)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  static GimpParam values[1];\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  GimpRunModeType run_mode;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  GimpPDBStatusType status = GIMP_PDB_SUCCESS;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  gint32     image_id;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  gint32  len_struct;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  gint32  total_steps;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  gdouble current_step;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  gint32     l_rc;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  *nreturn_vals = 1;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  *return_vals = values;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  l_rc = 0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  run_mode = param[0].data.d_int32;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  if ((run_mode == GIMP_RUN_NONINTERACTIVE)&& (n_params == 4))\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    total_steps  =  param[1].data.d_int32;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    current_step =  param[2].data.d_float;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    len_struct   =  param[3].data.d_int32;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    l_rc = p_%s_iter(run_mode, total_steps, current_step, len_struct);\n"
argument_list|,
name|l_clean_proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    if(l_rc< 0)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"       status = GIMP_PDB_EXECUTION_ERROR;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  else status = GIMP_PDB_CALLING_ERROR;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  values[0].type = GIMP_PDB_STATUS;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"  values[0].data.d_status = status;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|l_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|l_fp
argument_list|)
expr_stmt|;
block|}
comment|/*  free the query information  */
name|g_free
argument_list|(
name|l_proc_blurb
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_help
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_author
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_copyright
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_proc_date
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_params
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|l_return_vals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|l_rc
return|;
block|}
end_function

begin_comment
comment|/* p_gen_code_iter */
end_comment

end_unit

