begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * NOTE: This plugin is not currently in very good working order.  There  * are big pieces of code missing.  I am aware of this.  :)  And it  * would probably take longer for you to understand the code and finish it  * than wait for me to do so.  :)  Nonetheless, if you do spot an obviously  * grubby bug before I make a 'real' release then feel free to send a patch.  *  * In the meantime, I don't think that this will crash very often, but you'll  * often get some strange results.  *   *   -adam 97/03/16  */
end_comment

begin_comment
comment|/*  * This GIMP plug-in is designed to load Photoshop(tm) files (.PSD)  *  * Plug-in maintainer: Adam D. Moss<adam@foxbox.org>  *     If this plug-in fails to load a file which you think it should,  *     please tell me what seemed to go wrong, and anything you know  *     about the image you tried to load.  Please don't send big PSD  *     files to me without asking first.  *  * Copyright (C) 1997 Adam D. Moss  * Copyright (C) 1996 Torsten Martinsen  * Portions Copyright (C) 1995 Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Adobe and Adobe Photoshop are trademarks of Adobe Systems  * Incorporated that may be registered in certain jurisdictions.  */
end_comment

begin_comment
comment|/*  * TODO:  *	Make CMYK -> RGB conversion work  *	Better progress indicators  *	Load BITMAP mode  *      File saving  */
end_comment

begin_comment
comment|/*  * Revision history:  *  *  97.03.13 / v1.9.0 / Adam D. Moss  *       Layers, channels and masks, oh my.  *       Bugfixes, rearchitecturing(!).  *  *  97.01.30 / v1.0.12 / Torsten Martinsen  *       Flat image loading.  */
end_comment

begin_comment
comment|/* *** DEFINES *** */
end_comment

begin_comment
comment|/* the max number of layers that this plugin should try to load */
end_comment

begin_define
DECL|macro|MAX_LAYERS
define|#
directive|define
name|MAX_LAYERS
value|180
end_define

begin_comment
comment|/* the max number of channels that this plugin should let a layer have */
end_comment

begin_define
DECL|macro|MAX_CHANNELS
define|#
directive|define
name|MAX_CHANNELS
value|40
end_define

begin_comment
comment|/* *** END OF DEFINES *** */
end_comment

begin_comment
comment|/* Ideally the above defines wouldn't be necessary because the lists of  * channels and layers would be dynamic/linked, but:  *  * a) We don't necessarily know any limits that may be defined within  *      GIMP itself  *  * b) K.I.S.S.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*#include<endian.h>*/
end_comment

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* Local types etc  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon27b9ced60103
block|{
DECL|enumerator|PSD_UNKNOWN_IMAGE
name|PSD_UNKNOWN_IMAGE
block|,
DECL|enumerator|PSD_RGB_IMAGE
name|PSD_RGB_IMAGE
block|,
DECL|enumerator|PSD_RGBA_IMAGE
name|PSD_RGBA_IMAGE
block|,
DECL|enumerator|PSD_GRAY_IMAGE
name|PSD_GRAY_IMAGE
block|,
DECL|enumerator|PSD_GRAYA_IMAGE
name|PSD_GRAYA_IMAGE
block|,
DECL|enumerator|PSD_INDEXED_IMAGE
name|PSD_INDEXED_IMAGE
block|,
DECL|enumerator|PSD_INDEXEDA_IMAGE
name|PSD_INDEXEDA_IMAGE
DECL|typedef|psd_imagetype
block|}
name|psd_imagetype
typedef|;
end_typedef

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GDrawableType
name|psd_type_to_gimp_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GImageType
name|psd_type_to_gimp_base_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|GLayerMode
name|psd_lmode_to_gimp_lmode
parameter_list|(
name|gchar
name|modekey
index|[
literal|4
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|PsdChannel
typedef|typedef
struct|struct
name|PsdChannel
block|{
DECL|member|name
name|gchar
modifier|*
name|name
decl_stmt|;
DECL|member|data
name|guchar
modifier|*
name|data
decl_stmt|;
DECL|member|type
name|gint
name|type
decl_stmt|;
DECL|member|compressedsize
name|guint32
name|compressedsize
decl_stmt|;
DECL|typedef|PSDchannel
block|}
name|PSDchannel
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdLayer
typedef|typedef
struct|struct
name|PsdLayer
block|{
DECL|member|num_channels
name|gint
name|num_channels
decl_stmt|;
DECL|member|channel
name|PSDchannel
name|channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
DECL|member|x
name|gint32
name|x
decl_stmt|;
DECL|member|y
name|gint32
name|y
decl_stmt|;
DECL|member|width
name|guint32
name|width
decl_stmt|;
DECL|member|height
name|guint32
name|height
decl_stmt|;
DECL|member|blendkey
name|gchar
name|blendkey
index|[
literal|4
index|]
decl_stmt|;
DECL|member|opacity
name|guchar
name|opacity
decl_stmt|;
DECL|member|clipping
name|gchar
name|clipping
decl_stmt|;
DECL|member|protecttrans
name|gboolean
name|protecttrans
decl_stmt|;
DECL|member|visible
name|gboolean
name|visible
decl_stmt|;
DECL|typedef|PSDlayer
block|}
name|PSDlayer
typedef|;
end_typedef

begin_typedef
DECL|struct|PsdImage
typedef|typedef
struct|struct
name|PsdImage
block|{
DECL|member|num_layers
name|gint
name|num_layers
decl_stmt|;
DECL|member|layer
name|PSDlayer
name|layer
index|[
name|MAX_LAYERS
index|]
decl_stmt|;
DECL|member|absolute_alpha
name|gboolean
name|absolute_alpha
decl_stmt|;
DECL|member|type
name|gint
name|type
decl_stmt|;
DECL|member|colmaplen
name|gulong
name|colmaplen
decl_stmt|;
DECL|member|colmapdata
name|guchar
modifier|*
name|colmapdata
decl_stmt|;
DECL|member|num_aux_channels
name|guint
name|num_aux_channels
decl_stmt|;
DECL|member|aux_channel
name|PSDchannel
name|aux_channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
DECL|member|caption
name|gchar
modifier|*
name|caption
decl_stmt|;
DECL|member|active_layer_num
name|guint
name|active_layer_num
decl_stmt|;
DECL|typedef|PSDimage
block|}
name|PSDimage
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|psd_image
specifier|static
name|PSDimage
name|psd_image
decl_stmt|;
end_decl_stmt

begin_struct
DECL|struct|__anon27b9ced60208
specifier|static
struct|struct
block|{
DECL|member|signature
name|guchar
name|signature
index|[
literal|4
index|]
decl_stmt|;
DECL|member|version
name|gushort
name|version
decl_stmt|;
DECL|member|reserved
name|guchar
name|reserved
index|[
literal|6
index|]
decl_stmt|;
DECL|member|channels
name|gushort
name|channels
decl_stmt|;
DECL|member|rows
name|gulong
name|rows
decl_stmt|;
DECL|member|columns
name|gulong
name|columns
decl_stmt|;
DECL|member|bpp
name|gushort
name|bpp
decl_stmt|;
DECL|member|mode
name|gushort
name|mode
decl_stmt|;
DECL|member|imgreslen
name|gulong
name|imgreslen
decl_stmt|;
DECL|member|miscsizelen
name|gulong
name|miscsizelen
decl_stmt|;
DECL|member|compression
name|gushort
name|compression
decl_stmt|;
DECL|member|rowlength
name|gushort
modifier|*
name|rowlength
decl_stmt|;
DECL|member|imgdatalen
name|long
name|imgdatalen
decl_stmt|;
DECL|variable|PSDheader
block|}
name|PSDheader
struct|;
end_struct

begin_decl_stmt
DECL|variable|modename
specifier|static
name|gchar
modifier|*
name|modename
index|[]
init|=
block|{
literal|"Bitmap"
block|,
literal|"Grayscale"
block|,
literal|"Indexed Colour"
block|,
literal|"RGB Colour"
block|,
literal|"CMYK Colour"
block|,
literal|"<invalid>"
block|,
literal|"<invalid>"
block|,
literal|"Multichannel"
block|,
literal|"Duotone"
block|,
literal|"Lab Colour"
block|,
literal|"<invalid>"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|prog_name
specifier|static
specifier|const
name|gchar
modifier|*
name|prog_name
init|=
literal|"PSD"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|unpack_pb_channel
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint32
name|unpackedlen
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode
parameter_list|(
name|long
name|clen
parameter_list|,
name|long
name|uclen
parameter_list|,
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|packbitsdecode
parameter_list|(
name|long
modifier|*
name|clenp
parameter_list|,
name|long
name|uclen
parameter_list|,
name|gchar
modifier|*
name|src
parameter_list|,
name|gchar
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmyk2rgb
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|destp
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmykp2rgb
parameter_list|(
name|guchar
modifier|*
name|src
parameter_list|,
name|guchar
modifier|*
name|destp
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cmyk_to_rgb
parameter_list|(
name|int
modifier|*
name|c
parameter_list|,
name|int
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|k
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
name|getguchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gshort
name|getgshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gulong
name|getglong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfread
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|gchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_whole_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reshuffle_cmap
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|guchar
modifier|*
name|getpascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|throwchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dumpchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|why
parameter_list|)
function_decl|;
end_function_decl

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name of the file to load"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nload_return_vals
init|=
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/*  static GParamDef save_args[] =   {     { PARAM_INT32, "run_mode", "Interactive, non-interactive" },     { PARAM_IMAGE, "image", "Input image" },     { PARAM_DRAWABLE, "drawable", "Drawable to save" },     { PARAM_STRING, "filename", "The name of the file to save the image in" },     { PARAM_STRING, "raw_filename", "The name of the file to save the image in" },     { PARAM_INT32, "compression", "Compression type: { NONE (0), LZW (1), PACKBITS (2)" },     { PARAM_INT32, "fillorder", "Fill Order: { MSB to LSB (0), LSB to MSB (1)" }   };   static int nsave_args = sizeof (save_args) / sizeof (save_args[0]);*/
name|gimp_install_procedure
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"loads files of the Photoshop(tm) PSD file format"
argument_list|,
literal|"FIXME: write help for psd_load"
argument_list|,
literal|"Adam D. Moss& Torsten Martinsen"
argument_list|,
literal|"Adam D. Moss& Torsten Martinsen"
argument_list|,
literal|"1996-1997"
argument_list|,
literal|"<Load>/PSD"
argument_list|,
name|NULL
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
comment|/*  gimp_install_procedure ("file_psd_save",                           "saves files in the Photoshop(tm) PSD file format",                           "FIXME: write help for psd_save",                           "Adam D. Moss& Torsten Martinsen",                           "Adam D. Moss& Torsten Martinsen",                           "1996-1997",                           "<Save>/PSD", 			  "RGB, GRAY, INDEXED",                           PROC_PLUG_IN,                           nsave_args, 0,                           save_args, NULL);*/
name|gimp_register_load_handler
argument_list|(
literal|"file_psd_load"
argument_list|,
literal|"psd"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*  gimp_register_save_handler ("file_psd_save", "psd", "");*/
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (char * name,int nparams,GParam * param,int * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
comment|/*  GStatusType status = STATUS_SUCCESS;*/
name|gint32
name|image_ID
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_psd_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PARAM_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|GDrawableType
DECL|function|psd_type_to_gimp_type (psd_imagetype psdtype)
name|psd_type_to_gimp_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
name|PSD_RGBA_IMAGE
case|:
return|return
operator|(
name|RGBA_IMAGE
operator|)
return|;
case|case
name|PSD_RGB_IMAGE
case|:
return|return
operator|(
name|RGB_IMAGE
operator|)
return|;
case|case
name|PSD_GRAYA_IMAGE
case|:
return|return
operator|(
name|GRAYA_IMAGE
operator|)
return|;
case|case
name|PSD_GRAY_IMAGE
case|:
return|return
operator|(
name|GRAY_IMAGE
operator|)
return|;
case|case
name|PSD_INDEXEDA_IMAGE
case|:
return|return
operator|(
name|INDEXEDA_IMAGE
operator|)
return|;
case|case
name|PSD_INDEXED_IMAGE
case|:
return|return
operator|(
name|INDEXED_IMAGE
operator|)
return|;
default|default:
return|return
operator|(
name|RGB_IMAGE
operator|)
return|;
block|}
block|}
end_function

begin_function
name|GLayerMode
DECL|function|psd_lmode_to_gimp_lmode (gchar modekey[4])
name|psd_lmode_to_gimp_lmode
parameter_list|(
name|gchar
name|modekey
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"norm"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NORMAL_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"dark"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DARKEN_ONLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"lite"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|LIGHTEN_ONLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hue "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|HUE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sat "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SATURATION_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"colr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|COLOR_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"mul "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|MULTIPLY_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"scrn"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SCREEN_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"diss"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DISSOLVE_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"diff"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DIFFERENCE_MODE
operator|)
return|;
name|printf
argument_list|(
literal|"PSD: Warning - unsupported layer-blend mode, reverting to 'normal'\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"lum "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|NORMAL_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"over"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/****/
name|NORMAL_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"hLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|NORMAL_MODE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|modekey
argument_list|,
literal|"sLit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
comment|/**/
name|NORMAL_MODE
operator|)
return|;
name|printf
argument_list|(
literal|"PSD: Warning - UNKNOWN layer-blend mode, reverting to 'normal'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NORMAL_MODE
operator|)
return|;
block|}
end_function

begin_function
name|GImageType
DECL|function|psd_type_to_gimp_base_type (psd_imagetype psdtype)
name|psd_type_to_gimp_base_type
parameter_list|(
name|psd_imagetype
name|psdtype
parameter_list|)
block|{
switch|switch
condition|(
name|psdtype
condition|)
block|{
case|case
name|PSD_RGBA_IMAGE
case|:
case|case
name|PSD_RGB_IMAGE
case|:
return|return
operator|(
name|RGB
operator|)
return|;
case|case
name|PSD_GRAYA_IMAGE
case|:
case|case
name|PSD_GRAY_IMAGE
case|:
return|return
operator|(
name|GRAY
operator|)
return|;
case|case
name|PSD_INDEXEDA_IMAGE
case|:
case|case
name|PSD_INDEXED_IMAGE
case|:
return|return
operator|(
name|INDEXED
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"PSD: Can't convert PSD imagetype to GIMP imagetype\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|RGB
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|reshuffle_cmap (guchar * map256)
name|reshuffle_cmap
parameter_list|(
name|guchar
modifier|*
name|map256
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpmap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmpmap
operator|=
name|xmalloc
argument_list|(
literal|768
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|tmpmap
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|map256
index|[
name|i
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|256
index|]
expr_stmt|;
name|tmpmap
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|map256
index|[
name|i
operator|+
literal|512
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|768
condition|;
name|i
operator|++
control|)
block|{
name|map256
index|[
name|i
index|]
operator|=
name|tmpmap
index|[
name|i
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|tmpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dispatch_resID (guint ID,FILE * fd,guint32 * offset,guint32 Size)
name|dispatch_resID
parameter_list|(
name|guint
name|ID
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|,
name|guint32
name|Size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ID
operator|<
literal|0x0bb6
operator|)
operator|&&
operator|(
name|ID
operator|>
literal|0x07d0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\t\tPath data is irrelevant to GIMP at this time.\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res path throw"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|ID
condition|)
block|{
case|case
literal|0x03ee
case|:
block|{
name|gint32
name|remaining
init|=
name|Size
decl_stmt|;
name|printf
argument_list|(
literal|"\t\tALPHA CHANNEL NAMES:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|1
condition|)
block|{
name|guint32
name|alpha_name_len
decl_stmt|;
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"alpha channel name"
argument_list|)
expr_stmt|;
name|alpha_name_len
operator|=
name|strlen
argument_list|(
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\tname: \"%s\"\n"
argument_list|,
name|psd_image
operator|.
name|aux_channel
index|[
name|psd_image
operator|.
name|num_aux_channels
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|num_aux_channels
operator|++
expr_stmt|;
operator|*
name|offset
operator|+=
name|alpha_name_len
operator|+
literal|1
expr_stmt|;
name|remaining
operator|-=
name|alpha_name_len
operator|+
literal|1
expr_stmt|;
block|}
name|throwchunk
argument_list|(
name|remaining
argument_list|,
name|fd
argument_list|,
literal|"alphaname padding 0 throw"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x03ef
case|:
name|printf
argument_list|(
literal|"\t\tDISPLAYINFO STRUCTURE: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f0
case|:
comment|/* FIXME: untested */
block|{
name|guint32
name|caption_len
decl_stmt|;
name|psd_image
operator|.
name|caption
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"caption string"
argument_list|)
expr_stmt|;
name|caption_len
operator|=
name|strlen
argument_list|(
name|psd_image
operator|.
name|caption
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\tcontent: \"%s\"\n"
argument_list|,
name|psd_image
operator|.
name|caption
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|caption_len
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|0x03f2
case|:
name|printf
argument_list|(
literal|"\t\tBACKGROUND COLOR: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f4
case|:
name|printf
argument_list|(
literal|"\t\tGREY/MULTICHANNEL HALFTONING INFO: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f5
case|:
name|printf
argument_list|(
literal|"\t\tCOLOUR HALFTONING INFO: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f6
case|:
name|printf
argument_list|(
literal|"\t\tDUOTONE HALFTONING INFO: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f7
case|:
name|printf
argument_list|(
literal|"\t\tGREYSCALE/MULTICHANNEL TRANSFER FUNCTION: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f8
case|:
name|printf
argument_list|(
literal|"\t\tCOLOUR TRANSFER FUNCTION: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03f9
case|:
name|printf
argument_list|(
literal|"\t\tDUOTONE TRANSFER FUNCTION: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fa
case|:
name|printf
argument_list|(
literal|"\t\tDUOTONE IMAGE INFO: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fb
case|:
name|printf
argument_list|(
literal|"\t\tEFFECTIVE BLACK/WHITE VALUES: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fe
case|:
name|printf
argument_list|(
literal|"\t\tQUICK MASK INFO: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0400
case|:
block|{
name|printf
argument_list|(
literal|"\t\tLAYER STATE INFO:\n"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|active_layer_num
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"ID target_layer_num"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\ttarget: %d\n"
argument_list|,
operator|(
name|gint
operator|)
name|psd_image
operator|.
name|active_layer_num
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|0x0402
case|:
name|printf
argument_list|(
literal|"\t\tLAYER GROUP INFO: unhandled\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t(Inferred number of layers: %d)\n"
argument_list|,
call|(
name|gint
call|)
argument_list|(
name|Size
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x0405
case|:
name|printf
argument_list|(
literal|"\t\tIMAGE MODE FOR RAW FORMAT: unhandled\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03e9
case|:
case|case
literal|0x03ed
case|:
case|case
literal|0x03f1
case|:
case|case
literal|0x03f3
case|:
case|case
literal|0x03fd
case|:
case|case
literal|0x0401
case|:
case|case
literal|0x0404
case|:
case|case
literal|0x0406
case|:
case|case
literal|0x0bb7
case|:
case|case
literal|0x2710
case|:
name|printf
argument_list|(
literal|"\t\t<Field is irrelevant to GIMP at this time.>\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03e8
case|:
case|case
literal|0x03eb
case|:
name|printf
argument_list|(
literal|"\t\t<Obsolete Photoshop 2.0 field.>\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
case|case
literal|0x03fc
case|:
case|case
literal|0x03ff
case|:
case|case
literal|0x0403
case|:
name|printf
argument_list|(
literal|"\t\t<Obsolete field.>\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\t\t<Undocumented (Photoshop 4.0?) field.>\n"
argument_list|)
expr_stmt|;
name|throwchunk
argument_list|(
name|Size
argument_list|,
name|fd
argument_list|,
literal|"dispatch_res"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|Size
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_record (FILE * fd,guint32 * offset,gint layernum)
name|do_layer_record
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|,
name|gint
name|layernum
parameter_list|)
block|{
name|gint32
name|top
decl_stmt|,
name|left
decl_stmt|,
name|bottom
decl_stmt|,
name|right
decl_stmt|;
name|guint32
name|extradatasize
decl_stmt|;
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|guchar
name|flags
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\t\t\tLAYER RECORD (layer %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|layernum
argument_list|)
expr_stmt|;
name|top
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer top"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|left
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer left"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|bottom
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer bottom"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|right
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer right"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|x
operator|=
name|left
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|y
operator|=
name|top
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|width
operator|=
name|right
operator|-
name|left
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|height
operator|=
name|bottom
operator|-
name|top
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tLayer extents: (%d,%d) -> (%d,%d)\n"
argument_list|,
name|left
argument_list|,
name|top
argument_list|,
name|right
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer num_channels"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tNumber of channels: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t\t\t\tCHANNEL LENGTH INFO (%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|type
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"channel id"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\t\tChannel ID: %d\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|compressedsize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"channeldatalength"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\t\tChannel Data Length: %d\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|channel
index|[
name|i
index|]
operator|.
name|compressedsize
argument_list|)
expr_stmt|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|sig
argument_list|,
literal|4
argument_list|,
literal|"layer blend sig"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sig
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Error - layer blend signature is incorrect. :-(\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
argument_list|,
literal|4
argument_list|,
literal|"layer blend key"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tBlend type: PSD(\"%c%c%c%c\") = GIMP(%d)\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|0
index|]
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|1
index|]
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|2
index|]
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
index|[
literal|3
index|]
argument_list|,
name|psd_lmode_to_gimp_lmode
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|blendkey
argument_list|)
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|opacity
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer opacity"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tLayer Opacity: %d\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|opacity
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|clipping
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer clipping"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tLayer Clipping: %d (%s)\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|clipping
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|clipping
operator|==
literal|0
condition|?
literal|"base"
else|:
literal|"non-base"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer flags"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tLayer Flags: %d (%s, %s)\n"
argument_list|,
name|flags
argument_list|,
name|flags
operator|&
literal|1
condition|?
literal|"preserve transparency"
else|:
literal|"don't preserve transparency"
argument_list|,
name|flags
operator|&
literal|2
condition|?
literal|"visible"
else|:
literal|"not visible"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|protecttrans
operator|=
operator|(
name|flags
operator|&
literal|1
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layernum
index|]
operator|.
name|protecttrans
operator|=
operator|(
name|flags
operator|&
literal|2
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"layer record filler"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|extradatasize
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layer extra data size"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tEXTRA DATA SIZE: %d\n"
argument_list|,
name|extradatasize
argument_list|)
expr_stmt|;
comment|/* FIXME: should do something with this data */
name|throwchunk
argument_list|(
name|extradatasize
argument_list|,
name|fd
argument_list|,
literal|"layer extradata throw"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_struct (FILE * fd,guint32 * offset)
name|do_layer_struct
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|gint
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\t\tLAYER STRUCTURE SECTION\n"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|num_layers
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer struct numlayers"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\tCanonical number of layers: %d%s\n"
argument_list|,
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|?
operator|(
name|int
operator|)
name|psd_image
operator|.
name|num_layers
else|:
name|abs
argument_list|(
name|psd_image
operator|.
name|num_layers
argument_list|)
argument_list|,
name|psd_image
operator|.
name|num_layers
operator|>
literal|0
condition|?
literal|""
else|:
literal|" (absolute/alpha)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|num_layers
operator|<
literal|0
condition|)
block|{
name|psd_image
operator|.
name|num_layers
operator|=
operator|-
name|psd_image
operator|.
name|num_layers
expr_stmt|;
name|psd_image
operator|.
name|absolute_alpha
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|psd_image
operator|.
name|absolute_alpha
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|i
operator|++
control|)
block|{
name|do_layer_record
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_pixeldata (FILE * fd,guint32 * offset)
name|do_layer_pixeldata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|guint16
name|compression
decl_stmt|;
name|gint
name|layeri
decl_stmt|,
name|channeli
decl_stmt|;
name|guchar
modifier|*
name|tmpline
decl_stmt|;
for|for
control|(
name|layeri
operator|=
literal|0
init|;
name|layeri
operator|<
name|psd_image
operator|.
name|num_layers
condition|;
name|layeri
operator|++
control|)
block|{
name|tmpline
operator|=
name|xmalloc
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|channeli
operator|=
literal|0
init|;
name|channeli
operator|<
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|num_channels
condition|;
name|channeli
operator|++
control|)
block|{
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|type
operator|!=
operator|-
literal|2
condition|)
block|{
name|compression
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"layer channel compression type"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\tLayer (%d) Channel (%d:%d) Compression: %d (%s)\n"
argument_list|,
name|layeri
argument_list|,
name|channeli
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|type
argument_list|,
name|compression
argument_list|,
name|compression
operator|==
literal|0
condition|?
literal|"raw"
else|:
literal|"RLE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tLoading channel data (%d bytes)...\n"
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|data
operator|=
name|xmalloc
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
operator|*
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* raw data, padded to an even width (jeez, psd sux) */
block|{
comment|/* FIXME: untested */
name|gint
name|linei
decl_stmt|;
for|for
control|(
name|linei
operator|=
literal|0
init|;
name|linei
operator|<
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
condition|;
name|linei
operator|++
control|)
block|{
name|xfread
argument_list|(
name|fd
argument_list|,
operator|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|data
operator|+
name|linei
operator|*
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
operator|)
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
argument_list|,
literal|"raw channel line"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
operator|&
literal|1
condition|)
block|{
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"raw channel line padding"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|1
case|:
comment|/* RLE, one row at a time, padded to an even width */
block|{
name|gint
name|linei
decl_stmt|;
name|gint
name|blockread
decl_stmt|;
comment|/* we throw this away because in theory we can trust the 		       data to unpack to the right length... hmm... */
name|throwchunk
argument_list|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
operator|*
literal|2
argument_list|,
name|fd
argument_list|,
literal|"widthlist"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
operator|*
literal|2
expr_stmt|;
name|blockread
operator|=
operator|*
name|offset
expr_stmt|;
for|for
control|(
name|linei
operator|=
literal|0
init|;
name|linei
operator|<
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|height
condition|;
name|linei
operator|++
control|)
block|{
comment|/*printf(" %d ", *offset);*/
name|unpack_pb_channel
argument_list|(
name|fd
argument_list|,
name|tmpline
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
comment|/*(psd_image.layer[layeri].width&1)*/
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|channel
index|[
name|channeli
index|]
operator|.
name|data
operator|+
name|linei
operator|*
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
operator|)
argument_list|,
name|tmpline
argument_list|,
name|psd_image
operator|.
name|layer
index|[
name|layeri
index|]
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\t\t\t\t\tActual compressed size was %d bytes\n"
argument_list|,
operator|(
operator|*
name|offset
operator|)
operator|-
name|blockread
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* *unknown* */
name|printf
argument_list|(
literal|"*** Unknown compression type in channel.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
name|g_free
argument_list|(
name|tmpline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_layers (FILE * fd,guint32 * offset)
name|do_layers
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|guint32
name|section_length
decl_stmt|;
name|section_length
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"layerinfo sectionlength"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"\tLAYER INFO SECTION\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tSECTION LENGTH: %u\n"
argument_list|,
name|section_length
argument_list|)
expr_stmt|;
name|do_layer_struct
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|do_layer_pixeldata
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_masks (guint32 * offset)
name|do_masks
parameter_list|(
name|guint32
modifier|*
name|offset
parameter_list|)
block|{    }
end_function

begin_function
specifier|static
name|void
DECL|function|do_layer_and_mask (FILE * fd)
name|do_layer_and_mask
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|guint32
name|Size
init|=
name|PSDheader
operator|.
name|miscsizelen
decl_stmt|;
name|printf
argument_list|(
literal|"LAYER AND MASK INFO\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tSECTION LENGTH: %u\n"
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
operator|==
literal|0
condition|)
return|return;
name|do_layers
argument_list|(
name|fd
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|Size
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Supposedly there are %d bytes of mask info left.\n"
argument_list|,
name|Size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Size
operator|-
name|offset
operator|==
literal|4
operator|)
operator|||
operator|(
name|Size
operator|-
name|offset
operator|==
literal|0x14
operator|)
condition|)
name|printf
argument_list|(
literal|"     That sounds good to me.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     That sounds strange to me.\n"
argument_list|)
expr_stmt|;
comment|/* FIXME: supposed to do something with this */
comment|/*      dumpchunk(4, fd, "mask info throw");*/
if|if
condition|(
operator|(
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"mask info throw"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"mask info throw"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"mask info throw"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"mask info throw"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"*** This is bogus.  Quitting.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
comment|/*      do_masks(&offset);*/
block|}
else|else
name|printf
argument_list|(
literal|"PSD: Stern warning - no mask info.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|do_image_resources (FILE * fd)
name|do_image_resources
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint16
name|ID
decl_stmt|;
name|gchar
modifier|*
name|Name
decl_stmt|;
name|guint32
name|Size
decl_stmt|;
name|guint32
name|offset
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"IMAGE RESOURCE BLOCK:\n"
argument_list|)
expr_stmt|;
comment|/* FIXME: too trusting that the file isn't corrupt */
while|while
condition|(
name|offset
operator|<
name|PSDheader
operator|.
name|imgreslen
operator|-
literal|1
condition|)
block|{
name|gchar
name|sig
index|[
literal|4
index|]
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|sig
argument_list|,
literal|4
argument_list|,
literal|"imageresources signature"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sig
argument_list|,
literal|"8BIM"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PSD: Error - imageresources block has invalid signature.\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|offset
operator|+=
literal|4
expr_stmt|;
comment|/* generic information about a block ID */
name|ID
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"ID num"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\tID: 0x%04x / "
argument_list|,
name|ID
argument_list|)
expr_stmt|;
name|Name
operator|=
name|getpascalstring
argument_list|(
name|fd
argument_list|,
literal|"ID name"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|strlen
argument_list|(
name|Name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|Name
argument_list|)
operator|&
literal|1
condition|)
block|{
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID name throw"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|g_free
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|Size
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"ID Size"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"Size: %d\n"
argument_list|,
name|Size
argument_list|)
expr_stmt|;
name|dispatch_resID
argument_list|(
name|ID
argument_list|,
name|fd
argument_list|,
operator|&
name|offset
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
operator|&
literal|1
condition|)
block|{
name|throwchunk
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
literal|"ID content throw"
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
comment|/*  if (offset != PSDheader.imgreslen)     {       printf("\tSucking imageres byte...\n");       throwchunk(1, fd, "imageres suck");       offset ++;     }*/
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|load_image (char * name)
name|load_image
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|name_buf
decl_stmt|,
modifier|*
name|cmykbuf
decl_stmt|;
specifier|static
name|int
name|number
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|long
name|rowstride
decl_stmt|,
name|channels
decl_stmt|,
name|nguchars
decl_stmt|;
name|psd_imagetype
name|imagetype
decl_stmt|;
name|int
name|cmyk
init|=
literal|0
decl_stmt|,
name|step
init|=
literal|1
decl_stmt|;
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
name|gint32
name|layer_ID
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|gint32
name|iter
decl_stmt|;
name|printf
argument_list|(
literal|"------- %s --------------------------------------\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name_buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"%s-%d"
argument_list|,
name|name
argument_list|,
name|number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"Loading %s:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't open \"%s\"\n"
argument_list|,
name|prog_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|read_whole_file
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Image data %ld chars\n"
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|imagetype
operator|=
name|PSD_UNKNOWN_IMAGE
expr_stmt|;
switch|switch
condition|(
name|PSDheader
operator|.
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* Bitmap */
break|break;
case|case
literal|1
case|:
comment|/* Grayscale */
switch|switch
condition|(
name|PSDheader
operator|.
name|channels
condition|)
block|{
case|case
literal|1
case|:
name|step
operator|=
literal|1
expr_stmt|;
name|imagetype
operator|=
name|PSD_GRAY_IMAGE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|step
operator|=
literal|2
expr_stmt|;
name|imagetype
operator|=
name|PSD_GRAYA_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Warning: base GRAY image has %d channels...\n"
argument_list|,
name|step
operator|=
name|PSDheader
operator|.
name|channels
argument_list|)
expr_stmt|;
name|imagetype
operator|=
name|PSD_GRAYA_IMAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Indexed Colour */
switch|switch
condition|(
name|PSDheader
operator|.
name|channels
condition|)
block|{
case|case
literal|1
case|:
name|step
operator|=
literal|1
expr_stmt|;
name|imagetype
operator|=
name|PSD_INDEXED_IMAGE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|step
operator|=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: base INDEXED image has 2 channels - "
literal|"ignoring alpha.\n"
argument_list|)
expr_stmt|;
name|imagetype
operator|=
name|PSD_INDEXEDA_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Warning: base INDEXED image has %d channels...\n"
argument_list|,
name|step
operator|=
name|PSDheader
operator|.
name|channels
argument_list|)
expr_stmt|;
name|imagetype
operator|=
name|PSD_INDEXEDA_IMAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|3
case|:
comment|/* RGB Colour */
switch|switch
condition|(
name|PSDheader
operator|.
name|channels
condition|)
block|{
case|case
literal|3
case|:
name|step
operator|=
literal|3
expr_stmt|;
name|imagetype
operator|=
name|PSD_RGB_IMAGE
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|step
operator|=
literal|4
expr_stmt|;
name|imagetype
operator|=
name|PSD_RGBA_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Warning: base RGB image has %d channels...\n"
argument_list|,
name|step
operator|=
name|PSDheader
operator|.
name|channels
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|4
case|:
comment|/* CMYK Colour */
name|cmyk
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|PSDheader
operator|.
name|channels
condition|)
block|{
case|case
literal|4
case|:
name|step
operator|=
literal|4
expr_stmt|;
name|imagetype
operator|=
name|PSD_RGB_IMAGE
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|step
operator|=
literal|5
expr_stmt|;
name|imagetype
operator|=
name|PSD_RGBA_IMAGE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: cannot handle CMYK with more than 5 channels\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
break|break;
case|case
literal|7
case|:
comment|/* Multichannel (?) */
case|case
literal|8
case|:
comment|/* Duotone */
case|case
literal|9
case|:
comment|/* Lab Colour */
default|default:
break|break;
block|}
if|if
condition|(
name|imagetype
operator|==
name|PSD_UNKNOWN_IMAGE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Image type %d (%s) is not supported\n"
argument_list|,
name|prog_name
argument_list|,
name|PSDheader
operator|.
name|mode
argument_list|,
operator|(
name|PSDheader
operator|.
name|mode
operator|>
literal|10
operator|)
condition|?
literal|"<out of range>"
else|:
name|modename
index|[
name|PSDheader
operator|.
name|mode
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|PSDheader
operator|.
name|bpp
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"%s: The GIMP only supports 8-bit deep PSD images\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"psd:%d gimp:%d gimpbase:%d\n"
argument_list|,
name|imagetype
argument_list|,
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
argument_list|,
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
argument_list|)
expr_stmt|;
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_type_to_gimp_base_type
argument_list|(
name|imagetype
argument_list|)
operator|==
name|INDEXED
condition|)
block|{
if|if
condition|(
operator|(
name|psd_image
operator|.
name|colmaplen
operator|%
literal|3
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"PSD: Colourmap looks screwed! Aiee!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"PSD: Indexed image has no colourmap!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|!=
literal|768
condition|)
name|printf
argument_list|(
literal|"PSD: Warning: Indexed image is !=256 (%ld) colours.\n"
argument_list|,
name|psd_image
operator|.
name|colmaplen
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|==
literal|768
condition|)
block|{
name|reshuffle_cmap
argument_list|(
name|psd_image
operator|.
name|colmapdata
argument_list|)
expr_stmt|;
name|gimp_image_set_cmap
argument_list|(
name|image_ID
argument_list|,
name|psd_image
operator|.
name|colmapdata
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
block|}
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
literal|"Background"
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
comment|/*    dest = gimp_image_data (image);     channels = gimp_image_channels (image);     rowstride = gimp_image_width (image) * channels;*/
name|channels
operator|=
name|gimp_drawable_bpp
argument_list|(
name|drawable
operator|->
name|id
argument_list|)
expr_stmt|;
name|rowstride
operator|=
name|PSDheader
operator|.
name|columns
operator|*
name|channels
expr_stmt|;
name|dest
operator|=
name|xmalloc
argument_list|(
name|rowstride
operator|*
name|PSDheader
operator|.
name|rows
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|compression
operator|!=
literal|0
condition|)
block|{
name|nguchars
operator|=
name|PSDheader
operator|.
name|columns
operator|*
name|PSDheader
operator|.
name|rows
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|temp
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"image data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmyk
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.25
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
argument_list|,
name|temp
argument_list|,
name|dest
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.25
argument_list|)
expr_stmt|;
name|cmykbuf
operator|=
name|xmalloc
argument_list|(
name|step
operator|*
name|nguchars
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
name|nguchars
argument_list|,
name|temp
argument_list|,
name|cmykbuf
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.50
argument_list|)
expr_stmt|;
name|cmyk2rgb
argument_list|(
name|cmykbuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|step
operator|>
literal|4
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmykbuf
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cmyk
condition|)
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.50
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"image data"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.25
argument_list|)
expr_stmt|;
name|cmykbuf
operator|=
name|xmalloc
argument_list|(
name|PSDheader
operator|.
name|imgdatalen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|cmykbuf
argument_list|,
name|PSDheader
operator|.
name|imgdatalen
argument_list|,
literal|"image data"
argument_list|)
expr_stmt|;
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|0.50
argument_list|)
expr_stmt|;
name|cmykp2rgb
argument_list|(
name|cmykbuf
argument_list|,
name|dest
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|step
operator|>
literal|4
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|cmykbuf
argument_list|)
expr_stmt|;
block|}
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
literal|1.00
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_type_to_gimp_type
argument_list|(
name|imagetype
argument_list|)
operator|==
name|INDEXEDA_IMAGE
condition|)
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
condition|;
name|iter
operator|++
control|)
block|{
name|dest
index|[
name|iter
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|>
literal|0
condition|)
name|g_free
argument_list|(
name|psd_image
operator|.
name|colmapdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|image_ID
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|decode (long clen,long uclen,char * src,char * dst,int step)
name|decode
parameter_list|(
name|long
name|clen
parameter_list|,
name|long
name|uclen
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gint32
name|l
decl_stmt|;
name|gushort
modifier|*
name|w
decl_stmt|;
name|l
operator|=
name|clen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
condition|;
operator|++
name|i
control|)
name|l
operator|-=
name|PSDheader
operator|.
name|rowlength
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|printf
argument_list|(
literal|"*** %ld should be zero\n"
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
name|w
operator|=
name|PSDheader
operator|.
name|rowlength
expr_stmt|;
name|packbitsdecode
argument_list|(
operator|&
name|clen
argument_list|,
name|uclen
argument_list|,
name|src
argument_list|,
name|dst
operator|++
argument_list|,
name|step
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|step
operator|-
literal|1
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
condition|;
operator|++
name|i
control|)
name|src
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
name|packbitsdecode
argument_list|(
operator|&
name|clen
argument_list|,
name|uclen
argument_list|,
name|src
argument_list|,
name|dst
operator|++
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"clen %ld\n"
argument_list|,
name|clen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode a PackBits data stream.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|packbitsdecode (long * clenp,long uclen,char * src,char * dst,int step)
name|packbitsdecode
parameter_list|(
name|long
modifier|*
name|clenp
parameter_list|,
name|long
name|uclen
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|gint
name|n
decl_stmt|,
name|b
decl_stmt|;
name|gint32
name|clen
init|=
operator|*
name|clenp
decl_stmt|;
while|while
condition|(
operator|(
name|clen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uclen
operator|>
literal|0
operator|)
condition|)
block|{
name|n
operator|=
operator|(
name|int
operator|)
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* replicate next guchar -n+1 times */
name|clen
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|128
condition|)
comment|/* nop */
continue|continue;
name|n
operator|=
operator|-
name|n
operator|+
literal|1
expr_stmt|;
name|uclen
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|b
operator|=
operator|*
name|src
operator|++
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
operator|*
name|dst
operator|=
name|b
expr_stmt|;
name|dst
operator|+=
name|step
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* copy next n+1 guchars literally */
for|for
control|(
name|b
operator|=
operator|++
name|n
init|;
name|b
operator|>
literal|0
condition|;
operator|--
name|b
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|dst
operator|+=
name|step
expr_stmt|;
block|}
name|uclen
operator|-=
name|n
expr_stmt|;
name|clen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uclen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading image data\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
operator|*
name|clenp
operator|=
name|clen
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode a PackBits channel from file.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|unpack_pb_channel (FILE * fd,guchar * dst,gint32 unpackedlen,guint32 * offset)
name|unpack_pb_channel
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|dst
parameter_list|,
name|gint32
name|unpackedlen
parameter_list|,
name|guint32
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|b
decl_stmt|;
name|gint32
name|upremain
init|=
name|unpackedlen
decl_stmt|;
while|while
condition|(
name|upremain
operator|>
literal|0
condition|)
block|{
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|128
condition|)
name|n
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* replicate next guchar -n+1 times */
if|if
condition|(
name|n
operator|==
operator|-
literal|128
condition|)
comment|/* nop */
continue|continue;
name|n
operator|=
operator|-
name|n
operator|+
literal|1
expr_stmt|;
comment|/*	    upremain -= n;*/
name|b
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits2"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
operator|*
name|dst
operator|=
name|b
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|upremain
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* copy next n+1 guchars literally */
for|for
control|(
name|b
operator|=
operator|++
name|n
init|;
name|b
operator|>
literal|0
condition|;
operator|--
name|b
control|)
block|{
operator|*
name|dst
operator|=
name|getguchar
argument_list|(
name|fd
argument_list|,
literal|"packbits3"
argument_list|)
expr_stmt|;
empty_stmt|;
operator|(
operator|*
name|offset
operator|)
operator|++
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|upremain
operator|--
expr_stmt|;
block|}
comment|/*	    upremain -= n;*/
block|}
block|}
if|if
condition|(
name|upremain
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"*** Unpacking overshot destination (%d) buffer by %d bytes!\n"
argument_list|,
name|unpackedlen
argument_list|,
operator|-
name|upremain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cmyk2rgb (unsigned char * src,unsigned char * dst,long width,long height,int alpha)
name|cmyk2rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|k
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|cmyk_to_rgb
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|g
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
literal|2.0
operator|*
operator|(
name|double
operator|)
name|height
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|height
operator|+
operator|(
name|double
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode planar CMYK(A) to RGB(A).  */
end_comment

begin_function
specifier|static
name|void
DECL|function|cmykp2rgb (unsigned char * src,unsigned char * dst,long width,long height,int alpha)
name|cmykp2rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|long
name|width
parameter_list|,
name|long
name|height
parameter_list|,
name|int
name|alpha
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|,
modifier|*
name|gp
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|kp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|n
operator|=
name|width
operator|*
name|height
expr_stmt|;
name|rp
operator|=
name|src
expr_stmt|;
name|gp
operator|=
name|rp
operator|+
name|n
expr_stmt|;
name|bp
operator|=
name|gp
operator|+
name|n
expr_stmt|;
name|kp
operator|=
name|bp
operator|+
name|n
expr_stmt|;
name|ap
operator|=
name|kp
operator|+
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|k
operator|=
operator|*
name|kp
operator|++
expr_stmt|;
name|cmyk_to_rgb
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|g
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|alpha
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
call|(
name|double
call|)
argument_list|(
literal|2.0
operator|*
operator|(
name|double
operator|)
name|height
argument_list|)
operator|/
operator|(
operator|(
name|double
operator|)
name|height
operator|+
operator|(
name|double
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|cmyk_to_rgb (gint * c,gint * m,gint * y,gint * k)
name|cmyk_to_rgb
parameter_list|(
name|gint
modifier|*
name|c
parameter_list|,
name|gint
modifier|*
name|m
parameter_list|,
name|gint
modifier|*
name|y
parameter_list|,
name|gint
modifier|*
name|k
parameter_list|)
block|{
if|#
directive|if
literal|1
name|gint
name|cyan
decl_stmt|,
name|magenta
decl_stmt|,
name|yellow
decl_stmt|,
name|black
decl_stmt|;
name|cyan
operator|=
operator|*
name|c
expr_stmt|;
name|magenta
operator|=
operator|*
name|m
expr_stmt|;
name|yellow
operator|=
operator|*
name|y
expr_stmt|;
name|black
operator|=
operator|*
name|k
expr_stmt|;
if|if
condition|(
name|black
operator|>
literal|0
condition|)
block|{
name|cyan
operator|-=
name|black
expr_stmt|;
name|magenta
operator|-=
name|black
expr_stmt|;
name|yellow
operator|-=
name|black
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|255
operator|-
name|cyan
expr_stmt|;
operator|*
name|m
operator|=
literal|255
operator|-
name|magenta
expr_stmt|;
operator|*
name|y
operator|=
literal|255
operator|-
name|yellow
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
operator|*
name|c
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|c
operator|>
literal|255
condition|)
operator|*
name|c
operator|=
literal|255
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|<
literal|0
condition|)
operator|*
name|m
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|m
operator|>
literal|255
condition|)
operator|*
name|m
operator|=
literal|255
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|<
literal|0
condition|)
operator|*
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|y
operator|>
literal|255
condition|)
operator|*
name|y
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|dumpchunk (size_t n,FILE * fd,guchar * why)
name|dumpchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|why
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|int
operator|)
name|getguchar
argument_list|(
name|fd
argument_list|,
name|why
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|throwchunk (size_t n,FILE * fd,guchar * why)
name|throwchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|why
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpchunk
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|tmpchunk
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|n
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmpchunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|getchunk (size_t n,FILE * fd,char * why)
name|getchunk
parameter_list|(
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|why
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpchunk
decl_stmt|;
name|tmpchunk
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|n
argument_list|,
name|why
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmpchunk
operator|)
return|;
comment|/* caller should free memory */
block|}
end_function

begin_comment
comment|/* FIXME: This is dumb.  I guess I wish there were a g_realloc */
end_comment

begin_comment
comment|/*static guchar * xgrowstr(guchar *src) {   guint32 i,oldlen;   guchar *new;    oldlen = strlen(src);   new = xmalloc(oldlen+2);    for (i=0;i<oldlen;i++)     new[i] = src[i];      new[oldlen]=0;    g_free(src);   return (new); }*/
end_comment

begin_function
specifier|static
name|guchar
modifier|*
DECL|function|getpascalstring (FILE * fd,guchar * why)
name|getpascalstring
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|guchar
modifier|*
name|why
parameter_list|)
block|{
name|guchar
modifier|*
name|tmpchunk
decl_stmt|;
name|guchar
name|len
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|tmpchunk
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|tmpchunk
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tmpchunk
operator|)
return|;
block|}
name|xfread
argument_list|(
name|fd
argument_list|,
name|tmpchunk
argument_list|,
name|len
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|tmpchunk
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tmpchunk
operator|)
return|;
comment|/* caller should free memory */
block|}
end_function

begin_comment
comment|/* static guchar * getstring(FILE *fd, guchar *why) {   guchar *tmpchunk;   guint pos;   guchar ch;    tmpchunk = xmalloc(1);    pos = 0;    do     {       xfread(fd,&ch, 1, why);       tmpchunk = xgrowstr(tmpchunk);       tmpchunk[pos] = ch;       pos++;     }   while (ch != 0);      return(tmpchunk); }*/
end_comment

begin_function
specifier|static
name|guchar
DECL|function|getguchar (FILE * fd,char * why)
name|getguchar
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|why
parameter_list|)
block|{
name|guchar
name|tmp
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|,
name|why
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gshort
DECL|function|getgshort (FILE * fd,char * why)
name|getgshort
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|why
parameter_list|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
DECL|union|__anon27b9ced6030a
union|union
block|{
DECL|struct|__anon27b9ced60408
struct|struct
block|{
DECL|member|b1
DECL|member|b2
name|unsigned
name|char
name|b1
decl_stmt|,
name|b2
decl_stmt|;
DECL|member|b
block|}
name|b
struct|;
DECL|member|w
name|gshort
name|w
decl_stmt|;
block|}
name|s
union|;
endif|#
directive|endif
name|gushort
name|w
decl_stmt|;
name|guchar
name|b
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|w
argument_list|,
literal|2
argument_list|,
name|why
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
return|return
operator|(
name|gshort
operator|)
name|w
return|;
else|#
directive|else
name|s
operator|.
name|w
operator|=
name|w
expr_stmt|;
name|b
operator|=
name|s
operator|.
name|b
operator|.
name|b2
expr_stmt|;
name|s
operator|.
name|b
operator|.
name|b2
operator|=
name|s
operator|.
name|b
operator|.
name|b1
expr_stmt|;
name|s
operator|.
name|b
operator|.
name|b1
operator|=
name|b
expr_stmt|;
return|return
name|s
operator|.
name|w
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|gulong
DECL|function|getglong (FILE * fd,char * why)
name|getglong
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|why
parameter_list|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
DECL|union|__anon27b9ced6050a
union|union
block|{
DECL|struct|__anon27b9ced60608
struct|struct
block|{
DECL|member|b1
DECL|member|b2
DECL|member|b3
DECL|member|b4
name|unsigned
name|char
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|,
name|b4
decl_stmt|;
DECL|member|b
block|}
name|b
struct|;
DECL|member|w
name|gulong
name|w
decl_stmt|;
block|}
name|s
union|;
name|unsigned
name|char
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|s4
decl_stmt|;
endif|#
directive|endif
name|gulong
name|w
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|w
argument_list|,
literal|4
argument_list|,
name|why
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
return|return
operator|(
name|glong
operator|)
name|w
return|;
else|#
directive|else
name|s
operator|.
name|w
operator|=
name|w
expr_stmt|;
name|s1
operator|=
name|s
operator|.
name|b
operator|.
name|b1
expr_stmt|;
name|s2
operator|=
name|s
operator|.
name|b
operator|.
name|b2
expr_stmt|;
name|s3
operator|=
name|s
operator|.
name|b
operator|.
name|b3
expr_stmt|;
name|s4
operator|=
name|s
operator|.
name|b
operator|.
name|b4
expr_stmt|;
name|s
operator|.
name|b
operator|.
name|b3
operator|=
name|s2
expr_stmt|;
name|s
operator|.
name|b
operator|.
name|b4
operator|=
name|s1
expr_stmt|;
name|s
operator|.
name|b
operator|.
name|b1
operator|=
name|s4
expr_stmt|;
name|s
operator|.
name|b
operator|.
name|b2
operator|=
name|s3
expr_stmt|;
return|return
name|s
operator|.
name|w
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|xfread (FILE * fd,void * buf,long len,char * why)
name|xfread
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|long
name|len
parameter_list|,
name|char
modifier|*
name|why
parameter_list|)
block|{
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected EOF while reading '%s' chunk\n"
argument_list|,
name|prog_name
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
DECL|function|xmalloc (size_t n)
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: xmalloc asked for zero-sized chunk\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|g_malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
name|printf
argument_list|(
literal|"%s: out of memory\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|read_whole_file (FILE * fd)
name|read_whole_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|guint16
name|w
decl_stmt|;
name|gint32
name|pos
decl_stmt|;
name|gchar
name|dummy
index|[
literal|6
index|]
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|PSDheader
operator|.
name|signature
argument_list|,
literal|4
argument_list|,
literal|"signature"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|version
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
operator|&
name|dummy
argument_list|,
literal|6
argument_list|,
literal|"reserved"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|channels
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"channels"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|rows
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|columns
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"columns"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|bpp
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"depth"
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|mode
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"mode"
argument_list|)
expr_stmt|;
name|psd_image
operator|.
name|num_layers
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|type
operator|=
name|PSDheader
operator|.
name|mode
expr_stmt|;
name|psd_image
operator|.
name|colmaplen
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|num_aux_channels
operator|=
literal|0
expr_stmt|;
name|psd_image
operator|.
name|colmaplen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"color data length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psd_image
operator|.
name|colmaplen
operator|>
literal|0
condition|)
block|{
name|psd_image
operator|.
name|colmapdata
operator|=
name|xmalloc
argument_list|(
name|psd_image
operator|.
name|colmaplen
argument_list|)
expr_stmt|;
name|xfread
argument_list|(
name|fd
argument_list|,
name|psd_image
operator|.
name|colmapdata
argument_list|,
name|psd_image
operator|.
name|colmaplen
argument_list|,
literal|"colormap"
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|imgreslen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"image resource length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|imgreslen
operator|>
literal|0
condition|)
block|{
name|do_image_resources
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|miscsizelen
operator|=
name|getglong
argument_list|(
name|fd
argument_list|,
literal|"misc size data length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|miscsizelen
operator|>
literal|0
condition|)
block|{
name|do_layer_and_mask
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|PSDheader
operator|.
name|compression
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"compression"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<<%d>>"
argument_list|,
operator|(
name|int
operator|)
name|PSDheader
operator|.
name|compression
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSDheader
operator|.
name|compression
condition|)
block|{
name|PSDheader
operator|.
name|rowlength
operator|=
name|xmalloc
argument_list|(
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
operator|*
sizeof|sizeof
argument_list|(
name|gushort
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PSDheader
operator|.
name|rows
operator|*
name|PSDheader
operator|.
name|channels
condition|;
operator|++
name|i
control|)
name|PSDheader
operator|.
name|rowlength
index|[
name|i
index|]
operator|=
name|getgshort
argument_list|(
name|fd
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|PSDheader
operator|.
name|imgdatalen
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
operator|-
name|pos
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|PSDheader
operator|.
name|signature
argument_list|,
literal|"8BPS"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: not an Adobe Photoshop PSD file\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|PSDheader
operator|.
name|version
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad version number '%d', not 1\n"
argument_list|,
name|prog_name
argument_list|,
name|PSDheader
operator|.
name|version
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|PSDheader
operator|.
name|mode
expr_stmt|;
name|printf
argument_list|(
literal|"HEAD:\n"
literal|"\tChannels %d\n\tRows %ld\n\tColumns %ld\n\tDepth %d\n\tMode %d (%s)\n"
literal|"\tColour data %ld guchars\n"
argument_list|,
name|PSDheader
operator|.
name|channels
argument_list|,
name|PSDheader
operator|.
name|rows
argument_list|,
name|PSDheader
operator|.
name|columns
argument_list|,
name|PSDheader
operator|.
name|bpp
argument_list|,
name|w
argument_list|,
name|modename
index|[
name|w
operator|<
literal|10
condition|?
name|w
else|:
literal|10
index|]
argument_list|,
name|psd_image
operator|.
name|colmaplen
argument_list|)
expr_stmt|;
comment|/*    printf("\tImage resource length: %lu\n", PSDheader.imgreslen);*/
name|printf
argument_list|(
literal|"\tLayer/Mask Data length: %lu\n"
argument_list|,
name|PSDheader
operator|.
name|miscsizelen
argument_list|)
expr_stmt|;
name|w
operator|=
name|PSDheader
operator|.
name|compression
expr_stmt|;
name|printf
argument_list|(
literal|"\tCompression %d (%s)\n"
argument_list|,
name|w
argument_list|,
name|w
condition|?
literal|"RLE"
else|:
literal|"raw"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

