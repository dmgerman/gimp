begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Softweave calculator for gimp-print.  *  *   Copyright 2000 Charles Briscoe-Smith<cpbs@debian.org>  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * This file must include only standard C header files.  The core code must  * compile on generic platforms that don't support glib, gimp, gtk, etc.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TEST_RAW
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TEST_COOKED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ACCUMULATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_define
DECL|macro|ASSERTIONS
define|#
directive|define
name|ASSERTIONS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST_RAW
argument_list|)
operator|||
name|defined
argument_list|(
name|TEST_COOKED
argument_list|)
end_if

begin_define
DECL|macro|TEST
define|#
directive|define
name|TEST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASSERTIONS
end_ifdef

begin_define
DECL|macro|assert (x)
define|#
directive|define
name|assert
parameter_list|(
name|x
parameter_list|)
value|if (!(x)) { fprintf(stderr, "ASSERTION FAILURE!  \"%s\", line %d.\n", __FILE__, __LINE__); exit(1); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|assert (x)
define|#
directive|define
name|assert
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
DECL|macro|assert (x)
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_define
DECL|macro|MAXCOLLECT
define|#
directive|define
name|MAXCOLLECT
value|(1000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
DECL|function|gcd (int x,int y)
name|gcd
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|assert
argument_list|(
name|x
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|y
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
return|return
name|x
return|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|>
name|x
condition|)
block|{
name|int
name|t
init|=
name|x
decl_stmt|;
name|x
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|t
expr_stmt|;
block|}
name|x
operator|%=
name|y
expr_stmt|;
block|}
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* RAW WEAVE */
end_comment

begin_typedef
DECL|struct|raw
typedef|typedef
struct|struct
name|raw
block|{
DECL|member|separation
name|int
name|separation
decl_stmt|;
DECL|member|jets
name|int
name|jets
decl_stmt|;
DECL|member|oversampling
name|int
name|oversampling
decl_stmt|;
DECL|member|advancebasis
name|int
name|advancebasis
decl_stmt|;
DECL|member|subblocksperpassblock
name|int
name|subblocksperpassblock
decl_stmt|;
DECL|member|passespersubblock
name|int
name|passespersubblock
decl_stmt|;
DECL|member|strategy
name|int
name|strategy
decl_stmt|;
DECL|typedef|raw_t
block|}
name|raw_t
typedef|;
end_typedef

begin_comment
comment|/*  * Strategy types currently defined:  *  *  0: microweave (intercepted at the escp2 driver level so we never  *     see it here)  *  1: zig-zag type pass block filling  *  2: ascending pass block filling  *  3: descending pass block filling  *  4: ascending fill with 2x expansion  *  5: ascending fill with 3x expansion  *  6: staggered zig-zag neighbour-avoidance fill  *  * In theory, strategy 1 should be optimal; in practice, it can lead  * to visible areas of banding.  If it's necessary to avoid filling  * neighbouring rows in neighbouring passes, strategy 6 should be optimal,  * at least for some weaves.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|initialize_raw_weave (raw_t * w,int S,int J,int H,int strat)
name|initialize_raw_weave
parameter_list|(
name|raw_t
modifier|*
name|w
parameter_list|,
comment|/* I - weave struct to be filled in */
name|int
name|S
parameter_list|,
comment|/* I - jet separation */
name|int
name|J
parameter_list|,
comment|/* I - number of jets */
name|int
name|H
parameter_list|,
comment|/* I - oversampling factor */
name|int
name|strat
parameter_list|)
comment|/* I - weave pattern variation to use */
block|{
name|w
operator|->
name|separation
operator|=
name|S
expr_stmt|;
name|w
operator|->
name|jets
operator|=
name|J
expr_stmt|;
name|w
operator|->
name|oversampling
operator|=
name|H
expr_stmt|;
name|w
operator|->
name|advancebasis
operator|=
name|J
operator|/
name|H
expr_stmt|;
name|w
operator|->
name|subblocksperpassblock
operator|=
name|gcd
argument_list|(
name|S
argument_list|,
name|w
operator|->
name|advancebasis
argument_list|)
expr_stmt|;
name|w
operator|->
name|passespersubblock
operator|=
name|S
operator|/
name|w
operator|->
name|subblocksperpassblock
expr_stmt|;
name|w
operator|->
name|strategy
operator|=
name|strat
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calculate_raw_pass_parameters (raw_t * w,int pass,int * startrow,int * subpass)
name|calculate_raw_pass_parameters
parameter_list|(
name|raw_t
modifier|*
name|w
parameter_list|,
comment|/* I - weave parameters */
name|int
name|pass
parameter_list|,
comment|/* I - pass number (>= 0) */
name|int
modifier|*
name|startrow
parameter_list|,
comment|/* O - print head position */
name|int
modifier|*
name|subpass
parameter_list|)
comment|/* O - subpass number */
block|{
name|int
name|band
decl_stmt|,
name|passinband
decl_stmt|,
name|subpassblock
decl_stmt|,
name|subpassoffset
decl_stmt|;
name|band
operator|=
name|pass
operator|/
operator|(
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|oversampling
operator|)
expr_stmt|;
name|passinband
operator|=
name|pass
operator|%
operator|(
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|oversampling
operator|)
expr_stmt|;
name|subpassblock
operator|=
name|pass
operator|%
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|subblocksperpassblock
operator|/
name|w
operator|->
name|separation
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|strategy
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|subpassblock
operator|*
literal|2
operator|<
name|w
operator|->
name|subblocksperpassblock
condition|)
name|subpassoffset
operator|=
literal|2
operator|*
name|subpassblock
expr_stmt|;
else|else
name|subpassoffset
operator|=
literal|2
operator|*
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|-
name|subpassblock
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|subpassoffset
operator|=
name|subpassblock
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|subpassoffset
operator|=
name|w
operator|->
name|subblocksperpassblock
operator|-
literal|1
operator|-
name|subpassblock
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|subpassblock
operator|*
literal|2
operator|<
name|w
operator|->
name|subblocksperpassblock
condition|)
name|subpassoffset
operator|=
literal|2
operator|*
name|subpassblock
expr_stmt|;
else|else
name|subpassoffset
operator|=
literal|1
operator|+
literal|2
operator|*
operator|(
name|subpassblock
operator|-
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|subpassblock
operator|*
literal|3
operator|<
name|w
operator|->
name|subblocksperpassblock
condition|)
name|subpassoffset
operator|=
literal|3
operator|*
name|subpassblock
expr_stmt|;
elseif|else
if|if
condition|(
literal|3
operator|*
operator|(
name|subpassblock
operator|-
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|<
name|w
operator|->
name|subblocksperpassblock
operator|-
literal|2
condition|)
name|subpassoffset
operator|=
literal|2
operator|+
literal|3
operator|*
operator|(
name|subpassblock
operator|-
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|subpassoffset
operator|=
literal|1
operator|+
literal|3
operator|*
operator|(
name|subpassblock
operator|-
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|2
operator|)
operator|/
literal|3
operator|-
name|w
operator|->
name|subblocksperpassblock
operator|/
literal|3
operator|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|subpassblock
operator|*
literal|2
operator|<
name|w
operator|->
name|subblocksperpassblock
condition|)
name|subpassoffset
operator|=
literal|2
operator|*
name|subpassblock
expr_stmt|;
elseif|else
if|if
condition|(
name|subpassblock
operator|*
literal|2
operator|<
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|2
condition|)
name|subpassoffset
operator|=
literal|1
expr_stmt|;
else|else
name|subpassoffset
operator|=
literal|2
operator|*
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|-
name|subpassblock
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|subpassoffset
operator|=
name|subpassblock
expr_stmt|;
break|break;
block|}
operator|*
name|startrow
operator|=
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|jets
operator|*
name|band
operator|+
name|w
operator|->
name|advancebasis
operator|*
name|passinband
operator|+
name|subpassoffset
expr_stmt|;
operator|*
name|subpass
operator|=
name|passinband
operator|/
name|w
operator|->
name|separation
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calculate_raw_row_parameters (raw_t * w,int row,int subpass,int * pass,int * jet,int * startrow)
name|calculate_raw_row_parameters
parameter_list|(
name|raw_t
modifier|*
name|w
parameter_list|,
comment|/* I - weave parameters */
name|int
name|row
parameter_list|,
comment|/* I - row number */
name|int
name|subpass
parameter_list|,
comment|/* I - subpass number */
name|int
modifier|*
name|pass
parameter_list|,
comment|/* O - pass number */
name|int
modifier|*
name|jet
parameter_list|,
comment|/* O - jet number in pass */
name|int
modifier|*
name|startrow
parameter_list|)
comment|/* O - starting row of pass */
block|{
name|int
name|subblockoffset
decl_stmt|,
name|subpassblock
decl_stmt|,
name|band
decl_stmt|,
name|baserow
decl_stmt|,
name|passinband
decl_stmt|,
name|offset
decl_stmt|;
name|subblockoffset
operator|=
name|row
operator|%
name|w
operator|->
name|subblocksperpassblock
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|strategy
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|subblockoffset
operator|%
literal|2
operator|==
literal|0
condition|)
name|subpassblock
operator|=
name|subblockoffset
operator|/
literal|2
expr_stmt|;
else|else
name|subpassblock
operator|=
name|w
operator|->
name|subblocksperpassblock
operator|-
operator|(
name|subblockoffset
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|subpassblock
operator|=
name|subblockoffset
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|subpassblock
operator|=
name|w
operator|->
name|subblocksperpassblock
operator|-
literal|1
operator|-
name|subblockoffset
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|subblockoffset
operator|%
literal|2
operator|==
literal|0
condition|)
name|subpassblock
operator|=
name|subblockoffset
operator|/
literal|2
expr_stmt|;
else|else
name|subpassblock
operator|=
operator|(
name|subblockoffset
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|subblockoffset
operator|%
literal|3
operator|==
literal|0
condition|)
name|subpassblock
operator|=
name|subblockoffset
operator|/
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|subblockoffset
operator|%
literal|3
operator|==
literal|1
condition|)
name|subpassblock
operator|=
operator|(
name|subblockoffset
operator|-
literal|1
operator|)
operator|/
literal|3
operator|+
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
else|else
name|subpassblock
operator|=
operator|(
name|subblockoffset
operator|-
literal|2
operator|)
operator|/
literal|3
operator|+
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|2
operator|)
operator|/
literal|3
operator|+
operator|(
name|w
operator|->
name|subblocksperpassblock
operator|+
literal|1
operator|)
operator|/
literal|3
expr_stmt|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|subblockoffset
operator|%
literal|2
operator|==
literal|0
condition|)
name|subpassblock
operator|=
name|subblockoffset
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|subblockoffset
operator|==
literal|1
condition|)
name|subpassblock
operator|=
name|w
operator|->
name|subblocksperpassblock
operator|/
literal|2
expr_stmt|;
else|else
name|subpassblock
operator|=
name|w
operator|->
name|subblocksperpassblock
operator|-
operator|(
name|subblockoffset
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
default|default:
name|subpassblock
operator|=
name|subblockoffset
expr_stmt|;
break|break;
block|}
name|band
operator|=
name|row
operator|/
operator|(
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|jets
operator|)
expr_stmt|;
name|baserow
operator|=
name|row
operator|-
name|subblockoffset
operator|-
name|band
operator|*
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|jets
expr_stmt|;
name|passinband
operator|=
name|baserow
operator|/
name|w
operator|->
name|advancebasis
expr_stmt|;
name|offset
operator|=
name|baserow
operator|%
name|w
operator|->
name|advancebasis
expr_stmt|;
while|while
condition|(
name|offset
operator|%
name|w
operator|->
name|separation
operator|!=
literal|0
operator|||
name|passinband
operator|/
name|w
operator|->
name|separation
operator|!=
name|subpass
operator|||
name|passinband
operator|%
name|w
operator|->
name|separation
operator|/
name|w
operator|->
name|passespersubblock
operator|!=
name|subpassblock
condition|)
block|{
name|offset
operator|+=
name|w
operator|->
name|advancebasis
expr_stmt|;
name|passinband
operator|--
expr_stmt|;
if|if
condition|(
name|passinband
operator|<
literal|0
condition|)
block|{
specifier|const
name|int
name|roundedjets
init|=
name|w
operator|->
name|advancebasis
operator|*
name|w
operator|->
name|oversampling
decl_stmt|;
name|band
operator|--
expr_stmt|;
name|passinband
operator|+=
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|oversampling
expr_stmt|;
name|offset
operator|+=
name|w
operator|->
name|separation
operator|*
operator|(
name|w
operator|->
name|jets
operator|-
name|roundedjets
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|pass
operator|=
name|band
operator|*
name|w
operator|->
name|oversampling
operator|*
name|w
operator|->
name|separation
operator|+
name|passinband
expr_stmt|;
operator|*
name|jet
operator|=
name|offset
operator|/
name|w
operator|->
name|separation
expr_stmt|;
operator|*
name|startrow
operator|=
name|row
operator|-
operator|(
operator|*
name|jet
operator|*
name|w
operator|->
name|separation
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* COOKED WEAVE */
end_comment

begin_typedef
DECL|struct|cooked
typedef|typedef
struct|struct
name|cooked
block|{
DECL|member|rw
name|raw_t
name|rw
decl_stmt|;
DECL|member|first_row_printed
name|int
name|first_row_printed
decl_stmt|;
DECL|member|last_row_printed
name|int
name|last_row_printed
decl_stmt|;
DECL|member|first_premapped_pass
name|int
name|first_premapped_pass
decl_stmt|;
comment|/* First raw pass used by this page */
DECL|member|first_normal_pass
name|int
name|first_normal_pass
decl_stmt|;
DECL|member|first_postmapped_pass
name|int
name|first_postmapped_pass
decl_stmt|;
DECL|member|first_unused_pass
name|int
name|first_unused_pass
decl_stmt|;
DECL|member|pass_premap
name|int
modifier|*
name|pass_premap
decl_stmt|;
DECL|member|stagger_premap
name|int
modifier|*
name|stagger_premap
decl_stmt|;
DECL|member|pass_postmap
name|int
modifier|*
name|pass_postmap
decl_stmt|;
DECL|member|stagger_postmap
name|int
modifier|*
name|stagger_postmap
decl_stmt|;
DECL|typedef|cooked_t
block|}
name|cooked_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
DECL|function|sort_by_start_row (int * map,int * startrows,int count)
name|sort_by_start_row
parameter_list|(
name|int
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|startrows
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|/* 	 * Yes, it's a bubble sort, but we do it no more than 4 times 	 * per page, and we are only sorting a small number of items. 	 */
name|int
name|dirty
decl_stmt|;
do|do
block|{
name|int
name|x
decl_stmt|;
name|dirty
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|count
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|startrows
index|[
name|x
operator|-
literal|1
index|]
operator|>
name|startrows
index|[
name|x
index|]
condition|)
block|{
name|int
name|temp
init|=
name|startrows
index|[
name|x
operator|-
literal|1
index|]
decl_stmt|;
name|startrows
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|startrows
index|[
name|x
index|]
expr_stmt|;
name|startrows
index|[
name|x
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|map
index|[
name|x
operator|-
literal|1
index|]
expr_stmt|;
name|map
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|map
index|[
name|x
index|]
expr_stmt|;
name|map
index|[
name|x
index|]
operator|=
name|temp
expr_stmt|;
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|dirty
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calculate_stagger (raw_t * w,int * map,int * startrows_stagger,int count)
name|calculate_stagger
parameter_list|(
name|raw_t
modifier|*
name|w
parameter_list|,
name|int
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|startrows_stagger
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|startrow
decl_stmt|,
name|subpass
decl_stmt|;
name|calculate_raw_pass_parameters
argument_list|(
name|w
argument_list|,
name|map
index|[
name|i
index|]
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
name|startrow
operator|-=
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|jets
expr_stmt|;
name|startrows_stagger
index|[
name|i
index|]
operator|=
operator|(
name|startrows_stagger
index|[
name|i
index|]
operator|-
name|startrow
operator|)
operator|/
name|w
operator|->
name|separation
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|invert_map (int * map,int * stagger,int count,int oldfirstpass,int newfirstpass)
name|invert_map
parameter_list|(
name|int
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|stagger
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|oldfirstpass
parameter_list|,
name|int
name|newfirstpass
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|newmap
decl_stmt|,
modifier|*
name|newstagger
decl_stmt|;
name|newmap
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|newstagger
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|newmap
index|[
name|map
index|[
name|i
index|]
operator|-
name|oldfirstpass
index|]
operator|=
name|i
operator|+
name|newfirstpass
expr_stmt|;
name|newstagger
index|[
name|map
index|[
name|i
index|]
operator|-
name|oldfirstpass
index|]
operator|=
name|stagger
index|[
name|i
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|map
argument_list|,
name|newmap
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stagger
argument_list|,
name|newstagger
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newstagger
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|make_passmap (raw_t * w,int ** map,int ** starts,int first_pass_number,int first_pass_to_map,int first_pass_after_map,int first_pass_to_stagger,int first_pass_after_stagger,int first_row_of_maximal_pass,int separations_to_distribute)
name|make_passmap
parameter_list|(
name|raw_t
modifier|*
name|w
parameter_list|,
name|int
modifier|*
modifier|*
name|map
parameter_list|,
name|int
modifier|*
modifier|*
name|starts
parameter_list|,
name|int
name|first_pass_number
parameter_list|,
name|int
name|first_pass_to_map
parameter_list|,
name|int
name|first_pass_after_map
parameter_list|,
name|int
name|first_pass_to_stagger
parameter_list|,
name|int
name|first_pass_after_stagger
parameter_list|,
name|int
name|first_row_of_maximal_pass
parameter_list|,
name|int
name|separations_to_distribute
parameter_list|)
block|{
name|int
modifier|*
name|passmap
decl_stmt|,
modifier|*
name|startrows
decl_stmt|;
name|int
name|passes_to_map
init|=
name|first_pass_after_map
operator|-
name|first_pass_to_map
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|first_pass_to_map
operator|<=
name|first_pass_after_map
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|first_pass_to_stagger
operator|<=
name|first_pass_after_stagger
argument_list|)
expr_stmt|;
operator|*
name|map
operator|=
name|passmap
operator|=
name|malloc
argument_list|(
name|passes_to_map
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|starts
operator|=
name|startrows
operator|=
name|malloc
argument_list|(
name|passes_to_map
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|passes_to_map
condition|;
name|i
operator|++
control|)
block|{
name|int
name|startrow
decl_stmt|,
name|subpass
decl_stmt|;
name|int
name|pass
init|=
name|i
operator|+
name|first_pass_to_map
decl_stmt|;
name|calculate_raw_pass_parameters
argument_list|(
name|w
argument_list|,
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
name|passmap
index|[
name|i
index|]
operator|=
name|pass
expr_stmt|;
if|if
condition|(
name|first_row_of_maximal_pass
operator|>=
literal|0
condition|)
name|startrow
operator|=
name|first_row_of_maximal_pass
operator|-
name|startrow
operator|+
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|jets
expr_stmt|;
else|else
name|startrow
operator|-=
name|w
operator|->
name|separation
operator|*
name|w
operator|->
name|jets
expr_stmt|;
while|while
condition|(
name|startrow
operator|<
literal|0
condition|)
name|startrow
operator|+=
name|w
operator|->
name|separation
expr_stmt|;
name|startrows
index|[
name|i
index|]
operator|=
name|startrow
expr_stmt|;
block|}
name|sort_by_start_row
argument_list|(
name|passmap
argument_list|,
name|startrows
argument_list|,
name|passes_to_map
argument_list|)
expr_stmt|;
name|separations_to_distribute
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|first_pass_after_stagger
operator|-
name|first_pass_to_stagger
condition|;
name|i
operator|++
control|)
block|{
name|int
name|offset
init|=
name|first_pass_to_stagger
operator|-
name|first_pass_to_map
decl_stmt|;
if|if
condition|(
name|startrows
index|[
name|i
operator|+
name|offset
index|]
operator|/
name|w
operator|->
name|separation
operator|<
name|i
operator|%
name|separations_to_distribute
condition|)
block|{
name|startrows
index|[
name|i
operator|+
name|offset
index|]
operator|=
name|startrows
index|[
name|i
operator|+
name|offset
index|]
operator|%
name|w
operator|->
name|separation
operator|+
name|w
operator|->
name|separation
operator|*
operator|(
name|i
operator|%
name|separations_to_distribute
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first_row_of_maximal_pass
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|passes_to_map
condition|;
name|i
operator|++
control|)
block|{
name|startrows
index|[
name|i
index|]
operator|=
name|first_row_of_maximal_pass
operator|-
name|startrows
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|sort_by_start_row
argument_list|(
name|passmap
argument_list|,
name|startrows
argument_list|,
name|passes_to_map
argument_list|)
expr_stmt|;
name|calculate_stagger
argument_list|(
name|w
argument_list|,
name|passmap
argument_list|,
name|startrows
argument_list|,
name|passes_to_map
argument_list|)
expr_stmt|;
name|invert_map
argument_list|(
name|passmap
argument_list|,
name|startrows
argument_list|,
name|passes_to_map
argument_list|,
name|first_pass_to_map
argument_list|,
name|first_pass_to_map
operator|-
name|first_pass_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calculate_pass_map (cooked_t * w,int pagelength,int firstrow,int lastrow)
name|calculate_pass_map
parameter_list|(
name|cooked_t
modifier|*
name|w
parameter_list|,
comment|/* I - weave parameters */
name|int
name|pagelength
parameter_list|,
comment|/* I - number of rows on page */
name|int
name|firstrow
parameter_list|,
comment|/* I - first printed row */
name|int
name|lastrow
parameter_list|)
comment|/* I - last printed row */
block|{
name|int
name|startrow
decl_stmt|,
name|subpass
decl_stmt|;
name|int
name|pass
init|=
operator|-
literal|1
decl_stmt|;
name|w
operator|->
name|first_row_printed
operator|=
name|firstrow
expr_stmt|;
name|w
operator|->
name|last_row_printed
operator|=
name|lastrow
expr_stmt|;
if|if
condition|(
name|pagelength
operator|<=
name|lastrow
condition|)
name|pagelength
operator|=
name|lastrow
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
operator|++
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|startrow
operator|-
name|w
operator|->
name|rw
operator|.
name|separation
operator|<
name|firstrow
condition|)
do|;
name|w
operator|->
name|first_premapped_pass
operator|=
name|pass
expr_stmt|;
while|while
condition|(
name|startrow
operator|<
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
operator|&&
name|startrow
operator|-
name|w
operator|->
name|rw
operator|.
name|separation
operator|<
name|pagelength
operator|&&
name|startrow
operator|<=
name|lastrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
condition|)
block|{
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
operator|++
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|first_normal_pass
operator|=
name|pass
expr_stmt|;
while|while
condition|(
name|startrow
operator|-
name|w
operator|->
name|rw
operator|.
name|separation
operator|<
name|pagelength
operator|&&
name|startrow
operator|<=
name|lastrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
condition|)
block|{
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
operator|++
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|first_postmapped_pass
operator|=
name|pass
expr_stmt|;
while|while
condition|(
name|startrow
operator|<=
name|lastrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
condition|)
block|{
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
operator|++
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|first_unused_pass
operator|=
name|pass
expr_stmt|;
comment|/* 	 * FIXME: make sure first_normal_pass doesn't advance beyond 	 * first_postmapped_pass, or first_postmapped_pass doesn't 	 * retreat before first_normal_pass. 	 */
if|if
condition|(
name|w
operator|->
name|first_normal_pass
operator|>
name|w
operator|->
name|first_premapped_pass
condition|)
block|{
name|int
name|spread
decl_stmt|,
name|separations_to_distribute
decl_stmt|,
name|normal_passes_mapped
decl_stmt|;
name|separations_to_distribute
operator|=
name|firstrow
operator|/
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
name|spread
operator|=
operator|(
name|separations_to_distribute
operator|+
literal|1
operator|)
operator|*
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
name|normal_passes_mapped
operator|=
operator|(
name|spread
operator|+
name|w
operator|->
name|rw
operator|.
name|advancebasis
operator|-
literal|1
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|advancebasis
expr_stmt|;
name|w
operator|->
name|first_normal_pass
operator|+=
name|normal_passes_mapped
expr_stmt|;
name|make_passmap
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
operator|&
name|w
operator|->
name|pass_premap
argument_list|,
operator|&
name|w
operator|->
name|stagger_premap
argument_list|,
name|w
operator|->
name|first_premapped_pass
argument_list|,
name|w
operator|->
name|first_premapped_pass
argument_list|,
name|w
operator|->
name|first_normal_pass
argument_list|,
name|w
operator|->
name|first_premapped_pass
argument_list|,
name|w
operator|->
name|first_normal_pass
operator|-
name|normal_passes_mapped
argument_list|,
operator|-
literal|1
argument_list|,
name|separations_to_distribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|pass_premap
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|stagger_premap
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|first_unused_pass
operator|>
name|w
operator|->
name|first_postmapped_pass
condition|)
block|{
name|int
name|spread
decl_stmt|,
name|separations_to_distribute
decl_stmt|,
name|normal_passes_mapped
decl_stmt|;
name|separations_to_distribute
operator|=
operator|(
name|pagelength
operator|-
name|lastrow
operator|-
literal|1
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
name|spread
operator|=
operator|(
name|separations_to_distribute
operator|+
literal|1
operator|)
operator|*
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
name|normal_passes_mapped
operator|=
operator|(
name|spread
operator|+
name|w
operator|->
name|rw
operator|.
name|advancebasis
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|advancebasis
expr_stmt|;
name|w
operator|->
name|first_postmapped_pass
operator|-=
name|normal_passes_mapped
expr_stmt|;
name|make_passmap
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
operator|&
name|w
operator|->
name|pass_postmap
argument_list|,
operator|&
name|w
operator|->
name|stagger_postmap
argument_list|,
name|w
operator|->
name|first_premapped_pass
argument_list|,
name|w
operator|->
name|first_postmapped_pass
argument_list|,
name|w
operator|->
name|first_unused_pass
argument_list|,
name|w
operator|->
name|first_postmapped_pass
operator|+
name|normal_passes_mapped
argument_list|,
name|w
operator|->
name|first_unused_pass
argument_list|,
name|pagelength
operator|-
literal|1
operator|-
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
operator|(
name|w
operator|->
name|rw
operator|.
name|jets
operator|-
literal|1
operator|)
argument_list|,
name|separations_to_distribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|pass_postmap
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|stagger_postmap
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
comment|/* O - weave parameter block */
DECL|function|initialize_weave_params (int S,int J,int H,int firstrow,int lastrow,int pagelength,int strategy)
name|initialize_weave_params
parameter_list|(
name|int
name|S
parameter_list|,
comment|/* I - jet separation */
name|int
name|J
parameter_list|,
comment|/* I - number of jets */
name|int
name|H
parameter_list|,
comment|/* I - oversampling factor */
name|int
name|firstrow
parameter_list|,
comment|/* I - first row number to print */
name|int
name|lastrow
parameter_list|,
comment|/* I - last row number to print */
name|int
name|pagelength
parameter_list|,
comment|/* I - number of rows on the whole                         		       page, without using any                         		       expanded margin facilities */
name|int
name|strategy
parameter_list|)
comment|/* I - weave pattern variant to use */
block|{
name|cooked_t
modifier|*
name|w
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cooked_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|initialize_raw_weave
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
name|S
argument_list|,
name|J
argument_list|,
name|H
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
name|calculate_pass_map
argument_list|(
name|w
argument_list|,
name|pagelength
argument_list|,
name|firstrow
argument_list|,
name|lastrow
argument_list|)
expr_stmt|;
block|}
return|return
name|w
return|;
block|}
end_function

begin_function
name|void
DECL|function|destroy_weave_params (void * vw)
name|destroy_weave_params
parameter_list|(
name|void
modifier|*
name|vw
parameter_list|)
block|{
name|cooked_t
modifier|*
name|w
init|=
operator|(
name|cooked_t
operator|*
operator|)
name|vw
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|pass_premap
condition|)
name|free
argument_list|(
name|w
operator|->
name|pass_premap
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|stagger_premap
condition|)
name|free
argument_list|(
name|w
operator|->
name|stagger_premap
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|pass_postmap
condition|)
name|free
argument_list|(
name|w
operator|->
name|pass_postmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|stagger_postmap
condition|)
name|free
argument_list|(
name|w
operator|->
name|stagger_postmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|calculate_row_parameters (void * vw,int row,int subpass,int * pass,int * jetnum,int * startingrow,int * ophantomrows,int * ojetsused)
name|calculate_row_parameters
parameter_list|(
name|void
modifier|*
name|vw
parameter_list|,
comment|/* I - weave parameters */
name|int
name|row
parameter_list|,
comment|/* I - row number */
name|int
name|subpass
parameter_list|,
comment|/* I - subpass */
name|int
modifier|*
name|pass
parameter_list|,
comment|/* O - pass containing row */
name|int
modifier|*
name|jetnum
parameter_list|,
comment|/* O - jet number of row */
name|int
modifier|*
name|startingrow
parameter_list|,
comment|/* O - phys start row of pass */
name|int
modifier|*
name|ophantomrows
parameter_list|,
comment|/* O - missing rows at start */
name|int
modifier|*
name|ojetsused
parameter_list|)
comment|/* O - jets used by pass */
block|{
name|cooked_t
modifier|*
name|w
init|=
operator|(
name|cooked_t
operator|*
operator|)
name|vw
decl_stmt|;
name|int
name|raw_pass
decl_stmt|,
name|jet
decl_stmt|,
name|startrow
decl_stmt|,
name|phantomrows
decl_stmt|,
name|jetsused
decl_stmt|;
name|int
name|stagger
init|=
literal|0
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|assert
argument_list|(
name|row
operator|>=
name|w
operator|->
name|first_row_printed
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|row
operator|<=
name|w
operator|->
name|last_row_printed
argument_list|)
expr_stmt|;
name|calculate_raw_row_parameters
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
name|row
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
argument_list|,
name|subpass
argument_list|,
operator|&
name|raw_pass
argument_list|,
operator|&
name|jet
argument_list|,
operator|&
name|startrow
argument_list|)
expr_stmt|;
name|startrow
operator|-=
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
expr_stmt|;
name|jetsused
operator|=
name|w
operator|->
name|rw
operator|.
name|jets
expr_stmt|;
name|phantomrows
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|raw_pass
operator|<
name|w
operator|->
name|first_normal_pass
condition|)
block|{
operator|*
name|pass
operator|=
name|w
operator|->
name|pass_premap
index|[
name|raw_pass
operator|-
name|w
operator|->
name|first_premapped_pass
index|]
expr_stmt|;
name|stagger
operator|=
name|w
operator|->
name|stagger_premap
index|[
name|raw_pass
operator|-
name|w
operator|->
name|first_premapped_pass
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raw_pass
operator|>=
name|w
operator|->
name|first_postmapped_pass
condition|)
block|{
operator|*
name|pass
operator|=
name|w
operator|->
name|pass_postmap
index|[
name|raw_pass
operator|-
name|w
operator|->
name|first_postmapped_pass
index|]
expr_stmt|;
name|stagger
operator|=
name|w
operator|->
name|stagger_postmap
index|[
name|raw_pass
operator|-
name|w
operator|->
name|first_postmapped_pass
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pass
operator|=
name|raw_pass
operator|-
name|w
operator|->
name|first_premapped_pass
expr_stmt|;
block|}
name|startrow
operator|+=
name|stagger
operator|*
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
operator|*
name|jetnum
operator|=
name|jet
operator|-
name|stagger
expr_stmt|;
if|if
condition|(
name|stagger
operator|<
literal|0
condition|)
block|{
name|stagger
operator|=
operator|-
name|stagger
expr_stmt|;
name|phantomrows
operator|+=
name|stagger
expr_stmt|;
block|}
name|jetsused
operator|-=
name|stagger
expr_stmt|;
name|extra
operator|=
name|w
operator|->
name|first_row_printed
operator|-
operator|(
name|startrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|phantomrows
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
name|extra
operator|=
operator|(
name|extra
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|-
literal|1
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
name|jetsused
operator|-=
name|extra
expr_stmt|;
name|phantomrows
operator|+=
name|extra
expr_stmt|;
block|}
name|extra
operator|=
name|startrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
operator|(
name|phantomrows
operator|+
name|jetsused
operator|-
literal|1
operator|)
operator|-
name|w
operator|->
name|last_row_printed
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
name|extra
operator|=
operator|(
name|extra
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|-
literal|1
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
name|jetsused
operator|-=
name|extra
expr_stmt|;
block|}
operator|*
name|startingrow
operator|=
name|startrow
expr_stmt|;
operator|*
name|ophantomrows
operator|=
name|phantomrows
expr_stmt|;
operator|*
name|ojetsused
operator|=
name|jetsused
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_COOKED
end_ifdef

begin_function
specifier|static
name|void
DECL|function|calculate_pass_parameters (cooked_t * w,int pass,int * startrow,int * subpass,int * phantomrows,int * jetsused)
name|calculate_pass_parameters
parameter_list|(
name|cooked_t
modifier|*
name|w
parameter_list|,
comment|/* I - weave parameters */
name|int
name|pass
parameter_list|,
comment|/* I - pass number (>= 0) */
name|int
modifier|*
name|startrow
parameter_list|,
comment|/* O - print head position */
name|int
modifier|*
name|subpass
parameter_list|,
comment|/* O - subpass number */
name|int
modifier|*
name|phantomrows
parameter_list|,
comment|/* O - missing rows */
name|int
modifier|*
name|jetsused
parameter_list|)
comment|/* O - jets used to print */
block|{
name|int
name|raw_pass
init|=
name|pass
operator|+
name|w
operator|->
name|first_premapped_pass
decl_stmt|;
name|int
name|stagger
init|=
literal|0
decl_stmt|;
name|int
name|extra
decl_stmt|;
if|if
condition|(
name|raw_pass
operator|<
name|w
operator|->
name|first_normal_pass
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|+
name|w
operator|->
name|first_premapped_pass
operator|<
name|w
operator|->
name|first_normal_pass
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|pass_premap
index|[
name|i
index|]
operator|==
name|pass
condition|)
block|{
name|raw_pass
operator|=
name|i
operator|+
name|w
operator|->
name|first_premapped_pass
expr_stmt|;
name|stagger
operator|=
name|w
operator|->
name|stagger_premap
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|raw_pass
operator|>=
name|w
operator|->
name|first_postmapped_pass
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|+
name|w
operator|->
name|first_postmapped_pass
operator|<
name|w
operator|->
name|first_unused_pass
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|pass_postmap
index|[
name|i
index|]
operator|==
name|pass
condition|)
block|{
name|raw_pass
operator|=
name|i
operator|+
name|w
operator|->
name|first_postmapped_pass
expr_stmt|;
name|stagger
operator|=
name|w
operator|->
name|stagger_postmap
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|w
operator|->
name|rw
argument_list|,
name|raw_pass
argument_list|,
name|startrow
argument_list|,
name|subpass
argument_list|)
expr_stmt|;
operator|*
name|startrow
operator|-=
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
name|w
operator|->
name|rw
operator|.
name|jets
expr_stmt|;
operator|*
name|jetsused
operator|=
name|w
operator|->
name|rw
operator|.
name|jets
expr_stmt|;
operator|*
name|phantomrows
operator|=
literal|0
expr_stmt|;
operator|*
name|startrow
operator|+=
name|stagger
operator|*
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
if|if
condition|(
name|stagger
operator|<
literal|0
condition|)
block|{
name|stagger
operator|=
operator|-
name|stagger
expr_stmt|;
operator|*
name|phantomrows
operator|+=
name|stagger
expr_stmt|;
block|}
operator|*
name|jetsused
operator|-=
name|stagger
expr_stmt|;
name|extra
operator|=
name|w
operator|->
name|first_row_printed
operator|-
operator|(
operator|*
name|startrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
operator|*
name|phantomrows
operator|)
expr_stmt|;
name|extra
operator|=
operator|(
name|extra
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|-
literal|1
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
operator|*
name|jetsused
operator|-=
name|extra
expr_stmt|;
operator|*
name|phantomrows
operator|+=
name|extra
expr_stmt|;
block|}
name|extra
operator|=
operator|*
name|startrow
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|*
operator|(
operator|*
name|phantomrows
operator|+
operator|*
name|jetsused
operator|-
literal|1
operator|)
operator|-
name|w
operator|->
name|last_row_printed
expr_stmt|;
name|extra
operator|=
operator|(
name|extra
operator|+
name|w
operator|->
name|rw
operator|.
name|separation
operator|-
literal|1
operator|)
operator|/
name|w
operator|->
name|rw
operator|.
name|separation
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
operator|*
name|jetsused
operator|-=
name|extra
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_COOKED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ACCUMULATE
end_ifdef

begin_define
DECL|macro|PUTCHAR (x)
define|#
directive|define
name|PUTCHAR
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
DECL|macro|PUTCHAR (x)
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|PUTCHAR (x)
define|#
directive|define
name|PUTCHAR
parameter_list|(
name|x
parameter_list|)
value|putchar(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|plotpass (int startrow,int phantomjets,int jetsused,int totaljets,int separation,int subpass,int * collect,int * prints)
name|plotpass
parameter_list|(
name|int
name|startrow
parameter_list|,
name|int
name|phantomjets
parameter_list|,
name|int
name|jetsused
parameter_list|,
name|int
name|totaljets
parameter_list|,
name|int
name|separation
parameter_list|,
name|int
name|subpass
parameter_list|,
name|int
modifier|*
name|collect
parameter_list|,
name|int
modifier|*
name|prints
parameter_list|)
block|{
name|int
name|hpos
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|hpos
operator|=
literal|0
init|;
name|hpos
operator|<
name|startrow
condition|;
name|hpos
operator|++
control|)
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|phantomjets
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|PUTCHAR
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|hpos
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|separation
condition|;
name|j
operator|++
control|)
block|{
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|hpos
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|phantomjets
operator|+
name|jetsused
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|phantomjets
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|separation
condition|;
name|j
operator|++
control|)
block|{
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|hpos
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hpos
operator|<
name|MAXCOLLECT
condition|)
block|{
if|if
condition|(
name|collect
index|[
name|hpos
index|]
operator|&
literal|1
operator|<<
name|subpass
condition|)
name|PUTCHAR
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|subpass
operator|<
literal|10
condition|)
name|PUTCHAR
argument_list|(
literal|'0'
operator|+
name|subpass
argument_list|)
expr_stmt|;
else|else
name|PUTCHAR
argument_list|(
literal|'A'
operator|+
name|subpass
operator|-
literal|10
argument_list|)
expr_stmt|;
name|collect
index|[
name|hpos
index|]
operator||=
literal|1
operator|<<
name|subpass
expr_stmt|;
name|prints
index|[
name|hpos
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|PUTCHAR
argument_list|(
literal|'0'
operator|+
name|subpass
argument_list|)
expr_stmt|;
block|}
name|hpos
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|++
operator|<
name|totaljets
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|separation
condition|;
name|j
operator|++
control|)
block|{
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|hpos
operator|++
expr_stmt|;
block|}
name|PUTCHAR
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACCUMULATE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXCOLLECT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|collect
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|collect
index|[
name|i
index|]
operator|<
literal|10
condition|)
name|putchar
argument_list|(
literal|'0'
operator|+
name|collect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'A'
operator|+
name|collect
index|[
name|i
index|]
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_COOKED
end_ifdef

begin_function
name|int
DECL|function|main (int ac,char * av[])
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|int
name|S
init|=
name|ac
operator|>
literal|1
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
else|:
literal|4
decl_stmt|;
name|int
name|J
init|=
name|ac
operator|>
literal|2
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
else|:
literal|12
decl_stmt|;
name|int
name|H
init|=
name|ac
operator|>
literal|3
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|3
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
name|int
name|firstrow
init|=
name|ac
operator|>
literal|4
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|4
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
name|int
name|lastrow
init|=
name|ac
operator|>
literal|5
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|5
index|]
argument_list|)
else|:
literal|100
decl_stmt|;
name|int
name|pagelength
init|=
name|ac
operator|>
literal|6
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|6
index|]
argument_list|)
else|:
literal|1000
decl_stmt|;
name|int
name|strategy
init|=
name|ac
operator|>
literal|7
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|7
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
name|cooked_t
modifier|*
name|weave
decl_stmt|;
name|int
name|passes
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|x
decl_stmt|;
name|int
name|collect
index|[
name|MAXCOLLECT
index|]
decl_stmt|;
name|int
name|prints
index|[
name|MAXCOLLECT
index|]
decl_stmt|;
name|memset
argument_list|(
name|collect
argument_list|,
literal|0
argument_list|,
name|MAXCOLLECT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|prints
argument_list|,
literal|0
argument_list|,
name|MAXCOLLECT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"S=%d  J=%d  H=%d  firstrow=%d  lastrow=%d  "
literal|"pagelength=%d  strategy=%d\n"
argument_list|,
name|S
argument_list|,
name|J
argument_list|,
name|H
argument_list|,
name|firstrow
argument_list|,
name|lastrow
argument_list|,
name|pagelength
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
name|weave
operator|=
name|initialize_weave_params
argument_list|(
name|S
argument_list|,
name|J
argument_list|,
name|H
argument_list|,
name|firstrow
argument_list|,
name|lastrow
argument_list|,
name|pagelength
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
name|passes
operator|=
name|weave
operator|->
name|first_unused_pass
operator|-
name|weave
operator|->
name|first_premapped_pass
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|passes
condition|;
name|pass
operator|++
control|)
block|{
name|int
name|startrow
decl_stmt|,
name|subpass
decl_stmt|,
name|phantomjets
decl_stmt|,
name|jetsused
decl_stmt|;
name|calculate_pass_parameters
argument_list|(
name|weave
argument_list|,
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|,
operator|&
name|phantomjets
argument_list|,
operator|&
name|jetsused
argument_list|)
expr_stmt|;
name|plotpass
argument_list|(
name|startrow
argument_list|,
name|phantomjets
argument_list|,
name|jetsused
argument_list|,
name|J
argument_list|,
name|S
argument_list|,
name|subpass
argument_list|,
name|collect
argument_list|,
name|prints
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pass
operator|=
name|MAXCOLLECT
operator|-
literal|1
init|;
name|prints
index|[
name|pass
index|]
operator|==
literal|0
condition|;
name|pass
operator|--
control|)
empty_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|pass
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|collect
index|[
name|x
index|]
operator|<
literal|10
condition|)
name|putchar
argument_list|(
literal|'0'
operator|+
name|collect
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'A'
operator|+
name|collect
index|[
name|x
index|]
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|pass
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|prints
index|[
name|x
index|]
operator|<
literal|10
condition|)
name|putchar
argument_list|(
literal|'0'
operator|+
name|prints
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'A'
operator|+
name|prints
index|[
name|x
index|]
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_COOKED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_RAW
end_ifdef

begin_function
name|int
DECL|function|main (int ac,char * av[])
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|int
name|S
init|=
name|ac
operator|>
literal|1
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
else|:
literal|4
decl_stmt|;
name|int
name|J
init|=
name|ac
operator|>
literal|2
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
else|:
literal|12
decl_stmt|;
name|int
name|h_pos
init|=
name|ac
operator|>
literal|3
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|3
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
name|int
name|h_over
init|=
name|ac
operator|>
literal|4
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|4
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
name|int
name|v_over
init|=
name|ac
operator|>
literal|5
condition|?
name|atoi
argument_list|(
name|av
index|[
literal|5
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
name|int
name|H
init|=
name|h_pos
operator|*
name|h_over
operator|*
name|v_over
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|passes
decl_stmt|,
name|x
decl_stmt|;
name|int
name|collect
index|[
name|MAXCOLLECT
index|]
decl_stmt|;
name|int
name|prints
index|[
name|MAXCOLLECT
index|]
decl_stmt|;
name|raw_t
name|raw
decl_stmt|;
name|memset
argument_list|(
name|collect
argument_list|,
literal|0
argument_list|,
name|MAXCOLLECT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|prints
argument_list|,
literal|0
argument_list|,
name|MAXCOLLECT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"S=%d  J=%d  H=%d\n"
argument_list|,
name|S
argument_list|,
name|J
argument_list|,
name|H
argument_list|)
expr_stmt|;
if|if
condition|(
name|H
operator|>
name|J
condition|)
block|{
name|printf
argument_list|(
literal|"H> J, so this weave will not work!\n"
argument_list|)
expr_stmt|;
block|}
name|passes
operator|=
name|S
operator|*
name|H
operator|*
literal|3
expr_stmt|;
name|initialize_raw_weave
argument_list|(
operator|&
name|raw
argument_list|,
name|S
argument_list|,
name|J
argument_list|,
name|H
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|passes
operator|+
name|S
operator|*
name|H
condition|;
name|pass
operator|++
control|)
block|{
name|int
name|startrow
decl_stmt|,
name|subpass
decl_stmt|,
name|phantomjets
decl_stmt|,
name|jetsused
decl_stmt|;
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|raw
argument_list|,
name|pass
argument_list|,
operator|&
name|startrow
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
name|phantomjets
operator|=
literal|0
expr_stmt|;
name|jetsused
operator|=
name|J
expr_stmt|;
name|plotpass
argument_list|(
name|startrow
argument_list|,
name|phantomjets
argument_list|,
name|jetsused
argument_list|,
name|J
argument_list|,
name|S
argument_list|,
name|subpass
argument_list|,
name|collect
argument_list|,
name|prints
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pass
operator|=
name|MAXCOLLECT
operator|-
literal|1
init|;
name|prints
index|[
name|pass
index|]
operator|==
literal|0
condition|;
name|pass
operator|--
control|)
empty_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|pass
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|collect
index|[
name|x
index|]
operator|<
literal|10
condition|)
name|putchar
argument_list|(
literal|'0'
operator|+
name|collect
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'A'
operator|+
name|collect
index|[
name|x
index|]
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|pass
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|prints
index|[
name|x
index|]
operator|<
literal|10
condition|)
name|putchar
argument_list|(
literal|'0'
operator|+
name|prints
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'A'
operator|+
name|prints
index|[
name|x
index|]
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  A  first row given by pass lookup doesn't match row lookup\n"
literal|"  B  jet out of range\n"
literal|"  C  given jet number of pass doesn't print this row\n"
literal|"  D  subpass given by reverse lookup doesn't match requested subpass\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|S
operator|*
name|J
init|;
name|x
operator|<
name|S
operator|*
name|J
operator|*
literal|20
condition|;
name|x
operator|++
control|)
block|{
name|int
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|H
condition|;
name|h
operator|++
control|)
block|{
name|int
name|pass
decl_stmt|,
name|jet
decl_stmt|,
name|start
decl_stmt|,
name|first
decl_stmt|,
name|subpass
decl_stmt|,
name|z
decl_stmt|;
name|int
name|a
init|=
literal|0
decl_stmt|,
name|b
init|=
literal|0
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|,
name|d
init|=
literal|0
decl_stmt|;
name|calculate_raw_row_parameters
argument_list|(
operator|&
name|raw
argument_list|,
name|x
argument_list|,
name|h
argument_list|,
operator|&
name|pass
argument_list|,
operator|&
name|jet
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|pass
condition|;
name|z
operator|++
control|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|jet
argument_list|)
expr_stmt|;
name|calculate_raw_pass_parameters
argument_list|(
operator|&
name|raw
argument_list|,
name|pass
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|subpass
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|start
condition|)
name|a
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|jet
operator|<
literal|0
operator|||
name|jet
operator|>=
name|J
condition|)
name|b
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|first
operator|+
name|jet
operator|*
name|S
condition|)
name|c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|subpass
operator|!=
name|h
condition|)
name|d
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a
operator|||
name|b
operator|||
name|c
operator|||
name|d
condition|)
block|{
name|printf
argument_list|(
literal|"    ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|putchar
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|putchar
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|putchar
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|putchar
argument_list|(
literal|'D'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\npass=%d first=%d start=%d jet=%d subpass=%d"
argument_list|,
name|pass
argument_list|,
name|first
argument_list|,
name|start
argument_list|,
name|jet
argument_list|,
name|subpass
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|//putchar('\n');
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_RAW */
end_comment

end_unit

