begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in for the GIMP.  *  *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *   Copyright 2000 Charles Briscoe-Smith<cpbs@debian.org>  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<gimp-print/gimp-print.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpui.h"
end_include

begin_include
include|#
directive|include
file|"print_gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*  * "Image" ADT  *  * This file defines an abstract data type called "Image".  An Image wraps  * a Gimp drawable (or some other application-level image representation)  * for presentation to the low-level printer drivers (which do CMYK  * separation, dithering and weaving).  The Image ADT has the ability  * to perform any combination of flips and rotations on the image,  * and then deliver individual rows to the driver code.  *  * Stuff which might be useful to do in this layer:  *  * - Scaling, optionally with interpolation/filtering.  *  * - Colour-adjustment.  *  * - Multiple-image composition.  *  * Also useful might be to break off a thin application-dependent  * sublayer leaving this layer (which does the interesting stuff)  * application-independent.  */
end_comment

begin_comment
comment|/* Concrete type to represent image */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon27a31c2c0108
block|{
DECL|member|drawable
name|GimpDrawable
modifier|*
name|drawable
decl_stmt|;
DECL|member|rgn
name|GimpPixelRgn
name|rgn
decl_stmt|;
comment|/*    * Transformations we can impose on the image.  The transformations    * are considered to be performed in the order given here.    */
comment|/* 1: Transpose the x and y axes (flip image over its leading diagonal) */
DECL|member|columns
name|int
name|columns
decl_stmt|;
comment|/* Set if returning columns instead of rows. */
comment|/* 2: Translate (ox,oy) to the origin */
DECL|member|ox
DECL|member|oy
name|int
name|ox
decl_stmt|,
name|oy
decl_stmt|;
comment|/* Origin of image */
comment|/* 3: Flip vertically about the x axis */
DECL|member|increment
name|int
name|increment
decl_stmt|;
comment|/* +1 or -1 for offset of row n+1 from row n. */
comment|/* 4: Crop to width w, height h */
DECL|member|w
DECL|member|h
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
comment|/* Width and height of output image */
comment|/* 5: Flip horizontally about the vertical centre-line of the image */
DECL|member|mirror
name|int
name|mirror
decl_stmt|;
comment|/* Set if mirroring rows end-for-end. */
DECL|typedef|Gimp_Image_t
block|}
name|Gimp_Image_t
typedef|;
end_typedef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|Image_get_appname
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_progress_conclude
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_note_progress
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|,
name|double
name|current
parameter_list|,
name|double
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_progress_init
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|stp_image_status_t
name|Image_get_row
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|row
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|Image_height
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|Image_width
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|Image_bpp
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_rotate_180
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_rotate_cw
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_rotate_ccw
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_crop
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_vflip
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_hflip
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_transpose
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_reset
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Image_init
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|theImage
specifier|static
name|stp_image_t
name|theImage
init|=
block|{
name|Image_init
block|,
name|Image_reset
block|,
name|Image_transpose
block|,
name|Image_hflip
block|,
name|Image_vflip
block|,
name|Image_crop
block|,
name|Image_rotate_ccw
block|,
name|Image_rotate_cw
block|,
name|Image_rotate_180
block|,
name|Image_bpp
block|,
name|Image_width
block|,
name|Image_height
block|,
name|Image_get_row
block|,
name|Image_get_appname
block|,
name|Image_progress_init
block|,
name|Image_note_progress
block|,
name|Image_progress_conclude
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|stp_image_t
modifier|*
DECL|function|Image_GimpDrawable_new (GimpDrawable * drawable)
name|Image_GimpDrawable_new
parameter_list|(
name|GimpDrawable
modifier|*
name|drawable
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Gimp_Image_t
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|->
name|drawable
operator|=
name|drawable
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
operator|(
name|i
operator|->
name|rgn
operator|)
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|theImage
operator|.
name|rep
operator|=
name|i
expr_stmt|;
name|theImage
operator|.
name|reset
argument_list|(
operator|&
name|theImage
argument_list|)
expr_stmt|;
return|return
operator|&
name|theImage
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_init (stp_image_t * image)
name|Image_init
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
comment|/* Nothing to do. */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_reset (stp_image_t * image)
name|Image_reset
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
name|i
operator|->
name|columns
operator|=
name|FALSE
expr_stmt|;
name|i
operator|->
name|ox
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|oy
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|increment
operator|=
literal|1
expr_stmt|;
name|i
operator|->
name|w
operator|=
name|i
operator|->
name|drawable
operator|->
name|width
expr_stmt|;
name|i
operator|->
name|h
operator|=
name|i
operator|->
name|drawable
operator|->
name|height
expr_stmt|;
name|i
operator|->
name|mirror
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_transpose (stp_image_t * image)
name|Image_transpose
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|mirror
condition|)
name|i
operator|->
name|ox
operator|+=
name|i
operator|->
name|w
operator|-
literal|1
expr_stmt|;
name|i
operator|->
name|columns
operator|=
operator|!
name|i
operator|->
name|columns
expr_stmt|;
name|tmp
operator|=
name|i
operator|->
name|ox
expr_stmt|;
name|i
operator|->
name|ox
operator|=
name|i
operator|->
name|oy
expr_stmt|;
name|i
operator|->
name|oy
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|i
operator|->
name|mirror
expr_stmt|;
name|i
operator|->
name|mirror
operator|=
name|i
operator|->
name|increment
operator|<
literal|0
expr_stmt|;
name|i
operator|->
name|increment
operator|=
name|tmp
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|tmp
operator|=
name|i
operator|->
name|w
expr_stmt|;
name|i
operator|->
name|w
operator|=
name|i
operator|->
name|h
expr_stmt|;
name|i
operator|->
name|h
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|mirror
condition|)
name|i
operator|->
name|ox
operator|-=
name|i
operator|->
name|w
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_hflip (stp_image_t * image)
name|Image_hflip
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
name|i
operator|->
name|mirror
operator|=
operator|!
name|i
operator|->
name|mirror
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_vflip (stp_image_t * image)
name|Image_vflip
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
name|i
operator|->
name|oy
operator|+=
operator|(
name|i
operator|->
name|h
operator|-
literal|1
operator|)
operator|*
name|i
operator|->
name|increment
expr_stmt|;
name|i
operator|->
name|increment
operator|=
operator|-
name|i
operator|->
name|increment
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Image_crop:  *  * Crop the given number of pixels off the LEFT, TOP, RIGHT and BOTTOM  * of the image.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|Image_crop (stp_image_t * image,int left,int top,int right,int bottom)
name|Image_crop
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
name|int
name|xmax
init|=
operator|(
name|i
operator|->
name|columns
condition|?
name|i
operator|->
name|drawable
operator|->
name|height
else|:
name|i
operator|->
name|drawable
operator|->
name|width
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|ymax
init|=
operator|(
name|i
operator|->
name|columns
condition|?
name|i
operator|->
name|drawable
operator|->
name|width
else|:
name|i
operator|->
name|drawable
operator|->
name|height
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|nx
init|=
name|i
operator|->
name|ox
operator|+
name|i
operator|->
name|mirror
condition|?
name|right
else|:
name|left
decl_stmt|;
name|int
name|ny
init|=
name|i
operator|->
name|oy
operator|+
name|top
operator|*
operator|(
name|i
operator|->
name|increment
operator|)
decl_stmt|;
name|int
name|nw
init|=
name|i
operator|->
name|w
operator|-
name|left
operator|-
name|right
decl_stmt|;
name|int
name|nh
init|=
name|i
operator|->
name|h
operator|-
name|top
operator|-
name|bottom
decl_stmt|;
name|int
name|wmax
decl_stmt|,
name|hmax
decl_stmt|;
if|if
condition|(
name|nx
operator|<
literal|0
condition|)
name|nx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nx
operator|>
name|xmax
condition|)
name|nx
operator|=
name|xmax
expr_stmt|;
if|if
condition|(
name|ny
operator|<
literal|0
condition|)
name|ny
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ny
operator|>
name|ymax
condition|)
name|ny
operator|=
name|ymax
expr_stmt|;
name|wmax
operator|=
name|xmax
operator|-
name|nx
operator|+
literal|1
expr_stmt|;
name|hmax
operator|=
name|i
operator|->
name|increment
condition|?
name|ny
operator|+
literal|1
else|:
name|ymax
operator|-
name|ny
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nw
operator|<
literal|1
condition|)
name|nw
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nw
operator|>
name|wmax
condition|)
name|nw
operator|=
name|wmax
expr_stmt|;
if|if
condition|(
name|nh
operator|<
literal|1
condition|)
name|nh
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nh
operator|>
name|hmax
condition|)
name|nh
operator|=
name|hmax
expr_stmt|;
name|i
operator|->
name|ox
operator|=
name|nx
expr_stmt|;
name|i
operator|->
name|oy
operator|=
name|ny
expr_stmt|;
name|i
operator|->
name|w
operator|=
name|nw
expr_stmt|;
name|i
operator|->
name|h
operator|=
name|nh
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_rotate_ccw (stp_image_t * image)
name|Image_rotate_ccw
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Image_transpose
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|Image_vflip
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_rotate_cw (stp_image_t * image)
name|Image_rotate_cw
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Image_transpose
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|Image_hflip
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_rotate_180 (stp_image_t * image)
name|Image_rotate_180
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Image_vflip
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|Image_hflip
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|Image_bpp (stp_image_t * image)
name|Image_bpp
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
return|return
name|i
operator|->
name|drawable
operator|->
name|bpp
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|Image_width (stp_image_t * image)
name|Image_width
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
return|return
name|i
operator|->
name|w
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|Image_height (stp_image_t * image)
name|Image_height
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
return|return
name|i
operator|->
name|h
return|;
block|}
end_function

begin_function
specifier|static
name|stp_image_status_t
DECL|function|Image_get_row (stp_image_t * image,unsigned char * data,int row)
name|Image_get_row
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|row
parameter_list|)
block|{
name|Gimp_Image_t
modifier|*
name|i
init|=
operator|(
name|Gimp_Image_t
operator|*
operator|)
operator|(
name|image
operator|->
name|rep
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|columns
condition|)
name|gimp_pixel_rgn_get_col
argument_list|(
operator|&
operator|(
name|i
operator|->
name|rgn
operator|)
argument_list|,
name|data
argument_list|,
name|i
operator|->
name|oy
operator|+
name|row
operator|*
name|i
operator|->
name|increment
argument_list|,
name|i
operator|->
name|ox
argument_list|,
name|i
operator|->
name|w
argument_list|)
expr_stmt|;
else|else
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
operator|(
name|i
operator|->
name|rgn
operator|)
argument_list|,
name|data
argument_list|,
name|i
operator|->
name|ox
argument_list|,
name|i
operator|->
name|oy
operator|+
name|row
operator|*
name|i
operator|->
name|increment
argument_list|,
name|i
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|mirror
condition|)
block|{
comment|/* Flip row -- probably inefficiently */
name|int
name|f
decl_stmt|,
name|l
decl_stmt|,
name|b
init|=
name|i
operator|->
name|drawable
operator|->
name|bpp
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
operator|,
name|l
operator|=
name|i
operator|->
name|w
operator|-
literal|1
init|;
name|f
operator|<
name|l
condition|;
name|f
operator|++
operator|,
name|l
operator|--
control|)
block|{
name|int
name|c
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|b
condition|;
name|c
operator|++
control|)
block|{
name|tmp
operator|=
name|data
index|[
name|f
operator|*
name|b
operator|+
name|c
index|]
expr_stmt|;
name|data
index|[
name|f
operator|*
name|b
operator|+
name|c
index|]
operator|=
name|data
index|[
name|l
operator|*
name|b
operator|+
name|c
index|]
expr_stmt|;
name|data
index|[
name|l
operator|*
name|b
operator|+
name|c
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
return|return
name|STP_IMAGE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_progress_init (stp_image_t * image)
name|Image_progress_init
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Printing"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_note_progress (stp_image_t * image,double current,double total)
name|Image_note_progress
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|,
name|double
name|current
parameter_list|,
name|double
name|total
parameter_list|)
block|{
name|gimp_progress_update
argument_list|(
name|current
operator|/
name|total
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|Image_progress_conclude (stp_image_t * image)
name|Image_progress_conclude
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
name|gimp_progress_update
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|Image_get_appname (stp_image_t * image)
name|Image_get_appname
parameter_list|(
name|stp_image_t
modifier|*
name|image
parameter_list|)
block|{
specifier|static
name|char
name|pluginname
index|[]
init|=
name|PLUG_IN_NAME
literal|" plug-in V"
name|PLUG_IN_VERSION
literal|" for GIMP"
decl_stmt|;
return|return
name|pluginname
return|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

