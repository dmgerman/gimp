begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in driver utility functions for the GIMP.  *  *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Revision History:  *  *   See ChangeLog  */
end_comment

begin_comment
comment|/*  * This file must include only standard C header files.  The core code must  * compile on generic platforms that don't support glib, gimp, gtk, etc.  */
end_comment

begin_comment
comment|/* #define PRINT_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/*  * The GNU C library provides a good rand() function, but most others  * use a separate function called random() to provide the same quality  * (and size) numbers...  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RANDOM
end_ifdef

begin_define
DECL|macro|rand
define|#
directive|define
name|rand
value|random
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_RANDOM */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|_sgi
argument_list|)
operator|&&
name|_COMPILER_VERSION
operator|>=
literal|210
operator|)
end_if

begin_define
DECL|macro|inline
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not GNU C or SGI C */
end_comment

begin_comment
comment|/* If you don't want detailed performance numbers in this file,   * uncomment this:  */
end_comment

begin_comment
comment|/*#define QUANT(x) */
end_comment

begin_define
DECL|macro|D_FLOYD_HYBRID
define|#
directive|define
name|D_FLOYD_HYBRID
value|0
end_define

begin_define
DECL|macro|D_FLOYD
define|#
directive|define
name|D_FLOYD
value|1
end_define

begin_define
DECL|macro|D_ADAPTIVE_BASE
define|#
directive|define
name|D_ADAPTIVE_BASE
value|4
end_define

begin_define
DECL|macro|D_ADAPTIVE_HYBRID
define|#
directive|define
name|D_ADAPTIVE_HYBRID
value|(D_ADAPTIVE_BASE | D_FLOYD_HYBRID)
end_define

begin_define
DECL|macro|D_ADAPTIVE_RANDOM
define|#
directive|define
name|D_ADAPTIVE_RANDOM
value|(D_ADAPTIVE_BASE | D_FLOYD)
end_define

begin_define
DECL|macro|D_ORDERED_BASE
define|#
directive|define
name|D_ORDERED_BASE
value|8
end_define

begin_define
DECL|macro|D_ORDERED
define|#
directive|define
name|D_ORDERED
value|(D_ORDERED_BASE)
end_define

begin_define
DECL|macro|D_FAST_BASE
define|#
directive|define
name|D_FAST_BASE
value|16
end_define

begin_define
DECL|macro|D_FAST
define|#
directive|define
name|D_FAST
value|(D_FAST_BASE)
end_define

begin_define
DECL|macro|D_VERY_FAST
define|#
directive|define
name|D_VERY_FAST
value|(D_FAST_BASE + 1)
end_define

begin_define
DECL|macro|DITHER_FAST_STEPS
define|#
directive|define
name|DITHER_FAST_STEPS
value|(6)
end_define

begin_define
DECL|macro|DITHER_FAST_MASK
define|#
directive|define
name|DITHER_FAST_MASK
value|((1<< DITHER_FAST_STEPS) - 1)
end_define

begin_decl_stmt
DECL|variable|dither_algo_names
name|char
modifier|*
name|dither_algo_names
index|[]
init|=
block|{
literal|"Adaptive Hybrid"
block|,
literal|"Ordered"
block|,
literal|"Fast"
block|,
literal|"Very Fast"
block|,
literal|"Adaptive Random"
block|,
literal|"Hybrid Floyd-Steinberg"
block|,
literal|"Random Floyd-Steinberg"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|num_dither_algos
name|int
name|num_dither_algos
init|=
sizeof|sizeof
argument_list|(
name|dither_algo_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|ERROR_ROWS
define|#
directive|define
name|ERROR_ROWS
value|2
end_define

begin_define
DECL|macro|NCOLORS
define|#
directive|define
name|NCOLORS
value|(4)
end_define

begin_define
DECL|macro|ECOLOR_C
define|#
directive|define
name|ECOLOR_C
value|0
end_define

begin_define
DECL|macro|ECOLOR_M
define|#
directive|define
name|ECOLOR_M
value|1
end_define

begin_define
DECL|macro|ECOLOR_Y
define|#
directive|define
name|ECOLOR_Y
value|2
end_define

begin_define
DECL|macro|ECOLOR_K
define|#
directive|define
name|ECOLOR_K
value|3
end_define

begin_define
DECL|macro|MAX_SPREAD
define|#
directive|define
name|MAX_SPREAD
value|32
end_define

begin_comment
comment|/*  * A segment of the entire 0-65536 intensity range.  */
end_comment

begin_typedef
DECL|struct|dither_segment
typedef|typedef
struct|struct
name|dither_segment
block|{
DECL|member|range_l
name|unsigned
name|range_l
decl_stmt|;
comment|/* Bottom of range */
DECL|member|range_h
name|unsigned
name|range_h
decl_stmt|;
comment|/* Top of range */
DECL|member|value_l
name|unsigned
name|value_l
decl_stmt|;
comment|/* Value of lighter ink */
DECL|member|value_h
name|unsigned
name|value_h
decl_stmt|;
comment|/* Value of upper ink */
DECL|member|bits_l
name|unsigned
name|bits_l
decl_stmt|;
comment|/* Bit pattern of lower */
DECL|member|bits_h
name|unsigned
name|bits_h
decl_stmt|;
comment|/* Bit pattern of upper */
DECL|member|range_span
name|unsigned
name|range_span
decl_stmt|;
comment|/* Span (to avoid calculation on the fly) */
DECL|member|value_span
name|unsigned
name|value_span
decl_stmt|;
comment|/* Span of values */
DECL|member|dot_size_l
name|unsigned
name|dot_size_l
decl_stmt|;
comment|/* Size of lower dot */
DECL|member|dot_size_h
name|unsigned
name|dot_size_h
decl_stmt|;
comment|/* Size of upper dot */
DECL|member|isdark_l
name|char
name|isdark_l
decl_stmt|;
comment|/* Is lower value dark ink? */
DECL|member|isdark_h
name|char
name|isdark_h
decl_stmt|;
comment|/* Is upper value dark ink? */
DECL|typedef|dither_segment_t
block|}
name|dither_segment_t
typedef|;
end_typedef

begin_typedef
DECL|struct|dither_color
typedef|typedef
struct|struct
name|dither_color
block|{
DECL|member|nlevels
name|int
name|nlevels
decl_stmt|;
DECL|member|bit_max
name|unsigned
name|bit_max
decl_stmt|;
DECL|member|signif_bits
name|unsigned
name|signif_bits
decl_stmt|;
DECL|member|ranges
name|dither_segment_t
modifier|*
name|ranges
decl_stmt|;
DECL|typedef|dither_color_t
block|}
name|dither_color_t
typedef|;
end_typedef

begin_typedef
DECL|struct|dither_matrix
typedef|typedef
struct|struct
name|dither_matrix
block|{
DECL|member|base
name|int
name|base
decl_stmt|;
DECL|member|exp
name|int
name|exp
decl_stmt|;
DECL|member|x_size
name|int
name|x_size
decl_stmt|;
DECL|member|y_size
name|int
name|y_size
decl_stmt|;
DECL|member|total_size
name|int
name|total_size
decl_stmt|;
DECL|member|last_x
name|int
name|last_x
decl_stmt|;
DECL|member|last_x_mod
name|int
name|last_x_mod
decl_stmt|;
DECL|member|last_y
name|int
name|last_y
decl_stmt|;
DECL|member|last_y_mod
name|int
name|last_y_mod
decl_stmt|;
DECL|member|index
name|int
name|index
decl_stmt|;
DECL|member|i_own
name|int
name|i_own
decl_stmt|;
DECL|member|x_offset
name|int
name|x_offset
decl_stmt|;
DECL|member|y_offset
name|int
name|y_offset
decl_stmt|;
DECL|member|matrix
name|unsigned
modifier|*
name|matrix
decl_stmt|;
DECL|typedef|dither_matrix_t
block|}
name|dither_matrix_t
typedef|;
end_typedef

begin_typedef
DECL|struct|dither
typedef|typedef
struct|struct
name|dither
block|{
DECL|member|src_width
name|int
name|src_width
decl_stmt|;
comment|/* Input width */
DECL|member|dst_width
name|int
name|dst_width
decl_stmt|;
comment|/* Output width */
DECL|member|density
name|int
name|density
decl_stmt|;
comment|/* Desired density, 0-1.0 (scaled 0-65536) */
DECL|member|k_lower
name|int
name|k_lower
decl_stmt|;
comment|/* Transition range (lower/upper) for CMY */
DECL|member|k_upper
name|int
name|k_upper
decl_stmt|;
comment|/* vs. K */
DECL|member|density2
name|int
name|density2
decl_stmt|;
comment|/* Density * 2 */
DECL|member|dlb_range
name|unsigned
name|dlb_range
decl_stmt|;
DECL|member|bound_range
name|unsigned
name|bound_range
decl_stmt|;
DECL|member|spread
name|int
name|spread
decl_stmt|;
comment|/* With Floyd-Steinberg, how widely the */
comment|/* error is distributed.  This should be */
comment|/* between 12 (very broad distribution) and */
comment|/* 19 (very narrow) */
DECL|member|c_randomizer
name|unsigned
name|c_randomizer
decl_stmt|;
comment|/* With Floyd-Steinberg dithering, control */
DECL|member|m_randomizer
name|unsigned
name|m_randomizer
decl_stmt|;
comment|/* how much randomness is applied to the */
DECL|member|y_randomizer
name|unsigned
name|y_randomizer
decl_stmt|;
comment|/* threshold values (0-65536).  With ordered */
DECL|member|k_randomizer
name|unsigned
name|k_randomizer
decl_stmt|;
comment|/* dithering, how much randomness is added */
comment|/* to the matrix value. */
DECL|member|k_clevel
name|int
name|k_clevel
decl_stmt|;
comment|/* Amount of each ink (in 64ths) required */
DECL|member|k_mlevel
name|int
name|k_mlevel
decl_stmt|;
comment|/* to create equivalent black */
DECL|member|k_ylevel
name|int
name|k_ylevel
decl_stmt|;
DECL|member|c_darkness
name|int
name|c_darkness
decl_stmt|;
comment|/* Perceived "darkness" of each ink, */
DECL|member|m_darkness
name|int
name|m_darkness
decl_stmt|;
comment|/* in 64ths, to calculate CMY-K transitions */
DECL|member|y_darkness
name|int
name|y_darkness
decl_stmt|;
DECL|member|dither_type
name|int
name|dither_type
decl_stmt|;
DECL|member|d_cutoff
name|int
name|d_cutoff
decl_stmt|;
comment|/* When ordered dither is used, threshold */
comment|/* above which no randomness is used. */
DECL|member|adaptive_divisor
name|int
name|adaptive_divisor
decl_stmt|;
DECL|member|adaptive_limit
name|int
name|adaptive_limit
decl_stmt|;
DECL|member|adaptive_lower_limit
name|int
name|adaptive_lower_limit
decl_stmt|;
DECL|member|x_aspect
name|int
name|x_aspect
decl_stmt|;
comment|/* Aspect ratio numerator */
DECL|member|y_aspect
name|int
name|y_aspect
decl_stmt|;
comment|/* Aspect ratio denominator */
DECL|member|c_dither
name|dither_color_t
name|c_dither
decl_stmt|;
DECL|member|m_dither
name|dither_color_t
name|m_dither
decl_stmt|;
DECL|member|y_dither
name|dither_color_t
name|y_dither
decl_stmt|;
DECL|member|k_dither
name|dither_color_t
name|k_dither
decl_stmt|;
DECL|member|errs
name|int
modifier|*
name|errs
index|[
name|ERROR_ROWS
index|]
index|[
name|NCOLORS
index|]
decl_stmt|;
DECL|member|vals
name|unsigned
name|short
modifier|*
name|vals
index|[
name|NCOLORS
index|]
decl_stmt|;
DECL|member|offset0_table
name|int
modifier|*
name|offset0_table
decl_stmt|;
DECL|member|offset1_table
name|int
modifier|*
name|offset1_table
decl_stmt|;
DECL|member|ink_limit
name|int
name|ink_limit
decl_stmt|;
comment|/* Maximum amount of ink that may be */
comment|/* deposited */
DECL|member|oversampling
name|int
name|oversampling
decl_stmt|;
DECL|member|last_line_was_empty
name|int
name|last_line_was_empty
decl_stmt|;
comment|/* Hardwiring these matrices in here is an abomination.  This */
comment|/* eventually needs to be cleaned up. */
DECL|member|mat6
name|dither_matrix_t
name|mat6
decl_stmt|;
DECL|member|mat7
name|dither_matrix_t
name|mat7
decl_stmt|;
DECL|member|c_pick
name|dither_matrix_t
name|c_pick
decl_stmt|;
DECL|member|c_dithermat
name|dither_matrix_t
name|c_dithermat
decl_stmt|;
DECL|member|m_pick
name|dither_matrix_t
name|m_pick
decl_stmt|;
DECL|member|m_dithermat
name|dither_matrix_t
name|m_dithermat
decl_stmt|;
DECL|member|y_pick
name|dither_matrix_t
name|y_pick
decl_stmt|;
DECL|member|y_dithermat
name|dither_matrix_t
name|y_dithermat
decl_stmt|;
DECL|member|k_pick
name|dither_matrix_t
name|k_pick
decl_stmt|;
DECL|member|k_dithermat
name|dither_matrix_t
name|k_dithermat
decl_stmt|;
DECL|typedef|dither_t
block|}
name|dither_t
typedef|;
end_typedef

begin_comment
comment|/*  * Bayer's dither matrix using Judice, Jarvis, and Ninke recurrence relation  * http://www.cs.rit.edu/~sxc7922/Project/CRT.htm  */
end_comment

begin_decl_stmt
DECL|variable|sq2
specifier|static
name|unsigned
name|sq2
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static unsigned sq3[] = {   3, 2, 7,   8, 4, 0,   1, 6, 5 };
comment|/*  * This magic square taken from  * http://www.pse.che.tohoku.ac.jp/~msuzuki/MagicSquare.5x5.selfsim.html  *  * It is magic in the following ways:  * Rows and columns  * Major and minor diagonals  * Self-complementary  * Four neighbors at distance of 1 or 2 (diagonal or lateral)  */
end_comment

begin_include
unit|static unsigned msq0[] = {   00, 14, 21, 17,  8,   22, 18,  5,  4, 11,   9,   1, 12, 23, 15,   13, 20, 19,  6,  2,   16,  7,  3, 10, 24 };  static unsigned msq1[] = {   03, 11, 20, 17,  9,   22, 19,  8,  1, 10,   06,  0, 12, 24, 18,   14, 23, 16,  5,  2,   15,  7,  4, 13, 21 };  static unsigned short quic0[] = {
include|#
directive|include
file|"quickmatrix199.h"
end_include

begin_include
unit|};  static unsigned short quic1[] = {
include|#
directive|include
file|"quickmatrix199-2.h"
end_include

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_decl_stmt
DECL|variable|quic2
specifier|static
name|unsigned
name|int
name|quic2
index|[]
init|=
block|{
include|#
directive|include
file|"quickmatrix257.h"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|rect2x1
specifier|static
name|unsigned
name|int
name|rect2x1
index|[]
init|=
block|{
include|#
directive|include
file|"ran.367.179.h"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
DECL|function|calc_ordered_point (unsigned x,unsigned y,int steps,int multiplier,int size,int * map)
name|calc_ordered_point
parameter_list|(
name|unsigned
name|x
parameter_list|,
name|unsigned
name|y
parameter_list|,
name|int
name|steps
parameter_list|,
name|int
name|multiplier
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|map
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|divisor
init|=
literal|1
decl_stmt|;
name|int
name|div1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|steps
condition|;
name|i
operator|++
control|)
block|{
name|int
name|xa
init|=
operator|(
name|x
operator|/
name|divisor
operator|)
operator|%
name|size
decl_stmt|;
name|int
name|ya
init|=
operator|(
name|y
operator|/
name|divisor
operator|)
operator|%
name|size
decl_stmt|;
name|unsigned
name|base
decl_stmt|;
name|base
operator|=
name|map
index|[
name|ya
operator|+
operator|(
name|xa
operator|*
name|size
operator|)
index|]
expr_stmt|;
name|div1
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|steps
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|div1
operator|*=
name|size
operator|*
name|size
expr_stmt|;
name|retval
operator|+=
name|base
operator|*
name|div1
expr_stmt|;
name|divisor
operator|*=
name|size
expr_stmt|;
block|}
return|return
name|retval
operator|*
name|multiplier
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|init_iterated_matrix (dither_matrix_t * mat,int size,int exp,unsigned * array)
name|init_iterated_matrix
parameter_list|(
name|dither_matrix_t
modifier|*
name|mat
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|exp
parameter_list|,
name|unsigned
modifier|*
name|array
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|mat
operator|->
name|base
operator|=
name|size
expr_stmt|;
name|mat
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|mat
operator|->
name|x_size
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
condition|;
name|i
operator|++
control|)
name|mat
operator|->
name|x_size
operator|*=
name|mat
operator|->
name|base
expr_stmt|;
name|mat
operator|->
name|y_size
operator|=
name|mat
operator|->
name|x_size
expr_stmt|;
name|mat
operator|->
name|total_size
operator|=
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
expr_stmt|;
name|mat
operator|->
name|matrix
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mat
operator|->
name|x_size
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|mat
operator|->
name|y_size
condition|;
name|y
operator|++
control|)
block|{
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|=
name|calc_ordered_point
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|mat
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
name|mat
operator|->
name|base
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|=
operator|(
name|long
name|long
operator|)
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|*
literal|65536ll
operator|/
call|(
name|long
name|long
call|)
argument_list|(
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
argument_list|)
expr_stmt|;
block|}
name|mat
operator|->
name|last_x
operator|=
name|mat
operator|->
name|last_x_mod
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|last_y
operator|=
name|mat
operator|->
name|last_y_mod
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|i_own
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|init_matrix (dither_matrix_t * mat,int x_size,int y_size,unsigned int * array,int transpose)
name|init_matrix
parameter_list|(
name|dither_matrix_t
modifier|*
name|mat
parameter_list|,
name|int
name|x_size
parameter_list|,
name|int
name|y_size
parameter_list|,
name|unsigned
name|int
modifier|*
name|array
parameter_list|,
name|int
name|transpose
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|mat
operator|->
name|base
operator|=
name|x_size
expr_stmt|;
name|mat
operator|->
name|exp
operator|=
literal|1
expr_stmt|;
name|mat
operator|->
name|x_size
operator|=
name|x_size
expr_stmt|;
name|mat
operator|->
name|y_size
operator|=
name|y_size
expr_stmt|;
name|mat
operator|->
name|total_size
operator|=
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
expr_stmt|;
name|mat
operator|->
name|matrix
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mat
operator|->
name|x_size
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|mat
operator|->
name|y_size
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|transpose
condition|)
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|=
name|array
index|[
name|y
operator|+
name|x
operator|*
name|mat
operator|->
name|y_size
index|]
expr_stmt|;
else|else
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|=
name|array
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
expr_stmt|;
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|=
operator|(
name|long
name|long
operator|)
name|mat
operator|->
name|matrix
index|[
name|x
operator|+
name|y
operator|*
name|mat
operator|->
name|x_size
index|]
operator|*
literal|65536ll
operator|/
call|(
name|long
name|long
call|)
argument_list|(
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
argument_list|)
expr_stmt|;
block|}
name|mat
operator|->
name|last_x
operator|=
name|mat
operator|->
name|last_x_mod
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|last_y
operator|=
name|mat
operator|->
name|last_y_mod
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|i_own
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void init_matrix_short(dither_matrix_t *mat, int x_size, int y_size, 		  unsigned short *array, int transpose) {   int x, y;   mat->base = x_size;   mat->exp = 1;   mat->x_size = x_size;   mat->y_size = y_size;   mat->total_size = mat->x_size * mat->y_size;   mat->matrix = malloc(sizeof(unsigned) * mat->x_size * mat->y_size);   for (x = 0; x< mat->x_size; x++)     for (y = 0; y< mat->y_size; y++)       { 	if (transpose) 	  mat->matrix[x + y * mat->x_size] = array[y + x * mat->x_size]; 	else 	  mat->matrix[x + y * mat->x_size] = array[x + y * mat->x_size]; 	mat->matrix[x + y * mat->x_size] = 	  (long long) mat->matrix[x + y * mat->x_size] * 65536ll / 	  (long long) (mat->x_size * mat->y_size);       }   mat->last_x = mat->last_x_mod = 0;   mat->last_y = mat->last_y_mod = 0;   mat->index = 0;   mat->i_own = 1; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|destroy_matrix (dither_matrix_t * mat)
name|destroy_matrix
parameter_list|(
name|dither_matrix_t
modifier|*
name|mat
parameter_list|)
block|{
if|if
condition|(
name|mat
operator|->
name|i_own
operator|&&
name|mat
operator|->
name|matrix
condition|)
name|free
argument_list|(
name|mat
operator|->
name|matrix
argument_list|)
expr_stmt|;
name|mat
operator|->
name|matrix
operator|=
name|NULL
expr_stmt|;
name|mat
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|exp
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|x_size
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|y_size
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|total_size
operator|=
literal|0
expr_stmt|;
name|mat
operator|->
name|i_own
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|clone_matrix (const dither_matrix_t * src,dither_matrix_t * dest,int x_offset,int y_offset)
name|clone_matrix
parameter_list|(
specifier|const
name|dither_matrix_t
modifier|*
name|src
parameter_list|,
name|dither_matrix_t
modifier|*
name|dest
parameter_list|,
name|int
name|x_offset
parameter_list|,
name|int
name|y_offset
parameter_list|)
block|{
name|dest
operator|->
name|base
operator|=
name|src
operator|->
name|base
expr_stmt|;
name|dest
operator|->
name|exp
operator|=
name|src
operator|->
name|exp
expr_stmt|;
name|dest
operator|->
name|x_size
operator|=
name|src
operator|->
name|x_size
expr_stmt|;
name|dest
operator|->
name|y_size
operator|=
name|src
operator|->
name|y_size
expr_stmt|;
name|dest
operator|->
name|total_size
operator|=
name|src
operator|->
name|total_size
expr_stmt|;
name|dest
operator|->
name|matrix
operator|=
name|src
operator|->
name|matrix
expr_stmt|;
name|dest
operator|->
name|x_offset
operator|=
name|x_offset
expr_stmt|;
name|dest
operator|->
name|y_offset
operator|=
name|y_offset
expr_stmt|;
name|dest
operator|->
name|last_x
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|last_x_mod
operator|=
name|dest
operator|->
name|x_offset
operator|%
name|dest
operator|->
name|x_size
expr_stmt|;
name|dest
operator|->
name|last_y
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|last_y_mod
operator|=
name|dest
operator|->
name|x_size
operator|*
operator|(
name|dest
operator|->
name|y_offset
operator|%
name|dest
operator|->
name|y_size
operator|)
expr_stmt|;
name|dest
operator|->
name|index
operator|=
name|dest
operator|->
name|last_x_mod
operator|+
name|dest
operator|->
name|last_y_mod
expr_stmt|;
name|dest
operator|->
name|i_own
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|copy_matrix (const dither_matrix_t * src,dither_matrix_t * dest)
name|copy_matrix
parameter_list|(
specifier|const
name|dither_matrix_t
modifier|*
name|src
parameter_list|,
name|dither_matrix_t
modifier|*
name|dest
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|dest
operator|->
name|base
operator|=
name|src
operator|->
name|base
expr_stmt|;
name|dest
operator|->
name|exp
operator|=
name|src
operator|->
name|exp
expr_stmt|;
name|dest
operator|->
name|x_size
operator|=
name|src
operator|->
name|x_size
expr_stmt|;
name|dest
operator|->
name|y_size
operator|=
name|src
operator|->
name|y_size
expr_stmt|;
name|dest
operator|->
name|total_size
operator|=
name|src
operator|->
name|total_size
expr_stmt|;
name|dest
operator|->
name|matrix
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|dest
operator|->
name|x_size
operator|*
name|dest
operator|->
name|y_size
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dest
operator|->
name|x_size
operator|*
name|dest
operator|->
name|y_size
condition|;
name|x
operator|++
control|)
name|dest
operator|->
name|matrix
index|[
name|x
index|]
operator|=
name|src
operator|->
name|matrix
index|[
name|x
index|]
expr_stmt|;
name|dest
operator|->
name|x_offset
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|y_offset
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|last_x
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|last_x_mod
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|last_y
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|last_y_mod
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|i_own
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|exponential_scale_matrix (dither_matrix_t * mat,double exponent)
name|exponential_scale_matrix
parameter_list|(
name|dither_matrix_t
modifier|*
name|mat
parameter_list|,
name|double
name|exponent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mat
operator|->
name|x_size
operator|*
name|mat
operator|->
name|y_size
condition|;
name|i
operator|++
control|)
block|{
name|double
name|dd
init|=
name|mat
operator|->
name|matrix
index|[
name|i
index|]
operator|/
literal|65535.0
decl_stmt|;
name|dd
operator|=
name|pow
argument_list|(
name|dd
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
name|mat
operator|->
name|matrix
index|[
name|i
index|]
operator|=
literal|65535
operator|*
name|dd
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|matrix_set_row (const dither_t * d,dither_matrix_t * mat,int y)
name|matrix_set_row
parameter_list|(
specifier|const
name|dither_t
modifier|*
name|d
parameter_list|,
name|dither_matrix_t
modifier|*
name|mat
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|mat
operator|->
name|last_y
operator|=
name|y
expr_stmt|;
name|mat
operator|->
name|last_y_mod
operator|=
name|mat
operator|->
name|x_size
operator|*
operator|(
operator|(
name|y
operator|+
name|mat
operator|->
name|y_offset
operator|)
operator|%
name|mat
operator|->
name|y_size
operator|)
expr_stmt|;
name|mat
operator|->
name|index
operator|=
name|mat
operator|->
name|last_x_mod
operator|+
name|mat
operator|->
name|last_y_mod
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
DECL|function|ditherpoint (const dither_t * d,dither_matrix_t * mat,int x)
name|ditherpoint
parameter_list|(
specifier|const
name|dither_t
modifier|*
name|d
parameter_list|,
name|dither_matrix_t
modifier|*
name|mat
parameter_list|,
name|int
name|x
parameter_list|)
block|{
comment|/*    * This rather bizarre code is an attempt to avoid having to compute a lot    * of modulus and multiplication operations, which are typically slow.    */
if|if
condition|(
name|x
operator|==
name|mat
operator|->
name|last_x
operator|+
literal|1
condition|)
block|{
name|mat
operator|->
name|last_x
operator|=
name|x
expr_stmt|;
name|mat
operator|->
name|last_x_mod
operator|++
expr_stmt|;
name|mat
operator|->
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|mat
operator|->
name|last_x_mod
operator|>=
name|mat
operator|->
name|x_size
condition|)
block|{
name|mat
operator|->
name|last_x_mod
operator|-=
name|mat
operator|->
name|x_size
expr_stmt|;
name|mat
operator|->
name|index
operator|-=
name|mat
operator|->
name|x_size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|mat
operator|->
name|last_x
operator|-
literal|1
condition|)
block|{
name|mat
operator|->
name|last_x
operator|=
name|x
expr_stmt|;
name|mat
operator|->
name|last_x_mod
operator|--
expr_stmt|;
name|mat
operator|->
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|mat
operator|->
name|last_x_mod
operator|<
literal|0
condition|)
block|{
name|mat
operator|->
name|last_x_mod
operator|+=
name|mat
operator|->
name|x_size
expr_stmt|;
name|mat
operator|->
name|index
operator|+=
name|mat
operator|->
name|x_size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|mat
operator|->
name|last_x
condition|)
block|{     }
else|else
block|{
name|mat
operator|->
name|last_x
operator|=
name|x
expr_stmt|;
name|mat
operator|->
name|last_x_mod
operator|=
operator|(
name|x
operator|+
name|mat
operator|->
name|x_offset
operator|)
operator|%
name|mat
operator|->
name|x_size
expr_stmt|;
name|mat
operator|->
name|index
operator|=
name|mat
operator|->
name|last_x_mod
operator|+
name|mat
operator|->
name|last_y_mod
expr_stmt|;
block|}
return|return
name|mat
operator|->
name|matrix
index|[
name|mat
operator|->
name|index
index|]
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
DECL|function|ditherpoint_fast (const dither_t * d,dither_matrix_t * mat,int x)
name|ditherpoint_fast
parameter_list|(
specifier|const
name|dither_t
modifier|*
name|d
parameter_list|,
name|dither_matrix_t
modifier|*
name|mat
parameter_list|,
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|mat
operator|->
name|exp
operator|==
literal|1
condition|)
return|return
name|ditherpoint
argument_list|(
name|d
argument_list|,
name|mat
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|mat
operator|->
name|matrix
index|[
operator|(
name|mat
operator|->
name|last_y_mod
operator|+
operator|(
operator|(
name|x
operator|+
name|mat
operator|->
name|x_offset
operator|)
operator|&
name|DITHER_FAST_MASK
operator|)
operator|)
index|]
return|;
block|}
end_function

begin_function
name|void
modifier|*
DECL|function|init_dither (int in_width,int out_width,int horizontal_aspect,int vertical_aspect,vars_t * v)
name|init_dither
parameter_list|(
name|int
name|in_width
parameter_list|,
name|int
name|out_width
parameter_list|,
name|int
name|horizontal_aspect
parameter_list|,
name|int
name|vertical_aspect
parameter_list|,
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
name|int
name|x_3
decl_stmt|,
name|y_3
decl_stmt|;
name|dither_t
modifier|*
name|d
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dither_t
argument_list|)
argument_list|)
decl_stmt|;
name|simple_dither_range_t
name|r
decl_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dither_t
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|value
operator|=
literal|1.0
expr_stmt|;
name|r
operator|.
name|bit_pattern
operator|=
literal|1
expr_stmt|;
name|r
operator|.
name|is_dark
operator|=
literal|1
expr_stmt|;
name|r
operator|.
name|dot_size
operator|=
literal|1
expr_stmt|;
name|dither_set_c_ranges
argument_list|(
name|d
argument_list|,
literal|1
argument_list|,
operator|&
name|r
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|dither_set_m_ranges
argument_list|(
name|d
argument_list|,
literal|1
argument_list|,
operator|&
name|r
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|dither_set_y_ranges
argument_list|(
name|d
argument_list|,
literal|1
argument_list|,
operator|&
name|r
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|dither_set_k_ranges
argument_list|(
name|d
argument_list|,
literal|1
argument_list|,
operator|&
name|r
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset0_table
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|offset1_table
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|x_aspect
operator|=
name|horizontal_aspect
expr_stmt|;
name|d
operator|->
name|y_aspect
operator|=
name|vertical_aspect
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Hybrid Floyd-Steinberg"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_FLOYD_HYBRID
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Random Floyd-Steinberg"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_FLOYD
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Ordered"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_ORDERED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Adaptive Hybrid"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_ADAPTIVE_HYBRID
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Adaptive Random"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_ADAPTIVE_RANDOM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Fast"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_FAST
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
literal|"Very Fast"
argument_list|)
condition|)
name|d
operator|->
name|dither_type
operator|=
name|D_VERY_FAST
expr_stmt|;
else|else
name|d
operator|->
name|dither_type
operator|=
name|D_FLOYD_HYBRID
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dither_type
operator|==
name|D_VERY_FAST
condition|)
name|init_iterated_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
literal|2
argument_list|,
name|DITHER_FAST_STEPS
argument_list|,
name|sq2
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|d
operator|->
name|y_aspect
operator|/
name|d
operator|->
name|x_aspect
operator|==
literal|2
condition|)
name|init_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
literal|367
argument_list|,
literal|179
argument_list|,
name|rect2x1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|x_aspect
operator|/
name|d
operator|->
name|y_aspect
operator|==
literal|2
condition|)
name|init_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
literal|179
argument_list|,
literal|367
argument_list|,
name|rect2x1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|init_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
literal|257
argument_list|,
literal|257
argument_list|,
name|quic2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|x_3
operator|=
name|d
operator|->
name|mat6
operator|.
name|x_size
operator|/
literal|3
expr_stmt|;
name|y_3
operator|=
name|d
operator|->
name|mat6
operator|.
name|y_size
operator|/
literal|3
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_dithermat
operator|)
argument_list|,
literal|2
operator|*
name|x_3
argument_list|,
name|y_3
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_dithermat
operator|)
argument_list|,
name|x_3
argument_list|,
literal|2
operator|*
name|y_3
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_dithermat
operator|)
argument_list|,
literal|0
argument_list|,
name|y_3
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dither_set_transition
argument_list|(
name|d
argument_list|,
literal|.6
argument_list|)
expr_stmt|;
name|d
operator|->
name|src_width
operator|=
name|in_width
expr_stmt|;
name|d
operator|->
name|dst_width
operator|=
name|out_width
expr_stmt|;
name|d
operator|->
name|adaptive_divisor
operator|=
literal|2
expr_stmt|;
name|dither_set_max_ink
argument_list|(
name|d
argument_list|,
name|INT_MAX
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|dither_set_ink_spread
argument_list|(
name|d
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|dither_set_black_lower
argument_list|(
name|d
argument_list|,
literal|.4
argument_list|)
expr_stmt|;
name|dither_set_black_upper
argument_list|(
name|d
argument_list|,
literal|.7
argument_list|)
expr_stmt|;
name|dither_set_black_levels
argument_list|(
name|d
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|dither_set_randomizers
argument_list|(
name|d
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|dither_set_ink_darkness
argument_list|(
name|d
argument_list|,
literal|.4
argument_list|,
literal|.3
argument_list|,
literal|.2
argument_list|)
expr_stmt|;
name|dither_set_density
argument_list|(
name|d
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_transition (void * vd,double exponent)
name|dither_set_transition
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|exponent
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|int
name|x_3
init|=
name|d
operator|->
name|mat6
operator|.
name|x_size
operator|/
literal|3
decl_stmt|;
name|int
name|y_3
init|=
name|d
operator|->
name|mat6
operator|.
name|y_size
operator|/
literal|3
decl_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|c_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|m_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|y_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|)
expr_stmt|;
name|copy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|)
expr_stmt|;
name|exponential_scale_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_pick
operator|)
argument_list|,
name|x_3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_pick
operator|)
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|y_3
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_pick
operator|)
argument_list|,
literal|2
operator|*
name|x_3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clone_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|,
name|x_3
argument_list|,
literal|2
operator|*
name|y_3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_density (void * vd,double density)
name|dither_set_density
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
if|if
condition|(
name|density
operator|>
literal|1
condition|)
name|density
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|density
operator|<
literal|0
condition|)
name|density
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|k_upper
operator|=
name|d
operator|->
name|k_upper
operator|*
name|density
expr_stmt|;
name|d
operator|->
name|k_lower
operator|=
name|d
operator|->
name|k_lower
operator|*
name|density
expr_stmt|;
name|d
operator|->
name|density
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|65536
operator|*
name|density
operator|)
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|d
operator|->
name|density2
operator|=
literal|2
operator|*
name|d
operator|->
name|density
expr_stmt|;
name|d
operator|->
name|dlb_range
operator|=
name|d
operator|->
name|density
operator|-
name|d
operator|->
name|k_lower
expr_stmt|;
name|d
operator|->
name|bound_range
operator|=
name|d
operator|->
name|k_upper
operator|-
name|d
operator|->
name|k_lower
expr_stmt|;
name|d
operator|->
name|d_cutoff
operator|=
name|d
operator|->
name|density
operator|/
literal|16
expr_stmt|;
name|d
operator|->
name|adaptive_limit
operator|=
name|d
operator|->
name|density
operator|/
name|d
operator|->
name|adaptive_divisor
expr_stmt|;
name|d
operator|->
name|adaptive_lower_limit
operator|=
name|d
operator|->
name|adaptive_limit
operator|/
literal|4
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|double
DECL|function|imax (double a,double b)
name|imax
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
name|a
operator|>
name|b
operator|)
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_max_ink (void * vd,int levels,double max_ink)
name|dither_set_max_ink
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|levels
parameter_list|,
name|double
name|max_ink
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|ink_limit
operator|=
name|imax
argument_list|(
name|max_ink
argument_list|,
literal|1
argument_list|)
operator|*
name|levels
expr_stmt|;
name|d
operator|->
name|ink_limit
operator|=
name|max_ink
operator|*
name|levels
operator|+
literal|0.5
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Maxink: %f %d\n"
argument_list|,
name|max_ink
argument_list|,
name|d
operator|->
name|ink_limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|dither_set_adaptive_divisor (void * vd,unsigned divisor)
name|dither_set_adaptive_divisor
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|unsigned
name|divisor
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|adaptive_divisor
operator|=
name|divisor
expr_stmt|;
name|d
operator|->
name|adaptive_limit
operator|=
name|d
operator|->
name|density
operator|/
name|d
operator|->
name|adaptive_divisor
expr_stmt|;
name|d
operator|->
name|adaptive_lower_limit
operator|=
name|d
operator|->
name|adaptive_limit
operator|/
literal|4
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_black_lower (void * vd,double k_lower)
name|dither_set_black_lower
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|k_lower
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|k_lower
operator|=
call|(
name|int
call|)
argument_list|(
name|k_lower
operator|*
literal|65536
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_black_upper (void * vd,double k_upper)
name|dither_set_black_upper
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|k_upper
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|k_upper
operator|=
call|(
name|int
call|)
argument_list|(
name|k_upper
operator|*
literal|65536
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_ink_spread (void * vd,int spread)
name|dither_set_ink_spread
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|spread
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|offset0_table
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|offset0_table
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset0_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|offset1_table
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|offset1_table
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset1_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|spread
operator|>=
literal|16
condition|)
block|{
name|d
operator|->
name|spread
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|int
name|max_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|spread
operator|=
name|spread
expr_stmt|;
name|max_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
name|spread
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|offset0_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_offset
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset1_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_offset
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|->
name|offset0_table
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|d
operator|->
name|offset1_table
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|i
operator|)
operator|/
literal|2
expr_stmt|;
block|}
block|}
name|d
operator|->
name|adaptive_limit
operator|=
name|d
operator|->
name|density
operator|/
name|d
operator|->
name|adaptive_divisor
expr_stmt|;
name|d
operator|->
name|adaptive_lower_limit
operator|=
name|d
operator|->
name|adaptive_limit
operator|/
literal|4
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_black_levels (void * vd,double c,double m,double y)
name|dither_set_black_levels
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|m
parameter_list|,
name|double
name|y
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|k_clevel
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|*
literal|64
argument_list|)
expr_stmt|;
name|d
operator|->
name|k_mlevel
operator|=
call|(
name|int
call|)
argument_list|(
name|m
operator|*
literal|64
argument_list|)
expr_stmt|;
name|d
operator|->
name|k_ylevel
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|*
literal|64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_randomizers (void * vd,double c,double m,double y,double k)
name|dither_set_randomizers
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|m
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|k
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|c_randomizer
operator|=
name|c
operator|*
literal|65536
expr_stmt|;
name|d
operator|->
name|m_randomizer
operator|=
name|m
operator|*
literal|65536
expr_stmt|;
name|d
operator|->
name|y_randomizer
operator|=
name|y
operator|*
literal|65536
expr_stmt|;
name|d
operator|->
name|k_randomizer
operator|=
name|k
operator|*
literal|65536
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_ink_darkness (void * vd,double c,double m,double y)
name|dither_set_ink_darkness
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|m
parameter_list|,
name|double
name|y
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|d
operator|->
name|c_darkness
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|*
literal|64
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_darkness
operator|=
call|(
name|int
call|)
argument_list|(
name|m
operator|*
literal|64
argument_list|)
expr_stmt|;
name|d
operator|->
name|y_darkness
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|*
literal|64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_light_inks (void * vd,double c,double m,double y,double density)
name|dither_set_light_inks
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|m
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|simple_dither_range_t
name|range
index|[
literal|2
index|]
decl_stmt|;
name|range
index|[
literal|0
index|]
operator|.
name|bit_pattern
operator|=
literal|1
expr_stmt|;
name|range
index|[
literal|0
index|]
operator|.
name|is_dark
operator|=
literal|0
expr_stmt|;
name|range
index|[
literal|1
index|]
operator|.
name|value
operator|=
literal|1
expr_stmt|;
name|range
index|[
literal|1
index|]
operator|.
name|bit_pattern
operator|=
literal|1
expr_stmt|;
name|range
index|[
literal|1
index|]
operator|.
name|is_dark
operator|=
literal|1
expr_stmt|;
name|range
index|[
literal|1
index|]
operator|.
name|dot_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|range
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|c
expr_stmt|;
name|range
index|[
literal|0
index|]
operator|.
name|dot_size
operator|=
literal|1
expr_stmt|;
name|dither_set_c_ranges
argument_list|(
name|vd
argument_list|,
literal|2
argument_list|,
name|range
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|>
literal|0
condition|)
block|{
name|range
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|m
expr_stmt|;
name|range
index|[
literal|0
index|]
operator|.
name|dot_size
operator|=
literal|1
expr_stmt|;
name|dither_set_m_ranges
argument_list|(
name|vd
argument_list|,
literal|2
argument_list|,
name|range
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|range
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|y
expr_stmt|;
name|range
index|[
literal|0
index|]
operator|.
name|dot_size
operator|=
literal|1
expr_stmt|;
name|dither_set_y_ranges
argument_list|(
name|vd
argument_list|,
literal|2
argument_list|,
name|range
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dither_set_ranges (dither_color_t * s,int nlevels,const simple_dither_range_t * ranges,double density)
name|dither_set_ranges
parameter_list|(
name|dither_color_t
modifier|*
name|s
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|simple_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|lbit
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ranges
condition|)
name|free
argument_list|(
name|s
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|s
operator|->
name|nlevels
operator|=
name|nlevels
operator|>
literal|1
condition|?
name|nlevels
operator|+
literal|1
else|:
name|nlevels
expr_stmt|;
name|s
operator|->
name|ranges
operator|=
operator|(
name|dither_segment_t
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|->
name|nlevels
operator|*
sizeof|sizeof
argument_list|(
name|dither_segment_t
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|bit_max
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dither_set_ranges nlevels %d density %f\n"
argument_list|,
name|nlevels
argument_list|,
name|density
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  level %d value %f pattern %x is_dark %d\n"
argument_list|,
name|i
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|bit_pattern
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|is_dark
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_l
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|value_l
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|value
operator|*
literal|65536.0
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_l
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|bit_pattern
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_l
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|is_dark
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|dot_size_l
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|dot_size
expr_stmt|;
if|if
condition|(
name|nlevels
operator|==
literal|1
condition|)
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_h
operator|=
literal|65536
expr_stmt|;
else|else
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_h
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|value
operator|*
literal|65536.0
operator|*
name|density
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_h
operator|>
literal|65536
condition|)
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_h
operator|=
literal|65536
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|value_h
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|value
operator|*
literal|65536.0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|value_h
operator|>
literal|65536
condition|)
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|value_h
operator|=
literal|65536
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_h
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|bit_pattern
expr_stmt|;
if|if
condition|(
name|ranges
index|[
literal|0
index|]
operator|.
name|bit_pattern
operator|>
name|s
operator|->
name|bit_max
condition|)
name|s
operator|->
name|bit_max
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|bit_pattern
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_h
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|is_dark
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|dot_size_h
operator|=
name|ranges
index|[
literal|0
index|]
operator|.
name|dot_size
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_span
operator|=
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|range_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|value_span
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nlevels
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l
init|=
name|i
operator|+
literal|1
decl_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|bits_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|isdark_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|dot_size_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|dot_size_h
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nlevels
operator|-
literal|1
condition|)
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_h
operator|=
literal|65536
expr_stmt|;
else|else
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_h
operator|=
operator|(
name|ranges
index|[
name|l
index|]
operator|.
name|value
operator|+
name|ranges
index|[
name|l
index|]
operator|.
name|value
operator|)
operator|*
literal|65536.0
operator|*
name|density
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_h
operator|>
literal|65536
condition|)
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_h
operator|=
literal|65536
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_h
operator|=
name|ranges
index|[
name|l
index|]
operator|.
name|value
operator|*
literal|65536.0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_h
operator|>
literal|65536
condition|)
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_h
operator|=
literal|65536
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|bits_h
operator|=
name|ranges
index|[
name|l
index|]
operator|.
name|bit_pattern
expr_stmt|;
if|if
condition|(
name|ranges
index|[
name|l
index|]
operator|.
name|bit_pattern
operator|>
name|s
operator|->
name|bit_max
condition|)
name|s
operator|->
name|bit_max
operator|=
name|ranges
index|[
name|l
index|]
operator|.
name|bit_pattern
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|isdark_h
operator|=
name|ranges
index|[
name|l
index|]
operator|.
name|is_dark
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|dot_size_h
operator|=
name|ranges
index|[
name|l
index|]
operator|.
name|dot_size
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_span
operator|=
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_h
operator|-
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|range_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_span
operator|=
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_h
operator|-
name|s
operator|->
name|ranges
index|[
name|l
index|]
operator|.
name|value_l
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|range_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|value_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bits_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|isdark_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|dot_size_l
operator|=
name|s
operator|->
name|ranges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|dot_size_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_h
operator|=
literal|65536
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_h
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|dot_size_h
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|dot_size_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_span
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_h
operator|-
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_span
operator|=
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
operator|-
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
expr_stmt|;
block|}
name|lbit
operator|=
name|s
operator|->
name|bit_max
expr_stmt|;
name|s
operator|->
name|signif_bits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lbit
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|signif_bits
operator|++
expr_stmt|;
name|lbit
operator|>>=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    level %d value_l %d value_h %d range_l %d range_h %d\n"
argument_list|,
name|i
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_h
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       bits_l %d bits_h %d isdark_l %d isdark_h %d\n"
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_h
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       rangespan %d valuespan %d\n"
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_span
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_span
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  bit_max %d signif_bits %d\n"
argument_list|,
name|s
operator|->
name|bit_max
argument_list|,
name|s
operator|->
name|signif_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dither_set_ranges_full (dither_color_t * s,int nlevels,const full_dither_range_t * ranges,double density,int max_ink)
name|dither_set_ranges_full
parameter_list|(
name|dither_color_t
modifier|*
name|s
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|full_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|,
name|int
name|max_ink
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|lbit
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ranges
condition|)
name|free
argument_list|(
name|s
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|s
operator|->
name|nlevels
operator|=
name|nlevels
operator|>
literal|1
condition|?
name|nlevels
operator|+
literal|1
else|:
name|nlevels
expr_stmt|;
name|s
operator|->
name|nlevels
operator|=
name|nlevels
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|ranges
operator|=
operator|(
name|dither_segment_t
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|->
name|nlevels
operator|*
sizeof|sizeof
argument_list|(
name|dither_segment_t
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|bit_max
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dither_set_ranges nlevels %d density %f\n"
argument_list|,
name|nlevels
argument_list|,
name|density
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  level %d value: low %f high %f pattern low %x high %x is_dark low %d high %d\n"
argument_list|,
name|i
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_l
argument_list|,
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_h
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
operator|>
name|s
operator|->
name|bit_max
condition|)
name|s
operator|->
name|bit_max
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
expr_stmt|;
if|if
condition|(
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
operator|>
name|s
operator|->
name|bit_max
condition|)
name|s
operator|->
name|bit_max
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|dot_size_l
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
expr_stmt|;
comment|/* FIXME */
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|dot_size_h
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
expr_stmt|;
comment|/*if(s->ranges[j].dot_size_l> max_ink || s->ranges[j].dot_size_h> max_ink) 		   continue;*/
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_l
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
operator|*
literal|65535
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_h
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
operator|*
literal|65535
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_l
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_l
operator|*
name|density
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_h
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_h
operator|*
name|density
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bits_l
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bits_h
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|isdark_l
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|isdark_h
operator|=
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_span
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_h
operator|-
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_span
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_h
operator|-
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_l
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_l
operator|=
name|s
operator|->
name|ranges
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|range_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_l
operator|=
name|s
operator|->
name|ranges
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|value_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bits_l
operator|=
name|s
operator|->
name|ranges
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|bits_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|isdark_l
operator|=
name|s
operator|->
name|ranges
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|isdark_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|dot_size_l
operator|=
name|s
operator|->
name|ranges
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|dot_size_h
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_h
operator|=
literal|65535
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_h
operator|=
literal|65535
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bits_h
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bits_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|isdark_h
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|isdark_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|dot_size_h
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|dot_size_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_span
operator|=
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_h
operator|-
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|range_l
expr_stmt|;
name|s
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|value_span
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|nlevels
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|lbit
operator|=
name|s
operator|->
name|bit_max
expr_stmt|;
name|s
operator|->
name|signif_bits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lbit
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|signif_bits
operator|++
expr_stmt|;
name|lbit
operator|>>=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    level %d value_l %d value_h %d range_l %d range_h %d\n"
argument_list|,
name|i
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_h
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_h
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       bits_l %d bits_h %d isdark_l %d isdark_h %d\n"
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|bits_h
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_l
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|isdark_h
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       rangespan %d valuespan %d\n"
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|range_span
argument_list|,
name|s
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|value_span
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  bit_max %d signif_bits %d\n"
argument_list|,
name|s
operator|->
name|bit_max
argument_list|,
name|s
operator|->
name|signif_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
DECL|function|dither_set_c_ranges (void * vd,int nlevels,const simple_dither_range_t * ranges,double density)
name|dither_set_c_ranges
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|simple_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges
argument_list|(
operator|&
operator|(
name|d
operator|->
name|c_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_c_ranges_simple (void * vd,int nlevels,const double * levels,double density)
name|dither_set_c_ranges_simple
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|double
modifier|*
name|levels
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|simple_dither_range_t
modifier|*
name|r
init|=
name|malloc
argument_list|(
name|nlevels
operator|*
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|r
index|[
name|i
index|]
operator|.
name|bit_pattern
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|dot_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|value
operator|=
name|levels
index|[
name|i
index|]
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|is_dark
operator|=
literal|1
expr_stmt|;
block|}
name|dither_set_c_ranges
argument_list|(
name|vd
argument_list|,
name|nlevels
argument_list|,
name|r
argument_list|,
name|density
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_c_ranges_full (void * vd,int nlevels,const full_dither_range_t * ranges,double density)
name|dither_set_c_ranges_full
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|full_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges_full
argument_list|(
operator|&
operator|(
name|d
operator|->
name|c_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|,
name|d
operator|->
name|ink_limit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_m_ranges (void * vd,int nlevels,const simple_dither_range_t * ranges,double density)
name|dither_set_m_ranges
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|simple_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges
argument_list|(
operator|&
operator|(
name|d
operator|->
name|m_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_m_ranges_simple (void * vd,int nlevels,const double * levels,double density)
name|dither_set_m_ranges_simple
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|double
modifier|*
name|levels
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|simple_dither_range_t
modifier|*
name|r
init|=
name|malloc
argument_list|(
name|nlevels
operator|*
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|r
index|[
name|i
index|]
operator|.
name|bit_pattern
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|dot_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|value
operator|=
name|levels
index|[
name|i
index|]
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|is_dark
operator|=
literal|1
expr_stmt|;
block|}
name|dither_set_m_ranges
argument_list|(
name|vd
argument_list|,
name|nlevels
argument_list|,
name|r
argument_list|,
name|density
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_m_ranges_full (void * vd,int nlevels,const full_dither_range_t * ranges,double density)
name|dither_set_m_ranges_full
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|full_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges_full
argument_list|(
operator|&
operator|(
name|d
operator|->
name|m_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|,
name|d
operator|->
name|ink_limit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_y_ranges (void * vd,int nlevels,const simple_dither_range_t * ranges,double density)
name|dither_set_y_ranges
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|simple_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges
argument_list|(
operator|&
operator|(
name|d
operator|->
name|y_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_y_ranges_simple (void * vd,int nlevels,const double * levels,double density)
name|dither_set_y_ranges_simple
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|double
modifier|*
name|levels
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|simple_dither_range_t
modifier|*
name|r
init|=
name|malloc
argument_list|(
name|nlevels
operator|*
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|r
index|[
name|i
index|]
operator|.
name|bit_pattern
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|dot_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|value
operator|=
name|levels
index|[
name|i
index|]
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|is_dark
operator|=
literal|1
expr_stmt|;
block|}
name|dither_set_y_ranges
argument_list|(
name|vd
argument_list|,
name|nlevels
argument_list|,
name|r
argument_list|,
name|density
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_y_ranges_full (void * vd,int nlevels,const full_dither_range_t * ranges,double density)
name|dither_set_y_ranges_full
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|full_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges_full
argument_list|(
operator|&
operator|(
name|d
operator|->
name|y_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|,
name|d
operator|->
name|ink_limit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_k_ranges (void * vd,int nlevels,const simple_dither_range_t * ranges,double density)
name|dither_set_k_ranges
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|simple_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges
argument_list|(
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_k_ranges_simple (void * vd,int nlevels,const double * levels,double density)
name|dither_set_k_ranges_simple
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|double
modifier|*
name|levels
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|simple_dither_range_t
modifier|*
name|r
init|=
name|malloc
argument_list|(
name|nlevels
operator|*
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
name|r
index|[
name|i
index|]
operator|.
name|bit_pattern
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|dot_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|value
operator|=
name|levels
index|[
name|i
index|]
expr_stmt|;
name|r
index|[
name|i
index|]
operator|.
name|is_dark
operator|=
literal|1
expr_stmt|;
block|}
name|dither_set_k_ranges
argument_list|(
name|vd
argument_list|,
name|nlevels
argument_list|,
name|r
argument_list|,
name|density
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_set_k_ranges_full (void * vd,int nlevels,const full_dither_range_t * ranges,double density)
name|dither_set_k_ranges_full
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|,
name|int
name|nlevels
parameter_list|,
specifier|const
name|full_dither_range_t
modifier|*
name|ranges
parameter_list|,
name|double
name|density
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_set_ranges_full
argument_list|(
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
argument_list|,
name|nlevels
argument_list|,
name|ranges
argument_list|,
name|density
argument_list|,
name|d
operator|->
name|ink_limit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|free_dither (void * vd)
name|free_dither
parameter_list|(
name|void
modifier|*
name|vd
parameter_list|)
block|{
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCOLORS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|vals
index|[
name|j
index|]
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|vals
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|vals
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ERROR_ROWS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|errs
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|errs
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|errs
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|d
operator|->
name|c_dither
operator|.
name|ranges
argument_list|)
expr_stmt|;
name|d
operator|->
name|c_dither
operator|.
name|ranges
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|m_dither
operator|.
name|ranges
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_dither
operator|.
name|ranges
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|y_dither
operator|.
name|ranges
argument_list|)
expr_stmt|;
name|d
operator|->
name|y_dither
operator|.
name|ranges
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|k_dither
operator|.
name|ranges
argument_list|)
expr_stmt|;
name|d
operator|->
name|k_dither
operator|.
name|ranges
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|offset0_table
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|offset0_table
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset0_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|offset1_table
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|offset1_table
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset1_table
operator|=
name|NULL
expr_stmt|;
block|}
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|c_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|c_dithermat
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|m_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|m_dithermat
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|y_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|y_dithermat
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat6
operator|)
argument_list|)
expr_stmt|;
name|destroy_matrix
argument_list|(
operator|&
operator|(
name|d
operator|->
name|mat7
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
DECL|function|get_errline (dither_t * d,int row,int color)
name|get_errline
parameter_list|(
name|dither_t
modifier|*
name|d
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|color
parameter_list|)
block|{
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|color
operator|<
literal|0
operator|||
name|color
operator|>=
name|NCOLORS
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d
operator|->
name|errs
index|[
name|row
operator|&
literal|1
index|]
index|[
name|color
index|]
condition|)
return|return
name|d
operator|->
name|errs
index|[
name|row
operator|&
literal|1
index|]
index|[
name|color
index|]
operator|+
name|MAX_SPREAD
return|;
else|else
block|{
name|int
name|size
init|=
literal|2
operator|*
name|MAX_SPREAD
operator|+
operator|(
literal|16
operator|*
operator|(
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|)
decl_stmt|;
name|d
operator|->
name|errs
index|[
name|row
operator|&
literal|1
index|]
index|[
name|color
index|]
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|errs
index|[
name|row
operator|&
literal|1
index|]
index|[
name|color
index|]
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|errs
index|[
name|row
operator|&
literal|1
index|]
index|[
name|color
index|]
operator|+
name|MAX_SPREAD
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|short
modifier|*
DECL|function|get_valueline (dither_t * d,int color)
name|get_valueline
parameter_list|(
name|dither_t
modifier|*
name|d
parameter_list|,
name|int
name|color
parameter_list|)
block|{
if|if
condition|(
name|color
operator|<
literal|0
operator|||
name|color
operator|>=
name|NCOLORS
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d
operator|->
name|vals
index|[
name|color
index|]
condition|)
return|return
name|d
operator|->
name|vals
index|[
name|color
index|]
return|;
else|else
block|{
name|int
name|size
init|=
operator|(
literal|8
operator|*
operator|(
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|)
decl_stmt|;
name|d
operator|->
name|vals
index|[
name|color
index|]
operator|=
name|malloc
argument_list|(
name|size
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|vals
index|[
name|color
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add the error to the input value.  Notice that we micro-optimize this  * to save a division when appropriate.  */
end_comment

begin_define
DECL|macro|UPDATE_COLOR (color,dither)
define|#
directive|define
name|UPDATE_COLOR
parameter_list|(
name|color
parameter_list|,
name|dither
parameter_list|)
value|(\         ((dither)>= 0)? \                 (color) + ((dither)>> 3): \                 (color) - ((-(dither))>> 3))
end_define

begin_comment
comment|/*  * For Floyd-Steinberg, distribute the error residual.  We spread the  * error to nearby points, spreading more broadly in lighter regions to  * achieve more uniform distribution of color.  The actual distribution  * is a triangular function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
DECL|function|update_dither (int r,int o,int width,int odb,int odb_mask,int direction,int * error0,int * error1,dither_t * d)
name|update_dither
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|o
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|odb
parameter_list|,
name|int
name|odb_mask
parameter_list|,
name|int
name|direction
parameter_list|,
name|int
modifier|*
name|error0
parameter_list|,
name|int
modifier|*
name|error1
parameter_list|,
name|dither_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|tmp
init|=
name|r
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|dist
decl_stmt|;
name|int
name|dist1
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|delta1
decl_stmt|;
name|int
name|nextspread
init|=
literal|4
decl_stmt|;
name|int
name|thisspread
init|=
literal|8
operator|-
name|nextspread
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|65535
condition|)
name|tmp
operator|=
literal|65535
expr_stmt|;
if|if
condition|(
name|odb
operator|>=
literal|16
operator|||
name|o
operator|>=
literal|2048
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|tmpo
init|=
name|o
operator|*
literal|32
decl_stmt|;
name|offset
operator|=
operator|(
literal|65535
operator|-
operator|(
name|tmpo
operator|&
literal|0xffff
operator|)
operator|)
operator|>>
name|odb
expr_stmt|;
if|if
condition|(
operator|(
name|rand
argument_list|()
operator|&
name|odb_mask
operator|)
operator|>
operator|(
name|tmpo
operator|&
name|odb_mask
operator|)
condition|)
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_SPREAD
operator|-
literal|1
condition|)
name|offset
operator|=
name|MAX_SPREAD
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|dist
operator|=
name|nextspread
operator|*
name|tmp
expr_stmt|;
name|error1
index|[
literal|0
index|]
operator|+=
name|dist
expr_stmt|;
return|return
name|error0
index|[
name|direction
index|]
operator|+
name|thisspread
operator|*
name|tmp
return|;
block|}
else|else
block|{
name|dist
operator|=
name|nextspread
operator|*
name|tmp
operator|/
name|d
operator|->
name|offset0_table
index|[
name|offset
index|]
expr_stmt|;
name|dist1
operator|=
name|thisspread
operator|*
name|tmp
operator|/
name|d
operator|->
name|offset1_table
index|[
name|offset
index|]
expr_stmt|;
name|delta1
operator|=
name|dist1
operator|*
name|offset
expr_stmt|;
block|}
name|delta
operator|=
name|dist
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|offset
init|;
name|i
operator|<=
name|offset
condition|;
name|i
operator|++
control|)
block|{
name|error1
index|[
name|i
index|]
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|&&
name|direction
operator|>
literal|0
operator|)
operator|||
operator|(
name|i
operator|<
literal|0
operator|&&
name|direction
operator|<
literal|0
operator|)
condition|)
block|{
name|error0
index|[
name|i
index|]
operator|+=
name|delta1
expr_stmt|;
name|delta1
operator|-=
name|dist1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|delta
operator|+=
name|dist
expr_stmt|;
else|else
name|delta
operator|-=
name|dist
expr_stmt|;
block|}
block|}
return|return
name|error0
index|[
name|direction
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Print a single dot.  This routine has become awfully complicated  * awfully fast!  *  * Note that the ink budget is both an input and an output parameter  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
DECL|function|print_color (dither_t * d,dither_color_t * rv,int base,int density,int adjusted,int x,int y,unsigned char * c,unsigned char * lc,unsigned char bit,int length,unsigned randomizer,int dontprint,int * ink_budget,dither_matrix_t * pick_matrix,dither_matrix_t * dither_matrix,int dither_type)
name|print_color
parameter_list|(
name|dither_t
modifier|*
name|d
parameter_list|,
name|dither_color_t
modifier|*
name|rv
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|density
parameter_list|,
name|int
name|adjusted
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|lc
parameter_list|,
name|unsigned
name|char
name|bit
parameter_list|,
name|int
name|length
parameter_list|,
name|unsigned
name|randomizer
parameter_list|,
name|int
name|dontprint
parameter_list|,
name|int
modifier|*
name|ink_budget
parameter_list|,
name|dither_matrix_t
modifier|*
name|pick_matrix
parameter_list|,
name|dither_matrix_t
modifier|*
name|dither_matrix
parameter_list|,
name|int
name|dither_type
parameter_list|)
block|{
name|unsigned
name|rangepoint
decl_stmt|;
name|unsigned
name|virtual_value
decl_stmt|;
name|unsigned
name|vmatrix
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isdark
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tptr
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
name|unsigned
name|v
decl_stmt|;
name|unsigned
name|dot_size
decl_stmt|;
name|int
name|levels
init|=
name|rv
operator|->
name|nlevels
operator|-
literal|1
decl_stmt|;
name|int
name|dither_value
init|=
name|adjusted
decl_stmt|;
name|dither_segment_t
modifier|*
name|dd
decl_stmt|;
if|if
condition|(
operator|(
name|adjusted
operator|<=
literal|0
operator|&&
operator|!
operator|(
name|dither_type
operator|&
name|D_ADAPTIVE_BASE
operator|)
operator|)
operator|||
name|base
operator|<=
literal|0
operator|||
name|density
operator|<=
literal|0
condition|)
return|return
name|adjusted
return|;
if|if
condition|(
name|density
operator|>
literal|65536
condition|)
name|density
operator|=
literal|65536
expr_stmt|;
comment|/*    * Look for the appropriate range into which the input value falls.    * Notice that we use the input, not the error, to decide what dot type    * to print (if any).  We actually use the "density" input to permit    * the caller to use something other that simply the input value, if it's    * desired to use some function of overall density, rather than just    * this color's input, for this purpose.    */
for|for
control|(
name|i
operator|=
name|levels
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|dd
operator|=
operator|&
operator|(
name|rv
operator|->
name|ranges
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|density
operator|<=
name|dd
operator|->
name|range_l
condition|)
continue|continue;
comment|/*        * If we're using an adaptive dithering method, decide whether        * to use the Floyd-Steinberg or the ordered method based on the        * input value.  The choice of 1/128 is somewhat arbitrary and        * could stand to be parameterized.  Another possibility would be        * to scale to something less than pure ordered at 0 input value.        */
if|if
condition|(
name|dither_type
operator|&
name|D_ADAPTIVE_BASE
condition|)
block|{
name|dither_type
operator|-=
name|D_ADAPTIVE_BASE
expr_stmt|;
if|if
condition|(
name|base
operator|<=
name|d
operator|->
name|adaptive_limit
condition|)
block|{
name|dither_type
operator|=
name|D_ORDERED
expr_stmt|;
name|dither_value
operator|=
name|base
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adjusted
operator|<=
literal|0
condition|)
return|return
name|adjusted
return|;
block|}
comment|/*        * Where are we within the range.  If we're going to print at        * all, this determines the probability of printing the darker        * vs. the lighter ink.  If the inks are identical (same value        * and darkness), it doesn't matter.        *        * We scale the input linearly against the top and bottom of the        * range.        */
if|if
condition|(
name|dd
operator|->
name|range_span
operator|==
literal|0
operator|||
operator|(
name|dd
operator|->
name|value_span
operator|==
literal|0
operator|&&
name|dd
operator|->
name|isdark_l
operator|==
name|dd
operator|->
name|isdark_h
operator|)
condition|)
name|rangepoint
operator|=
literal|32768
expr_stmt|;
else|else
name|rangepoint
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|density
operator|-
name|dd
operator|->
name|range_l
argument_list|)
operator|)
operator|*
literal|65536
operator|/
name|dd
operator|->
name|range_span
expr_stmt|;
comment|/*        * Compute the virtual dot size that we're going to print.        * This is somewhere between the two candidate dot sizes.        * This is scaled between the high and low value.        */
if|if
condition|(
name|dd
operator|->
name|value_span
operator|==
literal|0
condition|)
name|virtual_value
operator|=
name|dd
operator|->
name|value_h
expr_stmt|;
elseif|else
if|if
condition|(
name|dd
operator|->
name|range_span
operator|==
literal|0
condition|)
name|virtual_value
operator|=
operator|(
name|dd
operator|->
name|value_h
operator|+
name|dd
operator|->
name|value_l
operator|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|dd
operator|->
name|value_h
operator|==
literal|65536
operator|&&
name|rangepoint
operator|==
literal|65536
condition|)
name|virtual_value
operator|=
literal|65536
expr_stmt|;
else|else
name|virtual_value
operator|=
name|dd
operator|->
name|value_l
operator|+
operator|(
name|dd
operator|->
name|value_span
operator|*
name|rangepoint
operator|/
literal|65536
operator|)
expr_stmt|;
comment|/*        * Reduce the randomness as the base value increases, to get        * smoother output in the midtones.  Idea suggested by        * Thomas Tonino.        */
if|if
condition|(
operator|!
operator|(
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
if|if
condition|(
name|randomizer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|base
operator|>
name|d
operator|->
name|d_cutoff
condition|)
name|randomizer
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|>
name|d
operator|->
name|d_cutoff
operator|/
literal|2
condition|)
name|randomizer
operator|=
name|randomizer
operator|*
literal|2
operator|*
operator|(
name|d
operator|->
name|d_cutoff
operator|-
name|base
operator|)
operator|/
name|d
operator|->
name|d_cutoff
expr_stmt|;
block|}
block|}
else|else
name|randomizer
operator|=
literal|65536
expr_stmt|;
comment|/* With ordered dither, we need this */
comment|/*        * Compute the comparison value to decide whether to print at        * all.  If there is no randomness, simply divide the virtual        * dotsize by 2 to get standard "pure" Floyd-Steinberg (or "pure"        * matrix dithering, which degenerates to a threshold).        */
if|if
condition|(
name|randomizer
operator|==
literal|0
condition|)
name|vmatrix
operator|=
name|virtual_value
operator|/
literal|2
expr_stmt|;
else|else
block|{
comment|/* 	   * First, compute a value between 0 and 65536 that will be 	   * scaled to produce an offset from the desired threshold. 	   */
switch|switch
condition|(
name|dither_type
condition|)
block|{
case|case
name|D_FLOYD
case|:
comment|/* 	       * Floyd-Steinberg: use a mildly Gaussian random number. 	       * This might be a bit too Gaussian. 	       */
name|vmatrix
operator|=
operator|(
operator|(
name|rand
argument_list|()
operator|&
literal|0xffff000
operator|)
operator|+
operator|(
name|rand
argument_list|()
operator|&
literal|0xffff000
operator|)
operator|)
operator|>>
literal|13
expr_stmt|;
break|break;
case|case
name|D_FLOYD_HYBRID
case|:
comment|/* 	       * Hybrid Floyd-Steinberg: use a matrix to generate the offset. 	       */
case|case
name|D_ORDERED
case|:
default|default:
name|vmatrix
operator|=
name|ditherpoint
argument_list|(
name|d
argument_list|,
name|dither_matrix
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vmatrix
operator|==
literal|65536
operator|&&
name|virtual_value
operator|==
literal|65536
condition|)
comment|/* 	     * These numbers will break 32-bit unsigned arithmetic! 	     * Maybe this is so rare that we'd be better off using 	     * long long arithmetic, but that's likely to be much more 	     * expensive on 32-bit architectures. 	     */
name|vmatrix
operator|=
literal|65536
expr_stmt|;
else|else
block|{
comment|/* 	       * Now, scale the virtual dot size appropriately.  Note that 	       * we'll get something evenly distributed between 0 and 	       * the virtual dot size, centered on the dot size / 2, 	       * which is the normal threshold value. 	       */
name|vmatrix
operator|=
name|vmatrix
operator|*
name|virtual_value
operator|/
literal|65536
expr_stmt|;
if|if
condition|(
name|randomizer
operator|!=
literal|65536
condition|)
block|{
comment|/* 		   * We want vmatrix to be scaled between 0 and 		   * virtual_value when randomizer is 65536 (fully random). 		   * When it's less, we want it to scale through part of 		   * that range. In all cases, it should center around 		   * virtual_value / 2. 		   * 		   * vbase is the bottom of the scaling range. 		   */
name|unsigned
name|vbase
init|=
name|virtual_value
operator|*
operator|(
literal|65536u
operator|-
name|randomizer
operator|)
operator|/
literal|131072u
decl_stmt|;
name|vmatrix
operator|=
name|vmatrix
operator|*
name|randomizer
operator|/
literal|65536
expr_stmt|;
name|vmatrix
operator|+=
name|vbase
expr_stmt|;
block|}
block|}
block|}
comment|/* randomizer != 0 */
comment|/*        * After all that, printing is almost an afterthought.        * Pick the actual dot size (using a matrix here) and print it.        */
if|if
condition|(
name|dither_value
operator|>=
name|vmatrix
condition|)
block|{
if|if
condition|(
name|dd
operator|->
name|isdark_h
operator|==
name|dd
operator|->
name|isdark_l
operator|&&
name|dd
operator|->
name|bits_h
operator|==
name|dd
operator|->
name|bits_l
condition|)
block|{
name|isdark
operator|=
name|dd
operator|->
name|isdark_h
expr_stmt|;
name|bits
operator|=
name|dd
operator|->
name|bits_h
expr_stmt|;
name|v
operator|=
name|dd
operator|->
name|value_h
expr_stmt|;
name|dot_size
operator|=
name|dd
operator|->
name|dot_size_h
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rangepoint
operator|>=
name|ditherpoint
argument_list|(
name|d
argument_list|,
name|pick_matrix
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|isdark
operator|=
name|dd
operator|->
name|isdark_h
expr_stmt|;
name|bits
operator|=
name|dd
operator|->
name|bits_h
expr_stmt|;
name|v
operator|=
name|dd
operator|->
name|value_h
expr_stmt|;
name|dot_size
operator|=
name|dd
operator|->
name|dot_size_h
expr_stmt|;
block|}
else|else
block|{
name|isdark
operator|=
name|dd
operator|->
name|isdark_l
expr_stmt|;
name|bits
operator|=
name|dd
operator|->
name|bits_l
expr_stmt|;
name|v
operator|=
name|dd
operator|->
name|value_l
expr_stmt|;
name|dot_size
operator|=
name|dd
operator|->
name|dot_size_l
expr_stmt|;
block|}
name|tptr
operator|=
name|isdark
condition|?
name|c
else|:
name|lc
expr_stmt|;
comment|/* 	   * Lay down all of the bits in the pixel. 	   */
if|if
condition|(
name|dontprint
operator|<
name|v
operator|&&
operator|(
operator|!
name|ink_budget
operator|||
operator|*
name|ink_budget
operator|>=
name|dot_size
operator|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|bits
condition|;
name|j
operator|+=
name|j
operator|,
name|tptr
operator|+=
name|length
control|)
block|{
if|if
condition|(
name|j
operator|&
name|bits
condition|)
name|tptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|ink_budget
condition|)
operator|*
name|ink_budget
operator|-=
name|dot_size
expr_stmt|;
block|}
if|if
condition|(
name|dither_type
operator|&
name|D_ORDERED_BASE
condition|)
name|adjusted
operator|=
operator|-
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
name|v
operator|/
literal|4
argument_list|)
expr_stmt|;
else|else
name|adjusted
operator|-=
name|v
expr_stmt|;
block|}
return|return
name|adjusted
return|;
block|}
return|return
name|adjusted
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|print_color_fast (dither_t * d,dither_color_t * rv,int base,int adjusted,int x,int y,unsigned char * c,unsigned char * lc,unsigned char bit,int length,dither_matrix_t * dither_matrix,int very_fast)
name|print_color_fast
parameter_list|(
name|dither_t
modifier|*
name|d
parameter_list|,
name|dither_color_t
modifier|*
name|rv
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|adjusted
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|lc
parameter_list|,
name|unsigned
name|char
name|bit
parameter_list|,
name|int
name|length
parameter_list|,
name|dither_matrix_t
modifier|*
name|dither_matrix
parameter_list|,
name|int
name|very_fast
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|levels
init|=
name|rv
operator|->
name|nlevels
operator|-
literal|1
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tptr
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
if|if
condition|(
name|adjusted
operator|<=
literal|0
operator|||
name|base
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|very_fast
condition|)
block|{
if|if
condition|(
name|adjusted
operator|>=
name|ditherpoint_fast
argument_list|(
name|d
argument_list|,
name|dither_matrix
argument_list|,
name|x
argument_list|)
condition|)
name|c
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
return|return;
block|}
comment|/*    * Look for the appropriate range into which the input value falls.    * Notice that we use the input, not the error, to decide what dot type    * to print (if any).  We actually use the "density" input to permit    * the caller to use something other that simply the input value, if it's    * desired to use some function of overall density, rather than just    * this color's input, for this purpose.    */
for|for
control|(
name|i
operator|=
name|levels
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|dither_segment_t
modifier|*
name|dd
init|=
operator|&
operator|(
name|rv
operator|->
name|ranges
index|[
name|i
index|]
operator|)
decl_stmt|;
name|unsigned
name|vmatrix
decl_stmt|;
if|if
condition|(
name|base
operator|<=
name|dd
operator|->
name|range_l
condition|)
continue|continue;
name|vmatrix
operator|=
operator|(
name|dd
operator|->
name|value_h
operator|*
name|ditherpoint_fast
argument_list|(
name|d
argument_list|,
name|dither_matrix
argument_list|,
name|x
argument_list|)
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/*        * After all that, printing is almost an afterthought.        * Pick the actual dot size (using a matrix here) and print it.        */
if|if
condition|(
name|adjusted
operator|>=
name|vmatrix
condition|)
block|{
name|bits
operator|=
name|dd
operator|->
name|bits_h
expr_stmt|;
name|tptr
operator|=
name|dd
operator|->
name|isdark_h
condition|?
name|c
else|:
name|lc
expr_stmt|;
comment|/* 	   * Lay down all of the bits in the pixel. 	   */
if|if
condition|(
name|bits
operator|==
literal|1
condition|)
block|{
name|tptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|bits
condition|;
name|j
operator|+=
name|j
operator|,
name|tptr
operator|+=
name|length
control|)
block|{
if|if
condition|(
name|j
operator|&
name|bits
condition|)
name|tptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Dithering functions!  *  * Documentation moved to README.dither  */
end_comment

begin_comment
comment|/*  * 'dither_monochrome()' - Dither grayscale pixels to black using a hard  * threshold.  This is for use with predithered output, or for text  * or other pure black and white only.  */
end_comment

begin_function
name|void
DECL|function|dither_monochrome (const unsigned short * gray,int row,void * vd,unsigned char * black,int duplicate_line)
name|dither_monochrome
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|void
modifier|*
name|vd
parameter_list|,
name|unsigned
name|char
modifier|*
name|black
parameter_list|,
comment|/* O - Black bitmap pixels */
name|int
name|duplicate_line
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_matrix_t
modifier|*
name|kdither
init|=
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
decl_stmt|;
name|unsigned
name|bits
init|=
name|d
operator|->
name|k_dither
operator|.
name|signif_bits
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tptr
decl_stmt|;
name|int
name|dst_width
init|=
name|d
operator|->
name|dst_width
decl_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|xstep
operator|=
name|d
operator|->
name|src_width
operator|/
name|d
operator|->
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|d
operator|->
name|src_width
operator|%
name|d
operator|->
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
name|kptr
operator|=
name|black
expr_stmt|;
name|xerror
operator|=
literal|0
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
name|kdither
argument_list|,
name|row
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|gray
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|density
operator|>=
name|ditherpoint_fast
argument_list|(
name|d
argument_list|,
name|kdither
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|tptr
operator|=
name|kptr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bits
condition|;
name|j
operator|++
operator|,
name|tptr
operator|+=
name|length
control|)
name|tptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'dither_black()' - Dither grayscale pixels to black.  * This is for grayscale output.  */
end_comment

begin_function
name|void
DECL|function|dither_black_fast (const unsigned short * gray,int row,void * vd,unsigned char * black,int duplicate_line)
name|dither_black_fast
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|void
modifier|*
name|vd
parameter_list|,
name|unsigned
name|char
modifier|*
name|black
parameter_list|,
comment|/* O - Black bitmap pixels */
name|int
name|duplicate_line
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|k
decl_stmt|;
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|dither_color_t
modifier|*
name|kd
init|=
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
decl_stmt|;
name|dither_matrix_t
modifier|*
name|kdither
init|=
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
decl_stmt|;
name|int
name|dst_width
init|=
name|d
operator|->
name|dst_width
decl_stmt|;
name|int
name|dither_very_fast
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kd
operator|->
name|nlevels
operator|==
literal|1
operator|&&
name|kd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_h
operator|==
literal|1
operator|&&
name|kd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_h
condition|)
name|dither_very_fast
operator|=
literal|1
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|xstep
operator|=
name|d
operator|->
name|src_width
operator|/
name|d
operator|->
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|d
operator|->
name|src_width
operator|%
name|d
operator|->
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|k_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
name|kptr
operator|=
name|black
expr_stmt|;
name|xerror
operator|=
literal|0
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
control|)
block|{
name|k
operator|=
literal|65535
operator|-
operator|*
name|gray
expr_stmt|;
name|print_color_fast
argument_list|(
name|d
argument_list|,
name|kd
argument_list|,
name|k
argument_list|,
name|k
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|kptr
argument_list|,
name|NULL
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|kdither
argument_list|,
name|dither_very_fast
argument_list|)
expr_stmt|;
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|dither_black (const unsigned short * gray,int row,void * vd,unsigned char * black,int duplicate_line)
name|dither_black
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|void
modifier|*
name|vd
parameter_list|,
name|unsigned
name|char
modifier|*
name|black
parameter_list|,
comment|/* O - Black bitmap pixels */
name|int
name|duplicate_line
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|k
decl_stmt|,
name|ok
decl_stmt|,
comment|/* Current black error */
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
name|int
name|terminate
decl_stmt|;
name|int
name|direction
init|=
name|row
operator|&
literal|1
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|odb
init|=
name|d
operator|->
name|spread
decl_stmt|;
name|int
name|odb_mask
init|=
operator|(
literal|1
operator|<<
name|odb
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|ink_budget
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|dither_type
operator|&
name|D_FAST_BASE
condition|)
block|{
name|dither_black_fast
argument_list|(
name|gray
argument_list|,
name|row
argument_list|,
name|vd
argument_list|,
name|black
argument_list|,
name|duplicate_line
argument_list|)
expr_stmt|;
return|return;
block|}
name|bit
operator|=
operator|(
name|direction
operator|==
literal|1
operator|)
condition|?
literal|128
else|:
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
operator|(
name|d
operator|->
name|dst_width
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|direction
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|terminate
operator|=
operator|(
name|direction
operator|==
literal|1
operator|)
condition|?
name|d
operator|->
name|dst_width
else|:
operator|-
literal|1
expr_stmt|;
name|xstep
operator|=
name|d
operator|->
name|src_width
operator|/
name|d
operator|->
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|d
operator|->
name|src_width
operator|%
name|d
operator|->
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|kerror0
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
argument_list|,
name|ECOLOR_K
argument_list|)
expr_stmt|;
name|kerror1
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
operator|+
literal|1
argument_list|,
name|ECOLOR_K
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kerror1
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|k_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
name|kptr
operator|=
name|black
expr_stmt|;
name|xerror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|direction
operator|==
operator|-
literal|1
condition|)
block|{
name|kerror0
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|kerror1
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|kptr
operator|=
name|black
operator|+
name|length
operator|-
literal|1
expr_stmt|;
name|xstep
operator|=
operator|-
name|xstep
expr_stmt|;
name|gray
operator|+=
name|d
operator|->
name|src_width
operator|-
literal|1
expr_stmt|;
name|xerror
operator|=
operator|(
operator|(
name|d
operator|->
name|dst_width
operator|-
literal|1
operator|)
operator|*
name|xmod
operator|)
operator|%
name|d
operator|->
name|dst_width
expr_stmt|;
name|xmod
operator|=
operator|-
name|xmod
expr_stmt|;
block|}
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
for|for
control|(
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
init|;
name|x
operator|!=
name|terminate
condition|;
name|x
operator|+=
name|direction
operator|,
name|kerror0
operator|+=
name|direction
operator|,
name|kerror1
operator|+=
name|direction
control|)
block|{
name|ink_budget
operator|=
name|d
operator|->
name|ink_limit
expr_stmt|;
name|k
operator|=
literal|65535
operator|-
operator|*
name|gray
expr_stmt|;
name|ok
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
condition|)
name|print_color
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
argument_list|,
name|k
argument_list|,
name|k
argument_list|,
name|k
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|kptr
argument_list|,
name|NULL
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|d
operator|->
name|k_randomizer
argument_list|,
literal|0
argument_list|,
operator|&
name|ink_budget
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|d
operator|->
name|dither_type
argument_list|)
expr_stmt|;
else|else
block|{
name|k
operator|=
name|UPDATE_COLOR
argument_list|(
name|k
argument_list|,
name|ditherk
argument_list|)
expr_stmt|;
name|k
operator|=
name|print_color
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
argument_list|,
name|ok
argument_list|,
name|ok
argument_list|,
name|k
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|kptr
argument_list|,
name|NULL
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|d
operator|->
name|k_randomizer
argument_list|,
literal|0
argument_list|,
operator|&
name|ink_budget
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|d
operator|->
name|dither_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
name|ditherk
operator|=
name|update_dither
argument_list|(
name|k
argument_list|,
name|ok
argument_list|,
name|d
operator|->
name|src_width
argument_list|,
name|odb
argument_list|,
name|odb_mask
argument_list|,
name|direction
argument_list|,
name|kerror0
argument_list|,
name|kerror1
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|direction
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|d
operator|->
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|d
operator|->
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bit
operator|==
literal|128
condition|)
block|{
name|kptr
operator|--
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bit
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|xerror
operator|<
literal|0
condition|)
block|{
name|xerror
operator|+=
name|d
operator|->
name|dst_width
expr_stmt|;
name|gray
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_define
DECL|macro|USMIN (a,b)
define|#
directive|define
name|USMIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_function
specifier|static
name|void
DECL|function|generate_cmy (dither_t * d,const unsigned short * rgb,int * nonzero,int row)
name|generate_cmy
parameter_list|(
name|dither_t
modifier|*
name|d
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
name|int
modifier|*
name|nonzero
parameter_list|,
name|int
name|row
parameter_list|)
block|{
specifier|register
name|unsigned
name|short
name|cc
decl_stmt|,
name|mm
decl_stmt|,
name|yy
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|c
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_C
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|m
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_M
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|y
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_Y
argument_list|)
decl_stmt|;
specifier|register
name|int
name|lnonzero
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|xerror
decl_stmt|,
name|xstep
decl_stmt|,
name|xmod
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|src_width
operator|==
name|d
operator|->
name|dst_width
condition|)
block|{
for|for
control|(
name|x
operator|=
name|d
operator|->
name|dst_width
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|cc
operator|=
operator|*
name|c
operator|++
operator|=
literal|65535
operator|-
operator|*
name|rgb
operator|++
expr_stmt|;
name|mm
operator|=
operator|*
name|m
operator|++
operator|=
literal|65535
operator|-
operator|*
name|rgb
operator|++
expr_stmt|;
name|yy
operator|=
operator|*
name|y
operator|++
operator|=
literal|65535
operator|-
operator|*
name|rgb
operator|++
expr_stmt|;
name|lnonzero
operator||=
name|cc
operator|||
name|mm
operator|||
name|yy
expr_stmt|;
block|}
block|}
else|else
block|{
name|xstep
operator|=
literal|3
operator|*
operator|(
name|d
operator|->
name|src_width
operator|/
name|d
operator|->
name|dst_width
operator|)
expr_stmt|;
name|xmod
operator|=
name|d
operator|->
name|src_width
operator|%
name|d
operator|->
name|dst_width
expr_stmt|;
name|xerror
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|d
operator|->
name|dst_width
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|cc
operator|=
operator|*
name|c
operator|++
operator|=
literal|65535
operator|-
name|rgb
index|[
literal|0
index|]
expr_stmt|;
name|mm
operator|=
operator|*
name|m
operator|++
operator|=
literal|65535
operator|-
name|rgb
index|[
literal|1
index|]
expr_stmt|;
name|yy
operator|=
operator|*
name|y
operator|++
operator|=
literal|65535
operator|-
name|rgb
index|[
literal|2
index|]
expr_stmt|;
name|lnonzero
operator||=
name|cc
operator|||
name|mm
operator|||
name|yy
expr_stmt|;
name|rgb
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|d
operator|->
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|d
operator|->
name|dst_width
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
operator|*
name|nonzero
operator|=
name|lnonzero
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|update_cmy (const dither_t * d,int c,int m,int y,int k,int * nc,int * nm,int * ny)
name|update_cmy
parameter_list|(
specifier|const
name|dither_t
modifier|*
name|d
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|k
parameter_list|,
name|int
modifier|*
name|nc
parameter_list|,
name|int
modifier|*
name|nm
parameter_list|,
name|int
modifier|*
name|ny
parameter_list|)
block|{
comment|/*    * We're not printing black, but let's adjust the CMY levels to    * produce better reds, greens, and blues...    *    * This code needs to be tuned    */
name|unsigned
name|ck
init|=
name|c
operator|-
name|k
decl_stmt|;
name|unsigned
name|mk
init|=
name|m
operator|-
name|k
decl_stmt|;
name|unsigned
name|yk
init|=
name|y
operator|-
name|k
decl_stmt|;
operator|*
name|nc
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
literal|65535
operator|-
name|c
operator|/
literal|4
argument_list|)
operator|)
operator|*
name|ck
operator|/
literal|65535
operator|+
name|k
expr_stmt|;
operator|*
name|nm
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
literal|65535
operator|-
name|m
operator|/
literal|4
argument_list|)
operator|)
operator|*
name|mk
operator|/
literal|65535
operator|+
name|k
expr_stmt|;
operator|*
name|ny
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
literal|65535
operator|-
name|y
operator|/
literal|4
argument_list|)
operator|)
operator|*
name|yk
operator|/
literal|65535
operator|+
name|k
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|update_cmyk (const dither_t * d,int c,int m,int y,int k,int * nc,int * nm,int * ny,int * nk,int * jk)
name|update_cmyk
parameter_list|(
specifier|const
name|dither_t
modifier|*
name|d
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|k
parameter_list|,
name|int
modifier|*
name|nc
parameter_list|,
name|int
modifier|*
name|nm
parameter_list|,
name|int
modifier|*
name|ny
parameter_list|,
name|int
modifier|*
name|nk
parameter_list|,
name|int
modifier|*
name|jk
parameter_list|)
block|{
name|int
name|ak
decl_stmt|;
name|int
name|kdarkness
decl_stmt|;
name|unsigned
name|ks
decl_stmt|,
name|kl
decl_stmt|;
name|int
name|ub
decl_stmt|,
name|lb
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|int
name|bk
decl_stmt|;
name|ub
operator|=
name|d
operator|->
name|k_upper
expr_stmt|;
comment|/* Upper bound */
name|lb
operator|=
name|d
operator|->
name|k_lower
expr_stmt|;
comment|/* Lower bound */
comment|/*    * Calculate total ink amount.    * If there is a lot of ink, black gets added sooner. Saves ink    * and with a lot of ink the black doesn't show as speckles.    *    * k already contains the grey contained in CMY.    * First we find out if the color is darker than the K amount    * suggests, and we look up where is value is between    * lowerbound and density:    */
name|kdarkness
operator|=
name|c
operator|+
name|c
operator|+
name|m
operator|+
name|m
operator|+
name|y
operator|-
name|d
operator|->
name|density2
expr_stmt|;
if|if
condition|(
name|kdarkness
operator|>
operator|(
name|k
operator|+
name|k
operator|+
name|k
operator|)
condition|)
name|ok
operator|=
name|kdarkness
operator|/
literal|3
expr_stmt|;
else|else
name|ok
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|ok
operator|>
name|lb
condition|)
name|kl
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|ok
operator|-
name|lb
argument_list|)
operator|*
operator|(
name|unsigned
operator|)
name|d
operator|->
name|density
operator|/
name|d
operator|->
name|dlb_range
expr_stmt|;
else|else
name|kl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kl
operator|>
name|d
operator|->
name|density
condition|)
name|kl
operator|=
name|d
operator|->
name|density
expr_stmt|;
comment|/*    * We have a second value, ks, that will be the scaler.    * ks is initially showing where the original black    * amount is between upper and lower bounds:    */
if|if
condition|(
name|k
operator|>
name|ub
condition|)
name|ks
operator|=
name|d
operator|->
name|density
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|<
name|lb
condition|)
name|ks
operator|=
literal|0
expr_stmt|;
else|else
name|ks
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|k
operator|-
name|lb
argument_list|)
operator|*
operator|(
name|unsigned
operator|)
name|d
operator|->
name|density
operator|/
name|d
operator|->
name|bound_range
expr_stmt|;
if|if
condition|(
name|ks
operator|>
name|d
operator|->
name|density
condition|)
name|ks
operator|=
name|d
operator|->
name|density
expr_stmt|;
comment|/*    * ks is then processed by a second order function that produces    * an S curve: 2ks - ks^2. This is then multiplied by the    * darkness value in kl. If we think this is too complex the    * following line can be tried instead:    * ak = ks;    */
name|ak
operator|=
name|ks
expr_stmt|;
name|k
operator|=
operator|(
name|unsigned
operator|)
name|kl
operator|*
operator|(
name|unsigned
operator|)
name|ak
operator|/
operator|(
name|unsigned
operator|)
name|d
operator|->
name|density
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|d
operator|->
name|density
condition|)
name|k
operator|=
name|d
operator|->
name|density
expr_stmt|;
name|ok
operator|=
name|k
expr_stmt|;
name|bk
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|&&
name|ak
condition|)
block|{
comment|/*        * Because black is always fairly neutral, we do not have to        * calculate the amount to take out of CMY. The result will        * be a bit dark but that is OK. If things are okay CMY        * cannot go negative here - unless extra K is added in the        * previous block. We multiply by ak to prevent taking out        * too much. This prevents dark areas from becoming very        * dull.        */
name|ok
operator|=
operator|(
name|unsigned
operator|)
name|k
operator|*
operator|(
name|unsigned
operator|)
name|ak
operator|/
operator|(
name|unsigned
operator|)
name|d
operator|->
name|density
expr_stmt|;
name|c
operator|-=
name|ok
expr_stmt|;
name|m
operator|-=
name|ok
expr_stmt|;
name|y
operator|-=
name|ok
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|<
literal|0
condition|)
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nc
operator|=
name|c
expr_stmt|;
operator|*
name|nm
operator|=
name|m
expr_stmt|;
operator|*
name|ny
operator|=
name|y
expr_stmt|;
operator|*
name|nk
operator|=
name|bk
expr_stmt|;
operator|*
name|jk
operator|=
name|k
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|dither_cmyk_fast (const unsigned short * rgb,int row,void * vd,unsigned char * cyan,unsigned char * lcyan,unsigned char * magenta,unsigned char * lmagenta,unsigned char * yellow,unsigned char * lyellow,unsigned char * black,int duplicate_line)
name|dither_cmyk_fast
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|void
modifier|*
name|vd
parameter_list|,
name|unsigned
name|char
modifier|*
name|cyan
parameter_list|,
comment|/* O - Cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|lcyan
parameter_list|,
comment|/* O - Light cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|magenta
parameter_list|,
comment|/* O - Magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|lmagenta
parameter_list|,
comment|/* O - Light magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|yellow
parameter_list|,
comment|/* O - Yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|lyellow
parameter_list|,
comment|/* O - Light yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|black
parameter_list|,
comment|/* O - Black bitmap pixels */
name|int
name|duplicate_line
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|int
name|c
decl_stmt|,
name|m
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
comment|/* CMYK values */
name|oc
decl_stmt|,
name|om
decl_stmt|,
name|oy
decl_stmt|,
name|ok
decl_stmt|;
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|cptr
decl_stmt|,
comment|/* Current cyan pixel */
modifier|*
name|mptr
decl_stmt|,
comment|/* Current magenta pixel */
modifier|*
name|yptr
decl_stmt|,
comment|/* Current yellow pixel */
modifier|*
name|lmptr
decl_stmt|,
comment|/* Current light magenta pixel */
modifier|*
name|lcptr
decl_stmt|,
comment|/* Current light cyan pixel */
modifier|*
name|lyptr
decl_stmt|,
comment|/* Current light yellow pixel */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|cline
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_C
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|mline
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_M
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|yline
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_Y
argument_list|)
decl_stmt|;
name|int
name|nonzero
decl_stmt|;
name|dither_color_t
modifier|*
name|cd
init|=
operator|&
operator|(
name|d
operator|->
name|c_dither
operator|)
decl_stmt|;
name|dither_matrix_t
modifier|*
name|cdither
init|=
operator|&
operator|(
name|d
operator|->
name|c_dithermat
operator|)
decl_stmt|;
name|dither_color_t
modifier|*
name|md
init|=
operator|&
operator|(
name|d
operator|->
name|m_dither
operator|)
decl_stmt|;
name|dither_matrix_t
modifier|*
name|mdither
init|=
operator|&
operator|(
name|d
operator|->
name|m_dithermat
operator|)
decl_stmt|;
name|dither_color_t
modifier|*
name|yd
init|=
operator|&
operator|(
name|d
operator|->
name|y_dither
operator|)
decl_stmt|;
name|dither_matrix_t
modifier|*
name|ydither
init|=
operator|&
operator|(
name|d
operator|->
name|y_dithermat
operator|)
decl_stmt|;
name|dither_color_t
modifier|*
name|kd
init|=
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
decl_stmt|;
name|dither_matrix_t
modifier|*
name|kdither
init|=
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
decl_stmt|;
name|int
name|dst_width
init|=
name|d
operator|->
name|dst_width
decl_stmt|;
name|int
name|cdither_very_fast
init|=
literal|0
decl_stmt|;
name|int
name|mdither_very_fast
init|=
literal|0
decl_stmt|;
name|int
name|ydither_very_fast
init|=
literal|0
decl_stmt|;
name|int
name|kdither_very_fast
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|nlevels
operator|==
literal|1
operator|&&
name|cd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_h
operator|==
literal|1
operator|&&
name|cd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_h
condition|)
name|cdither_very_fast
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|nlevels
operator|==
literal|1
operator|&&
name|md
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_h
operator|==
literal|1
operator|&&
name|md
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_h
condition|)
name|mdither_very_fast
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|yd
operator|->
name|nlevels
operator|==
literal|1
operator|&&
name|yd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_h
operator|==
literal|1
operator|&&
name|yd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_h
condition|)
name|ydither_very_fast
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|kd
operator|->
name|nlevels
operator|==
literal|1
operator|&&
name|kd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|bits_h
operator|==
literal|1
operator|&&
name|kd
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|isdark_h
condition|)
name|kdither_very_fast
operator|=
literal|1
expr_stmt|;
name|length
operator|=
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|memset
argument_list|(
name|cyan
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|c_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcyan
condition|)
name|memset
argument_list|(
name|lcyan
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|c_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|magenta
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|m_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmagenta
condition|)
name|memset
argument_list|(
name|lmagenta
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|m_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yellow
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|y_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyellow
condition|)
name|memset
argument_list|(
name|lyellow
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|y_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
condition|)
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|k_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
comment|/*    * First, generate the CMYK separation.  If there's nothing in    * this row, and we're using an ordered dither, there's no reason    * to do anything at all.    */
if|if
condition|(
operator|!
name|duplicate_line
condition|)
block|{
name|generate_cmy
argument_list|(
name|d
argument_list|,
name|rgb
argument_list|,
operator|&
name|nonzero
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonzero
condition|)
name|d
operator|->
name|last_line_was_empty
operator|=
literal|0
expr_stmt|;
else|else
name|d
operator|->
name|last_line_was_empty
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|last_line_was_empty
condition|)
name|d
operator|->
name|last_line_was_empty
operator|++
expr_stmt|;
comment|/*    * First, generate the CMYK separation.  If there's nothing in    * this row, and we're using an ordered dither, there's no reason    * to do anything at all.    */
if|if
condition|(
name|d
operator|->
name|last_line_was_empty
condition|)
return|return;
comment|/*    * Boilerplate    */
name|bit
operator|=
literal|128
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|cptr
operator|=
name|cyan
expr_stmt|;
name|mptr
operator|=
name|magenta
expr_stmt|;
name|yptr
operator|=
name|yellow
expr_stmt|;
name|lcptr
operator|=
name|lcyan
expr_stmt|;
name|lmptr
operator|=
name|lmagenta
expr_stmt|;
name|lyptr
operator|=
name|lyellow
expr_stmt|;
name|kptr
operator|=
name|black
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
comment|/* Shut up the compiler */
name|ok
operator|=
literal|0
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|/*    * Main loop starts here!    */
name|QUANT
argument_list|(
literal|14
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|x
operator|!=
name|dst_width
condition|;
name|x
operator|++
control|)
block|{
comment|/*        * First get the standard CMYK separation color values.        */
name|c
operator|=
name|cline
index|[
name|x
index|]
expr_stmt|;
name|m
operator|=
name|mline
index|[
name|x
index|]
expr_stmt|;
name|y
operator|=
name|yline
index|[
name|x
index|]
expr_stmt|;
name|oc
operator|=
name|c
expr_stmt|;
name|om
operator|=
name|m
expr_stmt|;
name|oy
operator|=
name|y
expr_stmt|;
comment|/*        * If we're doing ordered dither, and there's no ink, we aren't        * going to print anything.        */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|m
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
goto|goto
name|advance
goto|;
block|}
if|if
condition|(
name|black
condition|)
block|{
name|k
operator|=
name|USMIN
argument_list|(
name|c
argument_list|,
name|USMIN
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|32768
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|65535
operator|-
operator|(
operator|(
literal|65535
operator|-
name|k
operator|)
operator|*
literal|2
operator|)
expr_stmt|;
name|c
operator|-=
name|k
expr_stmt|;
name|m
operator|-=
name|k
expr_stmt|;
name|y
operator|-=
name|k
expr_stmt|;
name|ok
operator|=
name|k
expr_stmt|;
block|}
name|QUANT
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
condition|)
name|print_color_fast
argument_list|(
name|d
argument_list|,
name|kd
argument_list|,
name|ok
argument_list|,
name|k
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|kptr
argument_list|,
name|NULL
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|kdither
argument_list|,
name|kdither_very_fast
argument_list|)
expr_stmt|;
name|print_color_fast
argument_list|(
name|d
argument_list|,
name|kd
argument_list|,
name|oc
argument_list|,
name|c
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|cptr
argument_list|,
name|lcptr
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|cdither
argument_list|,
name|cdither_very_fast
argument_list|)
expr_stmt|;
name|print_color_fast
argument_list|(
name|d
argument_list|,
name|kd
argument_list|,
name|om
argument_list|,
name|m
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|mptr
argument_list|,
name|lmptr
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|mdither
argument_list|,
name|mdither_very_fast
argument_list|)
expr_stmt|;
name|print_color_fast
argument_list|(
name|d
argument_list|,
name|kd
argument_list|,
name|oy
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|yptr
argument_list|,
name|lyptr
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|ydither
argument_list|,
name|ydither_very_fast
argument_list|)
expr_stmt|;
name|QUANT
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/*****************************************************************        * Advance the loop        *****************************************************************/
name|advance
label|:
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
name|lcptr
condition|)
name|lcptr
operator|++
expr_stmt|;
name|mptr
operator|++
expr_stmt|;
if|if
condition|(
name|lmptr
condition|)
name|lmptr
operator|++
expr_stmt|;
name|yptr
operator|++
expr_stmt|;
if|if
condition|(
name|lyptr
condition|)
name|lyptr
operator|++
expr_stmt|;
if|if
condition|(
name|kptr
condition|)
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|QUANT
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
comment|/*    * Main loop ends here!    */
block|}
end_function

begin_function
name|void
DECL|function|dither_cmyk (const unsigned short * rgb,int row,void * vd,unsigned char * cyan,unsigned char * lcyan,unsigned char * magenta,unsigned char * lmagenta,unsigned char * yellow,unsigned char * lyellow,unsigned char * black,int duplicate_line)
name|dither_cmyk
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|void
modifier|*
name|vd
parameter_list|,
name|unsigned
name|char
modifier|*
name|cyan
parameter_list|,
comment|/* O - Cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|lcyan
parameter_list|,
comment|/* O - Light cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|magenta
parameter_list|,
comment|/* O - Magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|lmagenta
parameter_list|,
comment|/* O - Light magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|yellow
parameter_list|,
comment|/* O - Yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|lyellow
parameter_list|,
comment|/* O - Light yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|black
parameter_list|,
comment|/* O - Black bitmap pixels */
name|int
name|duplicate_line
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|int
name|c
decl_stmt|,
name|m
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
comment|/* CMYK values */
name|oc
decl_stmt|,
name|om
decl_stmt|,
name|oy
decl_stmt|;
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|cptr
decl_stmt|,
comment|/* Current cyan pixel */
modifier|*
name|mptr
decl_stmt|,
comment|/* Current magenta pixel */
modifier|*
name|yptr
decl_stmt|,
comment|/* Current yellow pixel */
modifier|*
name|lmptr
decl_stmt|,
comment|/* Current light magenta pixel */
modifier|*
name|lcptr
decl_stmt|,
comment|/* Current light cyan pixel */
modifier|*
name|lyptr
decl_stmt|,
comment|/* Current light yellow pixel */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|ditherc
init|=
literal|0
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|cerror0
init|=
literal|0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|cerror1
init|=
literal|0
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|dithery
init|=
literal|0
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|yerror0
init|=
literal|0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|yerror1
init|=
literal|0
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherm
init|=
literal|0
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|merror0
init|=
literal|0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|merror1
init|=
literal|0
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherk
init|=
literal|0
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
init|=
literal|0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
init|=
literal|0
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|bk
init|=
literal|0
decl_stmt|;
name|dither_t
modifier|*
name|d
init|=
operator|(
name|dither_t
operator|*
operator|)
name|vd
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|cline
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_C
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|mline
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_M
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|yline
init|=
name|get_valueline
argument_list|(
name|d
argument_list|,
name|ECOLOR_Y
argument_list|)
decl_stmt|;
name|int
name|nonzero
decl_stmt|;
name|int
name|terminate
decl_stmt|;
name|int
name|direction
init|=
name|row
operator|&
literal|1
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|odb
init|=
name|d
operator|->
name|spread
decl_stmt|;
name|int
name|odb_mask
init|=
operator|(
literal|1
operator|<<
name|odb
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|first_color
init|=
name|row
operator|%
literal|3
decl_stmt|;
name|int
name|printed_black
decl_stmt|;
name|int
name|ink_budget
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|dither_type
operator|&
name|D_FAST_BASE
condition|)
block|{
name|dither_cmyk_fast
argument_list|(
name|rgb
argument_list|,
name|row
argument_list|,
name|vd
argument_list|,
name|cyan
argument_list|,
name|lcyan
argument_list|,
name|magenta
argument_list|,
name|lmagenta
argument_list|,
name|yellow
argument_list|,
name|lyellow
argument_list|,
name|black
argument_list|,
name|duplicate_line
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|=
operator|(
name|d
operator|->
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|memset
argument_list|(
name|cyan
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|c_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcyan
condition|)
name|memset
argument_list|(
name|lcyan
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|c_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|magenta
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|m_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmagenta
condition|)
name|memset
argument_list|(
name|lmagenta
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|m_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yellow
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|y_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyellow
condition|)
name|memset
argument_list|(
name|lyellow
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|y_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
condition|)
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
name|d
operator|->
name|k_dither
operator|.
name|signif_bits
argument_list|)
expr_stmt|;
comment|/*    * First, generate the CMYK separation.  If there's nothing in    * this row, and we're using an ordered dither, there's no reason    * to do anything at all.    */
if|if
condition|(
operator|!
name|duplicate_line
condition|)
block|{
name|generate_cmy
argument_list|(
name|d
argument_list|,
name|rgb
argument_list|,
operator|&
name|nonzero
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonzero
condition|)
name|d
operator|->
name|last_line_was_empty
operator|=
literal|0
expr_stmt|;
else|else
name|d
operator|->
name|last_line_was_empty
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|last_line_was_empty
condition|)
name|d
operator|->
name|last_line_was_empty
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|last_line_was_empty
operator|&&
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
operator|)
operator|||
name|d
operator|->
name|last_line_was_empty
operator|>=
literal|5
condition|)
return|return;
comment|/*    * Boilerplate    */
if|if
condition|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
condition|)
name|direction
operator|=
literal|1
expr_stmt|;
name|bit
operator|=
operator|(
name|direction
operator|==
literal|1
operator|)
condition|?
literal|128
else|:
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
operator|(
name|d
operator|->
name|dst_width
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|direction
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|terminate
operator|=
operator|(
name|direction
operator|==
literal|1
operator|)
condition|?
name|d
operator|->
name|dst_width
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
name|cerror0
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
argument_list|,
name|ECOLOR_C
argument_list|)
expr_stmt|;
name|cerror1
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
operator|+
literal|1
argument_list|,
name|ECOLOR_C
argument_list|)
expr_stmt|;
name|merror0
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
argument_list|,
name|ECOLOR_M
argument_list|)
expr_stmt|;
name|merror1
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
operator|+
literal|1
argument_list|,
name|ECOLOR_M
argument_list|)
expr_stmt|;
name|yerror0
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
argument_list|,
name|ECOLOR_Y
argument_list|)
expr_stmt|;
name|yerror1
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
operator|+
literal|1
argument_list|,
name|ECOLOR_Y
argument_list|)
expr_stmt|;
name|kerror0
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
argument_list|,
name|ECOLOR_K
argument_list|)
expr_stmt|;
name|kerror1
operator|=
name|get_errline
argument_list|(
name|d
argument_list|,
name|row
operator|+
literal|1
argument_list|,
name|ECOLOR_K
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kerror1
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cerror1
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|merror1
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yerror1
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|last_line_was_empty
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|last_line_was_empty
operator|==
literal|4
condition|)
block|{
name|memset
argument_list|(
name|kerror0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cerror0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|merror0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yerror0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|dst_width
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|cptr
operator|=
name|cyan
expr_stmt|;
name|mptr
operator|=
name|magenta
expr_stmt|;
name|yptr
operator|=
name|yellow
expr_stmt|;
name|lcptr
operator|=
name|lcyan
expr_stmt|;
name|lmptr
operator|=
name|lmagenta
expr_stmt|;
name|lyptr
operator|=
name|lyellow
expr_stmt|;
name|kptr
operator|=
name|black
expr_stmt|;
if|if
condition|(
name|direction
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
name|cerror0
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|cerror1
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|merror0
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|merror1
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|yerror0
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|yerror1
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|kerror0
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
name|kerror1
operator|+=
name|d
operator|->
name|dst_width
operator|-
literal|1
expr_stmt|;
block|}
name|cptr
operator|=
name|cyan
operator|+
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lcptr
condition|)
name|lcptr
operator|=
name|lcyan
operator|+
name|length
operator|-
literal|1
expr_stmt|;
name|mptr
operator|=
name|magenta
operator|+
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lmptr
condition|)
name|lmptr
operator|=
name|lmagenta
operator|+
name|length
operator|-
literal|1
expr_stmt|;
name|yptr
operator|=
name|yellow
operator|+
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lyptr
condition|)
name|lyptr
operator|=
name|lyellow
operator|+
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|kptr
condition|)
name|kptr
operator|=
name|black
operator|+
name|length
operator|-
literal|1
expr_stmt|;
name|first_color
operator|=
operator|(
name|first_color
operator|+
name|d
operator|->
name|dst_width
operator|-
literal|1
operator|)
operator|%
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
name|ditherc
operator|=
name|cerror0
index|[
literal|0
index|]
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|0
index|]
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|0
index|]
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
expr_stmt|;
block|}
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_dithermat
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_pick
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_pick
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|matrix_set_row
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_pick
operator|)
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|QUANT
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/*    * Main loop starts here!    */
for|for
control|(
init|;
name|x
operator|!=
name|terminate
condition|;
name|x
operator|+=
name|direction
control|)
block|{
comment|/*        * First get the standard CMYK separation color values.        */
name|c
operator|=
name|cline
index|[
name|x
index|]
expr_stmt|;
name|m
operator|=
name|mline
index|[
name|x
index|]
expr_stmt|;
name|y
operator|=
name|yline
index|[
name|x
index|]
expr_stmt|;
name|oc
operator|=
name|c
expr_stmt|;
name|om
operator|=
name|m
expr_stmt|;
name|oy
operator|=
name|y
expr_stmt|;
comment|/*        * If we're doing ordered dither, and there's no ink, we aren't        * going to print anything.        */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|m
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
condition|)
goto|goto
name|advance
goto|;
else|else
block|{
name|c
operator|=
name|UPDATE_COLOR
argument_list|(
name|c
argument_list|,
name|ditherc
argument_list|)
expr_stmt|;
name|m
operator|=
name|UPDATE_COLOR
argument_list|(
name|m
argument_list|,
name|ditherm
argument_list|)
expr_stmt|;
name|y
operator|=
name|UPDATE_COLOR
argument_list|(
name|y
argument_list|,
name|dithery
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|QUANT
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|k
operator|=
name|USMIN
argument_list|(
name|c
argument_list|,
name|USMIN
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
comment|/*        * At this point we've computed the basic CMYK separations.        * Now we adjust the levels of each to improve the print quality.        */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|update_cmyk
argument_list|(
name|d
argument_list|,
name|oc
argument_list|,
name|om
argument_list|,
name|oy
argument_list|,
name|k
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|bk
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
else|else
name|update_cmy
argument_list|(
name|d
argument_list|,
name|oc
argument_list|,
name|om
argument_list|,
name|oy
argument_list|,
name|k
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
block|}
name|QUANT
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/*        * We've done all of the cmyk separations at this point.        * Now to do the dithering.        *        * At this point:        *        * bk = Amount of black printed with black ink        * ak = Adjusted "raw" K value        * k = raw K value derived from CMY        * oc, om, oy = raw CMY values assuming no K component        * c, m, y = CMY values adjusted for the presence of K        *        * The main reason for this rather elaborate setup, where we have        * 8 channels at this point, is to handle variable intensities        * (in particular light and dark variants) of inks.  Very dark regions        * with slight color tints should be printed with dark inks, not with        * the light inks that would be implied by the small amount of remnant        * CMY.        *        * It's quite likely that for simple four-color printers ordinary        * CMYK separations would work.  It's possible that they would work        * for variable dot sizes, too.        */
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
name|c
operator|=
name|UPDATE_COLOR
argument_list|(
name|c
argument_list|,
name|ditherc
argument_list|)
expr_stmt|;
name|m
operator|=
name|UPDATE_COLOR
argument_list|(
name|m
argument_list|,
name|ditherm
argument_list|)
expr_stmt|;
name|y
operator|=
name|UPDATE_COLOR
argument_list|(
name|y
argument_list|,
name|dithery
argument_list|)
expr_stmt|;
block|}
name|QUANT
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|ink_budget
operator|=
name|d
operator|->
name|ink_limit
expr_stmt|;
if|if
condition|(
name|black
condition|)
block|{
name|int
name|tk
init|=
name|print_color
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dither
operator|)
argument_list|,
name|bk
argument_list|,
name|bk
argument_list|,
name|k
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|kptr
argument_list|,
name|NULL
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ink_budget
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_pick
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|k_dithermat
operator|)
argument_list|,
name|D_ORDERED
argument_list|)
decl_stmt|;
name|printed_black
operator|=
name|k
operator|-
name|tk
expr_stmt|;
name|k
operator|=
name|tk
expr_stmt|;
block|}
else|else
name|printed_black
operator|=
literal|0
expr_stmt|;
name|QUANT
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/*        * If the printed density is high, ink reduction loses too much        * ink.  However, at low densities it seems to be safe.  Of course,        * at low densities it won't do as much.        */
if|if
condition|(
name|d
operator|->
name|density
operator|>
literal|45000
condition|)
name|printed_black
operator|=
literal|0
expr_stmt|;
comment|/*        * Uh oh spaghetti-o!        *        * It has been determined experimentally that inlining print_color        * saves a substantial amount of time.  However, expanding this out        * as a switch drastically increases the code volume by about 10 KB.        * The solution for now (until we do this properly, via an array)        * is to use this ugly code.        */
if|if
condition|(
name|first_color
operator|==
name|ECOLOR_M
condition|)
goto|goto
name|ecm
goto|;
elseif|else
if|if
condition|(
name|first_color
operator|==
name|ECOLOR_Y
condition|)
goto|goto
name|ecy
goto|;
name|ecc
label|:
name|c
operator|=
name|print_color
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_dither
operator|)
argument_list|,
name|oc
argument_list|,
name|oc
argument_list|,
name|c
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|cptr
argument_list|,
name|lcptr
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|d
operator|->
name|c_randomizer
argument_list|,
name|printed_black
argument_list|,
operator|&
name|ink_budget
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_pick
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|c_dithermat
operator|)
argument_list|,
name|d
operator|->
name|dither_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_color
operator|==
name|ECOLOR_M
condition|)
goto|goto
name|out
goto|;
name|ecm
label|:
name|m
operator|=
name|print_color
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_dither
operator|)
argument_list|,
name|om
argument_list|,
name|om
argument_list|,
name|m
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|mptr
argument_list|,
name|lmptr
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|d
operator|->
name|m_randomizer
argument_list|,
name|printed_black
argument_list|,
operator|&
name|ink_budget
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_pick
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|m_dithermat
operator|)
argument_list|,
name|d
operator|->
name|dither_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_color
operator|==
name|ECOLOR_Y
condition|)
goto|goto
name|out
goto|;
name|ecy
label|:
name|y
operator|=
name|print_color
argument_list|(
name|d
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_dither
operator|)
argument_list|,
name|oy
argument_list|,
name|oy
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|yptr
argument_list|,
name|lyptr
argument_list|,
name|bit
argument_list|,
name|length
argument_list|,
name|d
operator|->
name|y_randomizer
argument_list|,
name|printed_black
argument_list|,
operator|&
name|ink_budget
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_pick
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|y_dithermat
operator|)
argument_list|,
name|d
operator|->
name|dither_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_color
operator|!=
name|ECOLOR_C
condition|)
goto|goto
name|ecc
goto|;
name|out
label|:
name|QUANT
argument_list|(
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
name|ditherc
operator|=
name|update_dither
argument_list|(
name|c
argument_list|,
name|oc
argument_list|,
name|d
operator|->
name|src_width
argument_list|,
name|odb
argument_list|,
name|odb_mask
argument_list|,
name|direction
argument_list|,
name|cerror0
argument_list|,
name|cerror1
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|ditherm
operator|=
name|update_dither
argument_list|(
name|m
argument_list|,
name|om
argument_list|,
name|d
operator|->
name|src_width
argument_list|,
name|odb
argument_list|,
name|odb_mask
argument_list|,
name|direction
argument_list|,
name|merror0
argument_list|,
name|merror1
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dithery
operator|=
name|update_dither
argument_list|(
name|y
argument_list|,
name|oy
argument_list|,
name|d
operator|->
name|src_width
argument_list|,
name|odb
argument_list|,
name|odb_mask
argument_list|,
name|direction
argument_list|,
name|yerror0
argument_list|,
name|yerror1
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|/*****************************************************************        * Advance the loop        *****************************************************************/
name|QUANT
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|advance
label|:
if|if
condition|(
name|direction
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
name|lcptr
condition|)
name|lcptr
operator|++
expr_stmt|;
name|mptr
operator|++
expr_stmt|;
if|if
condition|(
name|lmptr
condition|)
name|lmptr
operator|++
expr_stmt|;
name|yptr
operator|++
expr_stmt|;
if|if
condition|(
name|lyptr
condition|)
name|lyptr
operator|++
expr_stmt|;
if|if
condition|(
name|kptr
condition|)
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|first_color
operator|++
expr_stmt|;
if|if
condition|(
name|first_color
operator|>=
literal|3
condition|)
name|first_color
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bit
operator|==
literal|128
condition|)
block|{
name|cptr
operator|--
expr_stmt|;
if|if
condition|(
name|lcptr
condition|)
name|lcptr
operator|--
expr_stmt|;
name|mptr
operator|--
expr_stmt|;
if|if
condition|(
name|lmptr
condition|)
name|lmptr
operator|--
expr_stmt|;
name|yptr
operator|--
expr_stmt|;
if|if
condition|(
name|lyptr
condition|)
name|lyptr
operator|--
expr_stmt|;
if|if
condition|(
name|kptr
condition|)
name|kptr
operator|--
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bit
operator|<<=
literal|1
expr_stmt|;
name|first_color
operator|--
expr_stmt|;
if|if
condition|(
name|first_color
operator|<=
literal|0
condition|)
name|first_color
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|dither_type
operator|&
name|D_ORDERED_BASE
operator|)
condition|)
block|{
name|cerror0
operator|+=
name|direction
expr_stmt|;
name|cerror1
operator|+=
name|direction
expr_stmt|;
name|merror0
operator|+=
name|direction
expr_stmt|;
name|merror1
operator|+=
name|direction
expr_stmt|;
name|yerror0
operator|+=
name|direction
expr_stmt|;
name|yerror1
operator|+=
name|direction
expr_stmt|;
name|kerror0
operator|+=
name|direction
expr_stmt|;
name|kerror1
operator|+=
name|direction
expr_stmt|;
block|}
name|QUANT
argument_list|(
literal|13
argument_list|)
expr_stmt|;
block|}
comment|/*    * Main loop ends here!    */
block|}
end_function

end_unit

