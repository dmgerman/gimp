begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in driver utility functions for the GIMP.  *  *   Copyright 1997-1999 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   dither_black()       - Dither grayscale pixels to black.  *   dither_cmyk()        - Dither RGB pixels to cyan, magenta, yellow, and  *                          black.  *   dither_black4()      - Dither grayscale pixels to 4 levels of black.  *   dither_cmyk4()       - Dither RGB pixels to 4 levels of cyan, magenta,  *                          yellow, and black.  *   gray_to_gray()       - Convert grayscale image data to grayscale.  *   indexed_to_gray()    - Convert indexed image data to grayscale.  *   indexed_to_rgb()     - Convert indexed image data to RGB.  *   rgb_to_gray()        - Convert RGB image data to grayscale.  *   rgb_to_rgb()         - Convert RGB image data to RGB.  *   default_media_size() - Return the size of a default page size.  *  * Revision History:  *  *   $Log$  *   Revision 1.11  1999/12/16 19:44:01  olofk  *   Thu Dec 16 20:15:25 CET 1999  Olof S Kylande<olof@gimp.org>  *  *           Fix of KDE/Kwm  selection add/sub/inter problem  *           NOTE: This is a workaround, not a real fix.  *           Many Thanks to Matthias Ettrich  *  *           * app/disp_callbacks.c  *  *           Updated unsharp-mask to version 0.10  *  *           * plug-ins/unsharp/dialog_f.c  *           * plug-ins/unsharp/dialog_f.h  *           * plug-ins/unsharp/dialog_i.c  *           * plug-ins/unsharp/dialog_i.h  *           * plug-ins/unsharp/unsharp.c  *  *           Updated print plug-in to version 3.0.1  *  *           * plug-ins/print/README (new file)  *           * plug-ins/print/print-escp2.c  *           * plug-ins/print/print-pcl.c  *           * plug-ins/print/print-ps.c  *           * plug-ins/print/print-util.c  *           * plug-ins/print/print.c  *           * plug-ins/print/print.h  *  *           Updated all files in the help/C/dialogs dir. This is  *           a first alpha glimpse of the help system. Please give  *           me feedback of the content. However since it's in alpha  *           stage it means that there is spell, grammatical, etc errors.  *           There is may also be pure errors which I hope "you" will  *           report to either olof@gimp.org or karin@gimp.org. Please  *           don't report spell, grammatical, etc error at this stage in dev.  *  *           If you have any plans to commit to the help system please write  *           to olof@gimp.org. (This is mandatory not a please ;-).  *  *           * help/C/welcome.html  *           * help/C/dialogs/about.html ..............  *  *   Revision 1.37  1999/12/05 23:24:08  rlk  *   don't want PRINT_LUT in release  *  *   Revision 1.36  1999/12/05 04:33:34  rlk  *   Good results for the night.  *  *   Revision 1.35  1999/12/04 19:01:05  rlk  *   better use of light colors  *  *   Revision 1.34  1999/12/02 02:09:45  rlk  *   .  *  *   Revision 1.33  1999/11/25 00:02:03  rlk  *   Revamped many controls  *  *   Revision 1.32  1999/11/23 02:11:37  rlk  *   Rationalize variables, pass 3  *  *   Revision 1.31  1999/11/23 01:33:37  rlk  *   First stage of simplifying the variable stuff  *  *   Revision 1.30  1999/11/16 00:59:00  rlk  *   More fine tuning  *  *   Revision 1.29  1999/11/14 21:37:13  rlk  *   Revamped contrast  *  *   Revision 1.28  1999/11/14 18:59:22  rlk  *   Final preparations for release to Olof  *  *   Revision 1.27  1999/11/14 00:57:11  rlk  *   Mix black in sooner gives better density.  *  *   Revision 1.26  1999/11/13 02:31:29  rlk  *   Finally!  Good settings!  *  *   Revision 1.25  1999/11/12 03:34:40  rlk  *   More tweaking  *  *   Revision 1.24  1999/11/12 02:18:32  rlk  *   Stubs for dynamic memory allocation  *  *   Revision 1.23  1999/11/12 01:53:37  rlk  *   Remove silly spurious stuff  *  *   Revision 1.22  1999/11/12 01:51:47  rlk  *   Much better black  *  *   Revision 1.21  1999/11/10 01:13:06  rlk  *   Support up to 2880 dpi  *  *   Revision 1.20  1999/11/07 22:16:42  rlk  *   Bug fixes; try to improve dithering slightly  *  *   Revision 1.19  1999/10/29 01:01:16  rlk  *   Smoother rendering of darker colors  *  *   Revision 1.18  1999/10/28 02:01:15  rlk  *   One bug, two effects:  *  *   1) Handle 4-color correctly (it was treating the 4-color too much like the  *   6-color).  *  *   2) An attempt to handle both cases with the same code path led to a  *   discontinuity that depending upon the orientation of a color gradient would  *   lead to either white or dark lines at the point that the dark version of  *   the color would kick in.  *  *   Revision 1.17  1999/10/26 23:58:31  rlk  *   indentation  *  *   Revision 1.16  1999/10/26 23:36:51  rlk  *   Comment out all remaining 16-bit code, and rename 16-bit functions to "standard" names  *  *   Revision 1.15  1999/10/26 02:10:30  rlk  *   Mostly fix save/load  *  *   Move all gimp, glib, gtk stuff into print.c (take it out of everything else).  *   This should help port it to more general purposes later.  *  *   Revision 1.14  1999/10/25 23:31:59  rlk  *   16-bit clean  *  *   Revision 1.13  1999/10/25 00:14:46  rlk  *   Remove more of the 8-bit code, now that it is tested  *  *   Revision 1.12  1999/10/23 20:26:48  rlk  *   Move LUT calculation to print-util  *  *   Revision 1.11  1999/10/21 01:27:37  rlk  *   More progress toward full 16-bit rendering  *  *   Revision 1.10  1999/10/19 02:04:59  rlk  *   Merge all of the single-level print_cmyk functions  *  *   Revision 1.9  1999/10/18 01:37:02  rlk  *   Remove spurious stuff  *  *   Revision 1.8  1999/10/17 23:44:07  rlk  *   16-bit everything (untested)  *  *   Revision 1.7  1999/10/17 23:01:01  rlk  *   Move various dither functions into print-utils.c  *  *   Revision 1.6  1999/10/14 01:59:59  rlk  *   Saturation  *  *   Revision 1.5  1999/10/03 23:57:20  rlk  *   Various improvements  *  *   Revision 1.4  1999/09/18 15:18:47  rlk  *   A bit more random  *  *   Revision 1.3  1999/09/14 21:43:43  rlk  *   Some hoped-for improvements  *  *   Revision 1.2  1999/09/12 00:12:24  rlk  *   Current best stuff  *  *   Revision 1.10  1998/05/17 07:16:49  yosh  *   0.99.31 fun  *  *   updated print plugin  *  *   -Yosh  *  *   Revision 1.14  1998/05/16  18:27:59  mike  *   Cleaned up dithering functions - unnecessary extra data in dither buffer.  *  *   Revision 1.13  1998/05/13  17:00:36  mike  *   Minor change to CMYK generation code - now cube black difference value  *   for better colors.  *  *   Revision 1.12  1998/05/08  19:20:50  mike  *   Updated CMYK generation code to use new method.  *   Updated dithering algorithm (slightly more uniform now, less speckling)  *   Added default media size function.  *  *   Revision 1.11  1998/03/01  18:03:27  mike  *   Whoops - need to add 255 - alpha to the output values (transparent to white  *   and not transparent to black...)  *  *   Revision 1.10  1998/03/01  17:20:48  mike  *   Updated alpha code to do alpha computation before gamma/brightness lut.  *  *   Revision 1.9  1998/03/01  17:13:46  mike  *   Updated CMY/CMYK conversion code for dynamic BG and hue adjustment.  *   Added alpha channel support to color conversion functions.  *  *   Revision 1.8  1998/01/21  21:33:47  mike  *   Replaced Burkes dither with stochastic (random) dither.  *  *   Revision 1.7  1997/10/02  17:57:26  mike  *   Replaced ordered dither with Burkes dither (error-diffusion).  *   Now dither K separate from CMY.  *  *   Revision 1.6  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.5  1997/07/26  18:43:04  mike  *   Fixed dither_black and dither_cmyk - wasn't clearing extra bits  *   (caused problems with A3/A4 size output).  *  *   Revision 1.5  1997/07/26  18:43:04  mike  *   Fixed dither_black and dither_cmyk - wasn't clearing extra bits  *   (caused problems with A3/A4 size output).  *  *   Revision 1.4  1997/07/02  18:46:26  mike  *   Fixed stupid bug in dither_black() - wasn't comparing against gray  *   pixels (comparing against the first black byte - d'oh!)  *   Changed 255 in dither matrix to 254 to shade correctly.  *  *   Revision 1.4  1997/07/02  18:46:26  mike  *   Fixed stupid bug in dither_black() - wasn't comparing against gray  *   pixels (comparing against the first black byte - d'oh!)  *   Changed 255 in dither matrix to 254 to shade correctly.  *  *   Revision 1.3  1997/07/02  13:51:53  mike  *   Added rgb_to_rgb and gray_to_gray conversion functions.  *   Standardized calling args to conversion functions.  *  *   Revision 1.2  1997/07/01  19:28:44  mike  *   Updated dither matrix.  *   Fixed scaling bugs in dither_*() functions.  *  *   Revision 1.1  1997/06/19  02:18:15  mike  *   Initial revision  */
end_comment

begin_comment
comment|/* #define PRINT_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/*  * RGB to grayscale luminance constants...  */
end_comment

begin_define
DECL|macro|LUM_RED
define|#
directive|define
name|LUM_RED
value|31
end_define

begin_define
DECL|macro|LUM_GREEN
define|#
directive|define
name|LUM_GREEN
value|61
end_define

begin_define
DECL|macro|LUM_BLUE
define|#
directive|define
name|LUM_BLUE
value|8
end_define

begin_comment
comment|/*  * Error buffer for dither functions.  This needs to be at least 14xMAXDPI  * (currently 720) to avoid problems...  *  * Want to dynamically allocate this so we can save memory!  */
end_comment

begin_define
DECL|macro|ERROR_ROWS
define|#
directive|define
name|ERROR_ROWS
value|2
end_define

begin_typedef
DECL|union|error
typedef|typedef
union|union
name|error
block|{
struct|struct
DECL|struct|__anon294b661d0108
block|{
DECL|member|c
name|int
name|c
index|[
name|ERROR_ROWS
index|]
decl_stmt|;
DECL|member|m
name|int
name|m
index|[
name|ERROR_ROWS
index|]
decl_stmt|;
DECL|member|y
name|int
name|y
index|[
name|ERROR_ROWS
index|]
decl_stmt|;
DECL|member|k
name|int
name|k
index|[
name|ERROR_ROWS
index|]
decl_stmt|;
DECL|member|c
block|}
name|c
struct|;
DECL|member|v
name|int
name|v
index|[
literal|4
index|]
index|[
name|ERROR_ROWS
index|]
decl_stmt|;
DECL|typedef|error_t
block|}
name|error_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|nerror
name|error_t
modifier|*
name|nerror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|error
name|int
name|error
index|[
literal|2
index|]
index|[
literal|4
index|]
index|[
literal|14
operator|*
literal|2880
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'dither_black()' - Dither grayscale pixels to black.  */
end_comment

begin_function
name|void
DECL|function|dither_black (unsigned short * gray,int row,int src_width,int dst_width,unsigned char * black)
name|dither_black
parameter_list|(
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output row */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|k
decl_stmt|,
comment|/* Current black error */
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dithering bitmask */
name|xstep
operator|=
name|src_width
operator|/
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|)
operator|/
literal|8
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherk
operator|=
operator|*
name|kerror0
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
name|k
operator|=
literal|65535
operator|-
operator|*
name|gray
operator|+
name|ditherk
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|32767
condition|)
block|{
operator|*
name|kptr
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
literal|65535
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|k
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'dither_cmyk6()' - Dither RGB pixels to cyan, magenta, light cyan,  * light magenta, yellow, and black.  *  * Added by Robert Krawitz<rlk@alum.mit.edu> August 30, 1999.  *  * Let's be really aggressive and use a single routine for ALL cmyk dithering,  * including 6 and 7 color.  *  * Note that this is heavily tuned for Epson Stylus Photo printers.  * This should be generalized for other CMYK and CcMmYK printers.  All  * of these constants were empirically determined, and are subject to review.  */
end_comment

begin_comment
comment|/*  * Ratios of dark to light inks.  The darker ink should be DE / NU darker  * than the light ink.  *  * It is essential to be very careful about use of parentheses with these  * macros!  *  * Increasing the denominators results in use of more dark ink.  This creates  * more saturated colors.  */
end_comment

begin_define
DECL|macro|NU_C
define|#
directive|define
name|NU_C
value|1
end_define

begin_define
DECL|macro|DE_C
define|#
directive|define
name|DE_C
value|3
end_define

begin_define
DECL|macro|NU_M
define|#
directive|define
name|NU_M
value|1
end_define

begin_define
DECL|macro|DE_M
define|#
directive|define
name|DE_M
value|3
end_define

begin_define
DECL|macro|NU_Y
define|#
directive|define
name|NU_Y
value|1
end_define

begin_define
DECL|macro|DE_Y
define|#
directive|define
name|DE_Y
value|3
end_define

begin_define
DECL|macro|I_RATIO_C
define|#
directive|define
name|I_RATIO_C
value|NU_C / DE_C
end_define

begin_define
DECL|macro|I_RATIO_C1
define|#
directive|define
name|I_RATIO_C1
value|NU_C / (DE_C + NU_C)
end_define

begin_define
DECL|macro|RATIO_C
define|#
directive|define
name|RATIO_C
value|DE_C / NU_C
end_define

begin_define
DECL|macro|RATIO_C1
define|#
directive|define
name|RATIO_C1
value|(DE_C + NU_C) / NU_C
end_define

begin_define
DECL|macro|I_RATIO_M
define|#
directive|define
name|I_RATIO_M
value|NU_M / DE_M
end_define

begin_define
DECL|macro|I_RATIO_M1
define|#
directive|define
name|I_RATIO_M1
value|NU_M / (DE_M + NU_M)
end_define

begin_define
DECL|macro|RATIO_M
define|#
directive|define
name|RATIO_M
value|DE_M / NU_M
end_define

begin_define
DECL|macro|RATIO_M1
define|#
directive|define
name|RATIO_M1
value|(DE_M + NU_M) / NU_M
end_define

begin_define
DECL|macro|I_RATIO_Y
define|#
directive|define
name|I_RATIO_Y
value|NU_Y / DE_Y
end_define

begin_define
DECL|macro|I_RATIO_Y1
define|#
directive|define
name|I_RATIO_Y1
value|NU_Y / (DE_Y + NU_Y)
end_define

begin_define
DECL|macro|RATIO_Y
define|#
directive|define
name|RATIO_Y
value|DE_Y / NU_Y
end_define

begin_define
DECL|macro|RATIO_Y1
define|#
directive|define
name|RATIO_Y1
value|(DE_Y + NU_Y) / NU_Y
end_define

begin_comment
comment|/*  * Lower and upper bounds for mixing CMY with K to produce gray scale.  * Reducing KDARKNESS_LOWER results in more black being used with relatively  * light grays, which causes speckling.  Increasing KDARKNESS_UPPER results  * in more CMY being used in dark tones, which results in less pure black.  * Decreasing the gap too much results in sharp crossover and stairstepping.  */
end_comment

begin_define
DECL|macro|KDARKNESS_LOWER
define|#
directive|define
name|KDARKNESS_LOWER
value|(32 * 256)
end_define

begin_define
DECL|macro|KDARKNESS_UPPER
define|#
directive|define
name|KDARKNESS_UPPER
value|(96 * 256)
end_define

begin_comment
comment|/*  * Randomizing values for deciding when to output a bit.  Normally with the  * error diffusion algorithm a bit is not output until the accumulated value  * of the pixel crosses a threshold.  This randomizes the threshold, which  * results in fewer obnoxious diagonal jaggies in pale regions.  Smaller values  * result in greater randomizing.  We use less randomness for black output  * to avoid production of black speckles in light regions.  */
end_comment

begin_define
DECL|macro|C_RANDOMIZER
define|#
directive|define
name|C_RANDOMIZER
value|2
end_define

begin_define
DECL|macro|M_RANDOMIZER
define|#
directive|define
name|M_RANDOMIZER
value|2
end_define

begin_define
DECL|macro|Y_RANDOMIZER
define|#
directive|define
name|Y_RANDOMIZER
value|2
end_define

begin_define
DECL|macro|K_RANDOMIZER
define|#
directive|define
name|K_RANDOMIZER
value|8
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PRINT_DEBUG
end_ifdef

begin_define
DECL|macro|UPDATE_COLOR_DBG (r)
define|#
directive|define
name|UPDATE_COLOR_DBG
parameter_list|(
name|r
parameter_list|)
define|\
value|do {						\   od##r = dither##r;				\   d##r = r;					\ } while (0)
end_define

begin_define
DECL|macro|PRINT_D1 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D1
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
define|\
value|do {									\   fprintf(dbg, "Case 4: o" #r " %lld " #r				\ 	  " %lld ditherbit" #d1 " %d ditherbit" #d2 " %d "		\ 	  "num %lld den %lld test1 %lld test2 %lld\n",			\ 	  o##r, r, ditherbit##d1, ditherbit##d2,			\ 	  o##r, 65536ll,						\ 	  ((32767 + (((long long) ditherbit##d2 / 1) - 32768)) * o##r	\ 	   / 65536),							\ 	  ((o##r - (65536 * I_RATIO_##R##1 * 3 / 4)) * 65536 /		\ 	   (65536 - (65536 * I_RATIO_##R##1 * 3 / 4))));		\ } while (0)
end_define

begin_define
DECL|macro|PRINT_D2 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D2
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
define|\
value|do {									\   fprintf(dbg, "Case 1: o" #r " %lld " #r " %lld test %lld\n", o##r, r,	\ 	  (32767 + (((long long) ditherbit##d2 / 1) - 32768)) *		\ 	  I_RATIO_##R##1);						\ } while (0)
end_define

begin_define
DECL|macro|PRINT_D3 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D3
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
define|\
value|do {									\   fprintf(dbg, "Case 2: o" #r " %lld " #r				\ 	  " %lld ditherbit" #d1 " %d ditherbit" #d2 " %d "		\ 	  "num %lld den %lld test1 %lld test2 %lld\n",			\ 	  o##r, r, ditherbit##d1, ditherbit##d2,			\ 	  o##r, 65536ll,						\ 	  ((32767 + (((long long) ditherbit##d2 / 1) - 32768)) * o##r /	\ 	   65536), cutoff);						\ } while (0)
end_define

begin_define
DECL|macro|PRINT_D4 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D4
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
define|\
value|do {									\   fprintf(dbg, "Case 3: o" #r " %lld " #r				\ 	  " %lld ditherbit" #d1 " %d ditherbit" #d2 " %d "		\ 	  "num %lld den %lld test1 %lld test2 %lld\n",			\ 	  o##r, r, ditherbit##d1, ditherbit##d2,			\ 	  o##r, 65536ll,						\ 	  ((32767 + (((long long) ditherbit##d2 / 1) - 32768)) * o##r /	\ 	   65536), cutoff);						\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PRINT_DEBUG */
end_comment

begin_define
DECL|macro|UPDATE_COLOR_DBG (r)
define|#
directive|define
name|UPDATE_COLOR_DBG
parameter_list|(
name|r
parameter_list|)
value|do {} while (0)
end_define

begin_define
DECL|macro|PRINT_D1 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D1
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
value|do {} while (0)
end_define

begin_define
DECL|macro|PRINT_D2 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D2
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
value|do {} while (0)
end_define

begin_define
DECL|macro|PRINT_D3 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D3
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
value|do {} while (0)
end_define

begin_define
DECL|macro|PRINT_D4 (r,R,d1,d2)
define|#
directive|define
name|PRINT_D4
parameter_list|(
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
DECL|macro|UPDATE_COLOR (r)
define|#
directive|define
name|UPDATE_COLOR
parameter_list|(
name|r
parameter_list|)
define|\
value|do {						\   o##r = r;					\   r += dither##r / 8;				\   UPDATE_COLOR_DBG(r);				\ } while (0)
end_define

begin_define
DECL|macro|PRINT_COLOR (color,r,R,d1,d2)
define|#
directive|define
name|PRINT_COLOR
parameter_list|(
name|color
parameter_list|,
name|r
parameter_list|,
name|R
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
define|\
value|do {									     \   if (!l##color)							     \     {									     \       if (r> (32767 + (((long long) ditherbit##d2 / R##_RANDOMIZER) -	     \ 			(32768 / R##_RANDOMIZER))))			     \ 	{								     \ 	  PRINT_D1(r, R, d1, d2);					     \ 	  if (r##bits++ % horizontal_overdensity == 0)			     \ 	    if (! (*kptr& bit))					     \ 	      *r##ptr |= bit;						     \ 	  r -= 65535;							     \ 	}								     \     }									     \   else									     \     {									     \       if (r<= (65536 * I_RATIO_##R##1 * 2 / 3))			     \ 	{								     \ 	  if (r> (32767 + (((long long) ditherbit##d2 / R##_RANDOMIZER) -   \ 			    (32768 / R##_RANDOMIZER))) * I_RATIO_##R##1)     \ 	    {								     \ 	      PRINT_D2(r, R, d1, d2);					     \ 	      if (l##r##bits++ % horizontal_overdensity == 0)		     \ 		if (! (*kptr& bit))					     \ 		  *l##r##ptr |= bit;					     \ 	      r -= 65535 * I_RATIO_##R##1;				     \ 	    }								     \ 	}								     \       else if (r> (32767 + (((long long) ditherbit##d2 / R##_RANDOMIZER) -  \ 			     (32768 / R##_RANDOMIZER))) * I_RATIO_##R##1)    \ 	{								     \ 	  int cutoff = ((density - (65536 * I_RATIO_##R##1 * 2 / 3)) *	     \ 			65536 / (65536 - (65536 * I_RATIO_##R##1 * 2 / 3))); \ 	  long long sub = (65535ll * I_RATIO_##R##1) +			     \ 	    ((65535ll - (65535ll * I_RATIO_##R##1)) * cutoff / 65536);	     \ 	  if (ditherbit##d1> cutoff)					     \ 	    {								     \ 	      PRINT_D3(r, R, d1, d2);					     \ 	      if (l##r##bits++ % horizontal_overdensity == 0)		     \ 		if (! (*kptr& bit))					     \ 		  *l##r##ptr |= bit;					     \ 	    }								     \ 	  else								     \ 	    {								     \ 	      PRINT_D4(r, R, d1, d2);					     \ 	      if (r##bits++ % horizontal_overdensity == 0)		     \ 		if (! (*kptr& bit))					     \ 		  *r##ptr |= bit;					     \ 	    }								     \ 	  if (sub< (65535 * I_RATIO_##R##1))				     \ 	    r -= (65535 * I_RATIO_##R##1);				     \ 	  else if (sub> 65535)						     \ 	    r -= 65535;							     \ 	  else								     \ 	    r -= sub;							     \ 	}								     \     }									     \ } while (0)
end_define

begin_if
if|#
directive|if
literal|1
end_if

begin_define
DECL|macro|UPDATE_DITHER (r,d2,x,width)
define|#
directive|define
name|UPDATE_DITHER
parameter_list|(
name|r
parameter_list|,
name|d2
parameter_list|,
name|x
parameter_list|,
name|width
parameter_list|)
define|\
value|do {						\   if (ditherbit##d2& bit)			\     {						\       if (x> 0)				\ 	r##error1[-1] += r;			\       else					\ 	r##error1[0] = r;			\       r##error1[0] += 3 * r;			\       r##error1[1] = r;				\       dither##r    = r##error0[1] + 3 * r;	\     }						\   else						\     {						\       if (x> 0)				\ 	r##error1[-1] += r * 3 / 4;		\       else					\ 	r##error1[0] = r * 3 / 4;		\       r##error1[0] +=  r * 3 / 2;		\       r##error1[1] = r * 3 / 4;			\       dither##r    = r##error0[1] + 5 * r;	\     }						\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|UPDATE_DITHER (r,d2,x,width)
define|#
directive|define
name|UPDATE_DITHER
parameter_list|(
name|r
parameter_list|,
name|d2
parameter_list|,
name|x
parameter_list|,
name|width
parameter_list|)
define|\
value|do {						\   if (ditherbit##d2& bit)			\     {						\       r##error1[0] = 5 * r;			\       dither##r    = r##error0[1] + 3 * r;	\     }						\   else						\     {						\       r##error1[0] = 3 * r;			\       dither##r    = r##error0[1] + 5 * r;	\     }						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
DECL|function|dither_cmyk (unsigned short * rgb,int row,int src_width,int dst_width,unsigned char * cyan,unsigned char * lcyan,unsigned char * magenta,unsigned char * lmagenta,unsigned char * yellow,unsigned char * lyellow,unsigned char * black,int horizontal_overdensity)
name|dither_cmyk
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output rows */
name|unsigned
name|char
modifier|*
name|cyan
parameter_list|,
comment|/* O - Cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|lcyan
parameter_list|,
comment|/* O - Light cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|magenta
parameter_list|,
comment|/* O - Magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|lmagenta
parameter_list|,
comment|/* O - Light magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|yellow
parameter_list|,
comment|/* O - Yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|lyellow
parameter_list|,
comment|/* O - Light yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|black
parameter_list|,
comment|/* O - Black bitmap pixels */
name|int
name|horizontal_overdensity
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|long
name|long
name|c
decl_stmt|,
name|m
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
comment|/* CMYK values */
name|oc
decl_stmt|,
name|om
decl_stmt|,
name|ok
decl_stmt|,
name|oy
decl_stmt|,
name|divk
decl_stmt|;
comment|/* Inverse of K */
name|long
name|long
name|diff
decl_stmt|;
comment|/* Average color difference */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|cptr
decl_stmt|,
comment|/* Current cyan pixel */
modifier|*
name|mptr
decl_stmt|,
comment|/* Current magenta pixel */
modifier|*
name|yptr
decl_stmt|,
comment|/* Current yellow pixel */
modifier|*
name|lmptr
decl_stmt|,
comment|/* Current light magenta pixel */
modifier|*
name|lcptr
decl_stmt|,
comment|/* Current light cyan pixel */
modifier|*
name|lyptr
decl_stmt|,
comment|/* Current light yellow pixel */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|ditherc
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|cerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|cerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|dithery
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|yerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|yerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherm
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|merror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|merror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dither bitmask */
name|int
name|nk
decl_stmt|;
name|int
name|ck
decl_stmt|;
name|int
name|bk
decl_stmt|;
name|int
name|ub
decl_stmt|,
name|lb
decl_stmt|;
name|int
name|ditherbit0
decl_stmt|,
name|ditherbit1
decl_stmt|,
name|ditherbit2
decl_stmt|,
name|ditherbit3
decl_stmt|;
name|long
name|long
name|density
decl_stmt|;
comment|/*    * If horizontal_overdensity is> 1, we want to output a bit only so many    * times that a bit would be generated.  These serve as counters for making    * that decision.  We make these variable static rather than reinitializing    * at zero each line to avoid having a line of bits near the edge of the    * image.    */
specifier|static
name|int
name|cbits
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|mbits
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|ybits
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|kbits
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|lcbits
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|lmbits
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|lybits
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|long
name|long
name|odk
decl_stmt|,
name|odc
decl_stmt|,
name|odm
decl_stmt|,
name|ody
decl_stmt|,
name|dk
decl_stmt|,
name|dc
decl_stmt|,
name|dm
decl_stmt|,
name|dy
decl_stmt|,
name|xk
decl_stmt|,
name|xc
decl_stmt|,
name|xm
decl_stmt|,
name|xy
decl_stmt|,
name|yc
decl_stmt|,
name|ym
decl_stmt|,
name|yy
decl_stmt|;
name|FILE
modifier|*
name|dbg
decl_stmt|;
endif|#
directive|endif
name|xstep
operator|=
literal|3
operator|*
operator|(
name|src_width
operator|/
name|dst_width
operator|)
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|cerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|0
index|]
expr_stmt|;
name|merror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|merror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|1
index|]
expr_stmt|;
name|yerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|yerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|2
index|]
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
name|cyan
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcyan
condition|)
name|memset
argument_list|(
name|lcyan
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|magenta
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmagenta
condition|)
name|memset
argument_list|(
name|lmagenta
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yellow
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lyellow
condition|)
name|memset
argument_list|(
name|lyellow
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
condition|)
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|dbg
operator|=
name|fopen
argument_list|(
literal|"/mnt1/dbg"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Main loop starts here!    */
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|cptr
operator|=
name|cyan
operator|,
name|mptr
operator|=
name|magenta
operator|,
name|yptr
operator|=
name|yellow
operator|,
name|lcptr
operator|=
name|lcyan
operator|,
name|lmptr
operator|=
name|lmagenta
operator|,
name|lyptr
operator|=
name|lyellow
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherc
operator|=
name|cerror0
index|[
literal|0
index|]
operator|,
name|ditherm
operator|=
name|merror0
index|[
literal|0
index|]
operator|,
name|dithery
operator|=
name|yerror0
index|[
literal|0
index|]
operator|,
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
operator|,
name|ditherbit0
operator|=
name|ditherbit
operator|&
literal|0xffff
operator|,
name|ditherbit1
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
operator|)
operator|,
name|ditherbit2
operator|=
operator|(
operator|(
operator|(
name|ditherbit
operator|>>
literal|16
operator|)
operator|&
literal|0x7fff
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|&
literal|0x100
operator|)
operator|<<
literal|7
operator|)
operator|)
operator|,
name|ditherbit3
operator|=
operator|(
operator|(
operator|(
name|ditherbit
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator|)
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|cerror0
operator|++
operator|,
name|cerror1
operator|++
operator|,
name|merror0
operator|++
operator|,
name|merror1
operator|++
operator|,
name|yerror0
operator|++
operator|,
name|yerror1
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
comment|/*     * First compute the standard CMYK separation color values...     */
name|int
name|maxlevel
decl_stmt|;
name|int
name|ak
decl_stmt|;
name|int
name|kdarkness
decl_stmt|;
name|c
operator|=
literal|65535
operator|-
operator|(
name|unsigned
operator|)
name|rgb
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|65535
operator|-
operator|(
name|unsigned
operator|)
name|rgb
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
literal|65535
operator|-
operator|(
name|unsigned
operator|)
name|rgb
index|[
literal|2
index|]
expr_stmt|;
name|oc
operator|=
name|c
expr_stmt|;
name|om
operator|=
name|m
expr_stmt|;
name|oy
operator|=
name|y
expr_stmt|;
name|k
operator|=
name|MIN
argument_list|(
name|c
argument_list|,
name|MIN
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|xc
operator|=
name|c
expr_stmt|;
name|xm
operator|=
name|m
expr_stmt|;
name|xy
operator|=
name|y
expr_stmt|;
name|xk
operator|=
name|k
expr_stmt|;
name|yc
operator|=
name|c
expr_stmt|;
name|ym
operator|=
name|m
expr_stmt|;
name|yy
operator|=
name|y
expr_stmt|;
endif|#
directive|endif
name|maxlevel
operator|=
name|MAX
argument_list|(
name|c
argument_list|,
name|MAX
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
block|{
comment|/*       * Since we're printing black, adjust the black level based upon       * the amount of color in the pixel (colorful pixels get less black)...       */
name|long
name|long
name|xdiff
init|=
operator|(
name|abs
argument_list|(
name|c
operator|-
name|m
argument_list|)
operator|+
name|abs
argument_list|(
name|c
operator|-
name|y
argument_list|)
operator|+
name|abs
argument_list|(
name|m
operator|-
name|y
argument_list|)
operator|)
operator|/
literal|3
decl_stmt|;
name|diff
operator|=
literal|65536
operator|-
name|xdiff
expr_stmt|;
name|diff
operator|=
name|diff
operator|*
name|diff
operator|*
name|diff
operator|/
operator|(
literal|65536ll
operator|*
literal|65536ll
operator|)
expr_stmt|;
comment|/* diff = diff^3 */
name|diff
operator|--
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|diff
operator|*
name|k
operator|/
literal|65535ll
expr_stmt|;
name|ak
operator|=
name|k
expr_stmt|;
name|divk
operator|=
literal|65535
operator|-
name|k
expr_stmt|;
if|if
condition|(
name|divk
operator|==
literal|0
condition|)
name|c
operator|=
name|m
operator|=
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Grayscale */
else|else
block|{
comment|/*         * Full color; update the CMY values for the black value and reduce         * CMY as necessary to give better blues, greens, and reds... :)         */
name|c
operator|=
operator|(
literal|65535
operator|-
operator|(
name|unsigned
operator|)
name|rgb
index|[
literal|1
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|c
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|m
operator|=
operator|(
literal|65535
operator|-
operator|(
name|unsigned
operator|)
name|rgb
index|[
literal|2
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|m
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|y
operator|=
operator|(
literal|65535
operator|-
operator|(
name|unsigned
operator|)
name|rgb
index|[
literal|0
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|y
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|yc
operator|=
name|c
expr_stmt|;
name|ym
operator|=
name|m
expr_stmt|;
name|yy
operator|=
name|y
expr_stmt|;
endif|#
directive|endif
comment|/*        * kdarkness is an artificially computed darkness value for deciding        * how much black vs. CMY to use for the k component.  This is        * empirically determined.        */
name|ok
operator|=
name|k
expr_stmt|;
name|nk
operator|=
name|k
operator|+
operator|(
name|ditherk
operator|)
operator|/
literal|8
expr_stmt|;
name|kdarkness
operator|=
name|MAX
argument_list|(
operator|(
name|c
operator|+
name|c
operator|/
literal|3
operator|+
name|m
operator|+
literal|2
operator|*
name|y
operator|/
literal|3
operator|)
operator|/
literal|4
argument_list|,
name|ak
argument_list|)
expr_stmt|;
comment|/*       kdarkness = ak; */
if|if
condition|(
name|kdarkness
operator|<
name|KDARKNESS_UPPER
condition|)
block|{
name|int
name|rb
decl_stmt|;
comment|/* 	  ub = KDARKNESS_UPPER - kdarkness; 	  lb = ub * KDARKNESS_LOWER / KDARKNESS_UPPER; */
name|ub
operator|=
name|KDARKNESS_UPPER
expr_stmt|;
name|lb
operator|=
name|KDARKNESS_LOWER
expr_stmt|;
name|rb
operator|=
name|ub
operator|-
name|lb
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|fprintf
argument_list|(
name|dbg
argument_list|,
literal|"Black: kd %d ub %d lb %d rb %d test %d range %d\n"
argument_list|,
name|kdarkness
argument_list|,
name|ub
argument_list|,
name|lb
argument_list|,
name|rb
argument_list|,
name|ditherbit
operator|%
name|rb
argument_list|,
name|kdarkness
operator|-
name|lb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|kdarkness
operator|<=
name|lb
condition|)
block|{
name|bk
operator|=
literal|0
expr_stmt|;
name|ub
operator|=
literal|0
expr_stmt|;
name|lb
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kdarkness
operator|<
name|ub
condition|)
block|{
if|if
condition|(
name|rb
operator|==
literal|0
operator|||
operator|(
name|ditherbit
operator|%
name|rb
operator|)
operator|<
operator|(
name|kdarkness
operator|-
name|lb
operator|)
condition|)
name|bk
operator|=
name|nk
expr_stmt|;
else|else
name|bk
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ub
operator|=
literal|1
expr_stmt|;
name|lb
operator|=
literal|1
expr_stmt|;
name|bk
operator|=
name|nk
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|fprintf
argument_list|(
name|dbg
argument_list|,
literal|"Black real\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bk
operator|=
name|nk
expr_stmt|;
block|}
name|ck
operator|=
name|nk
operator|-
name|bk
expr_stmt|;
comment|/*        * These constants are empirically determined to produce a CMY value        * that looks reasonably gray and is reasonably well balanced tonally        * with black.  As usual, this is very ad hoc and needs to be        * generalized.        */
if|if
condition|(
name|lmagenta
condition|)
block|{
name|c
operator|+=
name|ck
operator|*
literal|10
operator|/
literal|8
expr_stmt|;
name|m
operator|+=
name|ck
operator|*
literal|19
operator|/
literal|16
expr_stmt|;
name|y
operator|+=
name|ck
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|c
operator|+=
name|ck
expr_stmt|;
name|m
operator|+=
name|ck
expr_stmt|;
name|y
operator|+=
name|ck
expr_stmt|;
block|}
comment|/*        * Don't allow cmy to grow without bound.        */
if|if
condition|(
name|c
operator|>
literal|65535
condition|)
name|c
operator|=
literal|65535
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|65535
condition|)
name|m
operator|=
literal|65535
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|65535
condition|)
name|y
operator|=
literal|65535
expr_stmt|;
name|k
operator|=
name|bk
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|odk
operator|=
name|ditherk
expr_stmt|;
name|dk
operator|=
name|k
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|k
operator|>
operator|(
literal|32767
operator|+
operator|(
operator|(
name|ditherbit0
operator|/
name|K_RANDOMIZER
operator|)
operator|-
operator|(
literal|32768
operator|/
name|K_RANDOMIZER
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|kbits
operator|++
operator|%
name|horizontal_overdensity
operator|==
literal|0
condition|)
operator|*
name|kptr
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
literal|65535
expr_stmt|;
block|}
name|UPDATE_DITHER
argument_list|(
name|k
argument_list|,
literal|1
argument_list|,
name|x
argument_list|,
name|src_width
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (ditherbit0& bit) 	{ 	  if (x> 0) 	    kerror1[-1] += k; 	  else 	    kerror1[0] = k; 	  kerror1[0] += 2 * k; 	  kerror1[1] = k; 	  ditherk    = kerror0[1] + 3 * k; 	}       else 	{ 	  if (x> 0) 	    kerror1[-1] += k / 2; 	  else 	    kerror1[0] = k / 2; 	  kerror1[0] += k; 	  kerror1[1] = k / 2; 	  ditherk    = kerror0[1] + 5 * k; 	}
endif|#
directive|endif
block|}
else|else
block|{
comment|/*       * We're not printing black, but let's adjust the CMY levels to produce       * better reds, greens, and blues...       */
name|ok
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|(
literal|65535
operator|-
name|rgb
index|[
literal|1
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|c
operator|-
name|k
operator|)
operator|/
literal|65535
operator|+
name|k
expr_stmt|;
name|m
operator|=
operator|(
literal|65535
operator|-
name|rgb
index|[
literal|2
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|m
operator|-
name|k
operator|)
operator|/
literal|65535
operator|+
name|k
expr_stmt|;
name|y
operator|=
operator|(
literal|65535
operator|-
name|rgb
index|[
literal|0
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|y
operator|-
name|k
operator|)
operator|/
literal|65535
operator|+
name|k
expr_stmt|;
block|}
name|UPDATE_COLOR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|UPDATE_COLOR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|UPDATE_COLOR
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|density
operator|=
operator|(
name|c
operator|+
name|m
operator|+
name|y
operator|)
operator|/
name|horizontal_overdensity
expr_stmt|;
comment|/*****************************************************************      * Cyan      *****************************************************************/
if|if
condition|(
operator|!
operator|(
operator|*
name|kptr
operator|&
name|bit
operator|)
condition|)
name|PRINT_COLOR
argument_list|(
name|cyan
argument_list|,
name|c
argument_list|,
name|C
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|UPDATE_DITHER
argument_list|(
name|c
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|dst_width
argument_list|)
expr_stmt|;
comment|/*****************************************************************      * Magenta      *****************************************************************/
if|if
condition|(
operator|!
operator|(
operator|*
name|kptr
operator|&
name|bit
operator|)
condition|)
name|PRINT_COLOR
argument_list|(
name|magenta
argument_list|,
name|m
argument_list|,
name|M
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|UPDATE_DITHER
argument_list|(
name|m
argument_list|,
literal|3
argument_list|,
name|x
argument_list|,
name|dst_width
argument_list|)
expr_stmt|;
comment|/*****************************************************************      * Yellow      *****************************************************************/
if|if
condition|(
operator|!
operator|(
operator|*
name|kptr
operator|&
name|bit
operator|)
condition|)
name|PRINT_COLOR
argument_list|(
name|yellow
argument_list|,
name|y
argument_list|,
name|Y
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UPDATE_DITHER
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|dst_width
argument_list|)
expr_stmt|;
comment|/*****************************************************************      * Advance the loop      *****************************************************************/
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|fprintf
argument_list|(
name|dbg
argument_list|,
literal|"   x %d y %d  r %d g %d b %d  xc %lld xm %lld xy %lld yc "
literal|"%lld ym %lld yy %lld xk %lld  diff %lld divk %lld  oc %lld om "
literal|"%lld oy %lld ok %lld  c %lld m %lld y %lld k %lld  %c%c%c%c%c%c%c"
literal|"  dk %lld dc %lld dm %lld dy %lld  kd %d ck %d bk %d nk %d ub %d "
literal|"lb %d\n"
argument_list|,
name|x
argument_list|,
name|row
argument_list|,
name|rgb
index|[
literal|0
index|]
argument_list|,
name|rgb
index|[
literal|1
index|]
argument_list|,
name|rgb
index|[
literal|2
index|]
argument_list|,
name|xc
argument_list|,
name|xm
argument_list|,
name|xy
argument_list|,
name|yc
argument_list|,
name|ym
argument_list|,
name|yy
argument_list|,
name|xk
argument_list|,
name|diff
argument_list|,
name|divk
argument_list|,
name|oc
argument_list|,
name|om
argument_list|,
name|oy
argument_list|,
name|ok
argument_list|,
name|dc
argument_list|,
name|dm
argument_list|,
name|dy
argument_list|,
name|dk
argument_list|,
operator|(
operator|*
name|cptr
operator|&
name|bit
operator|)
condition|?
literal|'c'
else|:
literal|' '
argument_list|,
operator|(
name|lcyan
operator|&&
operator|(
operator|*
name|lcptr
operator|&
name|bit
operator|)
operator|)
condition|?
literal|'C'
else|:
literal|' '
argument_list|,
operator|(
operator|*
name|mptr
operator|&
name|bit
operator|)
condition|?
literal|'m'
else|:
literal|' '
argument_list|,
operator|(
name|lmagenta
operator|&&
operator|(
operator|*
name|lmptr
operator|&
name|bit
operator|)
operator|)
condition|?
literal|'M'
else|:
literal|' '
argument_list|,
operator|(
operator|*
name|yptr
operator|&
name|bit
operator|)
condition|?
literal|'y'
else|:
literal|' '
argument_list|,
operator|(
name|lyellow
operator|&&
operator|(
operator|*
name|lyptr
operator|&
name|bit
operator|)
operator|)
condition|?
literal|'Y'
else|:
literal|' '
argument_list|,
operator|(
name|black
operator|&&
operator|(
operator|*
name|kptr
operator|&
name|bit
operator|)
operator|)
condition|?
literal|'k'
else|:
literal|' '
argument_list|,
name|odk
argument_list|,
name|odc
argument_list|,
name|odm
argument_list|,
name|ody
argument_list|,
name|kdarkness
argument_list|,
name|ck
argument_list|,
name|bk
argument_list|,
name|nk
argument_list|,
name|ub
argument_list|,
name|lb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
name|lcptr
condition|)
name|lcptr
operator|++
expr_stmt|;
name|mptr
operator|++
expr_stmt|;
if|if
condition|(
name|lmptr
condition|)
name|lmptr
operator|++
expr_stmt|;
name|yptr
operator|++
expr_stmt|;
if|if
condition|(
name|lyptr
condition|)
name|lyptr
operator|++
expr_stmt|;
if|if
condition|(
name|kptr
condition|)
name|kptr
operator|++
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
name|ditherbit0
operator|=
name|ditherbit
operator|&
literal|0xffff
expr_stmt|;
name|ditherbit1
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|ditherbit2
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|16
operator|)
operator|&
literal|0x7fff
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|&
literal|0x100
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|ditherbit3
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
block|}
else|else
block|{
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
name|ditherbit0
operator|=
name|ditherbit
operator|&
literal|0xffff
expr_stmt|;
name|ditherbit1
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|ditherbit2
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|16
operator|)
operator|&
literal|0x7fff
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|&
literal|0x100
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
name|ditherbit3
operator|=
operator|(
operator|(
name|ditherbit
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|ditherbit
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|int dithertmp0 = (ditherbit1>> 14) ^ ((ditherbit3&0x3fff)<< 2); 	int dithertmp1 = (ditherbit2>> 14) ^ ((ditherbit2&0x3fff)<< 2); 	int dithertmp2 = (ditherbit3>> 14) ^ ((ditherbit1&0x3fff)<< 2); 	int dithertmp3 = (ditherbit0>> 14) ^ ((ditherbit0&0x3fff)<< 2); 	ditherbit0 = dithertmp0; 	ditherbit1 = dithertmp1; 	ditherbit2 = dithertmp2; 	ditherbit3 = dithertmp3;
endif|#
directive|endif
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
name|rgb
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
block|}
comment|/*    * Main loop ends here!    */
ifdef|#
directive|ifdef
name|PRINT_DEBUG
name|fprintf
argument_list|(
name|dbg
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|dbg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Constants for 4-level dithering functions...  * NOTE that these constants are HP-specific!  */
end_comment

begin_define
DECL|macro|LEVEL_3
define|#
directive|define
name|LEVEL_3
value|65535
end_define

begin_define
DECL|macro|LEVEL_2
define|#
directive|define
name|LEVEL_2
value|(213 * 65536)
end_define

begin_define
DECL|macro|LEVEL_1
define|#
directive|define
name|LEVEL_1
value|32767
end_define

begin_define
DECL|macro|LEVEL_0
define|#
directive|define
name|LEVEL_0
value|0
end_define

begin_comment
comment|/*  * 'dither_black4()' - Dither grayscale pixels to 4 levels of black.  */
end_comment

begin_function
name|void
DECL|function|dither_black4 (unsigned short * gray,int row,int src_width,int dst_width,unsigned char * black)
name|dither_black4
parameter_list|(
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output rows */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|k
decl_stmt|,
comment|/* Current black value */
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dither bitmask */
name|xstep
operator|=
name|src_width
operator|/
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
name|k
operator|=
literal|65535
operator|-
operator|*
name|gray
operator|+
name|ditherk
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|k
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'dither_cmyk4()' - Dither RGB pixels to 4 levels of cyan, magenta, yellow,  *                    and black.  */
end_comment

begin_function
name|void
DECL|function|dither_cmyk4 (unsigned short * rgb,int row,int src_width,int dst_width,unsigned char * cyan,unsigned char * magenta,unsigned char * yellow,unsigned char * black)
name|dither_cmyk4
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output rows */
name|unsigned
name|char
modifier|*
name|cyan
parameter_list|,
comment|/* O - Cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|magenta
parameter_list|,
comment|/* O - Magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|yellow
parameter_list|,
comment|/* O - Yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|long
name|long
name|c
decl_stmt|,
name|m
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
comment|/* CMYK values */
name|divk
decl_stmt|,
comment|/* Inverse of K */
name|diff
decl_stmt|;
comment|/* Average color difference */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|cptr
decl_stmt|,
comment|/* Current cyan pixel */
modifier|*
name|mptr
decl_stmt|,
comment|/* Current magenta pixel */
modifier|*
name|yptr
decl_stmt|,
comment|/* Current yellow pixel */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|ditherc
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|cerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|cerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|dithery
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|yerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|yerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherm
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|merror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|merror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dither bitmask */
name|xstep
operator|=
literal|3
operator|*
operator|(
name|src_width
operator|/
name|dst_width
operator|)
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|cerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|0
index|]
expr_stmt|;
name|merror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|merror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|1
index|]
expr_stmt|;
name|yerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|yerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|2
index|]
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
name|cyan
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|magenta
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yellow
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|cptr
operator|=
name|cyan
operator|,
name|mptr
operator|=
name|magenta
operator|,
name|yptr
operator|=
name|yellow
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherc
operator|=
name|cerror0
index|[
literal|0
index|]
operator|,
name|ditherm
operator|=
name|merror0
index|[
literal|0
index|]
operator|,
name|dithery
operator|=
name|yerror0
index|[
literal|0
index|]
operator|,
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|cerror0
operator|++
operator|,
name|cerror1
operator|++
operator|,
name|merror0
operator|++
operator|,
name|merror1
operator|++
operator|,
name|yerror0
operator|++
operator|,
name|yerror1
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
comment|/*     * First compute the standard CMYK separation color values...     */
name|c
operator|=
literal|65535
operator|-
name|rgb
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|65535
operator|-
name|rgb
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
literal|65535
operator|-
name|rgb
index|[
literal|2
index|]
expr_stmt|;
name|k
operator|=
name|MIN
argument_list|(
name|c
argument_list|,
name|MIN
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     * Since we're printing black, adjust the black level based upon     * the amount of color in the pixel (colorful pixels get less black)...     */
name|diff
operator|=
literal|65536
operator|-
operator|(
name|abs
argument_list|(
name|c
operator|-
name|m
argument_list|)
operator|+
name|abs
argument_list|(
name|c
operator|-
name|y
argument_list|)
operator|+
name|abs
argument_list|(
name|m
operator|-
name|y
argument_list|)
operator|)
operator|/
literal|3
expr_stmt|;
name|diff
operator|=
name|diff
operator|*
name|diff
operator|*
name|diff
operator|/
operator|(
literal|65536ll
operator|*
literal|65536ll
operator|)
expr_stmt|;
comment|/* diff = diff^3 */
name|diff
operator|--
expr_stmt|;
name|k
operator|=
name|diff
operator|*
name|k
operator|/
literal|65535ll
expr_stmt|;
name|divk
operator|=
literal|65535
operator|-
name|k
expr_stmt|;
if|if
condition|(
name|divk
operator|==
literal|0
condition|)
name|c
operator|=
name|m
operator|=
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Grayscale */
else|else
block|{
comment|/*       * Full color; update the CMY values for the black value and reduce       * CMY as necessary to give better blues, greens, and reds... :)       */
name|c
operator|=
operator|(
literal|65535
operator|-
name|rgb
index|[
literal|1
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|c
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|m
operator|=
operator|(
literal|65535
operator|-
name|rgb
index|[
literal|2
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|m
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|y
operator|=
operator|(
literal|65535
operator|-
name|rgb
index|[
literal|0
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|y
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
block|}
name|k
operator|+=
name|ditherk
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|k
expr_stmt|;
block|}
name|c
operator|+=
name|ditherc
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|cptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|cptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|cptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|cptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|cerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|c
expr_stmt|;
name|ditherc
operator|=
name|cerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|c
expr_stmt|;
block|}
else|else
block|{
name|cerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|c
expr_stmt|;
name|ditherc
operator|=
name|cerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|c
expr_stmt|;
block|}
name|m
operator|+=
name|ditherm
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|m
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|mptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|mptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|mptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|mptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|merror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|m
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|m
expr_stmt|;
block|}
else|else
block|{
name|merror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|m
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|m
expr_stmt|;
block|}
name|y
operator|+=
name|dithery
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|y
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|yptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|yptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|yptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|yptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|yerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|y
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|y
expr_stmt|;
block|}
else|else
block|{
name|yerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|y
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|y
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
name|mptr
operator|++
expr_stmt|;
name|yptr
operator|++
expr_stmt|;
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|rgb
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* rgb/hsv conversions taken from Gimp common/autostretch_hsv.c */
end_comment

begin_function
specifier|static
name|void
DECL|function|calc_rgb_to_hsv (unsigned short * rgb,double * hue,double * sat,double * val)
name|calc_rgb_to_hsv
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
name|double
modifier|*
name|hue
parameter_list|,
name|double
modifier|*
name|sat
parameter_list|,
name|double
modifier|*
name|val
parameter_list|)
block|{
name|double
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|double
name|min
decl_stmt|,
name|max
decl_stmt|;
name|double
name|delta
decl_stmt|;
name|red
operator|=
name|rgb
index|[
literal|0
index|]
operator|/
literal|65535.0
expr_stmt|;
name|green
operator|=
name|rgb
index|[
literal|1
index|]
operator|/
literal|65535.0
expr_stmt|;
name|blue
operator|=
name|rgb
index|[
literal|2
index|]
operator|/
literal|65535.0
expr_stmt|;
name|h
operator|=
literal|0.0
expr_stmt|;
comment|/* Shut up -Wall */
if|if
condition|(
name|red
operator|>
name|green
condition|)
block|{
if|if
condition|(
name|red
operator|>
name|blue
condition|)
name|max
operator|=
name|red
expr_stmt|;
else|else
name|max
operator|=
name|blue
expr_stmt|;
if|if
condition|(
name|green
operator|<
name|blue
condition|)
name|min
operator|=
name|green
expr_stmt|;
else|else
name|min
operator|=
name|blue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|green
operator|>
name|blue
condition|)
name|max
operator|=
name|green
expr_stmt|;
else|else
name|max
operator|=
name|blue
expr_stmt|;
if|if
condition|(
name|red
operator|<
name|blue
condition|)
name|min
operator|=
name|red
expr_stmt|;
else|else
name|min
operator|=
name|blue
expr_stmt|;
block|}
name|v
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|!=
literal|0.0
condition|)
name|s
operator|=
operator|(
name|max
operator|-
name|min
operator|)
operator|/
name|max
expr_stmt|;
else|else
name|s
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0.0
condition|)
name|h
operator|=
literal|0.0
expr_stmt|;
else|else
block|{
name|delta
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|max
condition|)
name|h
operator|=
operator|(
name|green
operator|-
name|blue
operator|)
operator|/
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|green
operator|==
name|max
condition|)
name|h
operator|=
literal|2
operator|+
operator|(
name|blue
operator|-
name|red
operator|)
operator|/
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|blue
operator|==
name|max
condition|)
name|h
operator|=
literal|4
operator|+
operator|(
name|red
operator|-
name|green
operator|)
operator|/
name|delta
expr_stmt|;
name|h
operator|/=
literal|6.0
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0.0
condition|)
name|h
operator|+=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|>
literal|1.0
condition|)
name|h
operator|-=
literal|1.0
expr_stmt|;
block|}
operator|*
name|hue
operator|=
name|h
expr_stmt|;
operator|*
name|sat
operator|=
name|s
expr_stmt|;
operator|*
name|val
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|calc_hsv_to_rgb (unsigned short * rgb,double h,double s,double v)
name|calc_hsv_to_rgb
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
name|double
name|h
parameter_list|,
name|double
name|s
parameter_list|,
name|double
name|v
parameter_list|)
block|{
name|double
name|hue
decl_stmt|,
name|saturation
decl_stmt|,
name|value
decl_stmt|;
name|double
name|f
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0.0
condition|)
block|{
name|h
operator|=
name|v
expr_stmt|;
name|s
operator|=
name|v
expr_stmt|;
name|v
operator|=
name|v
expr_stmt|;
comment|/* heh */
block|}
else|else
block|{
name|hue
operator|=
name|h
operator|*
literal|6.0
expr_stmt|;
name|saturation
operator|=
name|s
expr_stmt|;
name|value
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|hue
operator|==
literal|6.0
condition|)
name|hue
operator|=
literal|0.0
expr_stmt|;
name|f
operator|=
name|hue
operator|-
operator|(
name|int
operator|)
name|hue
expr_stmt|;
name|p
operator|=
name|value
operator|*
operator|(
literal|1.0
operator|-
name|saturation
operator|)
expr_stmt|;
name|q
operator|=
name|value
operator|*
operator|(
literal|1.0
operator|-
name|saturation
operator|*
name|f
operator|)
expr_stmt|;
name|t
operator|=
name|value
operator|*
operator|(
literal|1.0
operator|-
name|saturation
operator|*
operator|(
literal|1.0
operator|-
name|f
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|hue
condition|)
block|{
case|case
literal|0
case|:
name|h
operator|=
name|value
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|v
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|h
operator|=
name|q
expr_stmt|;
name|s
operator|=
name|value
expr_stmt|;
name|v
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|h
operator|=
name|p
expr_stmt|;
name|s
operator|=
name|value
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|h
operator|=
name|p
expr_stmt|;
name|s
operator|=
name|q
expr_stmt|;
name|v
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|h
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
name|v
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|h
operator|=
name|value
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
name|v
operator|=
name|q
expr_stmt|;
break|break;
block|}
block|}
name|rgb
index|[
literal|0
index|]
operator|=
name|h
operator|*
literal|65535
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|s
operator|*
literal|65535
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|v
operator|*
literal|65535
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'gray_to_gray()' - Convert grayscale image data to grayscale (brightness  *                    adjusted).  */
end_comment

begin_function
name|void
DECL|function|gray_to_gray (unsigned char * grayin,unsigned short * grayout,int width,int bpp,lut_t * lut,unsigned char * cmap,vars_t * vars)
name|gray_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|grayin
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|grayout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in grayin */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (unused) */
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|grayout
operator|=
name|lut
operator|->
name|composite
index|[
operator|*
name|grayin
index|]
expr_stmt|;
name|grayin
operator|++
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * Handle alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|grayout
operator|=
name|lut
operator|->
name|composite
index|[
name|grayin
index|[
literal|0
index|]
operator|*
name|grayin
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|grayin
index|[
literal|1
index|]
expr_stmt|;
name|grayin
operator|+=
name|bpp
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'indexed_to_gray()' - Convert indexed image data to grayscale.  */
end_comment

begin_function
name|void
DECL|function|indexed_to_gray (unsigned char * indexed,unsigned short * gray,int width,int bpp,lut_t * lut,unsigned char * cmap,vars_t * vars)
name|indexed_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - bpp in indexed */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness LUT */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
name|vars_t
modifier|*
name|vars
comment|/* I - Saturation */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Looping var */
name|unsigned
name|char
name|gray_cmap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Grayscale colormap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
operator|,
name|cmap
operator|+=
literal|3
control|)
name|gray_cmap
index|[
name|i
index|]
operator|=
operator|(
name|cmap
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|cmap
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|cmap
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
operator|->
name|composite
index|[
name|gray_cmap
index|[
operator|*
name|indexed
index|]
index|]
expr_stmt|;
name|indexed
operator|++
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * Handle alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
operator|->
name|composite
index|[
name|gray_cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|indexed_to_rgb (unsigned char * indexed,unsigned short * rgb,int width,int bpp,lut_t * lut,unsigned char * cmap,vars_t * vars)
name|indexed_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in indexed */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
name|vars_t
modifier|*
name|vars
comment|/* I - Saturation */
parameter_list|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|rgb
index|[
literal|0
index|]
operator|=
name|lut
operator|->
name|red
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|0
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|lut
operator|->
name|green
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|lut
operator|->
name|blue
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|2
index|]
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
condition|)
block|{
name|calc_rgb_to_hsv
argument_list|(
name|rgb
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
literal|1.0
operator|/
name|vars
operator|->
name|saturation
argument_list|)
expr_stmt|;
name|calc_hsv_to_rgb
argument_list|(
name|rgb
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|+=
literal|3
expr_stmt|;
name|indexed
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * RGBA image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|rgb
index|[
literal|0
index|]
operator|=
name|lut
operator|->
name|red
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|lut
operator|->
name|green
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|lut
operator|->
name|blue
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
condition|)
block|{
name|calc_rgb_to_hsv
argument_list|(
name|rgb
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
literal|1.0
operator|/
name|vars
operator|->
name|saturation
argument_list|)
expr_stmt|;
name|calc_hsv_to_rgb
argument_list|(
name|rgb
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|+=
literal|3
expr_stmt|;
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_gray()' - Convert RGB image data to grayscale.  */
end_comment

begin_function
name|void
DECL|function|rgb_to_gray (unsigned char * rgb,unsigned short * gray,int width,int bpp,lut_t * lut,unsigned char * cmap,vars_t * vars)
name|rgb_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in RGB */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (unused) */
name|vars_t
modifier|*
name|vars
comment|/* I - Saturation */
parameter_list|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
operator|->
name|composite
index|[
operator|(
name|rgb
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|rgb
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|rgb
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
index|]
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * Image has alpha channel...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
operator|->
name|composite
index|[
operator|(
operator|(
name|rgb
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|rgb
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|rgb
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|*
name|rgb
index|[
literal|3
index|]
operator|/
literal|25500
operator|+
literal|255
operator|-
name|rgb
index|[
literal|3
index|]
operator|)
index|]
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|rgb
operator|+=
name|bpp
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_rgb()' - Convert rgb image data to RGB.  */
end_comment

begin_function
name|void
DECL|function|rgb_to_rgb (unsigned char * rgbin,unsigned short * rgbout,int width,int bpp,lut_t * lut,unsigned char * cmap,vars_t * vars)
name|rgb_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|rgbin
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|rgbout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes/pix in indexed */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness LUT */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
name|vars_t
modifier|*
name|vars
comment|/* I - Saturation */
parameter_list|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|rgbout
index|[
literal|0
index|]
operator|=
name|lut
operator|->
name|red
index|[
name|rgbin
index|[
literal|0
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|lut
operator|->
name|green
index|[
name|rgbin
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|lut
operator|->
name|blue
index|[
name|rgbin
index|[
literal|2
index|]
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
operator|||
name|vars
operator|->
name|contrast
operator|!=
literal|100
condition|)
block|{
name|calc_rgb_to_hsv
argument_list|(
name|rgbout
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
condition|)
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
literal|1.0
operator|/
name|vars
operator|->
name|saturation
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (vars->contrast != 100) 	    { 	      double contrast = vars->contrast / 100.0; 	      double tv = fabs(v - .5) * 2.0; 	      tv = pow(tv, 1.0 / (contrast * contrast)); 	      if (v< .5) 		tv = - tv; 	      v = (tv / 2.0) + .5; 	    }
endif|#
directive|endif
name|calc_hsv_to_rgb
argument_list|(
name|rgbout
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
condition|)
block|{
name|float
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|float
operator|)
name|rgbout
index|[
name|i
index|]
operator|)
operator|/
literal|65536.0
expr_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
name|rgbout
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
block|}
name|rgbin
operator|+=
literal|3
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * RGBA image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|rgbout
index|[
literal|0
index|]
operator|=
name|lut
operator|->
name|red
index|[
name|rgbin
index|[
literal|0
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|lut
operator|->
name|green
index|[
name|rgbin
index|[
literal|1
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|lut
operator|->
name|blue
index|[
name|rgbin
index|[
literal|2
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
operator|||
name|vars
operator|->
name|contrast
operator|!=
literal|100
operator|||
name|vars
operator|->
name|density
operator|!=
literal|1.0
condition|)
block|{
name|calc_rgb_to_hsv
argument_list|(
name|rgbout
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
condition|)
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
literal|1.0
operator|/
name|vars
operator|->
name|saturation
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (vars->contrast != 100) 	    { 	      double contrast = vars->contrast / 100.0; 	      double tv = fabs(v - .5) * 2.0; 	      tv = pow(tv, 1.0 / (contrast * contrast)); 	      if (v< .5) 		tv = - tv; 	      v = (tv / 2.0) + .5; 	    }
endif|#
directive|endif
name|calc_hsv_to_rgb
argument_list|(
name|rgbout
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
condition|)
block|{
name|float
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|float
operator|)
name|rgbout
index|[
name|i
index|]
operator|)
operator|/
literal|65536.0
expr_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
name|rgbout
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
block|}
name|rgbin
operator|+=
name|bpp
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* #define PRINT_LUT */
end_comment

begin_function
name|void
DECL|function|compute_lut (lut_t * lut,float print_gamma,float app_gamma,vars_t * v)
name|compute_lut
parameter_list|(
name|lut_t
modifier|*
name|lut
parameter_list|,
name|float
name|print_gamma
parameter_list|,
name|float
name|app_gamma
parameter_list|,
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
name|float
name|brightness
decl_stmt|,
comment|/* Computed brightness */
name|screen_gamma
decl_stmt|,
comment|/* Screen gamma correction */
name|pixel
decl_stmt|,
comment|/* Pixel value */
name|red_pixel
decl_stmt|,
comment|/* Pixel value */
name|green_pixel
decl_stmt|,
comment|/* Pixel value */
name|blue_pixel
decl_stmt|;
comment|/* Pixel value */
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PRINT_LUT
name|FILE
modifier|*
name|ltfile
init|=
name|fopen
argument_list|(
literal|"/mnt1/lut"
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/*    * Got an output file/command, now compute a brightness lookup table...    */
name|float
name|red
init|=
literal|100.0
operator|/
name|v
operator|->
name|red
decl_stmt|;
name|float
name|green
init|=
literal|100.0
operator|/
name|v
operator|->
name|green
decl_stmt|;
name|float
name|blue
init|=
literal|100.0
operator|/
name|v
operator|->
name|blue
decl_stmt|;
name|float
name|contrast
decl_stmt|;
name|contrast
operator|=
name|v
operator|->
name|contrast
operator|/
literal|100.0
expr_stmt|;
if|if
condition|(
name|red
operator|<
literal|0.01
condition|)
name|red
operator|=
literal|0.01
expr_stmt|;
if|if
condition|(
name|green
operator|<
literal|0.01
condition|)
name|green
operator|=
literal|0.01
expr_stmt|;
if|if
condition|(
name|blue
operator|<
literal|0.01
condition|)
name|blue
operator|=
literal|0.01
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|linear
condition|)
block|{
name|screen_gamma
operator|=
name|app_gamma
operator|/
literal|1.7
expr_stmt|;
name|brightness
operator|=
name|v
operator|->
name|brightness
operator|/
literal|100.0
expr_stmt|;
block|}
else|else
block|{
name|brightness
operator|=
literal|100.0
operator|/
name|v
operator|->
name|brightness
expr_stmt|;
name|screen_gamma
operator|=
name|app_gamma
operator|*
name|brightness
operator|/
literal|1.7
expr_stmt|;
block|}
name|print_gamma
operator|=
name|v
operator|->
name|gamma
operator|/
name|print_gamma
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|linear
condition|)
block|{
name|double
name|adjusted_pixel
decl_stmt|;
name|pixel
operator|=
name|adjusted_pixel
operator|=
operator|(
name|float
operator|)
name|i
operator|/
literal|255.0
expr_stmt|;
if|if
condition|(
name|brightness
operator|<
literal|1.0
condition|)
name|adjusted_pixel
operator|=
name|adjusted_pixel
operator|*
name|brightness
expr_stmt|;
elseif|else
if|if
condition|(
name|brightness
operator|>
literal|1.0
condition|)
name|adjusted_pixel
operator|=
literal|1.0
operator|-
operator|(
operator|(
literal|1.0
operator|-
name|adjusted_pixel
operator|)
operator|/
name|brightness
operator|)
expr_stmt|;
if|if
condition|(
name|pixel
operator|<
literal|0
condition|)
name|adjusted_pixel
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pixel
operator|>
literal|1.0
condition|)
name|adjusted_pixel
operator|=
literal|1.0
expr_stmt|;
name|adjusted_pixel
operator|=
name|pow
argument_list|(
name|adjusted_pixel
argument_list|,
name|print_gamma
operator|*
name|screen_gamma
operator|*
name|print_gamma
argument_list|)
expr_stmt|;
name|adjusted_pixel
operator|*=
literal|65535.0
expr_stmt|;
name|red_pixel
operator|=
name|green_pixel
operator|=
name|blue_pixel
operator|=
name|adjusted_pixel
expr_stmt|;
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
name|adjusted_pixel
expr_stmt|;
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
name|adjusted_pixel
expr_stmt|;
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
name|adjusted_pixel
expr_stmt|;
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|adjusted_pixel
expr_stmt|;
block|}
else|else
block|{
name|float
name|temp_pixel
decl_stmt|;
name|pixel
operator|=
operator|(
name|float
operator|)
name|i
operator|/
literal|255.0
expr_stmt|;
comment|/* 	   * First, correct contrast 	   */
name|temp_pixel
operator|=
name|fabs
argument_list|(
operator|(
name|pixel
operator|-
literal|.5
operator|)
operator|*
literal|2.0
argument_list|)
expr_stmt|;
name|temp_pixel
operator|=
name|pow
argument_list|(
name|temp_pixel
argument_list|,
literal|1.0
operator|/
name|contrast
argument_list|)
expr_stmt|;
if|if
condition|(
name|pixel
operator|<
literal|.5
condition|)
name|temp_pixel
operator|=
operator|-
name|temp_pixel
expr_stmt|;
name|pixel
operator|=
operator|(
name|temp_pixel
operator|/
literal|2.0
operator|)
operator|+
literal|.5
expr_stmt|;
comment|/* 	   * Second, perform screen gamma correction 	   */
name|pixel
operator|=
literal|1.0
operator|-
name|pow
argument_list|(
name|pixel
argument_list|,
name|screen_gamma
argument_list|)
expr_stmt|;
comment|/* 	   * Third, fix up red, green, blue values 	   * 	   * I don't know how to do this correctly.  I think that what I'll do 	   * is if the correction is less than 1 to multiply it by the 	   * correction; if it's greater than 1, hinge it around 64K. 	   * Doubtless we can do better.  Oh well. 	   */
if|if
condition|(
name|pixel
operator|<
literal|0.0
condition|)
name|pixel
operator|=
literal|0.0
expr_stmt|;
elseif|else
if|if
condition|(
name|pixel
operator|>
literal|1.0
condition|)
name|pixel
operator|=
literal|1.0
expr_stmt|;
name|red_pixel
operator|=
name|pow
argument_list|(
name|pixel
argument_list|,
literal|1.0
operator|/
operator|(
name|red
operator|*
name|red
operator|)
argument_list|)
expr_stmt|;
name|green_pixel
operator|=
name|pow
argument_list|(
name|pixel
argument_list|,
literal|1.0
operator|/
operator|(
name|green
operator|*
name|green
operator|)
argument_list|)
expr_stmt|;
name|blue_pixel
operator|=
name|pow
argument_list|(
name|pixel
argument_list|,
literal|1.0
operator|/
operator|(
name|blue
operator|*
name|blue
operator|)
argument_list|)
expr_stmt|;
comment|/* 	   * Finally, fix up print gamma and scale 	   */
name|pixel
operator|=
literal|256.0
operator|*
operator|(
literal|256.0
operator|-
literal|256.0
operator|*
name|pow
argument_list|(
name|pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
name|red_pixel
operator|=
literal|256.0
operator|*
operator|(
literal|256.0
operator|-
literal|256.0
operator|*
name|pow
argument_list|(
name|red_pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
name|green_pixel
operator|=
literal|256.0
operator|*
operator|(
literal|256.0
operator|-
literal|256.0
operator|*
name|pow
argument_list|(
name|green_pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
name|blue_pixel
operator|=
literal|256.0
operator|*
operator|(
literal|256.0
operator|-
literal|256.0
operator|*
name|pow
argument_list|(
name|blue_pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (red> 1.0) 	    red_pixel = 65536.0 + ((pixel - 65536.0) / red); 	  else 	    red_pixel = pixel * red; 	  if (green> 1.0) 	    green_pixel = 65536.0 + ((pixel - 65536.0) / green); 	  else 	    green_pixel = pixel * green; 	  if (blue> 1.0) 	    blue_pixel = 65536.0 + ((pixel - 65536.0) / blue); 	  else 	    blue_pixel = pixel * blue;
endif|#
directive|endif
if|if
condition|(
name|pixel
operator|<=
literal|0.0
condition|)
block|{
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixel
operator|>=
literal|65535.0
condition|)
block|{
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
block|}
else|else
block|{
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|pixel
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|red_pixel
operator|<=
literal|0.0
condition|)
block|{
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|red_pixel
operator|>=
literal|65535.0
condition|)
block|{
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
block|}
else|else
block|{
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|red_pixel
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|green_pixel
operator|<=
literal|0.0
condition|)
block|{
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|green_pixel
operator|>=
literal|65535.0
condition|)
block|{
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
block|}
else|else
block|{
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|green_pixel
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blue_pixel
operator|<=
literal|0.0
condition|)
block|{
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blue_pixel
operator|>=
literal|65535.0
condition|)
block|{
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
block|}
else|else
block|{
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|blue_pixel
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PRINT_LUT
name|fprintf
argument_list|(
name|ltfile
argument_list|,
literal|"%3i  %5d  %5d  %5d  %5d  %f %f %f %f  %f %f %f  %f\n"
argument_list|,
name|i
argument_list|,
name|lut
operator|->
name|composite
index|[
name|i
index|]
argument_list|,
name|lut
operator|->
name|red
index|[
name|i
index|]
argument_list|,
name|lut
operator|->
name|green
index|[
name|i
index|]
argument_list|,
name|lut
operator|->
name|blue
index|[
name|i
index|]
argument_list|,
name|pixel
argument_list|,
name|red_pixel
argument_list|,
name|green_pixel
argument_list|,
name|blue_pixel
argument_list|,
name|print_gamma
argument_list|,
name|screen_gamma
argument_list|,
name|print_gamma
argument_list|,
name|app_gamma
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PRINT_LUT
name|fclose
argument_list|(
name|ltfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * 'default_media_size()' - Return the size of a default page size.  */
end_comment

begin_function
name|void
DECL|function|default_media_size (int model,char * ppd_file,char * media_size,int * width,int * length)
name|default_media_size
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|media_size
parameter_list|,
comment|/* I - Media size */
name|int
modifier|*
name|width
parameter_list|,
comment|/* O - Width in points */
name|int
modifier|*
name|length
parameter_list|)
comment|/* O - Length in points */
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|media_size
argument_list|,
literal|"Letter"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|width
operator|=
literal|612
expr_stmt|;
operator|*
name|length
operator|=
literal|792
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|media_size
argument_list|,
literal|"Legal"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|width
operator|=
literal|612
expr_stmt|;
operator|*
name|length
operator|=
literal|1008
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|media_size
argument_list|,
literal|"Tabloid"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|width
operator|=
literal|792
expr_stmt|;
operator|*
name|length
operator|=
literal|1214
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|media_size
argument_list|,
literal|"12x18"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|width
operator|=
literal|864
expr_stmt|;
operator|*
name|length
operator|=
literal|1296
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|media_size
argument_list|,
literal|"A4"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|width
operator|=
literal|595
expr_stmt|;
operator|*
name|length
operator|=
literal|842
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|media_size
argument_list|,
literal|"A3"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|width
operator|=
literal|842
expr_stmt|;
operator|*
name|length
operator|=
literal|1191
expr_stmt|;
block|}
else|else
block|{
operator|*
name|width
operator|=
literal|0
expr_stmt|;
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LEFTOVER_8_BIT
end_ifdef

begin_comment
comment|/*  * Everything here and below goes away when this is tested on all printers.  */
end_comment

begin_define
DECL|macro|LEVEL_3
define|#
directive|define
name|LEVEL_3
value|255
end_define

begin_define
DECL|macro|LEVEL_2
define|#
directive|define
name|LEVEL_2
value|213
end_define

begin_define
DECL|macro|LEVEL_1
define|#
directive|define
name|LEVEL_1
value|127
end_define

begin_define
DECL|macro|LEVEL_0
define|#
directive|define
name|LEVEL_0
value|0
end_define

begin_function
name|void
DECL|function|dither_black4 (unsigned char * gray,int row,int src_width,int dst_width,unsigned char * black)
name|dither_black4
parameter_list|(
name|unsigned
name|char
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output rows */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|k
decl_stmt|,
comment|/* Current black value */
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dither bitmask */
name|xstep
operator|=
name|src_width
operator|/
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
name|k
operator|=
literal|255
operator|-
operator|*
name|gray
operator|+
name|ditherk
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|k
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|dither_cmyk4 (unsigned char * rgb,int row,int src_width,int dst_width,unsigned char * cyan,unsigned char * magenta,unsigned char * yellow,unsigned char * black)
name|dither_cmyk4
parameter_list|(
name|unsigned
name|char
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output rows */
name|unsigned
name|char
modifier|*
name|cyan
parameter_list|,
comment|/* O - Cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|magenta
parameter_list|,
comment|/* O - Magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|yellow
parameter_list|,
comment|/* O - Yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|int
name|c
decl_stmt|,
name|m
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
comment|/* CMYK values */
name|divk
decl_stmt|,
comment|/* Inverse of K */
name|diff
decl_stmt|;
comment|/* Average color difference */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|cptr
decl_stmt|,
comment|/* Current cyan pixel */
modifier|*
name|mptr
decl_stmt|,
comment|/* Current magenta pixel */
modifier|*
name|yptr
decl_stmt|,
comment|/* Current yellow pixel */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|ditherc
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|cerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|cerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|dithery
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|yerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|yerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherm
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|merror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|merror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dither bitmask */
name|xstep
operator|=
literal|3
operator|*
operator|(
name|src_width
operator|/
name|dst_width
operator|)
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|cerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|0
index|]
expr_stmt|;
name|merror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|merror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|1
index|]
expr_stmt|;
name|yerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|yerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|2
index|]
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
name|cyan
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|magenta
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yellow
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|cptr
operator|=
name|cyan
operator|,
name|mptr
operator|=
name|magenta
operator|,
name|yptr
operator|=
name|yellow
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherc
operator|=
name|cerror0
index|[
literal|0
index|]
operator|,
name|ditherm
operator|=
name|merror0
index|[
literal|0
index|]
operator|,
name|dithery
operator|=
name|yerror0
index|[
literal|0
index|]
operator|,
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|cerror0
operator|++
operator|,
name|cerror1
operator|++
operator|,
name|merror0
operator|++
operator|,
name|merror1
operator|++
operator|,
name|yerror0
operator|++
operator|,
name|yerror1
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
comment|/*     * First compute the standard CMYK separation color values...     */
name|c
operator|=
literal|255
operator|-
name|rgb
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|255
operator|-
name|rgb
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
literal|255
operator|-
name|rgb
index|[
literal|2
index|]
expr_stmt|;
name|k
operator|=
name|MIN
argument_list|(
name|c
argument_list|,
name|MIN
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     * Since we're printing black, adjust the black level based upon     * the amount of color in the pixel (colorful pixels get less black)...     */
name|diff
operator|=
literal|255
operator|-
operator|(
name|abs
argument_list|(
name|c
operator|-
name|m
argument_list|)
operator|+
name|abs
argument_list|(
name|c
operator|-
name|y
argument_list|)
operator|+
name|abs
argument_list|(
name|m
operator|-
name|y
argument_list|)
operator|)
operator|/
literal|3
expr_stmt|;
name|diff
operator|=
name|diff
operator|*
name|diff
operator|*
name|diff
operator|/
literal|65025
expr_stmt|;
comment|/* diff = diff^3 */
name|k
operator|=
name|diff
operator|*
name|k
operator|/
literal|255
expr_stmt|;
name|divk
operator|=
literal|255
operator|-
name|k
expr_stmt|;
if|if
condition|(
name|divk
operator|==
literal|0
condition|)
name|c
operator|=
name|m
operator|=
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Grayscale */
else|else
block|{
comment|/*       * Full color; update the CMY values for the black value and reduce       * CMY as necessary to give better blues, greens, and reds... :)       */
name|c
operator|=
operator|(
literal|255
operator|-
name|rgb
index|[
literal|1
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|c
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|m
operator|=
operator|(
literal|255
operator|-
name|rgb
index|[
literal|2
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|m
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|y
operator|=
operator|(
literal|255
operator|-
name|rgb
index|[
literal|0
index|]
operator|/
literal|4
operator|)
operator|*
operator|(
name|y
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
block|}
name|k
operator|+=
name|ditherk
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|kptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|k
expr_stmt|;
block|}
name|c
operator|+=
name|ditherc
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|cptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|cptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|cptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|cptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|cerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|c
expr_stmt|;
name|ditherc
operator|=
name|cerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|c
expr_stmt|;
block|}
else|else
block|{
name|cerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|c
expr_stmt|;
name|ditherc
operator|=
name|cerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|c
expr_stmt|;
block|}
name|m
operator|+=
name|ditherm
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|m
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|mptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|mptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|mptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|mptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|merror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|m
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|m
expr_stmt|;
block|}
else|else
block|{
name|merror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|m
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|m
expr_stmt|;
block|}
name|y
operator|+=
name|dithery
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|y
operator|>
operator|(
operator|(
name|LEVEL_2
operator|+
name|LEVEL_3
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|yptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|yptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
name|LEVEL_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
operator|(
operator|(
name|LEVEL_1
operator|+
name|LEVEL_2
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|yptr
index|[
name|length
index|]
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
name|LEVEL_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
operator|(
operator|(
name|LEVEL_0
operator|+
name|LEVEL_1
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
name|yptr
index|[
literal|0
index|]
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
name|LEVEL_1
expr_stmt|;
block|}
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|yerror1
index|[
literal|0
index|]
operator|=
literal|5
operator|*
name|y
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|y
expr_stmt|;
block|}
else|else
block|{
name|yerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|y
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|1
index|]
operator|+
literal|5
operator|*
name|y
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
name|mptr
operator|++
expr_stmt|;
name|yptr
operator|++
expr_stmt|;
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|rgb
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|gray_to_gray (unsigned char * grayin,unsigned char * grayout,int width,int bpp,unsigned char * cmap,float saturation)
name|gray_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|grayin
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|char
modifier|*
name|grayout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in grayin */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (unused) */
name|float
name|saturation
comment|/* I - Saturation */
parameter_list|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|grayout
operator|=
name|lut
operator|->
name|composite
index|[
operator|*
name|grayin
index|]
expr_stmt|;
name|grayin
operator|++
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * Handle alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|grayout
operator|=
name|lut
operator|->
name|composite
index|[
name|grayin
index|[
literal|0
index|]
operator|*
name|grayin
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|grayin
index|[
literal|1
index|]
expr_stmt|;
name|grayin
operator|+=
name|bpp
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
DECL|function|indexed_to_gray (unsigned char * indexed,unsigned char * gray,int width,int bpp,unsigned char * cmap,float saturation)
name|indexed_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|unsigned
name|char
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes/pix in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
name|float
name|saturation
comment|/* I - Saturation */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Looping var */
name|unsigned
name|char
name|gray_cmap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Grayscale colormap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
operator|,
name|cmap
operator|+=
literal|3
control|)
name|gray_cmap
index|[
name|i
index|]
operator|=
operator|(
name|cmap
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|cmap
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|cmap
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
operator|->
name|composite
index|[
name|gray_cmap
index|[
operator|*
name|indexed
index|]
index|]
expr_stmt|;
name|indexed
operator|++
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*     * Handle alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
operator|->
name|composite
index|[
name|gray_cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

