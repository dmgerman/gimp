begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in driver utility functions for the GIMP.  *  *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   gray_to_gray()       - Convert grayscale image data to grayscale.  *   indexed_to_gray()    - Convert indexed image data to grayscale.  *   indexed_to_rgb()     - Convert indexed image data to RGB.  *   rgb_to_gray()        - Convert RGB image data to grayscale.  *   rgb_to_rgb()         - Convert RGB image data to RGB.  *   default_media_size() - Return the size of a default page size.  *  * Revision History:  *  *   See ChangeLog  */
end_comment

begin_comment
comment|/* #define PRINT_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
DECL|macro|inline
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_comment
comment|/*  * EGCS 1.1.2/gcc 2.91 seems to have some particularly nasty inlining bugs  */
end_comment

begin_if
if|#
directive|if
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|==
literal|91
operator|)
end_if

begin_define
DECL|macro|inline
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * RGB to grayscale luminance constants...  */
end_comment

begin_define
DECL|macro|LUM_RED
define|#
directive|define
name|LUM_RED
value|31
end_define

begin_define
DECL|macro|LUM_GREEN
define|#
directive|define
name|LUM_GREEN
value|61
end_define

begin_define
DECL|macro|LUM_BLUE
define|#
directive|define
name|LUM_BLUE
value|8
end_define

begin_comment
comment|/* rgb/hsv conversions taken from Gimp common/autostretch_hsv.c */
end_comment

begin_define
DECL|macro|FMAX (a,b)
define|#
directive|define
name|FMAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
DECL|macro|FMIN (a,b)
define|#
directive|define
name|FMIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_function
specifier|static
specifier|inline
name|void
DECL|function|calc_rgb_to_hsl (unsigned short * rgb,double * hue,double * sat,double * lightness)
name|calc_rgb_to_hsl
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
name|double
modifier|*
name|hue
parameter_list|,
name|double
modifier|*
name|sat
parameter_list|,
name|double
modifier|*
name|lightness
parameter_list|)
block|{
name|double
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|l
decl_stmt|;
name|double
name|min
decl_stmt|,
name|max
decl_stmt|;
name|double
name|delta
decl_stmt|;
name|red
operator|=
name|rgb
index|[
literal|0
index|]
operator|/
literal|65535.0
expr_stmt|;
name|green
operator|=
name|rgb
index|[
literal|1
index|]
operator|/
literal|65535.0
expr_stmt|;
name|blue
operator|=
name|rgb
index|[
literal|2
index|]
operator|/
literal|65535.0
expr_stmt|;
if|if
condition|(
name|red
operator|>
name|green
condition|)
block|{
name|max
operator|=
name|FMAX
argument_list|(
name|red
argument_list|,
name|blue
argument_list|)
expr_stmt|;
name|min
operator|=
name|FMIN
argument_list|(
name|green
argument_list|,
name|blue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|FMAX
argument_list|(
name|green
argument_list|,
name|blue
argument_list|)
expr_stmt|;
name|min
operator|=
name|FMIN
argument_list|(
name|red
argument_list|,
name|blue
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|/
literal|2.0
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|min
condition|)
block|{
name|s
operator|=
literal|0.0
expr_stmt|;
name|h
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|.5
condition|)
name|s
operator|=
name|delta
operator|/
operator|(
name|max
operator|+
name|min
operator|)
expr_stmt|;
else|else
name|s
operator|=
name|delta
operator|/
operator|(
literal|2
operator|-
name|max
operator|-
name|min
operator|)
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|max
condition|)
name|h
operator|=
operator|(
name|green
operator|-
name|blue
operator|)
operator|/
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|green
operator|==
name|max
condition|)
name|h
operator|=
literal|2
operator|+
operator|(
name|blue
operator|-
name|red
operator|)
operator|/
name|delta
expr_stmt|;
else|else
name|h
operator|=
literal|4
operator|+
operator|(
name|red
operator|-
name|green
operator|)
operator|/
name|delta
expr_stmt|;
name|h
operator|/=
literal|6.0
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0.0
condition|)
name|h
operator|+=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|>
literal|1.0
condition|)
name|h
operator|-=
literal|1.0
expr_stmt|;
block|}
operator|*
name|hue
operator|=
name|h
expr_stmt|;
operator|*
name|sat
operator|=
name|s
expr_stmt|;
operator|*
name|lightness
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|double
DECL|function|hsl_value (double n1,double n2,double hue)
name|hsl_value
parameter_list|(
name|double
name|n1
parameter_list|,
name|double
name|n2
parameter_list|,
name|double
name|hue
parameter_list|)
block|{
if|if
condition|(
name|hue
operator|<
literal|0
condition|)
name|hue
operator|+=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|hue
operator|>
literal|1
condition|)
name|hue
operator|-=
literal|1.0
expr_stmt|;
if|if
condition|(
name|hue
operator|<
operator|(
literal|1.0
operator|/
literal|6.0
operator|)
condition|)
return|return
operator|(
name|n1
operator|+
operator|(
name|n2
operator|-
name|n1
operator|)
operator|*
operator|(
name|hue
operator|*
literal|6.0
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|hue
operator|<
literal|.5
condition|)
return|return
operator|(
name|n2
operator|)
return|;
elseif|else
if|if
condition|(
name|hue
operator|<
operator|(
literal|4.0
operator|/
literal|6.0
operator|)
condition|)
return|return
operator|(
name|n1
operator|+
operator|(
name|n2
operator|-
name|n1
operator|)
operator|*
operator|(
operator|(
operator|(
literal|4.0
operator|/
literal|6.0
operator|)
operator|-
name|hue
operator|)
operator|*
literal|6.0
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|n1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|calc_hsl_to_rgb (unsigned short * rgb,double h,double s,double l)
name|calc_hsl_to_rgb
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
name|double
name|h
parameter_list|,
name|double
name|s
parameter_list|,
name|double
name|l
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|1
condition|)
name|l
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
name|rgb
index|[
literal|0
index|]
operator|=
name|l
operator|*
literal|65535
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|l
operator|*
literal|65535
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|l
operator|*
literal|65535
expr_stmt|;
block|}
else|else
block|{
name|double
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|double
name|h1
init|=
name|h
operator|+
operator|(
literal|2.0
operator|/
literal|6.0
operator|)
decl_stmt|;
name|double
name|h2
init|=
name|h
operator|-
operator|(
literal|2.0
operator|/
literal|6.0
operator|)
decl_stmt|;
if|if
condition|(
name|l
operator|<
literal|.5
condition|)
name|m2
operator|=
name|l
operator|*
operator|(
literal|1
operator|+
name|s
operator|)
expr_stmt|;
else|else
name|m2
operator|=
name|l
operator|+
name|s
operator|-
operator|(
name|l
operator|*
name|s
operator|)
expr_stmt|;
name|m1
operator|=
operator|(
name|l
operator|*
literal|2
operator|)
operator|-
name|m2
expr_stmt|;
name|rgb
index|[
literal|0
index|]
operator|=
literal|65535
operator|*
name|hsl_value
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
literal|65535
operator|*
name|hsl_value
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
literal|65535
operator|*
name|hsl_value
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
DECL|function|update_cmyk (unsigned short * rgb)
name|update_cmyk
parameter_list|(
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|)
block|{
name|unsigned
name|c
init|=
literal|65535
operator|-
name|rgb
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|m
init|=
literal|65535
operator|-
name|rgb
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|y
init|=
literal|65535
operator|-
name|rgb
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|nc
decl_stmt|,
name|nm
decl_stmt|,
name|ny
decl_stmt|;
name|unsigned
name|k
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|m
operator|&&
name|c
operator|==
name|y
condition|)
return|return;
name|k
operator|=
name|FMIN
argument_list|(
name|FMIN
argument_list|(
name|c
argument_list|,
name|m
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/*    * Soften up the CMY primaries    */
name|nc
operator|=
operator|(
name|c
operator|*
literal|4
operator|+
name|FMIN
argument_list|(
name|c
argument_list|,
name|FMAX
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
operator|*
literal|3
operator|+
name|k
operator|)
operator|/
literal|8
expr_stmt|;
name|nm
operator|=
operator|(
name|m
operator|*
literal|4
operator|+
name|FMIN
argument_list|(
name|m
argument_list|,
name|FMAX
argument_list|(
name|c
argument_list|,
name|y
argument_list|)
argument_list|)
operator|*
literal|3
operator|+
name|k
operator|)
operator|/
literal|8
expr_stmt|;
name|ny
operator|=
operator|(
name|y
operator|*
literal|4
operator|+
name|FMIN
argument_list|(
name|y
argument_list|,
name|FMAX
argument_list|(
name|c
argument_list|,
name|m
argument_list|)
argument_list|)
operator|*
literal|3
operator|+
name|k
operator|)
operator|/
literal|8
expr_stmt|;
comment|/*    * Make sure we didn't go overboard.  We don't want to go too    * close to white unnecessarily.    */
name|nc
operator|=
name|c
operator|+
operator|(
name|nc
operator|-
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|nm
operator|=
name|m
operator|+
operator|(
name|nm
operator|-
name|m
operator|)
operator|/
literal|2
expr_stmt|;
name|ny
operator|=
name|y
operator|+
operator|(
name|ny
operator|-
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|rgb
index|[
literal|0
index|]
operator|=
literal|65535
operator|-
name|nc
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
literal|65535
operator|-
name|nm
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
literal|65535
operator|-
name|ny
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|short
DECL|function|lookup_value (unsigned short value,int lut_size,unsigned short * lut)
name|lookup_value
parameter_list|(
name|unsigned
name|short
name|value
parameter_list|,
name|int
name|lut_size
parameter_list|,
name|unsigned
name|short
modifier|*
name|lut
parameter_list|)
block|{
name|unsigned
name|shiftval
decl_stmt|;
switch|switch
condition|(
name|lut_size
condition|)
block|{
case|case
literal|65536
case|:
return|return
name|value
return|;
break|break;
case|case
literal|16
case|:
name|shiftval
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|shiftval
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|shiftval
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|shiftval
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|shiftval
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|shiftval
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|shiftval
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|2048
case|:
name|shiftval
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|4096
case|:
name|shiftval
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|shiftval
operator|=
literal|13
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|shiftval
operator|=
literal|14
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|shiftval
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
block|{
name|unsigned
name|subrange
init|=
name|value
operator|/
name|lut_size
decl_stmt|;
name|unsigned
name|remainder
init|=
name|value
operator|%
name|lut_size
decl_stmt|;
name|unsigned
name|below
init|=
name|lut
index|[
name|subrange
index|]
decl_stmt|;
name|unsigned
name|above
decl_stmt|;
if|if
condition|(
name|subrange
operator|==
name|lut_size
operator|-
literal|1
condition|)
name|above
operator|=
literal|65535
expr_stmt|;
else|else
name|above
operator|=
name|lut
index|[
name|subrange
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|above
operator|==
name|below
condition|)
return|return
name|above
return|;
else|else
return|return
name|below
operator|+
operator|(
operator|(
name|above
operator|-
name|below
operator|)
operator|*
name|remainder
operator|)
operator|/
operator|(
literal|65536
operator|/
name|lut_size
operator|)
return|;
block|}
break|break;
block|}
block|{
name|unsigned
name|subrange
init|=
name|value
operator|>>
name|shiftval
decl_stmt|;
name|unsigned
name|remainder
init|=
name|value
operator|&
operator|(
name|lut_size
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|below
init|=
name|lut
index|[
name|subrange
index|]
decl_stmt|;
name|unsigned
name|above
decl_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
return|return
name|below
return|;
if|if
condition|(
name|subrange
operator|==
operator|(
name|lut_size
operator|-
literal|1
operator|)
condition|)
name|above
operator|=
literal|65535
expr_stmt|;
else|else
name|above
operator|=
name|lut
index|[
name|subrange
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|above
operator|==
name|below
condition|)
return|return
name|above
return|;
else|else
return|return
name|below
operator|+
operator|(
operator|(
operator|(
name|above
operator|-
name|below
operator|)
operator|*
name|remainder
operator|)
operator|>>
operator|(
literal|16
operator|-
name|shiftval
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'gray_to_gray()' - Convert grayscale image data to grayscale (brightness  *                    adjusted).  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gray_to_gray (unsigned char * grayin,unsigned short * grayout,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|gray_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|grayin
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|grayout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in grayin */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (unused) */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
comment|/* 	 * No alpha in image... 	 */
operator|*
name|grayout
operator|=
name|vars
operator|->
name|lut
operator|->
name|composite
index|[
name|grayin
index|[
literal|0
index|]
index|]
expr_stmt|;
else|else
operator|*
name|grayout
operator|=
name|vars
operator|->
name|lut
operator|->
name|composite
index|[
name|grayin
index|[
literal|0
index|]
operator|*
name|grayin
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|grayin
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
operator|&&
name|vars
operator|->
name|image_type
operator|!=
name|IMAGE_MONOCHROME
condition|)
block|{
name|float
name|t
init|=
operator|(
operator|(
name|float
operator|)
operator|*
name|grayout
operator|)
operator|/
literal|65536.0
decl_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
operator|*
name|grayout
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
name|grayin
operator|+=
name|bpp
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'indexed_to_gray()' - Convert indexed image data to grayscale.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|indexed_to_gray (unsigned char * indexed,unsigned short * gray,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|indexed_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - bpp in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|gray_cmap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Grayscale colormap */
comment|/* Really should precompute this silly thing... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
operator|,
name|cmap
operator|+=
literal|3
control|)
name|gray_cmap
index|[
name|i
index|]
operator|=
operator|(
name|cmap
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|cmap
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|cmap
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
expr_stmt|;
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
comment|/* 	 * No alpha in image... 	 */
operator|*
name|gray
operator|=
name|vars
operator|->
name|lut
operator|->
name|composite
index|[
name|gray_cmap
index|[
operator|*
name|indexed
index|]
index|]
expr_stmt|;
else|else
operator|*
name|gray
operator|=
name|vars
operator|->
name|lut
operator|->
name|composite
index|[
name|gray_cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
operator|&&
name|vars
operator|->
name|image_type
operator|!=
name|IMAGE_MONOCHROME
condition|)
block|{
name|float
name|t
init|=
operator|(
operator|(
name|float
operator|)
operator|*
name|gray
operator|)
operator|/
literal|65536.0
decl_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
operator|*
name|gray
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_gray()' - Convert RGB image data to grayscale.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|rgb_to_gray (unsigned char * rgb,unsigned short * gray,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|rgb_to_gray
parameter_list|(
name|unsigned
name|char
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in RGB */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (unused) */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
comment|/* 	 * No alpha in image... 	 */
operator|*
name|gray
operator|=
name|vars
operator|->
name|lut
operator|->
name|composite
index|[
operator|(
name|rgb
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|rgb
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|rgb
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
index|]
expr_stmt|;
else|else
operator|*
name|gray
operator|=
name|vars
operator|->
name|lut
operator|->
name|composite
index|[
operator|(
operator|(
name|rgb
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|rgb
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|rgb
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|*
name|rgb
index|[
literal|3
index|]
operator|/
literal|25500
operator|+
literal|255
operator|-
name|rgb
index|[
literal|3
index|]
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
operator|&&
name|vars
operator|->
name|image_type
operator|!=
name|IMAGE_MONOCHROME
condition|)
block|{
name|float
name|t
init|=
operator|(
operator|(
name|float
operator|)
operator|*
name|gray
operator|)
operator|/
literal|65536.0
decl_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
operator|*
name|gray
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|+=
name|bpp
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_rgb()' - Convert rgb image data to RGB.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|rgb_to_rgb (unsigned char * rgbin,unsigned short * rgbout,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|rgb_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|rgbin
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|rgbout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes/pix in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
name|unsigned
name|ld
init|=
name|vars
operator|->
name|density
operator|*
literal|65536
decl_stmt|;
name|double
name|isat
init|=
literal|1.0
decl_stmt|;
name|double
name|ssat
init|=
name|sqrt
argument_list|(
name|vars
operator|->
name|saturation
operator|*
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ssat
operator|>
literal|1
condition|)
name|isat
operator|=
literal|1.0
operator|/
name|ssat
expr_stmt|;
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|1
case|:
comment|/* 	   * No alpha in image, using colormap... 	   */
name|rgbout
index|[
literal|0
index|]
operator|=
name|cmap
index|[
operator|*
name|rgbin
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|cmap
index|[
operator|*
name|rgbin
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|cmap
index|[
operator|*
name|rgbin
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
literal|257
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rgbout
index|[
literal|0
index|]
operator|=
operator|(
name|cmap
index|[
name|rgbin
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|rgbin
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|1
index|]
operator|)
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
operator|(
name|cmap
index|[
name|rgbin
index|[
literal|1
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|rgbin
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|1
index|]
operator|)
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
operator|(
name|cmap
index|[
name|rgbin
index|[
literal|2
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|rgbin
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|1
index|]
operator|)
operator|*
literal|257
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 	   * No alpha in image... 	   */
name|rgbout
index|[
literal|0
index|]
operator|=
name|rgbin
index|[
literal|0
index|]
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|rgbin
index|[
literal|1
index|]
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|rgbin
index|[
literal|2
index|]
operator|*
literal|257
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|rgbout
index|[
literal|0
index|]
operator|=
operator|(
name|rgbin
index|[
literal|0
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
operator|)
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
operator|(
name|rgbin
index|[
literal|1
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
operator|)
operator|*
literal|257
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
operator|(
name|rgbin
index|[
literal|2
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
operator|)
operator|*
literal|257
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ssat
operator|!=
literal|1.0
condition|)
block|{
name|rgbout
index|[
literal|0
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|0
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|1
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|2
index|]
expr_stmt|;
name|calc_rgb_to_hsl
argument_list|(
name|rgbout
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssat
operator|<
literal|1
condition|)
name|s
operator|*=
name|ssat
expr_stmt|;
else|else
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
name|isat
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|1
condition|)
name|s
operator|=
literal|1.0
expr_stmt|;
name|calc_hsl_to_rgb
argument_list|(
name|rgbout
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|0
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|0
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|1
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|2
index|]
expr_stmt|;
block|}
name|update_cmyk
argument_list|(
name|rgbout
argument_list|)
expr_stmt|;
comment|/* Fiddle with the INPUT */
name|rgbout
index|[
literal|0
index|]
operator|=
name|lookup_value
argument_list|(
name|rgbout
index|[
literal|0
index|]
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|steps
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|red
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|lookup_value
argument_list|(
name|rgbout
index|[
literal|1
index|]
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|steps
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|green
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|lookup_value
argument_list|(
name|rgbout
index|[
literal|2
index|]
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|steps
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssat
operator|!=
literal|1.0
condition|)
block|{
name|rgbout
index|[
literal|0
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|0
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|1
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|2
index|]
expr_stmt|;
name|calc_rgb_to_hsl
argument_list|(
name|rgbout
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssat
operator|<
literal|1
condition|)
name|s
operator|*=
name|ssat
expr_stmt|;
else|else
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
name|isat
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|1
condition|)
name|s
operator|=
literal|1.0
expr_stmt|;
name|calc_hsl_to_rgb
argument_list|(
name|rgbout
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|0
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|0
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|1
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
literal|65535
operator|-
name|rgbout
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|<
literal|65536
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|t
init|=
name|rgbout
index|[
name|i
index|]
decl_stmt|;
name|t
operator|=
literal|65535
operator|-
operator|(
literal|65535
operator|-
name|t
operator|)
operator|*
name|ld
operator|/
literal|65536
expr_stmt|;
name|rgbout
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|t
expr_stmt|;
block|}
block|}
name|rgbin
operator|+=
name|bpp
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|indexed_to_rgb (unsigned char * indexed,unsigned short * rgb,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|indexed_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
name|rgb_to_rgb
argument_list|(
name|indexed
argument_list|,
name|rgb
argument_list|,
name|width
argument_list|,
name|bpp
argument_list|,
name|cmap
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'gray_to_rgb()' - Convert gray image data to RGB.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|gray_to_rgb (unsigned char * grayin,unsigned short * rgbout,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|gray_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|grayin
parameter_list|,
comment|/* I - grayscale pixels */
name|unsigned
name|short
modifier|*
name|rgbout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes/pix in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|unsigned
name|short
name|trgb
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/* 	   * No alpha in image... 	   */
name|trgb
index|[
literal|0
index|]
operator|=
name|grayin
index|[
literal|0
index|]
operator|*
literal|257
expr_stmt|;
name|trgb
index|[
literal|1
index|]
operator|=
name|grayin
index|[
literal|0
index|]
operator|*
literal|257
expr_stmt|;
name|trgb
index|[
literal|2
index|]
operator|=
name|grayin
index|[
literal|0
index|]
operator|*
literal|257
expr_stmt|;
block|}
else|else
block|{
name|int
name|lookup
init|=
operator|(
name|grayin
index|[
literal|0
index|]
operator|*
name|grayin
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|grayin
index|[
literal|1
index|]
operator|)
operator|*
literal|257
decl_stmt|;
name|trgb
index|[
literal|0
index|]
operator|=
name|lookup
expr_stmt|;
name|trgb
index|[
literal|1
index|]
operator|=
name|lookup
expr_stmt|;
name|trgb
index|[
literal|2
index|]
operator|=
name|lookup
expr_stmt|;
block|}
name|update_cmyk
argument_list|(
name|trgb
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|0
index|]
operator|=
name|lookup_value
argument_list|(
name|trgb
index|[
literal|0
index|]
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|steps
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|red
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|lookup_value
argument_list|(
name|trgb
index|[
literal|1
index|]
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|steps
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|green
argument_list|)
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|lookup_value
argument_list|(
name|trgb
index|[
literal|2
index|]
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|steps
argument_list|,
name|vars
operator|->
name|lut
operator|->
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
condition|)
block|{
name|float
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|float
operator|)
name|rgbout
index|[
name|i
index|]
operator|)
operator|/
literal|65536.0
expr_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
name|rgbout
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
block|}
name|grayin
operator|+=
name|bpp
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|fast_indexed_to_rgb (unsigned char * indexed,unsigned short * rgb,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|fast_indexed_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|unsigned
name|short
modifier|*
name|rgb
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
name|double
name|isat
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|>
literal|1
condition|)
name|isat
operator|=
literal|1.0
operator|/
name|vars
operator|->
name|saturation
expr_stmt|;
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/* 	   * No alpha in image... 	   */
name|rgb
index|[
literal|0
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|red
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|0
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|green
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|blue
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|2
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
name|rgb
index|[
literal|0
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|red
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|green
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|blue
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
condition|)
block|{
name|calc_rgb_to_hsl
argument_list|(
name|rgb
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|<
literal|1
condition|)
name|s
operator|*=
name|vars
operator|->
name|saturation
expr_stmt|;
else|else
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
name|isat
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|1
condition|)
name|s
operator|=
literal|1.0
expr_stmt|;
name|calc_hsl_to_rgb
argument_list|(
name|rgb
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
condition|)
block|{
name|float
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|float
operator|)
name|rgb
index|[
name|i
index|]
operator|)
operator|/
literal|65536.0
expr_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
name|rgb
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
block|}
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_rgb()' - Convert rgb image data to RGB.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|fast_rgb_to_rgb (unsigned char * rgbin,unsigned short * rgbout,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|fast_rgb_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|rgbin
parameter_list|,
comment|/* I - RGB pixels */
name|unsigned
name|short
modifier|*
name|rgbout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes/pix in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
name|unsigned
name|ld
init|=
name|vars
operator|->
name|density
operator|*
literal|65536
decl_stmt|;
name|double
name|isat
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|>
literal|1
condition|)
name|isat
operator|=
literal|1.0
operator|/
name|vars
operator|->
name|saturation
expr_stmt|;
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|double
name|h
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
block|{
comment|/* 	   * No alpha in image... 	   */
name|rgbout
index|[
literal|0
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|red
index|[
name|rgbin
index|[
literal|0
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|green
index|[
name|rgbin
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|blue
index|[
name|rgbin
index|[
literal|2
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
name|rgbout
index|[
literal|0
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|red
index|[
name|rgbin
index|[
literal|0
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|green
index|[
name|rgbin
index|[
literal|1
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|blue
index|[
name|rgbin
index|[
literal|2
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|saturation
operator|!=
literal|1.0
condition|)
block|{
name|calc_rgb_to_hsl
argument_list|(
name|rgbout
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|saturation
operator|<
literal|1
condition|)
name|s
operator|*=
name|vars
operator|->
name|saturation
expr_stmt|;
else|else
name|s
operator|=
name|pow
argument_list|(
name|s
argument_list|,
name|isat
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|1
condition|)
name|s
operator|=
literal|1.0
expr_stmt|;
name|calc_hsl_to_rgb
argument_list|(
name|rgbout
argument_list|,
name|h
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|<
literal|65536
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|t
init|=
name|rgbout
index|[
name|i
index|]
decl_stmt|;
name|t
operator|=
literal|65535
operator|-
operator|(
literal|65535
operator|-
name|t
operator|)
operator|*
name|ld
operator|/
literal|65536
expr_stmt|;
name|rgbout
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|t
expr_stmt|;
block|}
block|}
name|rgbin
operator|+=
name|bpp
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'gray_to_rgb()' - Convert gray image data to RGB.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|fast_gray_to_rgb (unsigned char * grayin,unsigned short * rgbout,int width,int bpp,unsigned char * cmap,const vars_t * vars)
name|fast_gray_to_rgb
parameter_list|(
name|unsigned
name|char
modifier|*
name|grayin
parameter_list|,
comment|/* I - grayscale pixels */
name|unsigned
name|short
modifier|*
name|rgbout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes/pix in indexed */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap */
specifier|const
name|vars_t
modifier|*
name|vars
parameter_list|)
block|{
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/* 	   * No alpha in image... 	   */
name|rgbout
index|[
literal|0
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|red
index|[
name|grayin
index|[
literal|0
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|green
index|[
name|grayin
index|[
literal|0
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|blue
index|[
name|grayin
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|lookup
init|=
operator|(
name|grayin
index|[
literal|0
index|]
operator|*
name|grayin
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|grayin
index|[
literal|1
index|]
operator|)
decl_stmt|;
name|rgbout
index|[
literal|0
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|red
index|[
name|lookup
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|green
index|[
name|lookup
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|vars
operator|->
name|lut
operator|->
name|blue
index|[
name|lookup
index|]
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|density
operator|!=
literal|1.0
condition|)
block|{
name|float
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|float
operator|)
name|rgbout
index|[
name|i
index|]
operator|)
operator|/
literal|65536.0
expr_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|+
operator|(
operator|(
name|t
operator|-
literal|1.0
operator|)
operator|*
name|vars
operator|->
name|density
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0.0
condition|)
name|t
operator|=
literal|0.0
expr_stmt|;
name|rgbout
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|t
operator|*
literal|65536.0
argument_list|)
expr_stmt|;
block|}
block|}
name|grayin
operator|+=
name|bpp
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|merge_printvars (vars_t * user,const vars_t * print)
name|merge_printvars
parameter_list|(
name|vars_t
modifier|*
name|user
parameter_list|,
specifier|const
name|vars_t
modifier|*
name|print
parameter_list|)
block|{
name|user
operator|->
name|red
operator|=
operator|(
name|user
operator|->
name|red
operator|*
name|print
operator|->
name|red
operator|)
operator|/
literal|100.0
expr_stmt|;
name|user
operator|->
name|green
operator|=
operator|(
name|user
operator|->
name|green
operator|*
name|print
operator|->
name|green
operator|)
operator|/
literal|100.0
expr_stmt|;
name|user
operator|->
name|blue
operator|=
operator|(
name|user
operator|->
name|blue
operator|*
name|print
operator|->
name|blue
operator|)
operator|/
literal|100.0
expr_stmt|;
name|user
operator|->
name|contrast
operator|=
operator|(
name|user
operator|->
name|contrast
operator|*
name|print
operator|->
name|contrast
operator|)
operator|/
literal|100.0
expr_stmt|;
name|user
operator|->
name|brightness
operator|=
operator|(
name|user
operator|->
name|brightness
operator|*
name|print
operator|->
name|brightness
operator|)
operator|/
literal|100.0
expr_stmt|;
name|user
operator|->
name|gamma
operator|/=
name|print
operator|->
name|gamma
expr_stmt|;
name|user
operator|->
name|saturation
operator|*=
name|print
operator|->
name|saturation
expr_stmt|;
name|user
operator|->
name|density
operator|*=
name|print
operator|->
name|density
expr_stmt|;
comment|/* Application gamma comes from the user variables */
block|}
end_function

begin_function
specifier|static
name|lut_t
modifier|*
DECL|function|allocate_lut (size_t steps)
name|allocate_lut
parameter_list|(
name|size_t
name|steps
parameter_list|)
block|{
name|lut_t
modifier|*
name|ret
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lut_t
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|->
name|steps
operator|=
name|steps
expr_stmt|;
name|ret
operator|->
name|composite
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
name|steps
argument_list|)
expr_stmt|;
name|ret
operator|->
name|red
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
name|steps
argument_list|)
expr_stmt|;
name|ret
operator|->
name|green
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
name|steps
argument_list|)
expr_stmt|;
name|ret
operator|->
name|blue
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
name|steps
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
DECL|function|free_lut (vars_t * v)
name|free_lut
parameter_list|(
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|->
name|lut
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|lut
operator|->
name|composite
condition|)
name|free
argument_list|(
name|v
operator|->
name|lut
operator|->
name|composite
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|lut
operator|->
name|red
condition|)
name|free
argument_list|(
name|v
operator|->
name|lut
operator|->
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|lut
operator|->
name|green
condition|)
name|free
argument_list|(
name|v
operator|->
name|lut
operator|->
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|lut
operator|->
name|blue
condition|)
name|free
argument_list|(
name|v
operator|->
name|lut
operator|->
name|blue
argument_list|)
expr_stmt|;
name|v
operator|->
name|lut
operator|->
name|steps
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|lut
operator|->
name|composite
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|lut
operator|->
name|red
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|lut
operator|->
name|green
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|lut
operator|->
name|blue
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|v
operator|->
name|lut
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|lut
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* #define PRINT_LUT */
end_comment

begin_function
name|void
DECL|function|compute_lut (size_t steps,vars_t * uv)
name|compute_lut
parameter_list|(
name|size_t
name|steps
parameter_list|,
name|vars_t
modifier|*
name|uv
parameter_list|)
block|{
name|float
name|pixel
decl_stmt|,
comment|/* Pixel value */
name|red_pixel
decl_stmt|,
comment|/* Pixel value */
name|green_pixel
decl_stmt|,
comment|/* Pixel value */
name|blue_pixel
decl_stmt|;
comment|/* Pixel value */
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PRINT_LUT
name|FILE
modifier|*
name|ltfile
init|=
name|fopen
argument_list|(
literal|"/mnt1/lut"
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/*    * Got an output file/command, now compute a brightness lookup table...    */
name|float
name|red
init|=
literal|100.0
operator|/
name|uv
operator|->
name|red
decl_stmt|;
name|float
name|green
init|=
literal|100.0
operator|/
name|uv
operator|->
name|green
decl_stmt|;
name|float
name|blue
init|=
literal|100.0
operator|/
name|uv
operator|->
name|blue
decl_stmt|;
name|float
name|print_gamma
init|=
name|uv
operator|->
name|gamma
decl_stmt|;
name|float
name|contrast
init|=
name|uv
operator|->
name|contrast
operator|/
literal|100.0
decl_stmt|;
name|float
name|app_gamma
init|=
name|uv
operator|->
name|app_gamma
decl_stmt|;
name|float
name|brightness
init|=
literal|100.0
operator|/
name|uv
operator|->
name|brightness
decl_stmt|;
name|float
name|screen_gamma
init|=
name|app_gamma
operator|*
name|brightness
operator|/
literal|1.7
decl_stmt|;
if|if
condition|(
name|red
operator|<
literal|0.01
condition|)
name|red
operator|=
literal|0.01
expr_stmt|;
if|if
condition|(
name|green
operator|<
literal|0.01
condition|)
name|green
operator|=
literal|0.01
expr_stmt|;
if|if
condition|(
name|blue
operator|<
literal|0.01
condition|)
name|blue
operator|=
literal|0.01
expr_stmt|;
name|uv
operator|->
name|lut
operator|=
name|allocate_lut
argument_list|(
name|steps
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|steps
condition|;
name|i
operator|++
control|)
block|{
name|float
name|temp_pixel
decl_stmt|;
name|float
name|fsteps
init|=
name|steps
decl_stmt|;
name|pixel
operator|=
operator|(
name|float
operator|)
name|i
operator|/
call|(
name|float
call|)
argument_list|(
name|steps
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*        * First, correct contrast        */
if|if
condition|(
name|pixel
operator|>=
literal|.5
condition|)
name|temp_pixel
operator|=
literal|1.0
operator|-
name|pixel
expr_stmt|;
else|else
name|temp_pixel
operator|=
name|pixel
expr_stmt|;
if|if
condition|(
name|contrast
operator|>=
literal|1
condition|)
name|temp_pixel
operator|=
literal|.5
operator|*
name|pow
argument_list|(
literal|2
operator|*
name|temp_pixel
argument_list|,
literal|1.0
operator|/
name|contrast
argument_list|)
expr_stmt|;
else|else
name|temp_pixel
operator|=
name|temp_pixel
operator|*
name|contrast
expr_stmt|;
if|if
condition|(
name|pixel
operator|<
literal|.5
condition|)
name|pixel
operator|=
name|temp_pixel
expr_stmt|;
else|else
name|pixel
operator|=
literal|1
operator|-
name|temp_pixel
expr_stmt|;
comment|/*        * Second, perform screen gamma correction        */
name|pixel
operator|=
literal|1.0
operator|-
name|pow
argument_list|(
name|pixel
argument_list|,
name|screen_gamma
argument_list|)
expr_stmt|;
comment|/*        * Third, fix up red, green, blue values        *        * I don't know how to do this correctly.  I think that what I'll do        * is if the correction is less than 1 to multiply it by the        * correction; if it's greater than 1, hinge it around 64K.        * Doubtless we can do better.  Oh well.        */
if|if
condition|(
name|pixel
operator|<
literal|0.0
condition|)
name|pixel
operator|=
literal|0.0
expr_stmt|;
elseif|else
if|if
condition|(
name|pixel
operator|>
literal|1.0
condition|)
name|pixel
operator|=
literal|1.0
expr_stmt|;
name|red_pixel
operator|=
name|pow
argument_list|(
name|pixel
argument_list|,
literal|1.0
operator|/
operator|(
name|red
operator|*
name|red
operator|)
argument_list|)
expr_stmt|;
name|green_pixel
operator|=
name|pow
argument_list|(
name|pixel
argument_list|,
literal|1.0
operator|/
operator|(
name|green
operator|*
name|green
operator|)
argument_list|)
expr_stmt|;
name|blue_pixel
operator|=
name|pow
argument_list|(
name|pixel
argument_list|,
literal|1.0
operator|/
operator|(
name|blue
operator|*
name|blue
operator|)
argument_list|)
expr_stmt|;
comment|/*        * Finally, fix up print gamma and scale        */
name|pixel
operator|=
name|fsteps
operator|*
operator|(
name|fsteps
operator|-
name|fsteps
operator|*
name|pow
argument_list|(
name|pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
name|red_pixel
operator|=
name|fsteps
operator|*
operator|(
name|fsteps
operator|-
name|fsteps
operator|*
name|pow
argument_list|(
name|red_pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
name|green_pixel
operator|=
name|fsteps
operator|*
operator|(
name|fsteps
operator|-
name|fsteps
operator|*
name|pow
argument_list|(
name|green_pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
name|blue_pixel
operator|=
name|fsteps
operator|*
operator|(
name|fsteps
operator|-
name|fsteps
operator|*
name|pow
argument_list|(
name|blue_pixel
argument_list|,
name|print_gamma
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pixel
operator|<=
literal|0.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pixel
operator|>=
literal|65535.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
else|else
name|uv
operator|->
name|lut
operator|->
name|composite
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|red_pixel
operator|<=
literal|0.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|red_pixel
operator|>=
literal|65535.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
else|else
name|uv
operator|->
name|lut
operator|->
name|red
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|red_pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|green_pixel
operator|<=
literal|0.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|green_pixel
operator|>=
literal|65535.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
else|else
name|uv
operator|->
name|lut
operator|->
name|green
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|green_pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|blue_pixel
operator|<=
literal|0.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|blue_pixel
operator|>=
literal|65535.0
condition|)
name|uv
operator|->
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
literal|65535
expr_stmt|;
else|else
name|uv
operator|->
name|lut
operator|->
name|blue
index|[
name|i
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|blue_pixel
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_LUT
name|fprintf
argument_list|(
name|ltfile
argument_list|,
literal|"%3i  %5d  %5d  %5d  %5d  %f %f %f %f  %f %f %f  %f\n"
argument_list|,
name|i
argument_list|,
name|uv
operator|->
name|lut
operator|->
name|composite
index|[
name|i
index|]
argument_list|,
name|uv
operator|->
name|lut
operator|->
name|red
index|[
name|i
index|]
argument_list|,
name|uv
operator|->
name|lut
operator|->
name|green
index|[
name|i
index|]
argument_list|,
name|uv
operator|->
name|lut
operator|->
name|blue
index|[
name|i
index|]
argument_list|,
name|pixel
argument_list|,
name|red_pixel
argument_list|,
name|green_pixel
argument_list|,
name|blue_pixel
argument_list|,
name|print_gamma
argument_list|,
name|screen_gamma
argument_list|,
name|print_gamma
argument_list|,
name|app_gamma
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PRINT_LUT
name|fclose
argument_list|(
name|ltfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * 'default_media_size()' - Return the size of a default page size.  */
end_comment

begin_comment
comment|/*  * Sizes are converted to 1/72in, then rounded down so that we don't  * print off the edge of the paper.  */
end_comment

begin_decl_stmt
DECL|variable|paper_sizes
specifier|const
specifier|static
name|papersize_t
name|paper_sizes
index|[]
init|=
block|{
comment|/* Common imperial page sizes */
block|{
literal|"Postcard"
block|,
literal|283
block|,
literal|416
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* 100mm x 147mm */
block|{
literal|"4x6"
block|,
literal|288
block|,
literal|432
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"5x7"
block|,
literal|360
block|,
literal|504
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"5x8"
block|,
literal|360
block|,
literal|576
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"6x8"
block|,
literal|432
block|,
literal|576
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"8x10"
block|,
literal|576
block|,
literal|720
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"Manual"
block|,
literal|396
block|,
literal|612
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* 5.5in x 8.5in */
block|{
literal|"Letter"
block|,
literal|612
block|,
literal|792
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* 8.5in x 11in */
block|{
literal|"Legal"
block|,
literal|612
block|,
literal|1008
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* 8.5in x 14in */
block|{
literal|"Tabloid"
block|,
literal|792
block|,
literal|1224
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/*  11in x 17in */
block|{
literal|"12x18"
block|,
literal|864
block|,
literal|1296
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"13x19"
block|,
literal|936
block|,
literal|1368
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* Other common photographic paper sizes */
block|{
literal|"8x12"
block|,
literal|576
block|,
literal|864
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* Sometimes used for 35 mm */
block|{
literal|"11x14"
block|,
literal|792
block|,
literal|1008
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"16x20"
block|,
literal|1152
block|,
literal|1440
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"16x24"
block|,
literal|1152
block|,
literal|1728
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* 20x24 for 35 mm */
block|{
literal|"20x24"
block|,
literal|1440
block|,
literal|1728
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"20x30"
block|,
literal|1440
block|,
literal|2160
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* 24x30 for 35 mm */
block|{
literal|"24x30"
block|,
literal|1728
block|,
literal|2160
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
block|{
literal|"24x36"
block|,
literal|1728
block|,
literal|2592
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* Sometimes used for 35 mm */
block|{
literal|"30x40"
block|,
literal|2160
block|,
literal|2880
block|,
name|PAPERSIZE_ENGLISH
block|}
block|,
comment|/* International Paper Sizes (mostly taken from BS4000:1968) */
comment|/*    * "A" series: Paper and boards, trimmed sizes    *    * "A" sizes are in the ratio 1 : sqrt(2).  A0 has a total area    * of 1 square metre.  Everything is rounded to the nearest    * millimetre.  Thus, A0 is 841mm x 1189mm.  Every other A    * size is obtained by doubling or halving another A size.    */
block|{
literal|"4A"
block|,
literal|4767
block|,
literal|6740
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 1682mm x 2378mm */
block|{
literal|"2A"
block|,
literal|3370
block|,
literal|4767
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 1189mm x 1682mm */
block|{
literal|"A0"
block|,
literal|2383
block|,
literal|3370
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  841mm x 1189mm */
block|{
literal|"A1"
block|,
literal|1683
block|,
literal|2383
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  594mm x  841mm */
block|{
literal|"A2"
block|,
literal|1190
block|,
literal|1683
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  420mm x  594mm */
block|{
literal|"A3"
block|,
literal|841
block|,
literal|1190
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  297mm x  420mm */
block|{
literal|"A4"
block|,
literal|595
block|,
literal|841
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  210mm x  297mm */
block|{
literal|"A5"
block|,
literal|419
block|,
literal|595
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  148mm x  210mm */
block|{
literal|"A6"
block|,
literal|297
block|,
literal|419
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  105mm x  148mm */
block|{
literal|"A7"
block|,
literal|209
block|,
literal|297
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   74mm x  105mm */
block|{
literal|"A8"
block|,
literal|147
block|,
literal|209
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   52mm x   74mm */
block|{
literal|"A9"
block|,
literal|104
block|,
literal|147
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   37mm x   52mm */
block|{
literal|"A10"
block|,
literal|73
block|,
literal|104
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   26mm x   37mm */
comment|/*    * Stock sizes for normal trims.    * Allowance for trim is 3 millimetres.    */
block|{
literal|"RA0"
block|,
literal|2437
block|,
literal|3458
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  860mm x 1220mm */
block|{
literal|"RA1"
block|,
literal|1729
block|,
literal|2437
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  610mm x  860mm */
block|{
literal|"RA2"
block|,
literal|1218
block|,
literal|1729
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  430mm x  610mm */
block|{
literal|"RA3"
block|,
literal|864
block|,
literal|1218
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  305mm x  430mm */
block|{
literal|"RA4"
block|,
literal|609
block|,
literal|864
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  215mm x  305mm */
comment|/*    * Stock sizes for bled work or extra trims.    */
block|{
literal|"SRA0"
block|,
literal|2551
block|,
literal|3628
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  900mm x 1280mm */
block|{
literal|"SRA1"
block|,
literal|1814
block|,
literal|2551
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  640mm x  900mm */
block|{
literal|"SRA2"
block|,
literal|1275
block|,
literal|1814
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  450mm x  640mm */
block|{
literal|"SRA3"
block|,
literal|907
block|,
literal|1275
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  320mm x  450mm */
block|{
literal|"SRA4"
block|,
literal|637
block|,
literal|907
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  225mm x  320mm */
comment|/*    * "B" series: Posters, wall charts and similar items.    */
block|{
literal|"4B ISO"
block|,
literal|5669
block|,
literal|8016
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 2000mm x 2828mm */
block|{
literal|"2B ISO"
block|,
literal|4008
block|,
literal|5669
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 1414mm x 2000mm */
block|{
literal|"B0 ISO"
block|,
literal|2834
block|,
literal|4008
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 1000mm x 1414mm */
block|{
literal|"B1 ISO"
block|,
literal|2004
block|,
literal|2834
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  707mm x 1000mm */
block|{
literal|"B2 ISO"
block|,
literal|1417
block|,
literal|2004
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  500mm x  707mm */
block|{
literal|"B3 ISO"
block|,
literal|1000
block|,
literal|1417
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  353mm x  500mm */
block|{
literal|"B4 ISO"
block|,
literal|708
block|,
literal|1000
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  250mm x  353mm */
block|{
literal|"B5 ISO"
block|,
literal|498
block|,
literal|708
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  176mm x  250mm */
block|{
literal|"B6 ISO"
block|,
literal|354
block|,
literal|498
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  125mm x  176mm */
block|{
literal|"B7 ISO"
block|,
literal|249
block|,
literal|354
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   88mm x  125mm */
block|{
literal|"B8 ISO"
block|,
literal|175
block|,
literal|249
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   62mm x   88mm */
block|{
literal|"B9 ISO"
block|,
literal|124
block|,
literal|175
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   44mm x   62mm */
block|{
literal|"B10 ISO"
block|,
literal|87
block|,
literal|124
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   31mm x   44mm */
block|{
literal|"B0 JIS"
block|,
literal|2919
block|,
literal|4127
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B1 JIS"
block|,
literal|2063
block|,
literal|2919
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B2 JIS"
block|,
literal|1459
block|,
literal|2063
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B3 JIS"
block|,
literal|1029
block|,
literal|1459
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B4 JIS"
block|,
literal|727
block|,
literal|1029
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B5 JIS"
block|,
literal|518
block|,
literal|727
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B6 JIS"
block|,
literal|362
block|,
literal|518
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B7 JIS"
block|,
literal|257
block|,
literal|362
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B8 JIS"
block|,
literal|180
block|,
literal|257
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B9 JIS"
block|,
literal|127
block|,
literal|180
block|,
name|PAPERSIZE_METRIC
block|}
block|,
block|{
literal|"B10 JIS"
block|,
literal|90
block|,
literal|127
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*    * "C" series: Envelopes or folders suitable for A size stationery.    */
block|{
literal|"C0"
block|,
literal|2599
block|,
literal|3676
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  917mm x 1297mm */
block|{
literal|"C1"
block|,
literal|1836
block|,
literal|2599
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  648mm x  917mm */
block|{
literal|"C2"
block|,
literal|1298
block|,
literal|1836
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  458mm x  648mm */
block|{
literal|"C3"
block|,
literal|918
block|,
literal|1298
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  324mm x  458mm */
block|{
literal|"C4"
block|,
literal|649
block|,
literal|918
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  229mm x  324mm */
block|{
literal|"C5"
block|,
literal|459
block|,
literal|649
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  162mm x  229mm */
block|{
literal|"B6/C4"
block|,
literal|354
block|,
literal|918
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  125mm x  324mm */
block|{
literal|"C6"
block|,
literal|323
block|,
literal|459
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  114mm x  162mm */
block|{
literal|"DL"
block|,
literal|311
block|,
literal|623
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*  110mm x  220mm */
block|{
literal|"C7/6"
block|,
literal|229
block|,
literal|459
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   81mm x  162mm */
block|{
literal|"C7"
block|,
literal|229
block|,
literal|323
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   81mm x  114mm */
block|{
literal|"C8"
block|,
literal|161
block|,
literal|229
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   57mm x   81mm */
block|{
literal|"C9"
block|,
literal|113
block|,
literal|161
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   40mm x   57mm */
block|{
literal|"C10"
block|,
literal|79
block|,
literal|113
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/*   28mm x   40mm */
comment|/*    * Sizes for book production    * The BPIF and the Publishers Association jointly recommend ten    * standard metric sizes for case-bound titles as follows:    */
block|{
literal|"Crown Quarto"
block|,
literal|535
block|,
literal|697
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 189mm x 246mm */
block|{
literal|"Large Crown Quarto"
block|,
literal|569
block|,
literal|731
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 201mm x 258mm */
block|{
literal|"Demy Quarto"
block|,
literal|620
block|,
literal|782
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 219mm x 276mm */
block|{
literal|"Royal Quarto"
block|,
literal|671
block|,
literal|884
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 237mm x 312mm */
comment|/*{ "ISO A4",             595,  841, PAPERSIZE_METRIC },    210mm x 297mm */
block|{
literal|"Crown Octavo"
block|,
literal|348
block|,
literal|527
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 123mm x 186mm */
block|{
literal|"Large Crown Octavo"
block|,
literal|365
block|,
literal|561
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 129mm x 198mm */
block|{
literal|"Demy Octavo"
block|,
literal|391
block|,
literal|612
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 138mm x 216mm */
block|{
literal|"Royal Octavo"
block|,
literal|442
block|,
literal|663
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 156mm x 234mm */
comment|/*{ "ISO A5",             419,  595, PAPERSIZE_METRIC },    148mm x 210mm */
comment|/* Paperback sizes in common usage */
block|{
literal|"Small paperback"
block|,
literal|314
block|,
literal|504
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 111mm x 178mm */
block|{
literal|"Penguin small paperback"
block|,
literal|314
block|,
literal|513
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 111mm x 181mm */
block|{
literal|"Penguin large paperback"
block|,
literal|365
block|,
literal|561
block|,
name|PAPERSIZE_METRIC
block|}
block|,
comment|/* 129mm x 198mm */
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
name|PAPERSIZE_METRIC
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
DECL|function|known_papersizes (void)
name|known_papersizes
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|paper_sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|papersize_t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|papersize_t
modifier|*
DECL|function|get_papersizes (void)
name|get_papersizes
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|paper_sizes
return|;
block|}
end_function

begin_function
specifier|const
name|papersize_t
modifier|*
DECL|function|get_papersize_by_name (const char * name)
name|get_papersize_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|papersize_t
modifier|*
name|val
init|=
operator|&
operator|(
name|paper_sizes
index|[
literal|0
index|]
operator|)
decl_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|val
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|val
return|;
name|val
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|papersize_t
modifier|*
DECL|function|get_papersize_by_size (int l,int w)
name|get_papersize_by_size
parameter_list|(
name|int
name|l
parameter_list|,
name|int
name|w
parameter_list|)
block|{
specifier|const
name|papersize_t
modifier|*
name|val
init|=
operator|&
operator|(
name|paper_sizes
index|[
literal|0
index|]
operator|)
decl_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|val
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|->
name|width
operator|==
name|w
operator|&&
name|val
operator|->
name|length
operator|==
name|l
condition|)
return|return
name|val
return|;
name|val
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
DECL|function|default_media_size (const printer_t * printer,const vars_t * v,int * width,int * length)
name|default_media_size
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|printer
parameter_list|,
comment|/* I - Printer model (not used) */
specifier|const
name|vars_t
modifier|*
name|v
parameter_list|,
comment|/* I */
name|int
modifier|*
name|width
parameter_list|,
comment|/* O - Width in points */
name|int
modifier|*
name|length
parameter_list|)
comment|/* O - Length in points */
block|{
if|if
condition|(
name|v
operator|->
name|page_width
operator|>
literal|0
operator|&&
name|v
operator|->
name|page_height
operator|>
literal|0
condition|)
block|{
operator|*
name|width
operator|=
name|v
operator|->
name|page_width
expr_stmt|;
operator|*
name|length
operator|=
name|v
operator|->
name|page_height
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|papersize_t
modifier|*
name|papersize
init|=
name|get_papersize_by_name
argument_list|(
name|v
operator|->
name|media_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|papersize
condition|)
block|{
operator|*
name|width
operator|=
literal|1
expr_stmt|;
operator|*
name|length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|width
operator|=
name|papersize
operator|->
name|width
expr_stmt|;
operator|*
name|length
operator|=
name|papersize
operator|->
name|length
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The list of printers has been moved to printers.c  */
end_comment

begin_include
include|#
directive|include
file|"print-printers.c"
end_include

begin_function
name|int
DECL|function|known_printers (void)
name|known_printers
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|printer_count
return|;
block|}
end_function

begin_function
specifier|const
name|printer_t
modifier|*
DECL|function|get_printers (void)
name|get_printers
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|printers
return|;
block|}
end_function

begin_function
specifier|const
name|printer_t
modifier|*
DECL|function|get_printer_by_index (int idx)
name|get_printer_by_index
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
operator|&
operator|(
name|printers
index|[
name|idx
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|printer_t
modifier|*
DECL|function|get_printer_by_long_name (const char * long_name)
name|get_printer_by_long_name
parameter_list|(
specifier|const
name|char
modifier|*
name|long_name
parameter_list|)
block|{
specifier|const
name|printer_t
modifier|*
name|val
init|=
operator|&
operator|(
name|printers
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|known_printers
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
operator|->
name|long_name
argument_list|,
name|long_name
argument_list|)
condition|)
return|return
name|val
return|;
name|val
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|printer_t
modifier|*
DECL|function|get_printer_by_driver (const char * driver)
name|get_printer_by_driver
parameter_list|(
specifier|const
name|char
modifier|*
name|driver
parameter_list|)
block|{
specifier|const
name|printer_t
modifier|*
name|val
init|=
operator|&
operator|(
name|printers
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|known_printers
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
operator|->
name|driver
argument_list|,
name|driver
argument_list|)
condition|)
return|return
name|val
return|;
name|val
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
DECL|function|get_printer_index_by_driver (const char * driver)
name|get_printer_index_by_driver
parameter_list|(
specifier|const
name|char
modifier|*
name|driver
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
specifier|const
name|printer_t
modifier|*
name|val
init|=
operator|&
operator|(
name|printers
index|[
literal|0
index|]
operator|)
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|known_printers
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
operator|->
name|driver
argument_list|,
name|driver
argument_list|)
condition|)
return|return
name|idx
return|;
name|val
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
DECL|function|default_dither_algorithm (void)
name|default_dither_algorithm
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dither_algo_names
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|convert_t
DECL|function|choose_colorfunc (int output_type,int image_bpp,const unsigned char * cmap,int * out_bpp,const vars_t * v)
name|choose_colorfunc
parameter_list|(
name|int
name|output_type
parameter_list|,
name|int
name|image_bpp
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
name|int
modifier|*
name|out_bpp
parameter_list|,
specifier|const
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
block|{
operator|*
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|image_bpp
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|image_type
operator|==
name|IMAGE_CONTINUOUS
condition|)
return|return
name|rgb_to_rgb
return|;
else|else
return|return
name|fast_rgb_to_rgb
return|;
block|}
else|else
block|{
if|if
condition|(
name|v
operator|->
name|image_type
operator|==
name|IMAGE_CONTINUOUS
condition|)
return|return
name|indexed_to_rgb
return|;
else|else
return|return
name|fast_indexed_to_rgb
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY_COLOR
condition|)
block|{
operator|*
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|image_type
operator|==
name|IMAGE_CONTINUOUS
condition|)
return|return
name|gray_to_rgb
return|;
else|else
return|return
name|fast_gray_to_rgb
return|;
block|}
else|else
block|{
operator|*
name|out_bpp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|image_bpp
operator|>=
literal|3
condition|)
return|return
name|rgb_to_gray
return|;
elseif|else
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
return|return
name|gray_to_gray
return|;
else|else
return|return
name|indexed_to_gray
return|;
block|}
block|}
end_function

begin_function
name|void
DECL|function|compute_page_parameters (int page_right,int page_left,int page_top,int page_bottom,int scaling,int image_width,int image_height,Image image,int * orientation,int * page_width,int * page_height,int * out_width,int * out_height,int * left,int * top)
name|compute_page_parameters
parameter_list|(
name|int
name|page_right
parameter_list|,
comment|/* I */
name|int
name|page_left
parameter_list|,
comment|/* I */
name|int
name|page_top
parameter_list|,
comment|/* I */
name|int
name|page_bottom
parameter_list|,
comment|/* I */
name|int
name|scaling
parameter_list|,
comment|/* I */
name|int
name|image_width
parameter_list|,
comment|/* I */
name|int
name|image_height
parameter_list|,
comment|/* I */
name|Image
name|image
parameter_list|,
comment|/* IO */
name|int
modifier|*
name|orientation
parameter_list|,
comment|/* IO */
name|int
modifier|*
name|page_width
parameter_list|,
comment|/* O */
name|int
modifier|*
name|page_height
parameter_list|,
comment|/* O */
name|int
modifier|*
name|out_width
parameter_list|,
comment|/* O */
name|int
modifier|*
name|out_height
parameter_list|,
comment|/* O */
name|int
modifier|*
name|left
parameter_list|,
comment|/* O */
name|int
modifier|*
name|top
parameter_list|)
comment|/* O */
block|{
operator|*
name|page_width
operator|=
name|page_right
operator|-
name|page_left
expr_stmt|;
operator|*
name|page_height
operator|=
name|page_top
operator|-
name|page_bottom
expr_stmt|;
comment|/* In AUTO orientation, just orient the paper the same way as the image. */
if|if
condition|(
operator|*
name|orientation
operator|==
name|ORIENT_AUTO
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|page_width
operator|>=
operator|*
name|page_height
operator|&&
name|image_width
operator|>=
name|image_height
operator|)
operator|||
operator|(
operator|*
name|page_height
operator|>=
operator|*
name|page_width
operator|&&
name|image_height
operator|>=
name|image_width
operator|)
condition|)
operator|*
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
else|else
operator|*
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|orientation
operator|==
name|ORIENT_LANDSCAPE
condition|)
block|{
name|Image_rotate_ccw
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_width
operator|=
name|Image_width
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_height
operator|=
name|Image_height
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
comment|/*    * Calculate width/height...    */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*        * Scale to pixels per inch...        */
operator|*
name|out_width
operator|=
name|image_width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
operator|*
name|out_height
operator|=
name|image_height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*        * Scale by percent...        */
comment|/*        * Decide which orientation gives the proper fit        * If we ask for 50%, we do not want to exceed that        * in either dimension!        */
name|int
name|twidth0
init|=
operator|*
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
decl_stmt|;
name|int
name|theight0
init|=
name|twidth0
operator|*
name|image_height
operator|/
name|image_width
decl_stmt|;
name|int
name|theight1
init|=
operator|*
name|page_height
operator|*
name|scaling
operator|/
literal|100.0
decl_stmt|;
name|int
name|twidth1
init|=
name|theight1
operator|*
name|image_width
operator|/
name|image_height
decl_stmt|;
operator|*
name|out_width
operator|=
name|FMIN
argument_list|(
name|twidth0
argument_list|,
name|twidth1
argument_list|)
expr_stmt|;
operator|*
name|out_height
operator|=
name|FMIN
argument_list|(
name|theight0
argument_list|,
name|theight1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|out_height
operator|>
operator|*
name|page_height
condition|)
block|{
operator|*
name|out_height
operator|=
operator|*
name|page_height
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
operator|*
name|out_width
operator|=
operator|*
name|out_height
operator|*
name|image_width
operator|/
name|image_height
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|out_width
operator|==
literal|0
condition|)
operator|*
name|out_width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|out_height
operator|==
literal|0
condition|)
operator|*
name|out_height
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|orientation
operator|==
name|ORIENT_LANDSCAPE
condition|)
block|{
name|int
name|x
decl_stmt|;
comment|/*        * Swap left/top offsets...        */
name|x
operator|=
operator|*
name|left
expr_stmt|;
operator|*
name|left
operator|=
operator|*
name|top
expr_stmt|;
operator|*
name|top
operator|=
operator|*
name|page_height
operator|-
name|x
operator|-
operator|*
name|out_height
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|left
operator|<
literal|0
condition|)
operator|*
name|left
operator|=
operator|(
operator|*
name|page_width
operator|-
operator|*
name|out_width
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|top
operator|<
literal|0
condition|)
operator|*
name|top
operator|=
operator|(
operator|*
name|page_height
operator|-
operator|*
name|out_height
operator|)
operator|/
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|int
DECL|function|verify_printer_params (const printer_t * p,const vars_t * v)
name|verify_printer_params
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|p
parameter_list|,
specifier|const
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|vptr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|answer
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|v
operator|->
name|media_size
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vptr
operator|=
call|(
modifier|*
name|p
operator|->
name|parameters
call|)
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"PageSize"
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|media_size
argument_list|,
name|vptr
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|good_page_size
goto|;
name|answer
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a valid page size\n"
argument_list|,
name|v
operator|->
name|media_size
argument_list|)
expr_stmt|;
block|}
name|good_page_size
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|vptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|height
decl_stmt|,
name|width
decl_stmt|;
call|(
modifier|*
name|p
operator|->
name|limit
call|)
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "limit %d %d dims %d %d\n", width, height, 	      v->page_width, v->page_height);
endif|#
directive|endif
if|if
condition|(
name|v
operator|->
name|page_height
operator|<=
literal|0
operator|||
name|v
operator|->
name|page_height
operator|>
name|height
operator|||
name|v
operator|->
name|page_width
operator|<=
literal|0
operator|||
name|v
operator|->
name|page_width
operator|>
name|width
condition|)
block|{
name|answer
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Image size is not valid\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|v
operator|->
name|media_type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vptr
operator|=
call|(
modifier|*
name|p
operator|->
name|parameters
call|)
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"MediaType"
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|media_type
argument_list|,
name|vptr
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|good_media_type
goto|;
name|answer
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a valid media type\n"
argument_list|,
name|v
operator|->
name|media_type
argument_list|)
expr_stmt|;
block|}
name|good_media_type
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|vptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|v
operator|->
name|media_source
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vptr
operator|=
call|(
modifier|*
name|p
operator|->
name|parameters
call|)
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"InputSlot"
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|media_source
argument_list|,
name|vptr
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|good_media_source
goto|;
name|answer
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a valid media source\n"
argument_list|,
name|v
operator|->
name|media_source
argument_list|)
expr_stmt|;
block|}
name|good_media_source
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|vptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|v
operator|->
name|resolution
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vptr
operator|=
call|(
modifier|*
name|p
operator|->
name|parameters
call|)
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"Resolution"
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|resolution
argument_list|,
name|vptr
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|good_resolution
goto|;
name|answer
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a valid resolution\n"
argument_list|,
name|v
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
name|good_resolution
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|vptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|v
operator|->
name|ink_type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vptr
operator|=
call|(
modifier|*
name|p
operator|->
name|parameters
call|)
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"InkType"
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|ink_type
argument_list|,
name|vptr
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|good_ink_type
goto|;
name|answer
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a valid ink type\n"
argument_list|,
name|v
operator|->
name|ink_type
argument_list|)
expr_stmt|;
block|}
name|good_ink_type
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|vptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dither_algos
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
operator|->
name|dither_algorithm
argument_list|,
name|dither_algo_names
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|answer
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not a valid dither algorithm\n"
argument_list|,
name|v
operator|->
name|dither_algorithm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

