begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in driver utility functions for the GIMP.  *  *   Copyright 1997-1998 Michael Sweet (mike@easysw.com)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Contents:  *  *   dither_black()    - Dither grayscale pixels to black.  *   dither_cmyk()     - Dither RGB pixels to cyan, magenta, yellow, and black.  *   gray_to_gray()    - Convert grayscale image data to grayscale.  *   indexed_to_gray() - Convert indexed image data to grayscale.  *   indexed_to_rgb()  - Convert indexed image data to RGB.  *   media_width()     - Get the addressable width of the page.  *   media_height()    - Get the addressable height of the page.  *   rgb_to_gray()     - Convert RGB image data to grayscale.  *   rgb_to_rgb()      - Convert RGB image data to RGB.  *  * Revision History:  *  *   $Log$  *   Revision 1.6  1998/04/11 05:07:46  yosh  *   * app/app_procs.c: fixed up idle handler for file open (look like testgtk  *   idle demo)  *  *   * app/colomaps.c: fixup for visual test and use of gdk_color_alloc for some  *   fixed colors (from Owen Taylor)  *  *   * app/errors.h  *   * app/errors.c  *   * app/main.c  *   * libgimp/gimp.c: redid the signal handlers so we only get a debug prompt on  *   SIGSEGV, SIGBUS, and SIGFPE.  *  *   * applied gimp-jbuhler-980408-0 and gimp-joke-980409-0 (warning fixups)  *  *   * applied gimp-monnaux-980409-0 for configurable plugin path for multiarch  *   setups  *  *   -Yosh  *  *   Revision 1.5  1998/04/07 03:41:15  yosh  *   configure.in: fix for $srcdir != $builddir for data. Tightened check for  *   random() and add -lucb on systems that need it. Fix for xdelta.h check. Find  *   xemacs as well as emacs. Properly define settings for print plugin.  *  *   app/Makefile.am: ditch -DNDEBUG, since nothing uses it  *  *   flame: properly handle random() and friends  *  *   pnm: workaround for systems with old sprintfs  *  *   print, sgi: fold back in portability fixes  *  *   threshold_alpha: properly get params in non-interactive mode  *  *   bmp: updated and merged in  *  *   -Yosh  *  *   Revision 1.4  1998/04/01 22:14:47  neo  *   Added checks for print spoolers to configure.in as suggested by Michael  *   Sweet. The print plug-in still needs some changes to Makefile.am to make  *   make use of this.  *  *   Updated print and sgi plug-ins to version on the registry.  *  *  *   --Sven  *  *   Revision 1.11  1998/03/01  18:03:27  mike  *   Whoops - need to add 255 - alpha to the output values (transparent to white  *   and not transparent to black...)  *  *   Revision 1.10  1998/03/01  17:20:48  mike  *   Updated alpha code to do alpha computation before gamma/brightness lut.  *  *   Revision 1.9  1998/03/01  17:13:46  mike  *   Updated CMY/CMYK conversion code for dynamic BG and hue adjustment.  *   Added alpha channel support to color conversion functions.  *  *   Revision 1.8  1998/01/21  21:33:47  mike  *   Replaced Burkes dither with stochastic (random) dither.  *  *   Revision 1.7  1997/10/02  17:57:26  mike  *   Replaced ordered dither with Burkes dither (error-diffusion).  *   Now dither K separate from CMY.  *  *   Revision 1.6  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.5  1997/07/26  18:43:04  mike  *   Fixed dither_black and dither_cmyk - wasn't clearing extra bits  *   (caused problems with A3/A4 size output).  *  *   Revision 1.5  1997/07/26  18:43:04  mike  *   Fixed dither_black and dither_cmyk - wasn't clearing extra bits  *   (caused problems with A3/A4 size output).  *  *   Revision 1.4  1997/07/02  18:46:26  mike  *   Fixed stupid bug in dither_black() - wasn't comparing against gray  *   pixels (comparing against the first black byte - d'oh!)  *   Changed 255 in dither matrix to 254 to shade correctly.  *  *   Revision 1.4  1997/07/02  18:46:26  mike  *   Fixed stupid bug in dither_black() - wasn't comparing against gray  *   pixels (comparing against the first black byte - d'oh!)  *   Changed 255 in dither matrix to 254 to shade correctly.  *  *   Revision 1.3  1997/07/02  13:51:53  mike  *   Added rgb_to_rgb and gray_to_gray conversion functions.  *   Standardized calling args to conversion functions.  *  *   Revision 1.2  1997/07/01  19:28:44  mike  *   Updated dither matrix.  *   Fixed scaling bugs in dither_*() functions.  *  *   Revision 1.1  1997/06/19  02:18:15  mike  *   Initial revision  */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_comment
comment|/*  * RGB to grayscale luminance constants...  */
end_comment

begin_define
DECL|macro|LUM_RED
define|#
directive|define
name|LUM_RED
value|31
end_define

begin_define
DECL|macro|LUM_GREEN
define|#
directive|define
name|LUM_GREEN
value|61
end_define

begin_define
DECL|macro|LUM_BLUE
define|#
directive|define
name|LUM_BLUE
value|8
end_define

begin_comment
comment|/*  * Error buffer for dither functions.  This needs to be at least 11xMAXDPI  * (currently 720) to avoid problems...  */
end_comment

begin_decl_stmt
DECL|variable|error
name|int
name|error
index|[
literal|2
index|]
index|[
literal|4
index|]
index|[
literal|11
operator|*
literal|720
operator|+
literal|4
index|]
init|=
block|{
block|{
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'dither_black()' - Dither grayscale pixels to black.  */
end_comment

begin_function
name|void
DECL|function|dither_black (guchar * gray,int row,int src_width,int dst_width,unsigned char * black)
name|dither_black
parameter_list|(
name|guchar
modifier|*
name|gray
parameter_list|,
comment|/* I - Grayscale pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output row */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|k
decl_stmt|,
comment|/* Current black error */
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dithering bitmask */
name|xstep
operator|=
name|src_width
operator|/
name|dst_width
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
name|kerror1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|kerror1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherk
operator|=
operator|*
name|kerror0
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
name|k
operator|=
literal|255
operator|-
operator|*
name|gray
operator|+
name|ditherk
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|127
condition|)
block|{
operator|*
name|kptr
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
literal|255
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|kptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|gray
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|gray
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'dither_cmyk()' - Dither RGB pixels to cyan, magenta, yellow, and black.  */
end_comment

begin_function
name|void
DECL|function|dither_cmyk (guchar * rgb,int row,int src_width,int dst_width,unsigned char * cyan,unsigned char * magenta,unsigned char * yellow,unsigned char * black)
name|dither_cmyk
parameter_list|(
name|guchar
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|int
name|row
parameter_list|,
comment|/* I - Current Y coordinate */
name|int
name|src_width
parameter_list|,
comment|/* I - Width of input row */
name|int
name|dst_width
parameter_list|,
comment|/* I - Width of output rows */
name|unsigned
name|char
modifier|*
name|cyan
parameter_list|,
comment|/* O - Cyan bitmap pixels */
name|unsigned
name|char
modifier|*
name|magenta
parameter_list|,
comment|/* O - Magenta bitmap pixels */
name|unsigned
name|char
modifier|*
name|yellow
parameter_list|,
comment|/* O - Yellow bitmap pixels */
name|unsigned
name|char
modifier|*
name|black
parameter_list|)
comment|/* O - Black bitmap pixels */
block|{
name|int
name|x
decl_stmt|,
comment|/* Current X coordinate */
name|xerror
decl_stmt|,
comment|/* X error count */
name|xstep
decl_stmt|,
comment|/* X step */
name|xmod
decl_stmt|,
comment|/* X error modulus */
name|length
decl_stmt|;
comment|/* Length of output bitmap in bytes */
name|int
name|c
decl_stmt|,
name|m
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
comment|/* CMYK values */
name|divk
decl_stmt|,
comment|/* Inverse of K */
name|diff
decl_stmt|;
comment|/* Average color difference */
name|unsigned
name|char
name|bit
decl_stmt|,
comment|/* Current bit */
modifier|*
name|cptr
decl_stmt|,
comment|/* Current cyan pixel */
modifier|*
name|mptr
decl_stmt|,
comment|/* Current magenta pixel */
modifier|*
name|yptr
decl_stmt|,
comment|/* Current yellow pixel */
modifier|*
name|kptr
decl_stmt|;
comment|/* Current black pixel */
name|int
name|ditherc
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|cerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|cerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|dithery
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|yerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|yerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherm
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|merror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|merror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherk
decl_stmt|,
comment|/* Next error value in buffer */
modifier|*
name|kerror0
decl_stmt|,
comment|/* Pointer to current error row */
modifier|*
name|kerror1
decl_stmt|;
comment|/* Pointer to next error row */
name|int
name|ditherbit
decl_stmt|;
comment|/* Random dither bitmask */
name|xstep
operator|=
literal|3
operator|*
operator|(
name|src_width
operator|/
name|dst_width
operator|)
expr_stmt|;
name|xmod
operator|=
name|src_width
operator|%
name|dst_width
expr_stmt|;
name|length
operator|=
operator|(
name|dst_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
name|cerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
name|cerror1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cerror1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|merror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
name|merror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
name|merror1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|merror1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|yerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|2
index|]
operator|+
literal|2
expr_stmt|;
name|yerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|2
index|]
operator|+
literal|2
expr_stmt|;
name|yerror1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|yerror1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|kerror0
operator|=
name|error
index|[
name|row
operator|&
literal|1
index|]
index|[
literal|3
index|]
operator|+
literal|2
expr_stmt|;
name|kerror1
operator|=
name|error
index|[
literal|1
operator|-
operator|(
name|row
operator|&
literal|1
operator|)
index|]
index|[
literal|3
index|]
operator|+
literal|2
expr_stmt|;
name|kerror1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|kerror1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|cyan
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|magenta
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yellow
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|black
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|bit
operator|=
literal|128
operator|,
name|cptr
operator|=
name|cyan
operator|,
name|mptr
operator|=
name|magenta
operator|,
name|yptr
operator|=
name|yellow
operator|,
name|kptr
operator|=
name|black
operator|,
name|xerror
operator|=
literal|0
operator|,
name|ditherbit
operator|=
name|rand
argument_list|()
operator|,
name|ditherc
operator|=
name|cerror0
index|[
literal|0
index|]
operator|,
name|ditherm
operator|=
name|merror0
index|[
literal|0
index|]
operator|,
name|dithery
operator|=
name|yerror0
index|[
literal|0
index|]
operator|,
name|ditherk
operator|=
name|kerror0
index|[
literal|0
index|]
init|;
name|x
operator|<
name|dst_width
condition|;
name|x
operator|++
operator|,
name|cerror0
operator|++
operator|,
name|cerror1
operator|++
operator|,
name|merror0
operator|++
operator|,
name|merror1
operator|++
operator|,
name|yerror0
operator|++
operator|,
name|yerror1
operator|++
operator|,
name|kerror0
operator|++
operator|,
name|kerror1
operator|++
control|)
block|{
comment|/*     * First compute the standard CMYK separation color values...     */
name|c
operator|=
literal|255
operator|-
name|rgb
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|255
operator|-
name|rgb
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
literal|255
operator|-
name|rgb
index|[
literal|2
index|]
expr_stmt|;
name|k
operator|=
name|MIN
argument_list|(
name|c
argument_list|,
name|MIN
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
block|{
comment|/*       * Since we're printing black, adjust the black level based upon       * the amount of color in the pixel (colorful pixels get less black)...       */
name|diff
operator|=
literal|255
operator|-
operator|(
name|abs
argument_list|(
name|c
operator|-
name|m
argument_list|)
operator|+
name|abs
argument_list|(
name|c
operator|-
name|y
argument_list|)
operator|+
name|abs
argument_list|(
name|m
operator|-
name|y
argument_list|)
operator|)
operator|/
literal|3
expr_stmt|;
name|k
operator|=
name|diff
operator|*
name|k
operator|/
literal|255
expr_stmt|;
name|divk
operator|=
literal|255
operator|-
name|k
expr_stmt|;
if|if
condition|(
name|divk
operator|==
literal|0
condition|)
name|c
operator|=
name|m
operator|=
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Grayscale */
else|else
block|{
comment|/*         * Full color; update the CMY values for the black value and reduce         * CMY as necessary to give better blues, greens, and reds... :)         */
name|c
operator|=
operator|(
literal|255
operator|-
operator|(
name|rgb
index|[
literal|1
index|]
operator|+
name|rgb
index|[
literal|2
index|]
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|c
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|m
operator|=
operator|(
literal|255
operator|-
operator|(
name|rgb
index|[
literal|0
index|]
operator|+
name|rgb
index|[
literal|2
index|]
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|m
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
name|y
operator|=
operator|(
literal|255
operator|-
operator|(
name|rgb
index|[
literal|0
index|]
operator|+
name|rgb
index|[
literal|1
index|]
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|y
operator|-
name|k
operator|)
operator|/
name|divk
expr_stmt|;
block|}
empty_stmt|;
name|k
operator|+=
name|ditherk
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|127
condition|)
block|{
operator|*
name|kptr
operator||=
name|bit
expr_stmt|;
name|k
operator|-=
literal|255
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
name|k
expr_stmt|;
block|}
else|else
block|{
name|kerror1
index|[
literal|0
index|]
operator|=
name|k
expr_stmt|;
name|ditherk
operator|=
name|kerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
name|kptr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/*       * We're not printing black, but let's adjust the CMY levels to produce       * better reds, greens, and blues...       */
name|c
operator|=
operator|(
literal|255
operator|-
operator|(
name|rgb
index|[
literal|1
index|]
operator|+
name|rgb
index|[
literal|2
index|]
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|c
operator|-
name|k
operator|)
operator|/
literal|255
operator|+
name|k
expr_stmt|;
name|m
operator|=
operator|(
literal|255
operator|-
operator|(
name|rgb
index|[
literal|0
index|]
operator|+
name|rgb
index|[
literal|2
index|]
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|m
operator|-
name|k
operator|)
operator|/
literal|255
operator|+
name|k
expr_stmt|;
name|y
operator|=
operator|(
literal|255
operator|-
operator|(
name|rgb
index|[
literal|0
index|]
operator|+
name|rgb
index|[
literal|1
index|]
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|y
operator|-
name|k
operator|)
operator|/
literal|255
operator|+
name|k
expr_stmt|;
block|}
empty_stmt|;
name|c
operator|+=
name|ditherc
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
operator|*
name|cptr
operator||=
name|bit
expr_stmt|;
name|c
operator|-=
literal|255
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|cerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|c
expr_stmt|;
name|ditherc
operator|=
name|cerror0
index|[
literal|1
index|]
operator|+
name|c
expr_stmt|;
block|}
else|else
block|{
name|cerror1
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ditherc
operator|=
name|cerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|c
expr_stmt|;
block|}
empty_stmt|;
name|m
operator|+=
name|ditherm
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|127
condition|)
block|{
operator|*
name|mptr
operator||=
name|bit
expr_stmt|;
name|m
operator|-=
literal|255
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|merror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|m
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|1
index|]
operator|+
name|m
expr_stmt|;
block|}
else|else
block|{
name|merror1
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
name|ditherm
operator|=
name|merror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|m
expr_stmt|;
block|}
empty_stmt|;
name|y
operator|+=
name|dithery
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|127
condition|)
block|{
operator|*
name|yptr
operator||=
name|bit
expr_stmt|;
name|y
operator|-=
literal|255
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ditherbit
operator|&
name|bit
condition|)
block|{
name|yerror1
index|[
literal|0
index|]
operator|=
literal|3
operator|*
name|y
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|1
index|]
operator|+
name|y
expr_stmt|;
block|}
else|else
block|{
name|yerror1
index|[
literal|0
index|]
operator|=
name|y
expr_stmt|;
name|dithery
operator|=
name|yerror0
index|[
literal|1
index|]
operator|+
literal|3
operator|*
name|y
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
name|mptr
operator|++
expr_stmt|;
name|yptr
operator|++
expr_stmt|;
name|bit
operator|=
literal|128
expr_stmt|;
name|ditherbit
operator|=
name|rand
argument_list|()
expr_stmt|;
block|}
else|else
name|bit
operator|>>=
literal|1
expr_stmt|;
name|rgb
operator|+=
name|xstep
expr_stmt|;
name|xerror
operator|+=
name|xmod
expr_stmt|;
if|if
condition|(
name|xerror
operator|>=
name|dst_width
condition|)
block|{
name|xerror
operator|-=
name|dst_width
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'gray_to_gray()' - Convert grayscale image data to grayscale (brightness  *                    adjusted).  */
end_comment

begin_function
name|void
DECL|function|gray_to_gray (guchar * grayin,guchar * grayout,int width,int bpp,guchar * lut,guchar * cmap)
name|gray_to_gray
parameter_list|(
name|guchar
modifier|*
name|grayin
parameter_list|,
comment|/* I - RGB pixels */
name|guchar
modifier|*
name|grayout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in grayin */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|)
comment|/* I - Colormap (unused) */
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|grayout
operator|=
name|lut
index|[
operator|*
name|grayin
index|]
expr_stmt|;
name|grayin
operator|++
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/*     * Handle alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|grayout
operator|=
name|lut
index|[
name|grayin
index|[
literal|0
index|]
operator|*
name|grayin
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|grayin
index|[
literal|1
index|]
expr_stmt|;
name|grayin
operator|+=
name|bpp
expr_stmt|;
name|grayout
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'indexed_to_gray()' - Convert indexed image data to grayscale.  */
end_comment

begin_function
name|void
DECL|function|indexed_to_gray (guchar * indexed,guchar * gray,int width,int bpp,guchar * lut,guchar * cmap)
name|indexed_to_gray
parameter_list|(
name|guchar
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|guchar
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in indexed */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|)
comment|/* I - Colormap */
block|{
name|int
name|i
decl_stmt|;
comment|/* Looping var */
name|unsigned
name|char
name|gray_cmap
index|[
literal|256
index|]
decl_stmt|;
comment|/* Grayscale colormap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
operator|,
name|cmap
operator|+=
literal|3
control|)
name|gray_cmap
index|[
name|i
index|]
operator|=
operator|(
name|cmap
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|cmap
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|cmap
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
index|[
name|gray_cmap
index|[
operator|*
name|indexed
index|]
index|]
expr_stmt|;
name|indexed
operator|++
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/*     * Handle alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
index|[
name|gray_cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
index|]
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'indexed_to_rgb()' - Convert indexed image data to RGB.  */
end_comment

begin_function
name|void
DECL|function|indexed_to_rgb (guchar * indexed,guchar * rgb,int width,int bpp,guchar * lut,guchar * cmap)
name|indexed_to_rgb
parameter_list|(
name|guchar
modifier|*
name|indexed
parameter_list|,
comment|/* I - Indexed pixels */
name|guchar
modifier|*
name|rgb
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in indexed */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|)
comment|/* I - Colormap */
block|{
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|rgb
index|[
literal|0
index|]
operator|=
name|lut
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|0
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|lut
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|lut
index|[
name|cmap
index|[
operator|*
name|indexed
operator|*
literal|3
operator|+
literal|2
index|]
index|]
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
name|indexed
operator|++
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/*     * RGBA image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|rgb
index|[
literal|0
index|]
operator|=
name|lut
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|0
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
name|lut
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|1
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
name|lut
index|[
name|cmap
index|[
name|indexed
index|[
literal|0
index|]
operator|*
literal|3
operator|+
literal|2
index|]
operator|*
name|indexed
index|[
literal|1
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|indexed
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
name|indexed
operator|+=
name|bpp
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'media_width()' - Get the addressable width of the page.  *  * This function assumes a standard left/right margin of 0.25".  */
end_comment

begin_function
name|int
DECL|function|media_width (int media_size,int dpi)
name|media_width
parameter_list|(
name|int
name|media_size
parameter_list|,
comment|/* I - Media size code */
name|int
name|dpi
parameter_list|)
comment|/* I - Resolution in dots-per-inch */
block|{
switch|switch
condition|(
name|media_size
condition|)
block|{
case|case
name|MEDIA_LETTER
case|:
case|case
name|MEDIA_LEGAL
case|:
return|return
operator|(
literal|8
operator|*
name|dpi
operator|)
return|;
case|case
name|MEDIA_TABLOID
case|:
return|return
operator|(
call|(
name|int
call|)
argument_list|(
literal|10.5
operator|*
name|dpi
operator|+
literal|0.5
argument_list|)
operator|)
return|;
case|case
name|MEDIA_A4
case|:
return|return
operator|(
call|(
name|int
call|)
argument_list|(
literal|7.77
operator|*
name|dpi
operator|+
literal|0.5
argument_list|)
operator|)
return|;
case|case
name|MEDIA_A3
case|:
return|return
operator|(
call|(
name|int
call|)
argument_list|(
literal|11.09
operator|*
name|dpi
operator|+
literal|0.5
argument_list|)
operator|)
return|;
default|default :
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'media_height()' - Get the addressable height of the page.  *  * This function assumes a standard top/bottom margin of 0.5".  */
end_comment

begin_function
name|int
DECL|function|media_height (int media_size,int dpi)
name|media_height
parameter_list|(
name|int
name|media_size
parameter_list|,
comment|/* I - Media size code */
name|int
name|dpi
parameter_list|)
comment|/* I - Resolution in dots-per-inch */
block|{
switch|switch
condition|(
name|media_size
condition|)
block|{
case|case
name|MEDIA_LETTER
case|:
return|return
operator|(
literal|10
operator|*
name|dpi
operator|)
return|;
case|case
name|MEDIA_LEGAL
case|:
return|return
operator|(
literal|13
operator|*
name|dpi
operator|)
return|;
case|case
name|MEDIA_TABLOID
case|:
return|return
operator|(
literal|16
operator|*
name|dpi
operator|)
return|;
case|case
name|MEDIA_A4
case|:
return|return
operator|(
call|(
name|int
call|)
argument_list|(
literal|10.69
operator|*
name|dpi
operator|+
literal|0.5
argument_list|)
operator|)
return|;
case|case
name|MEDIA_A3
case|:
return|return
operator|(
call|(
name|int
call|)
argument_list|(
literal|15.54
operator|*
name|dpi
operator|+
literal|0.5
argument_list|)
operator|)
return|;
default|default :
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_gray()' - Convert RGB image data to grayscale.  */
end_comment

begin_function
name|void
DECL|function|rgb_to_gray (guchar * rgb,guchar * gray,int width,int bpp,guchar * lut,guchar * cmap)
name|rgb_to_gray
parameter_list|(
name|guchar
modifier|*
name|rgb
parameter_list|,
comment|/* I - RGB pixels */
name|guchar
modifier|*
name|gray
parameter_list|,
comment|/* O - Grayscale pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in RGB */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|)
comment|/* I - Colormap (unused) */
block|{
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
index|[
operator|(
name|rgb
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|rgb
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|rgb
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|/
literal|100
index|]
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|rgb
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/*     * Image has alpha channel...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
operator|*
name|gray
operator|=
name|lut
index|[
operator|(
name|rgb
index|[
literal|0
index|]
operator|*
name|LUM_RED
operator|+
name|rgb
index|[
literal|1
index|]
operator|*
name|LUM_GREEN
operator|+
name|rgb
index|[
literal|2
index|]
operator|*
name|LUM_BLUE
operator|)
operator|*
name|rgb
index|[
literal|3
index|]
operator|/
literal|25500
operator|+
literal|255
operator|-
name|rgb
index|[
literal|3
index|]
index|]
expr_stmt|;
name|gray
operator|++
expr_stmt|;
name|rgb
operator|+=
name|bpp
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'rgb_to_rgb()' - Convert rgb image data to RGB.  */
end_comment

begin_function
name|void
DECL|function|rgb_to_rgb (guchar * rgbin,guchar * rgbout,int width,int bpp,guchar * lut,guchar * cmap)
name|rgb_to_rgb
parameter_list|(
name|guchar
modifier|*
name|rgbin
parameter_list|,
comment|/* I - RGB pixels */
name|guchar
modifier|*
name|rgbout
parameter_list|,
comment|/* O - RGB pixels */
name|int
name|width
parameter_list|,
comment|/* I - Width of row */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes-per-pixel in indexed */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|)
comment|/* I - Colormap */
block|{
if|if
condition|(
name|bpp
operator|==
literal|3
condition|)
block|{
comment|/*     * No alpha in image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|rgbout
index|[
literal|0
index|]
operator|=
name|lut
index|[
name|rgbin
index|[
literal|0
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|lut
index|[
name|rgbin
index|[
literal|1
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|lut
index|[
name|rgbin
index|[
literal|2
index|]
index|]
expr_stmt|;
name|rgbin
operator|+=
literal|3
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/*     * RGBA image...     */
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|rgbout
index|[
literal|0
index|]
operator|=
name|lut
index|[
name|rgbin
index|[
literal|0
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|1
index|]
operator|=
name|lut
index|[
name|rgbin
index|[
literal|1
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbout
index|[
literal|2
index|]
operator|=
name|lut
index|[
name|rgbin
index|[
literal|2
index|]
operator|*
name|rgbin
index|[
literal|3
index|]
operator|/
literal|255
operator|+
literal|255
operator|-
name|rgbin
index|[
literal|3
index|]
index|]
expr_stmt|;
name|rgbin
operator|+=
name|bpp
expr_stmt|;
name|rgbout
operator|+=
literal|3
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

