begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in EPSON ESC/P2 driver for the GIMP.  *  *   Copyright 1997-1999 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   escp2_parameters()     - Return the parameter values for the given  *                            parameter.  *   escp2_imageable_area() - Return the imageable area of the page.  *   escp2_print()          - Print an image to an EPSON printer.  *   escp2_write()          - Send 6-color ESC/P2 graphics using TIFF packbits compression.  *  * Revision History:  *  *   $Log$  *   Revision 1.12  1999/12/16 19:44:01  olofk  *   Thu Dec 16 20:15:25 CET 1999  Olof S Kylande<olof@gimp.org>  *  *           Fix of KDE/Kwm  selection add/sub/inter problem  *           NOTE: This is a workaround, not a real fix.  *           Many Thanks to Matthias Ettrich  *  *           * app/disp_callbacks.c  *  *           Updated unsharp-mask to version 0.10  *  *           * plug-ins/unsharp/dialog_f.c  *           * plug-ins/unsharp/dialog_f.h  *           * plug-ins/unsharp/dialog_i.c  *           * plug-ins/unsharp/dialog_i.h  *           * plug-ins/unsharp/unsharp.c  *  *           Updated print plug-in to version 3.0.1  *  *           * plug-ins/print/README (new file)  *           * plug-ins/print/print-escp2.c  *           * plug-ins/print/print-pcl.c  *           * plug-ins/print/print-ps.c  *           * plug-ins/print/print-util.c  *           * plug-ins/print/print.c  *           * plug-ins/print/print.h  *  *           Updated all files in the help/C/dialogs dir. This is  *           a first alpha glimpse of the help system. Please give  *           me feedback of the content. However since it's in alpha  *           stage it means that there is spell, grammatical, etc errors.  *           There is may also be pure errors which I hope "you" will  *           report to either olof@gimp.org or karin@gimp.org. Please  *           don't report spell, grammatical, etc error at this stage in dev.  *  *           If you have any plans to commit to the help system please write  *           to olof@gimp.org. (This is mandatory not a please ;-).  *  *           * help/C/welcome.html  *           * help/C/dialogs/about.html ..............  *  *   Revision 1.31  1999/12/05 22:10:53  rlk  *   minor, prep for release  *  *   Revision 1.30  1999/12/05 04:33:43  rlk  *   fencepost  *  *   Revision 1.29  1999/11/23 02:11:37  rlk  *   Rationalize variables, pass 3  *  *   Revision 1.28  1999/11/23 01:45:00  rlk  *   Rationalize variables -- pass 2  *  *   Revision 1.27  1999/11/16 01:04:06  rlk  *   Documentation  *  *   Revision 1.26  1999/11/14 18:59:22  rlk  *   Final preparations for release to Olof  *  *   Revision 1.25  1999/11/14 03:13:36  rlk  *   Pseudo-hi-res microweave options  *  *   Revision 1.24  1999/11/13 02:32:58  rlk  *   Comments on some good settings!  *  *   Revision 1.23  1999/11/10 01:13:27  rlk  *   1440x720 two-pass  *  *   Revision 1.22  1999/11/08 13:10:21  rlk  *   Bug fix  *  *   Revision 1.21  1999/11/07 22:18:51  rlk  *   Support Stylus Photo  *  *   Attempt at 1440 dpi  *  *   Revision 1.20  1999/11/04 03:08:52  rlk  *   Comments!  Comments!  Comments!  *  *   Revision 1.19  1999/11/02 23:11:16  rlk  *   Good weave code  *  *   Revision 1.18  1999/11/02 03:11:17  rlk  *   Remove dead code  *  *   Revision 1.17  1999/11/02 03:01:29  rlk  *   Support both softweave and microweave  *  *   Revision 1.16  1999/11/02 02:04:18  rlk  *   Much better weaving code!  *  *   Revision 1.15  1999/11/01 03:38:53  rlk  *   First cut at weaving  *  *   Revision 1.14  1999/10/26 23:58:31  rlk  *   indentation  *  *   Revision 1.13  1999/10/26 23:36:51  rlk  *   Comment out all remaining 16-bit code, and rename 16-bit functions to "standard" names  *  *   Revision 1.12  1999/10/26 02:10:30  rlk  *   Mostly fix save/load  *  *   Move all gimp, glib, gtk stuff into print.c (take it out of everything else).  *   This should help port it to more general purposes later.  *  *   Revision 1.11  1999/10/25 23:31:59  rlk  *   16-bit clean  *  *   Revision 1.10  1999/10/25 00:16:12  rlk  *   Comment  *  *   Revision 1.9  1999/10/21 01:27:37  rlk  *   More progress toward full 16-bit rendering  *  *   Revision 1.8  1999/10/19 02:04:59  rlk  *   Merge all of the single-level print_cmyk functions  *  *   Revision 1.7  1999/10/18 01:37:19  rlk  *   Add Stylus Photo 700 and switch to printer capabilities  *  *   Revision 1.6  1999/10/17 23:44:07  rlk  *   16-bit everything (untested)  *  *   Revision 1.5  1999/10/14 01:59:59  rlk  *   Saturation  *  *   Revision 1.4  1999/10/03 23:57:20  rlk  *   Various improvements  *  *   Revision 1.3  1999/09/15 02:53:58  rlk  *   Remove some stuff that seems to have no effect  *  *   Revision 1.2  1999/09/12 00:12:24  rlk  *   Current best stuff  *  *   Revision 1.11  1999/05/29 16:35:26  yosh  *   * configure.in  *   * Makefile.am: removed tips files, AC_SUBST GIMP_PLUGINS and  *   GIMP_MODULES so you can easily skip those parts of the build  *  *   * acinclude.m4  *   * config.sub  *   * config.guess  *   * ltconfig  *   * ltmain.sh: libtool 1.3.2  *  *   * app/fileops.c: shuffle #includes to avoid warning about MIN and  *   MAX  *  *   [ The following is a big i18n patch from David Monniaux  *<david.monniaux@ens.fr> ]  *  *   * tips/gimp_conseils.fr.txt  *   * tips/gimp_tips.txt  *   * tips/Makefile.am  *   * configure.in: moved tips to separate dir  *  *   * po-plugins: new dir for plug-in translation files  *  *   * configure.in: add po-plugins dir and POTFILES processing  *  *   * app/boundary.c  *   * app/brightness_contrast.c  *   * app/by_color_select.c  *   * app/color_balance.c  *   * app/convert.c  *   * app/curves.c  *   * app/free_select.c  *   * app/gdisplay.c  *   * app/gimpimage.c  *   * app/gimpunit.c  *   * app/gradient.c  *   * app/gradient_select.c  *   * app/install.c  *   * app/session.c: various i18n tweaks  *  *   * app/tips_dialog.c: localize tips filename  *  *   * libgimp/gimpunit.c  *   * libgimp/gimpunitmenu.c: #include "config.h"  *  *   * plug-ins/CEL  *   * plug-ins/CML_explorer  *   * plug-ins/Lighting  *   * plug-ins/apply_lens  *   * plug-ins/autostretch_hsv  *   * plug-ins/blur  *   * plug-ins/bmp  *   * plug-ins/borderaverage  *   * plug-ins/bumpmap  *   * plug-ins/bz2  *   * plug-ins/checkerboard  *   * plug-ins/colorify  *   * plug-ins/compose  *   * plug-ins/convmatrix  *   * plug-ins/cubism  *   * plug-ins/depthmerge  *   * plug-ins/destripe  *   * plug-ins/gif  *   * plug-ins/gifload  *   * plug-ins/jpeg  *   * plug-ins/mail  *   * plug-ins/oilify  *   * plug-ins/png  *   * plug-ins/print  *   * plug-ins/ps  *   * plug-ins/xbm  *   * plug-ins/xpm  *   * plug-ins/xwd: plug-in i18n stuff  *  *   -Yosh  *  *   Revision 1.10  1998/08/28 23:01:44  yosh  *   * acconfig.h  *   * configure.in  *   * app/main.c: added check for putenv and #ifdefed it's usage since NeXTStep is  *   lame  *  *   * libgimp/gimp.c  *   * app/main.c  *   * app/plug_in.c: conditionally compile shared mem stuff so platforms without  *   it can still work  *  *   * plug-ins/CEL/CEL.c  *   * plug-ins/palette/palette.c  *   * plug-ins/print/print-escp2.c  *   * plug-ins/print/print-pcl.c  *   * plug-ins/print/print-ps.c: s/strdup/g_strdup/ for portability  *  *   -Yosh  *  *   Revision 1.9  1998/05/17 07:16:45  yosh  *   0.99.31 fun  *  *   updated print plugin  *  *   -Yosh  *  *   Revision 1.11  1998/05/15  21:01:51  mike  *   Updated image positioning code (invert top and center left/top independently)  *  *   Revision 1.10  1998/05/08  21:18:34  mike  *   Now enable microweaving in 720 DPI mode.  *  *   Revision 1.9  1998/05/08  20:49:43  mike  *   Updated to support media size, imageable area, and parameter functions.  *   Added support for scaling modes - scale by percent or scale by PPI.  *  *   Revision 1.8  1998/01/21  21:33:47  mike  *   Updated copyright.  *  *   Revision 1.7  1997/11/12  15:57:48  mike  *   Minor changes for clean compiles under Digital UNIX.  *  *   Revision 1.7  1997/11/12  15:57:48  mike  *   Minor changes for clean compiles under Digital UNIX.  *  *   Revision 1.6  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.6  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.5  1997/07/30  18:47:39  mike  *   Added scaling, orientation, and offset options.  *  *   Revision 1.4  1997/07/15  20:57:11  mike  *   Updated ESC 800/1520/3000 output code to use vertical spacing of 5 instead of 40.  *  *   Revision 1.3  1997/07/03  13:21:15  mike  *   Updated documentation for 1.0 release.  *  *   Revision 1.2  1997/07/03  13:03:57  mike  *   Added horizontal offset to try to center image.  *   Got rid of initial vertical positioning since the top margin is  *   now set properly.  *  *   Revision 1.2  1997/07/03  13:03:57  mike  *   Added horizontal offset to try to center image.  *   Got rid of initial vertical positioning since the top margin is  *   now set properly.  *  *   Revision 1.1  1997/07/02  13:51:53  mike  *   Initial revision  */
end_comment

begin_comment
comment|/*  * Stylus Photo EX added by Robert Krawitz<rlk@alum.mit.edu> August 30, 1999  */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|escp2_write
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_weave
parameter_list|(
name|int
name|jets
parameter_list|,
name|int
name|separation
parameter_list|,
name|int
name|horizontal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_flush
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_write_weave
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
name|unsigned
name|char
modifier|*
name|C
parameter_list|,
name|unsigned
name|char
modifier|*
name|M
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Printer capabilities.  *  * Various classes of printer capabilities are represented by bitmasks.  */
end_comment

begin_typedef
DECL|typedef|model_cap_t
typedef|typedef
name|unsigned
name|int
name|model_cap_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|model_featureset_t
typedef|typedef
name|model_cap_t
name|model_featureset_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|model_class_t
typedef|typedef
name|model_cap_t
name|model_class_t
typedef|;
end_typedef

begin_define
DECL|macro|MODEL_PAPER_SIZE_MASK
define|#
directive|define
name|MODEL_PAPER_SIZE_MASK
value|0x3
end_define

begin_define
DECL|macro|MODEL_PAPER_SMALL
define|#
directive|define
name|MODEL_PAPER_SMALL
value|0x0
end_define

begin_define
DECL|macro|MODEL_PAPER_LARGE
define|#
directive|define
name|MODEL_PAPER_LARGE
value|0x1
end_define

begin_define
DECL|macro|MODEL_PAPER_1200
define|#
directive|define
name|MODEL_PAPER_1200
value|0x2
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_MASK
define|#
directive|define
name|MODEL_IMAGEABLE_MASK
value|0xc
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_DEFAULT
define|#
directive|define
name|MODEL_IMAGEABLE_DEFAULT
value|0x0
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_PHOTO
define|#
directive|define
name|MODEL_IMAGEABLE_PHOTO
value|0x4
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_600
define|#
directive|define
name|MODEL_IMAGEABLE_600
value|0x8
end_define

begin_define
DECL|macro|MODEL_INIT_MASK
define|#
directive|define
name|MODEL_INIT_MASK
value|0xf0
end_define

begin_define
DECL|macro|MODEL_INIT_COLOR
define|#
directive|define
name|MODEL_INIT_COLOR
value|0x00
end_define

begin_define
DECL|macro|MODEL_INIT_PRO
define|#
directive|define
name|MODEL_INIT_PRO
value|0x10
end_define

begin_define
DECL|macro|MODEL_INIT_1500
define|#
directive|define
name|MODEL_INIT_1500
value|0x20
end_define

begin_define
DECL|macro|MODEL_INIT_600
define|#
directive|define
name|MODEL_INIT_600
value|0x30
end_define

begin_define
DECL|macro|MODEL_INIT_PHOTO
define|#
directive|define
name|MODEL_INIT_PHOTO
value|0x40
end_define

begin_define
DECL|macro|MODEL_HASBLACK_MASK
define|#
directive|define
name|MODEL_HASBLACK_MASK
value|0x100
end_define

begin_define
DECL|macro|MODEL_HASBLACK_YES
define|#
directive|define
name|MODEL_HASBLACK_YES
value|0x000
end_define

begin_define
DECL|macro|MODEL_HASBLACK_NO
define|#
directive|define
name|MODEL_HASBLACK_NO
value|0x100
end_define

begin_define
DECL|macro|MODEL_6COLOR_MASK
define|#
directive|define
name|MODEL_6COLOR_MASK
value|0x200
end_define

begin_define
DECL|macro|MODEL_6COLOR_NO
define|#
directive|define
name|MODEL_6COLOR_NO
value|0x000
end_define

begin_define
DECL|macro|MODEL_6COLOR_YES
define|#
directive|define
name|MODEL_6COLOR_YES
value|0x200
end_define

begin_define
DECL|macro|MODEL_720DPI_MODE_MASK
define|#
directive|define
name|MODEL_720DPI_MODE_MASK
value|0xc00
end_define

begin_define
DECL|macro|MODEL_720DPI_DEFAULT
define|#
directive|define
name|MODEL_720DPI_DEFAULT
value|0x000
end_define

begin_define
DECL|macro|MODEL_720DPI_600
define|#
directive|define
name|MODEL_720DPI_600
value|0x400
end_define

begin_define
DECL|macro|MODEL_720DPI_PHOTO
define|#
directive|define
name|MODEL_720DPI_PHOTO
value|0x400
end_define

begin_comment
DECL|macro|MODEL_720DPI_PHOTO
comment|/* 0x800 for experimental stuff */
end_comment

begin_define
DECL|macro|MODEL_1440DPI_MASK
define|#
directive|define
name|MODEL_1440DPI_MASK
value|0x1000
end_define

begin_define
DECL|macro|MODEL_1440DPI_NO
define|#
directive|define
name|MODEL_1440DPI_NO
value|0x0000
end_define

begin_define
DECL|macro|MODEL_1440DPI_YES
define|#
directive|define
name|MODEL_1440DPI_YES
value|0x1000
end_define

begin_comment
comment|/*  * SUGGESTED SETTINGS FOR STYLUS PHOTO EX:  * Brightness 127  * Blue 92  * Saturation 1.2  *  * Another group of settings that has worked well for me is  * Brightness 110  * Gamma 1.2  * Contrast 97  * Blue 88  * Saturation 1.1  * Density 1.5  *  * With the current code, the following settings seem to work nicely:  * Brightness ~110  * Gamma 1.3  * Contrast 80  * Green 94  * Blue 89  * Saturation 1.15  * Density 1.6  *  * The green and blue will vary somewhat with different inks  */
end_comment

begin_decl_stmt
DECL|variable|model_capabilities
name|model_cap_t
name|model_capabilities
index|[]
init|=
block|{
comment|/* Stylus Color */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_DEFAULT
operator||
name|MODEL_INIT_COLOR
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator|)
block|,
comment|/* Stylus Color Pro/Pro XL/400/500 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_DEFAULT
operator||
name|MODEL_INIT_PRO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator|)
block|,
comment|/* Stylus Color 1500 */
operator|(
name|MODEL_PAPER_LARGE
operator||
name|MODEL_IMAGEABLE_DEFAULT
operator||
name|MODEL_INIT_1500
operator||
name|MODEL_HASBLACK_NO
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator|)
block|,
comment|/* Stylus Color 600 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_600
operator||
name|MODEL_INIT_600
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_1440DPI_NO
operator|)
block|,
comment|/* Stylus Color 800 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_600
operator||
name|MODEL_INIT_600
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator|)
block|,
comment|/* Stylus Color 1520/3000 */
operator|(
name|MODEL_PAPER_LARGE
operator||
name|MODEL_IMAGEABLE_600
operator||
name|MODEL_INIT_600
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator|)
block|,
comment|/* Stylus Photo 700 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_PHOTO
operator||
name|MODEL_INIT_PHOTO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_PHOTO
operator||
name|MODEL_1440DPI_YES
operator|)
block|,
comment|/* Stylus Photo EX */
operator|(
name|MODEL_PAPER_LARGE
operator||
name|MODEL_IMAGEABLE_PHOTO
operator||
name|MODEL_INIT_PHOTO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_PHOTO
operator||
name|MODEL_1440DPI_YES
operator|)
block|,
comment|/* Stylus Photo */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_PHOTO
operator||
name|MODEL_INIT_PHOTO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_PHOTO
operator||
name|MODEL_1440DPI_NO
operator|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
DECL|function|escp2_has_cap (int model,model_featureset_t featureset,model_class_t class)
name|escp2_has_cap
parameter_list|(
name|int
name|model
parameter_list|,
name|model_featureset_t
name|featureset
parameter_list|,
name|model_class_t
name|class
parameter_list|)
block|{
return|return
operator|(
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|&
name|featureset
operator|)
operator|==
name|class
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|model_class_t
DECL|function|escp2_cap (int model,model_featureset_t featureset)
name|escp2_cap
parameter_list|(
name|int
name|model
parameter_list|,
name|model_featureset_t
name|featureset
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|&
name|featureset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'escp2_parameters()' - Return the parameter values for the given parameter.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
comment|/* O - Parameter values */
DECL|function|escp2_parameters (int model,char * ppd_file,char * name,int * count)
name|escp2_parameters
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|name
parameter_list|,
comment|/* I - Name of parameter */
name|int
modifier|*
name|count
parameter_list|)
comment|/* O - Number of values */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|valptrs
decl_stmt|;
specifier|static
name|char
modifier|*
name|media_sizes
index|[]
init|=
block|{
operator|(
literal|"Letter"
operator|)
block|,
operator|(
literal|"Legal"
operator|)
block|,
operator|(
literal|"A4"
operator|)
block|,
operator|(
literal|"Tabloid"
operator|)
block|,
operator|(
literal|"A3"
operator|)
block|,
operator|(
literal|"12x18"
operator|)
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|resolutions
index|[]
init|=
block|{
operator|(
literal|"360 DPI"
operator|)
block|,
operator|(
literal|"720 DPI Microweave"
operator|)
block|,
operator|(
literal|"720 DPI Softweave"
operator|)
block|,
operator|(
literal|"1440 x 720 DPI"
operator|)
block|,
operator|(
literal|"1440 x 720 DPI Microweave"
operator|)
block|,
operator|(
literal|"1440 x 720 DPI Two-pass"
operator|)
block|,
operator|(
literal|"1440 x 720 DPI Two-pass Microweave"
operator|)
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PageSize"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_PAPER_SIZE_MASK
argument_list|,
name|MODEL_PAPER_LARGE
argument_list|)
condition|)
operator|*
name|count
operator|=
literal|6
expr_stmt|;
else|else
operator|*
name|count
operator|=
literal|3
expr_stmt|;
name|p
operator|=
name|media_sizes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Resolution"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
condition|)
operator|*
name|count
operator|=
literal|7
expr_stmt|;
else|else
operator|*
name|count
operator|=
literal|3
expr_stmt|;
name|p
operator|=
name|resolutions
expr_stmt|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|valptrs
operator|=
name|malloc
argument_list|(
operator|*
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* strdup doesn't appear to be POSIX... */
name|valptrs
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
name|i
index|]
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'escp2_imageable_area()' - Return the imageable area of the page.  */
end_comment

begin_function
name|void
DECL|function|escp2_imageable_area (int model,char * ppd_file,char * media_size,int * left,int * right,int * bottom,int * top)
name|escp2_imageable_area
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|media_size
parameter_list|,
comment|/* I - Media size */
name|int
modifier|*
name|left
parameter_list|,
comment|/* O - Left position in points */
name|int
modifier|*
name|right
parameter_list|,
comment|/* O - Right position in points */
name|int
modifier|*
name|bottom
parameter_list|,
comment|/* O - Bottom position in points */
name|int
modifier|*
name|top
parameter_list|)
comment|/* O - Top position in points */
block|{
name|int
name|width
decl_stmt|,
name|length
decl_stmt|;
comment|/* Size of page */
name|default_media_size
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|escp2_cap
argument_list|(
name|model
argument_list|,
name|MODEL_IMAGEABLE_MASK
argument_list|)
condition|)
block|{
case|case
name|MODEL_IMAGEABLE_PHOTO
case|:
operator|*
name|left
operator|=
literal|9
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
literal|9
expr_stmt|;
operator|*
name|top
operator|=
name|length
expr_stmt|;
operator|*
name|bottom
operator|=
literal|49
expr_stmt|;
break|break;
case|case
name|MODEL_IMAGEABLE_600
case|:
operator|*
name|left
operator|=
literal|8
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
literal|9
expr_stmt|;
operator|*
name|top
operator|=
name|length
operator|-
literal|32
expr_stmt|;
operator|*
name|bottom
operator|=
literal|40
expr_stmt|;
break|break;
case|case
name|MODEL_IMAGEABLE_DEFAULT
case|:
default|default:
operator|*
name|left
operator|=
literal|14
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
literal|14
expr_stmt|;
operator|*
name|top
operator|=
name|length
operator|-
literal|14
expr_stmt|;
operator|*
name|bottom
operator|=
literal|40
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * 'escp2_print()' - Print an image to an EPSON printer.  */
end_comment

begin_function
name|void
DECL|function|escp2_print (int model,int copies,FILE * prn,Image image,unsigned char * cmap,lut_t * lut,vars_t * v)
name|escp2_print
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Model */
name|int
name|copies
parameter_list|,
comment|/* I - Number of copies */
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|Image
name|image
parameter_list|,
comment|/* I - Image to print */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (for indexed images) */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
name|ppd_file
init|=
name|v
operator|->
name|ppd_file
decl_stmt|;
name|char
modifier|*
name|resolution
init|=
name|v
operator|->
name|resolution
decl_stmt|;
name|char
modifier|*
name|media_size
init|=
name|v
operator|->
name|media_size
decl_stmt|;
name|int
name|output_type
init|=
name|v
operator|->
name|output_type
decl_stmt|;
name|int
name|orientation
init|=
name|v
operator|->
name|orientation
decl_stmt|;
name|float
name|scaling
init|=
name|v
operator|->
name|scaling
decl_stmt|;
name|int
name|top
init|=
name|v
operator|->
name|top
decl_stmt|;
name|int
name|left
init|=
name|v
operator|->
name|left
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Looping vars */
name|int
name|xdpi
decl_stmt|,
name|ydpi
decl_stmt|;
comment|/* Resolution */
name|int
name|n
decl_stmt|;
comment|/* Output number */
name|unsigned
name|short
modifier|*
name|out
decl_stmt|;
comment|/* Output pixels (16-bit) */
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
comment|/* Input pixels */
modifier|*
name|black
decl_stmt|,
comment|/* Black bitmap data */
modifier|*
name|cyan
decl_stmt|,
comment|/* Cyan bitmap data */
modifier|*
name|magenta
decl_stmt|,
comment|/* Magenta bitmap data */
modifier|*
name|lcyan
decl_stmt|,
comment|/* Light cyan bitmap data */
modifier|*
name|lmagenta
decl_stmt|,
comment|/* Light magenta bitmap data */
modifier|*
name|yellow
decl_stmt|;
comment|/* Yellow bitmap data */
name|int
name|page_left
decl_stmt|,
comment|/* Left margin of page */
name|page_right
decl_stmt|,
comment|/* Right margin of page */
name|page_top
decl_stmt|,
comment|/* Top of page */
name|page_bottom
decl_stmt|,
comment|/* Bottom of page */
name|page_width
decl_stmt|,
comment|/* Width of page */
name|page_height
decl_stmt|,
comment|/* Height of page */
name|page_length
decl_stmt|,
comment|/* True length of page */
name|out_width
decl_stmt|,
comment|/* Width of image on page */
name|out_height
decl_stmt|,
comment|/* Height of image on page */
name|out_bpp
decl_stmt|,
comment|/* Output bytes per pixel */
name|temp_width
decl_stmt|,
comment|/* Temporary width of image on page */
name|temp_height
decl_stmt|,
comment|/* Temporary height of image on page */
name|landscape
decl_stmt|,
comment|/* True if we rotate the output 90 degrees */
name|length
decl_stmt|,
comment|/* Length of raster data */
name|errdiv
decl_stmt|,
comment|/* Error dividend */
name|errmod
decl_stmt|,
comment|/* Error modulus */
name|errval
decl_stmt|,
comment|/* Current error value */
name|errline
decl_stmt|,
comment|/* Current raster line */
name|errlast
decl_stmt|;
comment|/* Last raster line loaded */
name|convert_t
name|colorfunc
init|=
literal|0
decl_stmt|;
comment|/* Color conversion function... */
name|int
name|image_height
decl_stmt|,
name|image_width
decl_stmt|,
name|image_bpp
decl_stmt|;
name|int
name|use_softweave
init|=
literal|0
decl_stmt|;
name|int
name|nozzles
init|=
literal|1
decl_stmt|;
name|int
name|nozzle_separation
init|=
literal|1
decl_stmt|;
name|int
name|horizontal_passes
init|=
literal|1
decl_stmt|;
comment|/*   * Setup a read-only pixel region for the entire image...   */
name|Image_init
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_height
operator|=
name|Image_height
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_width
operator|=
name|Image_width
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_bpp
operator|=
name|Image_bpp
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Choose the correct color conversion function...   */
if|if
condition|(
name|image_bpp
operator|<
literal|3
operator|&&
name|cmap
operator|==
name|NULL
condition|)
name|output_type
operator|=
name|OUTPUT_GRAY
expr_stmt|;
comment|/* Force grayscale output */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
block|{
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|image_bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_rgb
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_rgb
expr_stmt|;
block|}
else|else
block|{
name|out_bpp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|image_bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_gray
expr_stmt|;
elseif|else
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
name|colorfunc
operator|=
name|gray_to_gray
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_gray
expr_stmt|;
block|}
comment|/*   * Figure out the output resolution...   */
name|xdpi
operator|=
name|ydpi
operator|=
name|atoi
argument_list|(
name|resolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
condition|)
block|{
if|if
condition|(
name|xdpi
operator|==
literal|1440
condition|)
block|{
name|use_softweave
operator|=
literal|1
expr_stmt|;
name|ydpi
operator|=
literal|720
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|"1440 x 720 DPI Two-pass"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|"1440 x 720 DPI Two-pass Microweave"
argument_list|)
condition|)
block|{
name|xdpi
operator|=
literal|2880
expr_stmt|;
name|horizontal_passes
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|"1440 x 720 DPI Two-pass"
argument_list|)
condition|)
block|{
name|nozzles
operator|=
literal|32
expr_stmt|;
name|nozzle_separation
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|nozzles
operator|=
literal|1
expr_stmt|;
name|nozzle_separation
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|horizontal_passes
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|"1440 x 720 DPI"
argument_list|)
condition|)
block|{
name|nozzles
operator|=
literal|32
expr_stmt|;
name|nozzle_separation
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|nozzles
operator|=
literal|1
expr_stmt|;
name|nozzle_separation
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ydpi
operator|==
literal|1440
condition|)
block|{
name|ydpi
operator|=
literal|720
expr_stmt|;
name|xdpi
operator|=
literal|720
expr_stmt|;
block|}
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|"720 DPI Softweave"
argument_list|)
operator|||
name|xdpi
operator|>
literal|720
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|"720 DPI Softweave"
argument_list|)
condition|)
block|{
name|nozzles
operator|=
literal|32
expr_stmt|;
name|nozzle_separation
operator|=
literal|8
expr_stmt|;
block|}
name|use_softweave
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*   * Compute the output size...   */
name|landscape
operator|=
literal|0
expr_stmt|;
name|escp2_imageable_area
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|page_left
argument_list|,
operator|&
name|page_right
argument_list|,
operator|&
name|page_bottom
argument_list|,
operator|&
name|page_top
argument_list|)
expr_stmt|;
name|page_width
operator|=
name|page_right
operator|-
name|page_left
expr_stmt|;
name|page_height
operator|=
name|page_top
operator|-
name|page_bottom
expr_stmt|;
name|default_media_size
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|page_length
argument_list|)
expr_stmt|;
comment|/*   * Portrait width/height...   */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*     * Scale to pixels per inch...     */
name|out_width
operator|=
name|image_width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
name|out_height
operator|=
name|image_height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*     * Scale by percent...     */
name|out_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|out_height
operator|=
name|out_width
operator|*
name|image_height
operator|/
name|image_width
expr_stmt|;
if|if
condition|(
name|out_height
operator|>
name|page_height
condition|)
block|{
name|out_height
operator|=
name|page_height
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|out_width
operator|=
name|out_height
operator|*
name|image_width
operator|/
name|image_height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out_width
operator|==
literal|0
condition|)
name|out_width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|out_height
operator|==
literal|0
condition|)
name|out_height
operator|=
literal|1
expr_stmt|;
comment|/*   * Landscape width/height...   */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*     * Scale to pixels per inch...     */
name|temp_width
operator|=
name|image_height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
name|temp_height
operator|=
name|image_width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*     * Scale by percent...     */
name|temp_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|temp_height
operator|=
name|temp_width
operator|*
name|image_width
operator|/
name|image_height
expr_stmt|;
if|if
condition|(
name|temp_height
operator|>
name|page_height
condition|)
block|{
name|temp_height
operator|=
name|page_height
expr_stmt|;
name|temp_width
operator|=
name|temp_height
operator|*
name|image_height
operator|/
name|image_width
expr_stmt|;
block|}
block|}
comment|/*   * See which orientation has the greatest area (or if we need to rotate the   * image to fit it on the page...)   */
if|if
condition|(
name|orientation
operator|==
name|ORIENT_AUTO
condition|)
block|{
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
name|out_width
operator|>
name|page_width
operator|&&
name|out_height
operator|<
name|page_width
operator|)
operator|||
operator|(
name|out_height
operator|>
name|page_height
operator|&&
name|out_width
operator|<
name|page_height
operator|)
condition|)
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
else|else
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|temp_width
operator|*
name|temp_height
operator|)
operator|>
operator|(
name|out_width
operator|*
name|out_height
operator|)
condition|)
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
else|else
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|orientation
operator|==
name|ORIENT_LANDSCAPE
condition|)
block|{
name|out_width
operator|=
name|temp_width
expr_stmt|;
name|out_height
operator|=
name|temp_height
expr_stmt|;
name|landscape
operator|=
literal|1
expr_stmt|;
comment|/*     * Swap left/top offsets...     */
name|x
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|<
literal|0
condition|)
name|left
operator|=
operator|(
name|page_width
operator|-
name|out_width
operator|)
operator|/
literal|2
operator|+
name|page_left
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|0
condition|)
name|top
operator|=
operator|(
name|page_height
operator|+
name|out_height
operator|)
operator|/
literal|2
operator|+
name|page_bottom
expr_stmt|;
else|else
name|top
operator|=
name|page_height
operator|-
name|top
operator|+
name|page_bottom
expr_stmt|;
comment|/*   * Let the user know what we're doing...   */
name|Image_progress_init
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Send ESC/P2 initialization commands...   */
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
if|#
directive|if
literal|0
block|if (escp2_has_cap(model, MODEL_INIT_MASK, MODEL_INIT_PHOTO))     {       fwrite("\033@", 2, 1, prn);       fwrite("\033(R\010\000\000REMOTE1PM\002\000\000\000SN\003\000\000\000\003MS\010\000\000\000\010\000\364\013x\017\033\000\000\000", 42, 1, prn);     }
endif|#
directive|endif
name|fwrite
argument_list|(
literal|"\033(G\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Enter graphics mode */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Set line feed increment */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\024"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\012"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\005"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|escp2_cap
argument_list|(
name|model
argument_list|,
name|MODEL_INIT_MASK
argument_list|)
condition|)
comment|/* Printer specific initialization */
block|{
case|case
name|MODEL_INIT_COLOR
case|:
comment|/* ESC */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
operator|&&
name|ydpi
operator|>
literal|360
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_PRO
case|:
comment|/* ESC Pro, Pro XL, 400, 500 */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
if|if
condition|(
name|ydpi
operator|>
literal|360
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_1500
case|:
comment|/* ESC 1500 */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
if|if
condition|(
name|ydpi
operator|>
literal|360
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_600
case|:
comment|/* ESC 600, 800, 1520, 3000 */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Fast black printing */
else|else
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Color printing */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
if|if
condition|(
name|ydpi
operator|>
literal|360
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_PHOTO
case|:
if|if
condition|(
name|ydpi
operator|>
literal|360
condition|)
block|{
if|if
condition|(
name|use_softweave
condition|)
block|{
if|if
condition|(
name|horizontal_passes
operator|>
literal|1
condition|)
name|fwrite
argument_list|(
literal|"\033U\000"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Unidirectional */
else|else
name|fwrite
argument_list|(
literal|"\033U\000"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Unidirectional */
name|fwrite
argument_list|(
literal|"\033(i\001\000\000"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave off! */
name|initialize_weave
argument_list|(
name|nozzles
argument_list|,
name|nozzle_separation
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\004"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microdots */
block|}
else|else
block|{
name|fwrite
argument_list|(
literal|"\033U\000"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Unidirectional */
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave on */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\004"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microdots */
block|}
if|#
directive|if
literal|0
block|fwrite("\033\0311", 3, 1, prn);
comment|/* ??? */
endif|#
directive|endif
block|}
else|else
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\003"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Whatever dots */
break|break;
if|#
directive|if
literal|0
block|if (output_type == OUTPUT_GRAY) 	  fwrite("\033(K\002\000\000\001", 7, 1, prn);
comment|/* Fast black printing */
block|else 	  fwrite("\033(K\002\000\000\002", 7, 1, prn);
comment|/* Color printing */
endif|#
directive|endif
block|}
name|fwrite
argument_list|(
literal|"\033(C\002\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Page length */
name|n
operator|=
name|ydpi
operator|*
name|page_length
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
literal|"\033(c\004\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Top/bottom margins */
name|n
operator|=
name|ydpi
operator|*
operator|(
name|page_length
operator|-
name|page_top
operator|)
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|n
operator|=
name|ydpi
operator|*
operator|(
name|page_length
operator|-
name|page_bottom
operator|)
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
literal|"\033(V\002\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Absolute vertical position */
name|n
operator|=
name|ydpi
operator|*
operator|(
name|page_length
operator|-
name|top
operator|)
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/*   * Convert image size to printer resolution...   */
name|out_width
operator|=
name|xdpi
operator|*
name|out_width
operator|/
literal|72
expr_stmt|;
name|out_height
operator|=
name|ydpi
operator|*
name|out_height
operator|/
literal|72
expr_stmt|;
name|left
operator|=
name|ydpi
operator|*
operator|(
name|left
operator|-
name|page_left
operator|)
operator|/
literal|72
expr_stmt|;
comment|/*   * Allocate memory for the raster data...   */
name|length
operator|=
operator|(
name|out_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|black
operator|=
name|malloc
argument_list|(
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cyan
operator|=
name|NULL
expr_stmt|;
name|magenta
operator|=
name|NULL
expr_stmt|;
name|lcyan
operator|=
name|NULL
expr_stmt|;
name|lmagenta
operator|=
name|NULL
expr_stmt|;
name|yellow
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cyan
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|magenta
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|yellow
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_HASBLACK_MASK
argument_list|,
name|MODEL_HASBLACK_YES
argument_list|)
condition|)
name|black
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
else|else
name|black
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
name|lcyan
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|lmagenta
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lcyan
operator|=
name|NULL
expr_stmt|;
name|lmagenta
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*   * Output the page, rotating as necessary...   */
if|if
condition|(
name|landscape
condition|)
block|{
name|in
operator|=
name|malloc
argument_list|(
name|image_height
operator|*
name|image_bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|image_height
operator|*
name|out_bpp
operator|*
literal|2
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|image_width
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|image_width
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
name|image_width
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|out_height
condition|;
name|x
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|printf("escp2_print: x = %d, line = %d, val = %d, mod = %d, height = %d\n",              x, errline, errval, errmod, out_height);
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|Image_note_progress
argument_list|(
name|image
argument_list|,
name|x
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|Image_get_col
argument_list|(
name|image
argument_list|,
name|in
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|image_height
argument_list|,
name|image_bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|dither_black
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|image_height
argument_list|,
name|out_width
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|image_height
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
name|lcyan
argument_list|,
name|magenta
argument_list|,
name|lmagenta
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
block|{
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lcyan
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lmagenta
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|image_height
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
literal|0
argument_list|,
name|magenta
argument_list|,
literal|0
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(v\002\000\001\000"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Feed one line */
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|-=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_softweave
condition|)
name|escp2_flush
argument_list|(
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|malloc
argument_list|(
name|image_width
operator|*
name|image_bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|image_width
operator|*
name|out_bpp
operator|*
literal|2
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|image_height
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|image_height
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|out_height
condition|;
name|y
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|printf("escp2_print: y = %d, line = %d, val = %d, mod = %d, height = %d, length = %d\n",              y, errline, errval, errmod, out_height, length);
endif|#
directive|endif
if|if
condition|(
operator|(
name|y
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|Image_note_progress
argument_list|(
name|image
argument_list|,
name|y
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|Image_get_row
argument_list|(
name|image
argument_list|,
name|in
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|image_width
argument_list|,
name|image_bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|dither_black
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|image_width
argument_list|,
name|out_width
argument_list|,
name|black
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|image_width
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
name|lcyan
argument_list|,
name|magenta
argument_list|,
name|lmagenta
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
block|{
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lcyan
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lmagenta
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|image_width
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
literal|0
argument_list|,
name|magenta
argument_list|,
literal|0
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(v\002\000\001\000"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Feed one line */
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|+=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_softweave
condition|)
name|escp2_flush
argument_list|(
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
comment|/*   * Cleanup...   */
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyan
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cyan
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magenta
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yellow
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\014'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Eject page */
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_pack (unsigned char * line,int length,unsigned char * comp_buf,unsigned char ** comp_ptr)
name|escp2_pack
parameter_list|(
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
name|int
name|length
parameter_list|,
name|unsigned
name|char
modifier|*
name|comp_buf
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|comp_ptr
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of compressed data */
name|unsigned
name|char
name|repeat
decl_stmt|;
comment|/* Repeating char */
name|int
name|count
decl_stmt|;
comment|/* Count of compressed bytes */
name|int
name|tcount
decl_stmt|;
comment|/* Temporary count< 128 */
comment|/*    * Compress using TIFF "packbits" run-length encoding...    */
operator|(
operator|*
name|comp_ptr
operator|)
operator|=
name|comp_buf
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/*        * Get a run of non-repeated chars...        */
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|(
name|line
index|[
operator|-
literal|2
index|]
operator|!=
name|line
index|[
operator|-
literal|1
index|]
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|!=
name|line
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
name|line
operator|-=
literal|2
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
comment|/*        * Output the non-repeated sequences (max 128 at a time).        */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|0
index|]
operator|=
name|tcount
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|comp_ptr
operator|)
operator|+
literal|1
argument_list|,
name|start
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
operator|+=
name|tcount
operator|+
literal|1
expr_stmt|;
name|start
operator|+=
name|tcount
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
break|break;
comment|/*        * Find the repeated sequences...        */
name|start
operator|=
name|line
expr_stmt|;
name|repeat
operator|=
name|line
index|[
literal|0
index|]
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|*
name|line
operator|==
name|repeat
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
comment|/*        * Output the repeated sequences (max 128 at a time).        */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|0
index|]
operator|=
literal|1
operator|-
name|tcount
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|1
index|]
operator|=
name|repeat
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'escp2_write()' - Send ESC/P2 graphics using TIFF packbits compression.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|escp2_write (FILE * prn,unsigned char * line,int length,int density,int plane,int ydpi,int model,int width,int offset)
name|escp2_write
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
comment|/* I - Output bitmap data */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|density
parameter_list|,
comment|/* I - 0 for dark, 1 for light */
name|int
name|plane
parameter_list|,
comment|/* I - Which color */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|)
comment|/* I - Offset from left side */
block|{
name|unsigned
name|char
name|comp_buf
index|[
literal|1536
index|]
decl_stmt|,
comment|/* Compression buffer */
modifier|*
name|comp_ptr
decl_stmt|;
specifier|static
name|int
name|last_density
init|=
literal|0
decl_stmt|;
comment|/* Last density printed */
specifier|static
name|int
name|last_plane
init|=
literal|0
decl_stmt|;
comment|/* Last color plane printed */
comment|/*   * Don't send blank lines...   */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|escp2_pack
argument_list|(
name|line
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
comment|/*   * Set the print head position.   */
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/*   * Set the color if necessary...   */
if|if
condition|(
name|last_plane
operator|!=
name|plane
operator|||
name|last_density
operator|!=
name|density
condition|)
block|{
name|last_plane
operator|=
name|plane
expr_stmt|;
name|last_density
operator|=
name|density
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(r\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|density
argument_list|,
name|plane
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(\\%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|160
argument_list|,
literal|5
argument_list|,
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|offset
operator|&
literal|255
argument_list|,
name|offset
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/*   * Send a line of raster graphics...   */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Raster graphics header */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033.\001\024\024\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033.\001\012\012\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_720DPI_MODE_MASK
argument_list|,
name|MODEL_720DPI_600
argument_list|)
condition|)
name|fwrite
argument_list|(
literal|"\033.\001\050\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
if|else if (model == 7)           fwrite("\033.\000\050\005\040", 6, 1, prn);
endif|#
directive|endif
else|else
name|fwrite
argument_list|(
literal|"\033.\001\005\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|width
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|width
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "Soft" weave  *  * The Epson Stylus Color/Photo printers don't have memory to print  * using all of the nozzles in the print head.  For example, the Stylus Photo  * 700/EX has 32 nozzles.  At 720 dpi, with an 8" wide image, a single line  * requires (8 * 720 * 6 / 8) bytes, or 4320 bytes (because the Stylus Photo  * printers have 6 ink colors).  To use 32 nozzles would require 138240 bytes.  * It's actually worse than that, though, because the nozzles are spaced 8  * rows apart.  Therefore, in order to store enough data to permit sending the  * page as a simple raster, the printer would require enough memory to store  * 256 rows, or 1105920 bytes.  Considering that the Photo EX can print  * 11" wide, we're looking at more like 1.5 MB.  In fact, these printers are  * capable of 1440 dpi horizontal resolution.  This would require 3 MB.  The  * printers actually have 64K.  *  * With the newer (750 and 1200) printers it's even worse, since these printers  * support multiple dot sizes.  But that's neither here nor there.  *  * The printer is capable of printing an image fed to it as single raster  * lines.  This is called MicroWeave (tm).  It actually produces extremely  * high quality output, but it only uses one nozzle per color per pass.  * This means that it has to make a lot of passes to print a page, so it's  * extremely slow (a full 8.5x11" page takes over 30 minutes!).  It's also  * not possible to print very close to the bottom of the page with MicroWeave  * since only the first nozzle is used, and the head cannot get closer than  * some distance from the edge of the page.  *  * The solution is to have the host rearrange the output so that a single  * pass is fed to the print head.  This means that we have to feed the printer  * every 8th line as a single pass, and we then have to interleave ("weave")  * the other raster lines as separate passes.  This allows us to use all 32  * nozzles, and achieve much higher printing speed.  *  * What makes this interesting is that there are many different ways of  * of accomplishing this goal.  The naive way would be to divide the image  * up into groups of 256 rows, and print all the mod8=0 rows in the first pass,  * mod8=1 rows in the second, and so forth.  The problem with this approach  * is that the individual ink jets are not perfectly uniform; some emit  * slightly bigger or smaller drops than others.  Since each group of 8  * adjacent rows is printed with the same nozzle, that means that there will  * be distinct streaks of lighter and darker bands within the image (8 rows  * is 1/90", which is visible; 1/720" is not).  Possibly worse is that these  * patterns will repeat every 256 rows.  This creates banding patterns that  * are about 1/3" wide.  *  * So we have to do something to break up this patterning.  *  * Epson does not publish the weaving algorithms that they use in their  * bundled drivers.  Indeed, their developer web site  * (http://www.ercipd.com/isv/edr_docs.htm) does not even describe how to  * do this weaving at all; it says that the only way to achieve 720 dpi  * is to use MicroWeave.  It does note (correctly) that 1440 dpi horizontal  * can only be achieved by the driver (i. e. in software).  The manual  * actually makes it fairly clear how to do this (it requires two passes  * with horizontal head movement between passes), and it is presumably  * possible to do this with MicroWeave.  *  * The information about how to do this is apparently available under NDA.  * It's actually easy enough to reverse engineer what's inside a print file  * with a simple Perl script.  There are presumably other printer commands  * that are not documented and may not be as easy to reverse engineer.  *  * I considered a few algorithms to perform the weave.  The first one I  * devised let me use only (jets - distance_between_jets + 1) nozzles, or  * 25.  This is OK in principle, but it's slower than using all nozzles.  * By playing around with it some more, I came up with an algorithm that  * lets me use all of the nozzles, except near the top and bottom of the  * page.  *  * The routine initialize_weave calculates the basic parameters, given  * the number of jets and separation between jets, in rows.  *  * -- Robert Krawitz<rlk@alum.mit.edu) November 3, 1999  */
end_comment

begin_typedef
typedef|typedef
struct|struct
comment|/* Weave parameters for a specific row */
DECL|struct|__anon29475c160108
block|{
DECL|member|row
name|int
name|row
decl_stmt|;
comment|/* Absolute row # */
DECL|member|pass
name|int
name|pass
decl_stmt|;
comment|/* Computed pass # */
DECL|member|jet
name|int
name|jet
decl_stmt|;
comment|/* Which physical nozzle we're using */
DECL|member|missingstartrows
name|int
name|missingstartrows
decl_stmt|;
comment|/* Phantom rows (nonexistent rows that */
comment|/* would be printed by nozzles lower than */
comment|/* the first nozzle we're using this pass; */
comment|/* with the current algorithm, always zero */
DECL|member|logicalpassstart
name|int
name|logicalpassstart
decl_stmt|;
comment|/* Offset in rows (from start of image) */
comment|/* that the printer must be for this row */
comment|/* to print correctly with the specified jet */
DECL|member|physpassstart
name|int
name|physpassstart
decl_stmt|;
comment|/* Offset in rows to the first row printed */
comment|/* in this pass.  Currently always equal to */
comment|/* logicalpassstart */
DECL|member|physpassend
name|int
name|physpassend
decl_stmt|;
comment|/* Offset in rows (from start of image) to */
comment|/* the last row that will be printed this */
comment|/* pass (assuming that we're printing a full */
comment|/* pass). */
DECL|typedef|weave_t
block|}
name|weave_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
comment|/* Weave parameters for a specific pass */
DECL|struct|__anon29475c160208
block|{
DECL|member|pass
name|int
name|pass
decl_stmt|;
comment|/* Absolute pass number */
DECL|member|missingstartrows
name|int
name|missingstartrows
decl_stmt|;
comment|/* All other values the same as weave_t */
DECL|member|logicalpassstart
name|int
name|logicalpassstart
decl_stmt|;
DECL|member|physpassstart
name|int
name|physpassstart
decl_stmt|;
DECL|member|physpassend
name|int
name|physpassend
decl_stmt|;
DECL|typedef|pass_t
block|}
name|pass_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon29475c16030a
typedef|typedef
union|union
block|{
comment|/* Offsets from the start of each line */
DECL|member|v
name|off_t
name|v
index|[
literal|6
index|]
decl_stmt|;
comment|/* (really pass) */
DECL|struct|__anon29475c160408
struct|struct
block|{
DECL|member|k
name|off_t
name|k
decl_stmt|;
DECL|member|m
name|off_t
name|m
decl_stmt|;
DECL|member|c
name|off_t
name|c
decl_stmt|;
DECL|member|y
name|off_t
name|y
decl_stmt|;
DECL|member|M
name|off_t
name|M
decl_stmt|;
DECL|member|C
name|off_t
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|lineoff_t
block|}
name|lineoff_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon29475c16050a
typedef|typedef
union|union
block|{
comment|/* Base pointers for each pass */
DECL|member|v
name|unsigned
name|char
modifier|*
name|v
index|[
literal|6
index|]
decl_stmt|;
DECL|struct|__anon29475c160608
struct|struct
block|{
DECL|member|k
name|unsigned
name|char
modifier|*
name|k
decl_stmt|;
DECL|member|m
name|unsigned
name|char
modifier|*
name|m
decl_stmt|;
DECL|member|c
name|unsigned
name|char
modifier|*
name|c
decl_stmt|;
DECL|member|y
name|unsigned
name|char
modifier|*
name|y
decl_stmt|;
DECL|member|M
name|unsigned
name|char
modifier|*
name|M
decl_stmt|;
DECL|member|C
name|unsigned
name|char
modifier|*
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|linebufs_t
block|}
name|linebufs_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|linebufs
specifier|static
name|unsigned
name|char
modifier|*
name|linebufs
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|linebufs
comment|/* Actual data buffers */
end_comment

begin_decl_stmt
DECL|variable|linebases
specifier|static
name|linebufs_t
modifier|*
name|linebases
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|linebases
comment|/* Base address of each row buffer */
end_comment

begin_decl_stmt
DECL|variable|lineoffsets
specifier|static
name|lineoff_t
modifier|*
name|lineoffsets
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|lineoffsets
comment|/* Offsets within each row buffer */
end_comment

begin_decl_stmt
DECL|variable|linecounts
specifier|static
name|int
modifier|*
name|linecounts
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|linecounts
comment|/* How many rows we've printed this pass */
end_comment

begin_decl_stmt
DECL|variable|passes
specifier|static
name|pass_t
modifier|*
name|passes
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|passes
comment|/* Circular list of pass numbers */
end_comment

begin_decl_stmt
DECL|variable|last_pass_offset
specifier|static
name|int
name|last_pass_offset
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|last_pass_offset
comment|/* Starting row (offset from the start of */
end_comment

begin_comment
comment|/* the image) of the most recently printed */
end_comment

begin_comment
comment|/* pass (so we can determine how far to */
end_comment

begin_comment
comment|/* advance the paper) */
end_comment

begin_decl_stmt
DECL|variable|last_pass
specifier|static
name|int
name|last_pass
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|last_pass
comment|/* Number of the most recently printed pass */
end_comment

begin_decl_stmt
DECL|variable|njets
specifier|static
name|int
name|njets
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|njets
comment|/* Number of jets in use */
end_comment

begin_decl_stmt
DECL|variable|separation
specifier|static
name|int
name|separation
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|separation
comment|/* Separation between jets */
end_comment

begin_decl_stmt
DECL|variable|weavefactor
specifier|static
name|int
name|weavefactor
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|weavefactor
comment|/* Interleave factor (jets / separation) */
end_comment

begin_decl_stmt
DECL|variable|jetsused
specifier|static
name|int
name|jetsused
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|jetsused
comment|/* How many jets we can actually use */
end_comment

begin_decl_stmt
DECL|variable|initialoffset
specifier|static
name|int
name|initialoffset
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|initialoffset
comment|/* Distance between the first row we're */
end_comment

begin_comment
comment|/* printing and the logical first row */
end_comment

begin_comment
comment|/* (first nozzle of the first pass). */
end_comment

begin_comment
comment|/* Currently this is zero. */
end_comment

begin_decl_stmt
DECL|variable|jetsleftover
specifier|static
name|int
name|jetsleftover
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|jetsleftover
comment|/* How many jets we're *not* using. */
end_comment

begin_comment
comment|/* This can be used to rotate exactly */
end_comment

begin_comment
comment|/* what jets we're using.  Currently this */
end_comment

begin_comment
comment|/* is not used. */
end_comment

begin_decl_stmt
DECL|variable|weavespan
specifier|static
name|int
name|weavespan
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|weavespan
comment|/* How many rows total are bracketed by */
end_comment

begin_comment
comment|/* one pass (separation * (jets - 1) */
end_comment

begin_decl_stmt
DECL|variable|horizontal_weave
specifier|static
name|int
name|horizontal_weave
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|horizontal_weave
comment|/* Number of horizontal passes required */
end_comment

begin_comment
comment|/* This is> 1 for some of the ultra-high */
end_comment

begin_comment
comment|/* resolution modes */
end_comment

begin_comment
comment|/*  * Mapping between color and linear index.  The colors are  * black, magenta, cyan, yellow, light magenta, light cyan  */
end_comment

begin_decl_stmt
DECL|variable|color_indices
specifier|static
name|int
name|color_indices
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|4
block|,
literal|5
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|colors
specifier|static
name|int
name|colors
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|densities
specifier|static
name|int
name|densities
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
DECL|function|get_color_by_params (int plane,int density)
name|get_color_by_params
parameter_list|(
name|int
name|plane
parameter_list|,
name|int
name|density
parameter_list|)
block|{
if|if
condition|(
name|plane
operator|>
literal|4
operator|||
name|plane
operator|<
literal|0
operator|||
name|density
operator|>
literal|1
operator|||
name|density
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|color_indices
index|[
name|density
operator|*
literal|8
operator|+
name|plane
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the weave parameters  */
end_comment

begin_function
specifier|static
name|void
DECL|function|initialize_weave (int jets,int sep,int horizontal_passes)
name|initialize_weave
parameter_list|(
name|int
name|jets
parameter_list|,
name|int
name|sep
parameter_list|,
name|int
name|horizontal_passes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|bufbase
decl_stmt|;
if|if
condition|(
name|jets
operator|<=
literal|1
condition|)
name|separation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sep
operator|<=
literal|0
condition|)
name|separation
operator|=
literal|1
expr_stmt|;
else|else
name|separation
operator|=
name|sep
expr_stmt|;
name|njets
operator|=
name|jets
expr_stmt|;
if|if
condition|(
name|horizontal_passes
operator|<=
literal|0
condition|)
name|horizontal_passes
operator|=
literal|1
expr_stmt|;
name|horizontal_weave
operator|=
name|horizontal_passes
expr_stmt|;
name|weavefactor
operator|=
name|jets
operator|/
name|separation
expr_stmt|;
name|jetsused
operator|=
operator|(
operator|(
name|weavefactor
operator|)
operator|*
name|separation
operator|)
expr_stmt|;
name|initialoffset
operator|=
operator|(
name|jetsused
operator|-
name|weavefactor
operator|-
literal|1
operator|)
operator|*
name|separation
expr_stmt|;
name|jetsleftover
operator|=
name|njets
operator|-
name|jetsused
operator|+
literal|1
expr_stmt|;
name|weavespan
operator|=
operator|(
name|jetsused
operator|-
literal|1
operator|)
operator|*
name|separation
expr_stmt|;
name|last_pass_offset
operator|=
literal|0
expr_stmt|;
name|last_pass
operator|=
operator|-
literal|1
expr_stmt|;
name|linebufs
operator|=
name|malloc
argument_list|(
literal|6
operator|*
literal|1536
operator|*
name|separation
operator|*
name|jetsused
operator|*
name|horizontal_passes
argument_list|)
expr_stmt|;
name|lineoffsets
operator|=
name|malloc
argument_list|(
name|separation
operator|*
sizeof|sizeof
argument_list|(
name|lineoff_t
argument_list|)
operator|*
name|horizontal_passes
argument_list|)
expr_stmt|;
name|linebases
operator|=
name|malloc
argument_list|(
name|separation
operator|*
sizeof|sizeof
argument_list|(
name|linebufs_t
argument_list|)
operator|*
name|horizontal_passes
argument_list|)
expr_stmt|;
name|passes
operator|=
name|malloc
argument_list|(
name|separation
operator|*
sizeof|sizeof
argument_list|(
name|pass_t
argument_list|)
argument_list|)
expr_stmt|;
name|linecounts
operator|=
name|malloc
argument_list|(
name|separation
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bufbase
operator|=
name|linebufs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|separation
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|passes
index|[
name|i
index|]
operator|.
name|pass
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|horizontal_weave
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
name|linebases
index|[
name|i
operator|*
name|horizontal_weave
operator|+
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
name|bufbase
expr_stmt|;
name|bufbase
operator|+=
literal|1536
operator|*
name|jetsused
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|lineoff_t
modifier|*
DECL|function|get_lineoffsets (int row)
name|get_lineoffsets
parameter_list|(
name|int
name|row
parameter_list|)
block|{
return|return
operator|&
operator|(
name|lineoffsets
index|[
name|horizontal_weave
operator|*
operator|(
name|row
operator|%
name|separation
operator|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
DECL|function|get_linecount (int row)
name|get_linecount
parameter_list|(
name|int
name|row
parameter_list|)
block|{
return|return
operator|&
operator|(
name|linecounts
index|[
name|row
operator|%
name|separation
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|linebufs_t
modifier|*
DECL|function|get_linebases (int row)
name|get_linebases
parameter_list|(
name|int
name|row
parameter_list|)
block|{
return|return
operator|&
operator|(
name|linebases
index|[
name|horizontal_weave
operator|*
operator|(
name|row
operator|%
name|separation
operator|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pass_t
modifier|*
DECL|function|get_pass (int row_or_pass)
name|get_pass
parameter_list|(
name|int
name|row_or_pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|passes
index|[
name|row_or_pass
operator|%
name|separation
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the weave parameters for the given row.  This computation is  * rather complex, and I need to go back and write down very carefully  * what's going on here.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|weave_parameters_by_row (int row,weave_t * w)
name|weave_parameters_by_row
parameter_list|(
name|int
name|row
parameter_list|,
name|weave_t
modifier|*
name|w
parameter_list|)
block|{
name|int
name|passblockstart
init|=
operator|(
name|row
operator|+
name|initialoffset
operator|)
operator|/
name|jetsused
decl_stmt|;
name|int
name|internaljetsused
init|=
name|jetsused
decl_stmt|;
name|int
name|internallogicalpassstart
decl_stmt|;
name|w
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|w
operator|->
name|pass
operator|=
operator|(
name|passblockstart
operator|-
operator|(
name|separation
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
name|separation
operator|+
name|row
operator|-
name|passblockstart
operator|-
literal|1
operator|)
operator|%
name|separation
expr_stmt|;
name|internallogicalpassstart
operator|=
operator|(
name|w
operator|->
name|pass
operator|*
name|jetsused
operator|)
operator|-
name|initialoffset
operator|+
operator|(
name|w
operator|->
name|pass
operator|%
name|separation
operator|)
expr_stmt|;
if|if
condition|(
name|internallogicalpassstart
operator|<
literal|0
condition|)
block|{
name|internaljetsused
operator|-=
operator|(
operator|(
operator|(
name|separation
operator|-
literal|1
operator|)
operator|-
name|internallogicalpassstart
operator|)
operator|/
name|separation
operator|)
expr_stmt|;
name|internallogicalpassstart
operator|+=
name|separation
operator|*
operator|(
operator|(
operator|(
name|separation
operator|-
literal|1
operator|)
operator|-
name|internallogicalpassstart
operator|)
operator|/
name|separation
operator|)
expr_stmt|;
block|}
name|w
operator|->
name|logicalpassstart
operator|=
name|internallogicalpassstart
expr_stmt|;
name|w
operator|->
name|jet
operator|=
operator|(
operator|(
name|row
operator|-
name|w
operator|->
name|logicalpassstart
operator|)
operator|/
name|separation
operator|)
expr_stmt|;
if|if
condition|(
name|internallogicalpassstart
operator|>=
literal|0
condition|)
name|w
operator|->
name|physpassstart
operator|=
name|internallogicalpassstart
expr_stmt|;
else|else
name|w
operator|->
name|physpassstart
operator|=
name|internallogicalpassstart
operator|+
operator|(
name|separation
operator|*
operator|(
operator|(
name|separation
operator|-
name|internallogicalpassstart
operator|)
operator|/
name|separation
operator|)
operator|)
expr_stmt|;
name|w
operator|->
name|physpassend
operator|=
operator|(
name|internaljetsused
operator|-
literal|1
operator|)
operator|*
name|separation
operator|+
name|internallogicalpassstart
expr_stmt|;
name|w
operator|->
name|missingstartrows
operator|=
operator|(
name|w
operator|->
name|physpassstart
operator|-
name|w
operator|->
name|logicalpassstart
operator|)
operator|/
name|separation
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there are phantom rows at the beginning of a pass, fill them in so  * that the printer knows exactly what it doesn't have to print.  We're  * using RLE compression here.  Each line must be specified independently,  * so we have to compute how many full blocks (groups of 128 bytes, or 1024  * "off" pixels) and how much leftover is needed.  Note that we can only  * RLE-encode groups of 2 or more bytes; single bytes must be specified  * with a count of 1.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|fillin_start_rows (int row,int width,int missingstartrows)
name|fillin_start_rows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|missingstartrows
parameter_list|)
block|{
name|lineoff_t
modifier|*
name|offsets
init|=
name|get_lineoffsets
argument_list|(
name|row
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|m
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|missingstartrows
condition|;
name|k
operator|++
control|)
block|{
name|int
name|bytes_to_fill
init|=
name|width
decl_stmt|;
name|int
name|full_blocks
init|=
name|bytes_to_fill
operator|/
literal|1024
decl_stmt|;
name|int
name|leftover
init|=
operator|(
literal|7
operator|+
operator|(
name|bytes_to_fill
operator|%
literal|1024
operator|)
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|l
operator|<
name|full_blocks
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
block|{
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|129
expr_stmt|;
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|leftover
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
block|{
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|1
expr_stmt|;
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftover
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
block|{
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|257
operator|-
name|leftover
expr_stmt|;
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
name|offsets
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|2
operator|*
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|initialize_row (int row,int width)
name|initialize_row
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|physpassstart
operator|==
name|row
condition|)
block|{
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|int
modifier|*
name|linecount
init|=
name|get_linecount
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|pass_t
modifier|*
name|pass
init|=
name|get_pass
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|pass
operator|->
name|pass
operator|=
name|w
operator|.
name|pass
expr_stmt|;
name|pass
operator|->
name|missingstartrows
operator|=
name|w
operator|.
name|missingstartrows
expr_stmt|;
name|pass
operator|->
name|logicalpassstart
operator|=
name|w
operator|.
name|logicalpassstart
expr_stmt|;
name|pass
operator|->
name|physpassstart
operator|=
name|w
operator|.
name|physpassstart
expr_stmt|;
name|pass
operator|->
name|physpassend
operator|=
name|w
operator|.
name|physpassend
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|horizontal_weave
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
name|lineoffs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|linecount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|missingstartrows
operator|>
literal|0
condition|)
name|fillin_start_rows
argument_list|(
name|row
argument_list|,
name|width
argument_list|,
name|w
operator|.
name|missingstartrows
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * A fair bit of this code is duplicated from escp2_write.  That's rather  * a pity.  It's also not correct for any but the 6-color printers.  One of  * these days I'll unify it.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|flush_pass (int passno,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|flush_pass
parameter_list|(
name|int
name|passno
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets
argument_list|(
name|passno
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases
argument_list|(
name|passno
argument_list|)
decl_stmt|;
name|pass_t
modifier|*
name|pass
init|=
name|get_pass
argument_list|(
name|passno
argument_list|)
decl_stmt|;
name|int
modifier|*
name|linecount
init|=
name|get_linecount
argument_list|(
name|passno
argument_list|)
decl_stmt|;
name|int
name|lwidth
init|=
operator|(
name|width
operator|+
operator|(
name|horizontal_weave
operator|-
literal|1
operator|)
operator|)
operator|/
name|horizontal_weave
decl_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "Flushing pass %d start %d last %d\n", passno, pass->physpassstart, last_pass_offset);
endif|#
directive|endif
if|if
condition|(
name|pass
operator|->
name|physpassstart
operator|>
name|last_pass_offset
condition|)
block|{
name|int
name|advance
init|=
name|pass
operator|->
name|logicalpassstart
operator|-
name|last_pass_offset
decl_stmt|;
name|int
name|alo
init|=
name|advance
operator|%
literal|256
decl_stmt|;
name|int
name|ahi
init|=
name|advance
operator|/
literal|256
decl_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "  advancing %d lines\n", advance);
endif|#
directive|endif
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(v\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|alo
argument_list|,
name|ahi
argument_list|)
expr_stmt|;
name|last_pass_offset
operator|=
name|pass
operator|->
name|logicalpassstart
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|horizontal_weave
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lineoffs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(r\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* FIXME need a more general way of specifying column */
comment|/* separation */
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(\\%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|160
argument_list|,
literal|5
argument_list|,
operator|(
operator|(
name|hoffset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
operator|(
name|k
operator|&
operator|(
name|horizontal_weave
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|&
literal|255
argument_list|,
operator|(
operator|(
name|hoffset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
operator|(
name|k
operator|&
operator|(
name|horizontal_weave
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|densities
index|[
name|j
index|]
operator|>
literal|0
condition|)
continue|continue;
else|else
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|hoffset
operator|&
literal|255
argument_list|,
name|hoffset
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Raster graphics header */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033.\001\024\024\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033.\001\012\012\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033.%c%c%c%c"
argument_list|,
literal|1
argument_list|,
literal|8
operator|*
literal|5
argument_list|,
literal|5
argument_list|,
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_720DPI_MODE_MASK
argument_list|,
name|MODEL_720DPI_600
argument_list|)
condition|)
name|fwrite
argument_list|(
literal|"\033.\001\050\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fwrite
argument_list|(
literal|"\033.\001\005\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|lwidth
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|lwidth
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|bufs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|,
name|lineoffs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "Sending %d bytes, plane %d, density %d, lines %d, x %d\n", 		  lineoffs[k].v[j], colors[j], densities[j], 		  *linecount + pass->missingstartrows, k);
endif|#
directive|endif
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
literal|"\033\006"
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
name|last_pass
operator|=
name|pass
operator|->
name|pass
expr_stmt|;
name|pass
operator|->
name|pass
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|add_to_row (int row,unsigned char * buf,size_t nbytes,int plane,int density,int horizontal)
name|add_to_row
parameter_list|(
name|int
name|row
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|density
parameter_list|,
name|int
name|horizontal
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
name|color
init|=
name|get_color_by_params
argument_list|(
name|plane
argument_list|,
name|density
argument_list|)
decl_stmt|;
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets
argument_list|(
name|row
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bufs
index|[
name|horizontal
index|]
operator|.
name|v
index|[
name|color
index|]
operator|+
name|lineoffs
index|[
name|horizontal
index|]
operator|.
name|v
index|[
name|color
index|]
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|lineoffs
index|[
name|horizontal
index|]
operator|.
name|v
index|[
name|color
index|]
operator|+=
name|nbytes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|finalize_row (int row,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|finalize_row
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
modifier|*
name|lines
init|=
name|get_linecount
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lines
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|physpassend
operator|==
name|row
condition|)
block|{
name|pass_t
modifier|*
name|pass
init|=
name|get_pass
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|flush_pass
argument_list|(
name|pass
operator|->
name|pass
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_flush (int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|escp2_flush
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|pass_t
modifier|*
name|pass
init|=
name|get_pass
argument_list|(
name|last_pass
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pass
operator|->
name|pass
operator|<
literal|0
condition|)
return|return;
name|flush_pass
argument_list|(
name|pass
operator|->
name|pass
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_2 (int length,const unsigned char * in,unsigned char * outlo,unsigned char * outhi)
name|escp2_unpack_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
operator|*
name|in
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
block|{
operator|*
name|outlo
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|outhi
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|outlo
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
operator|*
name|outhi
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|outlo
operator|++
expr_stmt|;
name|outhi
operator|++
expr_stmt|;
block|}
name|in
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_4 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_unpack_4
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
operator|*
name|in
decl_stmt|;
switch|switch
condition|(
name|i
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|out0
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|out1
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
operator|*
name|out2
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
operator|*
name|out3
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|out0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
operator|*
name|out1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
name|out2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|out3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|out0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
operator|*
name|out1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
operator|*
name|out2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
operator|*
name|out3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|out0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|6
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
operator|*
name|out1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|5
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
operator|*
name|out2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
operator|*
name|out3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|out0
operator|++
expr_stmt|;
name|out1
operator|++
expr_stmt|;
name|out2
operator|++
expr_stmt|;
name|out3
operator|++
expr_stmt|;
break|break;
block|}
name|in
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_write_weave (FILE * prn,int length,int ydpi,int model,int width,int offset,int xdpi,unsigned char * c,unsigned char * m,unsigned char * y,unsigned char * k,unsigned char * C,unsigned char * M)
name|escp2_write_weave
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
name|unsigned
name|char
modifier|*
name|C
parameter_list|,
name|unsigned
name|char
modifier|*
name|M
parameter_list|)
block|{
specifier|static
name|int
name|lineno
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|s
index|[
literal|4
index|]
index|[
literal|1536
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|comp_buf
index|[
literal|1536
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|comp_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|initialize_row
argument_list|(
name|lineno
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|==
literal|2
condition|)
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|c
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|c
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|horizontal_weave
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
name|length
operator|+
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|horizontal_weave
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|c
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|==
literal|2
condition|)
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|m
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|m
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|horizontal_weave
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
name|length
operator|+
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|horizontal_weave
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|m
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|==
literal|2
condition|)
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|y
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|y
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|horizontal_weave
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
name|length
operator|+
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|horizontal_weave
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|y
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|==
literal|2
condition|)
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|k
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|k
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|horizontal_weave
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
name|length
operator|+
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|horizontal_weave
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|k
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|C
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|==
literal|2
condition|)
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|C
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|C
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|horizontal_weave
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
name|length
operator|+
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|horizontal_weave
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|C
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|M
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|horizontal_weave
operator|==
literal|2
condition|)
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|M
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|M
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|horizontal_weave
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
name|length
operator|+
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|horizontal_weave
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|M
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|finalize_row
argument_list|(
name|lineno
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|offset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

