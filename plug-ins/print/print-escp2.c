begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in EPSON ESC/P2 driver for the GIMP.  *  *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   escp2_parameters()     - Return the parameter values for the given  *                            parameter.  *   escp2_imageable_area() - Return the imageable area of the page.  *   escp2_print()          - Print an image to an EPSON printer.  *   escp2_write()          - Send 6-color ESC/P2 graphics using TIFF packbits compression.  *  * Revision History:  *  *   See ChangeLog  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WEAVETEST
end_ifndef

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SIGNAL
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
DECL|macro|inline
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_comment
comment|/*#include<endian.h>*/
end_comment

begin_typedef
DECL|enum|__anon2a95129a0103
typedef|typedef
enum|enum
block|{
DECL|enumerator|COLOR_MONOCHROME
name|COLOR_MONOCHROME
block|,
DECL|enumerator|COLOR_CMYK
name|COLOR_CMYK
block|,
DECL|enumerator|COLOR_CCMMYK
name|COLOR_CCMMYK
DECL|typedef|colormode_t
block|}
name|colormode_t
typedef|;
end_typedef

begin_comment
comment|/*  * Mapping between color and linear index.  The colors are  * black, magenta, cyan, yellow, light magenta, light cyan  */
end_comment

begin_decl_stmt
DECL|variable|color_indices
specifier|static
specifier|const
name|int
name|color_indices
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|4
block|,
literal|5
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|colors
specifier|static
specifier|const
name|int
name|colors
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|densities
specifier|static
specifier|const
name|int
name|densities
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WEAVETEST
end_ifndef

begin_function_decl
specifier|static
name|void
name|escp2_write_microweave
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|initialize_weave
parameter_list|(
name|int
name|jets
parameter_list|,
name|int
name|separation
parameter_list|,
name|int
name|oversample
parameter_list|,
name|int
name|horizontal
parameter_list|,
name|int
name|vertical
parameter_list|,
name|colormode_t
name|colormode
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|linewidth
parameter_list|,
name|int
name|lineheight
parameter_list|,
name|int
name|vertical_row_separation
parameter_list|,
name|int
name|first_line
parameter_list|,
name|int
name|phys_lines
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_flush_all
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_write_weave
parameter_list|(
name|void
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|C
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|M
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_init_microweave
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_free_microweave
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_weave
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * We really need to get away from this silly static nonsense...  */
end_comment

begin_define
DECL|macro|PHYSICAL_BPI
define|#
directive|define
name|PHYSICAL_BPI
value|720
end_define

begin_define
DECL|macro|MAX_OVERSAMPLED
define|#
directive|define
name|MAX_OVERSAMPLED
value|4
end_define

begin_define
DECL|macro|MAX_BPP
define|#
directive|define
name|MAX_BPP
value|2
end_define

begin_define
DECL|macro|BITS_PER_BYTE
define|#
directive|define
name|BITS_PER_BYTE
value|8
end_define

begin_define
DECL|macro|COMPBUFWIDTH
define|#
directive|define
name|COMPBUFWIDTH
value|(PHYSICAL_BPI * MAX_OVERSAMPLED * MAX_BPP * \ 	MAX_CARRIAGE_WIDTH / BITS_PER_BYTE)
end_define

begin_comment
comment|/*  * Printer capabilities.  *  * Various classes of printer capabilities are represented by bitmasks.  */
end_comment

begin_typedef
DECL|typedef|model_cap_t
typedef|typedef
name|unsigned
name|long
name|long
name|model_cap_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|model_featureset_t
typedef|typedef
name|unsigned
name|long
name|long
name|model_featureset_t
typedef|;
end_typedef

begin_comment
comment|/*  * For each printer, we can select from a variety of dot sizes.  * For single dot size printers, the available sizes are usually 0,  * which is the "default", and some subset of 1-4.  For simple variable  * dot size printers (with only one kind of variable dot size), the  * variable dot size is specified as 0x10.  For newer printers, there  * is a choice of variable dot sizes available, 0x10, 0x11, and 0x12 in  * order of increasing size.  *  * Normally, we want to specify the smallest dot size that lets us achieve  * a density of less than .8 or thereabouts (above that we start to get  * some dither artifacts).  This needs to be tested for each printer and  * resolution.  *  * An entry of -1 in a slot means that this resolution is not available.  */
end_comment

begin_typedef
DECL|struct|escp2_dot_sizes
typedef|typedef
struct|struct
name|escp2_dot_sizes
block|{
DECL|member|dot_180
name|int
name|dot_180
decl_stmt|;
DECL|member|dot_360_microweave
name|int
name|dot_360_microweave
decl_stmt|;
DECL|member|dot_360
name|int
name|dot_360
decl_stmt|;
DECL|member|dot_720_microweave
name|int
name|dot_720_microweave
decl_stmt|;
DECL|member|dot_720
name|int
name|dot_720
decl_stmt|;
DECL|member|dot_1440_microweave
name|int
name|dot_1440_microweave
decl_stmt|;
DECL|member|dot_1440
name|int
name|dot_1440
decl_stmt|;
DECL|typedef|escp2_dot_size_t
block|}
name|escp2_dot_size_t
typedef|;
end_typedef

begin_comment
comment|/*  * Specify the base density for each available resolution.  * This obviously depends upon the dot size.  Experience suggests that  * variable dot size mode (0x10) on the 870 requires the density  * derived from the printer base and the resolution to be multiplied  * by 3.3.  Using dot size 0x11 requires the density to be multiplied  * by 2.2.  */
end_comment

begin_typedef
DECL|struct|escp2_densities
typedef|typedef
struct|struct
name|escp2_densities
block|{
DECL|member|d_180_180
name|double
name|d_180_180
decl_stmt|;
DECL|member|d_360_360_micro
name|double
name|d_360_360_micro
decl_stmt|;
DECL|member|d_360_360
name|double
name|d_360_360
decl_stmt|;
DECL|member|d_720_720_micro
name|double
name|d_720_720_micro
decl_stmt|;
DECL|member|d_720_720
name|double
name|d_720_720
decl_stmt|;
DECL|member|d_1440_720_micro
name|double
name|d_1440_720_micro
decl_stmt|;
DECL|member|d_1440_720
name|double
name|d_1440_720
decl_stmt|;
DECL|member|d_1440_1440
name|double
name|d_1440_1440
decl_stmt|;
DECL|member|d_1440_2880
name|double
name|d_1440_2880
decl_stmt|;
DECL|typedef|escp2_densities_t
block|}
name|escp2_densities_t
typedef|;
end_typedef

begin_comment
comment|/*  * Definition of the multi-level inks available to a given printer.  * Each printer may use a different kind of ink droplet for variable  * and single drop size for each supported horizontal resolution and  * type of ink (4 or 6 color).  *  * Recall that 6 color ink is treated as simply another kind of  * multi-level ink, but the driver offers the user a choice of 4 and  * 6 color ink, so we need to define appropriate inksets for both  * kinds of ink.  *  * Stuff like the MIS 4 and 6 "color" monochrome inks doesn't fit into  * this model very nicely, so we'll either have to special case it  * or find some way of handling it in here.  */
end_comment

begin_typedef
DECL|struct|escp2_variable_ink
typedef|typedef
struct|struct
name|escp2_variable_ink
block|{
DECL|member|range
name|simple_dither_range_t
modifier|*
name|range
decl_stmt|;
DECL|member|count
name|int
name|count
decl_stmt|;
DECL|member|density
name|double
name|density
decl_stmt|;
DECL|typedef|escp2_variable_ink_t
block|}
name|escp2_variable_ink_t
typedef|;
end_typedef

begin_typedef
DECL|struct|escp2_variable_inkset
typedef|typedef
struct|struct
name|escp2_variable_inkset
block|{
DECL|member|c
name|escp2_variable_ink_t
modifier|*
name|c
decl_stmt|;
DECL|member|m
name|escp2_variable_ink_t
modifier|*
name|m
decl_stmt|;
DECL|member|y
name|escp2_variable_ink_t
modifier|*
name|y
decl_stmt|;
DECL|member|k
name|escp2_variable_ink_t
modifier|*
name|k
decl_stmt|;
DECL|typedef|escp2_variable_inkset_t
block|}
name|escp2_variable_inkset_t
typedef|;
end_typedef

begin_typedef
DECL|struct|escp2_variable_inklist
typedef|typedef
struct|struct
name|escp2_variable_inklist
block|{
DECL|member|s_180_4
name|escp2_variable_inkset_t
modifier|*
name|s_180_4
decl_stmt|;
DECL|member|s_360_4
name|escp2_variable_inkset_t
modifier|*
name|s_360_4
decl_stmt|;
DECL|member|s_720_4
name|escp2_variable_inkset_t
modifier|*
name|s_720_4
decl_stmt|;
DECL|member|s_1440_4
name|escp2_variable_inkset_t
modifier|*
name|s_1440_4
decl_stmt|;
DECL|member|s_180_6
name|escp2_variable_inkset_t
modifier|*
name|s_180_6
decl_stmt|;
DECL|member|s_360_6
name|escp2_variable_inkset_t
modifier|*
name|s_360_6
decl_stmt|;
DECL|member|s_720_6
name|escp2_variable_inkset_t
modifier|*
name|s_720_6
decl_stmt|;
DECL|member|s_1440_6
name|escp2_variable_inkset_t
modifier|*
name|s_1440_6
decl_stmt|;
DECL|member|v_180_4
name|escp2_variable_inkset_t
modifier|*
name|v_180_4
decl_stmt|;
DECL|member|v_360_4
name|escp2_variable_inkset_t
modifier|*
name|v_360_4
decl_stmt|;
DECL|member|v_720_4
name|escp2_variable_inkset_t
modifier|*
name|v_720_4
decl_stmt|;
DECL|member|v_1440_4
name|escp2_variable_inkset_t
modifier|*
name|v_1440_4
decl_stmt|;
DECL|member|v_180_6
name|escp2_variable_inkset_t
modifier|*
name|v_180_6
decl_stmt|;
DECL|member|v_360_6
name|escp2_variable_inkset_t
modifier|*
name|v_360_6
decl_stmt|;
DECL|member|v_720_6
name|escp2_variable_inkset_t
modifier|*
name|v_720_6
decl_stmt|;
DECL|member|v_1440_6
name|escp2_variable_inkset_t
modifier|*
name|v_1440_6
decl_stmt|;
DECL|typedef|escp2_variable_inklist_t
block|}
name|escp2_variable_inklist_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|photo_dither_ranges
specifier|static
name|simple_dither_range_t
name|photo_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.33
block|,
literal|0x1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|1.0
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_ink
specifier|static
name|escp2_variable_ink_t
name|photo_ink
init|=
block|{
name|photo_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|photo_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|.75
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_6pl_dither_ranges
specifier|static
name|simple_dither_range_t
name|photo_6pl_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.15
block|,
literal|0x1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0.227
block|,
literal|0x2
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/*  { 0.333, 0x3, 0, 3 }, */
block|{
literal|0.45
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.68
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_6pl_ink
specifier|static
name|escp2_variable_ink_t
name|photo_6pl_ink
init|=
block|{
name|photo_6pl_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|photo_6pl_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_4pl_dither_ranges
specifier|static
name|simple_dither_range_t
name|photo_4pl_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.15
block|,
literal|0x1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0.227
block|,
literal|0x2
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/*  { 0.333, 0x3, 0, 3 }, */
block|{
literal|0.45
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.68
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_4pl_ink
specifier|static
name|escp2_variable_ink_t
name|photo_4pl_ink
init|=
block|{
name|photo_4pl_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|photo_4pl_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_6pl_dither_ranges
specifier|static
name|simple_dither_range_t
name|standard_6pl_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.45
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.68
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_6pl_ink
specifier|static
name|escp2_variable_ink_t
name|standard_6pl_ink
init|=
block|{
name|standard_6pl_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|standard_6pl_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_4pl_dither_ranges
specifier|static
name|simple_dither_range_t
name|standard_4pl_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.45
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.68
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_4pl_ink
specifier|static
name|escp2_variable_ink_t
name|standard_4pl_ink
init|=
block|{
name|standard_4pl_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|standard_4pl_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_3pl_dither_ranges
specifier|static
name|simple_dither_range_t
name|standard_3pl_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.45
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.68
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_3pl_ink
specifier|static
name|escp2_variable_ink_t
name|standard_3pl_ink
init|=
block|{
name|standard_3pl_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|standard_3pl_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_multishot_dither_ranges
specifier|static
name|simple_dither_range_t
name|photo_multishot_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.1097
block|,
literal|0x1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0.227
block|,
literal|0x2
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/*  { 0.333, 0x3, 0, 3 }, */
block|{
literal|0.28
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.58
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|0.85
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_multishot_ink
specifier|static
name|escp2_variable_ink_t
name|photo_multishot_ink
init|=
block|{
name|photo_multishot_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|photo_multishot_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_multishot_dither_ranges
specifier|static
name|simple_dither_range_t
name|standard_multishot_dither_ranges
index|[]
init|=
block|{
block|{
literal|0.28
block|,
literal|0x1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0.58
block|,
literal|0x2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|0.85
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|1.0
block|,
literal|0x3
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_multishot_ink
specifier|static
name|escp2_variable_ink_t
name|standard_multishot_ink
init|=
block|{
name|standard_multishot_dither_ranges
block|,
sizeof|sizeof
argument_list|(
name|standard_multishot_dither_ranges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|simple_dither_range_t
argument_list|)
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|mis_sixtone_ranges
specifier|static
name|simple_dither_range_t
name|mis_sixtone_ranges
index|[]
init|=
block|{
block|{
literal|0.15
block|,
literal|0x01
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* LC */
block|{
literal|0.25
block|,
literal|0x02
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* C */
block|{
literal|0.45
block|,
literal|0x04
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* LM */
block|{
literal|0.50
block|,
literal|0x08
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* Y */
block|{
literal|0.75
block|,
literal|0x10
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* M */
block|{
literal|1.00
block|,
literal|0x20
block|,
literal|1
block|,
literal|1
block|}
comment|/* K */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|standard_inks
specifier|static
name|escp2_variable_inkset_t
name|standard_inks
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photo_inks
specifier|static
name|escp2_variable_inkset_t
name|photo_inks
init|=
block|{
operator|&
name|photo_ink
block|,
operator|&
name|photo_ink
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_6pl_standard_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_6pl_standard_inks
init|=
block|{
operator|&
name|standard_6pl_ink
block|,
operator|&
name|standard_6pl_ink
block|,
operator|&
name|standard_6pl_ink
block|,
operator|&
name|standard_6pl_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_6pl_photo_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_6pl_photo_inks
init|=
block|{
operator|&
name|photo_6pl_ink
block|,
operator|&
name|photo_6pl_ink
block|,
operator|&
name|standard_6pl_ink
block|,
operator|&
name|standard_6pl_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_4pl_standard_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_4pl_standard_inks
init|=
block|{
operator|&
name|standard_4pl_ink
block|,
operator|&
name|standard_4pl_ink
block|,
operator|&
name|standard_4pl_ink
block|,
operator|&
name|standard_4pl_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_4pl_photo_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_4pl_photo_inks
init|=
block|{
operator|&
name|photo_4pl_ink
block|,
operator|&
name|photo_4pl_ink
block|,
operator|&
name|standard_4pl_ink
block|,
operator|&
name|standard_4pl_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_3pl_standard_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_3pl_standard_inks
init|=
block|{
operator|&
name|standard_3pl_ink
block|,
operator|&
name|standard_3pl_ink
block|,
operator|&
name|standard_3pl_ink
block|,
operator|&
name|standard_3pl_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_multishot_standard_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_multishot_standard_inks
init|=
block|{
operator|&
name|standard_multishot_ink
block|,
operator|&
name|standard_multishot_ink
block|,
operator|&
name|standard_multishot_ink
block|,
operator|&
name|standard_multishot_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|escp2_multishot_photo_inks
specifier|static
name|escp2_variable_inkset_t
name|escp2_multishot_photo_inks
init|=
block|{
operator|&
name|photo_multishot_ink
block|,
operator|&
name|photo_multishot_ink
block|,
operator|&
name|standard_multishot_ink
block|,
operator|&
name|standard_multishot_ink
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|simple_4color_inks
specifier|static
name|escp2_variable_inklist_t
name|simple_4color_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|simple_6color_inks
specifier|static
name|escp2_variable_inklist_t
name|simple_6color_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|variable_6pl_4color_inks
specifier|static
name|escp2_variable_inklist_t
name|variable_6pl_4color_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_6pl_standard_inks
block|,
operator|&
name|escp2_6pl_standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|variable_6pl_6color_inks
specifier|static
name|escp2_variable_inklist_t
name|variable_6pl_6color_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_6pl_standard_inks
block|,
operator|&
name|escp2_6pl_standard_inks
block|,
operator|&
name|escp2_multishot_photo_inks
block|,
operator|&
name|escp2_multishot_photo_inks
block|,
operator|&
name|escp2_6pl_photo_inks
block|,
operator|&
name|escp2_6pl_photo_inks
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|variable_3pl_inks
specifier|static
name|escp2_variable_inklist_t
name|variable_3pl_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_3pl_standard_inks
block|,
operator|&
name|escp2_3pl_standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|variable_4pl_4color_inks
specifier|static
name|escp2_variable_inklist_t
name|variable_4pl_4color_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_6pl_standard_inks
block|,
operator|&
name|escp2_4pl_standard_inks
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|variable_4pl_6color_inks
specifier|static
name|escp2_variable_inklist_t
name|variable_4pl_6color_inks
init|=
block|{
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|standard_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|photo_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_multishot_standard_inks
block|,
operator|&
name|escp2_6pl_standard_inks
block|,
operator|&
name|escp2_4pl_standard_inks
block|,
operator|&
name|escp2_multishot_photo_inks
block|,
operator|&
name|escp2_multishot_photo_inks
block|,
operator|&
name|escp2_6pl_photo_inks
block|,
operator|&
name|escp2_4pl_photo_inks
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|escp2_printer
typedef|typedef
struct|struct
name|escp2_printer
block|{
DECL|member|flags
name|model_cap_t
name|flags
decl_stmt|;
comment|/* Bitmask of flags, see below */
DECL|member|nozzles
name|int
name|nozzles
decl_stmt|;
comment|/* Number of nozzles per color */
DECL|member|nozzle_separation
name|int
name|nozzle_separation
decl_stmt|;
comment|/* Separation between rows, in 1/720" */
DECL|member|black_nozzles
name|int
name|black_nozzles
decl_stmt|;
comment|/* Number of black nozzles (may be extra) */
DECL|member|xres
name|int
name|xres
decl_stmt|;
comment|/* Normal distance between dots in */
comment|/* softweave mode (inverse inches) */
DECL|member|max_paper_width
name|int
name|max_paper_width
decl_stmt|;
comment|/* Maximum paper width, in points*/
DECL|member|max_paper_height
name|int
name|max_paper_height
decl_stmt|;
comment|/* Maximum paper height, in points */
DECL|member|left_margin
name|int
name|left_margin
decl_stmt|;
comment|/* Left margin, points */
DECL|member|right_margin
name|int
name|right_margin
decl_stmt|;
comment|/* Right margin, points */
DECL|member|top_margin
name|int
name|top_margin
decl_stmt|;
comment|/* Absolute top margin, points */
DECL|member|bottom_margin
name|int
name|bottom_margin
decl_stmt|;
comment|/* Absolute bottom margin, points */
DECL|member|separation_rows
name|int
name|separation_rows
decl_stmt|;
comment|/* Some printers require funky spacing */
comment|/* arguments in microweave mode. */
DECL|member|pseudo_separation_rows
name|int
name|pseudo_separation_rows
decl_stmt|;
comment|/* Some printers require funky */
comment|/* spacing arguments in softweave mode */
DECL|member|dot_sizes
name|escp2_dot_size_t
name|dot_sizes
decl_stmt|;
comment|/* Vector of dot sizes for resolutions */
DECL|member|densities
name|escp2_densities_t
name|densities
decl_stmt|;
comment|/* List of densities for each printer */
DECL|member|inks
name|escp2_variable_inklist_t
modifier|*
name|inks
decl_stmt|;
comment|/* Choices of inks for this printer */
DECL|typedef|escp2_printer_t
block|}
name|escp2_printer_t
typedef|;
end_typedef

begin_define
DECL|macro|MODEL_INIT_MASK
define|#
directive|define
name|MODEL_INIT_MASK
value|0xf
end_define

begin_define
DECL|macro|MODEL_INIT_STANDARD
define|#
directive|define
name|MODEL_INIT_STANDARD
value|0x0
end_define

begin_define
DECL|macro|MODEL_INIT_900
define|#
directive|define
name|MODEL_INIT_900
value|0x1
end_define

begin_define
DECL|macro|MODEL_HASBLACK_MASK
define|#
directive|define
name|MODEL_HASBLACK_MASK
value|0x10
end_define

begin_define
DECL|macro|MODEL_HASBLACK_YES
define|#
directive|define
name|MODEL_HASBLACK_YES
value|0x00
end_define

begin_define
DECL|macro|MODEL_HASBLACK_NO
define|#
directive|define
name|MODEL_HASBLACK_NO
value|0x10
end_define

begin_define
DECL|macro|MODEL_6COLOR_MASK
define|#
directive|define
name|MODEL_6COLOR_MASK
value|0x20
end_define

begin_define
DECL|macro|MODEL_6COLOR_NO
define|#
directive|define
name|MODEL_6COLOR_NO
value|0x00
end_define

begin_define
DECL|macro|MODEL_6COLOR_YES
define|#
directive|define
name|MODEL_6COLOR_YES
value|0x20
end_define

begin_define
DECL|macro|MODEL_1440DPI_MASK
define|#
directive|define
name|MODEL_1440DPI_MASK
value|0x40
end_define

begin_define
DECL|macro|MODEL_1440DPI_NO
define|#
directive|define
name|MODEL_1440DPI_NO
value|0x00
end_define

begin_define
DECL|macro|MODEL_1440DPI_YES
define|#
directive|define
name|MODEL_1440DPI_YES
value|0x40
end_define

begin_define
DECL|macro|MODEL_GRAYMODE_MASK
define|#
directive|define
name|MODEL_GRAYMODE_MASK
value|0x80
end_define

begin_define
DECL|macro|MODEL_GRAYMODE_NO
define|#
directive|define
name|MODEL_GRAYMODE_NO
value|0x00
end_define

begin_define
DECL|macro|MODEL_GRAYMODE_YES
define|#
directive|define
name|MODEL_GRAYMODE_YES
value|0x80
end_define

begin_define
DECL|macro|MODEL_720DPI_MODE_MASK
define|#
directive|define
name|MODEL_720DPI_MODE_MASK
value|0x300
end_define

begin_define
DECL|macro|MODEL_720DPI_DEFAULT
define|#
directive|define
name|MODEL_720DPI_DEFAULT
value|0x000
end_define

begin_define
DECL|macro|MODEL_720DPI_600
define|#
directive|define
name|MODEL_720DPI_600
value|0x100
end_define

begin_define
DECL|macro|MODEL_VARIABLE_DOT_MASK
define|#
directive|define
name|MODEL_VARIABLE_DOT_MASK
value|0xc00
end_define

begin_define
DECL|macro|MODEL_VARIABLE_NORMAL
define|#
directive|define
name|MODEL_VARIABLE_NORMAL
value|0x000
end_define

begin_define
DECL|macro|MODEL_VARIABLE_4
define|#
directive|define
name|MODEL_VARIABLE_4
value|0x400
end_define

begin_define
DECL|macro|MODEL_VARIABLE_MULTI
define|#
directive|define
name|MODEL_VARIABLE_MULTI
value|0x800
end_define

begin_define
DECL|macro|MODEL_COMMAND_MASK
define|#
directive|define
name|MODEL_COMMAND_MASK
value|0xf000
end_define

begin_define
DECL|macro|MODEL_COMMAND_GENERIC
define|#
directive|define
name|MODEL_COMMAND_GENERIC
value|0x0000
end_define

begin_define
DECL|macro|MODEL_COMMAND_1998
define|#
directive|define
name|MODEL_COMMAND_1998
value|0x1000
end_define

begin_define
DECL|macro|MODEL_COMMAND_1999
define|#
directive|define
name|MODEL_COMMAND_1999
value|0x2000
end_define

begin_comment
DECL|macro|MODEL_COMMAND_1999
comment|/* The 1999 series printers */
end_comment

begin_define
DECL|macro|MODEL_INK_MASK
define|#
directive|define
name|MODEL_INK_MASK
value|0x10000
end_define

begin_define
DECL|macro|MODEL_INK_NORMAL
define|#
directive|define
name|MODEL_INK_NORMAL
value|0x00000
end_define

begin_define
DECL|macro|MODEL_INK_SELECTABLE
define|#
directive|define
name|MODEL_INK_SELECTABLE
value|0x10000
end_define

begin_define
DECL|macro|MODEL_ROLLFEED_MASK
define|#
directive|define
name|MODEL_ROLLFEED_MASK
value|0x20000
end_define

begin_define
DECL|macro|MODEL_ROLLFEED_NO
define|#
directive|define
name|MODEL_ROLLFEED_NO
value|0x00000
end_define

begin_define
DECL|macro|MODEL_ROLLFEED_YES
define|#
directive|define
name|MODEL_ROLLFEED_YES
value|0x20000
end_define

begin_define
DECL|macro|MODEL_ZEROMARGIN_MASK
define|#
directive|define
name|MODEL_ZEROMARGIN_MASK
value|0x40000
end_define

begin_define
DECL|macro|MODEL_ZEROMARGIN_NO
define|#
directive|define
name|MODEL_ZEROMARGIN_NO
value|0x00000
end_define

begin_define
DECL|macro|MODEL_ZEROMARGIN_YES
define|#
directive|define
name|MODEL_ZEROMARGIN_YES
value|0x40000
end_define

begin_define
DECL|macro|INCH (x)
define|#
directive|define
name|INCH
parameter_list|(
name|x
parameter_list|)
value|(72 * x)
end_define

begin_decl_stmt
DECL|variable|model_capabilities
specifier|static
name|escp2_printer_t
name|model_capabilities
index|[]
init|=
block|{
comment|/* FIRST GENERATION PRINTERS */
comment|/* 0: Stylus Color */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|14
block|,
literal|14
block|,
literal|9
block|,
literal|49
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.568
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 1: Stylus Color Pro/Pro XL/400/500 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|48
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|14
block|,
literal|14
block|,
literal|0
block|,
literal|24
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.631
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 2: Stylus Color 1500 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_NO
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|11
argument_list|)
block|,
name|INCH
argument_list|(
literal|17
argument_list|)
block|,
literal|14
block|,
literal|14
block|,
literal|9
block|,
literal|49
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.631
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 3: Stylus Color 600 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|32
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|8
block|,
literal|9
block|,
literal|0
block|,
literal|24
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 4: Stylus Color 800 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|64
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|8
block|,
literal|9
block|,
literal|0
block|,
literal|24
block|,
literal|1
block|,
literal|4
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 5: Stylus Color 850 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|128
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|8
block|,
literal|9
block|,
literal|24
block|,
literal|24
block|,
literal|1
block|,
literal|4
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 6: Stylus Color 1520 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|1
block|,
literal|1
block|,
literal|128
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
argument_list|)
block|,
name|INCH
argument_list|(
literal|55
argument_list|)
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|49
block|,
literal|4
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|0
block|,
literal|.646
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* SECOND GENERATION PRINTERS */
comment|/* 7: Stylus Photo 700 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1998
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|32
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|24
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.775
block|,
literal|.775
block|,
literal|.387
block|,
literal|.387
block|,
literal|.193
block|,
literal|.0966
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* 8: Stylus Photo EX */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1998
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|32
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|11
argument_list|)
block|,
name|INCH
argument_list|(
literal|17
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|24
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.775
block|,
literal|.775
block|,
literal|.387
block|,
literal|.387
block|,
literal|.193
block|,
literal|.0966
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* 9: Stylus Photo */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1998
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|32
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|24
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* THIRD GENERATION PRINTERS */
comment|/* 10: Stylus Color 440/460 */
comment|/* Thorsten Schnier has confirmed that the separation is 8.  Why on */
comment|/* earth anyone would use 21 nozzles when designing a print head is */
comment|/* completely beyond me, but there you are... */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|21
block|,
literal|8
block|,
literal|64
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.900
block|,
literal|.900
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 11: Stylus Color 640 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|64
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.900
block|,
literal|.900
block|,
literal|.45
block|,
literal|.45
block|,
literal|.225
block|,
literal|.113
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 12: Stylus Color 740 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_4
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|144
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|11
argument_list|)
block|,
name|INCH
argument_list|(
literal|17
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
literal|0x11
block|,
literal|3
block|,
literal|0x10
block|,
literal|3
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.710
block|,
literal|.323
block|,
literal|.365
block|,
literal|.1825
block|,
literal|.0913
block|}
block|,
operator|&
name|variable_6pl_4color_inks
block|}
block|,
comment|/* 13: Stylus Color 900 */
comment|/* Still need to figure out density for 3 pl drops! */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_4
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|96
block|,
literal|2
block|,
literal|192
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|0x11
block|,
literal|1
block|,
literal|0x10
block|,
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.710
block|,
literal|.323
block|,
literal|.365
block|,
literal|.1825
block|,
literal|.0913
block|}
block|,
operator|&
name|variable_3pl_inks
block|}
block|,
comment|/* 14: Stylus Photo 750 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_4
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|48
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|0x11
block|,
literal|4
block|,
literal|0x10
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.710
block|,
literal|.323
block|,
literal|.365
block|,
literal|.1825
block|,
literal|.0913
block|}
block|,
operator|&
name|variable_6pl_6color_inks
block|}
block|,
comment|/* 15: Stylus Photo 1200 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_4
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|48
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|13
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|0x11
block|,
literal|4
block|,
literal|0x10
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.710
block|,
literal|.323
block|,
literal|.365
block|,
literal|.1825
block|,
literal|.0913
block|}
block|,
operator|&
name|variable_6pl_6color_inks
block|}
block|,
comment|/* 16: Stylus Color 860 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_MULTI
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|144
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0x12
block|,
literal|0
block|,
literal|0x11
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.431
block|,
literal|.710
block|,
literal|.216
block|,
literal|.533
block|,
literal|.2665
block|,
literal|.1333
block|}
block|,
operator|&
name|variable_4pl_4color_inks
block|}
block|,
comment|/* 17: Stylus Color 1160 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_MULTI
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|144
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|13
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0x12
block|,
literal|0
block|,
literal|0x11
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.431
block|,
literal|.710
block|,
literal|.216
block|,
literal|.533
block|,
literal|.2665
block|,
literal|.1333
block|}
block|,
operator|&
name|variable_4pl_4color_inks
block|}
block|,
comment|/* 18: Stylus Color 660 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1998
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|64
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|8
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 19: Stylus Color 760 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_MULTI
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|144
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0x12
block|,
literal|0
block|,
literal|0x11
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.431
block|,
literal|.710
block|,
literal|.216
block|,
literal|.533
block|,
literal|.2665
block|,
literal|.1333
block|}
block|,
operator|&
name|variable_4pl_4color_inks
block|}
block|,
comment|/* 20: Stylus Photo 720 (Australia) */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_4
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|32
block|,
literal|8
block|,
literal|48
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|0x11
block|,
literal|4
block|,
literal|0x10
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.710
block|,
literal|.323
block|,
literal|.365
block|,
literal|.1825
block|,
literal|.0913
block|}
block|,
operator|&
name|variable_6pl_6color_inks
block|}
block|,
comment|/* 21: Stylus Color 480 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_4
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|15
block|,
literal|8
block|,
literal|48
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|14
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
literal|0x11
block|,
literal|3
block|,
literal|0x10
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.710
block|,
literal|.323
block|,
literal|.365
block|,
literal|.1825
block|,
literal|.0913
block|}
block|,
operator|&
name|variable_6pl_4color_inks
block|}
block|,
comment|/* 22: Stylus Photo 870 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_MULTI
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_YES
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|48
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
literal|0x12
block|,
literal|2
block|,
literal|0x11
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.431
block|,
literal|.710
block|,
literal|.216
block|,
literal|.533
block|,
literal|.2665
block|,
literal|.1333
block|}
block|,
operator|&
name|variable_4pl_6color_inks
block|}
block|,
comment|/* 23: Stylus Photo 1270 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_MULTI
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_YES
operator|)
block|,
literal|48
block|,
literal|6
block|,
literal|48
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|13
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|4
block|,
literal|0x12
block|,
literal|2
block|,
literal|0x11
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.431
block|,
literal|.710
block|,
literal|.216
block|,
literal|.533
block|,
literal|.2665
block|,
literal|.1333
block|}
block|,
operator|&
name|variable_4pl_6color_inks
block|}
block|,
comment|/* 24: Stylus Color 3000 */
block|{
operator|(
name|MODEL_INIT_STANDARD
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_GENERIC
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|1
block|,
literal|1
block|,
literal|128
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
argument_list|)
block|,
name|INCH
argument_list|(
literal|55
argument_list|)
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|49
block|,
literal|4
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|0
block|,
literal|.646
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|&
name|simple_4color_inks
block|}
block|,
comment|/* 25: Stylus Color 670 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_MULTI
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_YES
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|48
block|,
literal|8
block|,
literal|144
block|,
literal|720
block|,
name|INCH
argument_list|(
literal|17
operator|/
literal|2
argument_list|)
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|8
block|,
block|{
operator|-
literal|1
block|,
literal|3
block|,
literal|0x12
block|,
literal|3
block|,
literal|0x11
block|,
operator|-
literal|1
block|,
literal|0x10
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.431
block|,
literal|.710
block|,
literal|.216
block|,
literal|.533
block|,
literal|.2665
block|,
literal|.1333
block|}
block|,
operator|&
name|variable_4pl_4color_inks
block|}
block|,
comment|/* 26: Stylus Pro 5000 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_NO
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|64
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|13
argument_list|)
block|,
name|INCH
argument_list|(
literal|1200
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* 27: Stylus Pro 7000 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|64
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|24
argument_list|)
block|,
name|INCH
argument_list|(
literal|1200
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* 28: Stylus Pro 7500 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_SELECTABLE
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|64
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|24
argument_list|)
block|,
name|INCH
argument_list|(
literal|1200
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* 29: Stylus Pro 9000 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_NORMAL
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|64
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
name|INCH
argument_list|(
literal|1200
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,
comment|/* 30: Stylus Pro 9500 */
block|{
operator|(
name|MODEL_INIT_900
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_INK_SELECTABLE
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_VARIABLE_NORMAL
operator||
name|MODEL_COMMAND_1999
operator||
name|MODEL_GRAYMODE_NO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_ROLLFEED_YES
operator||
name|MODEL_ZEROMARGIN_NO
operator|)
block|,
literal|64
block|,
literal|4
block|,
literal|64
block|,
literal|360
block|,
name|INCH
argument_list|(
literal|44
argument_list|)
block|,
name|INCH
argument_list|(
literal|1200
argument_list|)
block|,
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|0
block|,
block|{
operator|-
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|.646
block|,
literal|.646
block|,
literal|.323
block|,
literal|.323
block|,
literal|.1615
block|,
literal|.0808
block|}
block|,
operator|&
name|simple_6color_inks
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|escp_init
typedef|typedef
struct|struct
name|escp_init
block|{
DECL|member|model
name|int
name|model
decl_stmt|;
DECL|member|output_type
name|int
name|output_type
decl_stmt|;
DECL|member|ydpi
name|int
name|ydpi
decl_stmt|;
DECL|member|xdpi
name|int
name|xdpi
decl_stmt|;
DECL|member|use_softweave
name|int
name|use_softweave
decl_stmt|;
DECL|member|page_length
name|int
name|page_length
decl_stmt|;
DECL|member|page_width
name|int
name|page_width
decl_stmt|;
DECL|member|page_top
name|int
name|page_top
decl_stmt|;
DECL|member|page_bottom
name|int
name|page_bottom
decl_stmt|;
DECL|member|nozzles
name|int
name|nozzles
decl_stmt|;
DECL|member|nozzle_separation
name|int
name|nozzle_separation
decl_stmt|;
DECL|member|horizontal_passes
name|int
name|horizontal_passes
decl_stmt|;
DECL|member|vertical_passes
name|int
name|vertical_passes
decl_stmt|;
DECL|member|vertical_oversample
name|int
name|vertical_oversample
decl_stmt|;
DECL|member|bits
name|int
name|bits
decl_stmt|;
DECL|member|paper_type
specifier|const
name|char
modifier|*
name|paper_type
decl_stmt|;
DECL|typedef|escp_init_t
block|}
name|escp_init_t
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2a95129a0208
typedef|typedef
struct|struct
block|{
DECL|member|name
specifier|const
name|char
name|name
index|[
literal|65
index|]
decl_stmt|;
DECL|member|hres
name|int
name|hres
decl_stmt|;
DECL|member|vres
name|int
name|vres
decl_stmt|;
DECL|member|softweave
name|int
name|softweave
decl_stmt|;
DECL|member|vertical_passes
name|int
name|vertical_passes
decl_stmt|;
DECL|member|vertical_oversample
name|int
name|vertical_oversample
decl_stmt|;
DECL|typedef|res_t
block|}
name|res_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|escp2_reslist
specifier|static
specifier|const
name|res_t
name|escp2_reslist
index|[]
init|=
block|{
block|{
literal|"180 DPI"
block|,
literal|180
block|,
literal|180
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"360 DPI"
block|,
literal|360
block|,
literal|360
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"360 DPI Softweave"
block|,
literal|360
block|,
literal|360
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"360 DPI High Quality"
block|,
literal|360
block|,
literal|360
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI Microweave"
block|,
literal|720
block|,
literal|720
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI Softweave"
block|,
literal|720
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI High Quality"
block|,
literal|720
block|,
literal|720
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI Highest Quality"
block|,
literal|720
block|,
literal|720
block|,
literal|1
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
literal|"1440 x 720 DPI Microweave"
block|,
literal|1440
block|,
literal|720
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"1440 x 720 DPI Softweave"
block|,
literal|1440
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"1440 x 720 DPI Highest Quality"
block|,
literal|1440
block|,
literal|720
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"1440 x 1440 DPI Emulated"
block|,
literal|1440
block|,
literal|1440
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"1440 x 2880 DPI Emulated"
block|,
literal|1440
block|,
literal|2880
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|__anon2a95129a0308
typedef|typedef
struct|struct
block|{
DECL|member|name
specifier|const
name|char
name|name
index|[
literal|65
index|]
decl_stmt|;
DECL|member|is_color
name|int
name|is_color
decl_stmt|;
DECL|member|variable_dot_size
name|int
name|variable_dot_size
decl_stmt|;
DECL|member|dot_size_bits
name|int
name|dot_size_bits
decl_stmt|;
DECL|member|standard_dither
name|simple_dither_range_t
modifier|*
name|standard_dither
decl_stmt|;
DECL|member|photo_dither
name|simple_dither_range_t
modifier|*
name|photo_dither
decl_stmt|;
DECL|typedef|ink_t
block|}
name|ink_t
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2a95129a0408
typedef|typedef
struct|struct
block|{
DECL|member|name
specifier|const
name|char
name|name
index|[
literal|65
index|]
decl_stmt|;
DECL|member|paper_feed_sequence
name|int
name|paper_feed_sequence
decl_stmt|;
DECL|member|platen_gap
name|int
name|platen_gap
decl_stmt|;
DECL|typedef|paper_t
block|}
name|paper_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|escp2_paper_list
specifier|static
specifier|const
name|paper_t
name|escp2_paper_list
index|[]
init|=
block|{
block|{
literal|"Plain Paper"
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"Plain Paper Fast Load"
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|"Postcard"
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"Glossy Film"
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|"Transparencies"
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|"Envelopes"
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|"Back Light Film"
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|"Matte Paper"
block|,
literal|7
block|,
literal|0
block|}
block|,
block|{
literal|"Inkjet Paper"
block|,
literal|7
block|,
literal|0
block|}
block|,
block|{
literal|"Photo Quality Inkjet Paper"
block|,
literal|7
block|,
literal|0
block|}
block|,
block|{
literal|"Photo Paper"
block|,
literal|8
block|,
literal|0
block|}
block|,
block|{
literal|"Other"
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|paper_type_count
specifier|static
specifier|const
name|int
name|paper_type_count
init|=
sizeof|sizeof
argument_list|(
name|escp2_paper_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|paper_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|paper_t
modifier|*
DECL|function|get_media_type (const char * name)
name|get_media_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paper_type_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|escp2_paper_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
operator|&
operator|(
name|escp2_paper_list
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_has_cap (int model,model_featureset_t featureset,model_featureset_t class)
name|escp2_has_cap
parameter_list|(
name|int
name|model
parameter_list|,
name|model_featureset_t
name|featureset
parameter_list|,
name|model_featureset_t
name|class
parameter_list|)
block|{
return|return
operator|(
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|flags
operator|&
name|featureset
operator|)
operator|==
name|class
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_nozzles (int model)
name|escp2_nozzles
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|nozzles
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_black_nozzles (int model)
name|escp2_black_nozzles
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|black_nozzles
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_nozzle_separation (int model)
name|escp2_nozzle_separation
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|nozzle_separation
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_separation_rows (int model)
name|escp2_separation_rows
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|separation_rows
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_xres (int model)
name|escp2_xres
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|xres
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_ink_type (int model,int resolution,int microweave)
name|escp2_ink_type
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|resolution
parameter_list|,
name|int
name|microweave
parameter_list|)
block|{
if|if
condition|(
name|microweave
condition|)
block|{
switch|switch
condition|(
name|resolution
condition|)
block|{
case|case
literal|180
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_180
return|;
break|break;
case|case
literal|360
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_360_microweave
return|;
break|break;
case|case
literal|720
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_720_microweave
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_1440_microweave
return|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|resolution
condition|)
block|{
case|case
literal|180
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_180
return|;
break|break;
case|case
literal|360
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_360
return|;
break|break;
case|case
literal|720
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_720
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|dot_sizes
operator|.
name|dot_1440
return|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|double
DECL|function|escp2_density (int model,int xdpi,int ydpi,int microweave)
name|escp2_density
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|microweave
parameter_list|)
block|{
if|if
condition|(
name|microweave
condition|)
block|{
switch|switch
condition|(
name|xdpi
condition|)
block|{
case|case
literal|180
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_180_180
return|;
break|break;
case|case
literal|360
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_360_360_micro
return|;
break|break;
case|case
literal|720
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_720_720_micro
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_1440_720_micro
return|;
break|break;
block|}
block|}
switch|switch
condition|(
name|xdpi
condition|)
block|{
case|case
literal|180
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_180_180
return|;
break|break;
case|case
literal|360
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_360_360
return|;
break|break;
case|case
literal|720
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_720_720
return|;
break|break;
case|case
literal|1440
case|:
switch|switch
condition|(
name|ydpi
condition|)
block|{
case|case
literal|720
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_1440_720
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_1440_1440
return|;
break|break;
case|case
literal|2880
case|:
return|return
name|model_capabilities
index|[
name|model
index|]
operator|.
name|densities
operator|.
name|d_1440_2880
return|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|escp2_variable_inkset_t
modifier|*
DECL|function|escp2_inks (int model,int xdpi,int colors,int bits)
name|escp2_inks
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|int
name|colors
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|escp2_variable_inklist_t
modifier|*
name|inks
init|=
name|model_capabilities
index|[
name|model
index|]
operator|.
name|inks
decl_stmt|;
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|colors
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|4
case|:
switch|switch
condition|(
name|xdpi
condition|)
block|{
case|case
literal|180
case|:
return|return
name|inks
operator|->
name|s_180_4
return|;
break|break;
case|case
literal|360
case|:
return|return
name|inks
operator|->
name|s_360_4
return|;
break|break;
case|case
literal|720
case|:
return|return
name|inks
operator|->
name|s_720_4
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|inks
operator|->
name|s_1440_4
return|;
break|break;
block|}
case|case
literal|6
case|:
switch|switch
condition|(
name|xdpi
condition|)
block|{
case|case
literal|180
case|:
return|return
name|inks
operator|->
name|s_180_6
return|;
break|break;
case|case
literal|360
case|:
return|return
name|inks
operator|->
name|s_360_6
return|;
break|break;
case|case
literal|720
case|:
return|return
name|inks
operator|->
name|s_720_6
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|inks
operator|->
name|s_1440_6
return|;
break|break;
block|}
block|}
case|case
literal|2
case|:
switch|switch
condition|(
name|colors
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|4
case|:
switch|switch
condition|(
name|xdpi
condition|)
block|{
case|case
literal|180
case|:
return|return
name|inks
operator|->
name|v_180_4
return|;
break|break;
case|case
literal|360
case|:
return|return
name|inks
operator|->
name|v_360_4
return|;
break|break;
case|case
literal|720
case|:
return|return
name|inks
operator|->
name|v_720_4
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|inks
operator|->
name|v_1440_4
return|;
break|break;
block|}
case|case
literal|6
case|:
switch|switch
condition|(
name|xdpi
condition|)
block|{
case|case
literal|180
case|:
return|return
name|inks
operator|->
name|v_180_6
return|;
break|break;
case|case
literal|360
case|:
return|return
name|inks
operator|->
name|v_360_6
return|;
break|break;
case|case
literal|720
case|:
return|return
name|inks
operator|->
name|v_720_6
return|;
break|break;
case|case
literal|1440
case|:
return|return
name|inks
operator|->
name|v_1440_6
return|;
break|break;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_max_paper_width (int model)
name|escp2_max_paper_width
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|max_paper_width
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_max_paper_height (int model)
name|escp2_max_paper_height
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|max_paper_height
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_left_margin (int model)
name|escp2_left_margin
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|left_margin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_right_margin (int model)
name|escp2_right_margin
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|right_margin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_top_margin (int model)
name|escp2_top_margin
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|top_margin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
DECL|function|escp2_bottom_margin (int model)
name|escp2_bottom_margin
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|bottom_margin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_pseudo_separation_rows (int model)
name|escp2_pseudo_separation_rows
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|.
name|pseudo_separation_rows
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'escp2_parameters()' - Return the parameter values for the given parameter.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
comment|/* O - Parameter values */
DECL|function|escp2_parameters (const printer_t * printer,char * ppd_file,char * name,int * count)
name|escp2_parameters
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|printer
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|name
parameter_list|,
comment|/* I - Name of parameter */
name|int
modifier|*
name|count
parameter_list|)
comment|/* O - Number of values */
block|{
name|int
name|i
decl_stmt|;
name|int
name|model
init|=
name|printer
operator|->
name|model
decl_stmt|;
name|char
modifier|*
modifier|*
name|valptrs
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|ink_types
index|[]
init|=
block|{
literal|"Six Color Photo"
block|,
literal|"Four Color Standard"
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PageSize"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|length_limit
decl_stmt|,
name|width_limit
decl_stmt|;
specifier|const
name|papersize_t
modifier|*
name|papersizes
init|=
name|get_papersizes
argument_list|()
decl_stmt|;
name|valptrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|known_papersizes
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|width_limit
operator|=
name|escp2_max_paper_width
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|length_limit
operator|=
name|escp2_max_paper_height
argument_list|(
name|model
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|known_papersizes
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|papersizes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|>
literal|0
operator|&&
name|papersizes
index|[
name|i
index|]
operator|.
name|width
operator|<=
name|width_limit
operator|&&
name|papersizes
index|[
name|i
index|]
operator|.
name|length
operator|<=
name|length_limit
condition|)
block|{
name|valptrs
index|[
operator|*
name|count
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|papersizes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
operator|*
name|count
index|]
argument_list|,
name|papersizes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Resolution"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|res_t
modifier|*
name|res
init|=
operator|&
operator|(
name|escp2_reslist
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|valptrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|escp2_reslist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|res_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|res
operator|->
name|hres
condition|)
block|{
if|if
condition|(
name|escp2_ink_type
argument_list|(
name|model
argument_list|,
name|res
operator|->
name|hres
argument_list|,
operator|!
name|res
operator|->
name|softweave
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|nozzles
init|=
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
decl_stmt|;
name|int
name|separation
init|=
name|escp2_nozzle_separation
argument_list|(
name|model
argument_list|)
decl_stmt|;
name|int
name|max_weave
init|=
name|nozzles
operator|/
name|separation
decl_stmt|;
name|int
name|xdpi
init|=
name|res
operator|->
name|hres
decl_stmt|;
name|int
name|horizontal_passes
init|=
name|xdpi
operator|/
name|escp2_xres
argument_list|(
name|model
argument_list|)
decl_stmt|;
if|if
condition|(
name|horizontal_passes
operator|==
literal|0
condition|)
name|horizontal_passes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|horizontal_passes
operator|*
name|res
operator|->
name|vertical_passes
operator|)
operator|<=
literal|8
operator|)
operator|&&
operator|(
operator|!
name|res
operator|->
name|softweave
operator|||
operator|(
name|nozzles
operator|>
literal|1
operator|&&
name|res
operator|->
name|vertical_passes
operator|<=
name|max_weave
operator|)
operator|)
condition|)
block|{
name|valptrs
index|[
operator|*
name|count
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|res
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
operator|*
name|count
index|]
argument_list|,
name|res
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|res
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InkType"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_NO
argument_list|)
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|int
name|ninktypes
init|=
sizeof|sizeof
argument_list|(
name|ink_types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|valptrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|ninktypes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninktypes
condition|;
name|i
operator|++
control|)
block|{
name|valptrs
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ink_types
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
name|i
index|]
argument_list|,
name|ink_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|count
operator|=
name|ninktypes
expr_stmt|;
return|return
name|valptrs
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MediaType"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|nmediatypes
init|=
name|paper_type_count
decl_stmt|;
name|valptrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|nmediatypes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmediatypes
condition|;
name|i
operator|++
control|)
block|{
name|valptrs
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|escp2_paper_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
name|i
index|]
argument_list|,
name|escp2_paper_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|count
operator|=
name|nmediatypes
expr_stmt|;
return|return
name|valptrs
return|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'escp2_imageable_area()' - Return the imageable area of the page.  */
end_comment

begin_function
name|void
DECL|function|escp2_imageable_area (const printer_t * printer,const vars_t * v,int * left,int * right,int * bottom,int * top)
name|escp2_imageable_area
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|printer
parameter_list|,
comment|/* I - Printer model */
specifier|const
name|vars_t
modifier|*
name|v
parameter_list|,
comment|/* I */
name|int
modifier|*
name|left
parameter_list|,
comment|/* O - Left position in points */
name|int
modifier|*
name|right
parameter_list|,
comment|/* O - Right position in points */
name|int
modifier|*
name|bottom
parameter_list|,
comment|/* O - Bottom position in points */
name|int
modifier|*
name|top
parameter_list|)
comment|/* O - Top position in points */
block|{
name|int
name|width
decl_stmt|,
name|length
decl_stmt|;
comment|/* Size of page */
name|default_media_size
argument_list|(
name|printer
argument_list|,
name|v
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
operator|*
name|left
operator|=
name|escp2_left_margin
argument_list|(
name|printer
operator|->
name|model
argument_list|)
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
name|escp2_right_margin
argument_list|(
name|printer
operator|->
name|model
argument_list|)
expr_stmt|;
operator|*
name|top
operator|=
name|length
operator|-
name|escp2_top_margin
argument_list|(
name|printer
operator|->
name|model
argument_list|)
expr_stmt|;
operator|*
name|bottom
operator|=
name|escp2_bottom_margin
argument_list|(
name|printer
operator|->
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
DECL|function|escp2_limit (const printer_t * printer,const vars_t * v,int * width,int * length)
name|escp2_limit
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|printer
parameter_list|,
comment|/* I - Printer model */
specifier|const
name|vars_t
modifier|*
name|v
parameter_list|,
comment|/* I */
name|int
modifier|*
name|width
parameter_list|,
comment|/* O - Left position in points */
name|int
modifier|*
name|length
parameter_list|)
comment|/* O - Top position in points */
block|{
operator|*
name|width
operator|=
name|escp2_max_paper_width
argument_list|(
name|printer
operator|->
name|model
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|escp2_max_paper_height
argument_list|(
name|printer
operator|->
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
DECL|function|escp2_default_resolution (const printer_t * printer)
name|escp2_default_resolution
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|printer
parameter_list|)
block|{
specifier|const
name|res_t
modifier|*
name|res
init|=
operator|&
operator|(
name|escp2_reslist
index|[
literal|0
index|]
operator|)
decl_stmt|;
while|while
condition|(
name|res
operator|->
name|hres
condition|)
block|{
if|if
condition|(
name|escp2_ink_type
argument_list|(
name|printer
operator|->
name|model
argument_list|,
name|res
operator|->
name|hres
argument_list|,
operator|!
name|res
operator|->
name|softweave
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|nozzles
init|=
name|escp2_nozzles
argument_list|(
name|printer
operator|->
name|model
argument_list|)
decl_stmt|;
name|int
name|separation
init|=
name|escp2_nozzle_separation
argument_list|(
name|printer
operator|->
name|model
argument_list|)
decl_stmt|;
name|int
name|max_weave
init|=
name|nozzles
operator|/
name|separation
decl_stmt|;
name|int
name|xdpi
init|=
name|res
operator|->
name|hres
decl_stmt|;
name|int
name|horizontal_passes
init|=
name|xdpi
operator|/
name|escp2_xres
argument_list|(
name|printer
operator|->
name|model
argument_list|)
decl_stmt|;
if|if
condition|(
name|horizontal_passes
operator|==
literal|0
condition|)
name|horizontal_passes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|horizontal_passes
operator|*
name|res
operator|->
name|vertical_passes
operator|)
operator|<=
literal|8
operator|)
operator|&&
operator|(
operator|!
name|res
operator|->
name|softweave
operator|||
operator|(
name|nozzles
operator|>
literal|1
operator|&&
name|res
operator|->
name|vertical_passes
operator|<=
name|max_weave
operator|)
operator|)
condition|)
return|return
name|res
operator|->
name|name
return|;
block|}
name|res
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_reset_printer (FILE * prn,escp_init_t * init)
name|escp2_reset_printer
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
comment|/*    * Hack that seems to be necessary for these silly things to recognize    * the input.  It only needs to be done once per printer evidently, but    * it needs to be done.    */
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_INIT_MASK
argument_list|,
name|MODEL_INIT_900
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%c%c%c\033\001@EJL 1284.4\n@EJL     \n\033@"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_remote_sequence (FILE * prn,escp_init_t * init)
name|escp2_set_remote_sequence
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
comment|/* Magic remote mode commands, whatever they do */
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_COMMAND_MASK
argument_list|,
name|MODEL_COMMAND_1999
argument_list|)
condition|)
block|{
name|int
name|feed_sequence
init|=
literal|0
decl_stmt|;
specifier|const
name|paper_t
modifier|*
name|p
init|=
name|get_media_type
argument_list|(
name|init
operator|->
name|paper_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|feed_sequence
operator|=
name|p
operator|->
name|paper_feed_sequence
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
comment|/* Enter remote mode */
literal|"\033(R\010%c%cREMOTE1"
comment|/* Function unknown */
literal|"PM\002%c%c%c"
comment|/* Set mechanism sequence */
literal|"SN\003%c%c%c%c"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|feed_sequence
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_ZEROMARGIN_MASK
argument_list|,
name|MODEL_ZEROMARGIN_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
comment|/* Set zero-margin print mode */
literal|"FP\003%c%c\260\377"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
comment|/* Exit remote mode */
literal|"\033%c%c%c"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_graphics_mode (FILE * prn,escp_init_t * init)
name|escp2_set_graphics_mode
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
name|fwrite
argument_list|(
literal|"\033(G\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Enter graphics mode */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_resolution (FILE * prn,escp_init_t * init)
name|escp2_set_resolution
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
operator|)
operator|&&
name|init
operator|->
name|use_softweave
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(U\005%c%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
literal|1440
operator|/
name|init
operator|->
name|ydpi
argument_list|,
literal|1440
operator|/
name|init
operator|->
name|ydpi
argument_list|,
literal|1440
operator|/
operator|(
name|init
operator|->
name|ydpi
operator|*
operator|(
name|init
operator|->
name|horizontal_passes
operator|>
literal|2
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
argument_list|,
literal|1440
operator|%
literal|256
argument_list|,
literal|1440
operator|/
literal|256
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(U\001%c%c"
argument_list|,
literal|0
argument_list|,
literal|3600
operator|/
name|init
operator|->
name|ydpi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_color (FILE * prn,escp_init_t * init)
name|escp2_set_color
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_GRAYMODE_MASK
argument_list|,
name|MODEL_GRAYMODE_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(K\002%c%c%c"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|init
operator|->
name|output_type
operator|==
name|OUTPUT_GRAY
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_microweave (FILE * prn,escp_init_t * init)
name|escp2_set_microweave
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(i\001%c%c"
argument_list|,
literal|0
argument_list|,
operator|(
name|init
operator|->
name|use_softweave
operator|||
name|init
operator|->
name|ydpi
operator|<
literal|720
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_printhead_speed (FILE * prn,escp_init_t * init)
name|escp2_set_printhead_speed
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
operator|->
name|horizontal_passes
operator|*
name|init
operator|->
name|vertical_passes
operator|*
name|init
operator|->
name|vertical_oversample
operator|*
name|escp2_xres
argument_list|(
name|init
operator|->
name|model
argument_list|)
operator|/
literal|720
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033U%c"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|->
name|xdpi
operator|>
literal|720
condition|)
comment|/* Slow mode if available */
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(s%c%c%c"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033U%c"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_dot_size (FILE * prn,escp_init_t * init)
name|escp2_set_dot_size
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
comment|/* Dot size */
name|int
name|drop_size
init|=
name|escp2_ink_type
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|init
operator|->
name|xdpi
argument_list|,
operator|!
name|init
operator|->
name|use_softweave
argument_list|)
decl_stmt|;
if|if
condition|(
name|drop_size
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(e\002%c%c%c"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drop_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_page_length (FILE * prn,escp_init_t * init)
name|escp2_set_page_length
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
name|int
name|l
init|=
name|init
operator|->
name|ydpi
operator|*
name|init
operator|->
name|page_length
operator|/
literal|72
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
operator|)
operator|&&
name|init
operator|->
name|use_softweave
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(C\004%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
name|l
operator|&
literal|0xff
argument_list|,
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(C\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|l
operator|&
literal|255
argument_list|,
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_margins (FILE * prn,escp_init_t * init)
name|escp2_set_margins
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
name|int
name|l
init|=
name|init
operator|->
name|ydpi
operator|*
name|init
operator|->
name|page_length
operator|/
literal|72
decl_stmt|;
name|int
name|t
init|=
name|init
operator|->
name|ydpi
operator|*
name|init
operator|->
name|page_top
operator|/
literal|72
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
operator|)
operator|&&
name|init
operator|->
name|use_softweave
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(c\010%c%c%c%c%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
name|t
operator|&
literal|0xff
argument_list|,
name|t
operator|>>
literal|8
argument_list|,
operator|(
name|t
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|t
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
name|l
operator|&
literal|0xff
argument_list|,
name|l
operator|>>
literal|8
argument_list|,
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(c\004%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
name|t
operator|&
literal|0xff
argument_list|,
name|t
operator|>>
literal|8
argument_list|,
name|l
operator|&
literal|0xff
argument_list|,
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(c\004%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
name|t
operator|&
literal|0xff
argument_list|,
name|t
operator|>>
literal|8
argument_list|,
name|l
operator|&
literal|0xff
argument_list|,
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_form_factor (FILE * prn,escp_init_t * init)
name|escp2_set_form_factor
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
name|int
name|page_width
init|=
name|init
operator|->
name|page_width
operator|*
name|init
operator|->
name|ydpi
operator|/
literal|72
decl_stmt|;
name|int
name|page_length
init|=
name|init
operator|->
name|page_length
operator|*
name|init
operator|->
name|ydpi
operator|/
literal|72
decl_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_ZEROMARGIN_MASK
argument_list|,
name|MODEL_ZEROMARGIN_YES
argument_list|)
condition|)
comment|/* Make the page 2/10" wider (probably ignored by the printer anyway) */
name|page_width
operator|+=
literal|144
operator|*
literal|720
operator|/
name|init
operator|->
name|xdpi
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_COMMAND_MASK
argument_list|,
name|MODEL_COMMAND_1999
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(S\010%c%c%c%c%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|page_width
operator|>>
literal|0
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_width
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_width
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_width
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_length
operator|>>
literal|0
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_length
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_length
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|page_length
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_set_printhead_resolution (FILE * prn,escp_init_t * init)
name|escp2_set_printhead_resolution
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
operator|)
operator|&&
name|init
operator|->
name|use_softweave
condition|)
comment|/* Magic resolution cookie */
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(D%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|14400
operator|%
literal|256
argument_list|,
literal|14400
operator|/
literal|256
argument_list|,
name|escp2_nozzle_separation
argument_list|(
name|init
operator|->
name|model
argument_list|)
operator|*
literal|14400
operator|/
literal|720
argument_list|,
literal|14400
operator|/
name|escp2_xres
argument_list|(
name|init
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_init_printer (FILE * prn,escp_init_t * init)
name|escp2_init_printer
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
operator|->
name|ydpi
operator|>
literal|720
condition|)
name|init
operator|->
name|ydpi
operator|=
literal|720
expr_stmt|;
name|escp2_reset_printer
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_remote_sequence
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_graphics_mode
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_resolution
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_color
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_microweave
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_printhead_speed
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_dot_size
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_page_length
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_margins
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_form_factor
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|escp2_set_printhead_resolution
argument_list|(
name|prn
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_deinit_printer (FILE * prn,escp_init_t * init)
name|escp2_deinit_printer
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
name|escp_init_t
modifier|*
name|init
parameter_list|)
block|{
name|fputs
argument_list|(
comment|/* Eject page */
literal|"\014"
comment|/* ESC/P2 reset */
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|init
operator|->
name|model
argument_list|,
name|MODEL_COMMAND_MASK
argument_list|,
name|MODEL_COMMAND_1999
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
comment|/* Enter remote mode */
literal|"\033(R\010%c%cREMOTE1"
comment|/* Load settings from NVRAM */
literal|"LD%c%c"
comment|/* Exit remote mode */
literal|"\033%c%c%c"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'escp2_print()' - Print an image to an EPSON printer.  */
end_comment

begin_function
name|void
DECL|function|escp2_print (const printer_t * printer,int copies,FILE * prn,Image image,const vars_t * v)
name|escp2_print
parameter_list|(
specifier|const
name|printer_t
modifier|*
name|printer
parameter_list|,
comment|/* I - Model */
name|int
name|copies
parameter_list|,
comment|/* I - Number of copies */
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|Image
name|image
parameter_list|,
comment|/* I - Image to print */
specifier|const
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|cmap
init|=
name|v
operator|->
name|cmap
decl_stmt|;
name|int
name|model
init|=
name|printer
operator|->
name|model
decl_stmt|;
name|char
modifier|*
name|resolution
init|=
name|v
operator|->
name|resolution
decl_stmt|;
name|char
modifier|*
name|media_type
init|=
name|v
operator|->
name|media_type
decl_stmt|;
name|int
name|output_type
init|=
name|v
operator|->
name|output_type
decl_stmt|;
name|int
name|orientation
init|=
name|v
operator|->
name|orientation
decl_stmt|;
name|char
modifier|*
name|ink_type
init|=
name|v
operator|->
name|ink_type
decl_stmt|;
name|float
name|scaling
init|=
name|v
operator|->
name|scaling
decl_stmt|;
name|int
name|top
init|=
name|v
operator|->
name|top
decl_stmt|;
name|int
name|left
init|=
name|v
operator|->
name|left
decl_stmt|;
name|int
name|y
decl_stmt|;
comment|/* Looping vars */
name|int
name|xdpi
decl_stmt|,
name|ydpi
decl_stmt|;
comment|/* Resolution */
name|int
name|physical_ydpi
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Output number */
name|unsigned
name|short
modifier|*
name|out
decl_stmt|;
comment|/* Output pixels (16-bit) */
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
comment|/* Input pixels */
modifier|*
name|black
decl_stmt|,
comment|/* Black bitmap data */
modifier|*
name|cyan
decl_stmt|,
comment|/* Cyan bitmap data */
modifier|*
name|magenta
decl_stmt|,
comment|/* Magenta bitmap data */
modifier|*
name|lcyan
decl_stmt|,
comment|/* Light cyan bitmap data */
modifier|*
name|lmagenta
decl_stmt|,
comment|/* Light magenta bitmap data */
modifier|*
name|yellow
decl_stmt|;
comment|/* Yellow bitmap data */
name|int
name|page_left
decl_stmt|,
comment|/* Left margin of page */
name|page_right
decl_stmt|,
comment|/* Right margin of page */
name|page_top
decl_stmt|,
comment|/* Top of page */
name|page_bottom
decl_stmt|,
comment|/* Bottom of page */
name|page_width
decl_stmt|,
comment|/* Width of page */
name|page_height
decl_stmt|,
comment|/* Height of page */
name|page_length
decl_stmt|,
comment|/* True length of page */
name|out_width
decl_stmt|,
comment|/* Width of image on page */
name|out_height
decl_stmt|,
comment|/* Height of image on page */
name|out_bpp
decl_stmt|,
comment|/* Output bytes per pixel */
name|length
decl_stmt|,
comment|/* Length of raster data */
name|errdiv
decl_stmt|,
comment|/* Error dividend */
name|errmod
decl_stmt|,
comment|/* Error modulus */
name|errval
decl_stmt|,
comment|/* Current error value */
name|errline
decl_stmt|,
comment|/* Current raster line */
name|errlast
decl_stmt|;
comment|/* Last raster line loaded */
name|convert_t
name|colorfunc
init|=
literal|0
decl_stmt|;
comment|/* Color conversion function... */
name|int
name|image_height
decl_stmt|,
name|image_width
decl_stmt|,
name|image_bpp
decl_stmt|;
name|int
name|use_softweave
init|=
literal|0
decl_stmt|;
name|int
name|nozzles
init|=
literal|1
decl_stmt|;
name|int
name|nozzle_separation
init|=
literal|1
decl_stmt|;
name|int
name|horizontal_passes
init|=
literal|1
decl_stmt|;
name|int
name|vertical_passes
init|=
literal|1
decl_stmt|;
name|int
name|vertical_oversample
init|=
literal|1
decl_stmt|;
name|int
name|use_6color
init|=
literal|0
decl_stmt|;
specifier|const
name|res_t
modifier|*
name|res
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|void
modifier|*
name|weave
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|dither
decl_stmt|;
name|colormode_t
name|colormode
init|=
name|COLOR_CCMMYK
decl_stmt|;
name|int
name|separation_rows
init|=
name|escp2_separation_rows
argument_list|(
name|model
argument_list|)
decl_stmt|;
name|int
name|ink_spread
decl_stmt|;
name|vars_t
name|nv
decl_stmt|;
name|escp_init_t
name|init
decl_stmt|;
name|escp2_variable_inkset_t
modifier|*
name|inks
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|nv
argument_list|,
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|vars_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ink_type
argument_list|,
literal|"Four Color Standard"
argument_list|)
operator|!=
literal|0
operator|&&
name|nv
operator|.
name|image_type
operator|!=
name|IMAGE_MONOCHROME
condition|)
name|use_6color
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nv
operator|.
name|image_type
operator|==
name|IMAGE_MONOCHROME
condition|)
block|{
name|colormode
operator|=
name|COLOR_MONOCHROME
expr_stmt|;
name|output_type
operator|=
name|OUTPUT_GRAY
expr_stmt|;
name|bits
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|colormode
operator|=
name|COLOR_MONOCHROME
expr_stmt|;
elseif|else
if|if
condition|(
name|use_6color
condition|)
name|colormode
operator|=
name|COLOR_CCMMYK
expr_stmt|;
else|else
name|colormode
operator|=
name|COLOR_CMYK
expr_stmt|;
comment|/*   * Setup a read-only pixel region for the entire image...   */
name|Image_init
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_height
operator|=
name|Image_height
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_width
operator|=
name|Image_width
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_bpp
operator|=
name|Image_bpp
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Choose the correct color conversion function...   */
if|if
condition|(
name|image_bpp
operator|<
literal|3
operator|&&
name|cmap
operator|==
name|NULL
operator|&&
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
name|output_type
operator|=
name|OUTPUT_GRAY_COLOR
expr_stmt|;
comment|/* Force grayscale output */
name|colorfunc
operator|=
name|choose_colorfunc
argument_list|(
name|output_type
argument_list|,
name|image_bpp
argument_list|,
name|cmap
argument_list|,
operator|&
name|out_bpp
argument_list|,
operator|&
name|nv
argument_list|)
expr_stmt|;
comment|/*   * Compute the output size...   */
name|escp2_imageable_area
argument_list|(
name|printer
argument_list|,
operator|&
name|nv
argument_list|,
operator|&
name|page_left
argument_list|,
operator|&
name|page_right
argument_list|,
operator|&
name|page_bottom
argument_list|,
operator|&
name|page_top
argument_list|)
expr_stmt|;
name|compute_page_parameters
argument_list|(
name|page_right
argument_list|,
name|page_left
argument_list|,
name|page_top
argument_list|,
name|page_bottom
argument_list|,
name|scaling
argument_list|,
name|image_width
argument_list|,
name|image_height
argument_list|,
name|image
argument_list|,
operator|&
name|orientation
argument_list|,
operator|&
name|page_width
argument_list|,
operator|&
name|page_height
argument_list|,
operator|&
name|out_width
argument_list|,
operator|&
name|out_height
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|top
argument_list|)
expr_stmt|;
comment|/*    * Recompute the image height and width.  If the image has been    * rotated, these will change from previously.    */
name|image_height
operator|=
name|Image_height
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_width
operator|=
name|Image_width
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Figure out the output resolution...   */
for|for
control|(
name|res
operator|=
operator|&
name|escp2_reslist
index|[
literal|0
index|]
init|;
condition|;
name|res
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
name|res
operator|->
name|name
argument_list|)
condition|)
block|{
name|use_softweave
operator|=
name|res
operator|->
name|softweave
expr_stmt|;
name|xdpi
operator|=
name|res
operator|->
name|hres
expr_stmt|;
name|ydpi
operator|=
name|res
operator|->
name|vres
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|horizontal_passes
operator|=
name|xdpi
operator|/
name|escp2_xres
argument_list|(
name|model
argument_list|)
expr_stmt|;
else|else
name|horizontal_passes
operator|=
name|xdpi
operator|/
literal|720
expr_stmt|;
if|if
condition|(
name|horizontal_passes
operator|==
literal|0
condition|)
name|horizontal_passes
operator|=
literal|1
expr_stmt|;
name|vertical_passes
operator|=
name|res
operator|->
name|vertical_passes
expr_stmt|;
name|vertical_oversample
operator|=
name|res
operator|->
name|vertical_oversample
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|nozzles
operator|=
name|escp2_black_nozzles
argument_list|(
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|nozzles
operator|==
literal|0
condition|)
name|nozzles
operator|=
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
else|else
name|nozzles
operator|=
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|nozzle_separation
operator|=
name|escp2_nozzle_separation
argument_list|(
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|ydpi
operator|<
literal|720
condition|)
name|nozzle_separation
operator|=
name|nozzle_separation
operator|*
name|ydpi
operator|/
literal|720
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|""
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
operator|)
operator|&&
name|use_softweave
condition|)
name|bits
operator|=
literal|2
expr_stmt|;
else|else
name|bits
operator|=
literal|1
expr_stmt|;
comment|/*   * Let the user know what we're doing...   */
name|Image_progress_init
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Send ESC/P2 initialization commands...   */
name|default_media_size
argument_list|(
name|printer
argument_list|,
operator|&
name|nv
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|page_length
argument_list|)
expr_stmt|;
name|page_length
operator|+=
operator|(
literal|39
operator|+
operator|(
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
operator|*
literal|2
operator|)
operator|*
name|escp2_nozzle_separation
argument_list|(
name|model
argument_list|)
operator|)
operator|/
literal|10
expr_stmt|;
comment|/* Top and bottom */
name|page_top
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|model
operator|=
name|model
expr_stmt|;
name|init
operator|.
name|output_type
operator|=
name|output_type
expr_stmt|;
name|init
operator|.
name|ydpi
operator|=
name|ydpi
expr_stmt|;
name|init
operator|.
name|xdpi
operator|=
name|xdpi
expr_stmt|;
name|init
operator|.
name|use_softweave
operator|=
name|use_softweave
expr_stmt|;
name|init
operator|.
name|page_length
operator|=
name|page_length
expr_stmt|;
name|init
operator|.
name|page_width
operator|=
name|page_width
expr_stmt|;
name|init
operator|.
name|page_top
operator|=
name|page_top
expr_stmt|;
name|init
operator|.
name|page_bottom
operator|=
name|page_bottom
expr_stmt|;
name|init
operator|.
name|horizontal_passes
operator|=
name|horizontal_passes
expr_stmt|;
name|init
operator|.
name|vertical_passes
operator|=
name|vertical_passes
expr_stmt|;
name|init
operator|.
name|vertical_oversample
operator|=
name|vertical_oversample
expr_stmt|;
name|init
operator|.
name|bits
operator|=
name|bits
expr_stmt|;
name|init
operator|.
name|paper_type
operator|=
name|media_type
expr_stmt|;
name|escp2_init_printer
argument_list|(
name|prn
argument_list|,
operator|&
name|init
argument_list|)
expr_stmt|;
comment|/*   * Convert image size to printer resolution...   */
name|out_width
operator|=
name|xdpi
operator|*
name|out_width
operator|/
literal|72
expr_stmt|;
name|out_height
operator|=
name|ydpi
operator|*
name|out_height
operator|/
literal|72
expr_stmt|;
name|physical_ydpi
operator|=
name|ydpi
expr_stmt|;
if|if
condition|(
name|ydpi
operator|>
literal|720
condition|)
name|physical_ydpi
operator|=
literal|720
expr_stmt|;
name|left
operator|=
name|physical_ydpi
operator|*
name|left
operator|/
literal|72
expr_stmt|;
comment|/*   * Adjust for zero-margin printing...   */
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_ZEROMARGIN_MASK
argument_list|,
name|MODEL_ZEROMARGIN_YES
argument_list|)
condition|)
block|{
comment|/*       * In zero-margin mode, the origin is about 3/20" to the left of the       * paper's left edge.       */
name|left
operator|+=
literal|92
operator|*
name|physical_ydpi
operator|/
literal|720
expr_stmt|;
block|}
comment|/*   * Allocate memory for the raster data...   */
name|length
operator|=
operator|(
name|out_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|black
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
name|cyan
operator|=
name|NULL
expr_stmt|;
name|magenta
operator|=
name|NULL
expr_stmt|;
name|lcyan
operator|=
name|NULL
expr_stmt|;
name|lmagenta
operator|=
name|NULL
expr_stmt|;
name|yellow
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cyan
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
name|magenta
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
name|yellow
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_HASBLACK_MASK
argument_list|,
name|MODEL_HASBLACK_YES
argument_list|)
condition|)
name|black
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
else|else
name|black
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|use_6color
condition|)
block|{
name|lcyan
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
name|lmagenta
operator|=
name|malloc
argument_list|(
name|length
operator|*
name|bits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lcyan
operator|=
name|NULL
expr_stmt|;
name|lmagenta
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_softweave
condition|)
comment|/* Epson printers are all 720 physical dpi */
name|weave
operator|=
name|initialize_weave
argument_list|(
name|nozzles
argument_list|,
name|nozzle_separation
argument_list|,
name|horizontal_passes
argument_list|,
name|vertical_passes
argument_list|,
name|vertical_oversample
argument_list|,
name|colormode
argument_list|,
name|bits
argument_list|,
name|out_width
operator|*
name|escp2_xres
argument_list|(
name|model
argument_list|)
operator|/
name|physical_ydpi
argument_list|,
name|out_height
argument_list|,
name|separation_rows
argument_list|,
name|top
operator|*
name|physical_ydpi
operator|/
literal|72
argument_list|,
name|page_height
operator|*
name|physical_ydpi
operator|/
literal|72
argument_list|)
expr_stmt|;
else|else
name|escp2_init_microweave
argument_list|(
name|top
operator|*
name|ydpi
operator|/
literal|72
argument_list|)
expr_stmt|;
comment|/*    * Compute the LUT.  For now, it's 8 bit, but that may eventually    * sometimes change.    */
name|nv
operator|.
name|density
operator|*=
name|escp2_density
argument_list|(
name|model
argument_list|,
name|xdpi
argument_list|,
name|ydpi
argument_list|,
operator|!
name|use_softweave
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv
operator|.
name|density
operator|>
literal|1.0
condition|)
name|nv
operator|.
name|density
operator|=
literal|1.0
expr_stmt|;
name|compute_lut
argument_list|(
literal|256
argument_list|,
operator|&
name|nv
argument_list|)
expr_stmt|;
comment|/*   * Output the page...   */
if|if
condition|(
name|xdpi
operator|>
name|ydpi
condition|)
name|dither
operator|=
name|init_dither
argument_list|(
name|image_width
argument_list|,
name|out_width
argument_list|,
literal|1
argument_list|,
name|xdpi
operator|/
name|ydpi
argument_list|,
operator|&
name|nv
argument_list|)
expr_stmt|;
else|else
name|dither
operator|=
name|init_dither
argument_list|(
name|image_width
argument_list|,
name|out_width
argument_list|,
name|ydpi
operator|/
name|xdpi
argument_list|,
literal|1
argument_list|,
operator|&
name|nv
argument_list|)
expr_stmt|;
name|dither_set_black_levels
argument_list|(
name|dither
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_6color
condition|)
name|dither_set_black_lower
argument_list|(
name|dither
argument_list|,
literal|.4
operator|/
name|bits
operator|+
literal|.1
argument_list|)
expr_stmt|;
else|else
name|dither_set_black_lower
argument_list|(
name|dither
argument_list|,
literal|.25
operator|/
name|bits
argument_list|)
expr_stmt|;
name|dither_set_black_upper
argument_list|(
name|dither
argument_list|,
literal|.999
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|use_6color
condition|)
name|dither_set_adaptive_divisor
argument_list|(
name|dither
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|dither_set_adaptive_divisor
argument_list|(
name|dither
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|dither_set_error_mix
argument_list|(
name|dither
argument_list|,
literal|.5
argument_list|)
expr_stmt|;
block|}
else|else
name|dither_set_adaptive_divisor
argument_list|(
name|dither
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|inks
operator|=
name|escp2_inks
argument_list|(
name|model
argument_list|,
name|xdpi
argument_list|,
name|use_6color
condition|?
literal|6
else|:
literal|4
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|inks
operator|->
name|c
condition|)
name|dither_set_c_ranges
argument_list|(
name|dither
argument_list|,
name|inks
operator|->
name|c
operator|->
name|count
argument_list|,
name|inks
operator|->
name|c
operator|->
name|range
argument_list|,
name|inks
operator|->
name|c
operator|->
name|density
operator|*
name|nv
operator|.
name|density
argument_list|)
expr_stmt|;
if|if
condition|(
name|inks
operator|->
name|m
condition|)
name|dither_set_m_ranges
argument_list|(
name|dither
argument_list|,
name|inks
operator|->
name|m
operator|->
name|count
argument_list|,
name|inks
operator|->
name|m
operator|->
name|range
argument_list|,
name|inks
operator|->
name|m
operator|->
name|density
operator|*
name|nv
operator|.
name|density
argument_list|)
expr_stmt|;
if|if
condition|(
name|inks
operator|->
name|y
condition|)
name|dither_set_y_ranges
argument_list|(
name|dither
argument_list|,
name|inks
operator|->
name|y
operator|->
name|count
argument_list|,
name|inks
operator|->
name|y
operator|->
name|range
argument_list|,
name|inks
operator|->
name|y
operator|->
name|density
operator|*
name|nv
operator|.
name|density
argument_list|)
expr_stmt|;
if|if
condition|(
name|inks
operator|->
name|k
condition|)
name|dither_set_k_ranges
argument_list|(
name|dither
argument_list|,
name|inks
operator|->
name|k
operator|->
name|count
argument_list|,
name|inks
operator|->
name|k
operator|->
name|range
argument_list|,
name|inks
operator|->
name|k
operator|->
name|density
operator|*
name|nv
operator|.
name|density
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|use_6color
condition|)
name|dither_set_transition
argument_list|(
name|dither
argument_list|,
literal|.7
argument_list|)
expr_stmt|;
else|else
name|dither_set_transition
argument_list|(
name|dither
argument_list|,
literal|.5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nv
operator|.
name|dither_algorithm
argument_list|,
literal|"Ordered"
argument_list|)
condition|)
name|dither_set_transition
argument_list|(
name|dither
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nv
operator|.
name|image_type
condition|)
block|{
case|case
name|IMAGE_LINE_ART
case|:
name|dither_set_ink_spread
argument_list|(
name|dither
argument_list|,
literal|19
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGE_SOLID_TONE
case|:
name|dither_set_ink_spread
argument_list|(
name|dither
argument_list|,
literal|15
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGE_CONTINUOUS
case|:
name|ink_spread
operator|=
literal|13
expr_stmt|;
if|if
condition|(
name|ydpi
operator|>
literal|720
condition|)
name|ink_spread
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|>
literal|1
condition|)
name|ink_spread
operator|++
expr_stmt|;
name|dither_set_ink_spread
argument_list|(
name|dither
argument_list|,
name|ink_spread
argument_list|)
expr_stmt|;
break|break;
block|}
name|dither_set_density
argument_list|(
name|dither
argument_list|,
name|nv
operator|.
name|density
argument_list|)
expr_stmt|;
name|in
operator|=
name|malloc
argument_list|(
name|image_width
operator|*
name|image_bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|image_width
operator|*
name|out_bpp
operator|*
literal|2
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|image_height
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|image_height
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|out_height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|Image_note_progress
argument_list|(
name|image
argument_list|,
name|y
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|Image_get_row
argument_list|(
name|image
argument_list|,
name|in
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|image_width
argument_list|,
name|image_bpp
argument_list|,
name|cmap
argument_list|,
operator|&
name|nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv
operator|.
name|image_type
operator|==
name|IMAGE_MONOCHROME
condition|)
name|dither_fastblack
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|dither
argument_list|,
name|black
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|dither_black
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|dither
argument_list|,
name|black
argument_list|)
expr_stmt|;
else|else
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|dither
argument_list|,
name|cyan
argument_list|,
name|lcyan
argument_list|,
name|magenta
argument_list|,
name|lmagenta
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|weave
argument_list|,
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
name|escp2_write_microweave
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|,
name|length
argument_list|,
name|xdpi
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|+=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|++
expr_stmt|;
block|}
block|}
name|Image_progress_conclude
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_flush_all
argument_list|(
name|weave
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|escp2_free_microweave
argument_list|()
expr_stmt|;
name|free_dither
argument_list|(
name|dither
argument_list|)
expr_stmt|;
comment|/*   * Cleanup...   */
name|free_lut
argument_list|(
operator|&
name|nv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|destroy_weave
argument_list|(
name|weave
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyan
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cyan
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magenta
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yellow
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lcyan
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|lcyan
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lmagenta
argument_list|)
expr_stmt|;
block|}
name|escp2_deinit_printer
argument_list|(
name|prn
argument_list|,
operator|&
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_fold (const unsigned char * line,int single_length,unsigned char * outbuf)
name|escp2_fold
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
name|int
name|single_length
parameter_list|,
name|unsigned
name|char
modifier|*
name|outbuf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|outbuf
argument_list|,
literal|0
argument_list|,
name|single_length
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|single_length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|l0
init|=
name|line
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|char
name|l1
init|=
name|line
index|[
name|single_length
index|]
decl_stmt|;
if|if
condition|(
name|l0
operator|||
name|l1
condition|)
block|{
name|outbuf
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|outbuf
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|l0
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|l1
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
name|line
operator|++
expr_stmt|;
name|outbuf
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_2_1 (int length,const unsigned char * in,unsigned char * outhi,unsigned char * outlo)
name|escp2_split_2_1
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|outs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|row
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|length
operator|*
literal|2
decl_stmt|;
name|outs
index|[
literal|0
index|]
operator|=
name|outhi
expr_stmt|;
name|outs
index|[
literal|1
index|]
operator|=
name|outlo
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|outs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inbyte
operator|==
literal|0
condition|)
continue|continue;
comment|/* For some reason gcc isn't unrolling this, even with -funroll-loops */
if|if
condition|(
name|inbyte
operator|&
literal|1
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
literal|1
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_2_2 (int length,const unsigned char * in,unsigned char * outhi,unsigned char * outlo)
name|escp2_split_2_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|outs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|row
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|length
operator|*
literal|2
decl_stmt|;
name|outs
index|[
literal|0
index|]
operator|=
name|outhi
expr_stmt|;
name|outs
index|[
literal|1
index|]
operator|=
name|outlo
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|outs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inbyte
operator|==
literal|0
condition|)
continue|continue;
comment|/* For some reason gcc isn't unrolling this, even with -funroll-loops */
if|if
condition|(
name|inbyte
operator|&
literal|3
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|3
operator|&
name|inbyte
operator|)
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|&
name|inbyte
operator|)
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|&
name|inbyte
operator|)
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|&
name|inbyte
operator|)
expr_stmt|;
name|row
operator|=
name|row
operator|^
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_2 (int length,int bits,const unsigned char * in,unsigned char * outhi,unsigned char * outlo)
name|escp2_split_2
parameter_list|(
name|int
name|length
parameter_list|,
name|int
name|bits
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|)
block|{
if|if
condition|(
name|bits
operator|==
literal|2
condition|)
name|escp2_split_2_2
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|outhi
argument_list|,
name|outlo
argument_list|)
expr_stmt|;
else|else
name|escp2_split_2_1
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|outhi
argument_list|,
name|outlo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_4_1 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_split_4_1
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|outs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|row
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|length
operator|*
literal|2
decl_stmt|;
name|outs
index|[
literal|0
index|]
operator|=
name|out0
expr_stmt|;
name|outs
index|[
literal|1
index|]
operator|=
name|out1
expr_stmt|;
name|outs
index|[
literal|2
index|]
operator|=
name|out2
expr_stmt|;
name|outs
index|[
literal|3
index|]
operator|=
name|out3
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|outs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inbyte
operator|==
literal|0
condition|)
continue|continue;
comment|/* For some reason gcc isn't unrolling this, even with -funroll-loops */
if|if
condition|(
name|inbyte
operator|&
literal|1
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
literal|1
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_4_2 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_split_4_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|outs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|row
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|length
operator|*
literal|2
decl_stmt|;
name|outs
index|[
literal|0
index|]
operator|=
name|out0
expr_stmt|;
name|outs
index|[
literal|1
index|]
operator|=
name|out1
expr_stmt|;
name|outs
index|[
literal|2
index|]
operator|=
name|out2
expr_stmt|;
name|outs
index|[
literal|3
index|]
operator|=
name|out3
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outs
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|outs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inbyte
operator|==
literal|0
condition|)
continue|continue;
comment|/* For some reason gcc isn't unrolling this, even with -funroll-loops */
if|if
condition|(
name|inbyte
operator|&
literal|3
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
literal|3
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
condition|)
block|{
name|outs
index|[
name|row
index|]
index|[
name|i
index|]
operator||=
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|&
name|inbyte
expr_stmt|;
name|row
operator|=
operator|(
name|row
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_4 (int length,int bits,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_split_4
parameter_list|(
name|int
name|length
parameter_list|,
name|int
name|bits
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
if|if
condition|(
name|bits
operator|==
literal|2
condition|)
name|escp2_split_4_2
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|out0
argument_list|,
name|out1
argument_list|,
name|out2
argument_list|,
name|out3
argument_list|)
expr_stmt|;
else|else
name|escp2_split_4_1
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|out0
argument_list|,
name|out1
argument_list|,
name|out2
argument_list|,
name|out3
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__LITTLE_ENDIAN
end_if

begin_define
DECL|macro|SH20
define|#
directive|define
name|SH20
value|0
end_define

begin_define
DECL|macro|SH21
define|#
directive|define
name|SH21
value|8
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|SH20
define|#
directive|define
name|SH20
value|8
end_define

begin_define
DECL|macro|SH21
define|#
directive|define
name|SH21
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_2_1 (int length,const unsigned char * in,unsigned char * outlo,unsigned char * outhi)
name|escp2_unpack_2_1
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|limit
init|=
operator|(
name|length
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|memset
argument_list|(
name|outlo
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outhi
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|short
name|inint
init|=
operator|(
operator|(
specifier|const
name|unsigned
name|short
operator|*
operator|)
name|in
operator|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|inint
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|ob0
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob1
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|inbyte
init|=
operator|(
name|inint
operator|>>
name|SH20
operator|)
operator|&
literal|0xff
decl_stmt|;
name|ob0
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|ob1
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH21
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|outlo
index|[
name|i
index|]
operator|=
name|ob0
expr_stmt|;
name|outhi
index|[
name|i
index|]
operator|=
name|ob1
expr_stmt|;
block|}
name|in
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_2_2 (int length,const unsigned char * in,unsigned char * outlo,unsigned char * outhi)
name|escp2_unpack_2_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|outlo
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outhi
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|short
name|inint
init|=
operator|(
operator|(
specifier|const
name|unsigned
name|short
operator|*
operator|)
name|in
operator|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|inint
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|inbyte
init|=
operator|(
name|inint
operator|>>
name|SH20
operator|)
operator|&
literal|0xff
decl_stmt|;
name|unsigned
name|char
name|ob0
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob1
init|=
literal|0
decl_stmt|;
name|ob0
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|ob1
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH21
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|outlo
index|[
name|i
index|]
operator|=
name|ob0
expr_stmt|;
name|outhi
index|[
name|i
index|]
operator|=
name|ob1
expr_stmt|;
block|}
name|in
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_2 (int length,int bits,const unsigned char * in,unsigned char * outlo,unsigned char * outhi)
name|escp2_unpack_2
parameter_list|(
name|int
name|length
parameter_list|,
name|int
name|bits
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|)
block|{
if|if
condition|(
name|bits
operator|==
literal|1
condition|)
name|escp2_unpack_2_1
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|outlo
argument_list|,
name|outhi
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_2_2
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|outlo
argument_list|,
name|outhi
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__LITTLE_ENDIAN
end_if

begin_define
DECL|macro|SH40
define|#
directive|define
name|SH40
value|0
end_define

begin_define
DECL|macro|SH41
define|#
directive|define
name|SH41
value|8
end_define

begin_define
DECL|macro|SH42
define|#
directive|define
name|SH42
value|16
end_define

begin_define
DECL|macro|SH43
define|#
directive|define
name|SH43
value|24
end_define

begin_else
else|#
directive|else
end_else

begin_define
DECL|macro|SH40
define|#
directive|define
name|SH40
value|24
end_define

begin_define
DECL|macro|SH41
define|#
directive|define
name|SH41
value|16
end_define

begin_define
DECL|macro|SH42
define|#
directive|define
name|SH42
value|8
end_define

begin_define
DECL|macro|SH43
define|#
directive|define
name|SH43
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_4_1 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_unpack_4_1
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|limit
init|=
operator|(
name|length
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|memset
argument_list|(
name|out0
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out1
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out2
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out3
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|inint
init|=
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|in
operator|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|inint
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|ob0
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob1
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob2
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob3
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|inbyte
init|=
operator|(
name|inint
operator|>>
name|SH40
operator|)
operator|&
literal|0xff
decl_stmt|;
name|ob0
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|ob1
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|ob2
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
name|ob3
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH41
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|ob2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|ob3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH42
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
name|ob2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|ob3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH43
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|6
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|5
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ob2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|ob3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|out0
index|[
name|i
index|]
operator|=
name|ob0
expr_stmt|;
name|out1
index|[
name|i
index|]
operator|=
name|ob1
expr_stmt|;
name|out2
index|[
name|i
index|]
operator|=
name|ob2
expr_stmt|;
name|out3
index|[
name|i
index|]
operator|=
name|ob3
expr_stmt|;
block|}
name|in
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_4_2 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_unpack_4_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|limit
init|=
operator|(
name|length
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|memset
argument_list|(
name|out0
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out1
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out2
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out3
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|inint
init|=
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|in
operator|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|inint
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|ob0
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob1
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob2
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ob3
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|inbyte
init|=
operator|(
name|inint
operator|>>
name|SH40
operator|)
operator|&
literal|0xff
decl_stmt|;
name|ob0
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
name|ob1
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|ob2
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|ob3
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH41
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
name|ob2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|ob3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH42
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ob2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
name|ob3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|inbyte
operator|=
operator|(
name|inint
operator|>>
name|SH43
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ob0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|ob1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|ob2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ob3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|3
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|out0
index|[
name|i
index|]
operator|=
name|ob0
expr_stmt|;
name|out1
index|[
name|i
index|]
operator|=
name|ob1
expr_stmt|;
name|out2
index|[
name|i
index|]
operator|=
name|ob2
expr_stmt|;
name|out3
index|[
name|i
index|]
operator|=
name|ob3
expr_stmt|;
block|}
name|in
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_4 (int length,int bits,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_unpack_4
parameter_list|(
name|int
name|length
parameter_list|,
name|int
name|bits
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
if|if
condition|(
name|bits
operator|==
literal|1
condition|)
name|escp2_unpack_4_1
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|out0
argument_list|,
name|out1
argument_list|,
name|out2
argument_list|,
name|out3
argument_list|)
expr_stmt|;
else|else
name|escp2_unpack_4_2
argument_list|(
name|length
argument_list|,
name|in
argument_list|,
name|out0
argument_list|,
name|out1
argument_list|,
name|out2
argument_list|,
name|out3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_pack (const unsigned char * line,int length,unsigned char * comp_buf,unsigned char ** comp_ptr)
name|escp2_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
name|int
name|length
parameter_list|,
name|unsigned
name|char
modifier|*
name|comp_buf
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|comp_ptr
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of compressed data */
name|unsigned
name|char
name|repeat
decl_stmt|;
comment|/* Repeating char */
name|int
name|count
decl_stmt|;
comment|/* Count of compressed bytes */
name|int
name|tcount
decl_stmt|;
comment|/* Temporary count< 128 */
name|int
name|active
init|=
literal|0
decl_stmt|;
comment|/* Have we found data? */
comment|/*    * Compress using TIFF "packbits" run-length encoding...    */
operator|(
operator|*
name|comp_ptr
operator|)
operator|=
name|comp_buf
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/*        * Get a run of non-repeated chars...        */
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|(
name|line
index|[
operator|-
literal|2
index|]
operator|!=
name|line
index|[
operator|-
literal|1
index|]
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|!=
name|line
index|[
literal|0
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|active
operator|&&
operator|(
name|line
index|[
operator|-
literal|2
index|]
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|||
name|line
index|[
literal|0
index|]
operator|)
condition|)
name|active
operator|=
literal|1
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
name|line
operator|-=
literal|2
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
comment|/*        * Output the non-repeated sequences (max 128 at a time).        */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|0
index|]
operator|=
name|tcount
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|comp_ptr
operator|)
operator|+
literal|1
argument_list|,
name|start
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
operator|+=
name|tcount
operator|+
literal|1
expr_stmt|;
name|start
operator|+=
name|tcount
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
break|break;
comment|/*        * Find the repeated sequences...        */
name|start
operator|=
name|line
expr_stmt|;
name|repeat
operator|=
name|line
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
name|active
operator|=
literal|1
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|*
name|line
operator|==
name|repeat
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
comment|/*        * Output the repeated sequences (max 128 at a time).        */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|0
index|]
operator|=
literal|1
operator|-
name|tcount
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|1
index|]
operator|=
name|repeat
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
block|}
return|return
name|active
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|microweave_s
specifier|static
name|unsigned
name|char
modifier|*
name|microweave_s
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|microweave_comp_ptr
specifier|static
name|unsigned
name|char
modifier|*
name|microweave_comp_ptr
index|[
literal|6
index|]
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|microweave_setactive
specifier|static
name|int
name|microweave_setactive
index|[
literal|6
index|]
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|accumulated_spacing
specifier|static
name|int
name|accumulated_spacing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|last_color
specifier|static
name|int
name|last_color
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|MICRO_S (c,l)
define|#
directive|define
name|MICRO_S
parameter_list|(
name|c
parameter_list|,
name|l
parameter_list|)
value|(microweave_s + COMPBUFWIDTH * (l) + COMPBUFWIDTH * (c) * 4)
end_define

begin_function
specifier|static
name|void
DECL|function|escp2_init_microweave (int top)
name|escp2_init_microweave
parameter_list|(
name|int
name|top
parameter_list|)
block|{
if|if
condition|(
operator|!
name|microweave_s
condition|)
name|microweave_s
operator|=
name|malloc
argument_list|(
literal|6
operator|*
literal|4
operator|*
name|COMPBUFWIDTH
argument_list|)
expr_stmt|;
name|accumulated_spacing
operator|=
name|top
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_free_microweave ()
name|escp2_free_microweave
parameter_list|()
block|{
if|if
condition|(
name|microweave_s
condition|)
block|{
name|free
argument_list|(
name|microweave_s
argument_list|)
expr_stmt|;
name|microweave_s
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_do_microweave_pack (const unsigned char * line,int length,int oversample,int bits,int color)
name|escp2_do_microweave_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|oversample
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|color
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|pack_buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|s
index|[
literal|4
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pack_buf
condition|)
name|pack_buf
operator|=
name|malloc
argument_list|(
name|COMPBUFWIDTH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oversample
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|s
index|[
name|i
index|]
condition|)
name|s
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|COMPBUFWIDTH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|line
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
operator|(
name|bits
operator|*
name|length
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|microweave_setactive
index|[
name|color
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bits
operator|==
literal|1
condition|)
name|in
operator|=
name|line
expr_stmt|;
else|else
block|{
name|escp2_fold
argument_list|(
name|line
argument_list|,
name|length
argument_list|,
name|pack_buf
argument_list|)
expr_stmt|;
name|in
operator|=
name|pack_buf
expr_stmt|;
block|}
switch|switch
condition|(
name|oversample
condition|)
block|{
case|case
literal|1
case|:
name|memcpy
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|,
name|in
argument_list|,
name|bits
operator|*
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|bits
argument_list|,
name|in
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|bits
argument_list|,
name|in
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oversample
condition|;
name|i
operator|++
control|)
block|{
name|microweave_setactive
index|[
name|color
index|]
index|[
name|i
index|]
operator|=
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
name|length
operator|*
name|bits
argument_list|,
name|MICRO_S
argument_list|(
name|color
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
operator|(
name|microweave_comp_ptr
index|[
name|color
index|]
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|retval
operator||=
name|microweave_setactive
index|[
name|color
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_write_microweave (FILE * prn,const unsigned char * k,const unsigned char * c,const unsigned char * m,const unsigned char * y,const unsigned char * lc,const unsigned char * lm,int length,int xdpi,int ydpi,int model,int width,int offset,int bits)
name|escp2_write_microweave
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
specifier|const
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
comment|/* I - Output bitmap data */
specifier|const
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
comment|/* I - Output bitmap data */
specifier|const
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
comment|/* I - Output bitmap data */
specifier|const
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
comment|/* I - Output bitmap data */
specifier|const
name|unsigned
name|char
modifier|*
name|lc
parameter_list|,
comment|/* I - Output bitmap data */
specifier|const
name|unsigned
name|char
modifier|*
name|lm
parameter_list|,
comment|/* I - Output bitmap data */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|xdpi
parameter_list|,
comment|/* I - Horizontal resolution */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|,
comment|/* I - Offset from left side */
name|int
name|bits
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|oversample
init|=
literal|1
decl_stmt|;
name|int
name|gsetactive
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|xdpi
operator|>
literal|720
condition|)
name|oversample
operator|=
name|xdpi
operator|/
literal|720
expr_stmt|;
name|gsetactive
operator||=
name|escp2_do_microweave_pack
argument_list|(
name|k
argument_list|,
name|length
argument_list|,
name|oversample
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gsetactive
operator||=
name|escp2_do_microweave_pack
argument_list|(
name|m
argument_list|,
name|length
argument_list|,
name|oversample
argument_list|,
name|bits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gsetactive
operator||=
name|escp2_do_microweave_pack
argument_list|(
name|c
argument_list|,
name|length
argument_list|,
name|oversample
argument_list|,
name|bits
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gsetactive
operator||=
name|escp2_do_microweave_pack
argument_list|(
name|y
argument_list|,
name|length
argument_list|,
name|oversample
argument_list|,
name|bits
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gsetactive
operator||=
name|escp2_do_microweave_pack
argument_list|(
name|lm
argument_list|,
name|length
argument_list|,
name|oversample
argument_list|,
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gsetactive
operator||=
name|escp2_do_microweave_pack
argument_list|(
name|lc
argument_list|,
name|length
argument_list|,
name|oversample
argument_list|,
name|bits
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gsetactive
condition|)
block|{
name|accumulated_spacing
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oversample
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|microweave_setactive
index|[
name|j
index|]
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|accumulated_spacing
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(v\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|accumulated_spacing
operator|%
literal|256
argument_list|,
operator|(
name|accumulated_spacing
operator|>>
literal|8
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
name|accumulated_spacing
operator|=
literal|0
expr_stmt|;
comment|/* 	   * Set the print head position. 	   */
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
operator|&&
name|xdpi
operator|>
literal|720
condition|)
block|{
if|if
condition|(
operator|!
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|offset
operator|*
name|xdpi
operator|/
literal|1440
operator|)
operator|+
name|i
operator|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033($%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|offset
operator|*
name|xdpi
operator|/
literal|1440
operator|)
operator|+
name|i
operator|)
operator|&
literal|255
argument_list|,
operator|(
operator|(
operator|(
name|offset
operator|*
name|xdpi
operator|/
literal|1440
operator|)
operator|+
name|i
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
operator|(
operator|(
operator|(
name|offset
operator|*
name|xdpi
operator|/
literal|1440
operator|)
operator|+
name|i
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|255
argument_list|,
operator|(
operator|(
operator|(
name|offset
operator|*
name|xdpi
operator|/
literal|1440
operator|)
operator|+
name|i
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
name|i
operator|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(\\%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|160
argument_list|,
literal|5
argument_list|,
operator|(
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
name|i
operator|)
operator|&
literal|255
argument_list|,
operator|(
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
name|i
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|offset
operator|&
literal|255
argument_list|,
name|offset
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|last_color
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(r\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|last_color
operator|=
name|j
expr_stmt|;
block|}
comment|/* 	   * Send a line of raster graphics... 	   */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Raster graphics header */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033.\001\024\024\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033.\001\012\012\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_720DPI_MODE_MASK
argument_list|,
name|MODEL_720DPI_600
argument_list|)
condition|)
name|fwrite
argument_list|(
literal|"\033.\001\050\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fwrite
argument_list|(
literal|"\033.\001\005\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|width
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|width
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|MICRO_S
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
argument_list|,
name|microweave_comp_ptr
index|[
name|j
index|]
index|[
name|i
index|]
operator|-
name|MICRO_S
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
block|}
name|accumulated_spacing
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "Soft" weave  *  * The Epson Stylus Color/Photo printers don't have memory to print  * using all of the nozzles in the print head.  For example, the Stylus Photo  * 700/EX has 32 nozzles.  At 720 dpi, with an 8" wide image, a single line  * requires (8 * 720 * 6 / 8) bytes, or 4320 bytes (because the Stylus Photo  * printers have 6 ink colors).  To use 32 nozzles would require 138240 bytes.  * It's actually worse than that, though, because the nozzles are spaced 8  * rows apart.  Therefore, in order to store enough data to permit sending the  * page as a simple raster, the printer would require enough memory to store  * 256 rows, or 1105920 bytes.  Considering that the Photo EX can print  * 11" wide, we're looking at more like 1.5 MB.  In fact, these printers are  * capable of 1440 dpi horizontal resolution.  This would require 3 MB.  The  * printers actually have 64K-256K.  *  * With the newer (740/750 and later) printers it's even worse, since these  * printers support multiple dot sizes.  But that's neither here nor there.  *  * Older Epson printers had a mode called MicroWeave (tm).  In this mode, the  * host fed the printer individual rows of dots, and the printer bundled them  * up and sent them to the print head in the correct order to achieve high  * quality.  This MicroWeave mode still works in new printers, but the  * implementation is very minimal: the printer uses exactly one nozzle of  * each color (the first one).  This makes printing extremely slow (more than  * 30 minutes for one 8.5x11" page), although the quality is extremely high  * with no visible banding whatsoever.  It's not good for the print head,  * though, since no ink is flowing through the other nozzles.  This leads to  * drying of ink and possible permanent damage to the print head.  *  * By the way, although the Epson manual says that microweave mode should be  * used at 720 dpi, 360 dpi continues to work in much the same way.  At 360  * dpi, data is fed to the printer one row at a time on all Epson printers.  * The pattern that the printer uses to print is very prone to banding.  * However, 360 dpi is inherently a low quality mode; if you're using it,  * presumably you don't much care about quality.  *  * Printers from roughly the Stylus Color 600 and later do not have the  * capability to do MicroWeave correctly.  Instead, the host must arrange  * the output in the order that it will be sent to the print head.  This  * is a very complex process; the jets in the print head are spaced more  * than one row (1/720") apart, so we can't simply send consecutive rows  * of dots to the printer.  Instead, we have to pass e. g. the first, ninth,  * 17th, 25th... rows in order for them to print in the correct position on  * the paper.  This interleaving process is called "soft" weaving.  *  * This decision was probably made to save money on memory in the printer.  * It certainly makes the driver code far more complicated than it would  * be if the printer could arrange the output.  Is that a bad thing?  * Usually this takes far less CPU time than the dithering process, and it  * does allow us more control over the printing process, e. g. to reduce  * banding.  Conceivably, we could even use this ability to map out bad  * jets.  *  * Interestingly, apparently the Windows (and presumably Macintosh) drivers  * for most or all Epson printers still list a "microweave" mode.  * Experiments have demonstrated that this does not in fact use the  * "microweave" mode of the printer.  Possibly it does nothing, or it uses  * a different weave pattern from what the non-"microweave" mode does.  * This is unnecessarily confusing.  *  * What makes this interesting is that there are many different ways of  * of accomplishing this goal.  The naive way would be to divide the image  * up into groups of 256 rows, and print all the mod8=0 rows in the first pass,  * mod8=1 rows in the second, and so forth.  The problem with this approach  * is that the individual ink jets are not perfectly uniform; some emit  * slightly bigger or smaller drops than others.  Since each group of 8  * adjacent rows is printed with the same nozzle, that means that there will  * be distinct streaks of lighter and darker bands within the image (8 rows  * is 1/90", which is visible; 1/720" is not).  Possibly worse is that these  * patterns will repeat every 256 rows.  This creates banding patterns that  * are about 1/3" wide.  *  * So we have to do something to break up this patterning.  *  * Epson does not publish the weaving algorithms that they use in their  * bundled drivers.  Indeed, their developer web site  * (http://www.ercipd.com/isv/edr_docs.htm) does not even describe how to  * do this weaving at all; it says that the only way to achieve 720 dpi  * is to use MicroWeave.  It does note (correctly) that 1440 dpi horizontal  * can only be achieved by the driver (i. e. in software).  The manual  * actually makes it fairly clear how to do this (it requires two passes  * with horizontal head movement between passes), and it is presumably  * possible to do this with MicroWeave.  *  * The information about how to do this is apparently available under NDA.  * It's actually easy enough to reverse engineer what's inside a print file  * with a simple Perl script.  There are presumably other printer commands  * that are not documented and may not be as easy to reverse engineer.  *  * I considered a few algorithms to perform the weave.  The first one I  * devised let me use only (jets - distance_between_jets + 1) nozzles, or  * 25.  This is OK in principle, but it's slower than using all nozzles.  * By playing around with it some more, I came up with an algorithm that  * lets me use all of the nozzles, except near the top and bottom of the  * page.  *  * This still produces some banding, though.  Even better quality can be  * achieved by using multiple nozzles on the same line.  How do we do this?  * In 1440x720 mode, we're printing two output lines at the same vertical  * position.  However, if we want four passes, we have to effectively print  * each line twice.  Actually doing this would increase the density, so  * what we do is print half the dots on each pass.  This produces near-perfect  * output, and it's far faster than using (pseudo) "MicroWeave".  *  * The current algorithm is not completely general.  The number of passes  * is limited to (nozzles / gap).  On the Photo EX class printers, that limits  * it to 4 -- 32 nozzles, an inter-nozzle gap of 8 lines.  Furthermore, there  * are a number of routines that are only coded up to 8 passes.  Fortunately,  * this is enough passes to get rid of most banding.  What's left is a very  * fine pattern that is sometimes described as "corduroy", since the pattern  * looks like that kind of fabric.  *  * Newer printers (those that support variable dot sizes, such as the 740,  * 1200, etc.) have an additional complication: when used in softweave mode,  * they operate at 360 dpi horizontal resolution.  This requires FOUR passes  * to achieve 1440x720 dpi.  Thus, to enable us to break up each row  * into separate sub-rows, we have to actually print each row eight times.  * Fortunately, all such printers have 48 nozzles and a gap of 6 rows,  * except for the high-speed 900, which uses 96 nozzles and a gap of 2 rows.  *  * I cannot let this entirely pass without commenting on the Stylus Color 440.  * This is a very low-end printer with 21 (!) nozzles and a separation of 8.  * The weave routine works correctly with single-pass printing, which is enough  * to minimally achieve 720 dpi output (it's physically a 720 dpi printer).  * However, the routine does not work correctly at more than one pass per row.  * Therefore, this printer bands badly.  *  * Yet another complication is how to get near the top and bottom of the page.  * This algorithm lets us print to within one head width of the top of the  * page, and a bit more than one head width from the bottom.  That leaves a  * lot of blank space.  Doing the weave properly outside of this region is  * increasingly difficult as we get closer to the edge of the paper; in the  * interior region, any nozzle can print any line, but near the top and  * bottom edges, only some nozzles can print.  We've handled this for now by  * using the naive way mentioned above near the borders, and switching over  * to the high quality method in the interior.  Unfortunately, this means  * that the quality is quite visibly degraded near the top and bottom of the  * page.  Algorithms that degrade more gracefully are more complicated.  * Epson does not advertise that the printers can print at the very top of the  * page, although in practice most or all of them can.  I suspect that the  * quality that can be achieved very close to the top is poor enough that  * Epson does not want to allow printing there.  That is a valid decision,  * although we have taken another approach.  *  * To compute the weave information, we need to start with the following  * information:  *  * 1) The number of jets the print head has for each color;  *  * 2) The separation in rows between the jets;  *  * 3) The horizontal resolution of the printer;  *  * 4) The desired horizontal resolution of the output;  *  * 5) The desired extra passes to reduce banding.  *  * As discussed above, each row is actually printed in one or more passes  * of the print head; we refer to these as subpasses.  For example, if we're  * printing at 1440(h)x720(v) on a printer with true horizontal resolution of  * 360 dpi, and we wish to print each line twice with different nozzles  * to reduce banding, we need to use 8 subpasses.  The dither routine  * will feed us a complete row of bits for each color; we have to split that  * up, first by round robining the bits to ensure that they get printed at  * the right micro-position, and then to split up the bits that are actually  * turned on into two equal chunks to reduce banding.  *  * Given the above information, and the desired row index and subpass (which  * together form a line number), we can compute:  *  * 1) Which pass this line belongs to.  Passes are numbered consecutively,  *    and each pass must logically (see #3 below) start at no smaller a row  *    number than the previous pass, as the printer cannot advance by a  *    negative amount.  *  * 2) Which jet will print this line.  *  * 3) The "logical" first line of this pass.  That is, what line would be  *    printed by jet 0 in this pass.  This number may be less than zero.  *    If it is, there are ghost lines that don't actually contain any data.  *    The difference between the logical first line of this pass and the  *    logical first line of the preceding pass tells us how many lines must  *    be advanced.  *  * 4) The "physical" first line of this pass.  That is, the first line index  *    that is actually printed in this pass.  This information lets us know  *    when we must prepare this pass.  *  * 5) The last line of this pass.  This lets us know when we must actually  *    send this pass to the printer.  *  * 6) The number of ghost rows this pass contains.  We must still send the  *    ghost data to the printer, so this lets us know how much data we must  *    fill in prior to the start of the pass.  *  * The bookkeeping to keep track of all this stuff is quite hairy, and needs  * to be documented separately.  *  * The routine initialize_weave calculates the basic parameters, given  * the number of jets and separation between jets, in rows.  *  * -- Robert Krawitz<rlk@alum.mit.edu) November 3, 1999  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !WEAVETEST */
end_comment

begin_typedef
typedef|typedef
struct|struct
comment|/* Weave parameters for a specific row */
DECL|struct|__anon2a95129a0508
block|{
DECL|member|row
name|int
name|row
decl_stmt|;
comment|/* Absolute row # */
DECL|member|pass
name|int
name|pass
decl_stmt|;
comment|/* Computed pass # */
DECL|member|jet
name|int
name|jet
decl_stmt|;
comment|/* Which physical nozzle we're using */
DECL|member|missingstartrows
name|int
name|missingstartrows
decl_stmt|;
comment|/* Phantom rows (nonexistent rows that */
comment|/* would be printed by nozzles lower than */
comment|/* the first nozzle we're using this pass; */
comment|/* with the current algorithm, always zero */
DECL|member|logicalpassstart
name|int
name|logicalpassstart
decl_stmt|;
comment|/* Offset in rows (from start of image) */
comment|/* that the printer must be for this row */
comment|/* to print correctly with the specified jet */
DECL|member|physpassstart
name|int
name|physpassstart
decl_stmt|;
comment|/* Offset in rows to the first row printed */
comment|/* in this pass.  Currently always equal to */
comment|/* logicalpassstart */
DECL|member|physpassend
name|int
name|physpassend
decl_stmt|;
comment|/* Offset in rows (from start of image) to */
comment|/* the last row that will be printed this */
comment|/* pass (assuming that we're printing a full */
comment|/* pass). */
DECL|typedef|weave_t
block|}
name|weave_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
comment|/* Weave parameters for a specific pass */
DECL|struct|__anon2a95129a0608
block|{
DECL|member|pass
name|int
name|pass
decl_stmt|;
comment|/* Absolute pass number */
DECL|member|missingstartrows
name|int
name|missingstartrows
decl_stmt|;
comment|/* All other values the same as weave_t */
DECL|member|logicalpassstart
name|int
name|logicalpassstart
decl_stmt|;
DECL|member|physpassstart
name|int
name|physpassstart
decl_stmt|;
DECL|member|physpassend
name|int
name|physpassend
decl_stmt|;
DECL|member|subpass
name|int
name|subpass
decl_stmt|;
DECL|typedef|pass_t
block|}
name|pass_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon2a95129a070a
typedef|typedef
union|union
block|{
comment|/* Offsets from the start of each line */
DECL|member|v
name|off_t
name|v
index|[
literal|6
index|]
decl_stmt|;
comment|/* (really pass) */
DECL|struct|__anon2a95129a0808
struct|struct
block|{
DECL|member|k
name|off_t
name|k
decl_stmt|;
DECL|member|m
name|off_t
name|m
decl_stmt|;
DECL|member|c
name|off_t
name|c
decl_stmt|;
DECL|member|y
name|off_t
name|y
decl_stmt|;
DECL|member|M
name|off_t
name|M
decl_stmt|;
DECL|member|C
name|off_t
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|lineoff_t
block|}
name|lineoff_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon2a95129a090a
typedef|typedef
union|union
block|{
comment|/* Is this line active? */
DECL|member|v
name|char
name|v
index|[
literal|6
index|]
decl_stmt|;
comment|/* (really pass) */
DECL|struct|__anon2a95129a0a08
struct|struct
block|{
DECL|member|k
name|char
name|k
decl_stmt|;
DECL|member|m
name|char
name|m
decl_stmt|;
DECL|member|c
name|char
name|c
decl_stmt|;
DECL|member|y
name|char
name|y
decl_stmt|;
DECL|member|M
name|char
name|M
decl_stmt|;
DECL|member|C
name|char
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|lineactive_t
block|}
name|lineactive_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon2a95129a0b0a
typedef|typedef
union|union
block|{
comment|/* Base pointers for each pass */
DECL|member|v
name|unsigned
name|char
modifier|*
name|v
index|[
literal|6
index|]
decl_stmt|;
DECL|struct|__anon2a95129a0c08
struct|struct
block|{
DECL|member|k
name|unsigned
name|char
modifier|*
name|k
decl_stmt|;
DECL|member|m
name|unsigned
name|char
modifier|*
name|m
decl_stmt|;
DECL|member|c
name|unsigned
name|char
modifier|*
name|c
decl_stmt|;
DECL|member|y
name|unsigned
name|char
modifier|*
name|y
decl_stmt|;
DECL|member|M
name|unsigned
name|char
modifier|*
name|M
decl_stmt|;
DECL|member|C
name|unsigned
name|char
modifier|*
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|linebufs_t
block|}
name|linebufs_t
typedef|;
end_typedef

begin_typedef
DECL|struct|__anon2a95129a0d08
typedef|typedef
struct|struct
block|{
DECL|member|linebases
name|linebufs_t
modifier|*
name|linebases
decl_stmt|;
comment|/* Base address of each row buffer */
DECL|member|lineoffsets
name|lineoff_t
modifier|*
name|lineoffsets
decl_stmt|;
comment|/* Offsets within each row buffer */
DECL|member|lineactive
name|lineactive_t
modifier|*
name|lineactive
decl_stmt|;
comment|/* Does this line have anything printed? */
DECL|member|linecounts
name|int
modifier|*
name|linecounts
decl_stmt|;
comment|/* How many rows we've printed this pass */
DECL|member|passes
name|pass_t
modifier|*
name|passes
decl_stmt|;
comment|/* Circular list of pass numbers */
DECL|member|last_pass_offset
name|int
name|last_pass_offset
decl_stmt|;
comment|/* Starting row (offset from the start of */
comment|/* the page) of the most recently printed */
comment|/* pass (so we can determine how far to */
comment|/* advance the paper) */
DECL|member|last_pass
name|int
name|last_pass
decl_stmt|;
comment|/* Number of the most recently printed pass */
DECL|member|jets
name|int
name|jets
decl_stmt|;
comment|/* Number of jets per color */
DECL|member|separation
name|int
name|separation
decl_stmt|;
comment|/* Offset from one jet to the next in rows */
DECL|member|weaveparm
name|void
modifier|*
name|weaveparm
decl_stmt|;
comment|/* Weave calculation parameter block */
DECL|member|horizontal_weave
name|int
name|horizontal_weave
decl_stmt|;
comment|/* Number of horizontal passes required */
comment|/* This is> 1 for some of the ultra-high */
comment|/* resolution modes */
DECL|member|vertical_subpasses
name|int
name|vertical_subpasses
decl_stmt|;
comment|/* Number of passes per line (for better */
comment|/* quality) */
DECL|member|vmod
name|int
name|vmod
decl_stmt|;
comment|/* Number of banks of passes */
DECL|member|oversample
name|int
name|oversample
decl_stmt|;
comment|/* Excess precision per row */
DECL|member|ncolors
name|int
name|ncolors
decl_stmt|;
comment|/* How many colors (1, 4, or 6) */
DECL|member|horizontal_width
name|int
name|horizontal_width
decl_stmt|;
comment|/* Line width in output pixels */
DECL|member|vertical_height
name|int
name|vertical_height
decl_stmt|;
comment|/* Image height in output pixels */
DECL|member|firstline
name|int
name|firstline
decl_stmt|;
comment|/* Actual first line (referenced to paper) */
DECL|member|bitwidth
name|int
name|bitwidth
decl_stmt|;
comment|/* Bits per pixel */
DECL|member|lineno
name|int
name|lineno
decl_stmt|;
DECL|member|vertical_oversample
name|int
name|vertical_oversample
decl_stmt|;
comment|/* Vertical oversampling */
DECL|member|current_vertical_subpass
name|int
name|current_vertical_subpass
decl_stmt|;
DECL|member|separation_rows
name|int
name|separation_rows
decl_stmt|;
comment|/* Vertical spacing between rows. */
comment|/* This is used for the 1520/3000, which */
comment|/* use a funny value for the "print density */
comment|/* in the vertical direction". */
DECL|member|last_color
name|int
name|last_color
decl_stmt|;
DECL|typedef|escp2_softweave_t
block|}
name|escp2_softweave_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|WEAVETEST
end_ifndef

begin_function
specifier|static
specifier|inline
name|int
DECL|function|get_color_by_params (int plane,int density)
name|get_color_by_params
parameter_list|(
name|int
name|plane
parameter_list|,
name|int
name|density
parameter_list|)
block|{
if|if
condition|(
name|plane
operator|>
literal|4
operator|||
name|plane
operator|<
literal|0
operator|||
name|density
operator|>
literal|1
operator|||
name|density
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|color_indices
index|[
name|density
operator|*
literal|8
operator|+
name|plane
index|]
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize the weave parameters  *  * Rules:  *  * 1) Currently, osample * v_subpasses * v_subsample<= 8, and no one  *    of these variables may exceed 4.  *  * 2) first_line>= 0  *  * 3) line_height< physlines  *  * 4) phys_lines>= 2 * jets * sep  */
end_comment

begin_function
specifier|static
name|void
modifier|*
DECL|function|initialize_weave (int jets,int sep,int osample,int v_subpasses,int v_subsample,colormode_t colormode,int width,int linewidth,int lineheight,int separation_rows,int first_line,int phys_lines)
name|initialize_weave
parameter_list|(
name|int
name|jets
parameter_list|,
comment|/* Width of print head */
name|int
name|sep
parameter_list|,
comment|/* Separation in rows between jets */
name|int
name|osample
parameter_list|,
comment|/* Horizontal oversample */
name|int
name|v_subpasses
parameter_list|,
comment|/* Vertical passes */
name|int
name|v_subsample
parameter_list|,
comment|/* Vertical oversampling */
name|colormode_t
name|colormode
parameter_list|,
comment|/* mono, 4 color, 6 color */
name|int
name|width
parameter_list|,
comment|/* bits/pixel */
name|int
name|linewidth
parameter_list|,
comment|/* Width of a line, in pixels */
name|int
name|lineheight
parameter_list|,
comment|/* Number of lines that will be printed */
name|int
name|separation_rows
parameter_list|,
comment|/* Vertical spacing adjustment */
comment|/* for weird printers (1520/3000, */
comment|/* although they don't seem to do softweave */
comment|/* anyway) */
name|int
name|first_line
parameter_list|,
comment|/* First line that will be printed on page */
name|int
name|phys_lines
parameter_list|)
comment|/* Total height of the page in rows */
block|{
name|int
name|i
decl_stmt|;
name|escp2_softweave_t
modifier|*
name|sw
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|escp2_softweave_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sw
operator|==
literal|0
condition|)
return|return
name|sw
return|;
if|if
condition|(
name|jets
operator|<
literal|1
condition|)
name|jets
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|jets
operator|==
literal|1
operator|||
name|sep
operator|<
literal|1
condition|)
name|sep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v_subpasses
operator|<
literal|1
condition|)
name|v_subpasses
operator|=
literal|1
expr_stmt|;
name|sw
operator|->
name|separation
operator|=
name|sep
expr_stmt|;
name|sw
operator|->
name|jets
operator|=
name|jets
expr_stmt|;
name|sw
operator|->
name|horizontal_weave
operator|=
name|osample
expr_stmt|;
name|sw
operator|->
name|vertical_oversample
operator|=
name|v_subsample
expr_stmt|;
name|sw
operator|->
name|vertical_subpasses
operator|=
name|v_subpasses
expr_stmt|;
name|sw
operator|->
name|oversample
operator|=
name|osample
operator|*
name|v_subpasses
operator|*
name|v_subsample
expr_stmt|;
name|sw
operator|->
name|firstline
operator|=
name|first_line
expr_stmt|;
name|sw
operator|->
name|lineno
operator|=
name|first_line
expr_stmt|;
if|if
condition|(
name|sw
operator|->
name|oversample
operator|>
name|jets
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Weave error: oversample (%d)> jets (%d)\n"
argument_list|,
name|sw
operator|->
name|oversample
argument_list|,
name|jets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sw
operator|->
name|weaveparm
operator|=
name|initialize_weave_params
argument_list|(
name|sw
operator|->
name|separation
argument_list|,
name|sw
operator|->
name|jets
argument_list|,
name|sw
operator|->
name|oversample
argument_list|,
name|first_line
argument_list|,
name|first_line
operator|+
name|lineheight
operator|-
literal|1
argument_list|,
name|phys_lines
argument_list|)
expr_stmt|;
comment|/*    * The value of vmod limits how many passes may be unfinished at a time.    * If pass x is not yet printed, pass x+vmod cannot be started.    */
name|sw
operator|->
name|vmod
operator|=
literal|2
operator|*
name|sw
operator|->
name|separation
operator|*
name|sw
operator|->
name|oversample
expr_stmt|;
name|sw
operator|->
name|separation_rows
operator|=
name|separation_rows
expr_stmt|;
name|sw
operator|->
name|bitwidth
operator|=
name|width
expr_stmt|;
name|sw
operator|->
name|last_pass_offset
operator|=
literal|0
expr_stmt|;
name|sw
operator|->
name|last_pass
operator|=
operator|-
literal|1
expr_stmt|;
name|sw
operator|->
name|current_vertical_subpass
operator|=
literal|0
expr_stmt|;
name|sw
operator|->
name|last_color
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|colormode
condition|)
block|{
case|case
name|COLOR_MONOCHROME
case|:
name|sw
operator|->
name|ncolors
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|COLOR_CMYK
case|:
name|sw
operator|->
name|ncolors
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|COLOR_CCMMYK
case|:
default|default:
name|sw
operator|->
name|ncolors
operator|=
literal|6
expr_stmt|;
break|break;
block|}
comment|/*    * It's possible for the "compression" to actually expand the line by    * one part in 128.    */
name|sw
operator|->
name|horizontal_width
operator|=
operator|(
name|linewidth
operator|+
literal|128
operator|+
literal|7
operator|)
operator|*
literal|129
operator|/
literal|128
expr_stmt|;
name|sw
operator|->
name|vertical_height
operator|=
name|lineheight
expr_stmt|;
name|sw
operator|->
name|lineoffsets
operator|=
name|malloc
argument_list|(
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|lineoff_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sw
operator|->
name|lineoffsets
argument_list|,
literal|0
argument_list|,
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|lineoff_t
argument_list|)
argument_list|)
expr_stmt|;
name|sw
operator|->
name|lineactive
operator|=
name|malloc
argument_list|(
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|lineactive_t
argument_list|)
argument_list|)
expr_stmt|;
name|sw
operator|->
name|linebases
operator|=
name|malloc
argument_list|(
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|linebufs_t
argument_list|)
argument_list|)
expr_stmt|;
name|sw
operator|->
name|passes
operator|=
name|malloc
argument_list|(
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|pass_t
argument_list|)
argument_list|)
expr_stmt|;
name|sw
operator|->
name|linecounts
operator|=
name|malloc
argument_list|(
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sw
operator|->
name|linecounts
argument_list|,
literal|0
argument_list|,
name|sw
operator|->
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|vmod
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|sw
operator|->
name|passes
index|[
name|i
index|]
operator|.
name|pass
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
name|sw
operator|->
name|linebases
index|[
name|i
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
name|malloc
argument_list|(
name|jets
operator|*
name|sw
operator|->
name|bitwidth
operator|*
name|sw
operator|->
name|horizontal_width
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|sw
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|destroy_weave (void * vsw)
name|destroy_weave
parameter_list|(
name|void
modifier|*
name|vsw
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|escp2_softweave_t
modifier|*
name|sw
init|=
operator|(
name|escp2_softweave_t
operator|*
operator|)
name|vsw
decl_stmt|;
name|free
argument_list|(
name|sw
operator|->
name|linecounts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sw
operator|->
name|passes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sw
operator|->
name|lineactive
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sw
operator|->
name|lineoffsets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|vmod
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
name|free
argument_list|(
name|sw
operator|->
name|linebases
index|[
name|i
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sw
operator|->
name|linebases
argument_list|)
expr_stmt|;
name|destroy_weave_params
argument_list|(
name|sw
operator|->
name|weaveparm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vsw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|weave_parameters_by_row (const escp2_softweave_t * sw,int row,int vertical_subpass,weave_t * w)
name|weave_parameters_by_row
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|vertical_subpass
parameter_list|,
name|weave_t
modifier|*
name|w
parameter_list|)
block|{
specifier|static
specifier|const
name|escp2_softweave_t
modifier|*
name|scache
init|=
literal|0
decl_stmt|;
specifier|static
name|weave_t
name|wcache
decl_stmt|;
specifier|static
name|int
name|rcache
init|=
operator|-
literal|2
decl_stmt|;
specifier|static
name|int
name|vcache
init|=
operator|-
literal|2
decl_stmt|;
name|int
name|jetsused
decl_stmt|;
if|if
condition|(
name|scache
operator|==
name|sw
operator|&&
name|rcache
operator|==
name|row
operator|&&
name|vcache
operator|==
name|vertical_subpass
condition|)
block|{
name|memcpy
argument_list|(
name|w
argument_list|,
operator|&
name|wcache
argument_list|,
sizeof|sizeof
argument_list|(
name|weave_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|scache
operator|=
name|sw
expr_stmt|;
name|rcache
operator|=
name|row
expr_stmt|;
name|vcache
operator|=
name|vertical_subpass
expr_stmt|;
name|w
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|calculate_row_parameters
argument_list|(
name|sw
operator|->
name|weaveparm
argument_list|,
name|row
argument_list|,
name|vertical_subpass
argument_list|,
operator|&
name|w
operator|->
name|pass
argument_list|,
operator|&
name|w
operator|->
name|jet
argument_list|,
operator|&
name|w
operator|->
name|logicalpassstart
argument_list|,
operator|&
name|w
operator|->
name|missingstartrows
argument_list|,
operator|&
name|jetsused
argument_list|)
expr_stmt|;
name|w
operator|->
name|physpassstart
operator|=
name|w
operator|->
name|logicalpassstart
operator|+
name|sw
operator|->
name|separation
operator|*
name|w
operator|->
name|missingstartrows
expr_stmt|;
name|w
operator|->
name|physpassend
operator|=
name|w
operator|->
name|physpassstart
operator|+
name|sw
operator|->
name|separation
operator|*
operator|(
name|jetsused
operator|-
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wcache
argument_list|,
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|weave_t
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("row %d, jet %d of pass %d "          "(pos %d, start %d, end %d, missing rows %d\n",          w->row, w->jet, w->pass, w->logicalpassstart, w->physpassstart,          w->physpassend, w->missingstartrows);
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|WEAVETEST
end_ifndef

begin_function
specifier|static
name|lineoff_t
modifier|*
DECL|function|get_lineoffsets (const escp2_softweave_t * sw,int row,int subpass)
name|get_lineoffsets
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|sw
operator|->
name|lineoffsets
index|[
name|w
operator|.
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lineactive_t
modifier|*
DECL|function|get_lineactive (const escp2_softweave_t * sw,int row,int subpass)
name|get_lineactive
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|sw
operator|->
name|lineactive
index|[
name|w
operator|.
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
DECL|function|get_linecount (const escp2_softweave_t * sw,int row,int subpass)
name|get_linecount
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|sw
operator|->
name|linecounts
index|[
name|w
operator|.
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|linebufs_t
modifier|*
DECL|function|get_linebases (const escp2_softweave_t * sw,int row,int subpass)
name|get_linebases
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|sw
operator|->
name|linebases
index|[
name|w
operator|.
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pass_t
modifier|*
DECL|function|get_pass_by_row (const escp2_softweave_t * sw,int row,int subpass)
name|get_pass_by_row
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|sw
operator|->
name|passes
index|[
name|w
operator|.
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lineoff_t
modifier|*
DECL|function|get_lineoffsets_by_pass (const escp2_softweave_t * sw,int pass)
name|get_lineoffsets_by_pass
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|sw
operator|->
name|lineoffsets
index|[
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lineactive_t
modifier|*
DECL|function|get_lineactive_by_pass (const escp2_softweave_t * sw,int pass)
name|get_lineactive_by_pass
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|sw
operator|->
name|lineactive
index|[
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
DECL|function|get_linecount_by_pass (const escp2_softweave_t * sw,int pass)
name|get_linecount_by_pass
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|sw
operator|->
name|linecounts
index|[
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|linebufs_t
modifier|*
DECL|function|get_linebases_by_pass (const escp2_softweave_t * sw,int pass)
name|get_linebases_by_pass
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|sw
operator|->
name|linebases
index|[
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pass_t
modifier|*
DECL|function|get_pass_by_pass (const escp2_softweave_t * sw,int pass)
name|get_pass_by_pass
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|sw
operator|->
name|passes
index|[
name|pass
operator|%
name|sw
operator|->
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If there are phantom rows at the beginning of a pass, fill them in so  * that the printer knows exactly what it doesn't have to print.  We're  * using RLE compression here.  Each line must be specified independently,  * so we have to compute how many full blocks (groups of 128 bytes, or 1024  * "off" pixels) and how much leftover is needed.  Note that we can only  * RLE-encode groups of 2 or more bytes; single bytes must be specified  * with a count of 1.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|fillin_start_rows (const escp2_softweave_t * sw,int row,int subpass,int width,int missingstartrows)
name|fillin_start_rows
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|missingstartrows
parameter_list|)
block|{
name|lineoff_t
modifier|*
name|offsets
init|=
name|get_lineoffsets
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|subpass
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|width
operator|=
name|sw
operator|->
name|bitwidth
operator|*
name|width
operator|*
literal|8
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|missingstartrows
condition|;
name|k
operator|++
control|)
block|{
name|int
name|bytes_to_fill
init|=
name|width
decl_stmt|;
name|int
name|full_blocks
init|=
name|bytes_to_fill
operator|/
operator|(
literal|128
operator|*
literal|8
operator|)
decl_stmt|;
name|int
name|leftover
init|=
operator|(
literal|7
operator|+
operator|(
name|bytes_to_fill
operator|%
operator|(
literal|128
operator|*
literal|8
operator|)
operator|)
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|l
operator|<
name|full_blocks
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
operator|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|129
expr_stmt|;
operator|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|leftover
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
operator|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|1
expr_stmt|;
operator|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftover
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
operator|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|257
operator|-
name|leftover
expr_stmt|;
operator|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
name|offsets
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|2
operator|*
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|initialize_row (const escp2_softweave_t * sw,int row,int width)
name|initialize_row
parameter_list|(
specifier|const
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|oversample
condition|;
name|i
operator|++
control|)
block|{
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|physpassstart
operator|==
name|row
condition|)
block|{
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|lineactive_t
modifier|*
name|lineactive
init|=
name|get_lineactive
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
modifier|*
name|linecount
init|=
name|get_linecount
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|pass
operator|->
name|pass
operator|=
name|w
operator|.
name|pass
expr_stmt|;
name|pass
operator|->
name|missingstartrows
operator|=
name|w
operator|.
name|missingstartrows
expr_stmt|;
name|pass
operator|->
name|logicalpassstart
operator|=
name|w
operator|.
name|logicalpassstart
expr_stmt|;
name|pass
operator|->
name|physpassstart
operator|=
name|w
operator|.
name|physpassstart
expr_stmt|;
name|pass
operator|->
name|physpassend
operator|=
name|w
operator|.
name|physpassend
expr_stmt|;
name|pass
operator|->
name|subpass
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: pass %d subpass %d row %d: lineoffs %ld\n"
argument_list|,
name|w
operator|.
name|pass
argument_list|,
name|i
argument_list|,
name|row
argument_list|,
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|lineactive
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|linecount
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: pass %d subpass %d row %d: linecount %d\n"
argument_list|,
name|w
operator|.
name|pass
argument_list|,
name|i
argument_list|,
name|row
argument_list|,
operator|*
name|linecount
argument_list|)
expr_stmt|;
operator|*
name|linecount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|missingstartrows
operator|>
literal|0
condition|)
name|fillin_start_rows
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|w
operator|.
name|missingstartrows
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A fair bit of this code is duplicated from escp2_write.  That's rather  * a pity.  It's also not correct for any but the 6-color printers.  One of  * these days I'll unify it.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|flush_pass (escp2_softweave_t * sw,int passno,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn,int vertical_subpass)
name|flush_pass
parameter_list|(
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|passno
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|,
name|int
name|vertical_subpass
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets_by_pass
argument_list|(
name|sw
argument_list|,
name|passno
argument_list|)
decl_stmt|;
name|lineactive_t
modifier|*
name|lineactive
init|=
name|get_lineactive_by_pass
argument_list|(
name|sw
argument_list|,
name|passno
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases_by_pass
argument_list|(
name|sw
argument_list|,
name|passno
argument_list|)
decl_stmt|;
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_pass
argument_list|(
name|sw
argument_list|,
name|passno
argument_list|)
decl_stmt|;
name|int
modifier|*
name|linecount
init|=
name|get_linecount_by_pass
argument_list|(
name|sw
argument_list|,
name|passno
argument_list|)
decl_stmt|;
name|int
name|lwidth
init|=
operator|(
name|width
operator|+
operator|(
name|sw
operator|->
name|horizontal_weave
operator|-
literal|1
operator|)
operator|)
operator|/
name|sw
operator|->
name|horizontal_weave
decl_stmt|;
name|int
name|microoffset
init|=
name|vertical_subpass
operator|&
operator|(
name|sw
operator|->
name|horizontal_weave
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|ydpi
operator|>
literal|720
condition|)
name|ydpi
operator|=
literal|720
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lineactive
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pass
operator|->
name|logicalpassstart
operator|>
name|sw
operator|->
name|last_pass_offset
condition|)
block|{
name|int
name|advance
init|=
name|pass
operator|->
name|logicalpassstart
operator|-
name|sw
operator|->
name|last_pass_offset
operator|-
operator|(
name|sw
operator|->
name|separation_rows
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|alo
init|=
name|advance
operator|%
literal|256
decl_stmt|;
name|int
name|ahi
init|=
name|advance
operator|/
literal|256
decl_stmt|;
if|if
condition|(
operator|!
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
condition|)
block|{
name|int
name|a3
init|=
operator|(
name|advance
operator|>>
literal|16
operator|)
operator|%
literal|256
decl_stmt|;
name|int
name|a4
init|=
operator|(
name|advance
operator|>>
literal|24
operator|)
operator|%
literal|256
decl_stmt|;
name|ahi
operator|=
name|ahi
operator|%
literal|256
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(v\004%c%c%c%c%c"
argument_list|,
literal|0
argument_list|,
name|alo
argument_list|,
name|ahi
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(v\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|alo
argument_list|,
name|ahi
argument_list|)
expr_stmt|;
name|sw
operator|->
name|last_pass_offset
operator|=
name|pass
operator|->
name|logicalpassstart
expr_stmt|;
block|}
if|if
condition|(
name|last_color
operator|!=
name|j
condition|)
block|{
if|if
condition|(
operator|!
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(r\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|last_color
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
condition|)
block|{
comment|/* FIXME need a more general way of specifying column */
comment|/* separation */
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_COMMAND_MASK
argument_list|,
name|MODEL_COMMAND_1999
argument_list|)
operator|&&
operator|!
operator|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
operator|)
condition|)
block|{
name|int
name|pos
init|=
operator|(
operator|(
name|hoffset
operator|*
name|xdpi
operator|/
name|ydpi
operator|)
operator|+
name|microoffset
operator|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033($%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|pos
operator|&
literal|255
argument_list|,
operator|(
name|pos
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|pos
operator|>>
literal|16
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|pos
operator|>>
literal|24
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|pos
init|=
operator|(
operator|(
name|hoffset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
name|microoffset
operator|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(\\%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|160
argument_list|,
literal|5
argument_list|,
name|pos
operator|&
literal|255
argument_list|,
name|pos
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|pos
init|=
operator|(
name|hoffset
operator|+
name|microoffset
operator|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|pos
operator|&
literal|255
argument_list|,
name|pos
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_VARIABLE_DOT_MASK
argument_list|,
name|MODEL_VARIABLE_NORMAL
argument_list|)
condition|)
block|{
name|int
name|ncolor
init|=
operator|(
name|densities
index|[
name|j
index|]
operator|<<
literal|4
operator|)
operator||
name|colors
index|[
name|j
index|]
decl_stmt|;
name|int
name|nlines
init|=
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
decl_stmt|;
name|int
name|nwidth
init|=
name|sw
operator|->
name|bitwidth
operator|*
operator|(
operator|(
name|lwidth
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033i%c%c%c%c%c%c%c"
argument_list|,
name|ncolor
argument_list|,
literal|1
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|nwidth
operator|&
literal|255
argument_list|,
name|nwidth
operator|>>
literal|8
argument_list|,
name|nlines
operator|&
literal|255
argument_list|,
name|nlines
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|dotsep
init|=
literal|3600
operator|/
name|ydpi
decl_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_720DPI_MODE_MASK
argument_list|,
name|MODEL_720DPI_600
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033.%c%c%c%c"
argument_list|,
literal|1
argument_list|,
literal|8
operator|*
name|dotsep
argument_list|,
name|dotsep
argument_list|,
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|escp2_pseudo_separation_rows
argument_list|(
name|model
argument_list|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033.%c%c%c%c"
argument_list|,
literal|1
argument_list|,
name|dotsep
operator|*
name|escp2_pseudo_separation_rows
argument_list|(
name|model
argument_list|)
argument_list|,
name|dotsep
argument_list|,
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033.%c%c%c%c"
argument_list|,
literal|1
argument_list|,
name|dotsep
operator|*
name|sw
operator|->
name|separation_rows
argument_list|,
name|dotsep
argument_list|,
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|lwidth
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|lwidth
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|,
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
operator|*
name|linecount
operator|=
literal|0
expr_stmt|;
name|sw
operator|->
name|last_pass
operator|=
name|pass
operator|->
name|pass
expr_stmt|;
name|pass
operator|->
name|pass
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|add_to_row (escp2_softweave_t * sw,int row,unsigned char * buf,size_t nbytes,int plane,int density,int setactive,lineoff_t * lineoffs,lineactive_t * lineactive,const linebufs_t * bufs)
name|add_to_row
parameter_list|(
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|density
parameter_list|,
name|int
name|setactive
parameter_list|,
name|lineoff_t
modifier|*
name|lineoffs
parameter_list|,
name|lineactive_t
modifier|*
name|lineactive
parameter_list|,
specifier|const
name|linebufs_t
modifier|*
name|bufs
parameter_list|)
block|{
name|int
name|color
init|=
name|get_color_by_params
argument_list|(
name|plane
argument_list|,
name|density
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
operator|+
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|setactive
condition|)
name|lineactive
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_flush (void * vsw,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|escp2_flush
parameter_list|(
name|void
modifier|*
name|vsw
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|escp2_softweave_t
modifier|*
name|sw
init|=
operator|(
name|escp2_softweave_t
operator|*
operator|)
name|vsw
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_pass
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|last_pass
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/*        * This ought to be   pass->physpassend>  sw->lineno        * but that causes rubbish to be output for some reason.        */
if|if
condition|(
name|pass
operator|->
name|pass
operator|<
literal|0
operator|||
name|pass
operator|->
name|physpassend
operator|>=
name|sw
operator|->
name|lineno
condition|)
return|return;
name|flush_pass
argument_list|(
name|sw
argument_list|,
name|pass
operator|->
name|pass
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|,
name|pass
operator|->
name|subpass
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_flush_all (void * vsw,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|escp2_flush_all
parameter_list|(
name|void
modifier|*
name|vsw
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|escp2_softweave_t
modifier|*
name|sw
init|=
operator|(
name|escp2_softweave_t
operator|*
operator|)
name|vsw
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_pass
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|last_pass
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/*        * This ought to be   pass->physpassend>  sw->lineno        * but that causes rubbish to be output for some reason.        */
if|if
condition|(
name|pass
operator|->
name|pass
operator|<
literal|0
condition|)
return|return;
name|flush_pass
argument_list|(
name|sw
argument_list|,
name|pass
operator|->
name|pass
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|,
name|pass
operator|->
name|subpass
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|finalize_row (escp2_softweave_t * sw,int row,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|finalize_row
parameter_list|(
name|escp2_softweave_t
modifier|*
name|sw
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|printf("Finalizing row %d...\n", row);
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|oversample
condition|;
name|i
operator|++
control|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
modifier|*
name|lines
init|=
name|get_linecount
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|sw
argument_list|,
name|row
argument_list|,
name|i
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lines
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|physpassend
operator|==
name|row
condition|)
block|{
if|#
directive|if
literal|0
block|printf("Pass=%d, physpassend=%d, row=%d, lineno=%d, trying to flush...\n", w.pass, w.physpassend, row, sw->lineno);
endif|#
directive|endif
name|escp2_flush
argument_list|(
name|sw
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_write_weave (void * vsw,FILE * prn,int length,int ydpi,int model,int width,int offset,int xdpi,const unsigned char * c,const unsigned char * m,const unsigned char * y,const unsigned char * k,const unsigned char * C,const unsigned char * M)
name|escp2_write_weave
parameter_list|(
name|void
modifier|*
name|vsw
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|,
comment|/* I - Offset from left side of page */
name|int
name|xdpi
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|C
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|M
parameter_list|)
block|{
name|escp2_softweave_t
modifier|*
name|sw
init|=
operator|(
name|escp2_softweave_t
operator|*
operator|)
name|vsw
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|s
index|[
literal|8
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|fold_buf
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|comp_buf
decl_stmt|;
name|lineoff_t
modifier|*
name|lineoffs
index|[
literal|8
index|]
decl_stmt|;
name|lineactive_t
modifier|*
name|lineactives
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
index|[
literal|8
index|]
decl_stmt|;
name|int
name|xlength
init|=
operator|(
name|length
operator|+
name|sw
operator|->
name|horizontal_weave
operator|-
literal|1
operator|)
operator|/
name|sw
operator|->
name|horizontal_weave
decl_stmt|;
name|unsigned
name|char
modifier|*
name|comp_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|setactive
decl_stmt|;
name|int
name|h_passes
init|=
name|sw
operator|->
name|horizontal_weave
operator|*
name|sw
operator|->
name|vertical_subpasses
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cols
index|[
literal|6
index|]
decl_stmt|;
name|cols
index|[
literal|0
index|]
operator|=
name|k
expr_stmt|;
name|cols
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|cols
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|cols
index|[
literal|3
index|]
operator|=
name|y
expr_stmt|;
name|cols
index|[
literal|4
index|]
operator|=
name|M
expr_stmt|;
name|cols
index|[
literal|5
index|]
operator|=
name|C
expr_stmt|;
if|if
condition|(
operator|!
name|fold_buf
condition|)
name|fold_buf
operator|=
name|malloc
argument_list|(
name|COMPBUFWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comp_buf
condition|)
name|comp_buf
operator|=
name|malloc
argument_list|(
name|COMPBUFWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|->
name|current_vertical_subpass
operator|==
literal|0
condition|)
name|initialize_row
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|xlength
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h_passes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|cpass
init|=
name|sw
operator|->
name|current_vertical_subpass
operator|*
name|h_passes
decl_stmt|;
if|if
condition|(
operator|!
name|s
index|[
name|i
index|]
condition|)
name|s
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|COMPBUFWIDTH
argument_list|)
expr_stmt|;
name|lineoffs
index|[
name|i
index|]
operator|=
name|get_lineoffsets
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|cpass
operator|+
name|i
argument_list|)
expr_stmt|;
name|lineactives
index|[
name|i
index|]
operator|=
name|get_lineactive
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|cpass
operator|+
name|i
argument_list|)
expr_stmt|;
name|bufs
index|[
name|i
index|]
operator|=
name|get_linebases
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|cpass
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sw
operator|->
name|ncolors
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cols
index|[
name|j
index|]
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
if|if
condition|(
name|sw
operator|->
name|bitwidth
operator|==
literal|2
condition|)
block|{
name|escp2_fold
argument_list|(
name|cols
index|[
name|j
index|]
argument_list|,
name|length
argument_list|,
name|fold_buf
argument_list|)
expr_stmt|;
name|in
operator|=
name|fold_buf
expr_stmt|;
block|}
else|else
name|in
operator|=
name|cols
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|h_passes
operator|>
literal|1
condition|)
block|{
switch|switch
condition|(
name|sw
operator|->
name|horizontal_weave
condition|)
block|{
case|case
literal|2
case|:
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|in
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|in
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sw
operator|->
name|vertical_subpasses
condition|)
block|{
case|case
literal|4
case|:
switch|switch
condition|(
name|sw
operator|->
name|horizontal_weave
condition|)
block|{
case|case
literal|1
case|:
name|escp2_split_4
argument_list|(
name|length
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|in
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|escp2_split_4
argument_list|(
name|length
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|escp2_split_4
argument_list|(
name|length
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|s
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|sw
operator|->
name|horizontal_weave
condition|)
block|{
case|case
literal|1
case|:
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|in
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|escp2_split_2
argument_list|(
name|xlength
argument_list|,
name|sw
operator|->
name|bitwidth
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* case 1 is taken care of because the various unpack */
comment|/* functions will do the trick themselves */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h_passes
condition|;
name|i
operator|++
control|)
block|{
name|setactive
operator|=
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
name|sw
operator|->
name|bitwidth
operator|*
name|xlength
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|setactive
argument_list|,
name|lineoffs
index|[
name|i
index|]
argument_list|,
name|lineactives
index|[
name|i
index|]
argument_list|,
name|bufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|setactive
operator|=
name|escp2_pack
argument_list|(
name|in
argument_list|,
name|length
operator|*
name|sw
operator|->
name|bitwidth
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|setactive
argument_list|,
name|lineoffs
index|[
literal|0
index|]
argument_list|,
name|lineactives
index|[
literal|0
index|]
argument_list|,
name|bufs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sw
operator|->
name|current_vertical_subpass
operator|++
expr_stmt|;
if|if
condition|(
name|sw
operator|->
name|current_vertical_subpass
operator|>=
name|sw
operator|->
name|vertical_oversample
condition|)
block|{
name|finalize_row
argument_list|(
name|sw
argument_list|,
name|sw
operator|->
name|lineno
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|offset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|sw
operator|->
name|lineno
operator|++
expr_stmt|;
name|sw
operator|->
name|current_vertical_subpass
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

