begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in EPSON ESC/P2 driver for the GIMP.  *  *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and  *	Robert Krawitz (rlk@alum.mit.edu)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   escp2_parameters()     - Return the parameter values for the given  *                            parameter.  *   escp2_imageable_area() - Return the imageable area of the page.  *   escp2_print()          - Print an image to an EPSON printer.  *   escp2_write()          - Send 6-color ESC/P2 graphics using TIFF packbits  *                            compression.  *  * Revision History:  *  *   See ChangeLog  */
end_comment

begin_comment
comment|/*  * Stylus Photo EX added by Robert Krawitz<rlk@alum.mit.edu> August 30, 1999  */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|escp2_write
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_weave
parameter_list|(
name|int
name|jets
parameter_list|,
name|int
name|separation
parameter_list|,
name|int
name|oversample
parameter_list|,
name|int
name|horizontal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_flush
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|escp2_write_weave
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
name|unsigned
name|char
modifier|*
name|C
parameter_list|,
name|unsigned
name|char
modifier|*
name|M
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Printer capabilities.  *  * Various classes of printer capabilities are represented by bitmasks.  */
end_comment

begin_typedef
DECL|typedef|model_cap_t
typedef|typedef
name|unsigned
name|long
name|long
name|model_cap_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|model_featureset_t
typedef|typedef
name|model_cap_t
name|model_featureset_t
typedef|;
end_typedef

begin_typedef
DECL|typedef|model_class_t
typedef|typedef
name|model_cap_t
name|model_class_t
typedef|;
end_typedef

begin_define
DECL|macro|MODEL_PAPER_SIZE_MASK
define|#
directive|define
name|MODEL_PAPER_SIZE_MASK
value|0x300
end_define

begin_define
DECL|macro|MODEL_PAPER_SMALL
define|#
directive|define
name|MODEL_PAPER_SMALL
value|0x000
end_define

begin_define
DECL|macro|MODEL_PAPER_LARGE
define|#
directive|define
name|MODEL_PAPER_LARGE
value|0x100
end_define

begin_define
DECL|macro|MODEL_PAPER_1200
define|#
directive|define
name|MODEL_PAPER_1200
value|0x200
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_MASK
define|#
directive|define
name|MODEL_IMAGEABLE_MASK
value|0xc00
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_DEFAULT
define|#
directive|define
name|MODEL_IMAGEABLE_DEFAULT
value|0x000
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_PHOTO
define|#
directive|define
name|MODEL_IMAGEABLE_PHOTO
value|0x400
end_define

begin_define
DECL|macro|MODEL_IMAGEABLE_600
define|#
directive|define
name|MODEL_IMAGEABLE_600
value|0x800
end_define

begin_define
DECL|macro|MODEL_INIT_MASK
define|#
directive|define
name|MODEL_INIT_MASK
value|0xf000
end_define

begin_define
DECL|macro|MODEL_INIT_COLOR
define|#
directive|define
name|MODEL_INIT_COLOR
value|0x0000
end_define

begin_define
DECL|macro|MODEL_INIT_PRO
define|#
directive|define
name|MODEL_INIT_PRO
value|0x1000
end_define

begin_define
DECL|macro|MODEL_INIT_1500
define|#
directive|define
name|MODEL_INIT_1500
value|0x2000
end_define

begin_define
DECL|macro|MODEL_INIT_600
define|#
directive|define
name|MODEL_INIT_600
value|0x3000
end_define

begin_define
DECL|macro|MODEL_INIT_PHOTO
define|#
directive|define
name|MODEL_INIT_PHOTO
value|0x4000
end_define

begin_define
DECL|macro|MODEL_HASBLACK_MASK
define|#
directive|define
name|MODEL_HASBLACK_MASK
value|0x10000
end_define

begin_define
DECL|macro|MODEL_HASBLACK_YES
define|#
directive|define
name|MODEL_HASBLACK_YES
value|0x00000
end_define

begin_define
DECL|macro|MODEL_HASBLACK_NO
define|#
directive|define
name|MODEL_HASBLACK_NO
value|0x10000
end_define

begin_define
DECL|macro|MODEL_6COLOR_MASK
define|#
directive|define
name|MODEL_6COLOR_MASK
value|0x20000
end_define

begin_define
DECL|macro|MODEL_6COLOR_NO
define|#
directive|define
name|MODEL_6COLOR_NO
value|0x00000
end_define

begin_define
DECL|macro|MODEL_6COLOR_YES
define|#
directive|define
name|MODEL_6COLOR_YES
value|0x20000
end_define

begin_define
DECL|macro|MODEL_720DPI_MODE_MASK
define|#
directive|define
name|MODEL_720DPI_MODE_MASK
value|0xc0000
end_define

begin_define
DECL|macro|MODEL_720DPI_DEFAULT
define|#
directive|define
name|MODEL_720DPI_DEFAULT
value|0x00000
end_define

begin_define
DECL|macro|MODEL_720DPI_600
define|#
directive|define
name|MODEL_720DPI_600
value|0x40000
end_define

begin_define
DECL|macro|MODEL_720DPI_PHOTO
define|#
directive|define
name|MODEL_720DPI_PHOTO
value|0x40000
end_define

begin_comment
DECL|macro|MODEL_720DPI_PHOTO
comment|/* 0x80000 for experimental stuff */
end_comment

begin_define
DECL|macro|MODEL_1440DPI_MASK
define|#
directive|define
name|MODEL_1440DPI_MASK
value|0x100000
end_define

begin_define
DECL|macro|MODEL_1440DPI_NO
define|#
directive|define
name|MODEL_1440DPI_NO
value|0x000000
end_define

begin_define
DECL|macro|MODEL_1440DPI_YES
define|#
directive|define
name|MODEL_1440DPI_YES
value|0x100000
end_define

begin_define
DECL|macro|MODEL_NOZZLES_MASK
define|#
directive|define
name|MODEL_NOZZLES_MASK
value|0xff000000
end_define

begin_define
DECL|macro|MODEL_MAKE_NOZZLES (x)
define|#
directive|define
name|MODEL_MAKE_NOZZLES
parameter_list|(
name|x
parameter_list|)
value|((long long) ((x))<< 24)
end_define

begin_define
DECL|macro|MODEL_GET_NOZZLES (x)
define|#
directive|define
name|MODEL_GET_NOZZLES
parameter_list|(
name|x
parameter_list|)
value|(((x)& MODEL_NOZZLES_MASK)>> 24)
end_define

begin_define
DECL|macro|MODEL_SEPARATION_MASK
define|#
directive|define
name|MODEL_SEPARATION_MASK
value|0xf00000000ll
end_define

begin_define
DECL|macro|MODEL_MAKE_SEPARATION (x)
define|#
directive|define
name|MODEL_MAKE_SEPARATION
parameter_list|(
name|x
parameter_list|)
value|(((long long) (x))<< 32)
end_define

begin_define
DECL|macro|MODEL_GET_SEPARATION (x)
define|#
directive|define
name|MODEL_GET_SEPARATION
parameter_list|(
name|x
parameter_list|)
value|(((x)& MODEL_SEPARATION_MASK)>> 32)
end_define

begin_comment
comment|/*  * SUGGESTED SETTINGS FOR STYLUS PHOTO EX:  * Brightness 127  * Blue 92  * Saturation 1.2  *  * Another group of settings that has worked well for me is  * Brightness 110  * Gamma 1.2  * Contrast 97  * Blue 88  * Saturation 1.1  * Density 1.5  *  * With the current code, the following settings seem to work nicely:  * Brightness ~110  * Gamma 1.3  * Contrast 80  * Green 94  * Blue 89  * Saturation 1.15  * Density 1.6  *  * The green and blue will vary somewhat with different inks  */
end_comment

begin_decl_stmt
DECL|variable|model_capabilities
name|model_cap_t
name|model_capabilities
index|[]
init|=
block|{
comment|/* Stylus Color */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_DEFAULT
operator||
name|MODEL_INIT_COLOR
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|1
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|1
argument_list|)
operator|)
block|,
comment|/* Stylus Color Pro/Pro XL/400/500 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_DEFAULT
operator||
name|MODEL_INIT_PRO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|1
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|1
argument_list|)
operator|)
block|,
comment|/* Stylus Color 1500 */
operator|(
name|MODEL_PAPER_LARGE
operator||
name|MODEL_IMAGEABLE_DEFAULT
operator||
name|MODEL_INIT_1500
operator||
name|MODEL_HASBLACK_NO
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|1
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|1
argument_list|)
operator|)
block|,
comment|/* Stylus Color 600 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_600
operator||
name|MODEL_INIT_600
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_600
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|1
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|1
argument_list|)
operator|)
block|,
comment|/* Stylus Color 800 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_600
operator||
name|MODEL_INIT_600
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|64
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|8
argument_list|)
operator|)
block|,
comment|/* Stylus Color 1520/3000 */
operator|(
name|MODEL_PAPER_LARGE
operator||
name|MODEL_IMAGEABLE_600
operator||
name|MODEL_INIT_600
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_NO
operator||
name|MODEL_720DPI_DEFAULT
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|64
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|8
argument_list|)
operator|)
block|,
comment|/* Stylus Photo 700 */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_PHOTO
operator||
name|MODEL_INIT_PHOTO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_PHOTO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|32
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|8
argument_list|)
operator|)
block|,
comment|/* Stylus Photo EX */
operator|(
name|MODEL_PAPER_LARGE
operator||
name|MODEL_IMAGEABLE_PHOTO
operator||
name|MODEL_INIT_PHOTO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_PHOTO
operator||
name|MODEL_1440DPI_YES
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|32
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|8
argument_list|)
operator|)
block|,
comment|/* Stylus Photo */
operator|(
name|MODEL_PAPER_SMALL
operator||
name|MODEL_IMAGEABLE_PHOTO
operator||
name|MODEL_INIT_PHOTO
operator||
name|MODEL_HASBLACK_YES
operator||
name|MODEL_6COLOR_YES
operator||
name|MODEL_720DPI_PHOTO
operator||
name|MODEL_1440DPI_NO
operator||
name|MODEL_MAKE_NOZZLES
argument_list|(
literal|32
argument_list|)
operator||
name|MODEL_MAKE_SEPARATION
argument_list|(
literal|8
argument_list|)
operator|)
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
DECL|struct|__anon28ec10b40108
typedef|typedef
struct|struct
block|{
DECL|member|name
specifier|const
name|char
name|name
index|[
literal|65
index|]
decl_stmt|;
DECL|member|hres
name|int
name|hres
decl_stmt|;
DECL|member|vres
name|int
name|vres
decl_stmt|;
DECL|member|softweave
name|int
name|softweave
decl_stmt|;
DECL|member|horizontal_passes
name|int
name|horizontal_passes
decl_stmt|;
DECL|member|vertical_passes
name|int
name|vertical_passes
decl_stmt|;
DECL|typedef|res_t
block|}
name|res_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|reslist
name|res_t
name|reslist
index|[]
init|=
block|{
block|{
literal|"360 DPI"
block|,
literal|360
block|,
literal|360
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI Microweave"
block|,
literal|720
block|,
literal|720
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI Softweave"
block|,
literal|720
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"720 DPI High Quality"
block|,
literal|720
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"720 DPI Highest Quality"
block|,
literal|720
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|"1440 x 720 DPI Microweave"
block|,
literal|1440
block|,
literal|720
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"1440 x 720 DPI Softweave"
block|,
literal|1440
block|,
literal|720
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|"1440 x 720 DPI Highest Quality"
block|,
literal|1440
block|,
literal|720
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|"1440 x 720 DPI Two-pass"
block|,
literal|2880
block|,
literal|720
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|"1440 x 720 DPI Two-pass Microweave"
block|,
literal|2880
block|,
literal|720
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
DECL|function|escp2_has_cap (int model,model_featureset_t featureset,model_class_t class)
name|escp2_has_cap
parameter_list|(
name|int
name|model
parameter_list|,
name|model_featureset_t
name|featureset
parameter_list|,
name|model_class_t
name|class
parameter_list|)
block|{
return|return
operator|(
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|&
name|featureset
operator|)
operator|==
name|class
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|model_class_t
DECL|function|escp2_cap (int model,model_featureset_t featureset)
name|escp2_cap
parameter_list|(
name|int
name|model
parameter_list|,
name|model_featureset_t
name|featureset
parameter_list|)
block|{
return|return
operator|(
name|model_capabilities
index|[
name|model
index|]
operator|&
name|featureset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_nozzles (int model)
name|escp2_nozzles
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
name|MODEL_GET_NOZZLES
argument_list|(
name|model_capabilities
index|[
name|model
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|escp2_nozzle_separation (int model)
name|escp2_nozzle_separation
parameter_list|(
name|int
name|model
parameter_list|)
block|{
return|return
name|MODEL_GET_SEPARATION
argument_list|(
name|model_capabilities
index|[
name|model
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'escp2_parameters()' - Return the parameter values for the given parameter.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
comment|/* O - Parameter values */
DECL|function|escp2_parameters (int model,char * ppd_file,char * name,int * count)
name|escp2_parameters
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|name
parameter_list|,
comment|/* I - Name of parameter */
name|int
modifier|*
name|count
parameter_list|)
comment|/* O - Number of values */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|valptrs
decl_stmt|;
specifier|static
name|char
modifier|*
name|media_sizes
index|[]
init|=
block|{
operator|(
literal|"Letter"
operator|)
block|,
operator|(
literal|"Legal"
operator|)
block|,
operator|(
literal|"A4"
operator|)
block|,
operator|(
literal|"Tabloid"
operator|)
block|,
operator|(
literal|"A3"
operator|)
block|,
operator|(
literal|"12x18"
operator|)
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PageSize"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_PAPER_SIZE_MASK
argument_list|,
name|MODEL_PAPER_LARGE
argument_list|)
condition|)
operator|*
name|count
operator|=
literal|6
expr_stmt|;
else|else
operator|*
name|count
operator|=
literal|3
expr_stmt|;
name|valptrs
operator|=
name|malloc
argument_list|(
operator|*
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* strdup doesn't appear to be POSIX... */
name|valptrs
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|media_sizes
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
name|i
index|]
argument_list|,
name|media_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Resolution"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res_t
modifier|*
name|res
init|=
operator|&
operator|(
name|reslist
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|valptrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|reslist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|res_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|res
operator|->
name|hres
condition|)
block|{
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
operator|||
operator|(
name|res
operator|->
name|hres
operator|<=
literal|720
operator|&&
name|res
operator|->
name|vres
operator|<=
literal|720
operator|)
condition|)
block|{
name|int
name|nozzles
init|=
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
decl_stmt|;
name|int
name|separation
init|=
name|escp2_nozzle_separation
argument_list|(
name|model
argument_list|)
decl_stmt|;
name|int
name|max_weave
init|=
name|nozzles
operator|/
name|separation
decl_stmt|;
if|if
condition|(
operator|!
name|res
operator|->
name|softweave
operator|||
operator|(
name|nozzles
operator|>
literal|1
operator|&&
name|res
operator|->
name|vertical_passes
operator|<=
name|max_weave
operator|)
condition|)
block|{
name|valptrs
index|[
operator|*
name|count
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|res
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valptrs
index|[
operator|*
name|count
index|]
argument_list|,
name|res
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|res
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'escp2_imageable_area()' - Return the imageable area of the page.  */
end_comment

begin_function
name|void
DECL|function|escp2_imageable_area (int model,char * ppd_file,char * media_size,int * left,int * right,int * bottom,int * top)
name|escp2_imageable_area
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|media_size
parameter_list|,
comment|/* I - Media size */
name|int
modifier|*
name|left
parameter_list|,
comment|/* O - Left position in points */
name|int
modifier|*
name|right
parameter_list|,
comment|/* O - Right position in points */
name|int
modifier|*
name|bottom
parameter_list|,
comment|/* O - Bottom position in points */
name|int
modifier|*
name|top
parameter_list|)
comment|/* O - Top position in points */
block|{
name|int
name|width
decl_stmt|,
name|length
decl_stmt|;
comment|/* Size of page */
name|default_media_size
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|escp2_cap
argument_list|(
name|model
argument_list|,
name|MODEL_IMAGEABLE_MASK
argument_list|)
condition|)
block|{
case|case
name|MODEL_IMAGEABLE_PHOTO
case|:
operator|*
name|left
operator|=
literal|9
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
literal|9
expr_stmt|;
operator|*
name|top
operator|=
name|length
expr_stmt|;
operator|*
name|bottom
operator|=
literal|80
expr_stmt|;
break|break;
case|case
name|MODEL_IMAGEABLE_600
case|:
operator|*
name|left
operator|=
literal|8
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
literal|9
expr_stmt|;
operator|*
name|top
operator|=
name|length
operator|-
literal|32
expr_stmt|;
operator|*
name|bottom
operator|=
literal|40
expr_stmt|;
break|break;
case|case
name|MODEL_IMAGEABLE_DEFAULT
case|:
default|default:
operator|*
name|left
operator|=
literal|14
expr_stmt|;
operator|*
name|right
operator|=
name|width
operator|-
literal|14
expr_stmt|;
operator|*
name|top
operator|=
name|length
operator|-
literal|14
expr_stmt|;
operator|*
name|bottom
operator|=
literal|40
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * 'escp2_print()' - Print an image to an EPSON printer.  */
end_comment

begin_function
name|void
DECL|function|escp2_print (int model,int copies,FILE * prn,Image image,unsigned char * cmap,lut_t * lut,vars_t * v)
name|escp2_print
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Model */
name|int
name|copies
parameter_list|,
comment|/* I - Number of copies */
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|Image
name|image
parameter_list|,
comment|/* I - Image to print */
name|unsigned
name|char
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (for indexed images) */
name|lut_t
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|vars_t
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
name|ppd_file
init|=
name|v
operator|->
name|ppd_file
decl_stmt|;
name|char
modifier|*
name|resolution
init|=
name|v
operator|->
name|resolution
decl_stmt|;
name|char
modifier|*
name|media_size
init|=
name|v
operator|->
name|media_size
decl_stmt|;
name|int
name|output_type
init|=
name|v
operator|->
name|output_type
decl_stmt|;
name|int
name|orientation
init|=
name|v
operator|->
name|orientation
decl_stmt|;
name|float
name|scaling
init|=
name|v
operator|->
name|scaling
decl_stmt|;
name|int
name|top
init|=
name|v
operator|->
name|top
decl_stmt|;
name|int
name|left
init|=
name|v
operator|->
name|left
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Looping vars */
name|int
name|xdpi
decl_stmt|,
name|ydpi
decl_stmt|;
comment|/* Resolution */
name|int
name|n
decl_stmt|;
comment|/* Output number */
name|unsigned
name|short
modifier|*
name|out
decl_stmt|;
comment|/* Output pixels (16-bit) */
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
comment|/* Input pixels */
modifier|*
name|black
decl_stmt|,
comment|/* Black bitmap data */
modifier|*
name|cyan
decl_stmt|,
comment|/* Cyan bitmap data */
modifier|*
name|magenta
decl_stmt|,
comment|/* Magenta bitmap data */
modifier|*
name|lcyan
decl_stmt|,
comment|/* Light cyan bitmap data */
modifier|*
name|lmagenta
decl_stmt|,
comment|/* Light magenta bitmap data */
modifier|*
name|yellow
decl_stmt|;
comment|/* Yellow bitmap data */
name|int
name|page_left
decl_stmt|,
comment|/* Left margin of page */
name|page_right
decl_stmt|,
comment|/* Right margin of page */
name|page_top
decl_stmt|,
comment|/* Top of page */
name|page_bottom
decl_stmt|,
comment|/* Bottom of page */
name|page_width
decl_stmt|,
comment|/* Width of page */
name|page_height
decl_stmt|,
comment|/* Height of page */
name|page_length
decl_stmt|,
comment|/* True length of page */
name|out_width
decl_stmt|,
comment|/* Width of image on page */
name|out_height
decl_stmt|,
comment|/* Height of image on page */
name|out_bpp
decl_stmt|,
comment|/* Output bytes per pixel */
name|temp_width
decl_stmt|,
comment|/* Temporary width of image on page */
name|temp_height
decl_stmt|,
comment|/* Temporary height of image on page */
name|landscape
decl_stmt|,
comment|/* True if we rotate the output 90 degrees */
name|length
decl_stmt|,
comment|/* Length of raster data */
name|errdiv
decl_stmt|,
comment|/* Error dividend */
name|errmod
decl_stmt|,
comment|/* Error modulus */
name|errval
decl_stmt|,
comment|/* Current error value */
name|errline
decl_stmt|,
comment|/* Current raster line */
name|errlast
decl_stmt|;
comment|/* Last raster line loaded */
name|convert_t
name|colorfunc
init|=
literal|0
decl_stmt|;
comment|/* Color conversion function... */
name|int
name|image_height
decl_stmt|,
name|image_width
decl_stmt|,
name|image_bpp
decl_stmt|;
name|int
name|use_softweave
init|=
literal|0
decl_stmt|;
name|int
name|nozzles
init|=
literal|1
decl_stmt|;
name|int
name|nozzle_separation
init|=
literal|1
decl_stmt|;
name|int
name|horizontal_passes
init|=
literal|1
decl_stmt|;
name|int
name|vertical_passes
init|=
literal|1
decl_stmt|;
name|res_t
modifier|*
name|res
decl_stmt|;
comment|/*   * Setup a read-only pixel region for the entire image...   */
name|Image_init
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_height
operator|=
name|Image_height
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_width
operator|=
name|Image_width
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image_bpp
operator|=
name|Image_bpp
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Choose the correct color conversion function...   */
if|if
condition|(
name|image_bpp
operator|<
literal|3
operator|&&
name|cmap
operator|==
name|NULL
condition|)
name|output_type
operator|=
name|OUTPUT_GRAY
expr_stmt|;
comment|/* Force grayscale output */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
block|{
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|image_bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_rgb
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_rgb
expr_stmt|;
block|}
else|else
block|{
name|out_bpp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|image_bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_gray
expr_stmt|;
elseif|else
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
name|colorfunc
operator|=
name|gray_to_gray
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_gray
expr_stmt|;
block|}
comment|/*   * Figure out the output resolution...   */
for|for
control|(
name|res
operator|=
operator|&
name|reslist
index|[
literal|0
index|]
init|;
condition|;
name|res
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
name|res
operator|->
name|name
argument_list|)
condition|)
block|{
name|use_softweave
operator|=
name|res
operator|->
name|softweave
expr_stmt|;
name|horizontal_passes
operator|=
name|res
operator|->
name|horizontal_passes
expr_stmt|;
name|vertical_passes
operator|=
name|res
operator|->
name|vertical_passes
expr_stmt|;
name|xdpi
operator|=
name|res
operator|->
name|hres
expr_stmt|;
name|ydpi
operator|=
name|res
operator|->
name|vres
expr_stmt|;
name|nozzles
operator|=
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|nozzle_separation
operator|=
name|escp2_nozzle_separation
argument_list|(
name|model
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resolution
argument_list|,
literal|""
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|use_softweave
condition|)
block|{
comment|/*        * In microweave mode, correct for the loss of page height that        * would happen in softweave mode.  The divide by 10 is to convert        * lines into points (Epson printers all have 720 ydpi);        */
name|int
name|extra_points
init|=
operator|(
operator|(
name|escp2_nozzles
argument_list|(
name|model
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|escp2_nozzle_separation
argument_list|(
name|model
argument_list|)
operator|+
literal|5
operator|)
operator|/
literal|10
decl_stmt|;
name|top
operator|+=
name|extra_points
expr_stmt|;
block|}
comment|/*   * Compute the output size...   */
name|landscape
operator|=
literal|0
expr_stmt|;
name|escp2_imageable_area
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|page_left
argument_list|,
operator|&
name|page_right
argument_list|,
operator|&
name|page_bottom
argument_list|,
operator|&
name|page_top
argument_list|)
expr_stmt|;
name|page_width
operator|=
name|page_right
operator|-
name|page_left
expr_stmt|;
name|page_height
operator|=
name|page_top
operator|-
name|page_bottom
expr_stmt|;
name|default_media_size
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|page_length
argument_list|)
expr_stmt|;
comment|/*   * Portrait width/height...   */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*     * Scale to pixels per inch...     */
name|out_width
operator|=
name|image_width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
name|out_height
operator|=
name|image_height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*     * Scale by percent...     */
name|out_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|out_height
operator|=
name|out_width
operator|*
name|image_height
operator|/
name|image_width
expr_stmt|;
if|if
condition|(
name|out_height
operator|>
name|page_height
condition|)
block|{
name|out_height
operator|=
name|page_height
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|out_width
operator|=
name|out_height
operator|*
name|image_width
operator|/
name|image_height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out_width
operator|==
literal|0
condition|)
name|out_width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|out_height
operator|==
literal|0
condition|)
name|out_height
operator|=
literal|1
expr_stmt|;
comment|/*   * Landscape width/height...   */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*     * Scale to pixels per inch...     */
name|temp_width
operator|=
name|image_height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
name|temp_height
operator|=
name|image_width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*     * Scale by percent...     */
name|temp_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|temp_height
operator|=
name|temp_width
operator|*
name|image_width
operator|/
name|image_height
expr_stmt|;
if|if
condition|(
name|temp_height
operator|>
name|page_height
condition|)
block|{
name|temp_height
operator|=
name|page_height
expr_stmt|;
name|temp_width
operator|=
name|temp_height
operator|*
name|image_height
operator|/
name|image_width
expr_stmt|;
block|}
block|}
comment|/*   * See which orientation has the greatest area (or if we need to rotate the   * image to fit it on the page...)   */
if|if
condition|(
name|orientation
operator|==
name|ORIENT_AUTO
condition|)
block|{
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
name|out_width
operator|>
name|page_width
operator|&&
name|out_height
operator|<
name|page_width
operator|)
operator|||
operator|(
name|out_height
operator|>
name|page_height
operator|&&
name|out_width
operator|<
name|page_height
operator|)
condition|)
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
else|else
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|temp_width
operator|*
name|temp_height
operator|)
operator|>
operator|(
name|out_width
operator|*
name|out_height
operator|)
condition|)
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
else|else
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|orientation
operator|==
name|ORIENT_LANDSCAPE
condition|)
block|{
name|out_width
operator|=
name|temp_width
expr_stmt|;
name|out_height
operator|=
name|temp_height
expr_stmt|;
name|landscape
operator|=
literal|1
expr_stmt|;
comment|/*     * Swap left/top offsets...     */
name|x
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|page_width
operator|-
name|x
operator|-
name|out_width
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|<
literal|0
condition|)
name|left
operator|=
operator|(
name|page_width
operator|-
name|out_width
operator|)
operator|/
literal|2
operator|+
name|page_left
expr_stmt|;
else|else
name|left
operator|=
name|left
operator|+
name|page_left
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|0
condition|)
name|top
operator|=
operator|(
name|page_height
operator|+
name|out_height
operator|)
operator|/
literal|2
operator|+
name|page_bottom
expr_stmt|;
else|else
name|top
operator|=
name|page_height
operator|-
name|top
operator|+
name|page_bottom
expr_stmt|;
comment|/*   * Let the user know what we're doing...   */
name|Image_progress_init
argument_list|(
name|image
argument_list|)
expr_stmt|;
comment|/*   * Send ESC/P2 initialization commands...   */
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
if|#
directive|if
literal|0
block|if (escp2_has_cap(model, MODEL_INIT_MASK, MODEL_INIT_PHOTO))     {       fwrite("\033@", 2, 1, prn);       fwrite("\033(R\010\000\000REMOTE1PM\002\000\000\000SN\003\000\000\000\003MS\010\000\000\000\010\000\364\013x\017\033\000\000\000", 42, 1, prn);     }
endif|#
directive|endif
name|fwrite
argument_list|(
literal|"\033(G\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Enter graphics mode */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Set line feed increment */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\024"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\012"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
name|fwrite
argument_list|(
literal|"\033(U\001\000\005"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|use_softweave
condition|)
name|initialize_weave
argument_list|(
name|nozzles
argument_list|,
name|nozzle_separation
argument_list|,
name|horizontal_passes
argument_list|,
name|vertical_passes
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|escp2_cap
argument_list|(
name|model
argument_list|,
name|MODEL_INIT_MASK
argument_list|)
condition|)
comment|/* Printer specific initialization */
block|{
case|case
name|MODEL_INIT_COLOR
case|:
comment|/* ESC */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
operator|&&
name|ydpi
operator|>
literal|360
operator|&&
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_PRO
case|:
comment|/* ESC Pro, Pro XL, 400, 500 */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
if|if
condition|(
name|ydpi
operator|>
literal|360
operator|&&
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_1500
case|:
comment|/* ESC 1500 */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
if|if
condition|(
name|ydpi
operator|>
literal|360
operator|&&
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_600
case|:
comment|/* ESC 600, 800, 1520, 3000 */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Fast black printing */
else|else
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Color printing */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Small dots */
if|if
condition|(
name|ydpi
operator|>
literal|360
operator|&&
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave mode on */
break|break;
case|case
name|MODEL_INIT_PHOTO
case|:
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\001"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Fast black printing */
else|else
name|fwrite
argument_list|(
literal|"\033(K\002\000\000\002"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Color printing */
if|if
condition|(
name|ydpi
operator|>
literal|360
condition|)
block|{
name|fwrite
argument_list|(
literal|"\033U\000"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Unidirectional */
if|if
condition|(
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(i\001\000\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microweave on */
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\004"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Microdots */
block|}
else|else
name|fwrite
argument_list|(
literal|"\033(e\002\000\000\003"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Whatever dots */
break|break;
block|}
name|fwrite
argument_list|(
literal|"\033(C\002\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Page length */
name|n
operator|=
name|ydpi
operator|*
name|page_length
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
literal|"\033(c\004\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Top/bottom margins */
name|n
operator|=
name|ydpi
operator|*
operator|(
name|page_length
operator|-
name|page_top
operator|)
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|n
operator|=
name|ydpi
operator|*
operator|(
name|page_length
operator|-
name|page_bottom
operator|)
operator|/
literal|72
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|n
operator|+=
literal|320
operator|*
name|ydpi
operator|/
literal|720
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
literal|"\033(V\002\000"
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Absolute vertical position */
name|n
operator|=
name|ydpi
operator|*
operator|(
name|page_length
operator|-
name|top
operator|)
operator|/
literal|72
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/*   * Convert image size to printer resolution...   */
name|out_width
operator|=
name|xdpi
operator|*
name|out_width
operator|/
literal|72
expr_stmt|;
name|out_height
operator|=
name|ydpi
operator|*
name|out_height
operator|/
literal|72
expr_stmt|;
name|left
operator|=
name|ydpi
operator|*
operator|(
name|left
operator|-
name|page_left
operator|)
operator|/
literal|72
expr_stmt|;
comment|/*   * Allocate memory for the raster data...   */
name|length
operator|=
operator|(
name|out_width
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|black
operator|=
name|malloc
argument_list|(
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cyan
operator|=
name|NULL
expr_stmt|;
name|magenta
operator|=
name|NULL
expr_stmt|;
name|lcyan
operator|=
name|NULL
expr_stmt|;
name|lmagenta
operator|=
name|NULL
expr_stmt|;
name|yellow
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cyan
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|magenta
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|yellow
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_HASBLACK_MASK
argument_list|,
name|MODEL_HASBLACK_YES
argument_list|)
condition|)
name|black
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
else|else
name|black
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
name|lcyan
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|lmagenta
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lcyan
operator|=
name|NULL
expr_stmt|;
name|lmagenta
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*   * Output the page, rotating as necessary...   */
if|if
condition|(
name|landscape
condition|)
block|{
name|in
operator|=
name|malloc
argument_list|(
name|image_height
operator|*
name|image_bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|image_height
operator|*
name|out_bpp
operator|*
literal|2
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|image_width
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|image_width
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
name|image_width
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|out_height
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|Image_note_progress
argument_list|(
name|image
argument_list|,
name|x
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|Image_get_col
argument_list|(
name|image
argument_list|,
name|in
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|image_height
argument_list|,
name|image_bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|dither_black
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|image_height
argument_list|,
name|out_width
argument_list|,
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|image_height
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
name|lcyan
argument_list|,
name|magenta
argument_list|,
name|lmagenta
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
block|{
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lcyan
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lmagenta
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|image_height
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
literal|0
argument_list|,
name|magenta
argument_list|,
literal|0
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(v\002\000\001\000"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Feed one line */
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|-=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_softweave
condition|)
name|escp2_flush
argument_list|(
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|malloc
argument_list|(
name|image_width
operator|*
name|image_bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|image_width
operator|*
name|out_bpp
operator|*
literal|2
argument_list|)
expr_stmt|;
name|errdiv
operator|=
name|image_height
operator|/
name|out_height
expr_stmt|;
name|errmod
operator|=
name|image_height
operator|%
name|out_height
expr_stmt|;
name|errval
operator|=
literal|0
expr_stmt|;
name|errlast
operator|=
operator|-
literal|1
expr_stmt|;
name|errline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|out_height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|&
literal|255
operator|)
operator|==
literal|0
condition|)
name|Image_note_progress
argument_list|(
name|image
argument_list|,
name|y
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|!=
name|errlast
condition|)
block|{
name|errlast
operator|=
name|errline
expr_stmt|;
name|Image_get_row
argument_list|(
name|image
argument_list|,
name|in
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|image_width
argument_list|,
name|image_bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
block|{
name|dither_black
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|image_width
argument_list|,
name|out_width
argument_list|,
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|image_width
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
name|lcyan
argument_list|,
name|magenta
argument_list|,
name|lmagenta
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|lcyan
argument_list|,
name|lmagenta
argument_list|)
expr_stmt|;
else|else
block|{
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lcyan
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|lmagenta
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dither_cmyk
argument_list|(
name|out
argument_list|,
name|y
argument_list|,
name|image_width
argument_list|,
name|out_width
argument_list|,
name|cyan
argument_list|,
literal|0
argument_list|,
name|magenta
argument_list|,
literal|0
argument_list|,
name|yellow
argument_list|,
literal|0
argument_list|,
name|black
argument_list|,
name|horizontal_passes
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_softweave
condition|)
name|escp2_write_weave
argument_list|(
name|prn
argument_list|,
name|length
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|xdpi
argument_list|,
name|cyan
argument_list|,
name|magenta
argument_list|,
name|yellow
argument_list|,
name|black
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|cyan
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|magenta
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|yellow
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|escp2_write
argument_list|(
name|prn
argument_list|,
name|black
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ydpi
argument_list|,
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|use_softweave
condition|)
name|fwrite
argument_list|(
literal|"\033(v\002\000\001\000"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Feed one line */
name|errval
operator|+=
name|errmod
expr_stmt|;
name|errline
operator|+=
name|errdiv
expr_stmt|;
if|if
condition|(
name|errval
operator|>=
name|out_height
condition|)
block|{
name|errval
operator|-=
name|out_height
expr_stmt|;
name|errline
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_softweave
condition|)
name|escp2_flush
argument_list|(
name|model
argument_list|,
name|out_width
argument_list|,
name|left
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
comment|/*   * Cleanup...   */
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|black
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|black
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyan
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cyan
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magenta
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yellow
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\014'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Eject page */
name|fputs
argument_list|(
literal|"\033@"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* ESC/P2 reset */
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_pack (unsigned char * line,int length,unsigned char * comp_buf,unsigned char ** comp_ptr)
name|escp2_pack
parameter_list|(
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
name|int
name|length
parameter_list|,
name|unsigned
name|char
modifier|*
name|comp_buf
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|comp_ptr
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of compressed data */
name|unsigned
name|char
name|repeat
decl_stmt|;
comment|/* Repeating char */
name|int
name|count
decl_stmt|;
comment|/* Count of compressed bytes */
name|int
name|tcount
decl_stmt|;
comment|/* Temporary count< 128 */
comment|/*    * Compress using TIFF "packbits" run-length encoding...    */
operator|(
operator|*
name|comp_ptr
operator|)
operator|=
name|comp_buf
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/*        * Get a run of non-repeated chars...        */
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|(
name|line
index|[
operator|-
literal|2
index|]
operator|!=
name|line
index|[
operator|-
literal|1
index|]
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|!=
name|line
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
name|line
operator|-=
literal|2
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
comment|/*        * Output the non-repeated sequences (max 128 at a time).        */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|0
index|]
operator|=
name|tcount
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|comp_ptr
operator|)
operator|+
literal|1
argument_list|,
name|start
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
operator|+=
name|tcount
operator|+
literal|1
expr_stmt|;
name|start
operator|+=
name|tcount
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
break|break;
comment|/*        * Find the repeated sequences...        */
name|start
operator|=
name|line
expr_stmt|;
name|repeat
operator|=
name|line
index|[
literal|0
index|]
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
operator|*
name|line
operator|==
name|repeat
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
comment|/*        * Output the repeated sequences (max 128 at a time).        */
name|count
operator|=
name|line
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tcount
operator|=
name|count
operator|>
literal|128
condition|?
literal|128
else|:
name|count
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|0
index|]
operator|=
literal|1
operator|-
name|tcount
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
index|[
literal|1
index|]
operator|=
name|repeat
expr_stmt|;
operator|(
operator|*
name|comp_ptr
operator|)
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'escp2_write()' - Send ESC/P2 graphics using TIFF packbits compression.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|escp2_write (FILE * prn,unsigned char * line,int length,int density,int plane,int ydpi,int model,int width,int offset)
name|escp2_write
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
comment|/* I - Output bitmap data */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|density
parameter_list|,
comment|/* I - 0 for dark, 1 for light */
name|int
name|plane
parameter_list|,
comment|/* I - Which color */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|)
comment|/* I - Offset from left side */
block|{
name|unsigned
name|char
name|comp_buf
index|[
literal|3072
index|]
decl_stmt|,
comment|/* Compression buffer */
modifier|*
name|comp_ptr
decl_stmt|;
specifier|static
name|int
name|last_density
init|=
literal|0
decl_stmt|;
comment|/* Last density printed */
specifier|static
name|int
name|last_plane
init|=
literal|0
decl_stmt|;
comment|/* Last color plane printed */
comment|/*   * Don't send blank lines...   */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|escp2_pack
argument_list|(
name|line
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
comment|/*   * Set the print head position.   */
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/*   * Set the color if necessary...   */
if|if
condition|(
name|last_plane
operator|!=
name|plane
operator|||
name|last_density
operator|!=
name|density
condition|)
block|{
name|last_plane
operator|=
name|plane
expr_stmt|;
name|last_density
operator|=
name|density
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(r\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|density
argument_list|,
name|plane
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|plane
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(\\%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|160
argument_list|,
literal|5
argument_list|,
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|offset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|offset
operator|&
literal|255
argument_list|,
name|offset
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/*   * Send a line of raster graphics...   */
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Raster graphics header */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033.\001\024\024\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033.\001\012\012\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_720DPI_MODE_MASK
argument_list|,
name|MODEL_720DPI_600
argument_list|)
condition|)
name|fwrite
argument_list|(
literal|"\033.\001\050\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
if|else if (model == 7)           fwrite("\033.\000\050\005\040", 6, 1, prn);
endif|#
directive|endif
else|else
name|fwrite
argument_list|(
literal|"\033.\001\005\005\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|width
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|width
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "Soft" weave  *  * The Epson Stylus Color/Photo printers don't have memory to print  * using all of the nozzles in the print head.  For example, the Stylus Photo  * 700/EX has 32 nozzles.  At 720 dpi, with an 8" wide image, a single line  * requires (8 * 720 * 6 / 8) bytes, or 4320 bytes (because the Stylus Photo  * printers have 6 ink colors).  To use 32 nozzles would require 138240 bytes.  * It's actually worse than that, though, because the nozzles are spaced 8  * rows apart.  Therefore, in order to store enough data to permit sending the  * page as a simple raster, the printer would require enough memory to store  * 256 rows, or 1105920 bytes.  Considering that the Photo EX can print  * 11" wide, we're looking at more like 1.5 MB.  In fact, these printers are  * capable of 1440 dpi horizontal resolution.  This would require 3 MB.  The  * printers actually have 64K.  *  * With the newer (750 and 1200) printers it's even worse, since these printers  * support multiple dot sizes.  But that's neither here nor there.  *  * The printer is capable of printing an image fed to it as single raster  * lines.  This is called MicroWeave (tm).  It actually produces extremely  * high quality output, but it only uses one nozzle per color per pass.  * This means that it has to make a lot of passes to print a page, so it's  * extremely slow (a full 8.5x11" page takes over 30 minutes!).  It's also  * not possible to print very close to the bottom of the page with MicroWeave  * since only the first nozzle is used, and the head cannot get closer than  * some distance from the edge of the page.  *  * The solution is to have the host rearrange the output so that a single  * pass is fed to the print head.  This means that we have to feed the printer  * every 8th line as a single pass, and we then have to interleave ("weave")  * the other raster lines as separate passes.  This allows us to use all 32  * nozzles, and achieve much higher printing speed.  *  * What makes this interesting is that there are many different ways of  * of accomplishing this goal.  The naive way would be to divide the image  * up into groups of 256 rows, and print all the mod8=0 rows in the first pass,  * mod8=1 rows in the second, and so forth.  The problem with this approach  * is that the individual ink jets are not perfectly uniform; some emit  * slightly bigger or smaller drops than others.  Since each group of 8  * adjacent rows is printed with the same nozzle, that means that there will  * be distinct streaks of lighter and darker bands within the image (8 rows  * is 1/90", which is visible; 1/720" is not).  Possibly worse is that these  * patterns will repeat every 256 rows.  This creates banding patterns that  * are about 1/3" wide.  *  * So we have to do something to break up this patterning.  *  * Epson does not publish the weaving algorithms that they use in their  * bundled drivers.  Indeed, their developer web site  * (http://www.ercipd.com/isv/edr_docs.htm) does not even describe how to  * do this weaving at all; it says that the only way to achieve 720 dpi  * is to use MicroWeave.  It does note (correctly) that 1440 dpi horizontal  * can only be achieved by the driver (i. e. in software).  The manual  * actually makes it fairly clear how to do this (it requires two passes  * with horizontal head movement between passes), and it is presumably  * possible to do this with MicroWeave.  *  * The information about how to do this is apparently available under NDA.  * It's actually easy enough to reverse engineer what's inside a print file  * with a simple Perl script.  There are presumably other printer commands  * that are not documented and may not be as easy to reverse engineer.  *  * I considered a few algorithms to perform the weave.  The first one I  * devised let me use only (jets - distance_between_jets + 1) nozzles, or  * 25.  This is OK in principle, but it's slower than using all nozzles.  * By playing around with it some more, I came up with an algorithm that  * lets me use all of the nozzles, except near the top and bottom of the  * page.  *  * This still produces some banding, though.  Even better quality can be  * achieved by using multiple nozzles on the same line.  How do we do this?  * In 1440x720 mode, we're printing two output lines at the same vertical  * position.  However, if we want four passes, we have to effectively print  * each line twice.  Actually doing this would increase the density, so  * what we do is print half the dots on each pass.  This produces near-perfect  * output, and it's far faster than using "MicroWeave".  *  * The current algorithm is not completely general.  The number of passes  * is limited to (nozzles / gap).  On the Photo EX class printers, that limits  * it to 4 -- 32 nozzles, an inter-nozzle gap of 8 lines.  Furthermore, there  * are a number of routines that are only coded up to 4 passes.  *  * The routine initialize_weave calculates the basic parameters, given  * the number of jets and separation between jets, in rows.  *  * -- Robert Krawitz<rlk@alum.mit.edu) November 3, 1999  */
end_comment

begin_typedef
typedef|typedef
struct|struct
comment|/* Weave parameters for a specific row */
DECL|struct|__anon28ec10b40208
block|{
DECL|member|row
name|int
name|row
decl_stmt|;
comment|/* Absolute row # */
DECL|member|pass
name|int
name|pass
decl_stmt|;
comment|/* Computed pass # */
DECL|member|jet
name|int
name|jet
decl_stmt|;
comment|/* Which physical nozzle we're using */
DECL|member|missingstartrows
name|int
name|missingstartrows
decl_stmt|;
comment|/* Phantom rows (nonexistent rows that */
comment|/* would be printed by nozzles lower than */
comment|/* the first nozzle we're using this pass; */
comment|/* with the current algorithm, always zero */
DECL|member|logicalpassstart
name|int
name|logicalpassstart
decl_stmt|;
comment|/* Offset in rows (from start of image) */
comment|/* that the printer must be for this row */
comment|/* to print correctly with the specified jet */
DECL|member|physpassstart
name|int
name|physpassstart
decl_stmt|;
comment|/* Offset in rows to the first row printed */
comment|/* in this pass.  Currently always equal to */
comment|/* logicalpassstart */
DECL|member|physpassend
name|int
name|physpassend
decl_stmt|;
comment|/* Offset in rows (from start of image) to */
comment|/* the last row that will be printed this */
comment|/* pass (assuming that we're printing a full */
comment|/* pass). */
DECL|typedef|weave_t
block|}
name|weave_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
comment|/* Weave parameters for a specific pass */
DECL|struct|__anon28ec10b40308
block|{
DECL|member|pass
name|int
name|pass
decl_stmt|;
comment|/* Absolute pass number */
DECL|member|missingstartrows
name|int
name|missingstartrows
decl_stmt|;
comment|/* All other values the same as weave_t */
DECL|member|logicalpassstart
name|int
name|logicalpassstart
decl_stmt|;
DECL|member|physpassstart
name|int
name|physpassstart
decl_stmt|;
DECL|member|physpassend
name|int
name|physpassend
decl_stmt|;
DECL|typedef|pass_t
block|}
name|pass_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon28ec10b4040a
typedef|typedef
union|union
block|{
comment|/* Offsets from the start of each line */
DECL|member|v
name|off_t
name|v
index|[
literal|6
index|]
decl_stmt|;
comment|/* (really pass) */
DECL|struct|__anon28ec10b40508
struct|struct
block|{
DECL|member|k
name|off_t
name|k
decl_stmt|;
DECL|member|m
name|off_t
name|m
decl_stmt|;
DECL|member|c
name|off_t
name|c
decl_stmt|;
DECL|member|y
name|off_t
name|y
decl_stmt|;
DECL|member|M
name|off_t
name|M
decl_stmt|;
DECL|member|C
name|off_t
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|lineoff_t
block|}
name|lineoff_t
typedef|;
end_typedef

begin_typedef
DECL|union|__anon28ec10b4060a
typedef|typedef
union|union
block|{
comment|/* Base pointers for each pass */
DECL|member|v
name|unsigned
name|char
modifier|*
name|v
index|[
literal|6
index|]
decl_stmt|;
DECL|struct|__anon28ec10b40708
struct|struct
block|{
DECL|member|k
name|unsigned
name|char
modifier|*
name|k
decl_stmt|;
DECL|member|m
name|unsigned
name|char
modifier|*
name|m
decl_stmt|;
DECL|member|c
name|unsigned
name|char
modifier|*
name|c
decl_stmt|;
DECL|member|y
name|unsigned
name|char
modifier|*
name|y
decl_stmt|;
DECL|member|M
name|unsigned
name|char
modifier|*
name|M
decl_stmt|;
DECL|member|C
name|unsigned
name|char
modifier|*
name|C
decl_stmt|;
DECL|member|p
block|}
name|p
struct|;
DECL|typedef|linebufs_t
block|}
name|linebufs_t
typedef|;
end_typedef

begin_decl_stmt
DECL|variable|linebufs
specifier|static
name|unsigned
name|char
modifier|*
name|linebufs
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|linebufs
comment|/* Actual data buffers */
end_comment

begin_decl_stmt
DECL|variable|linebases
specifier|static
name|linebufs_t
modifier|*
name|linebases
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|linebases
comment|/* Base address of each row buffer */
end_comment

begin_decl_stmt
DECL|variable|lineoffsets
specifier|static
name|lineoff_t
modifier|*
name|lineoffsets
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|lineoffsets
comment|/* Offsets within each row buffer */
end_comment

begin_decl_stmt
DECL|variable|linecounts
specifier|static
name|int
modifier|*
name|linecounts
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|linecounts
comment|/* How many rows we've printed this pass */
end_comment

begin_decl_stmt
DECL|variable|passes
specifier|static
name|pass_t
modifier|*
name|passes
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|passes
comment|/* Circular list of pass numbers */
end_comment

begin_decl_stmt
DECL|variable|last_pass_offset
specifier|static
name|int
name|last_pass_offset
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|last_pass_offset
comment|/* Starting row (offset from the start of */
end_comment

begin_comment
comment|/* the image) of the most recently printed */
end_comment

begin_comment
comment|/* pass (so we can determine how far to */
end_comment

begin_comment
comment|/* advance the paper) */
end_comment

begin_decl_stmt
DECL|variable|last_pass
specifier|static
name|int
name|last_pass
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|last_pass
comment|/* Number of the most recently printed pass */
end_comment

begin_decl_stmt
DECL|variable|njets
specifier|static
name|int
name|njets
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|njets
comment|/* Number of jets in use */
end_comment

begin_decl_stmt
DECL|variable|separation
specifier|static
name|int
name|separation
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|separation
comment|/* Separation between jets */
end_comment

begin_decl_stmt
DECL|variable|weavefactor
specifier|static
name|int
name|weavefactor
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|weavefactor
comment|/* Interleave factor (jets / separation) */
end_comment

begin_decl_stmt
DECL|variable|jetsused
specifier|static
name|int
name|jetsused
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|jetsused
comment|/* How many jets we can actually use */
end_comment

begin_decl_stmt
DECL|variable|initialoffset
specifier|static
name|int
name|initialoffset
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|initialoffset
comment|/* Distance between the first row we're */
end_comment

begin_comment
comment|/* printing and the logical first row */
end_comment

begin_comment
comment|/* (first nozzle of the first pass). */
end_comment

begin_comment
comment|/* Currently this is zero. */
end_comment

begin_decl_stmt
DECL|variable|jetsleftover
specifier|static
name|int
name|jetsleftover
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|jetsleftover
comment|/* How many jets we're *not* using. */
end_comment

begin_comment
comment|/* This can be used to rotate exactly */
end_comment

begin_comment
comment|/* what jets we're using.  Currently this */
end_comment

begin_comment
comment|/* is not used. */
end_comment

begin_decl_stmt
DECL|variable|weavespan
specifier|static
name|int
name|weavespan
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|weavespan
comment|/* How many rows total are bracketed by */
end_comment

begin_comment
comment|/* one pass (separation * (jets - 1) */
end_comment

begin_decl_stmt
DECL|variable|horizontal_weave
specifier|static
name|int
name|horizontal_weave
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|horizontal_weave
comment|/* Number of horizontal passes required */
end_comment

begin_comment
comment|/* This is> 1 for some of the ultra-high */
end_comment

begin_comment
comment|/* resolution modes */
end_comment

begin_decl_stmt
DECL|variable|vertical_subpasses
specifier|static
name|int
name|vertical_subpasses
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|vertical_subpasses
comment|/* Number of passes per line (for better */
end_comment

begin_comment
comment|/* quality) */
end_comment

begin_decl_stmt
DECL|variable|vmod
specifier|static
name|int
name|vmod
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|vmod
comment|/* Number of banks of passes */
end_comment

begin_decl_stmt
DECL|variable|oversample
specifier|static
name|int
name|oversample
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|oversample
comment|/* Excess precision per row */
end_comment

begin_decl_stmt
DECL|variable|is_monochrome
specifier|static
name|int
name|is_monochrome
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mapping between color and linear index.  The colors are  * black, magenta, cyan, yellow, light magenta, light cyan  */
end_comment

begin_decl_stmt
DECL|variable|color_indices
specifier|static
name|int
name|color_indices
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|4
block|,
literal|5
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|colors
specifier|static
name|int
name|colors
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|densities
specifier|static
name|int
name|densities
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
DECL|function|get_color_by_params (int plane,int density)
name|get_color_by_params
parameter_list|(
name|int
name|plane
parameter_list|,
name|int
name|density
parameter_list|)
block|{
if|if
condition|(
name|plane
operator|>
literal|4
operator|||
name|plane
operator|<
literal|0
operator|||
name|density
operator|>
literal|1
operator|||
name|density
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|color_indices
index|[
name|density
operator|*
literal|8
operator|+
name|plane
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the weave parameters  */
end_comment

begin_function
specifier|static
name|void
DECL|function|initialize_weave (int jets,int sep,int osample,int v_subpasses)
name|initialize_weave
parameter_list|(
name|int
name|jets
parameter_list|,
name|int
name|sep
parameter_list|,
name|int
name|osample
parameter_list|,
name|int
name|v_subpasses
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|bufbase
decl_stmt|;
if|if
condition|(
name|jets
operator|<=
literal|1
condition|)
name|separation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sep
operator|<=
literal|0
condition|)
name|separation
operator|=
literal|1
expr_stmt|;
else|else
name|separation
operator|=
name|sep
expr_stmt|;
name|njets
operator|=
name|jets
expr_stmt|;
if|if
condition|(
name|v_subpasses
operator|<=
literal|0
condition|)
name|v_subpasses
operator|=
literal|1
expr_stmt|;
name|oversample
operator|=
name|osample
expr_stmt|;
name|vertical_subpasses
operator|=
name|v_subpasses
expr_stmt|;
name|njets
operator|/=
name|vertical_subpasses
expr_stmt|;
name|vmod
operator|=
name|separation
operator|*
name|vertical_subpasses
expr_stmt|;
name|horizontal_weave
operator|=
literal|1
expr_stmt|;
name|weavefactor
operator|=
name|njets
operator|/
name|separation
expr_stmt|;
name|jetsused
operator|=
operator|(
operator|(
name|weavefactor
operator|)
operator|*
name|separation
operator|)
expr_stmt|;
name|initialoffset
operator|=
operator|(
name|jetsused
operator|-
name|weavefactor
operator|-
literal|1
operator|)
operator|*
name|separation
expr_stmt|;
name|jetsleftover
operator|=
name|njets
operator|-
name|jetsused
operator|+
literal|1
expr_stmt|;
name|weavespan
operator|=
operator|(
name|jetsused
operator|-
literal|1
operator|)
operator|*
name|separation
expr_stmt|;
name|last_pass_offset
operator|=
literal|0
expr_stmt|;
name|last_pass
operator|=
operator|-
literal|1
expr_stmt|;
name|linebufs
operator|=
name|malloc
argument_list|(
literal|6
operator|*
literal|3072
operator|*
name|vmod
operator|*
name|jets
operator|*
name|horizontal_weave
argument_list|)
expr_stmt|;
name|lineoffsets
operator|=
name|malloc
argument_list|(
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|lineoff_t
argument_list|)
operator|*
name|horizontal_weave
argument_list|)
expr_stmt|;
name|linebases
operator|=
name|malloc
argument_list|(
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|linebufs_t
argument_list|)
operator|*
name|horizontal_weave
argument_list|)
expr_stmt|;
name|passes
operator|=
name|malloc
argument_list|(
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|pass_t
argument_list|)
argument_list|)
expr_stmt|;
name|linecounts
operator|=
name|malloc
argument_list|(
name|vmod
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bufbase
operator|=
name|linebufs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vmod
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|passes
index|[
name|i
index|]
operator|.
name|pass
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|horizontal_weave
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
name|linebases
index|[
name|k
operator|*
name|vmod
operator|+
name|i
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
name|bufbase
expr_stmt|;
name|bufbase
operator|+=
literal|3072
operator|*
name|jets
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the weave parameters for the given row.  This computation is  * rather complex, and I need to go back and write down very carefully  * what's going on here.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|weave_parameters_by_row (int row,int vertical_subpass,weave_t * w)
name|weave_parameters_by_row
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|vertical_subpass
parameter_list|,
name|weave_t
modifier|*
name|w
parameter_list|)
block|{
name|int
name|passblockstart
init|=
operator|(
name|row
operator|+
name|initialoffset
operator|)
operator|/
name|jetsused
decl_stmt|;
name|int
name|internaljetsused
init|=
name|jetsused
operator|*
name|vertical_subpasses
decl_stmt|;
name|int
name|subpass_adjustment
decl_stmt|;
name|w
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|w
operator|->
name|pass
operator|=
operator|(
name|passblockstart
operator|-
operator|(
name|separation
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
name|separation
operator|+
name|row
operator|-
name|passblockstart
operator|-
literal|1
operator|)
operator|%
name|separation
expr_stmt|;
name|subpass_adjustment
operator|=
operator|(
operator|(
name|w
operator|->
name|pass
operator|+
literal|1
operator|)
operator|/
name|separation
operator|)
operator|%
name|vertical_subpasses
expr_stmt|;
name|subpass_adjustment
operator|=
name|vertical_subpasses
operator|-
name|subpass_adjustment
operator|-
literal|1
expr_stmt|;
name|vertical_subpass
operator|=
operator|(
name|vertical_subpass
operator|+
name|subpass_adjustment
operator|)
operator|%
name|vertical_subpasses
expr_stmt|;
name|w
operator|->
name|pass
operator|+=
name|separation
operator|*
name|vertical_subpass
expr_stmt|;
name|w
operator|->
name|logicalpassstart
operator|=
operator|(
name|w
operator|->
name|pass
operator|*
name|jetsused
operator|)
operator|-
name|initialoffset
operator|+
operator|(
name|w
operator|->
name|pass
operator|%
name|separation
operator|)
expr_stmt|;
name|w
operator|->
name|jet
operator|=
operator|(
operator|(
name|row
operator|-
name|w
operator|->
name|logicalpassstart
operator|)
operator|/
name|separation
operator|)
expr_stmt|;
name|w
operator|->
name|jet
operator|+=
name|jetsused
operator|*
operator|(
name|vertical_subpasses
operator|-
literal|1
operator|)
expr_stmt|;
name|w
operator|->
name|logicalpassstart
operator|=
name|w
operator|->
name|row
operator|-
operator|(
name|w
operator|->
name|jet
operator|*
name|separation
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|logicalpassstart
operator|>=
literal|0
condition|)
name|w
operator|->
name|physpassstart
operator|=
name|w
operator|->
name|logicalpassstart
expr_stmt|;
else|else
name|w
operator|->
name|physpassstart
operator|=
name|w
operator|->
name|logicalpassstart
operator|+
operator|(
name|separation
operator|*
operator|(
operator|(
name|separation
operator|-
literal|1
operator|-
name|w
operator|->
name|logicalpassstart
operator|)
operator|/
name|separation
operator|)
operator|)
expr_stmt|;
name|w
operator|->
name|physpassend
operator|=
operator|(
name|internaljetsused
operator|-
literal|1
operator|)
operator|*
name|separation
operator|+
name|w
operator|->
name|logicalpassstart
expr_stmt|;
name|w
operator|->
name|missingstartrows
operator|=
operator|(
name|w
operator|->
name|physpassstart
operator|-
name|w
operator|->
name|logicalpassstart
operator|)
operator|/
name|separation
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|pass
operator|<
literal|0
condition|)
block|{
name|w
operator|->
name|logicalpassstart
operator|-=
name|w
operator|->
name|pass
operator|*
name|separation
expr_stmt|;
name|w
operator|->
name|physpassend
operator|-=
name|w
operator|->
name|pass
operator|*
name|separation
expr_stmt|;
name|w
operator|->
name|jet
operator|+=
name|w
operator|->
name|pass
expr_stmt|;
name|w
operator|->
name|missingstartrows
operator|+=
name|w
operator|->
name|pass
expr_stmt|;
block|}
name|w
operator|->
name|pass
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|lineoff_t
modifier|*
DECL|function|get_lineoffsets (int row,int subpass)
name|get_lineoffsets
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|lineoffsets
index|[
name|w
operator|.
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
DECL|function|get_linecount (int row,int subpass)
name|get_linecount
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|linecounts
index|[
name|w
operator|.
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|linebufs_t
modifier|*
DECL|function|get_linebases (int row,int subpass)
name|get_linebases
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|linebases
index|[
name|w
operator|.
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pass_t
modifier|*
DECL|function|get_pass_by_row (int row,int subpass)
name|get_pass_by_row
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
name|passes
index|[
name|w
operator|.
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lineoff_t
modifier|*
DECL|function|get_lineoffsets_by_pass (int pass)
name|get_lineoffsets_by_pass
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|lineoffsets
index|[
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
DECL|function|get_linecount_by_pass (int pass)
name|get_linecount_by_pass
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|linecounts
index|[
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|linebufs_t
modifier|*
DECL|function|get_linebases_by_pass (int pass)
name|get_linebases_by_pass
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|linebases
index|[
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pass_t
modifier|*
DECL|function|get_pass_by_pass (int pass)
name|get_pass_by_pass
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
return|return
operator|&
operator|(
name|passes
index|[
name|pass
operator|%
name|vmod
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If there are phantom rows at the beginning of a pass, fill them in so  * that the printer knows exactly what it doesn't have to print.  We're  * using RLE compression here.  Each line must be specified independently,  * so we have to compute how many full blocks (groups of 128 bytes, or 1024  * "off" pixels) and how much leftover is needed.  Note that we can only  * RLE-encode groups of 2 or more bytes; single bytes must be specified  * with a count of 1.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|fillin_start_rows (int row,int subpass,int width,int missingstartrows)
name|fillin_start_rows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|subpass
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|missingstartrows
parameter_list|)
block|{
name|lineoff_t
modifier|*
name|offsets
init|=
name|get_lineoffsets
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|m
decl_stmt|;
name|width
operator|=
operator|(
name|width
operator|+
operator|(
name|oversample
operator|-
literal|1
operator|)
operator|)
operator|/
name|oversample
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|missingstartrows
condition|;
name|k
operator|++
control|)
block|{
name|int
name|bytes_to_fill
init|=
name|width
decl_stmt|;
name|int
name|full_blocks
init|=
name|bytes_to_fill
operator|/
literal|1024
decl_stmt|;
name|int
name|leftover
init|=
operator|(
literal|7
operator|+
operator|(
name|bytes_to_fill
operator|%
literal|1024
operator|)
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|l
operator|<
name|full_blocks
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
block|{
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|129
expr_stmt|;
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|leftover
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
block|{
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|1
expr_stmt|;
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftover
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
block|{
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|=
literal|257
operator|-
name|leftover
expr_stmt|;
operator|(
name|bufs
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|horizontal_weave
condition|;
name|m
operator|++
control|)
name|offsets
index|[
name|m
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|2
operator|*
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|initialize_row (int row,int width)
name|initialize_row
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vertical_subpasses
condition|;
name|i
operator|++
control|)
block|{
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|i
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|physpassstart
operator|==
name|row
condition|)
block|{
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
modifier|*
name|linecount
init|=
name|get_linecount
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_row
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|pass
operator|->
name|pass
operator|=
name|w
operator|.
name|pass
expr_stmt|;
name|pass
operator|->
name|missingstartrows
operator|=
name|w
operator|.
name|missingstartrows
expr_stmt|;
name|pass
operator|->
name|logicalpassstart
operator|=
name|w
operator|.
name|logicalpassstart
expr_stmt|;
name|pass
operator|->
name|physpassstart
operator|=
name|w
operator|.
name|physpassstart
expr_stmt|;
name|pass
operator|->
name|physpassend
operator|=
name|w
operator|.
name|physpassend
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|horizontal_weave
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
name|lineoffs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|linecount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|missingstartrows
operator|>
literal|0
condition|)
name|fillin_start_rows
argument_list|(
name|row
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|w
operator|.
name|missingstartrows
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A fair bit of this code is duplicated from escp2_write.  That's rather  * a pity.  It's also not correct for any but the 6-color printers.  One of  * these days I'll unify it.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|flush_pass (int passno,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|flush_pass
parameter_list|(
name|int
name|passno
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets_by_pass
argument_list|(
name|passno
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases_by_pass
argument_list|(
name|passno
argument_list|)
decl_stmt|;
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_pass
argument_list|(
name|passno
argument_list|)
decl_stmt|;
name|int
modifier|*
name|linecount
init|=
name|get_linecount_by_pass
argument_list|(
name|passno
argument_list|)
decl_stmt|;
name|int
name|lwidth
init|=
operator|(
name|width
operator|+
operator|(
name|oversample
operator|-
literal|1
operator|)
operator|)
operator|/
name|oversample
decl_stmt|;
if|if
condition|(
name|pass
operator|->
name|physpassstart
operator|>
name|last_pass_offset
condition|)
block|{
name|int
name|advance
init|=
name|pass
operator|->
name|logicalpassstart
operator|-
name|last_pass_offset
decl_stmt|;
name|int
name|alo
init|=
name|advance
operator|%
literal|256
decl_stmt|;
name|int
name|ahi
init|=
name|advance
operator|/
literal|256
decl_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(v\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|alo
argument_list|,
name|ahi
argument_list|)
expr_stmt|;
name|last_pass_offset
operator|=
name|pass
operator|->
name|logicalpassstart
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|horizontal_weave
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lineoffs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
operator|==
literal|0
operator|||
operator|(
name|j
operator|>
literal|0
operator|&&
name|is_monochrome
operator|)
condition|)
continue|continue;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_6COLOR_MASK
argument_list|,
name|MODEL_6COLOR_YES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(r\002%c%c%c"
argument_list|,
literal|0
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|densities
index|[
name|j
index|]
operator|>
literal|0
condition|)
continue|continue;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033r%c"
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_1440DPI_MASK
argument_list|,
name|MODEL_1440DPI_YES
argument_list|)
condition|)
block|{
comment|/* FIXME need a more general way of specifying column */
comment|/* separation */
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033(\\%c%c%c%c%c%c"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|160
argument_list|,
literal|5
argument_list|,
operator|(
operator|(
name|hoffset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
operator|(
name|k
operator|&
name|oversample
operator|)
operator|)
operator|&
literal|255
argument_list|,
operator|(
operator|(
name|hoffset
operator|*
literal|1440
operator|/
name|ydpi
operator|)
operator|+
operator|(
name|k
operator|&
name|oversample
operator|)
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033\\%c%c"
argument_list|,
name|hoffset
operator|&
literal|255
argument_list|,
name|hoffset
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ydpi
condition|)
comment|/* Raster graphics header */
block|{
case|case
literal|180
case|:
name|fwrite
argument_list|(
literal|"\033.\001\024\024\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|fwrite
argument_list|(
literal|"\033.\001\012\012\001"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|720
case|:
if|if
condition|(
name|escp2_has_cap
argument_list|(
name|model
argument_list|,
name|MODEL_720DPI_MODE_MASK
argument_list|,
name|MODEL_720DPI_600
argument_list|)
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033.%c%c%c%c"
argument_list|,
literal|1
argument_list|,
literal|8
operator|*
literal|5
argument_list|,
literal|5
argument_list|,
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\033.%c%c%c%c"
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
operator|*
name|linecount
operator|+
name|pass
operator|->
name|missingstartrows
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|lwidth
operator|&
literal|255
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/* Width of raster line in pixels */
name|putc
argument_list|(
name|lwidth
operator|>>
literal|8
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|bufs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|,
name|lineoffs
index|[
name|k
index|]
operator|.
name|v
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
literal|"\033\006"
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
name|last_pass
operator|=
name|pass
operator|->
name|pass
expr_stmt|;
name|pass
operator|->
name|pass
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|add_to_row (int row,unsigned char * buf,size_t nbytes,int plane,int density,int subpass)
name|add_to_row
parameter_list|(
name|int
name|row
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|density
parameter_list|,
name|int
name|subpass
parameter_list|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
name|color
init|=
name|get_color_by_params
argument_list|(
name|plane
argument_list|,
name|density
argument_list|)
decl_stmt|;
name|lineoff_t
modifier|*
name|lineoffs
init|=
name|get_lineoffsets
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|)
decl_stmt|;
specifier|const
name|linebufs_t
modifier|*
name|bufs
init|=
name|get_linebases
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|)
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|subpass
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bufs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
operator|+
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|lineoffs
index|[
literal|0
index|]
operator|.
name|v
index|[
name|color
index|]
operator|+=
name|nbytes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|finalize_row (int row,int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|finalize_row
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vertical_subpasses
condition|;
name|i
operator|++
control|)
block|{
name|weave_t
name|w
decl_stmt|;
name|int
modifier|*
name|lines
init|=
name|get_linecount
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|weave_parameters_by_row
argument_list|(
name|row
argument_list|,
name|i
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lines
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|physpassend
operator|==
name|row
condition|)
block|{
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_row
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|flush_pass
argument_list|(
name|pass
operator|->
name|pass
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_flush (int model,int width,int hoffset,int ydpi,int xdpi,FILE * prn)
name|escp2_flush
parameter_list|(
name|int
name|model
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hoffset
parameter_list|,
name|int
name|ydpi
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|FILE
modifier|*
name|prn
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|pass_t
modifier|*
name|pass
init|=
name|get_pass_by_pass
argument_list|(
name|last_pass
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pass
operator|->
name|pass
operator|<
literal|0
condition|)
return|return;
name|flush_pass
argument_list|(
name|pass
operator|->
name|pass
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|hoffset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_2 (int length,const unsigned char * in,unsigned char * outlo,unsigned char * outhi)
name|escp2_split_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|outlo
index|[
name|i
index|]
operator|=
name|inbyte
operator|&
literal|0x55
expr_stmt|;
name|outhi
index|[
name|i
index|]
operator|=
name|inbyte
operator|&
literal|0xaa
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_split_4 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_split_4
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|out0
index|[
name|i
index|]
operator|=
name|inbyte
operator|&
literal|0x11
expr_stmt|;
name|out1
index|[
name|i
index|]
operator|=
name|inbyte
operator|&
literal|0x22
expr_stmt|;
name|out2
index|[
name|i
index|]
operator|=
name|inbyte
operator|&
literal|0x44
expr_stmt|;
name|out3
index|[
name|i
index|]
operator|=
name|inbyte
operator|&
literal|0x88
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_2 (int length,const unsigned char * in,unsigned char * outlo,unsigned char * outhi)
name|escp2_unpack_2
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|outlo
parameter_list|,
name|unsigned
name|char
modifier|*
name|outhi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
operator|*
name|in
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
block|{
operator|*
name|outlo
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|outhi
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|outlo
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
operator|*
name|outhi
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|outlo
operator|++
expr_stmt|;
name|outhi
operator|++
expr_stmt|;
block|}
name|in
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_unpack_4 (int length,const unsigned char * in,unsigned char * out0,unsigned char * out1,unsigned char * out2,unsigned char * out3)
name|escp2_unpack_4
parameter_list|(
name|int
name|length
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out0
parameter_list|,
name|unsigned
name|char
modifier|*
name|out1
parameter_list|,
name|unsigned
name|char
modifier|*
name|out2
parameter_list|,
name|unsigned
name|char
modifier|*
name|out3
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|inbyte
init|=
operator|*
name|in
decl_stmt|;
switch|switch
condition|(
name|i
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|out0
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|<<
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|out1
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
operator|*
name|out2
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
operator|*
name|out3
operator|=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|out0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
operator|*
name|out1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
name|out2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|0
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|out3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|out0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
operator|*
name|out1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
operator|*
name|out2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
operator|*
name|out3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|out0
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>>
literal|6
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
operator|*
name|out1
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
operator|>>
literal|5
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
operator|*
name|out2
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
operator|*
name|out3
operator|+=
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|inbyte
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|out0
operator|++
expr_stmt|;
name|out1
operator|++
expr_stmt|;
name|out2
operator|++
expr_stmt|;
name|out3
operator|++
expr_stmt|;
break|break;
block|}
name|in
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|escp2_write_weave (FILE * prn,int length,int ydpi,int model,int width,int offset,int xdpi,unsigned char * c,unsigned char * m,unsigned char * y,unsigned char * k,unsigned char * C,unsigned char * M)
name|escp2_write_weave
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - Print file or command */
name|int
name|length
parameter_list|,
comment|/* I - Length of bitmap data */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution */
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|int
name|width
parameter_list|,
comment|/* I - Printed width */
name|int
name|offset
parameter_list|,
name|int
name|xdpi
parameter_list|,
name|unsigned
name|char
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
name|unsigned
name|char
modifier|*
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|k
parameter_list|,
name|unsigned
name|char
modifier|*
name|C
parameter_list|,
name|unsigned
name|char
modifier|*
name|M
parameter_list|)
block|{
specifier|static
name|int
name|lineno
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|s
index|[
literal|4
index|]
index|[
literal|3072
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|comp_buf
index|[
literal|3072
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|comp_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cols
index|[
literal|6
index|]
decl_stmt|;
name|cols
index|[
literal|0
index|]
operator|=
name|k
expr_stmt|;
name|cols
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|cols
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|cols
index|[
literal|3
index|]
operator|=
name|y
expr_stmt|;
name|cols
index|[
literal|4
index|]
operator|=
name|M
expr_stmt|;
name|cols
index|[
literal|5
index|]
operator|=
name|C
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|is_monochrome
operator|=
literal|1
expr_stmt|;
else|else
name|is_monochrome
operator|=
literal|0
expr_stmt|;
name|initialize_row
argument_list|(
name|lineno
argument_list|,
name|width
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cols
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|vertical_subpasses
operator|>
literal|1
condition|)
block|{
switch|switch
condition|(
name|oversample
condition|)
block|{
case|case
literal|2
case|:
name|escp2_unpack_2
argument_list|(
name|length
argument_list|,
name|cols
index|[
name|j
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|escp2_unpack_4
argument_list|(
name|length
argument_list|,
name|cols
index|[
name|j
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|vertical_subpasses
operator|/
name|oversample
condition|)
block|{
case|case
literal|4
case|:
name|escp2_split_4
argument_list|(
name|length
argument_list|,
name|cols
index|[
name|j
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|oversample
operator|==
literal|1
condition|)
block|{
name|escp2_split_2
argument_list|(
name|length
argument_list|,
name|cols
index|[
name|j
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|escp2_split_2
argument_list|(
name|length
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|escp2_split_2
argument_list|(
name|length
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vertical_subpasses
condition|;
name|i
operator|++
control|)
block|{
name|escp2_pack
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
operator|(
operator|(
name|length
operator|+
name|oversample
operator|-
literal|1
operator|)
operator|/
name|oversample
operator|)
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|escp2_pack
argument_list|(
name|cols
index|[
name|j
index|]
argument_list|,
name|length
argument_list|,
name|comp_buf
argument_list|,
operator|&
name|comp_ptr
argument_list|)
expr_stmt|;
name|add_to_row
argument_list|(
name|lineno
argument_list|,
name|comp_buf
argument_list|,
name|comp_ptr
operator|-
name|comp_buf
argument_list|,
name|colors
index|[
name|j
index|]
argument_list|,
name|densities
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|finalize_row
argument_list|(
name|lineno
argument_list|,
name|model
argument_list|,
name|width
argument_list|,
name|offset
argument_list|,
name|ydpi
argument_list|,
name|xdpi
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

