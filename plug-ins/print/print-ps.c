begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in Adobe PostScript driver for the GIMP.  *  *   Copyright 1997-1998 Michael Sweet (mike@easysw.com)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *  * Contents:  *  *   ps_parameters()     - Return the parameter values for the given  *                            parameter.  *   ps_media_size()     - Return the size of the page.  *   ps_imageable_area() - Return the imageable area of the page.  *   ps_print()          - Print an image to a PostScript printer.  *   ps_hex()            - Print binary data as a series of hexadecimal numbers.  *   ps_ascii85()        - Print binary data as a series of base-85 numbers.  *  * Revision History:  *  *   $Log$  *   Revision 1.14  1999/05/29 16:35:29  yosh  *   * configure.in  *   * Makefile.am: removed tips files, AC_SUBST GIMP_PLUGINS and  *   GIMP_MODULES so you can easily skip those parts of the build  *  *   * acinclude.m4  *   * config.sub  *   * config.guess  *   * ltconfig  *   * ltmain.sh: libtool 1.3.2  *  *   * app/fileops.c: shuffle #includes to avoid warning about MIN and  *   MAX  *  *   [ The following is a big i18n patch from David Monniaux  *<david.monniaux@ens.fr> ]  *  *   * tips/gimp_conseils.fr.txt  *   * tips/gimp_tips.txt  *   * tips/Makefile.am  *   * configure.in: moved tips to separate dir  *  *   * po-plugins: new dir for plug-in translation files  *  *   * configure.in: add po-plugins dir and POTFILES processing  *  *   * app/boundary.c  *   * app/brightness_contrast.c  *   * app/by_color_select.c  *   * app/color_balance.c  *   * app/convert.c  *   * app/curves.c  *   * app/free_select.c  *   * app/gdisplay.c  *   * app/gimpimage.c  *   * app/gimpunit.c  *   * app/gradient.c  *   * app/gradient_select.c  *   * app/install.c  *   * app/session.c: various i18n tweaks  *  *   * app/tips_dialog.c: localize tips filename  *  *   * libgimp/gimpunit.c  *   * libgimp/gimpunitmenu.c: #include "config.h"  *  *   * plug-ins/CEL  *   * plug-ins/CML_explorer  *   * plug-ins/Lighting  *   * plug-ins/apply_lens  *   * plug-ins/autostretch_hsv  *   * plug-ins/blur  *   * plug-ins/bmp  *   * plug-ins/borderaverage  *   * plug-ins/bumpmap  *   * plug-ins/bz2  *   * plug-ins/checkerboard  *   * plug-ins/colorify  *   * plug-ins/compose  *   * plug-ins/convmatrix  *   * plug-ins/cubism  *   * plug-ins/depthmerge  *   * plug-ins/destripe  *   * plug-ins/gif  *   * plug-ins/gifload  *   * plug-ins/jpeg  *   * plug-ins/mail  *   * plug-ins/oilify  *   * plug-ins/png  *   * plug-ins/print  *   * plug-ins/ps  *   * plug-ins/xbm  *   * plug-ins/xpm  *   * plug-ins/xwd: plug-in i18n stuff  *  *   -Yosh  *  *   Revision 1.13  1999/05/27 19:11:33  asbjoer  *   use g_strncasecmp()  *  *   Revision 1.12  1999/05/01 17:54:09  asbjoer  *   os2 printing  *  *   Revision 1.11  1999/04/15 21:49:01  yosh  *   * applied gimp-lecorfec-99041[02]-0, changes follow  *  *   * plug-ins/FractalExplorer/Dialogs.h (make_color_map):  *   replaced free with g_free to fix segfault.  *  *   * plug-ins/Lighting/lighting_preview.c (compute_preview):  *   allocate xpostab and ypostab only when needed (it could also be  *   allocated on stack with a compilation-fixed size like MapObject).  *   It avoids to lose some Kb on each preview :)  *   Also reindented (unfortunate C-c C-q) some other lines.  *  *   * plug-ins/Lighting/lighting_main.c (run):  *   release allocated postabs.  *  *   * plug-ins/Lighting/lighting_ui.c:  *   callbacks now have only one argument because gck widget use  *   gtk_signal_connect_object. Caused segfault for scale widget.  *  *   * plug-ins/autocrop/autocrop.c (doit):  *   return if image has only background (thus fixing a segfault).  *  *   * plug-ins/emboss/emboss.c (pluginCore, emboss_do_preview):  *   replaced malloc/free with g_malloc/g_free (unneeded, but  *   shouldn't everyone use glib calls ? :)  *  *   * plug-ins/flame/flame.c :  *   replaced a segfaulting free, and several harmless malloc/free pairs.  *  *   * plug-ins/flame/megawidget.c (mw_preview_build):  *   replaced harmless malloc/free pair.  *   Note : mwp->bits is malloc'ed but seems to be never freed.  *  *   * plug-ins/fractaltrace/fractaltrace.c (pixels_free):  *   replaced a bunch of segfaulting free.  *   (pixels_get, dialog_show): replaced gtk_signal_connect_object  *   with gtk_signal_connect to accomodate callbacks (caused STRANGE  *   dialog behaviour, coz you destroyed buttons one by one).  *  *   * plug-ins/illusion/illusion.c (dialog):  *   same gtk_signal_connect_object replacement for same reasons.  *  *   * plug-ins/libgck/gck/gckcolor.c :  *   changed all gck_rgb_to_color* functions to use a static GdkColor  *   instead of a malloc'ed area. Provided reentrant functions with  *   the old behaviour (gck_rgb_to_color*_r). Made some private functions  *   static, too.  *   gck_rgb_to_gdkcolor now use the new functions while  *   gck_rgb_to_gdkcolor_r is the reentrant version.  *   Also affected by this change: gck_gc_set_foreground and  *   gck_gc_set_background (no more free(color)).  *  *   * plug-ins/libgck/gck/gckcolor.h :  *   added the gck_rgb_to_gdkcolor_r proto.  *  *   * plug-ins/lic/lic.c (ok_button_clicked, cancel_button_clicked) :  *   segfault on gtk_widget_destroy, now calls gtk_main_quit.  *   (dialog_destroy) : segfault on window closure when called by  *   "destroy" event. Now called by "delete_event".  *  *   * plug-ins/megawidget/megawidget.c (mw_preview_build):  *   replaced harmless malloc/free pair.  *   Note : mwp->bits is malloc'ed but seems to be never freed.  *  *   * plug-ins/png/png.c (load_image):  *   replaced 2 segfaulting free.  *  *   * plug-ins/print/print-ps.c (ps_print):  *   replaced a segfaulting free (called many times :).  *  *   * plug-ins/sgi/sgi.c (load_image, save_image):  *   replaced a bunch of segfaulting free, and did some harmless  *   inits to avoid a few gcc warnings.  *  *   * plug-ins/wind/wind.c (render_wind):  *   replaced a segfaulting free.  *   (render_blast): replaced harmless malloc/free pair.  *  *   * plug-ins/bmp/bmpread.c (ReadImage):  *   yet another free()/g_free() problem fixed.  *  *   * plug-ins/exchange/exchange.c (real_exchange):  *   ditto.  *  *   * plug-ins/fp/fp.h: added Frames_Check_Button_In_A_Box proto.  *   * plug-ins/fp/fp_gtk.c: closing subdialogs via window manager  *   wasn't handled, thus leading to errors and crashes.  *   Now delete_event signals the dialog control button  *   to close a dialog with the good way.  *  *   * plug-ins/ifscompose/ifscompose.c (value_pair_create):  *   tried to set events mask on scale widget (a NO_WINDOW widget).  *  *   * plug-ins/png/png.c (save_image):  *   Replaced 2 free() with g_free() for g_malloc'ed memory.  *   Mysteriously I corrected the loading bug but not the saving one :)  *  *   -Yosh  *  *   Revision 1.10  1998/08/28 23:01:46  yosh  *   * acconfig.h  *   * configure.in  *   * app/main.c: added check for putenv and #ifdefed it's usage since NeXTStep is  *   lame  *  *   * libgimp/gimp.c  *   * app/main.c  *   * app/plug_in.c: conditionally compile shared mem stuff so platforms without  *   it can still work  *  *   * plug-ins/CEL/CEL.c  *   * plug-ins/palette/palette.c  *   * plug-ins/print/print-escp2.c  *   * plug-ins/print/print-pcl.c  *   * plug-ins/print/print-ps.c: s/strdup/g_strdup/ for portability  *  *   -Yosh  *  *   Revision 1.9  1998/05/17 07:16:47  yosh  *   0.99.31 fun  *  *   updated print plugin  *  *   -Yosh  *  *   Revision 1.13  1998/05/15  21:01:51  mike  *   Updated image positioning code (invert top and center left/top independently)  *   Updated ps_imageable_area() to return a default imageable area when no PPD  *   file is available.  *  *   Revision 1.12  1998/05/11  23:56:56  mike  *   Removed unused outptr variable.  *  *   Revision 1.11  1998/05/08  19:20:50  mike  *   Updated to support PPD files, media size, imageable area, and parameter  *   functions.  *   Added support for scaling modes - scale by percent or scale by PPI.  *   Updated Ascii85 output - some Level 2 printers are buggy and won't accept  *   whitespace in the data stream.  *   Now use image dictionaries with Level 2 printers - allows interpolation  *   flag to be sent (not all printers use this flag).  *  *   Revision 1.10  1998/01/22  15:38:46  mike  *   Updated copyright notice.  *   Whoops - wasn't encoding correctly for portrait output to level 2 printers!  *  *   Revision 1.9  1998/01/21  21:33:47  mike  *   Added support for Level 2 filters; images are now sent in hex or  *   base-85 ASCII as necessary (faster printing).  *  *   Revision 1.8  1997/11/12  15:57:48  mike  *   Minor changes for clean compiles under Digital UNIX.  *  *   Revision 1.8  1997/11/12  15:57:48  mike  *   Minor changes for clean compiles under Digital UNIX.  *  *   Revision 1.7  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.7  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.6  1997/07/30  18:47:39  mike  *   Added scaling, orientation, and offset options.  *  *   Revision 1.5  1997/07/26  18:38:55  mike  *   Bug - was using asctime instead of ctime...  D'oh!  *  *   Revision 1.4  1997/07/26  18:19:54  mike  *   Fixed positioning/scaling bug.  *  *   Revision 1.3  1997/07/03  13:26:46  mike  *   Updated documentation for 1.0 release.  *  *   Revision 1.2  1997/07/02  18:49:36  mike  *   Forgot to free memory buffers...  *  *   Revision 1.2  1997/07/02  18:49:36  mike  *   Forgot to free memory buffers...  *  *   Revision 1.1  1997/07/02  13:51:53  mike  *   Initial revision  */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_comment
comment|/*#define DEBUG*/
end_comment

begin_comment
comment|/*  * Local variables...  */
end_comment

begin_decl_stmt
DECL|variable|ps_ppd
specifier|static
name|FILE
modifier|*
name|ps_ppd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ps_ppd_file
specifier|static
name|char
modifier|*
name|ps_ppd_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|ps_hex
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guchar
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_ascii85
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guchar
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ppd_find
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * 'ps_parameters()' - Return the parameter values for the given parameter.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
comment|/* O - Parameter values */
DECL|function|ps_parameters (int model,char * ppd_file,char * name,int * count)
name|ps_parameters
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|name
parameter_list|,
comment|/* I - Name of parameter */
name|int
modifier|*
name|count
parameter_list|)
comment|/* O - Number of values */
block|{
name|int
name|i
decl_stmt|;
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|,
name|lname
index|[
literal|255
index|]
decl_stmt|,
name|loption
index|[
literal|255
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|valptrs
decl_stmt|;
specifier|static
name|char
modifier|*
name|media_sizes
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"Letter"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Legal"
argument_list|)
block|,
name|N_
argument_list|(
literal|"A4"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Tabloid"
argument_list|)
block|,
name|N_
argument_list|(
literal|"A3"
argument_list|)
block|,
name|N_
argument_list|(
literal|"12x18"
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ppd_file
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ps_ppd_file
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ps_ppd_file
argument_list|,
name|ppd_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ps_ppd
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|ps_ppd
argument_list|)
expr_stmt|;
name|ps_ppd
operator|=
name|fopen
argument_list|(
name|ppd_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_ppd
operator|==
name|NULL
condition|)
name|ps_ppd_file
operator|=
name|NULL
expr_stmt|;
else|else
name|ps_ppd_file
operator|=
name|ppd_file
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ps_ppd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PageSize"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|count
operator|=
literal|6
expr_stmt|;
name|valptrs
operator|=
name|g_new
argument_list|(
name|char
operator|*
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|valptrs
index|[
name|i
index|]
operator|=
name|g_strdup
argument_list|(
name|media_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
name|rewind
argument_list|(
name|ps_ppd
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|valptrs
operator|=
name|g_new
argument_list|(
name|char
operator|*
argument_list|,
literal|100
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|ps_ppd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"*%s %[^/:]"
argument_list|,
name|lname
argument_list|,
name|loption
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
name|g_strcasecmp
argument_list|(
name|lname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|valptrs
index|[
operator|*
name|count
index|]
operator|=
name|g_strdup
argument_list|(
name|loption
argument_list|)
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|valptrs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
return|return
operator|(
name|valptrs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'ps_media_size()' - Return the size of the page.  */
end_comment

begin_function
name|void
DECL|function|ps_media_size (int model,char * ppd_file,char * media_size,int * width,int * length)
name|ps_media_size
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|media_size
parameter_list|,
comment|/* I - Media size */
name|int
modifier|*
name|width
parameter_list|,
comment|/* O - Width in points */
name|int
modifier|*
name|length
parameter_list|)
comment|/* O - Length in points */
block|{
name|char
modifier|*
name|dimensions
decl_stmt|;
comment|/* Dimensions of media size */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"ps_media_size(%d, \'%s\', \'%s\', %08x, %08x)\n"
argument_list|,
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
name|width
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|dimensions
operator|=
name|ppd_find
argument_list|(
name|ppd_file
argument_list|,
literal|"PaperDimension"
argument_list|,
name|media_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sscanf
argument_list|(
name|dimensions
argument_list|,
literal|"%d%d"
argument_list|,
name|width
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
name|default_media_size
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
name|width
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ps_imageable_area()' - Return the imageable area of the page.  */
end_comment

begin_function
name|void
DECL|function|ps_imageable_area (int model,char * ppd_file,char * media_size,int * left,int * right,int * bottom,int * top)
name|ps_imageable_area
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Printer model */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file (not used) */
name|char
modifier|*
name|media_size
parameter_list|,
comment|/* I - Media size */
name|int
modifier|*
name|left
parameter_list|,
comment|/* O - Left position in points */
name|int
modifier|*
name|right
parameter_list|,
comment|/* O - Right position in points */
name|int
modifier|*
name|bottom
parameter_list|,
comment|/* O - Bottom position in points */
name|int
modifier|*
name|top
parameter_list|)
comment|/* O - Top position in points */
block|{
name|char
modifier|*
name|area
decl_stmt|;
comment|/* Imageable area of media */
name|float
name|fleft
decl_stmt|,
comment|/* Floating point versions */
name|fright
decl_stmt|,
name|fbottom
decl_stmt|,
name|ftop
decl_stmt|;
if|if
condition|(
operator|(
name|area
operator|=
name|ppd_find
argument_list|(
name|ppd_file
argument_list|,
literal|"ImageableArea"
argument_list|,
name|media_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"area = \'%s\'\n"
argument_list|,
name|area
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|sscanf
argument_list|(
name|area
argument_list|,
literal|"%f%f%f%f"
argument_list|,
operator|&
name|fleft
argument_list|,
operator|&
name|fbottom
argument_list|,
operator|&
name|fright
argument_list|,
operator|&
name|ftop
argument_list|)
operator|==
literal|4
condition|)
block|{
operator|*
name|left
operator|=
operator|(
name|int
operator|)
name|fleft
expr_stmt|;
operator|*
name|right
operator|=
operator|(
name|int
operator|)
name|fright
expr_stmt|;
operator|*
name|bottom
operator|=
operator|(
name|int
operator|)
name|fbottom
expr_stmt|;
operator|*
name|top
operator|=
operator|(
name|int
operator|)
name|ftop
expr_stmt|;
block|}
else|else
operator|*
name|left
operator|=
operator|*
name|right
operator|=
operator|*
name|bottom
operator|=
operator|*
name|top
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|default_media_size
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
name|right
argument_list|,
name|top
argument_list|)
expr_stmt|;
operator|*
name|left
operator|=
literal|18
expr_stmt|;
operator|*
name|right
operator|-=
literal|18
expr_stmt|;
operator|*
name|top
operator|-=
literal|36
expr_stmt|;
operator|*
name|bottom
operator|=
literal|36
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ps_print()' - Print an image to a PostScript printer.  */
end_comment

begin_function
name|void
DECL|function|ps_print (int model,char * ppd_file,char * resolution,char * media_size,char * media_type,char * media_source,int output_type,int orientation,float scaling,int left,int top,int copies,FILE * prn,GDrawable * drawable,guchar * lut,guchar * cmap)
name|ps_print
parameter_list|(
name|int
name|model
parameter_list|,
comment|/* I - Model (Level 1 or 2) */
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - PPD file */
name|char
modifier|*
name|resolution
parameter_list|,
comment|/* I - Resolution */
name|char
modifier|*
name|media_size
parameter_list|,
comment|/* I - Media size */
name|char
modifier|*
name|media_type
parameter_list|,
comment|/* I - Media type */
name|char
modifier|*
name|media_source
parameter_list|,
comment|/* I - Media source */
name|int
name|output_type
parameter_list|,
comment|/* I - Output type (color/grayscale) */
name|int
name|orientation
parameter_list|,
comment|/* I - Orientation of image */
name|float
name|scaling
parameter_list|,
comment|/* I - Scaling of image */
name|int
name|left
parameter_list|,
comment|/* I - Left offset of image (points) */
name|int
name|top
parameter_list|,
comment|/* I - Top offset of image (points) */
name|int
name|copies
parameter_list|,
comment|/* I - Number of copies */
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|GDrawable
modifier|*
name|drawable
parameter_list|,
comment|/* I - Image to print */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|)
comment|/* I - Colormap (for indexed images) */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Looping vars */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Looping vars */
name|GPixelRgn
name|rgn
decl_stmt|;
comment|/* Image region */
name|guchar
modifier|*
name|in
decl_stmt|,
comment|/* Input pixels from image */
modifier|*
name|out
decl_stmt|;
comment|/* Output pixels for printer */
name|int
name|page_left
decl_stmt|,
comment|/* Left margin of page */
name|page_right
decl_stmt|,
comment|/* Right margin of page */
name|page_top
decl_stmt|,
comment|/* Top of page */
name|page_bottom
decl_stmt|,
comment|/* Bottom of page */
name|page_width
decl_stmt|,
comment|/* Width of page */
name|page_height
decl_stmt|,
comment|/* Height of page */
name|out_width
decl_stmt|,
comment|/* Width of image on page */
name|out_height
decl_stmt|,
comment|/* Height of image on page */
name|out_bpp
decl_stmt|,
comment|/* Output bytes per pixel */
name|out_length
decl_stmt|,
comment|/* Output length (Level 2 output) */
name|out_offset
decl_stmt|,
comment|/* Output offset (Level 2 output) */
name|temp_width
decl_stmt|,
comment|/* Temporary width of image on page */
name|temp_height
decl_stmt|,
comment|/* Temporary height of image on page */
name|landscape
decl_stmt|;
comment|/* True if we rotate the output 90 degrees */
name|time_t
name|curtime
decl_stmt|;
comment|/* Current time of day */
name|convert_t
name|colorfunc
decl_stmt|;
comment|/* Color conversion function... */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* PostScript command */
name|int
name|order
decl_stmt|,
comment|/* Order of command */
name|num_commands
decl_stmt|;
comment|/* Number of commands */
struct|struct
comment|/* PostScript commands... */
DECL|struct|__anon29bf8c080108
block|{
DECL|member|command
name|char
modifier|*
name|command
decl_stmt|;
DECL|member|order
name|int
name|order
decl_stmt|;
block|}
name|commands
index|[
literal|4
index|]
struct|;
comment|/*   * Setup a read-only pixel region for the entire image...   */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*   * Choose the correct color conversion function...   */
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|<
literal|3
operator|&&
name|cmap
operator|==
name|NULL
condition|)
name|output_type
operator|=
name|OUTPUT_GRAY
expr_stmt|;
comment|/* Force grayscale output */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
block|{
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_rgb
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_rgb
expr_stmt|;
block|}
else|else
block|{
name|out_bpp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_gray
expr_stmt|;
elseif|else
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
name|colorfunc
operator|=
name|gray_to_gray
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_gray
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Compute the output size...   */
name|landscape
operator|=
literal|0
expr_stmt|;
name|ps_imageable_area
argument_list|(
name|model
argument_list|,
name|ppd_file
argument_list|,
name|media_size
argument_list|,
operator|&
name|page_left
argument_list|,
operator|&
name|page_right
argument_list|,
operator|&
name|page_bottom
argument_list|,
operator|&
name|page_top
argument_list|)
expr_stmt|;
name|page_width
operator|=
name|page_right
operator|-
name|page_left
expr_stmt|;
name|page_height
operator|=
name|page_top
operator|-
name|page_bottom
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"page_width = %d, page_height = %d\n"
argument_list|,
name|page_width
argument_list|,
name|page_height
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"drawable->width = %d, drawable->height = %d\n"
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scaling = %.1f\n"
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*   * Portrait width/height...   */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*     * Scale to pixels per inch...     */
name|out_width
operator|=
name|drawable
operator|->
name|width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
name|out_height
operator|=
name|drawable
operator|->
name|height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*     * Scale by percent...     */
name|out_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|out_height
operator|=
name|out_width
operator|*
name|drawable
operator|->
name|height
operator|/
name|drawable
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|out_height
operator|>
name|page_height
condition|)
block|{
name|out_height
operator|=
name|page_height
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|out_width
operator|=
name|out_height
operator|*
name|drawable
operator|->
name|width
operator|/
name|drawable
operator|->
name|height
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*   * Landscape width/height...   */
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
comment|/*     * Scale to pixels per inch...     */
name|temp_width
operator|=
name|drawable
operator|->
name|height
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
name|temp_height
operator|=
name|drawable
operator|->
name|width
operator|*
operator|-
literal|72.0
operator|/
name|scaling
expr_stmt|;
block|}
else|else
block|{
comment|/*     * Scale by percent...     */
name|temp_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100.0
expr_stmt|;
name|temp_height
operator|=
name|temp_width
operator|*
name|drawable
operator|->
name|width
operator|/
name|drawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|temp_height
operator|>
name|page_height
condition|)
block|{
name|temp_height
operator|=
name|page_height
expr_stmt|;
name|temp_width
operator|=
name|temp_height
operator|*
name|drawable
operator|->
name|height
operator|/
name|drawable
operator|->
name|width
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*   * See which orientation has the greatest area (or if we need to rotate the   * image to fit it on the page...)   */
if|if
condition|(
name|orientation
operator|==
name|ORIENT_AUTO
condition|)
block|{
if|if
condition|(
name|scaling
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
name|out_width
operator|>
name|page_width
operator|&&
name|out_height
operator|<
name|page_width
operator|)
operator|||
operator|(
name|out_height
operator|>
name|page_height
operator|&&
name|out_width
operator|<
name|page_height
operator|)
condition|)
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
else|else
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|temp_width
operator|*
name|temp_height
operator|)
operator|>
operator|(
name|out_width
operator|*
name|out_height
operator|)
condition|)
name|orientation
operator|=
name|ORIENT_LANDSCAPE
expr_stmt|;
else|else
name|orientation
operator|=
name|ORIENT_PORTRAIT
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|orientation
operator|==
name|ORIENT_LANDSCAPE
condition|)
block|{
name|out_width
operator|=
name|temp_width
expr_stmt|;
name|out_height
operator|=
name|temp_height
expr_stmt|;
name|landscape
operator|=
literal|1
expr_stmt|;
comment|/*     * Swap left/top offsets...     */
name|x
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|x
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Let the user know what we're doing...   */
name|gimp_progress_init
argument_list|(
name|_
argument_list|(
literal|"Printing..."
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   * Output a standard PostScript header with DSC comments...   */
name|curtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
condition|)
name|left
operator|=
operator|(
name|page_width
operator|-
name|out_width
operator|)
operator|/
literal|2
operator|+
name|page_left
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|0
condition|)
name|top
operator|=
operator|(
name|page_height
operator|+
name|out_height
operator|)
operator|/
literal|2
operator|+
name|page_bottom
expr_stmt|;
else|else
name|top
operator|=
name|page_height
operator|-
name|top
operator|+
name|page_bottom
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"out_width = %d, out_height = %d\n"
argument_list|,
name|out_width
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"page_left = %d, page_right = %d, page_bottom = %d, page_top = %d\n"
argument_list|,
name|page_left
argument_list|,
name|page_right
argument_list|,
name|page_bottom
argument_list|,
name|page_top
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"left = %d, top = %d\n"
argument_list|,
name|left
argument_list|,
name|top
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|__EMX__
name|_fsetmode
argument_list|(
name|prn
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"%!PS-Adobe-3.0\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Creator: "
name|PLUG_IN_NAME
literal|" plug-in V"
name|PLUG_IN_VERSION
literal|" for GIMP.\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%%%%CreationDate: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|curtime
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Copyright: 1997-1998 by Michael Sweet (mike@easysw.com)\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%%%%BoundingBox: %d %d %d %d\n"
argument_list|,
name|left
argument_list|,
name|top
operator|-
name|out_height
argument_list|,
name|left
operator|+
name|out_width
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%DocumentData: Clean7Bit\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%%%%LanguageLevel: %d\n"
argument_list|,
name|model
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Pages: 1\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Orientation: Portrait\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%EndComments\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/*   * Find any printer-specific commands...   */
name|num_commands
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|=
name|ppd_find
argument_list|(
name|ppd_file
argument_list|,
literal|"PageSize"
argument_list|,
name|media_size
argument_list|,
operator|&
name|order
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|commands
index|[
name|num_commands
index|]
operator|.
name|command
operator|=
name|g_strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|commands
index|[
name|num_commands
index|]
operator|.
name|order
operator|=
name|order
expr_stmt|;
name|num_commands
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|command
operator|=
name|ppd_find
argument_list|(
name|ppd_file
argument_list|,
literal|"InputSlot"
argument_list|,
name|media_source
argument_list|,
operator|&
name|order
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|commands
index|[
name|num_commands
index|]
operator|.
name|command
operator|=
name|g_strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|commands
index|[
name|num_commands
index|]
operator|.
name|order
operator|=
name|order
expr_stmt|;
name|num_commands
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|command
operator|=
name|ppd_find
argument_list|(
name|ppd_file
argument_list|,
literal|"MediaType"
argument_list|,
name|media_type
argument_list|,
operator|&
name|order
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|commands
index|[
name|num_commands
index|]
operator|.
name|command
operator|=
name|g_strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|commands
index|[
name|num_commands
index|]
operator|.
name|order
operator|=
name|order
expr_stmt|;
name|num_commands
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|command
operator|=
name|ppd_find
argument_list|(
name|ppd_file
argument_list|,
literal|"Resolution"
argument_list|,
name|resolution
argument_list|,
operator|&
name|order
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|commands
index|[
name|num_commands
index|]
operator|.
name|command
operator|=
name|g_strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|commands
index|[
name|num_commands
index|]
operator|.
name|order
operator|=
name|order
expr_stmt|;
name|num_commands
operator|++
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Sort the commands using the OrderDependency value...   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|num_commands
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|num_commands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|commands
index|[
name|j
index|]
operator|.
name|order
operator|<
name|commands
index|[
name|i
index|]
operator|.
name|order
condition|)
block|{
name|order
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|order
expr_stmt|;
name|command
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|command
expr_stmt|;
name|commands
index|[
name|i
index|]
operator|.
name|command
operator|=
name|commands
index|[
name|j
index|]
operator|.
name|command
expr_stmt|;
name|commands
index|[
name|i
index|]
operator|.
name|order
operator|=
name|commands
index|[
name|j
index|]
operator|.
name|order
expr_stmt|;
name|commands
index|[
name|j
index|]
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|commands
index|[
name|j
index|]
operator|.
name|order
operator|=
name|order
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Send the commands...   */
if|if
condition|(
name|num_commands
operator|>
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"%%BeginProlog\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_commands
condition|;
name|i
operator|++
control|)
block|{
name|fputs
argument_list|(
name|commands
index|[
name|i
index|]
operator|.
name|command
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|commands
index|[
name|i
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fputs
argument_list|(
literal|"%%EndProlog\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Output the page, rotating as necessary...   */
name|fputs
argument_list|(
literal|"%%Page: 1\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gsave\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d translate\n"
argument_list|,
name|left
argument_list|,
name|top
operator|-
name|out_height
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%.3f %.3f scale\n"
argument_list|,
operator|(
name|float
operator|)
name|out_width
operator|/
operator|(
operator|(
name|float
operator|)
name|drawable
operator|->
name|height
operator|)
argument_list|,
operator|(
name|float
operator|)
name|out_height
operator|/
operator|(
operator|(
name|float
operator|)
name|drawable
operator|->
name|width
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d translate\n"
argument_list|,
name|left
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%.3f %.3f scale\n"
argument_list|,
operator|(
name|float
operator|)
name|out_width
operator|/
operator|(
operator|(
name|float
operator|)
name|drawable
operator|->
name|width
operator|)
argument_list|,
operator|(
name|float
operator|)
name|out_height
operator|/
operator|(
operator|(
name|float
operator|)
name|drawable
operator|->
name|height
operator|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|in
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|out_bpp
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"/picture %d string def\n"
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d 8\n"
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
name|fputs
argument_list|(
literal|"[ 0 1 1 0 0 0 ]\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"[ 1 0 0 -1 0 1 ]\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fputs
argument_list|(
literal|"{currentfile picture readhexstring pop} image\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"{currentfile picture readhexstring pop} false 3 colorimage\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|drawable
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|y
operator|/
operator|(
name|double
operator|)
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|rgn
argument_list|,
name|in
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
name|ps_hex
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fputs
argument_list|(
literal|"/DeviceGray setcolorspace\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"/DeviceRGB setcolorspace\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"<<\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t/ImageType 1\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\t/Width %d\n"
argument_list|,
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"\t/Height %d\n"
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t/BitsPerComponent 8\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fputs
argument_list|(
literal|"\t/Decode [ 0 1 ]\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t/Decode [ 0 1 0 1 0 1 ]\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t/DataSource currentfile /ASCII85Decode filter\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drawable
operator|->
name|width
operator|*
literal|72
operator|/
name|out_width
operator|)
operator|<
literal|100
condition|)
name|fputs
argument_list|(
literal|"\t/Interpolate true\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
name|fputs
argument_list|(
literal|"\t/ImageMatrix [ 0 1 1 0 0 0 ]\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t/ImageMatrix [ 1 0 0 -1 0 1 ]\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|">>\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"image\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
operator|,
name|out_offset
operator|=
literal|0
init|;
name|y
operator|<
name|drawable
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|y
operator|/
operator|(
name|double
operator|)
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|rgn
argument_list|,
name|in
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
operator|+
name|out_offset
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
name|out_length
operator|=
name|out_offset
operator|+
name|drawable
operator|->
name|width
operator|*
name|out_bpp
expr_stmt|;
if|if
condition|(
name|y
operator|<
operator|(
name|drawable
operator|->
name|height
operator|-
literal|1
operator|)
condition|)
block|{
name|ps_ascii85
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|out_length
operator|&
operator|~
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_offset
operator|=
name|out_length
operator|&
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ps_ascii85
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|out_length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out_offset
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|out_offset
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|out
argument_list|,
name|out
operator|+
name|out_length
operator|-
name|out_offset
argument_list|,
name|out_offset
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|g_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"grestore\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"showpage\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%EndPage\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%EOF\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ps_hex()' - Print binary data as a series of hexadecimal numbers.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|ps_hex (FILE * prn,guchar * data,int length)
name|ps_hex
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|guchar
modifier|*
name|data
parameter_list|,
comment|/* I - Data to print */
name|int
name|length
parameter_list|)
comment|/* I - Number of bytes to print */
block|{
name|int
name|col
decl_stmt|;
comment|/* Current column */
specifier|static
name|char
modifier|*
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/*     * Put the hex chars out to the file; note that we don't use fprintf()     * for speed reasons...     */
name|putc
argument_list|(
name|hex
index|[
operator|*
name|data
operator|>>
literal|4
index|]
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|hex
index|[
operator|*
name|data
operator|&
literal|15
index|]
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|col
operator|=
operator|(
name|col
operator|+
literal|1
operator|)
operator|&
literal|31
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|col
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ps_ascii85()' - Print binary data as a series of base-85 numbers.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|ps_ascii85 (FILE * prn,guchar * data,int length,int last_line)
name|ps_ascii85
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|guchar
modifier|*
name|data
parameter_list|,
comment|/* I - Data to print */
name|int
name|length
parameter_list|,
comment|/* I - Number of bytes to print */
name|int
name|last_line
parameter_list|)
comment|/* I - Last line of raster data? */
block|{
name|int
name|i
decl_stmt|;
comment|/* Looping var */
name|unsigned
name|b
decl_stmt|;
comment|/* Binary data word */
name|unsigned
name|char
name|c
index|[
literal|5
index|]
decl_stmt|;
comment|/* ASCII85 encoded chars */
while|while
condition|(
name|length
operator|>
literal|3
condition|)
block|{
name|b
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'z'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
block|{
name|c
index|[
literal|4
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|3
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|b
operator|+
literal|'!'
expr_stmt|;
name|fwrite
argument_list|(
name|c
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|last_line
condition|)
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
operator|,
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|b
operator|=
operator|(
name|b
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|0
index|]
operator|,
name|data
operator|++
operator|,
name|i
operator|--
control|)
empty_stmt|;
name|c
index|[
literal|4
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|3
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|b
operator|+
literal|'!'
expr_stmt|;
name|fwrite
argument_list|(
name|c
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fputs
argument_list|(
literal|"~>\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ppd_find()' - Find a control string with the specified name& parameters.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* O - Control string */
DECL|function|ppd_find (char * ppd_file,char * name,char * option,int * order)
name|ppd_find
parameter_list|(
name|char
modifier|*
name|ppd_file
parameter_list|,
comment|/* I - Name of PPD file */
name|char
modifier|*
name|name
parameter_list|,
comment|/* I - Name of parameter */
name|char
modifier|*
name|option
parameter_list|,
comment|/* I - Value of parameter */
name|int
modifier|*
name|order
parameter_list|)
comment|/* O - Order of the control string */
block|{
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|,
comment|/* Line from file */
name|lname
index|[
literal|255
index|]
decl_stmt|,
comment|/* Name from line */
name|loption
index|[
literal|255
index|]
decl_stmt|,
comment|/* Value from line */
modifier|*
name|opt
decl_stmt|;
comment|/* Current control string pointer */
specifier|static
name|char
name|value
index|[
literal|32768
index|]
decl_stmt|;
comment|/* Current control string value */
if|if
condition|(
name|ppd_file
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|option
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ps_ppd_file
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ps_ppd_file
argument_list|,
name|ppd_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ps_ppd
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|ps_ppd
argument_list|)
expr_stmt|;
name|ps_ppd
operator|=
name|fopen
argument_list|(
name|ppd_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_ppd
operator|==
name|NULL
condition|)
name|ps_ppd_file
operator|=
name|NULL
expr_stmt|;
else|else
name|ps_ppd_file
operator|=
name|ppd_file
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ps_ppd
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|order
operator|!=
name|NULL
condition|)
operator|*
name|order
operator|=
literal|1000
expr_stmt|;
name|rewind
argument_list|(
name|ps_ppd
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|ps_ppd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
continue|continue;
if|if
condition|(
name|g_strncasecmp
argument_list|(
name|line
argument_list|,
literal|"*OrderDependency:"
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
operator|&&
name|order
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%*s%d"
argument_list|,
name|order
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"*%s %[^/:]"
argument_list|,
name|lname
argument_list|,
name|loption
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
name|g_strcasecmp
argument_list|(
name|lname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|g_strcasecmp
argument_list|(
name|loption
argument_list|,
name|option
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opt
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|opt
operator|==
literal|' '
operator|||
operator|*
name|opt
operator|==
literal|'\t'
condition|)
name|opt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|opt
operator|!=
literal|'\"'
condition|)
continue|continue;
name|strcpy
argument_list|(
name|value
argument_list|,
name|opt
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|=
name|strchr
argument_list|(
name|value
argument_list|,
literal|'\"'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|ps_ppd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|value
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\"'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|'\"'
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
else|else
operator|*
name|opt
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

