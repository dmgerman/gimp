begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * "$Id$"  *  *   Print plug-in Adobe PostScript driver for the GIMP.  *  *   Copyright 1997-1998 Michael Sweet (mike@easysw.com)  *  *   This program is free software; you can redistribute it and/or modify it  *   under the terms of the GNU General Public License as published by the Free  *   Software Foundation; either version 2 of the License, or (at your option)  *   any later version.  *  *   This program is distributed in the hope that it will be useful, but  *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  *   for more details.  *  *   You should have received a copy of the GNU General Public License  *   along with this program; if not, write to the Free Software  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Contents:  *  *   ps_print()   - Print an image to a PostScript printer.  *   ps_hex()     - Print binary data as a series of hexadecimal numbers.  *   ps_ascii85() - Print binary data as a series of base-85 numbers.  *  * Revision History:  *  *   $Log$  *   Revision 1.2  1998/01/25 09:29:27  yosh  *   Plugin updates  *   Properly generated aa Makefile (still not built by default)  *   Sven's no args script patch  *  *   -Yosh  *  *   Revision 1.10  1998/01/22  15:38:46  mike  *   Updated copyright notice.  *   Whoops - wasn't encoding correctly for portrait output to level 2 printers!  *  *   Revision 1.9  1998/01/21  21:33:47  mike  *   Added support for Level 2 filters; images are now sent in hex or  *   base-85 ASCII as necessary (faster printing).  *  *   Revision 1.8  1997/11/12  15:57:48  mike  *   Minor changes for clean compiles under Digital UNIX.  *  *   Revision 1.8  1997/11/12  15:57:48  mike  *   Minor changes for clean compiles under Digital UNIX.  *  *   Revision 1.7  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.7  1997/07/30  20:33:05  mike  *   Final changes for 1.1 release.  *  *   Revision 1.6  1997/07/30  18:47:39  mike  *   Added scaling, orientation, and offset options.  *  *   Revision 1.5  1997/07/26  18:38:55  mike  *   Bug - was using asctime instead of ctime...  D'oh!  *  *   Revision 1.4  1997/07/26  18:19:54  mike  *   Fixed positioning/scaling bug.  *  *   Revision 1.3  1997/07/03  13:26:46  mike  *   Updated documentation for 1.0 release.  *  *   Revision 1.2  1997/07/02  18:49:36  mike  *   Forgot to free memory buffers...  *  *   Revision 1.2  1997/07/02  18:49:36  mike  *   Forgot to free memory buffers...  *  *   Revision 1.1  1997/07/02  13:51:53  mike  *   Initial revision  */
end_comment

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|void
name|ps_hex
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guchar
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_ascii85
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guchar
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * 'ps_print()' - Print an image to a PostScript printer.  */
end_comment

begin_function
name|void
DECL|function|ps_print (FILE * prn,GDrawable * drawable,int media_size,int xdpi,int ydpi,int output_type,int model,guchar * lut,guchar * cmap,int orientation,int scaling,int left,int top)
name|ps_print
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|GDrawable
modifier|*
name|drawable
parameter_list|,
comment|/* I - Image to print */
name|int
name|media_size
parameter_list|,
comment|/* I - Size of output */
name|int
name|xdpi
parameter_list|,
comment|/* I - Horizontal resolution (always 72) */
name|int
name|ydpi
parameter_list|,
comment|/* I - Vertical resolution (always 72) */
name|int
name|output_type
parameter_list|,
comment|/* I - Output type (color/grayscale) */
name|int
name|model
parameter_list|,
comment|/* I - Model (ignored) */
name|guchar
modifier|*
name|lut
parameter_list|,
comment|/* I - Brightness lookup table */
name|guchar
modifier|*
name|cmap
parameter_list|,
comment|/* I - Colormap (for indexed images) */
name|int
name|orientation
parameter_list|,
comment|/* I - Orientation of image */
name|int
name|scaling
parameter_list|,
comment|/* I - Scaling of image */
name|int
name|left
parameter_list|,
comment|/* I - Left offset of image (10ths) */
name|int
name|top
parameter_list|)
comment|/* I - Top offset of image (10ths) */
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Looping vars */
name|GPixelRgn
name|rgn
decl_stmt|;
comment|/* Image region */
name|guchar
modifier|*
name|in
decl_stmt|,
comment|/* Input pixels from image */
modifier|*
name|out
decl_stmt|,
comment|/* Output pixels for printer */
modifier|*
name|outptr
decl_stmt|;
comment|/* Current output pixel */
name|int
name|page_width
decl_stmt|,
comment|/* Width of page */
name|page_height
decl_stmt|,
comment|/* Height of page */
name|out_width
decl_stmt|,
comment|/* Width of image on page */
name|out_height
decl_stmt|,
comment|/* Height of image on page */
name|out_bpp
decl_stmt|,
comment|/* Output bytes per pixel */
name|out_length
decl_stmt|,
comment|/* Output length (Level 2 output) */
name|out_offset
decl_stmt|,
comment|/* Output offset (Level 2 output) */
name|temp_width
decl_stmt|,
comment|/* Temporary width of image on page */
name|temp_height
decl_stmt|,
comment|/* Temporary height of image on page */
name|landscape
decl_stmt|;
comment|/* True if we rotate the output 90 degrees */
name|time_t
name|curtime
decl_stmt|;
comment|/* Current time of day */
name|convert_t
name|colorfunc
decl_stmt|;
comment|/* Color conversion function... */
specifier|static
name|char
modifier|*
name|filters
index|[
literal|2
index|]
init|=
comment|/* PostScript image filters... */
block|{
literal|"{currentfile picture readhexstring pop}"
block|,
comment|/* Level 1 */
literal|"currentfile /ASCII85Decode filter"
comment|/* Level 2 */
block|}
decl_stmt|;
comment|/*   * Setup a read-only pixel region for the entire image...   */
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*   * Choose the correct color conversion function...   */
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|<
literal|3
operator|&&
name|cmap
operator|==
name|NULL
condition|)
name|output_type
operator|=
name|OUTPUT_GRAY
expr_stmt|;
comment|/* Force grayscale output */
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_COLOR
condition|)
block|{
name|out_bpp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_rgb
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_rgb
expr_stmt|;
block|}
else|else
block|{
name|out_bpp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|drawable
operator|->
name|bpp
operator|>=
literal|3
condition|)
name|colorfunc
operator|=
name|rgb_to_gray
expr_stmt|;
elseif|else
if|if
condition|(
name|cmap
operator|==
name|NULL
condition|)
name|colorfunc
operator|=
name|gray_to_gray
expr_stmt|;
else|else
name|colorfunc
operator|=
name|indexed_to_gray
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Compute the output size...   */
name|landscape
operator|=
literal|0
expr_stmt|;
name|page_width
operator|=
name|media_width
argument_list|(
name|media_size
argument_list|,
name|xdpi
argument_list|)
expr_stmt|;
name|page_height
operator|=
name|media_height
argument_list|(
name|media_size
argument_list|,
name|ydpi
argument_list|)
expr_stmt|;
comment|/*   * Portrait width/height...   */
name|out_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100
expr_stmt|;
name|out_height
operator|=
name|out_width
operator|*
name|ydpi
operator|/
name|xdpi
operator|*
name|drawable
operator|->
name|height
operator|/
name|drawable
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|out_height
operator|>
name|page_height
condition|)
block|{
name|out_height
operator|=
name|page_height
expr_stmt|;
name|out_width
operator|=
name|out_height
operator|*
name|xdpi
operator|/
name|ydpi
operator|*
name|drawable
operator|->
name|width
operator|/
name|drawable
operator|->
name|height
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Landscape width/height...   */
name|temp_width
operator|=
name|page_width
operator|*
name|scaling
operator|/
literal|100
expr_stmt|;
name|temp_height
operator|=
name|temp_width
operator|*
name|ydpi
operator|/
name|xdpi
operator|*
name|drawable
operator|->
name|width
operator|/
name|drawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|temp_height
operator|>
name|page_height
condition|)
block|{
name|temp_height
operator|=
name|page_height
expr_stmt|;
name|temp_width
operator|=
name|temp_height
operator|*
name|xdpi
operator|/
name|ydpi
operator|*
name|drawable
operator|->
name|height
operator|/
name|drawable
operator|->
name|width
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * See which orientation has the greatest area...   */
if|if
condition|(
operator|(
name|temp_width
operator|*
name|temp_height
operator|)
operator|>
operator|(
name|out_width
operator|*
name|out_height
operator|)
operator|&&
name|orientation
operator|!=
name|ORIENT_PORTRAIT
condition|)
block|{
name|out_width
operator|=
name|temp_width
expr_stmt|;
name|out_height
operator|=
name|temp_height
expr_stmt|;
name|landscape
operator|=
literal|1
expr_stmt|;
comment|/*     * Swap left/top offsets...     */
name|x
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|x
expr_stmt|;
block|}
empty_stmt|;
comment|/*   * Let the user know what we're doing...   */
name|gimp_progress_init
argument_list|(
literal|"Printing..."
argument_list|)
expr_stmt|;
comment|/*   * Output a standard PostScript header with DSC comments...   */
name|curtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%!PS-Adobe-3.0\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Creator: "
name|PLUG_IN_NAME
literal|" plug-in V"
name|PLUG_IN_VERSION
literal|" for GIMP.\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%%%%CreationDate: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|curtime
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Copyright: 1997-1998 by Michael Sweet (mike@easysw.com)\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%%%%BoundingBox: %d %d %d %d\n"
argument_list|,
operator|(
name|page_width
operator|-
name|out_width
operator|)
operator|/
literal|2
operator|+
literal|18
argument_list|,
operator|(
name|page_height
operator|-
name|out_height
operator|)
operator|/
literal|2
operator|+
literal|36
argument_list|,
operator|(
name|page_width
operator|+
name|out_width
operator|)
operator|/
literal|2
operator|+
literal|18
argument_list|,
operator|(
name|page_height
operator|+
name|out_height
operator|)
operator|/
literal|2
operator|+
literal|36
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%DocumentData: Clean7Bit\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%%%%LanguageLevel: %d\n"
argument_list|,
name|model
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Pages: 1\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%Orientation: Portrait\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%EndComments\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
comment|/*   * Output the page, rotating as necessary...   */
name|fputs
argument_list|(
literal|"%%Page: 1\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gsave\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|0
operator|||
name|left
operator|<
literal|0
condition|)
block|{
name|left
operator|=
operator|(
name|page_width
operator|-
name|out_width
operator|)
operator|/
literal|2
operator|+
literal|18
expr_stmt|;
name|top
operator|=
operator|(
name|page_height
operator|-
name|out_height
operator|)
operator|/
literal|2
operator|+
literal|36
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
literal|72
operator|*
name|left
operator|/
literal|10
operator|+
literal|18
expr_stmt|;
name|top
operator|=
name|page_height
operator|-
name|out_height
operator|-
literal|72
operator|*
name|top
operator|/
literal|10
operator|+
literal|36
expr_stmt|;
block|}
empty_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d translate\n"
argument_list|,
name|left
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d scale\n"
argument_list|,
name|out_width
argument_list|,
name|out_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
block|{
name|in
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|height
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|height
operator|*
name|out_bpp
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"/picture %d string def\n"
argument_list|,
name|drawable
operator|->
name|height
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d 8 [%d 0 0 %d 0 %d] %s image\n"
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
literal|0
argument_list|,
name|filters
index|[
name|model
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d 8 [%d 0 0 %d 0 %d] %s false 3 colorimage\n"
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
literal|0
argument_list|,
name|filters
index|[
name|model
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|out_offset
operator|=
literal|0
init|;
name|x
operator|<
name|drawable
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|x
operator|/
operator|(
name|double
operator|)
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_col
argument_list|(
operator|&
name|rgn
argument_list|,
name|in
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
operator|+
name|out_offset
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
condition|)
block|{
name|out_length
operator|=
name|out_offset
operator|+
name|drawable
operator|->
name|height
operator|*
name|out_bpp
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|(
name|drawable
operator|->
name|width
operator|-
literal|1
operator|)
condition|)
block|{
name|ps_ascii85
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|out_length
operator|&
operator|~
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_offset
operator|=
name|out_length
operator|&
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ps_ascii85
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|out_length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out_offset
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|out_offset
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|out
argument_list|,
name|out
operator|+
name|out_length
operator|-
name|out_offset
argument_list|,
name|out_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|ps_hex
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|drawable
operator|->
name|height
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|bpp
argument_list|)
expr_stmt|;
name|out
operator|=
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|out_bpp
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"/picture %d string def\n"
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_type
operator|==
name|OUTPUT_GRAY
condition|)
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d 8 [%d 0 0 %d 0 %d] %s image\n"
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
operator|-
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|filters
index|[
name|model
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prn
argument_list|,
literal|"%d %d 8 [%d 0 0 %d 0 %d] %s false 3 colorimage\n"
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
operator|-
name|drawable
operator|->
name|height
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|filters
index|[
name|model
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
operator|,
name|out_offset
operator|=
literal|0
init|;
name|y
operator|<
name|drawable
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|y
operator|/
operator|(
name|double
operator|)
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_row
argument_list|(
operator|&
name|rgn
argument_list|,
name|in
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|drawable
operator|->
name|width
argument_list|)
expr_stmt|;
call|(
modifier|*
name|colorfunc
call|)
argument_list|(
name|in
argument_list|,
name|out
operator|+
name|out_offset
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|bpp
argument_list|,
name|lut
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
condition|)
block|{
name|out_length
operator|=
name|out_offset
operator|+
name|drawable
operator|->
name|width
operator|*
name|out_bpp
expr_stmt|;
if|if
condition|(
name|y
operator|<
operator|(
name|drawable
operator|->
name|height
operator|-
literal|1
operator|)
condition|)
block|{
name|ps_ascii85
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|out_length
operator|&
operator|~
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_offset
operator|=
name|out_length
operator|&
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ps_ascii85
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|out_length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out_offset
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|out_offset
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|out
argument_list|,
name|out
operator|+
name|out_length
operator|-
name|out_offset
argument_list|,
name|out_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|ps_hex
argument_list|(
name|prn
argument_list|,
name|out
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|out_bpp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|g_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"grestore\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"showpage\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%EndPage\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%%EOF\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ps_hex()' - Print binary data as a series of hexadecimal numbers.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|ps_hex (FILE * prn,guchar * data,int length)
name|ps_hex
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|guchar
modifier|*
name|data
parameter_list|,
comment|/* I - Data to print */
name|int
name|length
parameter_list|)
comment|/* I - Number of bytes to print */
block|{
specifier|static
name|char
modifier|*
name|hex
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/*     * Put the hex chars out to the file; note that we don't use fprintf()     * for speed reasons...     */
name|putc
argument_list|(
name|hex
index|[
operator|*
name|data
operator|>>
literal|4
index|]
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|hex
index|[
operator|*
name|data
operator|&
literal|15
index|]
argument_list|,
name|prn
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'ps_ascii85()' - Print binary data as a series of base-85 numbers.  */
end_comment

begin_function
specifier|static
name|void
DECL|function|ps_ascii85 (FILE * prn,guchar * data,int length,int last_line)
name|ps_ascii85
parameter_list|(
name|FILE
modifier|*
name|prn
parameter_list|,
comment|/* I - File to print to */
name|guchar
modifier|*
name|data
parameter_list|,
comment|/* I - Data to print */
name|int
name|length
parameter_list|,
comment|/* I - Number of bytes to print */
name|int
name|last_line
parameter_list|)
comment|/* I - Last line of raster data? */
block|{
name|unsigned
name|b
decl_stmt|;
comment|/* Binary data word */
name|unsigned
name|char
name|c
index|[
literal|5
index|]
decl_stmt|;
comment|/* ASCII85 encoded chars */
name|int
name|col
decl_stmt|;
comment|/* Current column */
name|col
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|3
condition|)
block|{
name|b
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'z'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
else|else
block|{
name|c
index|[
literal|4
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|3
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|b
operator|+
literal|'!'
expr_stmt|;
name|fwrite
argument_list|(
name|c
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|col
operator|=
operator|(
name|col
operator|+
literal|1
operator|)
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
operator|&&
name|length
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|last_line
condition|)
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
operator|,
name|col
operator|=
name|length
init|;
name|col
operator|>
literal|0
condition|;
name|b
operator|=
operator|(
name|b
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|0
index|]
operator|,
name|data
operator|++
operator|,
name|col
operator|--
control|)
empty_stmt|;
name|c
index|[
literal|4
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|3
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|b
operator|%
literal|85
operator|)
operator|+
literal|'!'
expr_stmt|;
name|b
operator|/=
literal|85
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|b
operator|+
literal|'!'
expr_stmt|;
name|fwrite
argument_list|(
name|c
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fputs
argument_list|(
literal|"~>\n"
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|prn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End of "$Id$".  */
end_comment

end_unit

