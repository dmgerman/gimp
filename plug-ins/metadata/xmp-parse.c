begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xmp-parse.c - simple parser for XMP metadata  *  * Copyright (C) 2004-2007, RaphaÃ«l Quinet<raphael@gimp.org>  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<http://www.gnu.org/licenses/>.  */
end_comment

begin_comment
comment|/* This code implements a simple parser for XMP metadata.  Its API is  * based on the one provided by GMarkupParser (part of Glib).  *  * This is not a full RDF parser: it shares some of the limitations  * inherited from glib (UTF-8 only, no special entities) and supports  * RDF only to the extent needed for XMP.  XMP defines several  * "schemas" containing a list of "properties".  Each property in a  * schema has one value, which can be a simple type (e.g., integer or  * text) or a structured type (rdf:Alt, rdf:Bag, rdf:Seq).  As there  * is no need to support a much deeper nesting of elements, this  * parser does not try to maintain an arbitrarily large stack of  * elements.  Also, it does not support RDF features that are  * forbidden by the XMP specs, such as rdf:parseType="Litteral".  *  * The design goals for this parser are: support all RDF features  * needed for XMP (at least the features explicitely described in the  * XMP spec), be tolerant in case unknown elements or attributes are  * found, be as simple as possible, avoid building a DOM tree.  *  * TODO:  * - support UCS-2 and UCS-4 besides UTF-8 (copy and convert the data)  * - write a decent scanner for finding<?xpacket...?> as recommended  *   in the XMP specification (including support for UCS-2 and UCS-4)  * - provide an API for passing unknown elements or tags to the caller  * - think about re-writing this using a better XML parser (expat?)  *   instead of the GMarkup parser  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WITHOUT_GIMP
end_ifndef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
DECL|macro|_ (String)
define|#
directive|define
name|_
parameter_list|(
name|String
parameter_list|)
value|(String)
end_define

begin_define
DECL|macro|N_ (String)
define|#
directive|define
name|N_
parameter_list|(
name|String
parameter_list|)
value|(String)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"base64.h"
end_include

begin_include
include|#
directive|include
file|"xmp-parse.h"
end_include

begin_function
name|GQuark
DECL|function|xmp_parse_error_quark (void)
name|xmp_parse_error_quark
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|GQuark
name|error_quark
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|error_quark
operator|==
literal|0
condition|)
name|error_quark
operator|=
name|g_quark_from_static_string
argument_list|(
literal|"xmp-parse-error-quark"
argument_list|)
expr_stmt|;
return|return
name|error_quark
return|;
block|}
end_function

begin_comment
comment|/* The current version of XMP (January 2004) is relatively simple in  * that only a few elements (<rdf:Description>,<rdf:Alt>,<rdf:Bag>,  *<rdf:Seq>) may include other elements and no deep nesting is  * allowed.  As a result, it is possible to include all allowed  * combinations directly into the state instead of having to maintain  * a separate stack besides the simple state enum.  There is only a  * 1-element stack (saved_state) used for some special cases such as  * when skipping unknown tags or parsing a property with qualifiers.  *  * Here is a quick overview of the structure of an XMP document and  * the corresponding state after reading each element.  Depending on  * the contents of each property, we can have the following cases  * that are summarized as STATE_INSIDE... below:  * - structured types can use any valid combination of the states  *   between STATE_INSIDE_QDESC and STATE_INSIDE_SEQ_LI_RSC;  * - simple property types contain some text and no other element so  *   the only state will be STATE_INSIDE_PROPERTY while reading that  *   text;  * - if the shorthand notation is used for some simple properties,  *   then they will be written as attributes of a top level  *   rdf:Description instead of being a separate element, so the  *   state will not go deeper than STATE_INSIDE_TOPLEVEL_DESC.  *  * (init)                                 STATE_START  *<?xpacket begin='' id='...'?>           STATE_INSIDE_XPACKET  *<x:xmpmeta xmlns:x='adobe:ns:meta/'>    STATE_INSIDE_XMPMETA  *<rdf:RDF xmlns:rdf='...'>               STATE_INSIDE_RDF  *<rdf:Description rdf:about='' ...>      STATE_INSIDE_TOPLEVEL_DESC  *<foo:bar>                               STATE_INSIDE_PROPERTY  *       ... (simple or structured property)    STATE_INSIDE...  *</foo:bar>                             STATE_INSIDE_TOPLEVEL_DESC  *<foo:baz>                               STATE_INSIDE_PROPERTY  *       ... (simple or structured property)    STATE_INSIDE...  *</foo:baz>                             STATE_INSIDE_TOPLEVEL_DESC  *</rdf:Description>                     STATE_INSIDE_RDF  *<rdf:Description ...>                   STATE_INSIDE_TOPLEVEL_DESC  *     ... (some properties)                   STATE_INSIDE_PROPERTY  *</rdf:Description>                     STATE_INSIDE_RDF  *    ...  *</rdf:RDF>                             STATE_AFTER_RDF  *</x:xmpmeta>                           STATE_AFTER_XMPMETA  *<?xpacket end='r'?>                    STATE_AFTER_XPACKET  *  * Note: The abbreviation QDESC is used for the properties with  * qualifiers (when<rdf:Description> is used deeper than at the top  * level inside<rdf:RDF>).  In that case, QDESC_VALUE contains the  * value of the property and QDESC_QUAL is used for each of the  * optional qualifiers (which are currently ignored).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2c300b6c0103
block|{
DECL|enumerator|STATE_START
name|STATE_START
block|,
DECL|enumerator|STATE_INSIDE_XPACKET
name|STATE_INSIDE_XPACKET
block|,
DECL|enumerator|STATE_INSIDE_XMPMETA
name|STATE_INSIDE_XMPMETA
block|,
DECL|enumerator|STATE_INSIDE_RDF
name|STATE_INSIDE_RDF
block|,
DECL|enumerator|STATE_INSIDE_TOPLEVEL_DESC
name|STATE_INSIDE_TOPLEVEL_DESC
block|,
DECL|enumerator|STATE_INSIDE_PROPERTY
name|STATE_INSIDE_PROPERTY
block|,
DECL|enumerator|STATE_INSIDE_QDESC
name|STATE_INSIDE_QDESC
block|,
DECL|enumerator|STATE_INSIDE_QDESC_VALUE
name|STATE_INSIDE_QDESC_VALUE
block|,
DECL|enumerator|STATE_INSIDE_QDESC_QUAL
name|STATE_INSIDE_QDESC_QUAL
block|,
DECL|enumerator|STATE_INSIDE_STRUCT_ADD_NS
name|STATE_INSIDE_STRUCT_ADD_NS
block|,
DECL|enumerator|STATE_INSIDE_STRUCT
name|STATE_INSIDE_STRUCT
block|,
DECL|enumerator|STATE_INSIDE_STRUCT_ELEMENT
name|STATE_INSIDE_STRUCT_ELEMENT
block|,
DECL|enumerator|STATE_INSIDE_ALT
name|STATE_INSIDE_ALT
block|,
DECL|enumerator|STATE_INSIDE_ALT_LI
name|STATE_INSIDE_ALT_LI
block|,
DECL|enumerator|STATE_INSIDE_ALT_LI_RSC
name|STATE_INSIDE_ALT_LI_RSC
block|,
DECL|enumerator|STATE_INSIDE_ALT_LI_RSC_IMG
name|STATE_INSIDE_ALT_LI_RSC_IMG
block|,
DECL|enumerator|STATE_INSIDE_BAG
name|STATE_INSIDE_BAG
block|,
DECL|enumerator|STATE_INSIDE_BAG_LI
name|STATE_INSIDE_BAG_LI
block|,
DECL|enumerator|STATE_INSIDE_BAG_LI_RSC
name|STATE_INSIDE_BAG_LI_RSC
block|,
DECL|enumerator|STATE_INSIDE_SEQ
name|STATE_INSIDE_SEQ
block|,
DECL|enumerator|STATE_INSIDE_SEQ_LI
name|STATE_INSIDE_SEQ_LI
block|,
DECL|enumerator|STATE_INSIDE_SEQ_LI_RSC
name|STATE_INSIDE_SEQ_LI_RSC
block|,
DECL|enumerator|STATE_AFTER_RDF
name|STATE_AFTER_RDF
block|,
DECL|enumerator|STATE_AFTER_XMPMETA
name|STATE_AFTER_XMPMETA
block|,
DECL|enumerator|STATE_AFTER_XPACKET
name|STATE_AFTER_XPACKET
block|,
DECL|enumerator|STATE_SKIPPING_UNKNOWN_ELEMENTS
name|STATE_SKIPPING_UNKNOWN_ELEMENTS
block|,
DECL|enumerator|STATE_SKIPPING_IGNORED_ELEMENTS
name|STATE_SKIPPING_IGNORED_ELEMENTS
block|,
DECL|enumerator|STATE_ERROR
name|STATE_ERROR
DECL|typedef|XMPParseState
block|}
name|XMPParseState
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2c300b6c0208
block|{
DECL|member|depth
name|gint
name|depth
decl_stmt|;
DECL|member|uri
name|gchar
modifier|*
name|uri
decl_stmt|;
DECL|member|prefix
name|gchar
modifier|*
name|prefix
decl_stmt|;
DECL|member|prefix_len
name|gint
name|prefix_len
decl_stmt|;
DECL|member|ns_user_data
name|gpointer
name|ns_user_data
decl_stmt|;
DECL|typedef|XMLNameSpace
block|}
name|XMLNameSpace
typedef|;
end_typedef

begin_struct
DECL|struct|_XMPParseContext
struct|struct
name|_XMPParseContext
block|{
DECL|member|parser
specifier|const
name|XMPParser
modifier|*
name|parser
decl_stmt|;
DECL|member|flags
name|XMPParseFlags
name|flags
decl_stmt|;
DECL|member|user_data
name|gpointer
name|user_data
decl_stmt|;
DECL|member|user_data_dnotify
name|GDestroyNotify
name|user_data_dnotify
decl_stmt|;
DECL|member|state
name|XMPParseState
name|state
decl_stmt|;
DECL|member|depth
name|gint
name|depth
decl_stmt|;
DECL|member|namespaces
name|GSList
modifier|*
name|namespaces
decl_stmt|;
DECL|member|xmp_prefix
name|gchar
modifier|*
name|xmp_prefix
decl_stmt|;
DECL|member|xmp_prefix_len
name|guint
name|xmp_prefix_len
decl_stmt|;
DECL|member|rdf_prefix
name|gchar
modifier|*
name|rdf_prefix
decl_stmt|;
DECL|member|rdf_prefix_len
name|guint
name|rdf_prefix_len
decl_stmt|;
DECL|member|property
name|gchar
modifier|*
name|property
decl_stmt|;
DECL|member|property_ns
name|XMLNameSpace
modifier|*
name|property_ns
decl_stmt|;
DECL|member|property_type
name|XMPParseType
name|property_type
decl_stmt|;
DECL|member|prop_value
name|gchar
modifier|*
modifier|*
name|prop_value
decl_stmt|;
DECL|member|prop_cur_value
name|gint
name|prop_cur_value
decl_stmt|;
DECL|member|prop_max_value
name|gint
name|prop_max_value
decl_stmt|;
DECL|member|prop_missing_value
name|gboolean
name|prop_missing_value
decl_stmt|;
comment|/* used when skipping tags, or inside a struct or property qualifier */
DECL|member|saved_state
name|XMPParseState
name|saved_state
decl_stmt|;
DECL|member|saved_depth
name|gint
name|saved_depth
decl_stmt|;
DECL|member|markup_context
name|GMarkupParseContext
modifier|*
name|markup_context
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
end_ifdef

begin_decl_stmt
DECL|variable|state_names
specifier|static
specifier|const
name|gchar
modifier|*
specifier|const
name|state_names
index|[]
init|=
block|{
literal|"START"
block|,
literal|"INSIDE_XPACKET"
block|,
literal|"INSIDE_XMPMETA"
block|,
literal|"INSIDE_RDF"
block|,
literal|"INSIDE_TOPLEVEL_DESC"
block|,
literal|"INSIDE_PROPERTY"
block|,
literal|"INSIDE_QDESC"
block|,
literal|"INSIDE_QDESC_VALUE"
block|,
literal|"INSIDE_QDESC_QUAL"
block|,
literal|"INSIDE_STRUCT_ADD_NS"
block|,
literal|"INSIDE_STRUCT"
block|,
literal|"INSIDE_STRUCT_ELEMENT"
block|,
literal|"INSIDE_ALT"
block|,
literal|"INSIDE_ALT_LI"
block|,
literal|"INSIDE_ALT_LI_RSC"
block|,
literal|"INSIDE_ALT_LI_RSC_IMG"
block|,
literal|"INSIDE_BAG"
block|,
literal|"INSIDE_BAG_LI"
block|,
literal|"INSIDE_BAG_LI_RSC"
block|,
literal|"INSIDE_SEQ"
block|,
literal|"INSIDE_SEQ_LI"
block|,
literal|"INSIDE_SEQ_LI_RSC"
block|,
literal|"AFTER_RDF"
block|,
literal|"AFTER_XMPMETA"
block|,
literal|"AFTER_XPACKET"
block|,
literal|"SKIPPING_UNKNOWN_ELEMENTS"
block|,
literal|"SKIPPING_IGNORED_ELEMENTS"
block|,
literal|"ERROR"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* report an error and propagate it */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_error (XMPParseContext * context,GError ** error,XMPParseError code,const gchar * format,...)
name|parse_error
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|,
name|XMPParseError
name|code
parameter_list|,
specifier|const
name|gchar
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|GError
modifier|*
name|tmp_error
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|XMP_ERROR_NO_XPACKET
condition|)
name|tmp_error
operator|=
name|g_error_new
argument_list|(
name|XMP_PARSE_ERROR
argument_list|,
name|code
argument_list|,
name|_
argument_list|(
literal|"Error: No XMP packet found"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gchar
modifier|*
name|s
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|gint
name|line_number
decl_stmt|;
name|gint
name|char_number
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|s
operator|=
name|g_strdup_vprintf
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|g_markup_parse_context_get_position
argument_list|(
name|context
operator|->
name|markup_context
argument_list|,
operator|&
name|line_number
argument_list|,
operator|&
name|char_number
argument_list|)
expr_stmt|;
name|tmp_error
operator|=
name|g_error_new
argument_list|(
name|XMP_PARSE_ERROR
argument_list|,
name|code
argument_list|,
name|_
argument_list|(
literal|"Error on line %d char %d: %s"
argument_list|)
argument_list|,
name|line_number
argument_list|,
name|char_number
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|state
operator|=
name|STATE_ERROR
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|parser
operator|->
name|error
condition|)
call|(
modifier|*
name|context
operator|->
name|parser
operator|->
name|error
call|)
argument_list|(
name|context
argument_list|,
name|tmp_error
argument_list|,
name|context
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|g_propagate_error
argument_list|(
name|error
argument_list|,
name|tmp_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* report an error if an unexpected element is found in the wrong context */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_error_element (XMPParseContext * context,GError ** error,const gchar * expected_element,gboolean optional,const gchar * found_element)
name|parse_error_element
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|,
specifier|const
name|gchar
modifier|*
name|expected_element
parameter_list|,
name|gboolean
name|optional
parameter_list|,
specifier|const
name|gchar
modifier|*
name|found_element
parameter_list|)
block|{
if|if
condition|(
name|optional
operator|==
name|TRUE
condition|)
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_UNEXPECTED_ELEMENT
argument_list|,
name|_
argument_list|(
literal|"Expected text or optional element<%s>, found<%s> instead"
argument_list|)
argument_list|,
name|expected_element
argument_list|,
name|found_element
argument_list|)
expr_stmt|;
else|else
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_UNEXPECTED_ELEMENT
argument_list|,
name|_
argument_list|(
literal|"Expected element<%s>, found<%s> instead"
argument_list|)
argument_list|,
name|expected_element
argument_list|,
name|found_element
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* skip an unknown element (unknown property) and its contents */
end_comment

begin_function
specifier|static
name|void
DECL|function|unknown_element (XMPParseContext * context,GError ** error,const gchar * element_name)
name|unknown_element
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|g_print
argument_list|(
literal|"XMP: SKIPPING %s\n"
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_NO_UNKNOWN_ELEMENTS
condition|)
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_UNKNOWN_ELEMENT
argument_list|,
name|_
argument_list|(
literal|"Unknown element<%s>"
argument_list|)
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
else|else
block|{
name|context
operator|->
name|saved_depth
operator|=
name|context
operator|->
name|depth
expr_stmt|;
name|context
operator|->
name|saved_state
operator|=
name|context
operator|->
name|state
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_SKIPPING_UNKNOWN_ELEMENTS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* skip and element and all other elements that it may contain */
end_comment

begin_function
specifier|static
name|void
DECL|function|ignore_element (XMPParseContext * context)
name|ignore_element
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|)
block|{
name|context
operator|->
name|saved_depth
operator|=
name|context
operator|->
name|depth
expr_stmt|;
name|context
operator|->
name|saved_state
operator|=
name|context
operator|->
name|state
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_SKIPPING_IGNORED_ELEMENTS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* skip an unknown attribute (or abort if flags forbid unknown attributes) */
end_comment

begin_function
specifier|static
name|void
DECL|function|unknown_attribute (XMPParseContext * context,GError ** error,const gchar * element_name,const gchar * attribute_name,const gchar * attribute_value)
name|unknown_attribute
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|attribute_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|attribute_value
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_NO_UNKNOWN_ATTRIBUTES
condition|)
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_UNKNOWN_ATTRIBUTE
argument_list|,
name|_
argument_list|(
literal|"Unknown attribute \"%s\"=\"%s\" in element<%s>"
argument_list|)
argument_list|,
name|attribute_name
argument_list|,
name|attribute_value
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|g_print
argument_list|(
literal|"skipping unknown attribute \"%s\"=\"%s\" in element<%s>\n"
argument_list|,
name|attribute_name
argument_list|,
name|attribute_value
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|is_whitespace_string (const gchar * string)
name|is_whitespace_string
parameter_list|(
specifier|const
name|gchar
modifier|*
name|string
parameter_list|)
block|{
specifier|const
name|gchar
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* XML accepts only 4 ASCII chars as whitespace and no other UNICODE chars */
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* new namespace/schema seen - add it to the list of namespaces */
end_comment

begin_function
specifier|static
name|void
DECL|function|push_namespace (XMPParseContext * context,const gchar * uri,const gchar * prefix,GError ** error)
name|push_namespace
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|uri
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefix
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMLNameSpace
modifier|*
name|ns
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|uri
argument_list|,
literal|"adobe:ns:meta/"
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|context
operator|->
name|xmp_prefix
argument_list|)
expr_stmt|;
name|context
operator|->
name|xmp_prefix
operator|=
name|g_strdup
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* XMP recommends "x:" */
name|context
operator|->
name|xmp_prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|uri
argument_list|,
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|)
condition|)
block|{
name|g_free
argument_list|(
name|context
operator|->
name|rdf_prefix
argument_list|)
expr_stmt|;
name|context
operator|->
name|rdf_prefix
operator|=
name|g_strdup
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* XMP recommends "rdf:" */
name|context
operator|->
name|rdf_prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns
operator|=
name|g_slice_new0
argument_list|(
name|XMLNameSpace
argument_list|)
expr_stmt|;
name|ns
operator|->
name|depth
operator|=
name|context
operator|->
name|depth
expr_stmt|;
name|ns
operator|->
name|uri
operator|=
name|g_strdup
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|ns
operator|->
name|prefix
operator|=
name|g_strdup
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|ns
operator|->
name|prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|context
operator|->
name|namespaces
operator|=
name|g_slist_prepend
argument_list|(
name|context
operator|->
name|namespaces
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|parser
operator|->
name|start_schema
condition|)
name|ns
operator|->
name|ns_user_data
operator|=
call|(
modifier|*
name|context
operator|->
name|parser
operator|->
name|start_schema
call|)
argument_list|(
name|context
argument_list|,
name|ns
operator|->
name|uri
argument_list|,
name|ns
operator|->
name|prefix
argument_list|,
name|context
operator|->
name|user_data
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|ns
operator|->
name|ns_user_data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* free all namespaces that are deeper than the current element depth */
end_comment

begin_function
specifier|static
name|void
DECL|function|pop_namespaces (XMPParseContext * context,GError ** error)
name|pop_namespaces
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMLNameSpace
modifier|*
name|ns
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|namespaces
operator|==
name|NULL
condition|)
return|return;
name|ns
operator|=
name|context
operator|->
name|namespaces
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|ns
operator|->
name|depth
operator|>=
name|context
operator|->
name|depth
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|parser
operator|->
name|end_schema
condition|)
call|(
modifier|*
name|context
operator|->
name|parser
operator|->
name|end_schema
call|)
argument_list|(
name|context
argument_list|,
name|ns
operator|->
name|ns_user_data
argument_list|,
name|context
operator|->
name|user_data
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ns
operator|->
name|uri
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|ns
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|XMLNameSpace
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|context
operator|->
name|namespaces
operator|=
name|g_slist_delete_link
argument_list|(
name|context
operator|->
name|namespaces
argument_list|,
name|context
operator|->
name|namespaces
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|namespaces
operator|==
name|NULL
condition|)
break|break;
name|ns
operator|=
name|context
operator|->
name|namespaces
operator|->
name|data
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* checks if an element name starts with the prefix of the given namespace */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|has_ns_prefix (const gchar * name,XMLNameSpace * ns)
name|has_ns_prefix
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|XMLNameSpace
modifier|*
name|ns
parameter_list|)
block|{
if|if
condition|(
name|ns
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ns
operator|->
name|prefix
argument_list|,
name|ns
operator|->
name|prefix_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|name
index|[
name|ns
operator|->
name|prefix_len
index|]
operator|==
literal|':'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* checks if an element or attribute matches a target with the given prefix */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|matches_with_prefix (const gchar * name,const gchar * prefix,guint prefix_len,const gchar * target_name)
name|matches_with_prefix
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefix
parameter_list|,
name|guint
name|prefix_len
parameter_list|,
specifier|const
name|gchar
modifier|*
name|target_name
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
name|prefix_len
operator|+
literal|1
operator|)
operator|&&
operator|(
name|name
index|[
name|prefix_len
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
operator|+
name|prefix_len
operator|+
literal|1
argument_list|,
name|target_name
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* checks if an element or attribute matches a target in the RDF namespace */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|matches_rdf (const gchar * name,XMPParseContext * context,const gchar * target_name)
name|matches_rdf
parameter_list|(
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|target_name
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|rdf_prefix
operator|!=
name|NULL
condition|)
return|return
name|matches_with_prefix
argument_list|(
name|name
argument_list|,
name|context
operator|->
name|rdf_prefix
argument_list|,
name|context
operator|->
name|rdf_prefix_len
argument_list|,
name|target_name
argument_list|)
return|;
else|else
return|return
name|matches_with_prefix
argument_list|(
name|name
argument_list|,
literal|"rdf"
argument_list|,
literal|3
argument_list|,
name|target_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* add a new property to the schema referenced by its prefix */
end_comment

begin_comment
comment|/* the value(s) of the property will be added later by add_property_value() */
end_comment

begin_function
specifier|static
name|XMLNameSpace
modifier|*
DECL|function|new_property_in_ns (XMPParseContext * context,const gchar * element_name)
name|new_property_in_ns
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|)
block|{
name|GSList
modifier|*
name|list
decl_stmt|;
name|XMLNameSpace
modifier|*
name|ns
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|context
operator|->
name|property
operator|==
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|context
operator|->
name|prop_cur_value
operator|==
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* element_name is a new property if it starts with a known prefix */
for|for
control|(
name|list
operator|=
name|context
operator|->
name|namespaces
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|g_slist_next
argument_list|(
name|list
argument_list|)
control|)
block|{
name|ns
operator|=
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|has_ns_prefix
argument_list|(
name|element_name
argument_list|,
name|ns
argument_list|)
condition|)
block|{
name|context
operator|->
name|property
operator|=
name|g_strdup
argument_list|(
name|element_name
operator|+
name|ns
operator|->
name|prefix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|context
operator|->
name|property_type
operator|=
name|XMP_PTYPE_UNKNOWN
expr_stmt|;
name|context
operator|->
name|property_ns
operator|=
name|ns
expr_stmt|;
name|context
operator|->
name|prop_missing_value
operator|=
name|FALSE
expr_stmt|;
return|return
name|ns
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* store a value for the current property - if the element containing the */
end_comment

begin_comment
comment|/* value is being parsed but the actual value has not been seen yet, then */
end_comment

begin_comment
comment|/* call this function with a NULL value so that its data structure is */
end_comment

begin_comment
comment|/* allocated now; it will be updated later with update_property_value() */
end_comment

begin_function
specifier|static
name|void
DECL|function|add_property_value (XMPParseContext * context,XMPParseType type,gchar * name,gchar * value)
name|add_property_value
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|XMPParseType
name|type
parameter_list|,
name|gchar
modifier|*
name|name
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|property
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|XMP_PTYPE_TEXT
operator|||
name|type
operator|==
name|XMP_PTYPE_RESOURCE
condition|)
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|prop_cur_value
operator|<
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|property_type
operator|!=
name|type
condition|)
block|{
comment|/* make sure that we are not mixing different types in this property */
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|property_type
operator|==
name|XMP_PTYPE_UNKNOWN
argument_list|)
expr_stmt|;
name|context
operator|->
name|property_type
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|->
name|prop_cur_value
operator|+
literal|3
operator|>=
name|context
operator|->
name|prop_max_value
condition|)
block|{
name|context
operator|->
name|prop_max_value
operator|+=
literal|10
expr_stmt|;
name|context
operator|->
name|prop_value
operator|=
name|g_realloc
argument_list|(
name|context
operator|->
name|prop_value
argument_list|,
sizeof|sizeof
argument_list|(
name|gchar
operator|*
argument_list|)
operator|*
name|context
operator|->
name|prop_max_value
argument_list|)
expr_stmt|;
block|}
comment|/* some types store a name and a value; most others store only a value */
if|if
condition|(
name|type
operator|==
name|XMP_PTYPE_ALT_LANG
operator|||
name|type
operator|==
name|XMP_PTYPE_STRUCTURE
operator|||
name|type
operator|==
name|XMP_PTYPE_ALT_THUMBS
condition|)
comment|/* for thumbnails, name is the size */
block|{
name|context
operator|->
name|prop_cur_value
operator|++
expr_stmt|;
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
operator|=
name|name
expr_stmt|;
block|}
else|else
name|g_assert
argument_list|(
name|name
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|context
operator|->
name|prop_cur_value
operator|++
expr_stmt|;
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
operator|=
name|value
expr_stmt|;
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* if value was NULL, then we must update it later */
name|context
operator|->
name|prop_missing_value
operator|=
operator|(
name|value
operator|==
name|NULL
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* update a value that has been allocated but not stored yet */
end_comment

begin_function
specifier|static
name|void
DECL|function|update_property_value (XMPParseContext * context,gchar * value)
name|update_property_value
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|gchar
modifier|*
name|value
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|property
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|prop_cur_value
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|prop_missing_value
operator|==
name|TRUE
argument_list|)
expr_stmt|;
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
operator|=
name|value
expr_stmt|;
name|context
operator|->
name|prop_missing_value
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* invoke the 'set_property' callback and free the temporary structures */
end_comment

begin_function
specifier|static
name|void
DECL|function|propagate_property (XMPParseContext * context,GError ** error)
name|propagate_property
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|property
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|context
operator|->
name|prop_cur_value
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|parser
operator|->
name|set_property
condition|)
call|(
modifier|*
name|context
operator|->
name|parser
operator|->
name|set_property
call|)
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|property
argument_list|,
name|context
operator|->
name|property_type
argument_list|,
operator|(
specifier|const
name|gchar
operator|*
operator|*
operator|)
operator|(
name|context
operator|->
name|prop_value
operator|)
argument_list|,
name|context
operator|->
name|property_ns
operator|->
name|ns_user_data
argument_list|,
name|context
operator|->
name|user_data
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_DEFER_VALUE_FREE
operator|)
condition|)
block|{
while|while
condition|(
name|context
operator|->
name|prop_cur_value
operator|>=
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
argument_list|)
expr_stmt|;
name|context
operator|->
name|prop_cur_value
operator|--
expr_stmt|;
block|}
name|g_free
argument_list|(
name|context
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|prop_value
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|prop_cur_value
operator|=
operator|-
literal|1
expr_stmt|;
name|context
operator|->
name|prop_max_value
operator|=
literal|0
expr_stmt|;
name|g_free
argument_list|(
name|context
operator|->
name|property
argument_list|)
expr_stmt|;
name|context
operator|->
name|property
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|property_ns
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from the GMarkupParser */
end_comment

begin_function
specifier|static
name|void
DECL|function|start_element_handler (GMarkupParseContext * markup_context,const gchar * element_name,const gchar ** attribute_names,const gchar ** attribute_values,gpointer user_data,GError ** error)
name|start_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|markup_context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_names
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|attribute_values
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPParseContext
modifier|*
name|context
init|=
name|user_data
decl_stmt|;
name|gint
name|attr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|g_print
argument_list|(
literal|"[%25s/%17s] %d<%s>\n"
argument_list|,
name|state_names
index|[
name|context
operator|->
name|state
index|]
argument_list|,
operator|(
name|context
operator|->
name|saved_state
operator|==
name|STATE_ERROR
condition|?
literal|"-"
else|:
name|state_names
index|[
name|context
operator|->
name|saved_state
index|]
operator|)
argument_list|,
name|context
operator|->
name|depth
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|context
operator|->
name|depth
operator|++
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
literal|"xmlns:"
argument_list|)
condition|)
name|push_namespace
argument_list|(
name|context
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|,
name|attribute_names
index|[
name|attr
index|]
operator|+
sizeof|sizeof
argument_list|(
literal|"xmlns:"
argument_list|)
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|context
operator|->
name|state
condition|)
block|{
case|case
name|STATE_INSIDE_XPACKET
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"x:xmpmeta"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"x:xapmeta"
argument_list|)
operator|||
name|matches_with_prefix
argument_list|(
name|element_name
argument_list|,
name|context
operator|->
name|xmp_prefix
argument_list|,
name|context
operator|->
name|xmp_prefix_len
argument_list|,
literal|"xmpmeta"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_XMPMETA
expr_stmt|;
elseif|else
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"RDF"
argument_list|)
condition|)
block|{
comment|/* the x:xmpmeta element is missing, but this is allowed */
name|context
operator|->
name|depth
operator|++
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_RDF
expr_stmt|;
block|}
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"x:xmpmeta"
argument_list|,
name|FALSE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_XMPMETA
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"RDF"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_RDF
expr_stmt|;
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"rdf:RDF"
argument_list|,
name|FALSE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_RDF
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Description"
argument_list|)
condition|)
block|{
name|XMLNameSpace
modifier|*
name|ns
decl_stmt|;
name|gboolean
name|about_seen
init|=
name|FALSE
decl_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_TOPLEVEL_DESC
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|matches_rdf
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|context
argument_list|,
literal|"about"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
literal|"about"
argument_list|)
comment|/* old style */
condition|)
name|about_seen
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
literal|"xmlns"
argument_list|)
condition|)
empty_stmt|;
comment|/* the namespace has already been pushed on the stack */
else|else
block|{
name|ns
operator|=
name|new_property_in_ns
argument_list|(
name|context
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
name|NULL
condition|)
block|{
comment|/* RDF shorthand notation */
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_TEXT
argument_list|,
name|NULL
argument_list|,
name|g_strdup
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|propagate_property
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|unknown_attribute
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|about_seen
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_NO_MISSING_ABOUT
operator|)
condition|)
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_MISSING_ABOUT
argument_list|,
name|_
argument_list|(
literal|"Required attribute rdf:about missing in<%s>"
argument_list|)
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"rdf:Description"
argument_list|,
name|FALSE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_TOPLEVEL_DESC
case|:
block|{
name|XMLNameSpace
modifier|*
name|ns
decl_stmt|;
name|ns
operator|=
name|new_property_in_ns
argument_list|(
name|context
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
name|NULL
condition|)
block|{
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_PROPERTY
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|matches_rdf
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|context
argument_list|,
literal|"resource"
argument_list|)
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|g_strdup
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|matches_rdf
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|context
argument_list|,
literal|"parseType"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|,
literal|"Resource"
argument_list|)
condition|)
block|{
name|context
operator|->
name|saved_state
operator|=
name|STATE_INSIDE_TOPLEVEL_DESC
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_STRUCT_ADD_NS
expr_stmt|;
block|}
else|else
name|unknown_attribute
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|unknown_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_INSIDE_PROPERTY
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Description"
argument_list|)
condition|)
block|{
name|context
operator|->
name|saved_state
operator|=
name|context
operator|->
name|state
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_QDESC
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
literal|"xmlns"
argument_list|)
condition|)
block|{
comment|/* this desc. is a structure, not a property qualifier */
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_STRUCT_ADD_NS
expr_stmt|;
block|}
else|else
name|unknown_attribute
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Alt"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT
expr_stmt|;
elseif|else
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Bag"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_BAG
expr_stmt|;
elseif|else
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Seq"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_SEQ
expr_stmt|;
else|else
name|unknown_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_QDESC
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"value"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_QDESC_VALUE
expr_stmt|;
else|else
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_QDESC_QUAL
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_STRUCT_ADD_NS
case|:
case|case
name|STATE_INSIDE_STRUCT
case|:
block|{
name|GSList
modifier|*
name|ns_list
decl_stmt|;
name|XMLNameSpace
modifier|*
name|ns
decl_stmt|;
name|gboolean
name|found
decl_stmt|;
comment|/* compare with namespaces in scope of current rdf:Description */
name|found
operator|=
name|FALSE
expr_stmt|;
name|ns_list
operator|=
name|context
operator|->
name|namespaces
expr_stmt|;
while|while
condition|(
name|ns_list
operator|!=
name|NULL
condition|)
block|{
name|ns
operator|=
name|ns_list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|depth
operator|<
name|context
operator|->
name|depth
operator|-
literal|2
condition|)
break|break;
if|if
condition|(
name|has_ns_prefix
argument_list|(
name|element_name
argument_list|,
name|ns
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|state
operator|==
name|STATE_INSIDE_STRUCT_ADD_NS
condition|)
block|{
comment|/* first element - save the namespace prefix and uri */
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_STRUCTURE
argument_list|,
name|g_strdup
argument_list|(
name|ns
operator|->
name|prefix
argument_list|)
argument_list|,
name|g_strdup
argument_list|(
name|ns
operator|->
name|uri
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_STRUCT_ELEMENT
expr_stmt|;
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_STRUCTURE
argument_list|,
name|g_strdup
argument_list|(
name|element_name
operator|+
name|ns
operator|->
name|prefix_len
operator|+
literal|1
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ns_list
operator|=
name|ns_list
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|FALSE
condition|)
name|unknown_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_INSIDE_ALT
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"li"
argument_list|)
condition|)
block|{
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT_LI
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|matches_rdf
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|context
argument_list|,
literal|"parseType"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|,
literal|"Resource"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT_LI_RSC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
literal|"xml:lang"
argument_list|)
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_ALT_LANG
argument_list|,
name|g_strdup
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|unknown_attribute
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* rdf:Alt is not an ordered list, but some broken XMP files use */
comment|/* it instead of rdf:Seq.  Workaround: if we did not find some */
comment|/* attributes for the valid cases ALT_LANG or ALT_LI_RSC, then */
comment|/* we pretend that we are parsing a real list (bug #343315). */
if|if
condition|(
operator|(
name|context
operator|->
name|property_type
operator|!=
name|XMP_PTYPE_ALT_LANG
operator|)
operator|&&
operator|(
name|context
operator|->
name|state
operator|!=
name|STATE_INSIDE_ALT_LI_RSC
operator|)
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_ORDERED_LIST
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"rdf:li"
argument_list|,
name|FALSE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_BAG
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"li"
argument_list|)
condition|)
block|{
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_BAG_LI
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|matches_rdf
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|context
argument_list|,
literal|"parseType"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|,
literal|"Resource"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_BAG_LI_RSC
expr_stmt|;
else|else
name|unknown_attribute
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|->
name|state
operator|!=
name|STATE_INSIDE_BAG_LI_RSC
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_UNORDERED_LIST
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"rdf:li"
argument_list|,
name|FALSE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_SEQ
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"li"
argument_list|)
condition|)
block|{
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_SEQ_LI
expr_stmt|;
for|for
control|(
name|attr
operator|=
literal|0
init|;
name|attribute_names
index|[
name|attr
index|]
operator|!=
name|NULL
condition|;
operator|++
name|attr
control|)
block|{
if|if
condition|(
name|matches_rdf
argument_list|(
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|context
argument_list|,
literal|"parseType"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|attribute_values
index|[
name|attr
index|]
argument_list|,
literal|"Resource"
argument_list|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_SEQ_LI_RSC
expr_stmt|;
else|else
name|unknown_attribute
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|,
name|attribute_names
index|[
name|attr
index|]
argument_list|,
name|attribute_values
index|[
name|attr
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|->
name|state
operator|!=
name|STATE_INSIDE_SEQ_LI_RSC
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_ORDERED_LIST
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"rdf:li"
argument_list|,
name|FALSE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_BAG_LI
case|:
case|case
name|STATE_INSIDE_SEQ_LI
case|:
if|if
condition|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Description"
argument_list|)
condition|)
block|{
name|context
operator|->
name|saved_state
operator|=
name|context
operator|->
name|state
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_QDESC
expr_stmt|;
block|}
else|else
name|parse_error_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
literal|"rdf:Description"
argument_list|,
name|TRUE
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_ALT_LI_RSC
case|:
comment|/* store the thumbnail image and ignore the other elements */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"xapGImg:image"
argument_list|)
condition|)
comment|/* FIXME */
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT_LI_RSC_IMG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"xapGImg:format"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"xapGImg:width"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"xapGImg:height"
argument_list|)
condition|)
name|ignore_element
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|unknown_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_BAG_LI_RSC
case|:
case|case
name|STATE_INSIDE_SEQ_LI_RSC
case|:
name|unknown_element
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_SKIPPING_UNKNOWN_ELEMENTS
case|:
case|case
name|STATE_SKIPPING_IGNORED_ELEMENTS
case|:
break|break;
default|default:
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_PARSE
argument_list|,
name|_
argument_list|(
literal|"Nested elements (<%s>) are not allowed in this context"
argument_list|)
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called from the GMarkupParser */
end_comment

begin_function
specifier|static
name|void
DECL|function|end_element_handler (GMarkupParseContext * markup_context,const gchar * element_name,gpointer user_data,GError ** error)
name|end_element_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|markup_context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|element_name
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPParseContext
modifier|*
name|context
init|=
name|user_data
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|g_print
argument_list|(
literal|"[%25s/%17s] %d</%s>\n"
argument_list|,
name|state_names
index|[
name|context
operator|->
name|state
index|]
argument_list|,
operator|(
name|context
operator|->
name|saved_state
operator|==
name|STATE_ERROR
condition|?
literal|"-"
else|:
name|state_names
index|[
name|context
operator|->
name|saved_state
index|]
operator|)
argument_list|,
name|context
operator|->
name|depth
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|context
operator|->
name|state
condition|)
block|{
case|case
name|STATE_INSIDE_PROPERTY
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_TOPLEVEL_DESC
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|property
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|prop_cur_value
operator|<
literal|0
condition|)
block|{
comment|/* if not set yet, then property was empty */
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_TEXT
argument_list|,
name|NULL
argument_list|,
name|g_strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|propagate_property
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_INSIDE_STRUCT
case|:
name|context
operator|->
name|state
operator|=
name|context
operator|->
name|saved_state
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|property
operator|!=
name|NULL
condition|)
name|propagate_property
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_ALT
case|:
case|case
name|STATE_INSIDE_BAG
case|:
case|case
name|STATE_INSIDE_SEQ
case|:
if|if
condition|(
name|context
operator|->
name|property
operator|&&
name|context
operator|->
name|prop_cur_value
operator|<
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|context
operator|->
name|property
argument_list|)
expr_stmt|;
name|context
operator|->
name|property
operator|=
name|NULL
expr_stmt|;
block|}
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_PROPERTY
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_QDESC
case|:
name|context
operator|->
name|state
operator|=
name|context
operator|->
name|saved_state
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_QDESC_VALUE
case|:
case|case
name|STATE_INSIDE_QDESC_QUAL
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_QDESC
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_STRUCT_ELEMENT
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_STRUCT
expr_stmt|;
if|if
condition|(
operator|(
name|context
operator|->
name|prop_cur_value
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
operator|==
name|NULL
operator|)
condition|)
name|update_property_value
argument_list|(
name|context
argument_list|,
name|g_strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_ALT_LI
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT
expr_stmt|;
if|if
condition|(
operator|(
name|context
operator|->
name|prop_cur_value
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
operator|==
name|NULL
operator|)
condition|)
name|update_property_value
argument_list|(
name|context
argument_list|,
name|g_strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_ALT_LI_RSC
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_ALT_LI_RSC_IMG
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_ALT_LI_RSC
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_BAG_LI
case|:
case|case
name|STATE_INSIDE_BAG_LI_RSC
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_BAG
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_SEQ_LI
case|:
case|case
name|STATE_INSIDE_SEQ_LI_RSC
case|:
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_SEQ
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_TOPLEVEL_DESC
case|:
name|g_return_if_fail
argument_list|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"Description"
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_RDF
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_RDF
case|:
name|g_return_if_fail
argument_list|(
name|matches_rdf
argument_list|(
name|element_name
argument_list|,
name|context
argument_list|,
literal|"RDF"
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_AFTER_RDF
expr_stmt|;
break|break;
case|case
name|STATE_AFTER_RDF
case|:
name|g_return_if_fail
argument_list|(
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"x:xmpmeta"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|element_name
argument_list|,
literal|"x:xapmeta"
argument_list|)
operator|||
name|matches_with_prefix
argument_list|(
name|element_name
argument_list|,
name|context
operator|->
name|xmp_prefix
argument_list|,
name|context
operator|->
name|xmp_prefix_len
argument_list|,
literal|"xmpmeta"
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_AFTER_XMPMETA
expr_stmt|;
break|break;
case|case
name|STATE_SKIPPING_UNKNOWN_ELEMENTS
case|:
case|case
name|STATE_SKIPPING_IGNORED_ELEMENTS
case|:
if|if
condition|(
name|context
operator|->
name|depth
operator|==
name|context
operator|->
name|saved_depth
condition|)
block|{
comment|/* resume normal processing */
name|context
operator|->
name|state
operator|=
name|context
operator|->
name|saved_state
expr_stmt|;
name|context
operator|->
name|saved_state
operator|=
name|STATE_ERROR
expr_stmt|;
block|}
break|break;
default|default:
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_PARSE
argument_list|,
name|_
argument_list|(
literal|"End of element<%s> not expected in this context"
argument_list|)
argument_list|,
name|element_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|pop_namespaces
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|context
operator|->
name|depth
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from the GMarkupParser */
end_comment

begin_function
specifier|static
name|void
DECL|function|text_handler (GMarkupParseContext * markup_context,const gchar * text,gsize text_len,gpointer user_data,GError ** error)
name|text_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|markup_context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPParseContext
modifier|*
name|context
init|=
name|user_data
decl_stmt|;
switch|switch
condition|(
name|context
operator|->
name|state
condition|)
block|{
case|case
name|STATE_INSIDE_PROPERTY
case|:
if|if
condition|(
operator|!
name|is_whitespace_string
argument_list|(
name|text
argument_list|)
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_TEXT
argument_list|,
name|NULL
argument_list|,
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_STRUCT_ELEMENT
case|:
case|case
name|STATE_INSIDE_ALT_LI
case|:
case|case
name|STATE_INSIDE_BAG_LI
case|:
case|case
name|STATE_INSIDE_SEQ_LI
case|:
if|if
condition|(
operator|!
name|is_whitespace_string
argument_list|(
name|text
argument_list|)
condition|)
name|update_property_value
argument_list|(
name|context
argument_list|,
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_INSIDE_ALT_LI_RSC_IMG
case|:
block|{
name|gint
name|max_size
decl_stmt|;
name|gchar
modifier|*
name|decoded
decl_stmt|;
name|gint
name|decoded_size
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
comment|/* g_print ("XMP: Pushing text:\n%s\n", text); */
endif|#
directive|endif
name|max_size
operator|=
name|text_len
operator|-
name|text_len
operator|/
literal|4
operator|+
literal|1
expr_stmt|;
name|decoded
operator|=
name|g_malloc
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
name|decoded_size
operator|=
name|base64_decode
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|,
name|decoded
argument_list|,
name|max_size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
if|if
condition|(
name|decoded_size
operator|>
literal|0
condition|)
block|{
comment|/* FIXME: remove this debugging code */
comment|/*             FILE *ttt;              ttt = fopen ("/tmp/xmp-thumb.jpg", "wb");             fwrite (decoded, decoded_size, 1, ttt);             fclose (ttt);             */
name|g_print
argument_list|(
literal|"XMP: Thumb text len: %d (1/4 = %d)\nMax size: %d\nUsed size: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|text_len
argument_list|,
operator|(
name|int
operator|)
name|text_len
operator|/
literal|4
argument_list|,
name|max_size
argument_list|,
name|decoded_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|decoded_size
operator|>
literal|0
condition|)
block|{
name|gint
modifier|*
name|size_p
decl_stmt|;
name|size_p
operator|=
name|g_new
argument_list|(
name|gint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|=
name|decoded_size
expr_stmt|;
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_ALT_THUMBS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|size_p
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
else|else
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_ALT_THUMBS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_INSIDE_QDESC_VALUE
case|:
if|if
condition|(
operator|!
name|is_whitespace_string
argument_list|(
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|saved_state
operator|==
name|STATE_INSIDE_PROPERTY
condition|)
name|add_property_value
argument_list|(
name|context
argument_list|,
name|XMP_PTYPE_TEXT
argument_list|,
name|NULL
argument_list|,
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|update_property_value
argument_list|(
name|context
argument_list|,
name|g_strndup
argument_list|(
name|text
argument_list|,
name|text_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_INSIDE_QDESC_QUAL
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|g_print
argument_list|(
literal|"ignoring qualifier for part of \"%s\"[]: \"%.*s\"\n"
argument_list|,
name|context
operator|->
name|property
argument_list|,
operator|(
name|int
operator|)
name|text_len
argument_list|,
name|text
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FIXME: notify the user? add a way to collect qualifiers? */
break|break;
case|case
name|STATE_SKIPPING_UNKNOWN_ELEMENTS
case|:
case|case
name|STATE_SKIPPING_IGNORED_ELEMENTS
case|:
break|break;
default|default:
if|if
condition|(
operator|!
name|is_whitespace_string
argument_list|(
name|text
argument_list|)
condition|)
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_INVALID_CONTENT
argument_list|,
name|_
argument_list|(
literal|"The current element (<%s>) cannot contain text"
argument_list|)
argument_list|,
name|g_markup_parse_context_get_element
argument_list|(
name|markup_context
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called from the GMarkupParser */
end_comment

begin_function
specifier|static
name|void
DECL|function|passthrough_handler (GMarkupParseContext * markup_context,const gchar * passthrough_text,gsize text_len,gpointer user_data,GError ** error)
name|passthrough_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|markup_context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|passthrough_text
parameter_list|,
name|gsize
name|text_len
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPParseContext
modifier|*
name|context
init|=
name|user_data
decl_stmt|;
switch|switch
condition|(
name|context
operator|->
name|state
condition|)
block|{
case|case
name|STATE_START
case|:
case|case
name|STATE_AFTER_XPACKET
case|:
if|if
condition|(
operator|(
name|text_len
operator|>=
literal|21
operator|)
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|passthrough_text
argument_list|,
literal|"<?xpacket begin="
argument_list|,
literal|16
argument_list|)
operator|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_INSIDE_XPACKET
expr_stmt|;
else|else
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_PARSE
argument_list|,
name|_
argument_list|(
literal|"XMP packets must start with<?xpacket begin=...?>"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_AFTER_RDF
case|:
comment|/* the x:xmpmeta element is missing */
name|context
operator|->
name|depth
operator|--
expr_stmt|;
name|pop_namespaces
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/*fallthrough*/
case|case
name|STATE_AFTER_XMPMETA
case|:
if|if
condition|(
operator|(
name|text_len
operator|>=
literal|19
operator|)
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|passthrough_text
argument_list|,
literal|"<?xpacket end="
argument_list|,
literal|14
argument_list|)
operator|)
condition|)
name|context
operator|->
name|state
operator|=
name|STATE_AFTER_XPACKET
expr_stmt|;
else|else
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_PARSE
argument_list|,
name|_
argument_list|(
literal|"XMP packets must end with<?xpacket end=...?>"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|text_len
operator|>=
literal|18
operator|)
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|passthrough_text
argument_list|,
literal|"<?adobe-"
argument_list|,
literal|8
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* ignore things like<?adobe-xap-filters esc="CRLF"?> */
elseif|else
if|if
condition|(
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_NO_COMMENTS
operator|)
operator|&&
operator|(
name|text_len
operator|>
literal|7
operator|)
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|passthrough_text
argument_list|,
literal|"<!--"
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* comments are not allowed in XMP, but let's ignore them */
else|else
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_INVALID_COMMENT
argument_list|,
name|_
argument_list|(
literal|"XMP cannot contain XML comments or processing instructions"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called from the GMarkupParser */
end_comment

begin_function
specifier|static
name|void
DECL|function|error_handler (GMarkupParseContext * markup_context,GError * error,gpointer user_data)
name|error_handler
parameter_list|(
name|GMarkupParseContext
modifier|*
name|markup_context
parameter_list|,
name|GError
modifier|*
name|error
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|XMPParseContext
modifier|*
name|context
init|=
name|user_data
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|context
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_ERROR
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|->
name|domain
operator|!=
name|XMP_PARSE_ERROR
operator|)
operator|&&
operator|(
name|context
operator|->
name|parser
operator|->
name|error
operator|)
condition|)
call|(
modifier|*
name|context
operator|->
name|parser
operator|->
name|error
call|)
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|context
operator|->
name|user_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|markup_xmp_parser
specifier|static
name|GMarkupParser
name|markup_xmp_parser
init|=
block|{
name|start_element_handler
block|,
name|end_element_handler
block|,
name|text_handler
block|,
name|passthrough_handler
block|,
name|error_handler
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * xmp_parse_context_new:  * @parser: a #XMPParser  * @flags: one or more #XMPParseFlags  * @user_data: user data to pass to #GMarkupParser functions  * @user_data_dnotify: user data destroy notifier called when the  * parse context is freed  *  * Creates a new XMP parse context.  A parse context is used to parse  * documents.  You can feed any number of documents containing XMP  * metadata into a context, as long as no errors occur; once an error  * occurs, the parse context can't continue to parse text (you have to  * free it and create a new parse context).  *  * Return value: a new #XMPParseContext  **/
end_comment

begin_function
name|XMPParseContext
modifier|*
DECL|function|xmp_parse_context_new (const XMPParser * parser,XMPParseFlags flags,gpointer user_data,GDestroyNotify user_data_dnotify)
name|xmp_parse_context_new
parameter_list|(
specifier|const
name|XMPParser
modifier|*
name|parser
parameter_list|,
name|XMPParseFlags
name|flags
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GDestroyNotify
name|user_data_dnotify
parameter_list|)
block|{
name|XMPParseContext
modifier|*
name|context
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|parser
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|context
operator|=
name|g_slice_new0
argument_list|(
name|XMPParseContext
argument_list|)
expr_stmt|;
name|context
operator|->
name|parser
operator|=
name|parser
expr_stmt|;
name|context
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|context
operator|->
name|user_data
operator|=
name|user_data
expr_stmt|;
name|context
operator|->
name|user_data_dnotify
operator|=
name|user_data_dnotify
expr_stmt|;
name|context
operator|->
name|markup_context
operator|=
name|g_markup_parse_context_new
argument_list|(
operator|&
name|markup_xmp_parser
argument_list|,
literal|0
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|context
operator|->
name|state
operator|=
name|STATE_START
expr_stmt|;
name|context
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|namespaces
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|xmp_prefix
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|xmp_prefix_len
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|rdf_prefix
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|rdf_prefix_len
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|property
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|property_ns
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|prop_value
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|prop_cur_value
operator|=
operator|-
literal|1
expr_stmt|;
name|context
operator|->
name|prop_max_value
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|prop_missing_value
operator|=
name|FALSE
expr_stmt|;
name|context
operator|->
name|saved_state
operator|=
name|STATE_ERROR
expr_stmt|;
name|context
operator|->
name|saved_depth
operator|=
literal|0
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_parse_context_free:  * @context: a #XMPParseContext  *  * Frees a #XMPParseContext.  Cannot be called from inside one of the  * #XMPParser functions.  *  **/
end_comment

begin_function
name|void
DECL|function|xmp_parse_context_free (XMPParseContext * context)
name|xmp_parse_context_free
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|)
block|{
name|g_return_if_fail
argument_list|(
name|context
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|user_data_dnotify
condition|)
call|(
modifier|*
name|context
operator|->
name|user_data_dnotify
call|)
argument_list|(
name|context
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|g_slist_free
argument_list|(
name|context
operator|->
name|namespaces
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|context
operator|->
name|xmp_prefix
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|context
operator|->
name|rdf_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_DEFER_VALUE_FREE
operator|)
condition|)
block|{
while|while
condition|(
name|context
operator|->
name|prop_cur_value
operator|>=
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|context
operator|->
name|prop_value
index|[
name|context
operator|->
name|prop_cur_value
index|]
argument_list|)
expr_stmt|;
name|context
operator|->
name|prop_cur_value
operator|--
expr_stmt|;
block|}
name|g_free
argument_list|(
name|context
operator|->
name|prop_value
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|context
operator|->
name|property
argument_list|)
expr_stmt|;
name|g_slice_free
argument_list|(
name|XMPParseContext
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xmp_parse_context_parse:  * @context: a #XMPParseContext  * @text: chunk of text to parse  * @text_len: length of @text in bytes  * @error: return location for a #GError  *  * Feed some data to the #XMPParseContext.  The data need not be valid  * UTF-8; an error will be signaled if it's invalid.  The data need  * not be an entire document; you can feed a document into the parser  * incrementally, via multiple calls to this function.  Typically, as  * you receive data from a network connection or file, you feed each  * received chunk of data into this function, aborting the process if  * an error occurs.  Once an error is reported, no further data may be  * fed to the #XMPParseContext; all errors are fatal.  *  * Return value: %FALSE if an error occurred, %TRUE on success  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_parse_context_parse (XMPParseContext * context,const gchar * text,gssize text_len,GError ** error)
name|xmp_parse_context_parse
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|text
parameter_list|,
name|gssize
name|text_len
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|context
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|text
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|context
operator|->
name|state
operator|!=
name|STATE_ERROR
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|context
operator|->
name|flags
operator|&
name|XMP_FLAG_FIND_XPACKET
operator|)
operator|&&
operator|(
name|context
operator|->
name|state
operator|==
name|STATE_START
operator|||
name|context
operator|->
name|state
operator|==
name|STATE_AFTER_XPACKET
operator|)
condition|)
block|{
comment|/* There may be some arbitrary data before the<?xpacket...?>        * marker so we should first find it according to the        * recommendations of the XMP specification.  Once the start of        * the XMP packet has been found, the GMarkupParser can start        * its work on the text (including the<?xpacket...?> marker).        */
comment|/* FIXME: wrong, wrong, wrong!  but useful for simple tests... */
name|gint
name|i
decl_stmt|,
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|text_len
operator|-
literal|20
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|text
operator|+
name|i
argument_list|,
literal|"<?xpacket begin="
argument_list|,
literal|16
argument_list|)
condition|)
block|{
for|for
control|(
name|e
operator|=
name|i
init|;
name|e
operator|<
name|text_len
operator|-
literal|10
condition|;
name|e
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|text
operator|+
name|e
argument_list|,
literal|"<?xpacket end="
argument_list|,
literal|14
argument_list|)
condition|)
break|break;
while|while
condition|(
operator|(
name|e
operator|<
name|text_len
operator|)
operator|&&
operator|*
operator|(
name|text
operator|+
name|e
operator|)
operator|!=
literal|'>'
condition|)
name|e
operator|++
expr_stmt|;
return|return
name|g_markup_parse_context_parse
argument_list|(
name|context
operator|->
name|markup_context
argument_list|,
name|text
operator|+
name|i
argument_list|,
name|e
operator|-
name|i
operator|+
literal|1
argument_list|,
name|error
argument_list|)
return|;
block|}
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_NO_XPACKET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|g_markup_parse_context_parse
argument_list|(
name|context
operator|->
name|markup_context
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|,
name|error
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_parse_context_end_parse:  * @context: a #XMPParseContext  * @error: return location for a #GError  *  * Signals to the #XMPParseContext that all data has been fed into the  * parse context with xmp_parse_context_parse().  This function  * reports an error if the document did not contain any XMP packet or  * if the document isn't complete, for example if elements are still  * open.  *  * Return value: %TRUE on success, %FALSE if an error was set  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_parse_context_end_parse (XMPParseContext * context,GError ** error)
name|xmp_parse_context_end_parse
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|context
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|context
operator|->
name|state
operator|!=
name|STATE_ERROR
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|state
operator|==
name|STATE_START
condition|)
name|parse_error
argument_list|(
name|context
argument_list|,
name|error
argument_list|,
name|XMP_ERROR_NO_XPACKET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|g_markup_parse_context_end_parse
argument_list|(
name|context
operator|->
name|markup_context
argument_list|,
name|error
argument_list|)
return|;
block|}
end_function

end_unit

