begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xmp-model.c - treeview model for XMP metadata  *  * Copyright (C) 2004-2005, RaphaÃ«l Quinet<raphael@gimp.org>  *  * This library is free software: you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 3 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library.  If not, see  *<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"xmp-schemas.h"
end_include

begin_include
include|#
directive|include
file|"xmp-parse.h"
end_include

begin_include
include|#
directive|include
file|"xmp-model.h"
end_include

begin_comment
comment|/* The main part of the XMPModel structure is the GtkTreeStore in  * which all references to XMP properties are stored.  In the tree,  * the elements at the root level are the schemas (namespaces) and the  * children of the schemas are the XMP properties.  *  * If the XMP file contains a schema that is not part of the XMP  * specification or a known extension (e.g., IPTC Core), it will be  * included in the custom_schemas list and the corresponding element  * in the tree will get a reference to that list element instead of a  * reference to one of the static schema definitions found in  * xmp-schemas.c.  Same for custom properties inside a known or custom  * schema.  */
end_comment

begin_struct
DECL|struct|_XMPModel
struct|struct
name|_XMPModel
block|{
DECL|member|treestore
name|GtkTreeStore
modifier|*
name|treestore
decl_stmt|;
DECL|member|custom_schemas
name|GSList
modifier|*
name|custom_schemas
decl_stmt|;
DECL|member|custom_properties
name|GSList
modifier|*
name|custom_properties
decl_stmt|;
DECL|member|cached_schema
name|XMPSchema
modifier|*
name|cached_schema
decl_stmt|;
DECL|member|cached_schema_iter
name|GtkTreeIter
name|cached_schema_iter
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * xmp_model_new:  *  * Return value: a new #XMPModel.  **/
end_comment

begin_function
name|XMPModel
modifier|*
DECL|function|xmp_model_new (void)
name|xmp_model_new
parameter_list|(
name|void
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
decl_stmt|;
name|xmp_model
operator|=
name|g_new
argument_list|(
name|XMPModel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* columns defined by the XMPModelColumns enum */
name|xmp_model
operator|->
name|treestore
operator|=
name|gtk_tree_store_new
argument_list|(
name|XMP_MODEL_NUM_COLUMNS
argument_list|,
name|G_TYPE_STRING
argument_list|,
comment|/* COL_XMP_NAME */
name|G_TYPE_STRING
argument_list|,
comment|/* COL_XMP_VALUE */
name|G_TYPE_POINTER
argument_list|,
comment|/* COL_XMP_VALUE_RAW */
name|G_TYPE_POINTER
argument_list|,
comment|/* COL_XMP_TYPE_XREF */
name|G_TYPE_POINTER
argument_list|,
comment|/* COL_XMP_WIDGET_XREF */
name|G_TYPE_INT
argument_list|,
comment|/* COL_XMP_EDITABLE */
name|GDK_TYPE_PIXBUF
argument_list|,
comment|/* COL_XMP_EDIT_ICON */
name|G_TYPE_BOOLEAN
argument_list|,
comment|/* COL_XMP_VISIBLE */
name|G_TYPE_INT
argument_list|,
comment|/* COL_XMP_WEIGHT */
name|G_TYPE_BOOLEAN
comment|/* COL_XMP_WEIGHT_SET */
argument_list|)
expr_stmt|;
name|xmp_model
operator|->
name|custom_schemas
operator|=
name|NULL
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|NULL
expr_stmt|;
name|xmp_model
operator|->
name|cached_schema
operator|=
name|NULL
expr_stmt|;
return|return
name|xmp_model
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_free:  * @xmp_model: an #XMPModel  *  * Frees an #XMPModel.  **/
end_comment

begin_function
name|void
DECL|function|xmp_model_free (XMPModel * xmp_model)
name|xmp_model_free
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|)
block|{
name|GtkTreeModel
modifier|*
name|model
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|GtkTreeIter
name|child
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|value_array
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* we used XMP_FLAG_DEFER_VALUE_FREE for the parser, so now we must free      all value arrays */
name|model
operator|=
name|xmp_model_get_tree_model
argument_list|(
name|xmp_model
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtk_tree_model_get_iter_first
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|model
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
name|gtk_tree_model_iter_children
argument_list|(
name|model
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
name|gchar
modifier|*
modifier|*
name|last_value_array
init|=
name|NULL
decl_stmt|;
do|do
block|{
name|gtk_tree_model_get
argument_list|(
name|model
argument_list|,
operator|&
name|child
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
operator|&
name|value_array
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_array
operator|!=
name|last_value_array
condition|)
block|{
comment|/* FIXME: this does not free everything */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value_array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|value_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value_array
argument_list|)
expr_stmt|;
block|}
name|last_value_array
operator|=
name|value_array
expr_stmt|;
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|model
argument_list|,
operator|&
name|child
argument_list|)
condition|)
do|;
block|}
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|model
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
do|;
block|}
name|g_object_unref
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
expr_stmt|;
comment|/* FIXME: free custom schemas */
name|g_free
argument_list|(
name|xmp_model
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_is_empty:  * @xmp_model: an #XMPModel  *  * Return value: %TRUE if @xmp_model is empty (no shemas, no properties)  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_is_empty (XMPModel * xmp_model)
name|xmp_model_is_empty
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|)
block|{
name|GtkTreeIter
name|iter
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xmp_model
operator|->
name|custom_schemas
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|xmp_model
operator|->
name|custom_properties
operator|!=
name|NULL
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|!
name|gtk_tree_model_get_iter_first
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* check if the given schema_uri matches a known schema; else return NULL */
end_comment

begin_function
specifier|static
name|XMPSchema
modifier|*
DECL|function|find_xmp_schema (XMPModel * xmp_model,const gchar * schema_uri)
name|find_xmp_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|schema_uri
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|c
decl_stmt|;
comment|/* check if we know about this schema (exact match for URI) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|,
name|schema_uri
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
if|if
condition|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
name|g_print
argument_list|(
literal|"%s \t[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
else|else
name|g_print
argument_list|(
literal|"(no name) \t[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
comment|/* this is not a standard shema; now check the custom schemas */
for|for
control|(
name|list
operator|=
name|xmp_model
operator|->
name|custom_schemas
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|uri
argument_list|,
name|schema_uri
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"CUSTOM %s \t[%s]\n"
argument_list|,
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
return|;
block|}
block|}
comment|/* now check for some common errors and results of bad encoding: */
comment|/* - check for "http:" without "//", or missing "http://" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|,
literal|"http://"
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|+
literal|7
argument_list|,
name|schema_uri
argument_list|)
operator|)
operator|||
operator|(
name|g_str_has_prefix
argument_list|(
name|schema_uri
argument_list|,
literal|"http:"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|+
literal|7
argument_list|,
name|schema_uri
operator|+
literal|5
argument_list|)
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"%s \t~~~[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
comment|/* - check for errors such as "name (uri)" or "name (prefix, uri)"  */
for|for
control|(
name|c
operator|=
name|schema_uri
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|c
operator|==
literal|'('
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|','
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|c
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|==
literal|' '
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|c
condition|)
break|break;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|c
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|(
name|c
index|[
name|len
index|]
operator|==
literal|')'
operator|)
operator|||
operator|(
name|c
index|[
name|len
index|]
operator|==
literal|' '
operator|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|,
name|c
argument_list|,
name|len
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"%s \t~~~[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"Unknown schema URI %s\n"
argument_list|,
name|schema_uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* check if the given prefix matches a known schema; else return NULL */
end_comment

begin_function
specifier|static
name|XMPSchema
modifier|*
DECL|function|find_xmp_schema_prefix (XMPModel * xmp_model,const gchar * prefix)
name|find_xmp_schema_prefix
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|prefix
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
for|for
control|(
name|list
operator|=
name|xmp_model
operator|->
name|custom_schemas
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|prefix
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* make the next lookup a bit faster if the tree is not modified */
end_comment

begin_function
specifier|static
name|void
DECL|function|cache_iter_for_schema (XMPModel * xmp_model,XMPSchema * schema,GtkTreeIter * iter)
name|cache_iter_for_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPSchema
modifier|*
name|schema
parameter_list|,
name|GtkTreeIter
modifier|*
name|iter
parameter_list|)
block|{
name|xmp_model
operator|->
name|cached_schema
operator|=
name|schema
expr_stmt|;
if|if
condition|(
name|iter
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
operator|&
operator|(
name|xmp_model
operator|->
name|cached_schema_iter
operator|)
argument_list|,
name|iter
argument_list|,
sizeof|sizeof
argument_list|(
name|GtkTreeIter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find the GtkTreeIter for the given schema and return TRUE if the schema was    found in the tree; else return FALSE */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|find_iter_for_schema (XMPModel * xmp_model,XMPSchema * schema,GtkTreeIter * iter)
name|find_iter_for_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPSchema
modifier|*
name|schema
parameter_list|,
name|GtkTreeIter
modifier|*
name|iter
parameter_list|)
block|{
name|XMPSchema
modifier|*
name|schema_xref
decl_stmt|;
comment|/* common case: return the cached iter */
if|if
condition|(
name|schema
operator|==
name|xmp_model
operator|->
name|cached_schema
condition|)
block|{
name|memcpy
argument_list|(
name|iter
argument_list|,
operator|&
operator|(
name|xmp_model
operator|->
name|cached_schema_iter
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|GtkTreeIter
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* find where this schema has been stored in the tree */
if|if
condition|(
operator|!
name|gtk_tree_model_get_iter_first
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
name|iter
argument_list|)
condition|)
return|return
name|FALSE
return|;
do|do
block|{
name|gtk_tree_model_get
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
name|iter
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
operator|&
name|schema_xref
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema_xref
operator|==
name|schema
condition|)
block|{
name|cache_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
name|iter
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
name|iter
argument_list|)
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* remove a property from the list of children of schema_iter */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_and_remove_property (XMPModel * xmp_model,XMPProperty * property,GtkTreeIter * schema_iter)
name|find_and_remove_property
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPProperty
modifier|*
name|property
parameter_list|,
name|GtkTreeIter
modifier|*
name|schema_iter
parameter_list|)
block|{
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|XMPProperty
modifier|*
name|property_xref
decl_stmt|;
if|if
condition|(
operator|!
name|gtk_tree_model_iter_children
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
name|schema_iter
argument_list|)
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|gtk_tree_model_get
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
operator|&
name|property_xref
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|property_xref
operator|==
name|property
condition|)
block|{
if|if
condition|(
operator|!
name|gtk_tree_store_remove
argument_list|(
name|GTK_TREE_STORE
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|gtk_tree_model_iter_next
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* add a schema to the tree */
end_comment

begin_function
specifier|static
name|void
DECL|function|add_known_schema (XMPModel * xmp_model,XMPSchema * schema,GtkTreeIter * iter)
name|add_known_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPSchema
modifier|*
name|schema
parameter_list|,
name|GtkTreeIter
modifier|*
name|iter
parameter_list|)
block|{
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
name|iter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
name|iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|schema
operator|->
name|name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|schema
operator|->
name|uri
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|schema
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|FALSE
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|FALSE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_BOLD
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|TRUE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cache_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
name|iter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called by the XMP parser - new schema */
end_comment

begin_function
specifier|static
name|gpointer
DECL|function|parse_start_schema (XMPParseContext * context,const gchar * ns_uri,const gchar * ns_prefix,gpointer user_data,GError ** error)
name|parse_start_schema
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|ns_uri
parameter_list|,
specifier|const
name|gchar
modifier|*
name|ns_prefix
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
init|=
name|user_data
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|XMPSchema
modifier|*
name|schema
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|schema
operator|=
name|find_xmp_schema
argument_list|(
name|xmp_model
argument_list|,
name|ns_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
name|NULL
condition|)
block|{
comment|/* add schema to custom_schemas */
name|schema
operator|=
name|g_new
argument_list|(
name|XMPSchema
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|schema
operator|->
name|uri
operator|=
name|g_strdup
argument_list|(
name|ns_uri
argument_list|)
expr_stmt|;
name|schema
operator|->
name|prefix
operator|=
name|g_strdup
argument_list|(
name|ns_prefix
argument_list|)
expr_stmt|;
name|schema
operator|->
name|name
operator|=
name|schema
operator|->
name|uri
expr_stmt|;
name|schema
operator|->
name|properties
operator|=
name|NULL
expr_stmt|;
name|xmp_model
operator|->
name|custom_schemas
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_schemas
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
comment|/* already in the tree, so no need to add it again */
return|return
name|schema
return|;
block|}
comment|/* schemas with NULL names are special and should not go in the tree */
if|if
condition|(
name|schema
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|cache_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|schema
return|;
block|}
comment|/* if the schema is not in the tree yet, add it now */
name|add_known_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
return|return
name|schema
return|;
block|}
end_function

begin_comment
comment|/* called by the XMP parser - end of schema */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_end_schema (XMPParseContext * context,gpointer ns_user_data,gpointer user_data,GError ** error)
name|parse_end_schema
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|gpointer
name|ns_user_data
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
init|=
name|user_data
decl_stmt|;
name|XMPSchema
modifier|*
name|schema
init|=
name|ns_user_data
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|schema
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xmp_model
operator|->
name|cached_schema
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
if|if
condition|(
name|schema
operator|->
name|name
condition|)
name|g_print
argument_list|(
literal|"End of %s\n"
argument_list|,
name|schema
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* called by the XMP parser - new property */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_set_property (XMPParseContext * context,const gchar * name,XMPParseType type,const gchar ** value,gpointer ns_user_data,gpointer user_data,GError ** error)
name|parse_set_property
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|XMPParseType
name|type
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|value
parameter_list|,
name|gpointer
name|ns_user_data
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
init|=
name|user_data
decl_stmt|;
name|XMPSchema
modifier|*
name|schema
init|=
name|ns_user_data
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|ns_prefix
decl_stmt|;
name|XMPProperty
modifier|*
name|property
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|gchar
modifier|*
name|tmp_name
decl_stmt|;
name|gchar
modifier|*
name|tmp_value
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|schema
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
name|g_printerr
argument_list|(
literal|"Unable to set XMP property '%s' because its schema is bad"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns_prefix
operator|=
name|schema
operator|->
name|prefix
expr_stmt|;
name|property
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|schema
operator|->
name|properties
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|property
operator|=
operator|&
operator|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
comment|/* if the same property was already present, remove it (replace it) */
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
name|find_and_remove_property
argument_list|(
name|xmp_model
argument_list|,
name|property
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|XMP_PTYPE_TEXT
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"\t%s:%s = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_TEXT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_RESOURCE
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"\t%s:%s @ = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_URI
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" @"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_ORDERED_LIST
case|:
case|case
name|XMP_PTYPE_UNORDERED_LIST
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"\t%s:%s [] ="
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|g_print
argument_list|(
literal|" \"%s\""
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|g_print
argument_list|(
literal|", \"%s\""
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
operator|(
operator|(
name|type
operator|==
name|XMP_PTYPE_ORDERED_LIST
operator|)
condition|?
name|XMP_TYPE_TEXT_BAG
else|:
name|XMP_TYPE_TEXT_SEQ
operator|)
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" []"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp_value
operator|=
name|g_strjoinv
argument_list|(
literal|"; "
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|tmp_value
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_ALT_THUMBS
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
name|g_print
argument_list|(
literal|"\t%s:%s [size:%d] = \"...\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|value
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|g_print
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_THUMBNAIL_ALT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" []"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
literal|"[FIXME: display thumbnails]"
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_ALT_LANG
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
name|g_print
argument_list|(
literal|"\t%s:%s [lang:%s] = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_LANG_ALT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" ["
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
literal|"]"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XMP_PTYPE_STRUCTURE
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
for|for
control|(
name|i
operator|=
literal|2
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
name|g_print
argument_list|(
literal|"\t%s:%s [%s] = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_GENERIC_STRUCTURE
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" ["
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
literal|"]"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG_XMP_MODEL
name|g_print
argument_list|(
literal|"\t%s:%s = ?\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called by the XMP parser - parse error */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_error (XMPParseContext * context,GError * error,gpointer user_data)
name|parse_error
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
name|error
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|g_printerr
argument_list|(
literal|"While parsing XMP metadata:\n%s\n"
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|xmp_parser
specifier|static
name|XMPParser
name|xmp_parser
init|=
block|{
name|parse_start_schema
block|,
name|parse_end_schema
block|,
name|parse_set_property
block|,
name|parse_error
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * xmp_model_parse_buffer:  * @xmp_model: pointer to the #XMPModel in which the results will be stored  * @buffer: buffer to be parsed  * @buffer_length: length of the @buffer  * @skip_other_data: if %TRUE, allow arbitrary data before XMP packet marker  * @error: return location for a #GError  *  * Parse a buffer containing XMP metadata and merge the parsed contents into  * the supplied @xmp_model.  If @skip_other_data is %TRUE, then the parser  * will try to find the<?xpacket...?> marker in the buffer, skipping any  * unknown data found before it.  *  * Return value: %TRUE on success, %FALSE if an error was set  *  * (Note: this calls the functions from xmp_parse.c, which will call the  *  functions in this file through the xmp_parser structure defined above.)  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_parse_buffer (XMPModel * xmp_model,const gchar * buffer,gssize buffer_length,gboolean skip_other_data,GError ** error)
name|xmp_model_parse_buffer
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|buffer
parameter_list|,
name|gssize
name|buffer_length
parameter_list|,
name|gboolean
name|skip_other_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPParseFlags
name|flags
decl_stmt|;
name|XMPParseContext
modifier|*
name|context
decl_stmt|;
name|flags
operator|=
name|XMP_FLAG_DEFER_VALUE_FREE
expr_stmt|;
comment|/* we will free the array ourselves */
if|if
condition|(
name|skip_other_data
condition|)
name|flags
operator||=
name|XMP_FLAG_FIND_XPACKET
expr_stmt|;
name|context
operator|=
name|xmp_parse_context_new
argument_list|(
operator|&
name|xmp_parser
argument_list|,
name|flags
argument_list|,
name|xmp_model
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xmp_parse_context_parse
argument_list|(
name|context
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|xmp_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|xmp_parse_context_end_parse
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|xmp_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xmp_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_parse_file:  * @xmp_model: pointer to the #XMPModel in which the results will be stored  * @filename: name of the file containing XMP metadata to parse  * @error: return location for a #GError   *  * Try to find XMP metadata in a file and merge its contents into the supplied  * @xmp_model.  *  * Return value: %TRUE on success, %FALSE if an error was set  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_parse_file (XMPModel * xmp_model,const gchar * filename,GError ** error)
name|xmp_model_parse_file
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gchar
modifier|*
name|buffer
decl_stmt|;
name|gsize
name|buffer_length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_file_get_contents
argument_list|(
name|filename
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|buffer_length
argument_list|,
name|error
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|xmp_model_parse_buffer
argument_list|(
name|xmp_model
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
name|TRUE
argument_list|,
name|error
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_get_tree_model:  * @xmp_model: pointer to an #XMPModel  *  * Return a pointer to the #GtkTreeModel contained in the #XMPModel.  **/
end_comment

begin_function
name|GtkTreeModel
modifier|*
DECL|function|xmp_model_get_tree_model (XMPModel * xmp_model)
name|xmp_model_get_tree_model
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_get_scalar_property:  * @xmp_model: pointer to an #XMPModel  * @schema_name: full URI or usual prefix of the schema  * @property_name: name of the property to store  *  * Store a new value for the specified XMP property.  *  * Return value: string representation of the value of that property, or %NULL if the property does not exist  **/
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|xmp_model_get_scalar_property (XMPModel * xmp_model,const gchar * schema_name,const gchar * property_name)
name|xmp_model_get_scalar_property
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|schema_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|property_name
parameter_list|)
block|{
name|XMPSchema
modifier|*
name|schema
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|XMPProperty
modifier|*
name|property
init|=
name|NULL
decl_stmt|;
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|XMPProperty
modifier|*
name|property_xref
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|value
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|schema_name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|property_name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|schema
operator|=
name|find_xmp_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
name|schema
operator|=
name|find_xmp_schema_prefix
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|schema
operator|->
name|properties
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|property_name
argument_list|)
condition|)
block|{
name|property
operator|=
operator|&
operator|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|property
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|gtk_tree_model_iter_children
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL
return|;
do|do
block|{
name|gtk_tree_model_get
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
operator|&
name|property_xref
argument_list|,
name|COL_XMP_VALUE
argument_list|,
operator|&
name|value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|property_xref
operator|==
name|property
condition|)
return|return
name|value
return|;
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|)
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_set_scalar_property:  * @xmp_model: pointer to an #XMPModel  * @schema_name: full URI or usual prefix of the schema  * @property_name: name of the property to store  * @property_value: value to store  *  * Store a new value for the specified XMP property.  *  * Return value: %TRUE if the property was set, %FALSE if an error occurred (for example, the @schema_name is invalid)  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_set_scalar_property (XMPModel * xmp_model,const gchar * schema_name,const gchar * property_name,const gchar * property_value)
name|xmp_model_set_scalar_property
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|schema_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|property_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|property_value
parameter_list|)
block|{
name|XMPSchema
modifier|*
name|schema
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|XMPProperty
modifier|*
name|property
init|=
name|NULL
decl_stmt|;
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|value
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|schema_name
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|property_name
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|property_value
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|schema
operator|=
name|find_xmp_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
name|schema
operator|=
name|find_xmp_schema_prefix
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
name|add_known_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|->
name|properties
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|property_name
argument_list|)
condition|)
block|{
name|property
operator|=
operator|&
operator|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
name|find_and_remove_property
argument_list|(
name|xmp_model
argument_list|,
name|property
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|property_name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_TEXT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|value
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
name|property_value
argument_list|)
expr_stmt|;
name|value
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|g_strdup
argument_list|(
name|property_name
argument_list|)
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

