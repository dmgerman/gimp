begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xmp-model.c - treeview model for XMP metadata  *  * Copyright (C) 2004-2005, RaphaÃ«l Quinet<raphael@gimp.org>  *  * This library is free software; you can redistribute it and/or  * modify it under the terms of the GNU Lesser General Public  * License as published by the Free Software Foundation; either  * version 2 of the License, or (at your option) any later version.  *  * This library is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * Lesser General Public License for more details.  *  * You should have received a copy of the GNU Lesser General Public  * License along with this library; if not, write to the  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,  * Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<gtk/gtk.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimp.h>
end_include

begin_include
include|#
directive|include
file|<libgimp/gimpui.h>
end_include

begin_include
include|#
directive|include
file|"libgimp/stdplugins-intl.h"
end_include

begin_include
include|#
directive|include
file|"xmp-parse.h"
end_include

begin_include
include|#
directive|include
file|"xmp-model.h"
end_include

begin_comment
comment|/* The main part of the XMPModel structure is the GtkTreeStore in  * which all references to XMP properties are stored.  In the tree,  * the elements at the root level are the schemas (namespaces) and the  * children of the schemas are the XMP properties.  *  * If the XMP file contains a schema that is not part of the XMP  * specification, it will be included in the custom_schemas list and  * the corresponding element in the tree will get a reference to that  * list element instead of a reference to one of the static schema  * definitions included below.  Same for custom properties inside a  * known or custom schema.  */
end_comment

begin_struct
DECL|struct|_XMPModel
struct|struct
name|_XMPModel
block|{
DECL|member|treestore
name|GtkTreeStore
modifier|*
name|treestore
decl_stmt|;
DECL|member|custom_schemas
name|GSList
modifier|*
name|custom_schemas
decl_stmt|;
DECL|member|custom_properties
name|GSList
modifier|*
name|custom_properties
decl_stmt|;
DECL|member|current_schema
name|XMPSchema
modifier|*
name|current_schema
decl_stmt|;
DECL|member|current_schema_iter
name|GtkTreeIter
name|current_schema_iter
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|dc_properties
specifier|static
name|XMPProperty
name|dc_properties
index|[]
init|=
block|{
block|{
literal|"contributor"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"coverage"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"creator"
block|,
name|XMP_TYPE_TEXT_SEQ
block|,
name|TRUE
block|}
block|,
block|{
literal|"date"
block|,
name|XMP_TYPE_DATE
block|,
name|TRUE
block|}
block|,
block|{
literal|"description"
block|,
name|XMP_TYPE_LANG_ALT
block|,
name|TRUE
block|}
block|,
block|{
literal|"format"
block|,
name|XMP_TYPE_MIME_TYPE
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"identifier"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
comment|/*xmp:Identifier*/
block|{
literal|"language"
block|,
name|XMP_TYPE_LOCALE_BAG
block|,
name|FALSE
block|}
block|,
block|{
literal|"publisher"
block|,
name|XMP_TYPE_TEXT_BAG
block|,
name|TRUE
block|}
block|,
block|{
literal|"relation"
block|,
name|XMP_TYPE_TEXT_BAG
block|,
name|TRUE
block|}
block|,
block|{
literal|"rights"
block|,
name|XMP_TYPE_LANG_ALT
block|,
name|TRUE
block|}
block|,
block|{
literal|"source"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"subject"
block|,
name|XMP_TYPE_TEXT_BAG
block|,
name|TRUE
block|}
block|,
block|{
literal|"title"
block|,
name|XMP_TYPE_LANG_ALT
block|,
name|TRUE
block|}
block|,
block|{
literal|"type"
block|,
name|XMP_TYPE_TEXT_BAG
block|,
name|TRUE
block|}
block|,
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmp_properties
specifier|static
name|XMPProperty
name|xmp_properties
index|[]
init|=
block|{
block|{
literal|"Advisory"
block|,
name|XMP_TYPE_XPATH_BAG
block|,
name|TRUE
block|}
block|,
block|{
literal|"BaseURL"
block|,
name|XMP_TYPE_URI
block|,
name|FALSE
block|}
block|,
block|{
literal|"CreateDate"
block|,
name|XMP_TYPE_DATE
block|,
name|TRUE
block|}
block|,
block|{
literal|"CreatorTool"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"Identifier"
block|,
name|XMP_TYPE_TEXT_BAG
block|,
name|TRUE
block|}
block|,
block|{
literal|"MetadataDate"
block|,
name|XMP_TYPE_DATE
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"ModifyDate"
block|,
name|XMP_TYPE_DATE
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"NickName"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Thumbnails"
block|,
name|XMP_TYPE_THUMBNAIL_ALT
block|,
name|TRUE
block|}
block|,
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmprights_properties
specifier|static
name|XMPProperty
name|xmprights_properties
index|[]
init|=
block|{
block|{
literal|"Certificate"
block|,
name|XMP_TYPE_URI
block|,
name|TRUE
block|}
block|,
block|{
literal|"Marked"
block|,
name|XMP_TYPE_BOOLEAN
block|,
name|TRUE
block|}
block|,
block|{
literal|"Owner"
block|,
name|XMP_TYPE_TEXT_BAG
block|,
name|TRUE
block|}
block|,
block|{
literal|"UsageTerms"
block|,
name|XMP_TYPE_LANG_ALT
block|,
name|TRUE
block|}
block|,
block|{
literal|"WebStatement"
block|,
name|XMP_TYPE_URI
block|,
name|TRUE
block|}
block|,
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmpmm_properties
specifier|static
name|XMPProperty
name|xmpmm_properties
index|[]
init|=
block|{
block|{
literal|"DerivedFrom"
block|,
name|XMP_TYPE_RESOURCE_REF
block|,
name|FALSE
block|}
block|,
block|{
literal|"DocumentID"
block|,
name|XMP_TYPE_URI
block|,
name|FALSE
block|}
block|,
block|{
literal|"History"
block|,
name|XMP_TYPE_RESOURCE_EVENT_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"ManagedFrom"
block|,
name|XMP_TYPE_RESOURCE_REF
block|,
name|FALSE
block|}
block|,
block|{
literal|"Manager"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"ManageTo"
block|,
name|XMP_TYPE_URI
block|,
name|FALSE
block|}
block|,
block|{
literal|"ManageUI"
block|,
name|XMP_TYPE_URI
block|,
name|FALSE
block|}
block|,
block|{
literal|"ManagerVariant"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"RenditionClass"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"RenditionParams"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"VersionID"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"Versions"
block|,
name|XMP_TYPE_TEXT_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"LastURL"
block|,
name|XMP_TYPE_URI
block|,
name|FALSE
block|}
block|,
comment|/*deprecated*/
block|{
literal|"RenditionOf"
block|,
name|XMP_TYPE_RESOURCE_REF
block|,
name|FALSE
block|}
block|,
comment|/*deprecated*/
block|{
literal|"SaveID"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/*deprecated*/
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmpbj_properties
specifier|static
name|XMPProperty
name|xmpbj_properties
index|[]
init|=
block|{
block|{
literal|"JobRef"
block|,
name|XMP_TYPE_JOB_BAG
block|,
name|TRUE
block|}
block|,
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmptpg_properties
specifier|static
name|XMPProperty
name|xmptpg_properties
index|[]
init|=
block|{
block|{
literal|"MaxPageSize"
block|,
name|XMP_TYPE_DIMENSIONS
block|,
name|FALSE
block|}
block|,
block|{
literal|"NPages"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pdf_properties
specifier|static
name|XMPProperty
name|pdf_properties
index|[]
init|=
block|{
block|{
literal|"Keywords"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"PDFVersion"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"Producer"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|photoshop_properties
specifier|static
name|XMPProperty
name|photoshop_properties
index|[]
init|=
block|{
block|{
literal|"AuthorsPosition"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"CaptionWriter"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Category"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
comment|/* 3 ascii chars */
block|{
literal|"City"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Country"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Credit"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"DateCreated"
block|,
name|XMP_TYPE_DATE
block|,
name|TRUE
block|}
block|,
block|{
literal|"Headline"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Instructions"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Source"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"State"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"SupplementalCategories"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"TransmissionReference"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"Urgency"
block|,
name|XMP_TYPE_INTEGER
block|,
name|TRUE
block|}
block|,
comment|/* range: 1-8 */
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|tiff_properties
specifier|static
name|XMPProperty
name|tiff_properties
index|[]
init|=
block|{
block|{
literal|"ImageWidth"
block|,
name|XMP_TYPE_INTEGER
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"ImageLength"
block|,
name|XMP_TYPE_INTEGER
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"BitsPerSample"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"Compression"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1 or 6 */
block|{
literal|"PhotometricInterpretation"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 2 or 6 */
block|{
literal|"Orientation"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1-8 */
block|{
literal|"SamplesPerPixel"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
block|{
literal|"PlanarConfiguration"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1 or 2 */
block|{
literal|"YCbCrSubSampling"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
comment|/* 2,1 or 2,2 */
block|{
literal|"YCbCrPositioning"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1 or 2 */
block|{
literal|"XResolution"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"YResolution"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"ResolutionUnit"
block|,
name|XMP_TYPE_INTEGER
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
comment|/*2or3*/
block|{
literal|"TransferFunction"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
comment|/* 3 * 256 ints */
block|{
literal|"WhitePoint"
block|,
name|XMP_TYPE_RATIONAL_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"PrimaryChromaticities"
block|,
name|XMP_TYPE_RATIONAL_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"YCbCrCoefficients"
block|,
name|XMP_TYPE_RATIONAL_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"ReferenceBlackWhite"
block|,
name|XMP_TYPE_RATIONAL_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"DateTime"
block|,
name|XMP_TYPE_DATE
block|,
name|FALSE
block|}
block|,
comment|/*xmp:ModifyDate*/
block|{
literal|"ImageDescription"
block|,
name|XMP_TYPE_LANG_ALT
block|,
name|TRUE
block|}
block|,
comment|/*dc:description*/
block|{
literal|"Make"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"Model"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"Software"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/*xmp:CreatorTool*/
block|{
literal|"Artist"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
comment|/*dc:creator*/
block|{
literal|"Copyright"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
comment|/*dc:rights*/
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|exif_properties
specifier|static
name|XMPProperty
name|exif_properties
index|[]
init|=
block|{
block|{
literal|"ExifVersion"
block|,
name|XMP_TYPE_TEXT
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
comment|/*"0210*/
block|{
literal|"FlashpixVersion"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "0100" */
block|{
literal|"ColorSpace"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1 or -32768 */
block|{
literal|"ComponentsConfiguration"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
comment|/* 4 ints */
block|{
literal|"CompressedBitsPerPixel"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"PixelXDimension"
block|,
name|XMP_TYPE_INTEGER
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"PixelYDimension"
block|,
name|XMP_TYPE_INTEGER
block|,
name|XMP_AUTO_UPDATE
block|}
block|,
block|{
literal|"MakerNote"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* base64 enc.? */
block|{
literal|"UserComment"
block|,
name|XMP_TYPE_TEXT
block|,
name|TRUE
block|}
block|,
block|{
literal|"RelatedSoundFile"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* DOS 8.3 fname */
block|{
literal|"DateTimeOriginal"
block|,
name|XMP_TYPE_DATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"DateTimeDigitized"
block|,
name|XMP_TYPE_DATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"ExposureTime"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"FNumber"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"ExposureProgram"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-8 */
block|{
literal|"SpectralSensitivity"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* ? */
block|{
literal|"ISOSpeedRatings"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"OECF"
block|,
name|XMP_TYPE_OECF_SFR
block|,
name|FALSE
block|}
block|,
block|{
literal|"ShutterSpeedValue"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"ApertureValue"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"BrightnessValue"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"ExposureBiasValue"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"MaxApertureValue"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"SubjectDistance"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
comment|/* in meters */
block|{
literal|"MeteringMode"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-6 or 255 */
block|{
literal|"LightSource"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-3,17-22,255*/
block|{
literal|"Flash"
block|,
name|XMP_TYPE_FLASH
block|,
name|FALSE
block|}
block|,
block|{
literal|"FocalLength"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"SubjectArea"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
block|{
literal|"FlashEnergy"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"SpatialFrequencyResponse"
block|,
name|XMP_TYPE_OECF_SFR
block|,
name|FALSE
block|}
block|,
block|{
literal|"FocalPlaneXResolution"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"FocalPlaneYResolution"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"FocalPlaneResolutionUnit"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* unit: 2 or 3 */
block|{
literal|"SubjectLocation"
block|,
name|XMP_TYPE_INTEGER_SEQ
block|,
name|FALSE
block|}
block|,
comment|/* 2 ints: X, Y */
block|{
literal|"ExposureIndex"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"SensingMethod"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1-8 */
block|{
literal|"FileSource"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 3 */
block|{
literal|"SceneType"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 1 */
block|{
literal|"CFAPattern"
block|,
name|XMP_TYPE_CFA_PATTERN
block|,
name|FALSE
block|}
block|,
block|{
literal|"CustomRendered"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-1 */
block|{
literal|"ExposureMode"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-2 */
block|{
literal|"WhiteBalance"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-1 */
block|{
literal|"DigitalZoomRatio"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"FocalLengthIn35mmFilm"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* in mm */
block|{
literal|"SceneCaptureType"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-3 */
block|{
literal|"GainControl"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-4 */
block|{
literal|"Contrast"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-2 */
block|{
literal|"Saturation"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-2 */
block|{
literal|"Sharpness"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-2 */
block|{
literal|"DeviceSettingDescription"
block|,
name|XMP_TYPE_DEVICE_SETTINGS
block|,
name|FALSE
block|}
block|,
block|{
literal|"SubjectDistanceRange"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-3 */
block|{
literal|"ImageUniqueID"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* 32 chars */
block|{
literal|"GPSVersionID"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "2.0.0.0" */
block|{
literal|"GPSLatitude"
block|,
name|XMP_TYPE_GPS_COORDINATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSLongitude"
block|,
name|XMP_TYPE_GPS_COORDINATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSAltitudeRef"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-1 */
block|{
literal|"GPSAltitude"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
comment|/* in meters */
block|{
literal|"GPSTimeStamp"
block|,
name|XMP_TYPE_DATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSSatellites"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* ? */
block|{
literal|"GPSStatus"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "A" or "V" */
block|{
literal|"GPSMeasureMode"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 2-3 */
block|{
literal|"GPSDOP"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSSpeedRef"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "K","M","N" */
block|{
literal|"GPSSpeed"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSTrackRef"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "T" or "M"" */
block|{
literal|"GPSTrack"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSImgDirectionRef"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "T" or "M"" */
block|{
literal|"GPSImgDirection"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSMapDatum"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSDestLatitude"
block|,
name|XMP_TYPE_GPS_COORDINATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSDestLongitude"
block|,
name|XMP_TYPE_GPS_COORDINATE
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSDestBearingRef"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "T" or "M"" */
block|{
literal|"GPSDestBearing"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSDestDistanceRef"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
comment|/* "K","M","N" */
block|{
literal|"GPSDestDistance"
block|,
name|XMP_TYPE_RATIONAL
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSProcessingMethod"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSAreaInformation"
block|,
name|XMP_TYPE_TEXT
block|,
name|FALSE
block|}
block|,
block|{
literal|"GPSDifferential"
block|,
name|XMP_TYPE_INTEGER
block|,
name|FALSE
block|}
block|,
comment|/* 0-1 */
block|{
name|NULL
block|,
name|XMP_TYPE_UNKNOWN
block|,
name|FALSE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|xmp_schemas
specifier|static
name|XMPSchema
name|xmp_schemas
index|[]
init|=
block|{
comment|/* XMP schemas defined as of January 2004 */
block|{
literal|"http://purl.org/dc/elements/1.1/"
block|,
literal|"dc"
block|,
literal|"Dublin Core"
block|,
name|dc_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/"
block|,
literal|"xmp"
block|,
literal|"XMP Basic"
block|,
name|xmp_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/rights/"
block|,
literal|"xmpRights"
block|,
literal|"XMP Rights Management"
block|,
name|xmprights_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/mm/"
block|,
literal|"xmpMM"
block|,
literal|"XMP Media Management"
block|,
name|xmpmm_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/bj/"
block|,
literal|"xmpBJ"
block|,
literal|"XMP Basic Job Ticket"
block|,
name|xmpbj_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/t/pg/"
block|,
literal|"xmpTPg"
block|,
literal|"XMP Paged-Text"
block|,
name|xmptpg_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/pdf/1.3/"
block|,
literal|"pdf"
block|,
literal|"Adobe PDF"
block|,
name|pdf_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/photoshop/1.0/"
block|,
literal|"photoshop"
block|,
literal|"Photoshop"
block|,
name|photoshop_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/tiff/1.0/"
block|,
literal|"tiff"
block|,
literal|"EXIF (TIFF Properties)"
block|,
name|tiff_properties
block|}
block|,
block|{
literal|"http://ns.adobe.com/exif/1.0/"
block|,
literal|"exif"
block|,
literal|"EXIF (EXIF-specific Properties)"
block|,
name|exif_properties
block|}
block|,
comment|/* XMP sub-types */
block|{
literal|"http://ns.adobe.com/xmp/Identifier/qual/1.0/"
block|,
literal|"xmpidq"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/g/img/"
block|,
literal|"xapGImg"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/sType/Dimensions#"
block|,
literal|"stDim"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#"
block|,
literal|"stEvt"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/sType/ResourceRef#"
block|,
literal|"stRef"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/sType/Version#"
block|,
literal|"stVer"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/xap/1.0/sType/Job#"
block|,
literal|"stJob"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* other useful namespaces */
block|{
literal|"http://web.resource.org/cc/"
block|,
literal|"cc"
block|,
literal|"Creative Commons"
block|,
name|NULL
block|}
block|,
block|{
literal|"http://ns.adobe.com/iX/1.0/"
block|,
literal|"iX"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * xmp_model_new:  *  * Return value: a new #XMPModel.  **/
end_comment

begin_function
name|XMPModel
modifier|*
DECL|function|xmp_model_new (void)
name|xmp_model_new
parameter_list|(
name|void
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
decl_stmt|;
name|xmp_model
operator|=
name|g_new
argument_list|(
name|XMPModel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* columns defined by the XMPModelColumns enum */
name|xmp_model
operator|->
name|treestore
operator|=
name|gtk_tree_store_new
argument_list|(
name|XMP_MODEL_NUM_COLUMNS
argument_list|,
name|G_TYPE_STRING
argument_list|,
comment|/* name */
name|G_TYPE_STRING
argument_list|,
comment|/* value as string (for viewing) */
name|G_TYPE_POINTER
argument_list|,
comment|/* value as array (from parser) */
name|G_TYPE_POINTER
argument_list|,
comment|/* XMPProperty or XMPSchema */
name|G_TYPE_POINTER
argument_list|,
comment|/* GtkWidget cross-reference */
name|G_TYPE_INT
argument_list|,
comment|/* editable? */
name|GDK_TYPE_PIXBUF
argument_list|,
comment|/* edit icon */
name|G_TYPE_BOOLEAN
argument_list|,
comment|/* visible? */
name|G_TYPE_INT
argument_list|,
comment|/* font weight */
name|G_TYPE_BOOLEAN
comment|/* font weight set? */
argument_list|)
expr_stmt|;
name|xmp_model
operator|->
name|custom_schemas
operator|=
name|NULL
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|NULL
expr_stmt|;
name|xmp_model
operator|->
name|current_schema
operator|=
name|NULL
expr_stmt|;
return|return
name|xmp_model
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_free:  * @xmp_model: an #XMPModel  *  * Frees an #XMPModel.  **/
end_comment

begin_function
name|void
DECL|function|xmp_model_free (XMPModel * xmp_model)
name|xmp_model_free
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|)
block|{
name|GtkTreeModel
modifier|*
name|model
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|GtkTreeIter
name|child
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|value_array
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* we used XMP_FLAG_DEFER_VALUE_FREE for the parser, so now we must free      all value arrays */
name|model
operator|=
name|xmp_model_get_tree_model
argument_list|(
name|xmp_model
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtk_tree_model_get_iter_first
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|model
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
name|gtk_tree_model_iter_children
argument_list|(
name|model
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
do|do
block|{
name|gtk_tree_model_get
argument_list|(
name|model
argument_list|,
operator|&
name|child
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
operator|&
name|value_array
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: this does not free everything */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value_array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|g_free
argument_list|(
name|value_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|value_array
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|model
argument_list|,
operator|&
name|child
argument_list|)
condition|)
do|;
block|}
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|model
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
do|;
block|}
name|g_object_unref
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
expr_stmt|;
comment|/* FIXME: free custom schemas */
name|g_free
argument_list|(
name|xmp_model
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_is_empty:  * @xmp_model: an #XMPModel  *  * Return value: %TRUE if @xmp_model is empty (no shemas, no properties)  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_is_empty (XMPModel * xmp_model)
name|xmp_model_is_empty
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|)
block|{
name|GtkTreeIter
name|iter
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xmp_model
operator|->
name|custom_schemas
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|xmp_model
operator|->
name|custom_properties
operator|!=
name|NULL
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|!
name|gtk_tree_model_get_iter_first
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|iter
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* check if the given schema_uri matches a known schema; else return NULL */
end_comment

begin_function
specifier|static
name|XMPSchema
modifier|*
DECL|function|find_xmp_schema (XMPModel * xmp_model,const gchar * schema_uri)
name|find_xmp_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|schema_uri
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
comment|/* check if we know about this schema (exact match for URI) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|,
name|schema_uri
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
if|if
condition|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s \t[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"*** \t[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
comment|/* try again but accept "http:" without "//", or missing "http://" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|g_str_has_prefix
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|,
literal|"http://"
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|+
literal|7
argument_list|,
name|schema_uri
argument_list|)
operator|)
operator|||
operator|(
name|g_str_has_prefix
argument_list|(
name|schema_uri
argument_list|,
literal|"http:"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|+
literal|7
argument_list|,
name|schema_uri
operator|+
literal|5
argument_list|)
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"%s \t~~~[%s]\n"
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
comment|/* this is not a standard shema; now check the custom schemas */
for|for
control|(
name|list
operator|=
name|xmp_model
operator|->
name|custom_schemas
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|uri
argument_list|,
name|schema_uri
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"CUSTOM %s \t[%s]\n"
argument_list|,
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"Unknown schema URI %s\n"
argument_list|,
name|schema_uri
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* check if the given prefix matches a known schema; else return NULL */
end_comment

begin_function
specifier|static
name|XMPSchema
modifier|*
DECL|function|find_xmp_schema_prefix (XMPModel * xmp_model,const gchar * prefix)
name|find_xmp_schema_prefix
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|GSList
modifier|*
name|list
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|uri
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xmp_schemas
index|[
name|i
index|]
operator|.
name|prefix
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
operator|&
operator|(
name|xmp_schemas
index|[
name|i
index|]
operator|)
return|;
for|for
control|(
name|list
operator|=
name|xmp_model
operator|->
name|custom_schemas
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
operator|)
operator|->
name|prefix
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
operator|(
name|XMPSchema
operator|*
operator|)
operator|(
name|list
operator|->
name|data
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* make the next lookup a bit faster if the tree is not modified */
end_comment

begin_function
specifier|static
name|void
DECL|function|save_iter_for_schema (XMPModel * xmp_model,XMPSchema * schema,GtkTreeIter * iter)
name|save_iter_for_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPSchema
modifier|*
name|schema
parameter_list|,
name|GtkTreeIter
modifier|*
name|iter
parameter_list|)
block|{
name|xmp_model
operator|->
name|current_schema
operator|=
name|schema
expr_stmt|;
if|if
condition|(
name|iter
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
operator|&
operator|(
name|xmp_model
operator|->
name|current_schema_iter
operator|)
argument_list|,
name|iter
argument_list|,
sizeof|sizeof
argument_list|(
name|GtkTreeIter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find the GtkTreeIter for the given schema and return TRUE if the schema was    found in the tree; else return FALSE */
end_comment

begin_function
specifier|static
name|gboolean
DECL|function|find_iter_for_schema (XMPModel * xmp_model,XMPSchema * schema,GtkTreeIter * iter)
name|find_iter_for_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPSchema
modifier|*
name|schema
parameter_list|,
name|GtkTreeIter
modifier|*
name|iter
parameter_list|)
block|{
name|XMPSchema
modifier|*
name|schema_xref
decl_stmt|;
if|if
condition|(
name|schema
operator|==
name|xmp_model
operator|->
name|current_schema
condition|)
block|{
name|memcpy
argument_list|(
name|iter
argument_list|,
operator|&
operator|(
name|xmp_model
operator|->
name|current_schema_iter
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|GtkTreeIter
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* check where this schema has been stored in the tree */
if|if
condition|(
operator|!
name|gtk_tree_model_get_iter_first
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
name|iter
argument_list|)
condition|)
return|return
name|FALSE
return|;
do|do
block|{
name|gtk_tree_model_get
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
name|iter
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
operator|&
name|schema_xref
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema_xref
operator|==
name|schema
condition|)
block|{
name|save_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
name|iter
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
name|iter
argument_list|)
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* remove a property from the list of children of schema_iter */
end_comment

begin_function
specifier|static
name|void
DECL|function|find_and_remove_property (XMPModel * xmp_model,XMPProperty * property,GtkTreeIter * schema_iter)
name|find_and_remove_property
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPProperty
modifier|*
name|property
parameter_list|,
name|GtkTreeIter
modifier|*
name|schema_iter
parameter_list|)
block|{
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|XMPProperty
modifier|*
name|property_xref
decl_stmt|;
if|if
condition|(
operator|!
name|gtk_tree_model_iter_children
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
name|schema_iter
argument_list|)
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|gtk_tree_model_get
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
operator|&
name|property_xref
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|property_xref
operator|==
name|property
condition|)
block|{
if|if
condition|(
operator|!
name|gtk_tree_store_remove
argument_list|(
name|GTK_TREE_STORE
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|gtk_tree_model_iter_next
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* add a schema to the tree */
end_comment

begin_function
specifier|static
name|void
DECL|function|add_known_schema (XMPModel * xmp_model,XMPSchema * schema,GtkTreeIter * iter)
name|add_known_schema
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
name|XMPSchema
modifier|*
name|schema
parameter_list|,
name|GtkTreeIter
modifier|*
name|iter
parameter_list|)
block|{
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
name|iter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
name|iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|schema
operator|->
name|name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|schema
operator|->
name|uri
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|schema
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|FALSE
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|FALSE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_BOLD
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|TRUE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|save_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
name|iter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called by the XMP parser - new schema */
end_comment

begin_function
specifier|static
name|gpointer
DECL|function|parse_start_schema (XMPParseContext * context,const gchar * ns_uri,const gchar * ns_prefix,gpointer user_data,GError ** error)
name|parse_start_schema
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|ns_uri
parameter_list|,
specifier|const
name|gchar
modifier|*
name|ns_prefix
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
init|=
name|user_data
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|XMPSchema
modifier|*
name|schema
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|schema
operator|=
name|find_xmp_schema
argument_list|(
name|xmp_model
argument_list|,
name|ns_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
name|NULL
condition|)
block|{
comment|/* add schema to custom_schemas */
name|schema
operator|=
name|g_new
argument_list|(
name|XMPSchema
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|schema
operator|->
name|uri
operator|=
name|g_strdup
argument_list|(
name|ns_uri
argument_list|)
expr_stmt|;
name|schema
operator|->
name|prefix
operator|=
name|g_strdup
argument_list|(
name|ns_prefix
argument_list|)
expr_stmt|;
name|schema
operator|->
name|name
operator|=
name|schema
operator|->
name|uri
expr_stmt|;
name|schema
operator|->
name|properties
operator|=
name|NULL
expr_stmt|;
name|xmp_model
operator|->
name|custom_schemas
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_schemas
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
comment|/* already in the tree, so no need to add it again */
return|return
name|schema
return|;
block|}
comment|/* schemas with NULL names are special and should not go in the tree */
if|if
condition|(
name|schema
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|save_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|schema
return|;
block|}
comment|/* if the schema is not in the tree yet, add it now */
name|add_known_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
return|return
name|schema
return|;
block|}
end_function

begin_comment
comment|/* called by the XMP parser - end of schema */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_end_schema (XMPParseContext * context,gpointer ns_user_data,gpointer user_data,GError ** error)
name|parse_end_schema
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|gpointer
name|ns_user_data
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
init|=
name|user_data
decl_stmt|;
name|XMPSchema
modifier|*
name|schema
init|=
name|ns_user_data
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|schema
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xmp_model
operator|->
name|current_schema
operator|=
name|NULL
expr_stmt|;
comment|/* printf ("End of %s\n", schema->name); */
block|}
end_function

begin_comment
comment|/* called by the XMP parser - new property */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_set_property (XMPParseContext * context,const gchar * name,XMPParseType type,const gchar ** value,gpointer ns_user_data,gpointer user_data,GError ** error)
name|parse_set_property
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
specifier|const
name|gchar
modifier|*
name|name
parameter_list|,
name|XMPParseType
name|type
parameter_list|,
specifier|const
name|gchar
modifier|*
modifier|*
name|value
parameter_list|,
name|gpointer
name|ns_user_data
parameter_list|,
name|gpointer
name|user_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPModel
modifier|*
name|xmp_model
init|=
name|user_data
decl_stmt|;
name|XMPSchema
modifier|*
name|schema
init|=
name|ns_user_data
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|ns_prefix
decl_stmt|;
name|XMPProperty
modifier|*
name|property
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|gchar
modifier|*
name|tmp_name
decl_stmt|;
name|gchar
modifier|*
name|tmp_value
decl_stmt|;
name|g_return_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g_return_if_fail
argument_list|(
name|schema
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"Unable to set XMP property '%s' because its schema is bad"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns_prefix
operator|=
name|schema
operator|->
name|prefix
expr_stmt|;
name|property
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|schema
operator|->
name|properties
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|property
operator|=
operator|&
operator|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
comment|/* if the same property was already present, remove it (replace it) */
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
name|find_and_remove_property
argument_list|(
name|xmp_model
argument_list|,
name|property
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|XMP_PTYPE_TEXT
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"\t%s:%s = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_TEXT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_RESOURCE
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"\t%s:%s @ = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_URI
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" @"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_ORDERED_LIST
case|:
case|case
name|XMP_PTYPE_UNORDERED_LIST
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"\t%s:%s [] ="
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" \"%s\""
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", \"%s\""
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
operator|(
operator|(
name|type
operator|==
name|XMP_PTYPE_ORDERED_LIST
operator|)
condition|?
name|XMP_TYPE_TEXT_BAG
else|:
name|XMP_TYPE_TEXT_SEQ
operator|)
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" []"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp_value
operator|=
name|g_strjoinv
argument_list|(
literal|"; "
argument_list|,
operator|(
name|gchar
operator|*
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|tmp_value
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_value
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMP_PTYPE_ALT_LANG
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"\t%s:%s [lang:%s] = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_LANG_ALT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" ["
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
literal|"]"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XMP_PTYPE_STRUCTURE
case|:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
for|for
control|(
name|i
operator|=
literal|2
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"\t%s:%s [%s] = \"%s\"\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
comment|/* FIXME */
empty_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_UNKNOWN
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|tmp_name
operator|=
name|g_strconcat
argument_list|(
name|name
argument_list|,
literal|" ["
argument_list|,
name|value
index|[
name|i
index|]
argument_list|,
literal|"]"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|tmp_name
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG_XMP_PARSER
name|printf
argument_list|(
literal|"\t%s:%s = ?\n"
argument_list|,
name|ns_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called by the XMP parser - parse error */
end_comment

begin_function
specifier|static
name|void
DECL|function|parse_error (XMPParseContext * context,GError * error,gpointer user_data)
name|parse_error
parameter_list|(
name|XMPParseContext
modifier|*
name|context
parameter_list|,
name|GError
modifier|*
name|error
parameter_list|,
name|gpointer
name|user_data
parameter_list|)
block|{
name|g_warning
argument_list|(
literal|"While parsing XMP metadata:\n%s\n"
argument_list|,
name|error
operator|->
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
DECL|variable|xmp_parser
specifier|static
name|XMPParser
name|xmp_parser
init|=
block|{
name|parse_start_schema
block|,
name|parse_end_schema
block|,
name|parse_set_property
block|,
name|parse_error
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * xmp_model_parse_buffer:  * @xmp_model: pointer to the #XMPModel in which the results will be stored  * @buffer: buffer to be parsed  * @buffer_length: length of the @buffer  * @skip_other_data: if %TRUE, allow arbitrary data before XMP packet marker  * @error: return location for a #GError  *  * Parse a buffer containing XMP metadata and merge the parsed contents into  * the supplied @xmp_model.  If @skip_other_data is %TRUE, then the parser  * will try to find the<?xpacket...?> marker in the buffer, skipping any  * unknown data found before it.  *  * Return value: %TRUE on success, %FALSE if an error was set  *  * (Note: this calls the functions from xmp_parse.c, which will call the  *  functions in this file through the xmp_parser structure defined above.)  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_parse_buffer (XMPModel * xmp_model,const gchar * buffer,gssize buffer_length,gboolean skip_other_data,GError ** error)
name|xmp_model_parse_buffer
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|buffer
parameter_list|,
name|gssize
name|buffer_length
parameter_list|,
name|gboolean
name|skip_other_data
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|XMPParseFlags
name|flags
decl_stmt|;
name|XMPParseContext
modifier|*
name|context
decl_stmt|;
name|flags
operator|=
name|XMP_FLAG_DEFER_VALUE_FREE
expr_stmt|;
comment|/* we will free the array ourselves */
if|if
condition|(
name|skip_other_data
condition|)
name|flags
operator||=
name|XMP_FLAG_FIND_XPACKET
expr_stmt|;
name|context
operator|=
name|xmp_parse_context_new
argument_list|(
operator|&
name|xmp_parser
argument_list|,
name|flags
argument_list|,
name|xmp_model
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xmp_parse_context_parse
argument_list|(
name|context
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|xmp_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|xmp_parse_context_end_parse
argument_list|(
name|context
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|xmp_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xmp_parse_context_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_parse_file:  * @xmp_model: pointer to the #XMPModel in which the results will be stored  * @filename: name of the file containing XMP metadata to parse  * @error: return location for a #GError   *  * Try to find XMP metadata in a file and merge its contents into the supplied  * @xmp_model.  *  * Return value: %TRUE on success, %FALSE if an error was set  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_parse_file (XMPModel * xmp_model,const gchar * filename,GError ** error)
name|xmp_model_parse_file
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|filename
parameter_list|,
name|GError
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|gchar
modifier|*
name|buffer
decl_stmt|;
name|guint
name|buffer_length
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_file_get_contents
argument_list|(
name|filename
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|buffer_length
argument_list|,
name|error
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|xmp_model_parse_buffer
argument_list|(
name|xmp_model
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
name|TRUE
argument_list|,
name|error
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_get_tree_model:  * @xmp_model: pointer to an #XMPModel  *  * Return a pointer to the #GtkTreeModel contained in the #XMPModel.  **/
end_comment

begin_function
name|GtkTreeModel
modifier|*
DECL|function|xmp_model_get_tree_model (XMPModel * xmp_model)
name|xmp_model_get_tree_model
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|)
block|{
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_get_scalar_property:  * @xmp_model: pointer to an #XMPModel  * @schema_name: full URI or usual prefix of the schema  * @property_name: name of the property to store  *  * Store a new value for the specified XMP property.  *  * Return value: string representation of the value of that property, or %NULL if the property does not exist  **/
end_comment

begin_function
specifier|const
name|gchar
modifier|*
DECL|function|xmp_model_get_scalar_property (XMPModel * xmp_model,const gchar * schema_name,const gchar * property_name)
name|xmp_model_get_scalar_property
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|schema_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|property_name
parameter_list|)
block|{
name|XMPSchema
modifier|*
name|schema
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|XMPProperty
modifier|*
name|property
init|=
name|NULL
decl_stmt|;
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|XMPProperty
modifier|*
name|property_xref
decl_stmt|;
specifier|const
name|gchar
modifier|*
name|value
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|schema_name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|property_name
operator|!=
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|schema
operator|=
name|find_xmp_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
name|schema
operator|=
name|find_xmp_schema_prefix
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|schema
operator|->
name|properties
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|property_name
argument_list|)
condition|)
block|{
name|property
operator|=
operator|&
operator|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|property
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|gtk_tree_model_iter_children
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL
return|;
do|do
block|{
name|gtk_tree_model_get
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
operator|&
name|property_xref
argument_list|,
name|COL_XMP_VALUE
argument_list|,
operator|&
name|value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|property_xref
operator|==
name|property
condition|)
return|return
name|value
return|;
block|}
do|while
condition|(
name|gtk_tree_model_iter_next
argument_list|(
name|GTK_TREE_MODEL
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|)
argument_list|,
operator|&
name|child_iter
argument_list|)
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * xmp_model_set_scalar_property:  * @xmp_model: pointer to an #XMPModel  * @schema_name: full URI or usual prefix of the schema  * @property_name: name of the property to store  * @property_value: value to store  *  * Store a new value for the specified XMP property.  *  * Return value: %TRUE if the property was set, %FALSE if an error occured (for example, the @schema_name is invalid)  **/
end_comment

begin_function
name|gboolean
DECL|function|xmp_model_set_scalar_property (XMPModel * xmp_model,const gchar * schema_name,const gchar * property_name,const gchar * property_value)
name|xmp_model_set_scalar_property
parameter_list|(
name|XMPModel
modifier|*
name|xmp_model
parameter_list|,
specifier|const
name|gchar
modifier|*
name|schema_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|property_name
parameter_list|,
specifier|const
name|gchar
modifier|*
name|property_value
parameter_list|)
block|{
name|XMPSchema
modifier|*
name|schema
decl_stmt|;
name|GtkTreeIter
name|iter
decl_stmt|;
name|XMPProperty
modifier|*
name|property
init|=
name|NULL
decl_stmt|;
name|GtkTreeIter
name|child_iter
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|value
decl_stmt|;
name|g_return_val_if_fail
argument_list|(
name|xmp_model
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|schema_name
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|property_name
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g_return_val_if_fail
argument_list|(
name|property_value
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|schema
operator|=
name|find_xmp_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
name|schema
operator|=
name|find_xmp_schema_prefix
argument_list|(
name|xmp_model
argument_list|,
name|schema_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|schema
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|find_iter_for_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
name|add_known_schema
argument_list|(
name|xmp_model
argument_list|,
name|schema
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|->
name|properties
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|property_name
argument_list|)
condition|)
block|{
name|property
operator|=
operator|&
operator|(
name|schema
operator|->
name|properties
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|property
operator|!=
name|NULL
condition|)
name|find_and_remove_property
argument_list|(
name|xmp_model
argument_list|,
name|property
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
else|else
block|{
name|property
operator|=
name|g_new
argument_list|(
name|XMPProperty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property
operator|->
name|name
operator|=
name|g_strdup
argument_list|(
name|property_name
argument_list|)
expr_stmt|;
name|property
operator|->
name|type
operator|=
name|XMP_TYPE_TEXT
expr_stmt|;
name|property
operator|->
name|editable
operator|=
name|TRUE
expr_stmt|;
name|xmp_model
operator|->
name|custom_properties
operator|=
name|g_slist_prepend
argument_list|(
name|xmp_model
operator|->
name|custom_properties
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|value
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
name|property_value
argument_list|)
expr_stmt|;
name|value
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|gtk_tree_store_append
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|gtk_tree_store_set
argument_list|(
name|xmp_model
operator|->
name|treestore
argument_list|,
operator|&
name|child_iter
argument_list|,
name|COL_XMP_NAME
argument_list|,
name|g_strdup
argument_list|(
name|property_name
argument_list|)
argument_list|,
name|COL_XMP_VALUE
argument_list|,
name|value
index|[
literal|0
index|]
argument_list|,
name|COL_XMP_VALUE_RAW
argument_list|,
name|value
argument_list|,
name|COL_XMP_TYPE_XREF
argument_list|,
name|property
argument_list|,
name|COL_XMP_WIDGET_XREF
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_EDITABLE
argument_list|,
name|property
operator|->
name|editable
argument_list|,
name|COL_XMP_EDIT_ICON
argument_list|,
name|NULL
argument_list|,
name|COL_XMP_VISIBLE
argument_list|,
name|TRUE
argument_list|,
name|COL_XMP_WEIGHT
argument_list|,
name|PANGO_WEIGHT_NORMAL
argument_list|,
name|COL_XMP_WEIGHT_SET
argument_list|,
name|FALSE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

