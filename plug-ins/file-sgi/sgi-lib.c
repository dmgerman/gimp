begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SGI image file format library routines.  *  * Copyright 1997-1998 Michael Sweet (mike@easysw.com)  *  * This program is free software: you can redistribute it and/or modify it  * under the terms of the GNU General Public License as published by the Free  * Software Foundation; either version 3 of the License, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  * for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  *  * Contents:  *  *   sgiClose()    - Close an SGI image file.  *   sgiGetRow()   - Get a row of image data from a file.  *   sgiOpen()     - Open an SGI image file for reading or writing.  *   sgiOpenFile() - Open an SGI image file for reading or writing.  *   sgiPutRow()   - Put a row of image data to a file.  *   getlong()     - Get a 32-bit big-endian integer.  *   getshort()    - Get a 16-bit big-endian integer.  *   putlong()     - Put a 32-bit big-endian integer.  *   putshort()    - Put a 16-bit big-endian integer.  *   read_rle8()   - Read 8-bit RLE data.  *   read_rle16()  - Read 16-bit RLE data.  *   write_rle8()  - Write 8-bit RLE data.  *   write_rle16() - Write 16-bit RLE data.  *  * Revision History:  *  *   $Log$  *   Revision 1.9  2005/03/04 13:23:31  neo  *   2005-03-04  Sven Neumann<sven@gimp.org>  *  *   	* plug-ins/FractalExplorer  *   	* plug-ins/Lighting  *   	* plug-ins/bmp  *   	* plug-ins/dbbrowser  *   	* plug-ins/faxg3  *   	* plug-ins/fits  *   	* plug-ins/flame  *   	* plug-ins/gfig  *   	* plug-ins/gflare  *   	* plug-ins/gfli  *   	* plug-ins/gimpressionist  *   	* plug-ins/ifscompose  *   	* plug-ins/jpeg  *   	* plug-ins/maze  *   	* plug-ins/pagecurl  *   	* plug-ins/print  *   	* plug-ins/rcm  *   	* plug-ins/script-fu  *   	* plug-ins/sel2path  *   	* plug-ins/sgi  *   	* plug-ins/twain  *   	* plug-ins/winicon  *   	* plug-ins/xjt: ported to gstdio, removed unnecessary includes,  *   	minor fixes to filename handling here and there.  *  *   Revision 1.8  2003/04/07 11:59:33  neo  *   2003-04-07  Sven Neumann<sven@gimp.org>  *  *   	* plug-ins/sgi/sgi.h  *   	* plug-ins/sgi/sgilib.c: applied a patch from marek@aki.cz that  *   	adds support for reading SGI files in little-endian format. Fixes  *   	bug #106610.  *  *   Revision 1.7  1998/06/06 23:22:21  yosh  *   * adding Lighting plugin  *  *   * updated despeckle, png, sgi, and sharpen  *  *   -Yosh  *  *   Revision 1.5  1998/04/23  17:40:49  mike  *   Updated to support 16-bit<unsigned> image data.  *  *   Revision 1.4  1998/02/05  17:10:58  mike  *   Added sgiOpenFile() function for opening an existing file pointer.  *  *   Revision 1.3  1997/07/02  16:40:16  mike  *   sgiOpen() wasn't opening files with "rb" or "wb+".  This caused problems  *   on PCs running Windows/DOS...  *  *   Revision 1.2  1997/06/18  00:55:28  mike  *   Updated to hold length table when writing.  *   Updated to hold current length when doing ARLE.  *   Wasn't writing length table on close.  *   Wasn't saving new line into arle_row when necessary.  *  *   Revision 1.1  1997/06/15  03:37:19  mike  *   Initial revision  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<glib.h>
end_include

begin_include
include|#
directive|include
file|<glib/gstdio.h>
end_include

begin_include
include|#
directive|include
file|"sgi-lib.h"
end_include

begin_comment
comment|/*  * Local functions...  */
end_comment

begin_function_decl
specifier|static
name|int
name|getlong
parameter_list|(
name|sgi_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getshort
parameter_list|(
name|sgi_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putlong
parameter_list|(
name|long
parameter_list|,
name|sgi_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putshort
parameter_list|(
name|unsigned
name|short
parameter_list|,
name|sgi_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_rle8
parameter_list|(
name|sgi_t
modifier|*
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_rle16
parameter_list|(
name|sgi_t
modifier|*
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_rle8
parameter_list|(
name|sgi_t
modifier|*
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_rle16
parameter_list|(
name|sgi_t
modifier|*
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * 'sgiClose()' - Close an SGI image file.  */
end_comment

begin_function
name|int
DECL|function|sgiClose (sgi_t * sgip)
name|sgiClose
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|)
comment|/* I - SGI image */
block|{
name|int
name|i
decl_stmt|;
comment|/* Return status */
name|long
modifier|*
name|offset
decl_stmt|;
comment|/* Looping var for offset table */
if|if
condition|(
name|sgip
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sgip
operator|->
name|mode
operator|==
name|SGI_WRITE
operator|&&
name|sgip
operator|->
name|comp
operator|!=
name|SGI_COMP_NONE
condition|)
block|{
comment|/*     * Write the scanline offset table to the file...     */
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
literal|512
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
operator|,
name|offset
operator|=
name|sgip
operator|->
name|table
index|[
literal|0
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|offset
operator|++
control|)
if|if
condition|(
name|putlong
argument_list|(
name|offset
index|[
literal|0
index|]
argument_list|,
name|sgip
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
operator|,
name|offset
operator|=
name|sgip
operator|->
name|length
index|[
literal|0
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|offset
operator|++
control|)
if|if
condition|(
name|putlong
argument_list|(
name|offset
index|[
literal|0
index|]
argument_list|,
name|sgip
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
name|sgip
operator|->
name|table
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
operator|->
name|table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sgip
operator|->
name|length
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sgip
operator|->
name|length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sgip
operator|->
name|comp
operator|==
name|SGI_COMP_ARLE
condition|)
name|free
argument_list|(
name|sgip
operator|->
name|arle_row
argument_list|)
expr_stmt|;
name|i
operator|=
name|fclose
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiGetRow()' - Get a row of image data from a file.  */
end_comment

begin_function
name|int
DECL|function|sgiGetRow (sgi_t * sgip,unsigned short * row,int y,int z)
name|sgiGetRow
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image */
name|unsigned
name|short
modifier|*
name|row
parameter_list|,
comment|/* O - Row to read */
name|int
name|y
parameter_list|,
comment|/* I - Line to read */
name|int
name|z
parameter_list|)
comment|/* I - Channel to read */
block|{
name|int
name|x
decl_stmt|;
comment|/* X coordinate */
name|long
name|offset
decl_stmt|;
comment|/* File offset */
if|if
condition|(
name|sgip
operator|==
name|NULL
operator|||
name|row
operator|==
name|NULL
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|sgip
operator|->
name|ysize
operator|||
name|z
operator|<
literal|0
operator|||
name|z
operator|>=
name|sgip
operator|->
name|zsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|sgip
operator|->
name|comp
condition|)
block|{
case|case
name|SGI_COMP_NONE
case|:
comment|/*         * Seek to the image row - optimize buffering by only seeking if         * necessary...         */
name|offset
operator|=
literal|512
operator|+
operator|(
name|y
operator|+
name|z
operator|*
name|sgip
operator|->
name|ysize
operator|)
operator|*
name|sgip
operator|->
name|xsize
operator|*
name|sgip
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
operator|*
name|row
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
operator|*
name|row
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_COMP_RLE
case|:
name|offset
operator|=
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
return|return
operator|(
name|read_rle8
argument_list|(
name|sgip
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|read_rle16
argument_list|(
name|sgip
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
return|;
break|break;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiOpen()' - Open an SGI image file for reading or writing.  */
end_comment

begin_function
name|sgi_t
modifier|*
DECL|function|sgiOpen (const char * filename,int mode,int comp,int bpp,int xsize,int ysize,int zsize)
name|sgiOpen
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
comment|/* I - File to open */
name|int
name|mode
parameter_list|,
comment|/* I - Open mode (SGI_READ or SGI_WRITE) */
name|int
name|comp
parameter_list|,
comment|/* I - Type of compression */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes per pixel */
name|int
name|xsize
parameter_list|,
comment|/* I - Width of image in pixels */
name|int
name|ysize
parameter_list|,
comment|/* I - Height of image in pixels */
name|int
name|zsize
parameter_list|)
comment|/* I - Number of channels */
block|{
name|sgi_t
modifier|*
name|sgip
decl_stmt|;
comment|/* New SGI image file */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* Image file pointer */
if|if
condition|(
name|mode
operator|==
name|SGI_READ
condition|)
name|file
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
else|else
name|file
operator|=
name|g_fopen
argument_list|(
name|filename
argument_list|,
literal|"wb+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|sgip
operator|=
name|sgiOpenFile
argument_list|(
name|file
argument_list|,
name|mode
argument_list|,
name|comp
argument_list|,
name|bpp
argument_list|,
name|xsize
argument_list|,
name|ysize
argument_list|,
name|zsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|sgip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiOpenFile()' - Open an SGI image file for reading or writing.  */
end_comment

begin_function
name|sgi_t
modifier|*
DECL|function|sgiOpenFile (FILE * file,int mode,int comp,int bpp,int xsize,int ysize,int zsize)
name|sgiOpenFile
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
comment|/* I - File to open */
name|int
name|mode
parameter_list|,
comment|/* I - Open mode (SGI_READ or SGI_WRITE) */
name|int
name|comp
parameter_list|,
comment|/* I - Type of compression */
name|int
name|bpp
parameter_list|,
comment|/* I - Bytes per pixel */
name|int
name|xsize
parameter_list|,
comment|/* I - Width of image in pixels */
name|int
name|ysize
parameter_list|,
comment|/* I - Height of image in pixels */
name|int
name|zsize
parameter_list|)
comment|/* I - Number of channels */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Looping var */
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
comment|/* Name of file in image header */
name|short
name|magic
decl_stmt|;
comment|/* Magic number */
name|sgi_t
modifier|*
name|sgip
decl_stmt|;
comment|/* New image pointer */
if|if
condition|(
operator|(
name|sgip
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sgi_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sgip
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|sgip
operator|->
name|swapBytes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SGI_READ
case|:
name|sgip
operator|->
name|mode
operator|=
name|SGI_READ
expr_stmt|;
name|magic
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|SGI_MAGIC
condition|)
block|{
comment|/* try little endian format */
name|magic
operator|=
operator|(
operator|(
name|magic
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|(
operator|(
name|magic
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|SGI_MAGIC
condition|)
block|{
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|sgip
operator|->
name|swapBytes
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sgip
operator|->
name|comp
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|bpp
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
comment|/* Dimensions */
name|sgip
operator|->
name|xsize
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|ysize
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|zsize
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
name|getlong
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
comment|/* Minimum pixel */
name|getlong
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
comment|/* Maximum pixel */
if|if
condition|(
name|sgip
operator|->
name|comp
condition|)
block|{
comment|/*           * This file is compressed; read the scanline tables...           */
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
literal|512
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
name|sgip
operator|->
name|table
index|[
name|i
index|]
operator|=
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|sgip
operator|->
name|ysize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sgip
operator|->
name|ysize
condition|;
name|j
operator|++
control|)
name|sgip
operator|->
name|table
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|getlong
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_WRITE
case|:
if|if
condition|(
name|xsize
operator|<
literal|1
operator|||
name|ysize
operator|<
literal|1
operator|||
name|zsize
operator|<
literal|1
operator|||
name|bpp
operator|<
literal|1
operator|||
name|bpp
operator|>
literal|2
operator|||
name|comp
operator|<
name|SGI_COMP_NONE
operator|||
name|comp
operator|>
name|SGI_COMP_ARLE
condition|)
block|{
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
name|sgip
operator|->
name|mode
operator|=
name|SGI_WRITE
expr_stmt|;
name|putshort
argument_list|(
name|SGI_MAGIC
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|sgip
operator|->
name|comp
operator|=
name|comp
operator|)
operator|!=
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|sgip
operator|->
name|bpp
operator|=
name|bpp
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|putshort
argument_list|(
literal|3
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
comment|/* Dimensions */
name|putshort
argument_list|(
name|sgip
operator|->
name|xsize
operator|=
name|xsize
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
name|putshort
argument_list|(
name|sgip
operator|->
name|ysize
operator|=
name|ysize
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
name|putshort
argument_list|(
name|sgip
operator|->
name|zsize
operator|=
name|zsize
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
comment|/* Minimum pixel */
name|putlong
argument_list|(
literal|255
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
comment|/* Maximum pixel */
block|}
else|else
block|{
name|putlong
argument_list|(
operator|-
literal|32768
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
comment|/* Minimum pixel */
name|putlong
argument_list|(
literal|32767
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
comment|/* Maximum pixel */
block|}
empty_stmt|;
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
comment|/* Reserved */
name|memset
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|102
condition|;
name|i
operator|++
control|)
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp
condition|)
block|{
case|case
name|SGI_COMP_NONE
case|:
comment|/* No compression */
comment|/*               * This file is uncompressed.  To avoid problems with sparse files,               * we need to write blank pixels for the entire image...               */
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|xsize
operator|*
name|ysize
operator|*
name|zsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|putc
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|xsize
operator|*
name|ysize
operator|*
name|zsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|putshort
argument_list|(
literal|0
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_COMP_ARLE
case|:
comment|/* Aggressive RLE */
name|sgip
operator|->
name|arle_row
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|calloc
argument_list|(
name|xsize
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|arle_offset
operator|=
literal|0
expr_stmt|;
case|case
name|SGI_COMP_RLE
case|:
comment|/* Run-Length Encoding */
comment|/*               * This file is compressed; write the (blank) scanline tables...               */
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|ysize
operator|*
name|zsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|putlong
argument_list|(
literal|0
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|firstrow
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|nextrow
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
name|sgip
operator|->
name|table
index|[
name|i
index|]
operator|=
name|sgip
operator|->
name|table
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|sgip
operator|->
name|ysize
expr_stmt|;
name|sgip
operator|->
name|length
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|length
index|[
literal|0
index|]
operator|=
name|calloc
argument_list|(
name|sgip
operator|->
name|ysize
operator|*
name|sgip
operator|->
name|zsize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sgip
operator|->
name|zsize
condition|;
name|i
operator|++
control|)
name|sgip
operator|->
name|length
index|[
name|i
index|]
operator|=
name|sgip
operator|->
name|length
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|sgip
operator|->
name|ysize
expr_stmt|;
break|break;
block|}
empty_stmt|;
break|break;
default|default :
name|free
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|sgip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'sgiPutRow()' - Put a row of image data to a file.  */
end_comment

begin_function
name|int
DECL|function|sgiPutRow (sgi_t * sgip,unsigned short * row,int y,int z)
name|sgiPutRow
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image */
name|unsigned
name|short
modifier|*
name|row
parameter_list|,
comment|/* I - Row to write */
name|int
name|y
parameter_list|,
comment|/* I - Line to write */
name|int
name|z
parameter_list|)
comment|/* I - Channel to write */
block|{
name|int
name|x
decl_stmt|;
comment|/* X coordinate */
name|long
name|offset
decl_stmt|;
comment|/* File offset */
if|if
condition|(
name|sgip
operator|==
name|NULL
operator|||
name|row
operator|==
name|NULL
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|sgip
operator|->
name|ysize
operator|||
name|z
operator|<
literal|0
operator|||
name|z
operator|>=
name|sgip
operator|->
name|zsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|sgip
operator|->
name|comp
condition|)
block|{
case|case
name|SGI_COMP_NONE
case|:
comment|/*         * Seek to the image row - optimize buffering by only seeking if         * necessary...         */
name|offset
operator|=
literal|512
operator|+
operator|(
name|y
operator|+
name|z
operator|*
name|sgip
operator|->
name|ysize
operator|)
operator|*
name|sgip
operator|->
name|xsize
operator|*
name|sgip
operator|->
name|bpp
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
name|putc
argument_list|(
operator|*
name|row
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|sgip
operator|->
name|xsize
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
operator|,
name|row
operator|++
control|)
name|putshort
argument_list|(
operator|*
name|row
argument_list|,
name|sgip
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|SGI_COMP_ARLE
case|:
if|if
condition|(
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*         * First check the last row written...         */
if|if
condition|(
name|sgip
operator|->
name|arle_offset
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|row
index|[
name|x
index|]
operator|!=
name|sgip
operator|->
name|arle_row
index|[
name|x
index|]
condition|)
break|break;
if|if
condition|(
name|x
operator|==
name|sgip
operator|->
name|xsize
condition|)
block|{
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_offset
expr_stmt|;
name|sgip
operator|->
name|length
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*         * If that didn't match, search all the previous rows...         */
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|sgip
operator|->
name|firstrow
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
block|{
do|do
block|{
name|sgip
operator|->
name|arle_offset
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgip
operator|->
name|arle_length
operator|=
name|read_rle8
argument_list|(
name|sgip
argument_list|,
name|sgip
operator|->
name|arle_row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|row
index|[
name|x
index|]
operator|!=
name|sgip
operator|->
name|arle_row
index|[
name|x
index|]
condition|)
break|break;
block|}
do|while
condition|(
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|sgip
operator|->
name|arle_offset
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgip
operator|->
name|arle_length
operator|=
name|read_rle16
argument_list|(
name|sgip
argument_list|,
name|sgip
operator|->
name|arle_row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|row
index|[
name|x
index|]
operator|!=
name|sgip
operator|->
name|arle_row
index|[
name|x
index|]
condition|)
break|break;
block|}
do|while
condition|(
name|x
operator|<
name|sgip
operator|->
name|xsize
condition|)
do|;
block|}
empty_stmt|;
if|if
condition|(
name|x
operator|==
name|sgip
operator|->
name|xsize
condition|)
block|{
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_offset
expr_stmt|;
name|sgip
operator|->
name|length
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|arle_length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/* Clear EOF */
case|case
name|SGI_COMP_RLE
case|:
if|if
condition|(
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|offset
operator|=
name|sgip
operator|->
name|table
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|sgip
operator|->
name|nextrow
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
condition|)
name|fseek
argument_list|(
name|sgip
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|bpp
operator|==
literal|1
condition|)
name|x
operator|=
name|write_rle8
argument_list|(
name|sgip
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|write_rle16
argument_list|(
name|sgip
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|comp
operator|==
name|SGI_COMP_ARLE
condition|)
block|{
name|sgip
operator|->
name|arle_offset
operator|=
name|offset
expr_stmt|;
name|sgip
operator|->
name|arle_length
operator|=
name|x
expr_stmt|;
name|memcpy
argument_list|(
name|sgip
operator|->
name|arle_row
argument_list|,
name|row
argument_list|,
name|sgip
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|sgip
operator|->
name|nextrow
operator|=
name|ftell
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|sgip
operator|->
name|length
index|[
name|z
index|]
index|[
name|y
index|]
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'getlong()' - Get a 32-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|getlong (sgi_t * sgip)
name|getlong
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|)
comment|/* I - SGI image to read from */
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|fread
argument_list|(
name|b
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|swapBytes
condition|)
return|return
operator|(
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|0
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|3
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'getshort()' - Get a 16-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|getshort (sgi_t * sgip)
name|getshort
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|)
comment|/* I - SGI image to read from */
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|fread
argument_list|(
name|b
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgip
operator|->
name|swapBytes
condition|)
return|return
operator|(
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|0
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'putlong()' - Put a 32-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|putlong (long n,sgi_t * sgip)
name|putlong
parameter_list|(
name|long
name|n
parameter_list|,
comment|/* I - Long to write */
name|sgi_t
modifier|*
name|sgip
parameter_list|)
comment|/* I - File to write to */
block|{
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|24
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|16
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'putshort()' - Put a 16-bit big-endian integer.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|putshort (unsigned short n,sgi_t * sgip)
name|putshort
parameter_list|(
name|unsigned
name|short
name|n
parameter_list|,
comment|/* I - Short to write */
name|sgi_t
modifier|*
name|sgip
parameter_list|)
comment|/* I - File to write to */
block|{
if|if
condition|(
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|putc
argument_list|(
name|n
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'read_rle8()' - Read 8-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|read_rle8 (sgi_t * sgip,unsigned short * row,int xsize)
name|read_rle8
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image to read from */
name|unsigned
name|short
modifier|*
name|row
parameter_list|,
comment|/* O - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|i
decl_stmt|,
comment|/* Looping var */
name|ch
decl_stmt|,
comment|/* Current character */
name|count
decl_stmt|,
comment|/* RLE count */
name|length
decl_stmt|;
comment|/* Number of bytes read... */
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|ch
operator|&
literal|127
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ch
operator|&
literal|128
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
operator|,
name|length
operator|++
control|)
operator|*
name|row
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|getc
argument_list|(
name|sgip
operator|->
name|file
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
control|)
operator|*
name|row
operator|=
name|ch
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|xsize
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
name|length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'read_rle16()' - Read 16-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|read_rle16 (sgi_t * sgip,unsigned short * row,int xsize)
name|read_rle16
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image to read from */
name|unsigned
name|short
modifier|*
name|row
parameter_list|,
comment|/* O - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|i
decl_stmt|,
comment|/* Looping var */
name|ch
decl_stmt|,
comment|/* Current character */
name|count
decl_stmt|,
comment|/* RLE count */
name|length
decl_stmt|;
comment|/* Number of bytes read... */
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|ch
operator|&
literal|127
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ch
operator|&
literal|128
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
operator|,
name|length
operator|++
control|)
operator|*
name|row
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|getshort
argument_list|(
name|sgip
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|row
operator|++
operator|,
name|xsize
operator|--
control|)
operator|*
name|row
operator|=
name|ch
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|xsize
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
name|length
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'write_rle8()' - Write 8-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|write_rle8 (sgi_t * sgip,unsigned short * row,int xsize)
name|write_rle8
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image to write to */
name|unsigned
name|short
modifier|*
name|row
parameter_list|,
comment|/* I - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|length
decl_stmt|,
comment|/* Length of output line */
name|count
decl_stmt|,
comment|/* Number of repeated/non-repeated pixels */
name|i
decl_stmt|,
comment|/* Looping var */
name|x
decl_stmt|;
comment|/* Looping var */
name|unsigned
name|short
modifier|*
name|start
decl_stmt|,
comment|/* Start of sequence */
name|repeat
decl_stmt|;
comment|/* Repeated pixel */
for|for
control|(
name|x
operator|=
name|xsize
operator|,
name|length
operator|=
literal|0
init|;
name|x
operator|>
literal|0
condition|;
control|)
block|{
name|start
operator|=
name|row
expr_stmt|;
name|row
operator|+=
literal|2
expr_stmt|;
name|x
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|(
name|row
index|[
operator|-
literal|2
index|]
operator|!=
name|row
index|[
operator|-
literal|1
index|]
operator|||
name|row
index|[
operator|-
literal|1
index|]
operator|!=
name|row
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|row
operator|-=
literal|2
expr_stmt|;
name|x
operator|+=
literal|2
expr_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
literal|128
operator||
name|i
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
operator|*
name|start
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|start
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
break|break;
name|start
operator|=
name|row
expr_stmt|;
name|repeat
operator|=
name|row
index|[
literal|0
index|]
expr_stmt|;
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|*
name|row
operator|==
name|repeat
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|i
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|repeat
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
literal|0
argument_list|,
name|sgip
operator|->
name|file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'write_rle16()' - Write 16-bit RLE data.  */
end_comment

begin_function
specifier|static
name|int
DECL|function|write_rle16 (sgi_t * sgip,unsigned short * row,int xsize)
name|write_rle16
parameter_list|(
name|sgi_t
modifier|*
name|sgip
parameter_list|,
comment|/* I - SGI image to write to */
name|unsigned
name|short
modifier|*
name|row
parameter_list|,
comment|/* I - Data */
name|int
name|xsize
parameter_list|)
comment|/* I - Width of data in pixels */
block|{
name|int
name|length
decl_stmt|,
comment|/* Length of output line */
name|count
decl_stmt|,
comment|/* Number of repeated/non-repeated pixels */
name|i
decl_stmt|,
comment|/* Looping var */
name|x
decl_stmt|;
comment|/* Looping var */
name|unsigned
name|short
modifier|*
name|start
decl_stmt|,
comment|/* Start of sequence */
name|repeat
decl_stmt|;
comment|/* Repeated pixel */
for|for
control|(
name|x
operator|=
name|xsize
operator|,
name|length
operator|=
literal|0
init|;
name|x
operator|>
literal|0
condition|;
control|)
block|{
name|start
operator|=
name|row
expr_stmt|;
name|row
operator|+=
literal|2
expr_stmt|;
name|x
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|(
name|row
index|[
operator|-
literal|2
index|]
operator|!=
name|row
index|[
operator|-
literal|1
index|]
operator|||
name|row
index|[
operator|-
literal|1
index|]
operator|!=
name|row
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|row
operator|-=
literal|2
expr_stmt|;
name|x
operator|+=
literal|2
expr_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
literal|128
operator||
name|i
argument_list|,
name|sgip
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|putshort
argument_list|(
operator|*
name|start
argument_list|,
name|sgip
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|start
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
break|break;
name|start
operator|=
name|row
expr_stmt|;
name|repeat
operator|=
name|row
index|[
literal|0
index|]
expr_stmt|;
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
operator|&&
operator|*
name|row
operator|==
name|repeat
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|x
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|count
operator|=
name|row
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|count
operator|>
literal|126
condition|?
literal|126
else|:
name|count
expr_stmt|;
name|count
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
name|i
argument_list|,
name|sgip
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
name|repeat
argument_list|,
name|sgip
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|length
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|putshort
argument_list|(
literal|0
argument_list|,
name|sgip
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|2
operator|*
name|length
operator|)
return|;
block|}
end_function

end_unit

