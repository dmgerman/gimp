begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GIF loading and saving file filter for The GIMP version 1.0/1.1  *  *    - Adam D. Moss  *    - Peter Mattis  *    - Spencer Kimball  *  *      Based around original GIF code by David Koblas.  *  *  * Version 2.1.1 - 99/01/23  *                        Adam D. Moss -<adam@gimp.org><adam@foxbox.org>  */
end_comment

begin_comment
comment|/*  * This filter uses code taken from the "giftopnm" and "ppmtogif" programs  *    which are part of the "netpbm" package.  */
end_comment

begin_comment
comment|/*  *  "The Graphics Interchange Format(c) is the Copyright property of  *  CompuServe Incorporated.  GIF(sm) is a Service Mark property of  *  CompuServe Incorporated."   */
end_comment

begin_comment
comment|/*  * REVISION HISTORY  *  * 99/01/23  * 2.01.01 - Use a text-box to permit multi-line comments.  Don't  *           try to write comment blocks which are longer than  *           permitted.  *  * 98/10/09  * 2.01.00 - Added support for persistant GIF Comments through  *           the GIMP 1.1 Parasite mechanism where available.  *           Did some user-interface tweaks.  *           Fixed a bug when trying to save a GIF smaller  *           than five pixels high as interlaced.  *  * 98/09/28  * 2.00.05 - Fixed TigerT's Infinite GIF Bug.  Icky one.  *  * 98/09/15  * 2.00.04 - The facility to specify the background colour of  *           a transparent/animated GIF for non-transparent  *           viewers now works very much more consistantly.  *  *           The only situations in which it will fail to work  *           as expected now are those where file size can be reduced  *           (abeit not by much, as the plugin is sometimes more pessimistic  *           than it need be) by re-using an existing unused colour  *           index rather than using another bit per pixel in the  *           encoded file.  That will never be an issue with an image  *           which was freshly converted from RGB to INDEXED with the  *           Quantize option, as that option removes any unused colours  *           from the image.  *  *           Let me know if you find the consistancy/size tradeoff more  *           annoying than helpful and I can adjust it.  IMHO it is too  *           arcane a feature to present to any user as a runtime option.  *  * 98/05/18  * 2.00.03 - If we did manage to decode at least one frame of a  *           gif, be sure to display the resulting image even if  *           it terminated abruptly.  *  * 98/04/28  * 2.00.02 - Fixed a bug with (ms) tag parsing.  *  * 98/03/16  * 2.00.01 - Fixed a long-standing bug when loading GIFs which layer  *           opaque frames onto transparent ones.  *  * 98/03/15  * 2.00.00 - No longer beta.  Uses the current GIMP brush background  *           colour as the transparent-index colour for viewers that  *           don't know about transparency, instead of magenta.  Note  *           that this is by no means likely to actually work, but  *           is more likely to do so if your image has been freshly  *           to-index'd before saving.  *  *           Also added some analysis to gif-reading to prevent the  *           number of encoded bits being pumped up inadvertantly for  *           successive load/saves of the same image.  [Adam]  *  * 97/12/11  * 1.99.18 - Bleh.  Disposals should specify how the next frame will  *           be composed with this frame, NOT how this frame will  *           be composed with the previous frame.  Fixed.  [Adam]  *  * 97/11/30  * 1.99.17 - No more bogus transparency indices in animated GIFs,  *           hopefully.  Saved files are better-behaved, sometimes  *           smaller.  [Adam]  *  * 97/09/29  * 1.99.16 - Added a dialog for the user to choose what to do if  *           one of the layers of the image extends beyond the image  *           borders - crop or cancel.  Added code behind it.  *  *           Corrected the number of bits for the base image to be  *           on the generous side.  Hopefully we can no longer generate  *           GIFs which make XV barf.  *  *           Now a lot more careful about whether we choose to encode  *           as a GIF87a or a GIF89a.  Hopefully does everything by the  *           book.  It should now be nigh-on impossible to torture the  *           plugin into generating a GIF which isn't extremely well  *           behaved with respect to the GIF89a specification.  *  *           Fixed(?) a lot of dialog callback details, should now be  *           happy with window deletion (GTK+970925).  Fixed the  *           cancellation of a save.  [Adam]  *  * 97/09/16  * 1.99.15 - Hey!  We can now cope with loading images which change  *           colourmap between frames.  This plugin will never save  *           such abominations of nature while I still live, though.  *           There should be no noncorrupt GIF in the universe which  *           GIMP can't load and play now.  [Adam]  *  * 97/09/14  * 1.99.14 - Added a check for layers whose extents don't lay  *           within the image boundaries, which would make it a  *           lot harder to generate badly-behaved GIFs.  Doesn't  *           do anything about it yet, but it should crop all layers  *           to the image boundaries.  Also, there's now a (separate)  *           animation-preview plugin!  [Adam]  *  * 97/08/29  * 1.99.13 - Basic ability to embed GIF comments within saved images.  *           Fixed a bug with encoding the number of loops in a GIF file -  *           would have been important, but we're not using that feature  *           yet anyway.  ;)  *           Subtly improved dialog layout a little. [Adam]  *  * 97/07/25  * 1.99.12 - Fixed attempts to load GIFs which don't exist.  Made a  *           related cosmetic adjustment. [Adam]  *  * 97/07/10  * 1.99.11 - Fixed a bug with loading and saving GIFs where the bottom  *           layer wasn't the same size as the image. [Adam]  *  * 97/07/06  * 1.99.10 - New 'save' dialog, now most of the default behaviour of  *           animated GIF saving is user-settable (looping, default  *           time between frames, etc.)  *           PDB entry for saving is no longer compatible.  Fortunately  *           I don't think that anyone is using file_gif_save in  *           scripts.  [Adam]  *  * 97/07/05  * 1.99.9  - More animated GIF work: now loads and saves frame disposal  *           information.  This is neat and will also allow some delta  *           stuff in the future.  *           The disposal-method is kept in the layer name, like the timing  *           info.  *           (replace) - this frame replaces whatever else has been shown  *                       so far.  *           (combine) - this frame builds apon the previous frame.  *           If a disposal method is not specified, it is assumed to mean  *           "don't care."  [Adam]  *  * 97/07/04  * 1.99.8  - Can save per-frame timing information too, now.  The time  *           for which a frame is visible is specified within the layer name  *           as i,e. (250ms).  If a frame doesn't have this timing value  *           it defaults to lasting 100ms. [Adam]  *  * 97/07/02  * 1.99.7  - For animated GIFs, fixed the saving of timing information for  *           frames which couldn't be made transparent.  *           Added the loading of timing information into the layer  *           names.  Adjusted GIMP's GIF magic number very slightly. [Adam]  *  * 97/06/30  * 1.99.6  - Now saves GRAY and GRAYA images, albeit not always  *           optimally (yet). [Adam]  *  * 97/06/25  * 1.99.5  - Good, the transparancy-on-big-architectures bug is  *           fixed.  Cleaned up some stuff.  *           (Adam D. Moss, adam@foxbox.org)  *  * 97/06/23  * 1.99.4  - Trying to fix some endianness/word-size problems with  *           transparent gif-saving on some architectures... does  *           this help?  (Adam D. Moss, adam@foxbox.org)  *  * 97/05/18  * 1.99.3  - Fixed the problem with GIFs getting loop extensions even  *           if they only had one frame (thanks to Zach for noticing -  *           git!  :) )  (Adam D. Moss, adam@foxbox.org)  *  * 97/05/17  * 1.99.2  - Can now save animated GIFs.  Correctly handles saving of  *           image offsets.  Uses N*tscape extentions to loop infinitely.  *           Some notable shortcomings - see TODO list below.  *           (Adam D. Moss, adam@foxbox.org)  *  * 97/05/16  * 1.99.1  - Implemented image offsets in animated GIF loading.  Requires  *           a fix to gimp_layer_translate in libgimp/gimplayer.c if used  *           with GIMP versions<= 0.99.10.  Started work on saving animated  *           GIFs.  Started TODO list.  (Adam D. Moss, adam@foxbox.org)  *  * 97/05/15  * 1.99.0  - Started revision log.  GIF plugin now loads/saves INDEXED  *           and INDEXEDA images with correct transparency where possible.  *           Loads multi-image (animated) GIFs as a framestack implemented  *           in GIMP layers.  Some bug fixes to original code, some new bugs  *           cheerfully added.  (Adam D. Moss, adam@foxbox.org)  *  * Previous versions - load/save INDEXED images.  *           (Peter Mattis& Spencer Kimball, gimp@scam.xcf.berkeley.edu)  */
end_comment

begin_comment
comment|/*  * TODO (more *'s means more important!)  *  * - PDB stuff for comments  *  * - 'requantize' option for INDEXEDA images which really have 256 colours  *   in them  *  * - Be a bit smarter about finding unused/superfluous colour indices for  *   lossless colour crunching of INDEXEDA images.  (Specifically, look  *   for multiple indices which correspond to the same physical colour.)  *  * - Tidy up parameters for the GIFEncode routines  *  * - Remove unused colourmap entries for GRAYSCALE images.  *  * - Button to activate the animation preview plugin from the GIF-save  *   dialog.  *  */
end_comment

begin_comment
comment|/* Copyright notice for code which this plugin was long ago derived from */
end_comment

begin_comment
comment|/* +-------------------------------------------------------------------+ */
end_comment

begin_comment
comment|/* | Copyright 1990, 1991, 1993, David Koblas.  (koblas@netcom.com)    | */
end_comment

begin_comment
comment|/* |   Permission to use, copy, modify, and distribute this software   | */
end_comment

begin_comment
comment|/* |   and its documentation for any purpose and without fee is hereby | */
end_comment

begin_comment
comment|/* |   granted, provided that the above copyright notice appear in all | */
end_comment

begin_comment
comment|/* |   copies and that both that copyright notice and this permission  | */
end_comment

begin_comment
comment|/* |   notice appear in supporting documentation.  This software is    | */
end_comment

begin_comment
comment|/* |   provided "as is" without express or implied warranty.           | */
end_comment

begin_comment
comment|/* +-------------------------------------------------------------------+ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_comment
comment|/* uncomment the line below for a little debugging info */
end_comment

begin_comment
comment|/* #define GIFDEBUG yesplease */
end_comment

begin_comment
comment|/* Wear your GIMP with pride! */
end_comment

begin_define
DECL|macro|DEFAULT_COMMENT
define|#
directive|define
name|DEFAULT_COMMENT
value|"Made with GIMP"
end_define

begin_comment
comment|/* Does the version of GIMP we're compiling for support    data attachments to images?  ('Parasites') */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_PARASITE_H_
end_ifdef

begin_define
DECL|macro|FACEHUGGERS
define|#
directive|define
name|FACEHUGGERS
value|aieee
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PS: I know that technically facehuggers aren't parasites,    the pupal-forms are.  But facehuggers are cute. */
end_comment

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2a480e230108
block|{
DECL|member|interlace
name|int
name|interlace
decl_stmt|;
DECL|member|loop
name|int
name|loop
decl_stmt|;
DECL|member|default_delay
name|int
name|default_delay
decl_stmt|;
DECL|member|default_dispose
name|int
name|default_dispose
decl_stmt|;
DECL|typedef|GIFSaveVals
block|}
name|GIFSaveVals
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
DECL|struct|__anon2a480e230208
block|{
DECL|member|run
name|gint
name|run
decl_stmt|;
DECL|typedef|GIFSaveInterface
block|}
name|GIFSaveInterface
typedef|;
end_typedef

begin_comment
comment|/* Declare some local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|load_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|boundscheck
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gboolean
name|badbounds_dialog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cropok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cropclose_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cropcancel_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_cancel_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_windelete_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disposal_select_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comment_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|radio_pressed
specifier|static
name|gint
name|radio_pressed
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|used_cmap
specifier|static
name|guchar
name|used_cmap
index|[
literal|3
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|can_crop
specifier|static
name|gboolean
name|can_crop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|highest_used_index
specifier|static
name|guchar
name|highest_used_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|promote_to_rgb
specifier|static
name|gboolean
name|promote_to_rgb
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gimp_cmap
specifier|static
name|guchar
name|gimp_cmap
index|[
literal|768
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FACEHUGGERS
end_ifdef

begin_decl_stmt
DECL|variable|comment_parasite
name|Parasite
modifier|*
name|comment_parasite
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For compression code */
end_comment

begin_decl_stmt
DECL|variable|Interlace
specifier|static
name|int
name|Interlace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|NULL
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gsvals
specifier|static
name|GIFSaveVals
name|gsvals
init|=
block|{
name|FALSE
block|,
comment|/* interlace */
name|TRUE
block|,
comment|/* loop infinitely */
literal|100
block|,
comment|/* default_delay between frames (100ms) */
literal|0
comment|/* default_dispose = "don't care" */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|gsint
specifier|static
name|GIFSaveInterface
name|gsint
init|=
block|{
name|FALSE
comment|/*  run  */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
DECL|function|MAIN ()
name|MAIN
argument_list|()
end_macro

begin_function
specifier|static
name|void
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|load_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to load"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
name|load_return_vals
index|[]
init|=
block|{
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Output image"
block|}
block|,   }
decl_stmt|;
specifier|static
name|int
name|nload_args
init|=
sizeof|sizeof
argument_list|(
name|load_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nload_return_vals
init|=
sizeof|sizeof
argument_list|(
name|load_return_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|load_return_vals
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|GParamDef
name|save_args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,
block|{
name|PARAM_IMAGE
block|,
literal|"image"
block|,
literal|"Image to save"
block|}
block|,
block|{
name|PARAM_DRAWABLE
block|,
literal|"drawable"
block|,
literal|"Drawable to save"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"filename"
block|,
literal|"The name of the file to save the image in"
block|}
block|,
block|{
name|PARAM_STRING
block|,
literal|"raw_filename"
block|,
literal|"The name entered"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"interlace"
block|,
literal|"Try to save as interlaced"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"loop"
block|,
literal|"(animated gif) loop infinitely"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"default_delay"
block|,
literal|"(animated gif) Default delay between framese in milliseconds"
block|}
block|,
block|{
name|PARAM_INT32
block|,
literal|"default_dispose"
block|,
literal|"(animated gif) Default disposal type (0=`don't care`, 1=combine, 2=replace)"
block|}
block|}
decl_stmt|;
specifier|static
name|int
name|nsave_args
init|=
sizeof|sizeof
argument_list|(
name|save_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|save_args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_gif_load"
argument_list|,
literal|"loads files of Compuserve GIF file format"
argument_list|,
literal|"FIXME: write help for gif_load"
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"1995-1997"
argument_list|,
literal|"<Load>/GIF"
argument_list|,
name|NULL
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nload_args
argument_list|,
name|nload_return_vals
argument_list|,
name|load_args
argument_list|,
name|load_return_vals
argument_list|)
expr_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"file_gif_save"
argument_list|,
literal|"saves files in Compuserve GIF file format"
argument_list|,
literal|"FIXME: write help for gif_save"
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"Spencer Kimball, Peter Mattis, Adam Moss, David Koblas"
argument_list|,
literal|"1995-1997"
argument_list|,
literal|"<Save>/GIF"
argument_list|,
literal|"INDEXED*"
argument_list|,
name|PROC_PLUG_IN
argument_list|,
name|nsave_args
argument_list|,
literal|0
argument_list|,
name|save_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimp_register_magic_load_handler
argument_list|(
literal|"file_gif_load"
argument_list|,
literal|"gif"
argument_list|,
literal|""
argument_list|,
literal|"0,string,GIF8"
argument_list|)
expr_stmt|;
name|gimp_register_save_handler
argument_list|(
literal|"file_gif_save"
argument_list|,
literal|"gif"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (char * name,int nparams,GParam * param,int * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|2
index|]
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|gint32
name|image_ID
decl_stmt|;
name|gchar
modifier|*
modifier|*
name|argv
decl_stmt|;
name|gint
name|argc
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
operator|*
name|nreturn_vals
operator|=
literal|2
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_gif_load"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image_ID
operator|=
name|load_image
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
comment|/* The GIF format only tells you how many bits per pixel        *  are in the image, not the actual number of used indices (D'OH!)        *        * So if we're not careful, repeated load/save of a transparent GIF        *  without intermediate indexed->RGB->indexed pumps up the number of        *  bits used, as we add an index each time for the transparent        *  colour.  Ouch.  We either do some heavier analysis at save-time,        *  or trim down the number of GIMP colours at load-time.  We do the        *  latter for now.        */
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_print
argument_list|(
literal|"GIF: Highest used index is %d\n"
argument_list|,
name|highest_used_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|promote_to_rgb
condition|)
block|{
name|gimp_image_set_cmap
argument_list|(
name|image_ID
argument_list|,
name|gimp_cmap
argument_list|,
name|highest_used_index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|image_ID
operator|!=
operator|-
literal|1
condition|)
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PARAM_IMAGE
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_image
operator|=
name|image_ID
expr_stmt|;
block|}
else|else
block|{
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file_gif_save"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argc
operator|=
literal|1
expr_stmt|;
name|argv
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"gif"
argument_list|)
expr_stmt|;
name|gtk_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|gtk_rc_parse
argument_list|(
name|gimp_gtkrc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|boundscheck
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|)
condition|)
comment|/* The image may or may not have had layers out of 	   bounds, but the user didn't mind cropping it down. */
block|{
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
block|{
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_gif_save"
argument_list|,
operator|&
name|gsvals
argument_list|)
expr_stmt|;
comment|/*  First acquire information with a dialog  */
name|radio_pressed
index|[
literal|0
index|]
operator|=
name|radio_pressed
index|[
literal|1
index|]
operator|=
name|radio_pressed
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
name|radio_pressed
index|[
name|gsvals
operator|.
name|default_dispose
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|save_dialog
argument_list|(
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|)
condition|)
block|{
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|radio_pressed
index|[
literal|0
index|]
condition|)
name|gsvals
operator|.
name|default_dispose
operator|=
literal|0x00
expr_stmt|;
elseif|else
if|if
condition|(
name|radio_pressed
index|[
literal|1
index|]
condition|)
name|gsvals
operator|.
name|default_dispose
operator|=
literal|0x01
expr_stmt|;
elseif|else
if|if
condition|(
name|radio_pressed
index|[
literal|2
index|]
condition|)
name|gsvals
operator|.
name|default_dispose
operator|=
literal|0x02
expr_stmt|;
block|}
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
comment|/*  Make sure all the arguments are there!  */
if|if
condition|(
name|nparams
operator|!=
literal|9
condition|)
name|status
operator|=
name|STATUS_CALLING_ERROR
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|STATUS_SUCCESS
condition|)
block|{
name|gsvals
operator|.
name|interlace
operator|=
operator|(
name|param
index|[
literal|5
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|gsvals
operator|.
name|loop
operator|=
operator|(
name|param
index|[
literal|6
index|]
operator|.
name|data
operator|.
name|d_int32
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|gsvals
operator|.
name|default_delay
operator|=
name|param
index|[
literal|7
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
name|gsvals
operator|.
name|default_dispose
operator|=
name|param
index|[
literal|8
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
block|}
break|break;
case|case
name|RUN_WITH_LAST_VALS
case|:
comment|/*  Possibly retrieve data  */
name|gimp_get_data
argument_list|(
literal|"file_gif_save"
argument_list|,
operator|&
name|gsvals
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|save_image
argument_list|(
name|param
index|[
literal|3
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|,
name|param
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|,
name|param
index|[
literal|2
index|]
operator|.
name|data
operator|.
name|d_int32
argument_list|)
condition|)
block|{
comment|/*  Store psvals data  */
name|gimp_set_data
argument_list|(
literal|"file_gif_save"
argument_list|,
operator|&
name|gsvals
argument_list|,
sizeof|sizeof
argument_list|(
name|GIFSaveVals
argument_list|)
argument_list|)
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
block|}
else|else
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
else|else
comment|/* Some layers were out of bounds and the user wishes 	      to abort.  */
block|{
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|STATUS_EXECUTION_ERROR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
DECL|macro|MAXCOLORMAPSIZE
define|#
directive|define
name|MAXCOLORMAPSIZE
value|256
end_define

begin_define
DECL|macro|CM_RED
define|#
directive|define
name|CM_RED
value|0
end_define

begin_define
DECL|macro|CM_GREEN
define|#
directive|define
name|CM_GREEN
value|1
end_define

begin_define
DECL|macro|CM_BLUE
define|#
directive|define
name|CM_BLUE
value|2
end_define

begin_define
DECL|macro|MAX_LWZ_BITS
define|#
directive|define
name|MAX_LWZ_BITS
value|12
end_define

begin_define
DECL|macro|INTERLACE
define|#
directive|define
name|INTERLACE
value|0x40
end_define

begin_define
DECL|macro|LOCALCOLORMAP
define|#
directive|define
name|LOCALCOLORMAP
value|0x80
end_define

begin_define
DECL|macro|BitSet (byte,bit)
define|#
directive|define
name|BitSet
parameter_list|(
name|byte
parameter_list|,
name|bit
parameter_list|)
value|(((byte)& (bit)) == (bit))
end_define

begin_define
DECL|macro|ReadOK (file,buffer,len)
define|#
directive|define
name|ReadOK
parameter_list|(
name|file
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
value|(fread(buffer, len, 1, file) != 0)
end_define

begin_define
DECL|macro|LM_to_uint (a,b)
define|#
directive|define
name|LM_to_uint
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((b)<<8)|(a))
end_define

begin_define
DECL|macro|GRAYSCALE
define|#
directive|define
name|GRAYSCALE
value|1
end_define

begin_define
DECL|macro|COLOR
define|#
directive|define
name|COLOR
value|2
end_define

begin_typedef
DECL|typedef|CMap
typedef|typedef
name|unsigned
name|char
name|CMap
index|[
literal|3
index|]
index|[
name|MAXCOLORMAPSIZE
index|]
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2a480e230308
block|{
DECL|member|Width
name|unsigned
name|int
name|Width
decl_stmt|;
DECL|member|Height
name|unsigned
name|int
name|Height
decl_stmt|;
DECL|member|ColorMap
name|CMap
name|ColorMap
decl_stmt|;
DECL|member|BitPixel
name|unsigned
name|int
name|BitPixel
decl_stmt|;
DECL|member|ColorResolution
name|unsigned
name|int
name|ColorResolution
decl_stmt|;
DECL|member|Background
name|unsigned
name|int
name|Background
decl_stmt|;
DECL|member|AspectRatio
name|unsigned
name|int
name|AspectRatio
decl_stmt|;
comment|/*    **    */
DECL|member|GrayScale
name|int
name|GrayScale
decl_stmt|;
DECL|variable|GifScreen
block|}
name|GifScreen
struct|;
end_struct

begin_struct
specifier|static
struct|struct
DECL|struct|__anon2a480e230408
block|{
DECL|member|transparent
name|int
name|transparent
decl_stmt|;
DECL|member|delayTime
name|int
name|delayTime
decl_stmt|;
DECL|member|inputFlag
name|int
name|inputFlag
decl_stmt|;
DECL|member|disposal
name|int
name|disposal
decl_stmt|;
DECL|variable|Gif89
block|}
name|Gif89
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
DECL|variable|verbose
name|int
name|verbose
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|showComment
name|int
name|showComment
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|globalcomment
name|char
modifier|*
name|globalcomment
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|globalusecomment
name|gint
name|globalusecomment
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ReadColorMap
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|CMap
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DoExtension
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GetDataBlock
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GetCode
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LWZReadByte
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint32
name|ReadImage
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|CMap
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|guint
parameter_list|,
name|guint
parameter_list|,
name|guint
parameter_list|,
name|guint
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|gint32
DECL|function|load_image (char * filename)
name|load_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|name_buf
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|CMap
name|localColorMap
decl_stmt|;
name|int
name|grayScale
decl_stmt|;
name|int
name|useGlobalColormap
decl_stmt|;
name|int
name|bitPixel
decl_stmt|;
name|int
name|imageCount
init|=
literal|0
decl_stmt|;
name|char
name|version
index|[
literal|4
index|]
decl_stmt|;
name|gint32
name|image_ID
init|=
operator|-
literal|1
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: can't open \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|name_buf
operator|=
name|g_malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"Loading %s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: error reading magic number\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"GIF"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: not a GIF file\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|version
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|version
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"87a"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"89a"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: bad version number, not '87a' or '89a'\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: failed to read screen descriptor\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|GifScreen
operator|.
name|Width
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|GifScreen
operator|.
name|Height
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|GifScreen
operator|.
name|BitPixel
operator|=
literal|2
operator|<<
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x07
operator|)
expr_stmt|;
name|GifScreen
operator|.
name|ColorResolution
operator|=
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x70
operator|)
operator|>>
literal|3
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|GifScreen
operator|.
name|Background
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|GifScreen
operator|.
name|AspectRatio
operator|=
name|buf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|BitSet
argument_list|(
name|buf
index|[
literal|4
index|]
argument_list|,
name|LOCALCOLORMAP
argument_list|)
condition|)
block|{
comment|/* Global Colormap */
if|if
condition|(
name|ReadColorMap
argument_list|(
name|fd
argument_list|,
name|GifScreen
operator|.
name|BitPixel
argument_list|,
name|GifScreen
operator|.
name|ColorMap
argument_list|,
operator|&
name|GifScreen
operator|.
name|GrayScale
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: error reading global colormap\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|GifScreen
operator|.
name|AspectRatio
operator|!=
literal|0
operator|&&
name|GifScreen
operator|.
name|AspectRatio
operator|!=
literal|49
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: warning - non-square pixels\n"
argument_list|)
expr_stmt|;
block|}
name|highest_used_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: EOF / read error on image data\n"
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
comment|/* will be -1 if failed on first image! */
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
comment|/* GIF terminator */
return|return
name|image_ID
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
block|{
comment|/* Extension */
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: OF / read error on extention function code\n"
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
comment|/* will be -1 if failed on first image! */
block|}
name|DoExtension
argument_list|(
name|fd
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
block|{
comment|/* Not a valid start character */
name|g_message
argument_list|(
literal|"GIF: bogus character 0x%02x, ignoring\n"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|imageCount
expr_stmt|;
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: couldn't read left/top/width/height\n"
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
comment|/* will be -1 if failed on first image! */
block|}
name|useGlobalColormap
operator|=
operator|!
name|BitSet
argument_list|(
name|buf
index|[
literal|8
index|]
argument_list|,
name|LOCALCOLORMAP
argument_list|)
expr_stmt|;
name|bitPixel
operator|=
literal|1
operator|<<
operator|(
operator|(
name|buf
index|[
literal|8
index|]
operator|&
literal|0x07
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|useGlobalColormap
condition|)
block|{
if|if
condition|(
name|ReadColorMap
argument_list|(
name|fd
argument_list|,
name|bitPixel
argument_list|,
name|localColorMap
argument_list|,
operator|&
name|grayScale
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: error reading local colormap\n"
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
comment|/* will be -1 if failed on first image! */
block|}
name|image_ID
operator|=
name|ReadImage
argument_list|(
name|fd
argument_list|,
name|filename
argument_list|,
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|6
index|]
argument_list|,
name|buf
index|[
literal|7
index|]
argument_list|)
argument_list|,
name|localColorMap
argument_list|,
name|bitPixel
argument_list|,
name|grayScale
argument_list|,
name|BitSet
argument_list|(
name|buf
index|[
literal|8
index|]
argument_list|,
name|INTERLACE
argument_list|)
argument_list|,
name|imageCount
argument_list|,
operator|(
name|guint
operator|)
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|guint
operator|)
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|GifScreen
operator|.
name|Width
argument_list|,
name|GifScreen
operator|.
name|Height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|image_ID
operator|=
name|ReadImage
argument_list|(
name|fd
argument_list|,
name|filename
argument_list|,
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|6
index|]
argument_list|,
name|buf
index|[
literal|7
index|]
argument_list|)
argument_list|,
name|GifScreen
operator|.
name|ColorMap
argument_list|,
name|GifScreen
operator|.
name|BitPixel
argument_list|,
name|GifScreen
operator|.
name|GrayScale
argument_list|,
name|BitSet
argument_list|(
name|buf
index|[
literal|8
index|]
argument_list|,
name|INTERLACE
argument_list|)
argument_list|,
name|imageCount
argument_list|,
operator|(
name|guint
operator|)
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|guint
operator|)
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|GifScreen
operator|.
name|Width
argument_list|,
name|GifScreen
operator|.
name|Height
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FACEHUGGERS
if|if
condition|(
name|comment_parasite
operator|!=
name|NULL
condition|)
block|{
name|gimp_image_attach_parasite
argument_list|(
name|image_ID
argument_list|,
name|comment_parasite
argument_list|)
expr_stmt|;
name|parasite_free
argument_list|(
name|comment_parasite
argument_list|)
expr_stmt|;
name|comment_parasite
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|image_ID
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|ReadColorMap (FILE * fd,int number,CMap buffer,int * format)
name|ReadColorMap
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|number
parameter_list|,
name|CMap
name|buffer
parameter_list|,
name|int
modifier|*
name|format
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|rgb
index|[
literal|3
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
name|rgb
argument_list|,
sizeof|sizeof
argument_list|(
name|rgb
argument_list|)
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: bad colormap\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|buffer
index|[
name|CM_RED
index|]
index|[
name|i
index|]
operator|=
name|rgb
index|[
literal|0
index|]
expr_stmt|;
name|buffer
index|[
name|CM_GREEN
index|]
index|[
name|i
index|]
operator|=
name|rgb
index|[
literal|1
index|]
expr_stmt|;
name|buffer
index|[
name|CM_BLUE
index|]
index|[
name|i
index|]
operator|=
name|rgb
index|[
literal|2
index|]
expr_stmt|;
name|flag
operator|&=
operator|(
name|rgb
index|[
literal|0
index|]
operator|==
name|rgb
index|[
literal|1
index|]
operator|&&
name|rgb
index|[
literal|1
index|]
operator|==
name|rgb
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
operator|*
name|format
operator|=
operator|(
name|flag
operator|)
condition|?
name|GRAYSCALE
else|:
name|COLOR
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|DoExtension (FILE * fd,int label)
name|DoExtension
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|label
parameter_list|)
block|{
specifier|static
name|guchar
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|label
condition|)
block|{
case|case
literal|0x01
case|:
comment|/* Plain Text Extension */
name|str
operator|=
literal|"Plain Text Extension"
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|lpos
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tpos
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|width
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|height
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|6
index|]
argument_list|,
name|buf
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|cellw
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|cellh
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|foreground
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|background
operator|=
name|buf
index|[
literal|11
index|]
expr_stmt|;
while|while
condition|(
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PPM_ASSIGN
argument_list|(
name|image
index|[
name|ypos
index|]
index|[
name|xpos
index|]
argument_list|,
name|cmap
index|[
name|CM_RED
index|]
index|[
name|v
index|]
argument_list|,
name|cmap
index|[
name|CM_GREEN
index|]
index|[
name|v
index|]
argument_list|,
name|cmap
index|[
name|CM_BLUE
index|]
index|[
name|v
index|]
argument_list|)
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
return|return
name|FALSE
return|;
else|#
directive|else
break|break;
endif|#
directive|endif
case|case
literal|0xff
case|:
comment|/* Application Extension */
name|str
operator|=
literal|"Application Extension"
expr_stmt|;
break|break;
case|case
literal|0xfe
case|:
comment|/* Comment Extension */
name|str
operator|=
literal|"Comment Extension"
expr_stmt|;
while|while
condition|(
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|FACEHUGGERS
if|if
condition|(
name|comment_parasite
operator|!=
name|NULL
condition|)
block|{
name|parasite_free
argument_list|(
name|comment_parasite
argument_list|)
expr_stmt|;
block|}
name|comment_parasite
operator|=
name|parasite_new
argument_list|(
literal|"gimp-comment"
argument_list|,
name|PARASITE_PERSISTENT
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|showComment
condition|)
name|g_print
argument_list|(
literal|"GIF: gif comment: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|TRUE
return|;
break|break;
case|case
literal|0xf9
case|:
comment|/* Graphic Control Extension */
name|str
operator|=
literal|"Graphic Control Extension"
expr_stmt|;
operator|(
name|void
operator|)
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|Gif89
operator|.
name|disposal
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x7
expr_stmt|;
name|Gif89
operator|.
name|inputFlag
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x1
expr_stmt|;
name|Gif89
operator|.
name|delayTime
operator|=
name|LM_to_uint
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
name|Gif89
operator|.
name|transparent
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
else|else
name|Gif89
operator|.
name|transparent
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
name|FALSE
return|;
break|break;
default|default:
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"UNKNOWN (0x%02x)"
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_print
argument_list|(
literal|"GIF: got a '%s'\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_decl_stmt
DECL|variable|ZeroDataBlock
name|int
name|ZeroDataBlock
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
DECL|function|GetDataBlock (FILE * fd,unsigned char * buf)
name|GetDataBlock
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
operator|&
name|count
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: error in getting DataBlock size\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ZeroDataBlock
operator|=
name|count
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
operator|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: error in reading DataBlock\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|GetCode (FILE * fd,int code_size,int flag)
name|GetCode
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|code_size
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|buf
index|[
literal|280
index|]
decl_stmt|;
specifier|static
name|int
name|curbit
decl_stmt|,
name|lastbit
decl_stmt|,
name|done
decl_stmt|,
name|last_byte
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|char
name|count
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|curbit
operator|=
literal|0
expr_stmt|;
name|lastbit
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|curbit
operator|+
name|code_size
operator|)
operator|>=
name|lastbit
condition|)
block|{
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|curbit
operator|>=
name|lastbit
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: ran off the end of by bits\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|buf
index|[
name|last_byte
operator|-
literal|2
index|]
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
name|last_byte
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|done
operator|=
name|TRUE
expr_stmt|;
name|last_byte
operator|=
literal|2
operator|+
name|count
expr_stmt|;
name|curbit
operator|=
operator|(
name|curbit
operator|-
name|lastbit
operator|)
operator|+
literal|16
expr_stmt|;
name|lastbit
operator|=
operator|(
literal|2
operator|+
name|count
operator|)
operator|*
literal|8
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|curbit
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|code_size
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
name|ret
operator||=
operator|(
operator|(
name|buf
index|[
name|i
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|<<
name|j
expr_stmt|;
name|curbit
operator|+=
name|code_size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|LWZReadByte (FILE * fd,int flag,int input_code_size)
name|LWZReadByte
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|input_code_size
parameter_list|)
block|{
specifier|static
name|int
name|fresh
init|=
name|FALSE
decl_stmt|;
name|int
name|code
decl_stmt|,
name|incode
decl_stmt|;
specifier|static
name|int
name|code_size
decl_stmt|,
name|set_code_size
decl_stmt|;
specifier|static
name|int
name|max_code
decl_stmt|,
name|max_code_size
decl_stmt|;
specifier|static
name|int
name|firstcode
decl_stmt|,
name|oldcode
decl_stmt|;
specifier|static
name|int
name|clear_code
decl_stmt|,
name|end_code
decl_stmt|;
specifier|static
name|int
name|table
index|[
literal|2
index|]
index|[
operator|(
literal|1
operator|<<
name|MAX_LWZ_BITS
operator|)
index|]
decl_stmt|;
specifier|static
name|int
name|stack
index|[
operator|(
literal|1
operator|<<
operator|(
name|MAX_LWZ_BITS
operator|)
operator|)
operator|*
literal|2
index|]
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|set_code_size
operator|=
name|input_code_size
expr_stmt|;
name|code_size
operator|=
name|set_code_size
operator|+
literal|1
expr_stmt|;
name|clear_code
operator|=
literal|1
operator|<<
name|set_code_size
expr_stmt|;
name|end_code
operator|=
name|clear_code
operator|+
literal|1
expr_stmt|;
name|max_code_size
operator|=
literal|2
operator|*
name|clear_code
expr_stmt|;
name|max_code
operator|=
name|clear_code
operator|+
literal|2
expr_stmt|;
name|GetCode
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fresh
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clear_code
condition|;
operator|++
name|i
control|)
block|{
name|table
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|table
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|MAX_LWZ_BITS
operator|)
condition|;
operator|++
name|i
control|)
name|table
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|table
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fresh
condition|)
block|{
name|fresh
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|firstcode
operator|=
name|oldcode
operator|=
name|GetCode
argument_list|(
name|fd
argument_list|,
name|code_size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|firstcode
operator|==
name|clear_code
condition|)
do|;
return|return
name|firstcode
return|;
block|}
if|if
condition|(
name|sp
operator|>
name|stack
condition|)
return|return
operator|*
operator|--
name|sp
return|;
while|while
condition|(
operator|(
name|code
operator|=
name|GetCode
argument_list|(
name|fd
argument_list|,
name|code_size
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|clear_code
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clear_code
condition|;
operator|++
name|i
control|)
block|{
name|table
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|table
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|MAX_LWZ_BITS
operator|)
condition|;
operator|++
name|i
control|)
name|table
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|table
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|code_size
operator|=
name|set_code_size
operator|+
literal|1
expr_stmt|;
name|max_code_size
operator|=
literal|2
operator|*
name|clear_code
expr_stmt|;
name|max_code
operator|=
name|clear_code
operator|+
literal|2
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
name|firstcode
operator|=
name|oldcode
operator|=
name|GetCode
argument_list|(
name|fd
argument_list|,
name|code_size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|firstcode
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|end_code
condition|)
block|{
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|260
index|]
decl_stmt|;
if|if
condition|(
name|ZeroDataBlock
condition|)
return|return
operator|-
literal|2
return|;
while|while
condition|(
operator|(
name|count
operator|=
name|GetDataBlock
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|g_print
argument_list|(
literal|"GIF: missing EOD in data stream (common occurence)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|incode
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|max_code
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|firstcode
expr_stmt|;
name|code
operator|=
name|oldcode
expr_stmt|;
block|}
while|while
condition|(
name|code
operator|>=
name|clear_code
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|table
index|[
literal|1
index|]
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|table
index|[
literal|0
index|]
index|[
name|code
index|]
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: circular table entry BIG ERROR\n"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|code
operator|=
name|table
index|[
literal|0
index|]
index|[
name|code
index|]
expr_stmt|;
block|}
operator|*
name|sp
operator|++
operator|=
name|firstcode
operator|=
name|table
index|[
literal|1
index|]
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|max_code
operator|)
operator|<
operator|(
literal|1
operator|<<
name|MAX_LWZ_BITS
operator|)
condition|)
block|{
name|table
index|[
literal|0
index|]
index|[
name|code
index|]
operator|=
name|oldcode
expr_stmt|;
name|table
index|[
literal|1
index|]
index|[
name|code
index|]
operator|=
name|firstcode
expr_stmt|;
operator|++
name|max_code
expr_stmt|;
if|if
condition|(
operator|(
name|max_code
operator|>=
name|max_code_size
operator|)
operator|&&
operator|(
name|max_code_size
operator|<
operator|(
literal|1
operator|<<
name|MAX_LWZ_BITS
operator|)
operator|)
condition|)
block|{
name|max_code_size
operator|*=
literal|2
expr_stmt|;
operator|++
name|code_size
expr_stmt|;
block|}
block|}
name|oldcode
operator|=
name|incode
expr_stmt|;
if|if
condition|(
name|sp
operator|>
name|stack
condition|)
return|return
operator|*
operator|--
name|sp
return|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_function
specifier|static
name|gint32
DECL|function|ReadImage (FILE * fd,char * filename,int len,int height,CMap cmap,int ncols,int format,int interlace,int number,guint leftpos,guint toppos,guint screenwidth,guint screenheight)
name|ReadImage
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|height
parameter_list|,
name|CMap
name|cmap
parameter_list|,
name|int
name|ncols
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|interlace
parameter_list|,
name|int
name|number
parameter_list|,
name|guint
name|leftpos
parameter_list|,
name|guint
name|toppos
parameter_list|,
name|guint
name|screenwidth
parameter_list|,
name|guint
name|screenheight
parameter_list|)
block|{
specifier|static
name|gint32
name|image_ID
decl_stmt|;
specifier|static
name|gint
name|frame_number
init|=
literal|1
decl_stmt|;
name|gint32
name|layer_ID
decl_stmt|;
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|guchar
modifier|*
name|dest
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|guchar
name|c
decl_stmt|;
name|gint
name|xpos
init|=
literal|0
decl_stmt|,
name|ypos
init|=
literal|0
decl_stmt|,
name|pass
init|=
literal|0
decl_stmt|;
name|gint
name|cur_progress
decl_stmt|,
name|max_progress
decl_stmt|;
name|gint
name|v
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gchar
name|framename
index|[
literal|200
index|]
decl_stmt|;
comment|/* FIXME */
name|gboolean
name|alpha_frame
init|=
name|FALSE
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
specifier|static
name|int
name|previous_disposal
decl_stmt|;
comment|/*    **  Initialize the Compression routines    */
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: EOF / read error on image data\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|LWZReadByte
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: error while reading\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|frame_number
operator|==
literal|1
condition|)
block|{
name|image_ID
operator|=
name|gimp_image_new
argument_list|(
name|screenwidth
argument_list|,
name|screenheight
argument_list|,
name|INDEXED
argument_list|)
expr_stmt|;
name|gimp_image_set_filename
argument_list|(
name|image_ID
argument_list|,
name|filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|used_cmap
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|gimp_cmap
index|[
name|j
operator|++
index|]
operator|=
name|cmap
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
name|used_cmap
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|gimp_cmap
index|[
name|j
operator|++
index|]
operator|=
name|cmap
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
name|used_cmap
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
name|gimp_cmap
index|[
name|j
operator|++
index|]
operator|=
name|cmap
index|[
literal|2
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|gimp_image_set_cmap
argument_list|(
name|image_ID
argument_list|,
name|gimp_cmap
argument_list|,
name|ncols
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gif89
operator|.
name|delayTime
operator|<
literal|0
condition|)
name|strcpy
argument_list|(
name|framename
argument_list|,
literal|"Background"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|framename
argument_list|,
literal|"Background (%dms)"
argument_list|,
literal|10
operator|*
name|Gif89
operator|.
name|delayTime
argument_list|)
expr_stmt|;
name|previous_disposal
operator|=
name|Gif89
operator|.
name|disposal
expr_stmt|;
if|if
condition|(
name|Gif89
operator|.
name|transparent
operator|==
operator|-
literal|1
condition|)
block|{
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|framename
argument_list|,
name|len
argument_list|,
name|height
argument_list|,
name|INDEXED_IMAGE
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|framename
argument_list|,
name|len
argument_list|,
name|height
argument_list|,
name|INDEXEDA_IMAGE
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|alpha_frame
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
comment|/* NOT FIRST FRAME */
block|{
comment|/* If the colourmap is now different, we have to promote to 	 RGB! */
if|if
condition|(
operator|!
name|promote_to_rgb
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|used_cmap
index|[
literal|0
index|]
index|[
name|i
index|]
operator|!=
name|cmap
index|[
literal|0
index|]
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|used_cmap
index|[
literal|1
index|]
index|[
name|i
index|]
operator|!=
name|cmap
index|[
literal|1
index|]
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|used_cmap
index|[
literal|2
index|]
index|[
name|i
index|]
operator|!=
name|cmap
index|[
literal|2
index|]
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* Everything is RGB(A) from now on... sigh. */
name|promote_to_rgb
operator|=
name|TRUE
expr_stmt|;
comment|/* Promote everything we have so far into RGB(A) */
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_print
argument_list|(
literal|"GIF: Promoting image to RGB...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gimp_run_procedure
argument_list|(
literal|"gimp_convert_rgb"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|Gif89
operator|.
name|delayTime
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|framename
argument_list|,
literal|"Frame %d"
argument_list|,
name|frame_number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|framename
argument_list|,
literal|"Frame %d (%dms)"
argument_list|,
name|frame_number
argument_list|,
literal|10
operator|*
name|Gif89
operator|.
name|delayTime
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|previous_disposal
condition|)
block|{
case|case
literal|0x00
case|:
break|break;
comment|/* 'don't care' */
case|case
literal|0x01
case|:
name|strcat
argument_list|(
name|framename
argument_list|,
literal|" (combine)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|strcat
argument_list|(
name|framename
argument_list|,
literal|" (replace)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|strcat
argument_list|(
name|framename
argument_list|,
literal|" (combine)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
case|case
literal|0x05
case|:
case|case
literal|0x06
case|:
case|case
literal|0x07
case|:
name|strcat
argument_list|(
name|framename
argument_list|,
literal|" (unknown disposal)"
argument_list|)
expr_stmt|;
name|g_message
argument_list|(
literal|"GIF: Hmm... please forward this GIF to the "
literal|"GIF plugin author!\n  (adam@foxbox.org)\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_message
argument_list|(
literal|"GIF: Something got corrupted.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|previous_disposal
operator|=
name|Gif89
operator|.
name|disposal
expr_stmt|;
name|layer_ID
operator|=
name|gimp_layer_new
argument_list|(
name|image_ID
argument_list|,
name|framename
argument_list|,
name|len
argument_list|,
name|height
argument_list|,
name|promote_to_rgb
condition|?
name|RGBA_IMAGE
else|:
name|INDEXEDA_IMAGE
argument_list|,
literal|100
argument_list|,
name|NORMAL_MODE
argument_list|)
expr_stmt|;
name|alpha_frame
operator|=
name|TRUE
expr_stmt|;
block|}
name|frame_number
operator|++
expr_stmt|;
name|gimp_image_add_layer
argument_list|(
name|image_ID
argument_list|,
name|layer_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimp_layer_translate
argument_list|(
name|layer_ID
argument_list|,
operator|(
name|gint
operator|)
name|leftpos
argument_list|,
operator|(
name|gint
operator|)
name|toppos
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layer_ID
argument_list|)
expr_stmt|;
name|cur_progress
operator|=
literal|0
expr_stmt|;
name|max_progress
operator|=
name|height
expr_stmt|;
if|if
condition|(
name|alpha_frame
condition|)
name|dest
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|len
operator|*
name|height
operator|*
operator|(
name|promote_to_rgb
condition|?
literal|4
else|:
literal|2
operator|)
argument_list|)
expr_stmt|;
else|else
name|dest
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|len
operator|*
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|g_print
argument_list|(
literal|"GIF: reading %d by %d%s GIF image, ncols=%d\n"
argument_list|,
name|len
argument_list|,
name|height
argument_list|,
name|interlace
condition|?
literal|" interlaced"
else|:
literal|""
argument_list|,
name|ncols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alpha_frame
operator|&&
name|promote_to_rgb
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: Ouchie!  Can't handle non-alpha RGB frames.\n     Please mail the plugin author.  (adam@gimp.org)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|v
operator|=
name|LWZReadByte
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|,
name|c
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|alpha_frame
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|guchar
operator|)
name|v
operator|>
name|highest_used_index
operator|)
operator|&&
operator|!
operator|(
name|v
operator|==
name|Gif89
operator|.
name|transparent
operator|)
condition|)
name|highest_used_index
operator|=
operator|(
name|guchar
operator|)
name|v
expr_stmt|;
if|if
condition|(
name|promote_to_rgb
condition|)
block|{
name|temp
operator|=
name|dest
operator|+
operator|(
operator|(
name|ypos
operator|*
name|len
operator|)
operator|+
name|xpos
operator|)
operator|*
literal|4
expr_stmt|;
operator|*
operator|(
name|temp
operator|)
operator|=
operator|(
name|guchar
operator|)
name|cmap
index|[
literal|0
index|]
index|[
name|v
index|]
expr_stmt|;
operator|*
operator|(
name|temp
operator|+
literal|1
operator|)
operator|=
operator|(
name|guchar
operator|)
name|cmap
index|[
literal|1
index|]
index|[
name|v
index|]
expr_stmt|;
operator|*
operator|(
name|temp
operator|+
literal|2
operator|)
operator|=
operator|(
name|guchar
operator|)
name|cmap
index|[
literal|2
index|]
index|[
name|v
index|]
expr_stmt|;
operator|*
operator|(
name|temp
operator|+
literal|3
operator|)
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|(
name|v
operator|==
name|Gif89
operator|.
name|transparent
operator|)
condition|?
literal|0
else|:
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|dest
operator|+
operator|(
operator|(
name|ypos
operator|*
name|len
operator|)
operator|+
name|xpos
operator|)
operator|*
literal|2
expr_stmt|;
operator|*
name|temp
operator|=
operator|(
name|guchar
operator|)
name|v
expr_stmt|;
operator|*
operator|(
name|temp
operator|+
literal|1
operator|)
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|(
name|v
operator|==
name|Gif89
operator|.
name|transparent
operator|)
condition|?
literal|0
else|:
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|guchar
operator|)
name|v
operator|>
name|highest_used_index
condition|)
name|highest_used_index
operator|=
operator|(
name|guchar
operator|)
name|v
expr_stmt|;
name|temp
operator|=
name|dest
operator|+
operator|(
name|ypos
operator|*
name|len
operator|)
operator|+
name|xpos
expr_stmt|;
operator|*
name|temp
operator|=
operator|(
name|guchar
operator|)
name|v
expr_stmt|;
block|}
name|xpos
operator|++
expr_stmt|;
if|if
condition|(
name|xpos
operator|==
name|len
condition|)
block|{
name|xpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|interlace
condition|)
block|{
switch|switch
condition|(
name|pass
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ypos
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ypos
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ypos
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ypos
operator|>=
name|height
condition|)
block|{
name|pass
operator|++
expr_stmt|;
switch|switch
condition|(
name|pass
condition|)
block|{
case|case
literal|1
case|:
name|ypos
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ypos
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ypos
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|fini
goto|;
block|}
block|}
block|}
else|else
block|{
name|ypos
operator|++
expr_stmt|;
block|}
name|cur_progress
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cur_progress
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|cur_progress
operator|/
operator|(
name|double
operator|)
name|max_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ypos
operator|>=
name|height
condition|)
break|break;
block|}
name|fini
label|:
if|if
condition|(
name|LWZReadByte
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
condition|)
name|g_print
argument_list|(
literal|"GIF: too much input data, ignoring extra...\n"
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_set_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gimp_drawable_flush
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|image_ID
return|;
block|}
end_function

begin_comment
comment|/* ppmtogif.c - read a portable pixmap and produce a GIF file ** ** Based on GIFENCOD by David Rowley<mgardi@watdscu.waterloo.edu>.A ** Lempel-Zim compression based on "compress". ** ** Modified by Marcel Wijkstra<wijkstra@fwi.uva.nl> ** ** ** Copyright (C) 1989 by Jef Poskanzer. ** ** Permission to use, copy, modify, and distribute this software and its ** documentation for any purpose and without fee is hereby granted, provided ** that the above copyright notice appear in all copies and that both that ** copyright notice and this permission notice appear in supporting ** documentation.  This software is provided "as is" without express or ** implied warranty. ** ** The Graphics Interchange Format(c) is the Copyright property of ** CompuServe Incorporated.  GIF(sm) is a Service Mark property of ** CompuServe Incorporated. */
end_comment

begin_define
DECL|macro|MAXCOLORS
define|#
directive|define
name|MAXCOLORS
value|256
end_define

begin_comment
comment|/*  * Pointer to function returning an int  */
end_comment

begin_typedef
DECL|typedef|ifunptr
typedef|typedef
name|int
function_decl|(
modifier|*
name|ifunptr
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * a code_int must be able to hold 2**BITS values of type int, and also -1  */
end_comment

begin_typedef
DECL|typedef|code_int
typedef|typedef
name|int
name|code_int
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
end_ifdef

begin_typedef
DECL|typedef|count_int
typedef|typedef
name|unsigned
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_typedef
DECL|typedef|count_short
typedef|typedef
name|unsigned
name|short
name|int
name|count_short
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*SIGNED_COMPARE_SLOW */
end_comment

begin_typedef
DECL|typedef|count_int
typedef|typedef
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SIGNED_COMPARE_SLOW */
end_comment

begin_function_decl
specifier|static
name|int
name|find_unused_ia_colour
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
name|numpixels
parameter_list|,
name|int
name|num_indices
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|special_flatten_indexed_alpha
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
modifier|*
name|transparent
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|,
name|int
name|numpixels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|colorstobpp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpptocolors
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GetPixel
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|BumpPixel
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|GIFNextPixel
parameter_list|(
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeHeader
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|gboolean
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeGraphicControlExt
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeImageData
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifunptr
parameter_list|,
name|gint
parameter_list|,
name|gint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeClose
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeLoopExt
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|guint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|GIFEncodeCommentExt
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|rowstride
name|int
name|rowstride
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|pixels
name|guchar
modifier|*
name|pixels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_progress
name|int
name|cur_progress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|max_progress
name|int
name|max_progress
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|Putword
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|ifunptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output
parameter_list|(
name|code_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cl_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cl_hash
parameter_list|(
name|count_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeerr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|char_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|char_out
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_char
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
DECL|function|find_unused_ia_colour (guchar * pixels,int numpixels,int num_indices,int * colors)
specifier|static
name|int
name|find_unused_ia_colour
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
name|numpixels
parameter_list|,
name|int
name|num_indices
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gboolean
name|ix_used
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_print
argument_list|(
literal|"GIF: fuiac: Image claims to use %d/%d indices - finding free "
literal|"index...\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|colors
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|num_indices
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|ix_used
index|[
name|i
index|]
operator|=
operator|(
name|gboolean
operator|)
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
condition|)
name|ix_used
index|[
name|pixels
index|[
name|i
operator|*
literal|2
index|]
index|]
operator|=
operator|(
name|gboolean
operator|)
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|num_indices
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ix_used
index|[
name|i
index|]
operator|==
operator|(
name|gboolean
operator|)
name|FALSE
condition|)
block|{
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_print
argument_list|(
literal|"GIF: Found unused colour index %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|i
return|;
block|}
block|}
comment|/* Couldn't find an unused colour index within the number of      bits per pixel we wanted.  Will have to increment the number      of colours in the image and assign a transparent pixel there. */
if|if
condition|(
operator|(
operator|*
name|colors
operator|)
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|colors
operator|)
operator|++
expr_stmt|;
name|g_print
argument_list|(
literal|"GIF: 2nd pass - Increasing bounds and using colour index %d.\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|colors
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|colors
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|g_message
argument_list|(
literal|"GIF: Couldn't simply reduce colours further.  Saving as opaque.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
DECL|function|special_flatten_indexed_alpha (guchar * pixels,int * transparent,int * colors,int numpixels)
name|special_flatten_indexed_alpha
parameter_list|(
name|guchar
modifier|*
name|pixels
parameter_list|,
name|int
modifier|*
name|transparent
parameter_list|,
name|int
modifier|*
name|colors
parameter_list|,
name|int
name|numpixels
parameter_list|)
block|{
name|guint32
name|i
decl_stmt|;
comment|/* Each transparent pixel in the image is mapped to a uniform value for      encoding, if image already has<=255 colours */
if|if
condition|(
operator|(
operator|*
name|transparent
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* tough, no indices left for the trans. index */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
name|pixels
index|[
name|i
index|]
operator|=
name|pixels
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
else|else
comment|/* make transparent */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numpixels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|pixels
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|&
literal|128
operator|)
condition|)
block|{
name|pixels
index|[
name|i
index|]
operator|=
call|(
name|guchar
call|)
argument_list|(
operator|*
name|transparent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pixels
index|[
name|i
index|]
operator|=
name|pixels
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Pixel data now takes half as much space (the alpha data has been      discarded) */
comment|/*  pixels = g_realloc (pixels, numpixels);*/
block|}
end_function

begin_function
name|int
DECL|function|parse_ms_tag (char * str)
name|parse_ms_tag
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|gint
name|sum
init|=
literal|0
decl_stmt|;
name|gint
name|offset
init|=
literal|0
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|find_another_bra
label|:
while|while
condition|(
operator|(
name|offset
operator|<
name|length
operator|)
operator|&&
operator|(
name|str
index|[
name|offset
index|]
operator|!=
literal|'('
operator|)
condition|)
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|length
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|str
index|[
operator|++
name|offset
index|]
argument_list|)
condition|)
goto|goto
name|find_another_bra
goto|;
do|do
block|{
name|sum
operator|*=
literal|10
expr_stmt|;
name|sum
operator|+=
name|str
index|[
name|offset
index|]
operator|-
literal|'0'
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|offset
operator|<
name|length
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|str
index|[
name|offset
index|]
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|length
operator|-
name|offset
operator|<=
literal|2
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
if|if
condition|(
operator|(
name|toupper
argument_list|(
name|str
index|[
name|offset
index|]
argument_list|)
operator|!=
literal|'M'
operator|)
operator|||
operator|(
name|toupper
argument_list|(
name|str
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|'S'
operator|)
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
name|int
DECL|function|parse_disposal_tag (char * str)
name|parse_disposal_tag
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|gint
name|offset
init|=
literal|0
decl_stmt|;
name|gint
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|offset
operator|+
literal|9
operator|)
operator|<=
name|length
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|offset
index|]
argument_list|,
literal|"(combine)"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0x01
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|offset
index|]
argument_list|,
literal|"(replace)"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0x02
operator|)
return|;
name|offset
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|gsvals
operator|.
name|default_dispose
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|boundscheck (gint32 image_ID)
name|boundscheck
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|gint32
modifier|*
name|layers
decl_stmt|;
name|gint
name|nlayers
decl_stmt|;
name|gint
name|nreturn_vals
decl_stmt|;
name|gint
name|i
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
comment|/* get a list of layers for this image_ID */
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
comment|/*** Iterate through the layers to make sure they're all ***/
comment|/*** within the bounds of the image                      ***/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlayers
condition|;
name|i
operator|++
control|)
block|{
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset_x
operator|<
literal|0
operator|)
operator|||
operator|(
name|offset_y
operator|<
literal|0
operator|)
operator|||
operator|(
name|offset_x
operator|+
name|drawable
operator|->
name|width
operator|>
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
operator|)
operator|||
operator|(
name|offset_y
operator|+
name|drawable
operator|->
name|height
operator|>
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
operator|)
condition|)
block|{
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
comment|/* Image has illegal bounds - ask the user what it wants to do */
if|if
condition|(
name|badbounds_dialog
argument_list|()
condition|)
block|{
name|gimp_run_procedure
argument_list|(
literal|"gimp_crop"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_IMAGE
argument_list|,
name|image_ID
argument_list|,
name|PARAM_INT32
argument_list|,
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
argument_list|,
name|PARAM_INT32
argument_list|,
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
argument_list|,
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
name|PARAM_INT32
argument_list|,
literal|0
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
else|else
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_image (char * filename,gint32 image_ID,gint32 drawable_ID)
name|save_image
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|gint32
name|image_ID
parameter_list|,
name|gint32
name|drawable_ID
parameter_list|)
block|{
name|GPixelRgn
name|pixel_rgn
decl_stmt|;
name|GDrawable
modifier|*
name|drawable
decl_stmt|;
name|GDrawableType
name|drawable_type
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|Red
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|int
name|Green
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|int
name|Blue
index|[
name|MAXCOLORS
index|]
decl_stmt|;
name|guchar
modifier|*
name|cmap
decl_stmt|;
name|guint
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|int
name|BitsPerPixel
decl_stmt|,
name|liberalBPP
init|=
literal|0
decl_stmt|,
name|useBPP
init|=
literal|0
decl_stmt|;
name|int
name|colors
decl_stmt|;
name|char
modifier|*
name|temp_buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|transparent
decl_stmt|;
name|gint
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|gint32
modifier|*
name|layers
decl_stmt|;
name|int
name|nlayers
decl_stmt|;
name|gboolean
name|is_gif89
init|=
name|FALSE
decl_stmt|;
name|int
name|Delay89
decl_stmt|;
name|int
name|Disposal
decl_stmt|;
name|char
modifier|*
name|layer_name
decl_stmt|;
name|unsigned
name|char
name|bgred
decl_stmt|,
name|bggreen
decl_stmt|,
name|bgblue
decl_stmt|;
comment|/* get a list of layers for this image_ID */
name|layers
operator|=
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|layers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If the image has multiple layers (i.e. will be animated), a comment,      or transparency, then it must be encoded as a GIF89a file, not a vanilla      GIF87a. */
if|if
condition|(
name|nlayers
operator|>
literal|1
condition|)
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|globalusecomment
condition|)
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|drawable_type
condition|)
block|{
case|case
name|INDEXEDA_IMAGE
case|:
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
case|case
name|INDEXED_IMAGE
case|:
name|cmap
operator|=
name|gimp_image_get_cmap
argument_list|(
name|image_ID
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|gimp_palette_get_background
argument_list|(
operator|&
name|bgred
argument_list|,
operator|&
name|bggreen
argument_list|,
operator|&
name|bgblue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
name|Green
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
name|Blue
index|[
name|i
index|]
operator|=
operator|*
name|cmap
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
name|bgred
expr_stmt|;
name|Green
index|[
name|i
index|]
operator|=
name|bggreen
expr_stmt|;
name|Blue
index|[
name|i
index|]
operator|=
name|bgblue
expr_stmt|;
block|}
break|break;
case|case
name|GRAYA_IMAGE
case|:
name|is_gif89
operator|=
name|TRUE
expr_stmt|;
case|case
name|GRAY_IMAGE
case|:
name|colors
operator|=
literal|256
expr_stmt|;
comment|/* FIXME: Not ideal. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|Red
index|[
name|i
index|]
operator|=
name|Green
index|[
name|i
index|]
operator|=
name|Blue
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
break|break;
default|default:
name|g_message
argument_list|(
literal|"GIF: Sorry, can't save RGB images as GIFs - convert to INDEXED\nor GRAY first.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
break|break;
block|}
comment|/* init the progress meter */
name|temp_buf
operator|=
name|g_malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp_buf
argument_list|,
literal|"Saving %s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|gimp_progress_init
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|temp_buf
argument_list|)
expr_stmt|;
comment|/* open the destination file for writing */
name|outfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF: can't open %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* write the GIFheader */
if|if
condition|(
name|colors
operator|<
literal|256
condition|)
block|{
comment|/* we keep track of how many bits we promised to have in liberalBPP, 	 so that we don't accidentally come under this when doing 	 clever transparency stuff where we can re-use wasted indices. */
name|liberalBPP
operator|=
name|BitsPerPixel
operator|=
name|colorstobpp
argument_list|(
name|colors
operator|+
operator|(
operator|(
name|drawable_type
operator|==
name|INDEXEDA_IMAGE
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|liberalBPP
operator|=
name|BitsPerPixel
operator|=
name|colorstobpp
argument_list|(
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawable_type
operator|==
name|INDEXEDA_IMAGE
condition|)
block|{
name|g_print
argument_list|(
literal|"GIF: Too many colours?\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cols
operator|=
name|gimp_image_width
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|rows
operator|=
name|gimp_image_height
argument_list|(
name|image_ID
argument_list|)
expr_stmt|;
name|Interlace
operator|=
name|gsvals
operator|.
name|interlace
expr_stmt|;
name|GIFEncodeHeader
argument_list|(
name|outfile
argument_list|,
name|is_gif89
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
literal|0
argument_list|,
name|BitsPerPixel
argument_list|,
name|Red
argument_list|,
name|Green
argument_list|,
name|Blue
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
comment|/* If the image has multiple layers it'll be made into an      animated GIF, so write out the infinite-looping extension */
if|if
condition|(
operator|(
name|nlayers
operator|>
literal|1
operator|)
operator|&&
operator|(
name|gsvals
operator|.
name|loop
operator|)
condition|)
name|GIFEncodeLoopExt
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write comment extension - mustn't be written before the looping ext. */
if|if
condition|(
name|globalusecomment
condition|)
block|{
name|GIFEncodeCommentExt
argument_list|(
name|outfile
argument_list|,
name|globalcomment
argument_list|)
expr_stmt|;
block|}
comment|/*** Now for each layer in the image, save an image in a compound GIF ***/
comment|/************************************************************************/
name|i
operator|=
name|nlayers
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|drawable_type
operator|=
name|gimp_drawable_type
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|drawable
operator|=
name|gimp_drawable_get
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gimp_drawable_offsets
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|)
expr_stmt|;
name|cols
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|rows
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|rowstride
operator|=
name|drawable
operator|->
name|width
expr_stmt|;
name|gimp_pixel_rgn_init
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|drawable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cur_progress
operator|=
literal|0
expr_stmt|;
name|max_progress
operator|=
name|drawable
operator|->
name|height
expr_stmt|;
name|pixels
operator|=
operator|(
name|guchar
operator|*
operator|)
name|g_malloc
argument_list|(
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
operator|*
operator|(
operator|(
operator|(
name|drawable_type
operator|==
name|INDEXEDA_IMAGE
operator|)
operator|||
operator|(
name|drawable_type
operator|==
name|GRAYA_IMAGE
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|gimp_pixel_rgn_get_rect
argument_list|(
operator|&
name|pixel_rgn
argument_list|,
name|pixels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|drawable
operator|->
name|width
argument_list|,
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* sort out whether we need to do transparency jiggery-pokery */
if|if
condition|(
operator|(
name|drawable_type
operator|==
name|INDEXEDA_IMAGE
operator|)
operator|||
operator|(
name|drawable_type
operator|==
name|GRAYA_IMAGE
operator|)
condition|)
block|{
comment|/* Try to find an entry which isn't actually used in the 	     image, for a transparency index. */
name|transparent
operator|=
name|find_unused_ia_colour
argument_list|(
name|pixels
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
argument_list|,
name|bpptocolors
argument_list|(
name|colorstobpp
argument_list|(
name|colors
argument_list|)
argument_list|)
argument_list|,
operator|&
name|colors
argument_list|)
expr_stmt|;
name|special_flatten_indexed_alpha
argument_list|(
name|pixels
argument_list|,
operator|&
name|transparent
argument_list|,
operator|&
name|colors
argument_list|,
name|drawable
operator|->
name|width
operator|*
name|drawable
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
else|else
name|transparent
operator|=
operator|-
literal|1
expr_stmt|;
name|BitsPerPixel
operator|=
name|colorstobpp
argument_list|(
name|colors
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitsPerPixel
operator|!=
name|liberalBPP
condition|)
block|{
comment|/* We were able to re-use an index within the existing bitspace, 	     whereas the estimate in the header was pessimistic but still 	     needs to be upheld... */
ifdef|#
directive|ifdef
name|GIFDEBUG
name|g_warning
argument_list|(
literal|"Promised %d bpp, pondered writing chunk with %d bpp!\n"
argument_list|,
name|liberalBPP
argument_list|,
name|BitsPerPixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_warning
argument_list|(
literal|"Transparent colour may be incorrect on viewers which"
literal|" don't support transparency.\n"
argument_list|)
expr_stmt|;
block|}
name|useBPP
operator|=
operator|(
name|BitsPerPixel
operator|>
name|liberalBPP
operator|)
condition|?
name|BitsPerPixel
else|:
name|liberalBPP
expr_stmt|;
if|if
condition|(
name|is_gif89
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|layer_name
operator|=
name|gimp_layer_get_name
argument_list|(
name|layers
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|Disposal
operator|=
name|parse_disposal_tag
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
block|}
else|else
name|Disposal
operator|=
name|gsvals
operator|.
name|default_dispose
expr_stmt|;
name|layer_name
operator|=
name|gimp_layer_get_name
argument_list|(
name|layers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Delay89
operator|=
name|parse_ms_tag
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|layer_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delay89
operator|<
literal|0
condition|)
name|Delay89
operator|=
name|gsvals
operator|.
name|default_delay
operator|/
literal|10
expr_stmt|;
else|else
name|Delay89
operator|/=
literal|10
expr_stmt|;
name|GIFEncodeGraphicControlExt
argument_list|(
name|outfile
argument_list|,
name|Disposal
argument_list|,
name|Delay89
argument_list|,
name|nlayers
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
literal|0
argument_list|,
name|transparent
argument_list|,
name|useBPP
argument_list|,
name|Red
argument_list|,
name|Green
argument_list|,
name|Blue
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
block|}
name|GIFEncodeImageData
argument_list|(
name|outfile
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
operator|(
name|rows
operator|>
literal|4
operator|)
condition|?
name|gsvals
operator|.
name|interlace
else|:
literal|0
argument_list|,
literal|0
argument_list|,
name|transparent
argument_list|,
name|useBPP
argument_list|,
name|Red
argument_list|,
name|Green
argument_list|,
name|Blue
argument_list|,
name|GetPixel
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|)
expr_stmt|;
name|gimp_drawable_detach
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|g_free
argument_list|(
name|layers
argument_list|)
expr_stmt|;
name|GIFEncodeClose
argument_list|(
name|outfile
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|gsvals
operator|.
name|interlace
argument_list|,
literal|0
argument_list|,
name|transparent
argument_list|,
name|useBPP
argument_list|,
name|Red
argument_list|,
name|Green
argument_list|,
name|Blue
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|gboolean
DECL|function|badbounds_dialog (void)
name|badbounds_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|can_crop
operator|=
name|FALSE
expr_stmt|;
name|dlg
operator|=
name|gtk_dialog_new
argument_list|()
expr_stmt|;
name|gtk_window_set_title
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"GIF Warning"
argument_list|)
expr_stmt|;
name|gtk_window_position
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|cropclose_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"delete_event"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|cropclose_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
comment|/*  Action area  */
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Crop"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|cropok_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_grab_default
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|cropcancel_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
comment|/*  gtk_signal_connect_object (GTK_OBJECT (button), "clicked", 			     (GtkSignalFunc) gtk_widget_destroy, 			     GTK_OBJECT (dlg)); 			     */
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
comment|/*  the warning message  */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"The image which you are trying to save as a GIF\n"
literal|"contains layers which extend beyond the actual\n"
literal|"borders of the image.  This isn't allowed in GIFs,\n"
literal|"I'm afraid.\n\n"
literal|"You may choose whether to crop all of the layers to\n"
literal|"the image borders, or cancel this save."
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|dlg
argument_list|)
argument_list|)
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|can_crop
return|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|save_dialog (gint32 image_ID)
name|save_dialog
parameter_list|(
name|gint32
name|image_ID
parameter_list|)
block|{
name|GtkWidget
modifier|*
name|dlg
decl_stmt|;
name|GtkWidget
modifier|*
name|button
decl_stmt|;
name|GtkWidget
modifier|*
name|toggle
decl_stmt|;
name|GtkWidget
modifier|*
name|label
decl_stmt|;
name|GtkWidget
modifier|*
name|entry
decl_stmt|;
name|GtkWidget
modifier|*
name|text
decl_stmt|;
name|GtkWidget
modifier|*
name|frame
decl_stmt|;
name|GtkWidget
modifier|*
name|vbox
decl_stmt|;
name|GtkWidget
modifier|*
name|hbox
decl_stmt|;
name|GtkWidget
modifier|*
name|menu
decl_stmt|;
name|GtkWidget
modifier|*
name|disposal_option_menu
decl_stmt|;
name|GtkWidget
modifier|*
name|com_table
decl_stmt|;
name|GtkWidget
modifier|*
name|vscrollbar
decl_stmt|;
ifdef|#
directive|ifdef
name|FACEHUGGERS
name|Parasite
modifier|*
name|GIF2_CMNT
decl_stmt|;
endif|#
directive|endif
name|gchar
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|gint32
name|nlayers
decl_stmt|;
name|gimp_image_get_layers
argument_list|(
name|image_ID
argument_list|,
operator|&
name|nlayers
argument_list|)
expr_stmt|;
name|dlg
operator|=
name|gtk_dialog_new
argument_list|()
expr_stmt|;
name|gtk_window_set_title
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"Save as GIF"
argument_list|)
expr_stmt|;
name|gtk_window_position
argument_list|(
name|GTK_WINDOW
argument_list|(
name|dlg
argument_list|)
argument_list|,
name|GTK_WIN_POS_MOUSE
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"destroy"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_close_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|dlg
argument_list|)
argument_list|,
literal|"delete_event"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_windelete_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
comment|/*  Action area  */
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_ok_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_grab_default
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|button
operator|=
name|gtk_button_new_with_label
argument_list|(
literal|"Cancel"
argument_list|)
expr_stmt|;
name|GTK_WIDGET_SET_FLAGS
argument_list|(
name|button
argument_list|,
name|GTK_CAN_DEFAULT
argument_list|)
expr_stmt|;
comment|/*  gtk_signal_connect_object (GTK_OBJECT (button), "clicked", 			     (GtkSignalFunc) gtk_widget_destroy, 			     GTK_OBJECT (dlg)); */
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|button
argument_list|)
argument_list|,
literal|"clicked"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_cancel_callback
argument_list|,
name|dlg
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|action_area
argument_list|)
argument_list|,
name|button
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|button
argument_list|)
expr_stmt|;
comment|/*  regular gif parameter settings  */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"GIF Options"
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Interlace"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_toggle_update
argument_list|,
operator|&
name|gsvals
operator|.
name|interlace
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|gsvals
operator|.
name|interlace
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|hbox
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"GIF Comment: "
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_toggle_update
argument_list|,
operator|&
name|globalusecomment
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
name|com_table
operator|=
name|gtk_table_new
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  gtk_container_border_width (GTK_CONTAINER (com_table), 10);*/
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|com_table
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text
operator|=
name|gtk_text_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_text_set_editable
argument_list|(
name|GTK_TEXT
argument_list|(
name|text
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|text
argument_list|,
literal|80
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|com_table
argument_list|)
argument_list|,
name|text
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_SHRINK
operator||
name|GTK_FILL
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_SHRINK
operator||
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|globalcomment
operator|!=
name|NULL
condition|)
block|{
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FACEHUGGERS
name|GIF2_CMNT
operator|=
name|gimp_image_find_parasite
argument_list|(
name|image_ID
argument_list|,
literal|"gimp-comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIF2_CMNT
condition|)
block|{
name|globalcomment
operator|=
name|g_malloc
argument_list|(
name|GIF2_CMNT
operator|->
name|size
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|globalcomment
argument_list|,
name|GIF2_CMNT
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|globalcomment
operator|=
name|g_malloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|DEFAULT_COMMENT
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|globalcomment
argument_list|,
name|DEFAULT_COMMENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FACEHUGGERS
block|}
name|parasite_free
argument_list|(
name|GIF2_CMNT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gtk_text_insert
argument_list|(
name|GTK_TEXT
argument_list|(
name|text
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|globalcomment
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|text
argument_list|)
argument_list|,
literal|"changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|comment_entry_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vscrollbar
operator|=
name|gtk_vscrollbar_new
argument_list|(
name|GTK_TEXT
argument_list|(
name|text
argument_list|)
operator|->
name|vadj
argument_list|)
expr_stmt|;
name|gtk_table_attach
argument_list|(
name|GTK_TABLE
argument_list|(
name|com_table
argument_list|)
argument_list|,
name|vscrollbar
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|GTK_FILL
argument_list|,
name|GTK_EXPAND
operator||
name|GTK_SHRINK
operator||
name|GTK_FILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vscrollbar
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|com_table
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/*  additional animated gif parameter settings  */
name|frame
operator|=
name|gtk_frame_new
argument_list|(
literal|"Animated GIF Options"
argument_list|)
expr_stmt|;
name|gtk_frame_set_shadow_type
argument_list|(
name|GTK_FRAME
argument_list|(
name|frame
argument_list|)
argument_list|,
name|GTK_SHADOW_ETCHED_IN
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|GTK_DIALOG
argument_list|(
name|dlg
argument_list|)
operator|->
name|vbox
argument_list|)
argument_list|,
name|frame
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbox
operator|=
name|gtk_vbox_new
argument_list|(
name|FALSE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_border_width
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|vbox
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|frame
argument_list|)
argument_list|,
name|vbox
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|gtk_check_button_new_with_label
argument_list|(
literal|"Loop forever"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|toggle
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|toggle
argument_list|)
argument_list|,
literal|"toggled"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_toggle_update
argument_list|,
operator|&
name|gsvals
operator|.
name|loop
argument_list|)
expr_stmt|;
name|gtk_toggle_button_set_active
argument_list|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|toggle
argument_list|)
argument_list|,
name|gsvals
operator|.
name|loop
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|toggle
argument_list|)
expr_stmt|;
comment|/* default_delay entry field */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Delay between frames where unspecified: "
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|entry
operator|=
name|gtk_entry_new
argument_list|()
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|entry
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_set_usize
argument_list|(
name|entry
argument_list|,
literal|80
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|gsvals
operator|.
name|default_delay
argument_list|)
expr_stmt|;
name|gtk_entry_set_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|"changed"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|save_entry_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|" milliseconds"
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
comment|/* Disposal selector */
name|hbox
operator|=
name|gtk_hbox_new
argument_list|(
name|FALSE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|vbox
argument_list|)
argument_list|,
name|hbox
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gtk_label_new
argument_list|(
literal|"Frame disposal where unspecified: "
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|label
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|disposal_option_menu
operator|=
name|gtk_option_menu_new
argument_list|()
expr_stmt|;
block|{
name|GtkWidget
modifier|*
name|menu_item
decl_stmt|;
name|menu
operator|=
name|gtk_menu_new
argument_list|()
expr_stmt|;
block|{
name|menu_item
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
literal|"I don't care"
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|menu_item
argument_list|)
argument_list|,
literal|"activate"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|disposal_select_callback
argument_list|,
operator|&
name|radio_pressed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|menu
argument_list|)
argument_list|,
name|menu_item
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|menu_item
argument_list|)
expr_stmt|;
name|menu_item
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
literal|"Cumulative layers (combine)"
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|menu_item
argument_list|)
argument_list|,
literal|"activate"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|disposal_select_callback
argument_list|,
operator|&
name|radio_pressed
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|menu
argument_list|)
argument_list|,
name|menu_item
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|menu_item
argument_list|)
expr_stmt|;
name|menu_item
operator|=
name|gtk_menu_item_new_with_label
argument_list|(
literal|"One frame per layer (replace)"
argument_list|)
expr_stmt|;
name|gtk_signal_connect
argument_list|(
name|GTK_OBJECT
argument_list|(
name|menu_item
argument_list|)
argument_list|,
literal|"activate"
argument_list|,
operator|(
name|GtkSignalFunc
operator|)
name|disposal_select_callback
argument_list|,
operator|&
name|radio_pressed
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gtk_container_add
argument_list|(
name|GTK_CONTAINER
argument_list|(
name|menu
argument_list|)
argument_list|,
name|menu_item
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|menu_item
argument_list|)
expr_stmt|;
block|}
block|}
name|gtk_option_menu_set_menu
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|disposal_option_menu
argument_list|)
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|gtk_option_menu_set_history
argument_list|(
name|GTK_OPTION_MENU
argument_list|(
name|disposal_option_menu
argument_list|)
argument_list|,
name|gsvals
operator|.
name|default_dispose
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|disposal_option_menu
argument_list|)
expr_stmt|;
name|gtk_box_pack_start
argument_list|(
name|GTK_BOX
argument_list|(
name|hbox
argument_list|)
argument_list|,
name|disposal_option_menu
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|hbox
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|vbox
argument_list|)
expr_stmt|;
comment|/* If the image has only one layer it can't be animated, so      desensitize the animation options. */
if|if
condition|(
name|nlayers
operator|==
literal|1
condition|)
name|gtk_widget_set_sensitive
argument_list|(
name|frame
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gtk_widget_show
argument_list|(
name|dlg
argument_list|)
expr_stmt|;
name|gtk_main
argument_list|()
expr_stmt|;
name|gdk_flush
argument_list|()
expr_stmt|;
return|return
name|gsint
operator|.
name|run
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|colorstobpp (int colors)
name|colorstobpp
parameter_list|(
name|int
name|colors
parameter_list|)
block|{
name|int
name|bpp
decl_stmt|;
if|if
condition|(
name|colors
operator|<=
literal|2
condition|)
name|bpp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|4
condition|)
name|bpp
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|8
condition|)
name|bpp
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|16
condition|)
name|bpp
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|32
condition|)
name|bpp
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|64
condition|)
name|bpp
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|128
condition|)
name|bpp
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|colors
operator|<=
literal|256
condition|)
name|bpp
operator|=
literal|8
expr_stmt|;
else|else
block|{
name|g_warning
argument_list|(
literal|"GIF: colorstobpp - Eep! too many colours: %d\n"
argument_list|,
name|colors
argument_list|)
expr_stmt|;
return|return
literal|8
return|;
block|}
return|return
name|bpp
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|bpptocolors (int bpp)
name|bpptocolors
parameter_list|(
name|int
name|bpp
parameter_list|)
block|{
name|int
name|colors
decl_stmt|;
if|if
condition|(
name|bpp
operator|>
literal|8
condition|)
block|{
name|g_warning
argument_list|(
literal|"GIF: bpptocolors - Eep! bpp==%d !\n"
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
return|return
literal|256
return|;
block|}
name|colors
operator|=
literal|1
operator|<<
name|bpp
expr_stmt|;
return|return
operator|(
name|colors
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
DECL|function|GetPixel (int x,int y)
name|GetPixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
operator|*
operator|(
name|pixels
operator|+
operator|(
name|rowstride
operator|*
operator|(
name|long
operator|)
name|y
operator|)
operator|+
operator|(
name|long
operator|)
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * GIFENCODE.C    - GIF Image compression interface  *  * GIFEncode( FName, GHeight, GWidth, GInterlace, Background, Transparent,  *            BitsPerPixel, Red, Green, Blue, GetPixel )  *  *****************************************************************************/
end_comment

begin_decl_stmt
DECL|variable|Width
DECL|variable|Height
specifier|static
name|int
name|Width
decl_stmt|,
name|Height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|curx
DECL|variable|cury
specifier|static
name|int
name|curx
decl_stmt|,
name|cury
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|CountDown
specifier|static
name|long
name|CountDown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|Pass
specifier|static
name|int
name|Pass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Bump the 'curx' and 'cury' to point to the next pixel  */
end_comment

begin_function
specifier|static
name|void
DECL|function|BumpPixel ()
name|BumpPixel
parameter_list|()
block|{
comment|/*    * Bump the current X position    */
name|curx
operator|++
expr_stmt|;
comment|/*    * If we are at the end of a scan line, set curx back to the beginning    * If we are interlaced, bump the cury to the appropriate spot,    * otherwise, just increment it.    */
if|if
condition|(
name|curx
operator|==
name|Width
condition|)
block|{
name|cur_progress
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cur_progress
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|gimp_progress_update
argument_list|(
operator|(
name|double
operator|)
name|cur_progress
operator|/
operator|(
name|double
operator|)
name|max_progress
argument_list|)
expr_stmt|;
name|curx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Interlace
condition|)
operator|++
name|cury
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|Pass
condition|)
block|{
case|case
literal|0
case|:
name|cury
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|cury
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|cury
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|cury
operator|>=
name|Height
condition|)
block|{
name|Pass
operator|++
expr_stmt|;
name|cury
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|cury
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the next pixel from the image  */
end_comment

begin_function
specifier|static
name|int
DECL|function|GIFNextPixel (ifunptr getpixel)
name|GIFNextPixel
parameter_list|(
name|ifunptr
name|getpixel
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|CountDown
operator|==
literal|0
condition|)
return|return
name|EOF
return|;
operator|--
name|CountDown
expr_stmt|;
name|r
operator|=
call|(
modifier|*
name|getpixel
call|)
argument_list|(
name|curx
argument_list|,
name|cury
argument_list|)
expr_stmt|;
name|BumpPixel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* public */
end_comment

begin_function
specifier|static
name|void
DECL|function|GIFEncodeHeader (FILE * fp,gboolean gif89,int GWidth,int GHeight,int Background,int BitsPerPixel,int Red[],int Green[],int Blue[],ifunptr GetPixel)
name|GIFEncodeHeader
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|gboolean
name|gif89
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|Background
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|int
name|Red
index|[]
parameter_list|,
name|int
name|Green
index|[]
parameter_list|,
name|int
name|Blue
index|[]
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|)
block|{
name|int
name|B
decl_stmt|;
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
name|TopOfs
operator|=
literal|0
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write the Magic header    */
name|fwrite
argument_list|(
name|gif89
condition|?
literal|"GIF89a"
else|:
literal|"GIF87a"
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the screen width and height    */
name|Putword
argument_list|(
name|RWidth
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|RHeight
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Indicate that there is a global colour map    */
name|B
operator|=
literal|0x80
expr_stmt|;
comment|/* Yes, there is a color map */
comment|/*    * OR in the resolution    */
name|B
operator||=
operator|(
name|Resolution
operator|-
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
comment|/*    * OR in the Bits per Pixel    */
name|B
operator||=
operator|(
name|BitsPerPixel
operator|-
literal|1
operator|)
expr_stmt|;
comment|/*    * Write it out    */
name|fputc
argument_list|(
name|B
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the Background colour    */
name|fputc
argument_list|(
name|Background
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Byte of 0's (future expansion)    */
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the Global Colour Map    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ColorMapSize
condition|;
name|i
operator|++
control|)
block|{
name|fputc
argument_list|(
name|Red
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Green
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Blue
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeGraphicControlExt (FILE * fp,int Disposal,int Delay89,int NumFramesInImage,int GWidth,int GHeight,int Background,int Transparent,int BitsPerPixel,int Red[],int Green[],int Blue[],ifunptr GetPixel)
name|GIFEncodeGraphicControlExt
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|Disposal
parameter_list|,
name|int
name|Delay89
parameter_list|,
name|int
name|NumFramesInImage
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|Background
parameter_list|,
name|int
name|Transparent
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|int
name|Red
index|[]
parameter_list|,
name|int
name|Green
index|[]
parameter_list|,
name|int
name|Blue
index|[]
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|)
block|{
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
name|TopOfs
operator|=
literal|0
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
comment|/*    * Write out extension for transparent colour index, if necessary.    */
if|if
condition|(
operator|(
name|Transparent
operator|>=
literal|0
operator|)
operator|||
operator|(
name|NumFramesInImage
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* Extension Introducer - fixed. */
name|fputc
argument_list|(
literal|'!'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Graphic Control Label - fixed. */
name|fputc
argument_list|(
literal|0xf9
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Block Size - fixed. */
name|fputc
argument_list|(
literal|4
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Packed Fields - XXXdddut (d=disposal, u=userInput, t=transFlag) */
comment|/*                    s8421                                        */
name|fputc
argument_list|(
operator|(
operator|(
name|Transparent
operator|>=
literal|0
operator|)
condition|?
literal|0x01
else|:
literal|0x00
operator|)
comment|/* TRANSPARENCY */
comment|/* DISPOSAL */
operator||
operator|(
operator|(
name|NumFramesInImage
operator|>
literal|1
operator|)
condition|?
operator|(
name|Disposal
operator|<<
literal|2
operator|)
else|:
literal|0x00
operator|)
argument_list|,
comment|/* 0x03 or 0x01 build frames cumulatively */
comment|/* 0x02 clears frame before drawing */
comment|/* 0x00 'don't care' */
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Delay89
operator|&
literal|255
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|Delay89
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|Transparent
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeImageData (FILE * fp,int GWidth,int GHeight,int GInterlace,int Background,int Transparent,int BitsPerPixel,int Red[],int Green[],int Blue[],ifunptr GetPixel,gint offset_x,gint offset_y)
name|GIFEncodeImageData
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|GInterlace
parameter_list|,
name|int
name|Background
parameter_list|,
name|int
name|Transparent
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|int
name|Red
index|[]
parameter_list|,
name|int
name|Green
index|[]
parameter_list|,
name|int
name|Blue
index|[]
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|,
name|gint
name|offset_x
parameter_list|,
name|gint
name|offset_y
parameter_list|)
block|{
name|int
name|RWidth
decl_stmt|,
name|RHeight
decl_stmt|;
name|int
name|LeftOfs
decl_stmt|,
name|TopOfs
decl_stmt|;
name|int
name|Resolution
decl_stmt|;
name|int
name|ColorMapSize
decl_stmt|;
name|int
name|InitCodeSize
decl_stmt|;
name|Interlace
operator|=
name|GInterlace
expr_stmt|;
name|ColorMapSize
operator|=
literal|1
operator|<<
name|BitsPerPixel
expr_stmt|;
name|RWidth
operator|=
name|Width
operator|=
name|GWidth
expr_stmt|;
name|RHeight
operator|=
name|Height
operator|=
name|GHeight
expr_stmt|;
name|LeftOfs
operator|=
operator|(
name|int
operator|)
name|offset_x
expr_stmt|;
name|TopOfs
operator|=
operator|(
name|int
operator|)
name|offset_y
expr_stmt|;
name|Resolution
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Calculate number of bits we are expecting    */
name|CountDown
operator|=
operator|(
name|long
operator|)
name|Width
operator|*
operator|(
name|long
operator|)
name|Height
expr_stmt|;
comment|/*    * Indicate which pass we are on (if interlace)    */
name|Pass
operator|=
literal|0
expr_stmt|;
comment|/*    * The initial code size    */
if|if
condition|(
name|BitsPerPixel
operator|<=
literal|1
condition|)
name|InitCodeSize
operator|=
literal|2
expr_stmt|;
else|else
name|InitCodeSize
operator|=
name|BitsPerPixel
expr_stmt|;
comment|/*    * Set up the current x and y position    */
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/*    * Write an Image separator    */
block|fputc (',', fp);
comment|/*    * Write the Image header    */
block|Putword (LeftOfs, fp);   Putword (TopOfs, fp);   Putword (Width, fp);   Putword (Height, fp);
comment|/*    * Write out whether or not the image is interlaced    */
block|if (Interlace)     fputc (0x40, fp);   else     fputc (0x00, fp);
comment|/*    * Write out the initial code size    */
block|fputc (InitCodeSize, fp);
comment|/*    * Go and actually compress the data    */
block|compress (InitCodeSize + 1, fp, GetPixel);
comment|/*    * Write out a Zero-length packet (to end the series)    */
block|fputc (0, fp);
comment|/***************************/
block|Interlace = GInterlace;   ColorMapSize = 1<< BitsPerPixel;   RWidth = Width = GWidth;   RHeight = Height = GHeight;   LeftOfs = TopOfs = 0;   Resolution = BitsPerPixel;    CountDown = (long) Width *(long) Height;   Pass = 0;
comment|/*    * The initial code size    */
block|if (BitsPerPixel<= 1)     InitCodeSize = 2;   else     InitCodeSize = BitsPerPixel;
comment|/*    * Set up the current x and y position    */
block|curx = cury = 0;
endif|#
directive|endif
name|cur_progress
operator|=
literal|0
expr_stmt|;
comment|/*    * Write an Image separator    */
name|fputc
argument_list|(
literal|','
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write the Image header    */
name|Putword
argument_list|(
name|LeftOfs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|TopOfs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|Width
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|Height
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out whether or not the image is interlaced    */
if|if
condition|(
name|Interlace
condition|)
name|fputc
argument_list|(
literal|0x40
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Write out the initial code size    */
name|fputc
argument_list|(
name|InitCodeSize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * Go and actually compress the data    */
name|compress
argument_list|(
name|InitCodeSize
operator|+
literal|1
argument_list|,
name|fp
argument_list|,
name|GetPixel
argument_list|)
expr_stmt|;
comment|/*    * Write out a Zero-length packet (to end the series)    */
name|fputc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeClose (FILE * fp,int GWidth,int GHeight,int GInterlace,int Background,int Transparent,int BitsPerPixel,int Red[],int Green[],int Blue[],ifunptr GetPixel)
name|GIFEncodeClose
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|GWidth
parameter_list|,
name|int
name|GHeight
parameter_list|,
name|int
name|GInterlace
parameter_list|,
name|int
name|Background
parameter_list|,
name|int
name|Transparent
parameter_list|,
name|int
name|BitsPerPixel
parameter_list|,
name|int
name|Red
index|[]
parameter_list|,
name|int
name|Green
index|[]
parameter_list|,
name|int
name|Blue
index|[]
parameter_list|,
name|ifunptr
name|GetPixel
parameter_list|)
block|{
comment|/*    * Write the GIF file terminator    */
name|fputc
argument_list|(
literal|';'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/*    * And close the file    */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|GIFEncodeLoopExt (FILE * fp,guint num_loops)
name|GIFEncodeLoopExt
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|guint
name|num_loops
parameter_list|)
block|{
name|fputc
argument_list|(
literal|0x21
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x0b
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"NETSCAPE2.0"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x03
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x01
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|Putword
argument_list|(
name|num_loops
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* NOTE: num_loops==0 means 'loop infinitely' */
block|}
end_function

begin_function
DECL|function|GIFEncodeCommentExt (FILE * fp,char * comment)
specifier|static
name|void
name|GIFEncodeCommentExt
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|comment
parameter_list|)
block|{
if|if
condition|(
name|comment
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|comment
argument_list|)
operator|<
literal|1
condition|)
block|{
name|g_print
argument_list|(
literal|"GIF: warning: no comment given - comment block not written.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|comment
argument_list|)
operator|>
literal|240
condition|)
block|{
name|g_print
argument_list|(
literal|"GIF: warning: comment too large - comment block not written.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputc
argument_list|(
literal|0x21
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0xfe
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|strlen
argument_list|(
name|comment
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|comment
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x00
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out a word to the GIF file  */
end_comment

begin_function
specifier|static
name|void
DECL|function|Putword (int w,FILE * fp)
name|Putword
parameter_list|(
name|int
name|w
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fputc
argument_list|(
name|w
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|w
operator|/
literal|256
operator|)
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  *  GIFCOMPR.C       - GIF Image compression routines  *  *  Lempel-Ziv compression based on 'compress'.  GIF modifications by  *  David Rowley (mgardi@watdcsu.waterloo.edu)  *  ***************************************************************************/
end_comment

begin_comment
comment|/*  * General DEFINEs  */
end_comment

begin_define
DECL|macro|GIF_BITS
define|#
directive|define
name|GIF_BITS
value|12
end_define

begin_define
DECL|macro|HSIZE
define|#
directive|define
name|HSIZE
value|5003
end_define

begin_comment
DECL|macro|HSIZE
comment|/* 80% occupancy */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UCHAR
end_ifdef

begin_typedef
DECL|typedef|char_type
typedef|typedef
name|char
name|char_type
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*NO_UCHAR */
end_comment

begin_typedef
DECL|typedef|char_type
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NO_UCHAR */
end_comment

begin_comment
comment|/*   * GIF Image compression - modified 'compress'  *  * Based on: compress.c - File compression ala IEEE Computer, June 1984.  *  * By Authors:  Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)  *              Jim McKie               (decvax!mcvax!jim)  *              Steve Davies            (decvax!vax135!petsd!peora!srd)  *              Ken Turkowski           (decvax!decwrl!turtlevax!ken)  *              James A. Woods          (decvax!ihnp4!ames!jaw)  *              Joe Orost               (decvax!vax135!petsd!joe)  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
DECL|macro|ARGVAL ()
define|#
directive|define
name|ARGVAL
parameter_list|()
value|(*++(*argv) || (--argc&& *++argv))
end_define

begin_decl_stmt
DECL|variable|n_bits
specifier|static
name|int
name|n_bits
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|n_bits
comment|/* number of bits/code */
end_comment

begin_decl_stmt
DECL|variable|maxbits
specifier|static
name|int
name|maxbits
init|=
name|GIF_BITS
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxbits
comment|/* user settable max # bits/code */
end_comment

begin_decl_stmt
DECL|variable|maxcode
specifier|static
name|code_int
name|maxcode
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxcode
comment|/* maximum code, given n_bits */
end_comment

begin_decl_stmt
DECL|variable|maxmaxcode
specifier|static
name|code_int
name|maxmaxcode
init|=
operator|(
name|code_int
operator|)
literal|1
operator|<<
name|GIF_BITS
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|maxmaxcode
comment|/* should NEVER generate this code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_comment
comment|/* But wrong! */
end_comment

begin_define
DECL|macro|MAXCODE (Mn_bits)
define|#
directive|define
name|MAXCODE
parameter_list|(
name|Mn_bits
parameter_list|)
value|((code_int) 1<< (Mn_bits) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*COMPATIBLE */
end_comment

begin_define
DECL|macro|MAXCODE (Mn_bits)
define|#
directive|define
name|MAXCODE
parameter_list|(
name|Mn_bits
parameter_list|)
value|(((code_int) 1<< (Mn_bits)) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*COMPATIBLE */
end_comment

begin_decl_stmt
DECL|variable|htab
specifier|static
name|count_int
name|htab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|codetab
specifier|static
name|unsigned
name|short
name|codetab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
DECL|macro|HashTabOf (i)
define|#
directive|define
name|HashTabOf
parameter_list|(
name|i
parameter_list|)
value|htab[i]
end_define

begin_define
DECL|macro|CodeTabOf (i)
define|#
directive|define
name|CodeTabOf
parameter_list|(
name|i
parameter_list|)
value|codetab[i]
end_define

begin_decl_stmt
DECL|variable|hsize
specifier|const
name|code_int
name|hsize
init|=
name|HSIZE
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|hsize
comment|/* the original reason for this being 				   variable was "for dynamic table sizing", 				   but since it was never actually changed 				   I made it const   --Adam. */
end_comment

begin_comment
comment|/*  * To save much memory, we overlay the table used by compress() with those  * used by decompress().  The tab_prefix table is the same size and type  * as the codetab.  The tab_suffix table needs 2**GIF_BITS characters.  We  * get this from the beginning of htab.  The output stack uses the rest  * of htab, and contains characters.  There is plenty of room for any  * possible stack (stack used to be 8000 characters).  */
end_comment

begin_define
DECL|macro|tab_prefixof (i)
define|#
directive|define
name|tab_prefixof
parameter_list|(
name|i
parameter_list|)
value|CodeTabOf(i)
end_define

begin_define
DECL|macro|tab_suffixof (i)
define|#
directive|define
name|tab_suffixof
parameter_list|(
name|i
parameter_list|)
value|((char_type*)(htab))[i]
end_define

begin_define
DECL|macro|de_stack
define|#
directive|define
name|de_stack
value|((char_type*)&tab_suffixof((code_int)1<<GIF_BITS))
end_define

begin_decl_stmt
DECL|variable|free_ent
specifier|static
name|code_int
name|free_ent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|free_ent
comment|/* first unused entry */
end_comment

begin_comment
comment|/*  * block compression parameters -- after all codes are used up,  * and compression rate changes, start over.  */
end_comment

begin_decl_stmt
DECL|variable|clear_flg
specifier|static
name|int
name|clear_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|offset
specifier|static
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|in_count
specifier|static
name|long
name|int
name|in_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|in_count
comment|/* length of input */
end_comment

begin_decl_stmt
DECL|variable|out_count
specifier|static
name|long
name|int
name|out_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
DECL|variable|out_count
comment|/* # of codes output (for debugging) */
end_comment

begin_comment
comment|/*  * compress stdin to stdout  *  * Algorithm:  use open addressing double hashing (no chaining) on the  * prefix code / next character combination.  We do a variant of Knuth's  * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime  * secondary probe.  Here, the modular division first probe is gives way  * to a faster exclusive-or manipulation.  Also do block compression with  * an adaptive reset, whereby the code table is cleared when the compression  * ratio decreases, but after the table fills.  The variable-length output  * codes are re-sized at this point, and a special CLEAR code is generated  * for the decompressor.  Late addition:  construct the table according to  * file size for noticeable speed improvement on small files.  Please direct  * questions about this implementation to ames!jaw.  */
end_comment

begin_decl_stmt
DECL|variable|g_init_bits
specifier|static
name|int
name|g_init_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|g_outfile
specifier|static
name|FILE
modifier|*
name|g_outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|ClearCode
specifier|static
name|int
name|ClearCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|EOFCode
specifier|static
name|int
name|EOFCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_accum
specifier|static
name|unsigned
name|long
name|cur_accum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|cur_bits
specifier|static
name|int
name|cur_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|masks
specifier|static
name|unsigned
name|long
name|masks
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000F
block|,
literal|0x001F
block|,
literal|0x003F
block|,
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x01FF
block|,
literal|0x03FF
block|,
literal|0x07FF
block|,
literal|0x0FFF
block|,
literal|0x1FFF
block|,
literal|0x3FFF
block|,
literal|0x7FFF
block|,
literal|0xFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
DECL|function|compress (int init_bits,FILE * outfile,ifunptr ReadValue)
name|compress
parameter_list|(
name|int
name|init_bits
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|,
name|ifunptr
name|ReadValue
parameter_list|)
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
comment|/* = 0 */
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|code_int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
comment|/*    * Set up the globals:  g_init_bits - initial number of bits    *                      g_outfile   - pointer to output file    */
name|g_init_bits
operator|=
name|init_bits
expr_stmt|;
name|g_outfile
operator|=
name|outfile
expr_stmt|;
name|cur_bits
operator|=
literal|0
expr_stmt|;
name|cur_accum
operator|=
literal|0
expr_stmt|;
comment|/*    * Set up the necessary values    */
name|offset
operator|=
literal|0
expr_stmt|;
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|ClearCode
operator|=
operator|(
literal|1
operator|<<
operator|(
name|init_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|EOFCode
operator|=
name|ClearCode
operator|+
literal|1
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
comment|/* Had some problems here... should be okay now.  --Adam */
name|n_bits
operator|=
name|g_init_bits
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|char_init
argument_list|()
expr_stmt|;
name|ent
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
operator|++
name|hshift
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
while|while
condition|(
operator|(
name|c
operator|=
name|GIFNextPixel
argument_list|(
name|ReadValue
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
operator|++
name|in_count
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|code_int
operator|)
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|CodeTabOf
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
comment|/*SIGNED_COMPARE_SLOW */
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
comment|/* } */
endif|#
directive|endif
comment|/*SIGNED_COMPARE_SLOW */
name|CodeTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|HashTabOf
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
else|else
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*    * Put out the final code.    */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
operator|++
name|out_count
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|EOFCode
argument_list|)
expr_stmt|;
block|}
comment|/*****************************************************************  * TAG( output )  *  * Output the given code.  * Inputs:  *      code:   A n_bits-bit integer.  If == -1, then EOF.  This assumes  *              that n_bits =< (long)wordsize - 1.  * Outputs:  *      Outputs code to the file.  * Assumptions:  *      Chars are 8 bits long.  * Algorithm:  *      Maintain a GIF_BITS character long buffer (so that 8 codes will  * fit in it exactly).  Use the VAX insv instruction to insert each  * code in turn.  When the buffer fills up empty it and start over.  */
specifier|static
name|void
DECL|function|output (code_int code)
name|output
parameter_list|(
name|code_int
name|code
parameter_list|)
block|{
name|cur_accum
operator|&=
name|masks
index|[
name|cur_bits
index|]
expr_stmt|;
if|if
condition|(
name|cur_bits
operator|>
literal|0
condition|)
name|cur_accum
operator||=
operator|(
operator|(
name|long
operator|)
name|code
operator|<<
name|cur_bits
operator|)
expr_stmt|;
else|else
name|cur_accum
operator|=
name|code
expr_stmt|;
name|cur_bits
operator|+=
name|n_bits
expr_stmt|;
while|while
condition|(
name|cur_bits
operator|>=
literal|8
condition|)
block|{
name|char_out
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cur_accum
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|cur_accum
operator|>>=
literal|8
expr_stmt|;
name|cur_bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/*    * If the next entry is going to be too big for the code size,    * then increase it, if possible.    */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
operator|||
name|clear_flg
condition|)
block|{
if|if
condition|(
name|clear_flg
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|g_init_bits
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|n_bits
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|EOFCode
condition|)
block|{
comment|/*        * At EOF, write the rest of the buffer.        */
while|while
condition|(
name|cur_bits
operator|>
literal|0
condition|)
block|{
name|char_out
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cur_accum
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|cur_accum
operator|>>=
literal|8
expr_stmt|;
name|cur_bits
operator|-=
literal|8
expr_stmt|;
block|}
name|flush_char
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|g_outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|g_outfile
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  * Clear out the hash table  */
specifier|static
name|void
DECL|function|cl_block ()
name|cl_block
parameter_list|()
comment|/* table clear for block compress */
block|{
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|)
expr_stmt|;
name|free_ent
operator|=
name|ClearCode
operator|+
literal|2
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ClearCode
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|cl_hash (register count_int hsize)
name|cl_hash
parameter_list|(
specifier|register
name|count_int
name|hsize
parameter_list|)
comment|/* reset code table */
block|{
specifier|register
name|count_int
modifier|*
name|htab_p
init|=
name|htab
operator|+
name|hsize
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|long
name|m1
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
name|hsize
operator|-
literal|16
expr_stmt|;
do|do
block|{
comment|/* might use Sys V memset(3) here */
operator|*
operator|(
name|htab_p
operator|-
literal|16
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|15
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|14
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|13
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|12
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|11
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|10
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|9
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|8
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|7
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|6
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|5
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|4
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|3
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|2
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|1
operator|)
operator|=
name|m1
expr_stmt|;
name|htab_p
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|-=
literal|16
operator|)
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|+=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
operator|--
name|htab_p
operator|=
name|m1
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|writeerr ()
name|writeerr
parameter_list|()
block|{
name|g_message
argument_list|(
literal|"GIF: error writing output file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/******************************************************************************  *  * GIF Specific routines  *  ******************************************************************************/
comment|/*  * Number of characters so far in this 'packet'  */
DECL|variable|a_count
specifier|static
name|int
name|a_count
decl_stmt|;
comment|/*  * Set up the 'byte output' routine  */
specifier|static
name|void
DECL|function|char_init ()
name|char_init
parameter_list|()
block|{
name|a_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Define the storage for the packet accumulator  */
DECL|variable|accum
specifier|static
name|char
name|accum
index|[
literal|256
index|]
decl_stmt|;
comment|/*  * Add a character to the end of the current packet, and if it is 254  * characters, flush the packet to disk.  */
specifier|static
name|void
DECL|function|char_out (int c)
name|char_out
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|accum
index|[
name|a_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|a_count
operator|>=
literal|254
condition|)
name|flush_char
argument_list|()
expr_stmt|;
block|}
comment|/*  * Flush the packet to disk, and reset the accumulator  */
specifier|static
name|void
DECL|function|flush_char ()
name|flush_char
parameter_list|()
block|{
if|if
condition|(
name|a_count
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
name|a_count
argument_list|,
name|g_outfile
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|accum
argument_list|,
literal|1
argument_list|,
name|a_count
argument_list|,
name|g_outfile
argument_list|)
expr_stmt|;
name|a_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* crop dialog functions */
specifier|static
name|void
DECL|function|cropok_callback (GtkWidget * widget,gpointer data)
name|cropok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|can_crop
operator|=
name|TRUE
expr_stmt|;
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|cropcancel_callback (GtkWidget * widget,gpointer data)
name|cropcancel_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|can_crop
operator|=
name|FALSE
expr_stmt|;
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|cropclose_callback (GtkWidget * widget,gpointer data)
name|cropclose_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
comment|/*  Save interface functions  */
specifier|static
name|void
DECL|function|save_close_callback (GtkWidget * widget,gpointer data)
name|save_close_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gtk_main_quit
argument_list|()
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|save_ok_callback (GtkWidget * widget,gpointer data)
name|save_ok_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gsint
operator|.
name|run
operator|=
name|TRUE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|save_cancel_callback (GtkWidget * widget,gpointer data)
name|save_cancel_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gsint
operator|.
name|run
operator|=
name|FALSE
expr_stmt|;
name|gtk_widget_destroy
argument_list|(
name|GTK_WIDGET
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|save_windelete_callback (GtkWidget * widget,gpointer data)
name|save_windelete_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gsint
operator|.
name|run
operator|=
name|FALSE
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|disposal_select_callback (GtkWidget * widget,gpointer data)
name|disposal_select_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|int
modifier|*
name|valptr
decl_stmt|;
name|valptr
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|radio_pressed
index|[
literal|0
index|]
operator|=
name|radio_pressed
index|[
literal|1
index|]
operator|=
name|radio_pressed
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|valptr
operator|=
literal|1
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|save_toggle_update (GtkWidget * widget,gpointer data)
name|save_toggle_update
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|int
modifier|*
name|toggle_val
decl_stmt|;
name|toggle_val
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|GTK_TOGGLE_BUTTON
argument_list|(
name|widget
argument_list|)
operator|->
name|active
condition|)
operator|*
name|toggle_val
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|toggle_val
operator|=
name|FALSE
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|save_entry_callback (GtkWidget * widget,gpointer data)
name|save_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gsvals
operator|.
name|default_delay
operator|=
name|atoi
argument_list|(
name|gtk_entry_get_text
argument_list|(
name|GTK_ENTRY
argument_list|(
name|widget
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsvals
operator|.
name|default_delay
operator|<
literal|0
condition|)
name|gsvals
operator|.
name|default_delay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gsvals
operator|.
name|default_delay
operator|>
literal|65000
condition|)
name|gsvals
operator|.
name|default_delay
operator|=
literal|65000
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|comment_entry_callback (GtkWidget * widget,gpointer data)
name|comment_entry_callback
parameter_list|(
name|GtkWidget
modifier|*
name|widget
parameter_list|,
name|gpointer
name|data
parameter_list|)
block|{
name|gint
name|ssize
decl_stmt|;
name|gchar
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|gtk_editable_get_chars
argument_list|(
name|GTK_EDITABLE
argument_list|(
name|widget
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Temporary kludge for overlength strings - just return */
if|if
condition|(
name|ssize
operator|>
literal|240
condition|)
block|{
name|g_message
argument_list|(
literal|"GIF save: Your comment string is too long.\n"
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|globalcomment
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|globalcomment
argument_list|)
expr_stmt|;
name|globalcomment
operator|=
name|g_malloc
argument_list|(
name|ssize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*strcpy(globalcomment, gtk_entry_get_text (GTK_ENTRY (widget)));*/
name|strcpy
argument_list|(
name|globalcomment
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* g_print ("COMMENT: %s\n",globalcomment); */
block|}
end_function

begin_comment
comment|/* The End */
end_comment

end_unit

