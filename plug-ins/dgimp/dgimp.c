begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The GIMP -- an image manipulation program  * Copyright (C) 1995 Spencer Kimball and Peter Mattis  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SELECT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gtk/gtk.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimp.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpprotocol.h"
end_include

begin_include
include|#
directive|include
file|"libgimp/gimpwire.h"
end_include

begin_include
include|#
directive|include
file|"dgimp_procs.h"
end_include

begin_define
DECL|macro|DEBUG_DGIMP
define|#
directive|define
name|DEBUG_DGIMP
end_define

begin_comment
comment|/* External functions.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|gimp_extension_process
parameter_list|(
name|guint
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declare local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|quit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_install_procedures
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_init_server
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_init_lgps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_init_tcp_ip_args
parameter_list|(
name|char
modifier|*
modifier|*
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gint
name|dgimp_make_socket
parameter_list|(
name|gint
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_process
parameter_list|(
name|guint
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_configure_lgp
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|clientname
parameter_list|,
name|gint
name|new
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgimp_handle_lgp_msg
parameter_list|(
name|int
name|fd
parameter_list|,
name|WireMessage
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
DECL|variable|PLUG_IN_INFO
name|GPlugInInfo
name|PLUG_IN_INFO
init|=
block|{
name|NULL
block|,
comment|/* init_proc */
name|quit
block|,
comment|/* quit_proc */
name|query
block|,
comment|/* query_proc */
name|run
block|,
comment|/* run_proc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_lgp_list
name|GList
modifier|*
name|dgimp_lgp_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_lgp_executable
specifier|static
name|char
modifier|*
name|dgimp_lgp_executable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_server_port
specifier|static
name|gint
name|dgimp_server_port
init|=
literal|10007
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_server_sock
specifier|static
name|gint
name|dgimp_server_sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_gimp_port
specifier|static
name|gint
name|dgimp_gimp_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_procs
specifier|static
name|DGimpProc
name|dgimp_procs
index|[]
init|=
block|{
block|{
literal|"gimp_invert"
block|,
name|dgimp_invert_proc
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|variable|dgimp_num_procs
specifier|static
name|int
name|dgimp_num_procs
init|=
sizeof|sizeof
argument_list|(
name|dgimp_procs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dgimp_procs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_writefd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_readfd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MAIN
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
DECL|function|quit ()
name|quit
parameter_list|()
block|{
name|GList
modifier|*
name|list
init|=
name|dgimp_lgp_list
decl_stmt|;
name|DGimpLGP
modifier|*
name|lgp
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|lgp
operator|=
operator|(
name|DGimpLGP
operator|*
operator|)
name|list
operator|->
name|data
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_DGIMP
argument_list|)
name|g_print
argument_list|(
literal|"Shutting down lightweight GIMP process...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gp_quit_write
argument_list|(
name|lgp
operator|->
name|filedes
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|lgp
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|query ()
name|query
parameter_list|()
block|{
specifier|static
name|GParamDef
name|args
index|[]
init|=
block|{
block|{
name|PARAM_INT32
block|,
literal|"run_mode"
block|,
literal|"Interactive, non-interactive"
block|}
block|,   }
decl_stmt|;
specifier|static
name|GParamDef
modifier|*
name|return_vals
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|nargs
init|=
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|static
name|int
name|nreturn_vals
init|=
literal|0
decl_stmt|;
name|gimp_install_procedure
argument_list|(
literal|"plug_in_dgimp"
argument_list|,
literal|"Distributed GIMP"
argument_list|,
literal|"More help here later"
argument_list|,
literal|"Spencer Kimball"
argument_list|,
literal|"Spencer Kimball"
argument_list|,
literal|"1997"
argument_list|,
literal|"<Toolbox>/Xtns/Distributed GIMP"
argument_list|,
name|NULL
argument_list|,
name|PROC_EXTENSION
argument_list|,
name|nargs
argument_list|,
name|nreturn_vals
argument_list|,
name|args
argument_list|,
name|return_vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|run (char * name,int nparams,GParam * param,int * nreturn_vals,GParam ** return_vals)
name|run
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nparams
parameter_list|,
name|GParam
modifier|*
name|param
parameter_list|,
name|int
modifier|*
name|nreturn_vals
parameter_list|,
name|GParam
modifier|*
modifier|*
name|return_vals
parameter_list|)
block|{
specifier|static
name|GParam
name|values
index|[
literal|1
index|]
decl_stmt|;
name|GRunModeType
name|run_mode
decl_stmt|;
name|GStatusType
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|run_mode
operator|=
name|param
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_int32
expr_stmt|;
switch|switch
condition|(
name|run_mode
condition|)
block|{
case|case
name|RUN_INTERACTIVE
case|:
break|break;
case|case
name|RUN_NONINTERACTIVE
case|:
break|break;
default|default:
break|break;
block|}
name|dgimp_install_procedures
argument_list|()
expr_stmt|;
name|dgimp_init_server
argument_list|()
expr_stmt|;
name|dgimp_init_lgps
argument_list|()
expr_stmt|;
comment|/*  Enter the temp procedure processing loop  */
while|while
condition|(
literal|1
condition|)
block|{
name|gimp_extension_process
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|dgimp_process
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
operator|*
name|nreturn_vals
operator|=
literal|1
expr_stmt|;
operator|*
name|return_vals
operator|=
name|values
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PARAM_STATUS
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_install_procedures ()
name|dgimp_install_procedures
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|int
name|proc_type
decl_stmt|;
name|char
modifier|*
name|blurb
decl_stmt|;
name|char
modifier|*
name|new_blurb
decl_stmt|;
name|char
modifier|*
name|help
decl_stmt|;
name|char
modifier|*
name|author
decl_stmt|;
name|char
modifier|*
name|copyright
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|GParamDef
modifier|*
name|args
decl_stmt|;
name|GParamDef
modifier|*
name|return_vals
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dgimp_num_procs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gimp_query_procedure
argument_list|(
name|dgimp_procs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|blurb
argument_list|,
operator|&
name|help
argument_list|,
operator|&
name|author
argument_list|,
operator|&
name|copyright
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|proc_type
argument_list|,
operator|&
name|nargs
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|return_vals
argument_list|)
condition|)
block|{
name|new_blurb
operator|=
name|g_new
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|blurb
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"  (DISTRIBUTED)"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_blurb
argument_list|,
literal|"%s%s"
argument_list|,
name|blurb
argument_list|,
literal|"  (DISTRIBUTED)"
argument_list|)
expr_stmt|;
name|gimp_install_temp_proc
argument_list|(
name|dgimp_procs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|new_blurb
argument_list|,
name|help
argument_list|,
name|author
argument_list|,
name|copyright
argument_list|,
name|date
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|PROC_TEMPORARY
argument_list|,
name|nargs
argument_list|,
name|nreturn_vals
argument_list|,
name|args
argument_list|,
name|return_vals
argument_list|,
name|dgimp_procs
index|[
name|i
index|]
operator|.
name|run_proc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_init_server ()
name|dgimp_init_server
parameter_list|()
block|{
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
comment|/*  The server port #  */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_gimprc_query"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_STRING
argument_list|,
literal|"dgimp-server-port"
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|==
name|STATUS_SUCCESS
operator|&&
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|!=
name|NULL
condition|)
name|dgimp_server_port
operator|=
operator|(
name|int
operator|)
name|atof
argument_list|(
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
argument_list|)
expr_stmt|;
comment|/* Create the socket and set it up to accept connections. */
name|dgimp_server_sock
operator|=
name|dgimp_make_socket
argument_list|(
operator|&
name|dgimp_server_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|dgimp_server_sock
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"listen"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_DGIMP
argument_list|)
name|g_print
argument_list|(
literal|"dgimp server initialized and listening for connections...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_init_lgps ()
name|dgimp_init_lgps
parameter_list|()
block|{
name|GParam
modifier|*
name|return_vals
decl_stmt|;
name|int
name|nreturn_vals
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|host_list
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/*  The list of hosts for distributed processing  */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_gimprc_query"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_STRING
argument_list|,
literal|"dgimp-host-list"
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|!=
name|STATUS_SUCCESS
condition|)
block|{
name|g_warning
argument_list|(
literal|"Unable to query for a dgimp host list.  Specify \"dgimp-host-list\" in the gimprc."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|host_list
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|)
operator|==
name|NULL
condition|)
block|{
name|g_warning
argument_list|(
literal|"No hosts specified by dgimp-host-list variable..."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  The location in the filesystem of the LGP executable (constant across hosts)  */
name|return_vals
operator|=
name|gimp_run_procedure
argument_list|(
literal|"gimp_gimprc_query"
argument_list|,
operator|&
name|nreturn_vals
argument_list|,
name|PARAM_STRING
argument_list|,
literal|"dgimp-lgp-executable"
argument_list|,
name|PARAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_vals
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|d_status
operator|!=
name|STATUS_SUCCESS
condition|)
block|{
name|g_warning
argument_list|(
literal|"No LGP executable.  Specify \"dgimp-lgp-executable\" in the gimprc."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dgimp_lgp_executable
operator|=
name|return_vals
index|[
literal|1
index|]
operator|.
name|data
operator|.
name|d_string
operator|)
operator|==
name|NULL
condition|)
block|{
name|g_warning
argument_list|(
literal|"No LGP executable specified by dgimp-lgp-executable variable..."
argument_list|)
expr_stmt|;
return|return;
block|}
name|host
operator|=
name|strtok
argument_list|(
name|host_list
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
name|host
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_DGIMP
argument_list|)
name|g_print
argument_list|(
literal|"Invoking a lightweight GIMP process (LGP) on host %s...\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  Initialize the arguments for invoking the LGP by TCP-IP  */
name|dgimp_init_tcp_ip_args
argument_list|(
operator|&
name|args
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/* Fork another process for starting the LGP        */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Execute the LGP starting program. The "_exit" call should never 	   *  be reached, unless some strange error condition 	   *  exists. 	   */
name|execvp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|g_warning
argument_list|(
literal|"unable to run LGP for host: %s\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|host
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_init_tcp_ip_args (char *** args,char * host)
name|dgimp_init_tcp_ip_args
parameter_list|(
name|char
modifier|*
modifier|*
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
block|{
name|char
name|server_port_buf
index|[
literal|12
index|]
decl_stmt|;
name|char
name|gimp_port_buf
index|[
literal|12
index|]
decl_stmt|;
name|char
modifier|*
name|localhost
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|in_addr
name|inp
decl_stmt|;
comment|/*  The localhost inet address  */
name|he
operator|=
name|gethostbyname
argument_list|(
literal|"zarathustra"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inp
argument_list|,
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
name|he
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|localhost
operator|=
name|inet_ntoa
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/*  Allocate room for the arguments  */
operator|*
name|args
operator|=
name|g_new
argument_list|(
name|gchar
operator|*
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|server_port_buf
argument_list|,
literal|"%d"
argument_list|,
name|dgimp_server_port
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|gimp_port_buf
argument_list|,
literal|"%d"
argument_list|,
name|dgimp_gimp_port
argument_list|)
expr_stmt|;
comment|/*  The arguments  */
operator|(
operator|*
name|args
operator|)
index|[
literal|0
index|]
operator|=
name|g_strdup
argument_list|(
literal|"rsh"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
index|[
literal|1
index|]
operator|=
name|g_strdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
index|[
literal|2
index|]
operator|=
name|g_strdup
argument_list|(
name|dgimp_lgp_executable
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
index|[
literal|3
index|]
operator|=
name|g_strdup
argument_list|(
name|localhost
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
index|[
literal|4
index|]
operator|=
name|g_strdup
argument_list|(
name|server_port_buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
index|[
literal|5
index|]
operator|=
name|g_strdup
argument_list|(
name|gimp_port_buf
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gint
DECL|function|dgimp_make_socket (gint * port)
name|dgimp_make_socket
parameter_list|(
name|gint
modifier|*
name|port
parameter_list|)
block|{
name|gint
name|sock
decl_stmt|;
name|struct
name|sockaddr_in
name|name
decl_stmt|;
name|gint
name|v
decl_stmt|;
name|gint
name|initial_port
init|=
operator|*
name|port
decl_stmt|;
comment|/* Create the socket. */
name|sock
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Give the socket a name. */
name|name
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|name
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|*
name|port
argument_list|)
expr_stmt|;
name|name
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
while|while
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
operator|*
name|port
operator|)
operator|++
expr_stmt|;
comment|/*  Try the next sequential port number  */
name|name
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|*
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|port
operator|>
name|initial_port
operator|+
literal|10
condition|)
block|{
name|g_warning
argument_list|(
literal|"Unable to start dgimp server on ports (%d - %d)."
argument_list|,
name|initial_port
argument_list|,
operator|*
name|port
argument_list|)
expr_stmt|;
name|gimp_quit
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sock
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_process (guint timeout)
name|dgimp_process
parameter_list|(
name|guint
name|timeout
parameter_list|)
block|{
name|WireMessage
name|msg
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
name|fd_set
name|active_fd_set
decl_stmt|;
name|fd_set
name|read_fd_set
decl_stmt|;
name|gint
name|i
decl_stmt|,
name|select_val
decl_stmt|;
name|struct
name|sockaddr_in
name|clientname
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|timeout
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|timeout
operator|%
literal|1000
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize the set of active sockets. */
name|FD_ZERO
argument_list|(
operator|&
name|active_fd_set
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|dgimp_server_sock
argument_list|,
operator|&
name|active_fd_set
argument_list|)
expr_stmt|;
comment|/* Block until input arrives on one or more active sockets. */
name|read_fd_set
operator|=
name|active_fd_set
expr_stmt|;
name|select_val
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|read_fd_set
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_val
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|select_val
operator|==
literal|0
condition|)
return|return;
comment|/* Service all the sockets with input pending. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FD_SETSIZE
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|read_fd_set
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|dgimp_server_sock
condition|)
block|{
comment|/* Connection request on original socket. */
name|gint
name|new
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|clientname
argument_list|)
expr_stmt|;
name|new
operator|=
name|accept
argument_list|(
name|dgimp_server_sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|clientname
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_DGIMP
argument_list|)
name|g_print
argument_list|(
literal|"Server: connect from host %s, port %hd.\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|clientname
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|clientname
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_SET
argument_list|(
name|new
argument_list|,
operator|&
name|active_fd_set
argument_list|)
expr_stmt|;
comment|/*  Configure LGP  */
name|dgimp_configure_lgp
argument_list|(
operator|&
name|clientname
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Data arriving on an already-connected socket. */
if|if
condition|(
operator|!
name|wire_read_msg
argument_list|(
name|i
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_DGIMP
argument_list|)
name|g_print
argument_list|(
literal|"Server: disconnect from host %s, port %hd.\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|clientname
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|clientname
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|active_fd_set
argument_list|)
expr_stmt|;
block|}
else|else
name|dgimp_handle_lgp_msg
argument_list|(
name|i
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_configure_lgp (struct sockaddr_in * clientname,gint new)
name|dgimp_configure_lgp
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|clientname
parameter_list|,
name|gint
name|new
parameter_list|)
block|{
name|GPConfig
name|config
decl_stmt|;
name|DGimpLGP
modifier|*
name|lgp
decl_stmt|;
name|guchar
modifier|*
name|color_cube
decl_stmt|;
name|lgp
operator|=
name|g_new
argument_list|(
name|DGimpLGP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lgp
operator|->
name|filedes
operator|=
name|new
expr_stmt|;
name|lgp
operator|->
name|available
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|version
operator|=
name|GP_VERSION
expr_stmt|;
name|config
operator|.
name|tile_width
operator|=
name|gimp_tile_width
argument_list|()
expr_stmt|;
name|config
operator|.
name|tile_height
operator|=
name|gimp_tile_height
argument_list|()
expr_stmt|;
name|config
operator|.
name|shm_ID
operator|=
operator|-
literal|1
expr_stmt|;
name|config
operator|.
name|gamma
operator|=
name|gimp_gamma
argument_list|()
expr_stmt|;
name|config
operator|.
name|install_cmap
operator|=
name|gimp_install_cmap
argument_list|()
expr_stmt|;
name|config
operator|.
name|use_xshm
operator|=
name|FALSE
expr_stmt|;
name|color_cube
operator|=
name|gimp_color_cube
argument_list|()
expr_stmt|;
name|config
operator|.
name|color_cube
index|[
literal|0
index|]
operator|=
name|color_cube
index|[
literal|0
index|]
expr_stmt|;
name|config
operator|.
name|color_cube
index|[
literal|1
index|]
operator|=
name|color_cube
index|[
literal|1
index|]
expr_stmt|;
name|config
operator|.
name|color_cube
index|[
literal|2
index|]
operator|=
name|color_cube
index|[
literal|2
index|]
expr_stmt|;
name|config
operator|.
name|color_cube
index|[
literal|3
index|]
operator|=
name|color_cube
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|gp_config_write
argument_list|(
name|lgp
operator|->
name|filedes
argument_list|,
operator|&
name|config
argument_list|)
operator|||
operator|!
name|wire_flush
argument_list|(
name|lgp
operator|->
name|filedes
argument_list|)
condition|)
name|g_warning
argument_list|(
literal|"Failed on LGP configure\n"
argument_list|)
expr_stmt|;
else|else
name|dgimp_lgp_list
operator|=
name|g_list_append
argument_list|(
name|dgimp_lgp_list
argument_list|,
name|lgp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|dgimp_handle_lgp_msg (int fd,WireMessage * msg)
name|dgimp_handle_lgp_msg
parameter_list|(
name|int
name|fd
parameter_list|,
name|WireMessage
modifier|*
name|msg
parameter_list|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|GP_QUIT
case|:
name|g_warning
argument_list|(
literal|"unexpected quit message received from LGP(should not happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_CONFIG
case|:
name|g_warning
argument_list|(
literal|"unexpected config message received from LGP(should not happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TILE_REQ
case|:
case|case
name|GP_TILE_ACK
case|:
case|case
name|GP_TILE_DATA
case|:
name|g_warning
argument_list|(
literal|"unexpected tile message received from LGP(should not happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_RUN
case|:
name|g_print
argument_list|(
literal|"Got a proc run request from LGP\n"
argument_list|)
expr_stmt|;
comment|/*  forward to GIMP  */
if|if
condition|(
operator|!
name|wire_write_msg
argument_list|(
name|_writefd
argument_list|,
name|msg
argument_list|)
operator|||
operator|!
name|wire_flush
argument_list|(
name|_writefd
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"Failed message forwarding to GIMP.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|g_print
argument_list|(
literal|"Waiting for return vals from GIMP...\n"
argument_list|)
expr_stmt|;
comment|/*  retrieve return vals, pass through to LGP  */
if|if
condition|(
operator|!
name|wire_read_msg
argument_list|(
name|_readfd
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"Failed to retrieve return vals from GIMP.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|g_print
argument_list|(
literal|"Forwarding return vals to LGP...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wire_write_msg
argument_list|(
name|fd
argument_list|,
name|msg
argument_list|)
operator|||
operator|!
name|wire_flush
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|g_warning
argument_list|(
literal|"Failed to forward return vals to LGP.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|g_print
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GP_PROC_RETURN
case|:
name|g_warning
argument_list|(
literal|"unexpected proc return message received from LGP(should not happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RUN
case|:
name|g_warning
argument_list|(
literal|"unexpected temp proc run message received from LGP(should not happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_TEMP_PROC_RETURN
case|:
name|g_print
argument_list|(
literal|"LGP returning!\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GP_PROC_INSTALL
case|:
comment|/*  don't forward this install request, as the main GIMP needn't know about it  */
break|break;
block|}
block|}
end_function

end_unit

