begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* edge.c: operations on edges in bitmaps.  *  * Copyright (C) 1992 Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"selection-to-path.h"
end_include

begin_include
include|#
directive|include
file|"edge.h"
end_include

begin_comment
comment|/* We can move in any of eight directions as we are traversing    the outline.  These numbers are not arbitrary; TRY_PIXEL depends on    them.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
DECL|enum|__anon2b8b0d280103
block|{
DECL|enumerator|north
DECL|enumerator|northwest
DECL|enumerator|west
DECL|enumerator|southwest
DECL|enumerator|south
name|north
init|=
literal|0
block|,
name|northwest
init|=
literal|1
block|,
name|west
init|=
literal|2
block|,
name|southwest
init|=
literal|3
block|,
name|south
init|=
literal|4
block|,
DECL|enumerator|southeast
DECL|enumerator|east
DECL|enumerator|northeast
name|southeast
init|=
literal|5
block|,
name|east
init|=
literal|6
block|,
name|northeast
init|=
literal|7
DECL|typedef|direction_type
block|}
name|direction_type
typedef|;
end_typedef

begin_function_decl
specifier|static
name|boolean
name|is_marked_edge
parameter_list|(
name|edge_type
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|bitmap_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|is_outline_edge
parameter_list|(
name|edge_type
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge_type
name|next_edge
parameter_list|(
name|edge_type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The following macros are used (directly or indirectly) by the    `next_outline_edge' routine.  */
end_comment

begin_comment
comment|/* Given the direction DIR of the pixel to test, decide which edge on    that pixel we are supposed to test.  Because we've chosen the mapping    from directions to numbers carefully, we don't have to do much.  */
end_comment

begin_define
DECL|macro|FIND_TEST_EDGE (dir)
define|#
directive|define
name|FIND_TEST_EDGE
parameter_list|(
name|dir
parameter_list|)
value|((dir) / 2)
end_define

begin_comment
comment|/* Find how to move in direction DIR on the axis AXIS (either `ROW' or   `COL').   We are in the ``display'' coordinate system, with y   increasing downward and x increasing to the right.  Therefore, we are   implementing the following table:    direction  row delta  col delta     north       -1          0     south	+1	    0     east	 0	   +1     west	 0	   +1    with the other four directions (e.g., northwest) being the sum of   their components (e.g., north + west).    The first macro, `COMPUTE_DELTA', handles splitting up the latter   cases, all of which have been assigned odd numbers.  */
end_comment

begin_define
DECL|macro|COMPUTE_DELTA (axis,dir)
define|#
directive|define
name|COMPUTE_DELTA
parameter_list|(
name|axis
parameter_list|,
name|dir
parameter_list|)
define|\
value|((dir) % 2 != 0							\     ? COMPUTE_##axis##_DELTA ((dir) - 1)				\       + COMPUTE_##axis##_DELTA (((dir) + 1) % 8)			\     : COMPUTE_##axis##_DELTA (dir)					\   )
end_define

begin_comment
comment|/* Now it is trivial to implement the four cardinal directions.  */
end_comment

begin_define
DECL|macro|COMPUTE_ROW_DELTA (dir)
define|#
directive|define
name|COMPUTE_ROW_DELTA
parameter_list|(
name|dir
parameter_list|)
define|\
value|((dir) == north ? -1 : (dir) == south ? +1 : 0)
end_define

begin_define
DECL|macro|COMPUTE_COL_DELTA (dir)
define|#
directive|define
name|COMPUTE_COL_DELTA
parameter_list|(
name|dir
parameter_list|)
define|\
value|((dir) == west ? -1 : (dir) == east ? +1 : 0)
end_define

begin_comment
comment|/* See if the appropriate edge on the pixel from (row,col) in direction    DIR is on the outline.  If so, update `row', `col', and `edge', and    break.  We also use the variable `character' as the bitmap in which    to look.  */
end_comment

begin_define
DECL|macro|TRY_PIXEL (dir)
define|#
directive|define
name|TRY_PIXEL
parameter_list|(
name|dir
parameter_list|)
define|\
value|{									\     int delta_r = COMPUTE_DELTA (ROW, dir);				\     int delta_c = COMPUTE_DELTA (COL, dir);				\     int test_row = *row + delta_r;					\     int test_col = *col + delta_c;					\     edge_type test_edge = FIND_TEST_EDGE (dir);				\ 									\     if (sel_valid_pixel(test_row, test_col)               		\&& is_outline_edge (test_edge, test_row, test_col))     	\       {									\         *row = test_row;						\         *col = test_col;						\         *edge = test_edge;						\         break;								\       }									\   }
end_define

begin_comment
comment|/* Finally, we are ready to implement the routine that finds the next    edge on the outline.  We look first for an adjacent edge that is not    on the current pixel.  We want to go around outside outlines    counterclockwise, and inside outlines clockwise (because that is how    both Metafont and Adobe Type 1 format want their curves to be drawn).     The very first outline (an outside one) on each character starts on a    top edge (STARTING_EDGE in edge.h defines this); so, if we're at a    top edge, we want to go only to the left (on the pixel to the west)    or down (on the same pixel), to begin with.  Then, when we're on a    left edge, we want to go to the top edge (on the southwest pixel) or    to the left edge (on the south pixel).     All well and good. But if you draw a rasterized circle (or whatever),    eventually we have to come back around to the beginning; at that    point, we'll be on a top edge, and we'll have to go to the right edge    on the northwest pixel.  Draw pictures.     The upshot is, if we find an edge on another pixel, we return (in ROW    and COL) the position of the new pixel, and (in EDGE) the kind of    edge it is.  If we don't find such an edge, we return (in EDGE) the    next (in a counterclockwise direction) edge on the current pixel.  */
end_comment

begin_function
name|void
DECL|function|next_outline_edge (edge_type * edge,unsigned * row,unsigned * col)
name|next_outline_edge
parameter_list|(
name|edge_type
modifier|*
name|edge
parameter_list|,
name|unsigned
modifier|*
name|row
parameter_list|,
name|unsigned
modifier|*
name|col
parameter_list|)
block|{
name|unsigned
name|original_row
init|=
operator|*
name|row
decl_stmt|;
name|unsigned
name|original_col
init|=
operator|*
name|col
decl_stmt|;
switch|switch
condition|(
operator|*
name|edge
condition|)
block|{
case|case
name|right
case|:
name|TRY_PIXEL
argument_list|(
name|north
argument_list|)
expr_stmt|;
name|TRY_PIXEL
argument_list|(
name|northeast
argument_list|)
expr_stmt|;
break|break;
case|case
name|top
case|:
name|TRY_PIXEL
argument_list|(
name|west
argument_list|)
expr_stmt|;
name|TRY_PIXEL
argument_list|(
name|northwest
argument_list|)
expr_stmt|;
break|break;
case|case
name|left
case|:
name|TRY_PIXEL
argument_list|(
name|south
argument_list|)
expr_stmt|;
name|TRY_PIXEL
argument_list|(
name|southwest
argument_list|)
expr_stmt|;
break|break;
case|case
name|bottom
case|:
name|TRY_PIXEL
argument_list|(
name|east
argument_list|)
expr_stmt|;
name|TRY_PIXEL
argument_list|(
name|southeast
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"next_outline_edge: Bad edge value (%d)"
argument_list|,
operator|*
name|edge
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't find an adjacent edge on another pixel, return the      next edge on the current pixel.  */
if|if
condition|(
operator|*
name|row
operator|==
name|original_row
operator|&&
operator|*
name|col
operator|==
name|original_col
condition|)
operator|*
name|edge
operator|=
name|next_edge
argument_list|(
operator|*
name|edge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We return the next edge on the pixel at position ROW and COL which is    an unmarked outline edge.  By ``next'' we mean either the one sent in    in STARTING_EDGE, if it qualifies, or the next such returned by    `next_edge'.  */
end_comment

begin_function
name|edge_type
DECL|function|next_unmarked_outline_edge (unsigned row,unsigned col,edge_type starting_edge,bitmap_type marked)
name|next_unmarked_outline_edge
parameter_list|(
name|unsigned
name|row
parameter_list|,
name|unsigned
name|col
parameter_list|,
name|edge_type
name|starting_edge
parameter_list|,
name|bitmap_type
name|marked
parameter_list|)
block|{
name|edge_type
name|edge
init|=
name|starting_edge
decl_stmt|;
name|assert
argument_list|(
name|edge
operator|!=
name|no_edge
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_marked_edge
argument_list|(
name|edge
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|marked
argument_list|)
operator|||
operator|!
name|is_outline_edge
argument_list|(
name|edge
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
condition|)
block|{
name|edge
operator|=
name|next_edge
argument_list|(
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|==
name|starting_edge
condition|)
return|return
name|no_edge
return|;
block|}
return|return
name|edge
return|;
block|}
end_function

begin_comment
comment|/* We check to see if the edge EDGE of the pixel at position ROW and COL    is an outline edge; i.e., that it is a black pixel which shares that    edge with a white pixel.  The position ROW and COL should be inside    the bitmap CHARACTER.  */
end_comment

begin_function
name|boolean
DECL|function|is_outline_edge (edge_type edge,unsigned row,unsigned col)
name|is_outline_edge
parameter_list|(
name|edge_type
name|edge
parameter_list|,
name|unsigned
name|row
parameter_list|,
name|unsigned
name|col
parameter_list|)
block|{
comment|/* If this pixel isn't black, it's not part of the outline.  */
if|if
condition|(
name|sel_pixel_is_white
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|edge
condition|)
block|{
case|case
name|left
case|:
return|return
name|col
operator|==
literal|0
operator|||
name|sel_pixel_is_white
argument_list|(
name|row
argument_list|,
name|col
operator|-
literal|1
argument_list|)
return|;
case|case
name|top
case|:
return|return
name|row
operator|==
literal|0
operator|||
name|sel_pixel_is_white
argument_list|(
name|row
operator|-
literal|1
argument_list|,
name|col
argument_list|)
return|;
case|case
name|right
case|:
return|return
operator|(
name|col
operator|==
name|sel_get_width
argument_list|()
operator|-
literal|1
operator|)
operator|||
name|sel_pixel_is_white
argument_list|(
name|row
argument_list|,
name|col
operator|+
literal|1
argument_list|)
return|;
case|case
name|bottom
case|:
return|return
operator|(
name|row
operator|==
name|sel_get_height
argument_list|()
operator|-
literal|1
operator|)
operator|||
name|sel_pixel_is_white
argument_list|(
name|row
operator|+
literal|1
argument_list|,
name|col
argument_list|)
return|;
case|case
name|no_edge
case|:
default|default:
name|printf
argument_list|(
literal|"is_outline_edge: Bad edge value(%d)"
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* If EDGE is not already marked, we mark it; otherwise, it's a fatal error.    The position ROW and COL should be inside the bitmap MARKED.  EDGE can    be `no_edge'; we just return false.  */
end_comment

begin_function
name|void
DECL|function|mark_edge (edge_type edge,unsigned row,unsigned col,bitmap_type * marked)
name|mark_edge
parameter_list|(
name|edge_type
name|edge
parameter_list|,
name|unsigned
name|row
parameter_list|,
name|unsigned
name|col
parameter_list|,
name|bitmap_type
modifier|*
name|marked
parameter_list|)
block|{
comment|/* printf("row = %d, col = %d \n",row,col); */
name|assert
argument_list|(
operator|!
name|is_marked_edge
argument_list|(
name|edge
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
operator|*
name|marked
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|!=
name|no_edge
condition|)
name|BITMAP_PIXEL
argument_list|(
operator|*
name|marked
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
operator||=
literal|1
operator|<<
name|edge
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test if the edge EDGE at ROW/COL in MARKED is marked.  */
end_comment

begin_function
specifier|static
name|boolean
DECL|function|is_marked_edge (edge_type edge,unsigned row,unsigned col,bitmap_type marked)
name|is_marked_edge
parameter_list|(
name|edge_type
name|edge
parameter_list|,
name|unsigned
name|row
parameter_list|,
name|unsigned
name|col
parameter_list|,
name|bitmap_type
name|marked
parameter_list|)
block|{
return|return
name|edge
operator|==
name|no_edge
condition|?
name|false
else|:
name|BITMAP_PIXEL
argument_list|(
name|marked
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|edge
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the edge which is counterclockwise-adjacent to EDGE.  This    code makes use of the ``numericness'' of C enumeration constants;    sorry about that.  */
end_comment

begin_define
DECL|macro|NUM_EDGES
define|#
directive|define
name|NUM_EDGES
value|no_edge
end_define

begin_function
specifier|static
name|edge_type
DECL|function|next_edge (edge_type edge)
name|next_edge
parameter_list|(
name|edge_type
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|==
name|no_edge
condition|?
name|edge
else|:
operator|(
name|edge
operator|+
literal|1
operator|)
operator|%
name|NUM_EDGES
return|;
block|}
end_function

end_unit

