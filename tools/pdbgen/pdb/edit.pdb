# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

# Common arguments
sub inargs {
    @inargs = (
	{ name => 'drawable', type => 'drawable',
	  desc => "The drawable to @{[shift]}" }
    );
}

sub drawable_arg () {{
    name => 'drawable',
    type => 'drawable',
    desc => 'The affected drawable',
}}

sub sample_merged_arg () {{
    name => 'sample_merged',
    type => 'boolean',
    desc => 'Use the composite image, not the drawable'
}}

# Common invoker for checking for image/drawable consistency
sub invoke {
    %invoke = (
	headers => [ qw("core/gimp.h") ],
	vars => [ 'GimpImage *gimage' ],
	code => <<CODE
{
  gimage = gimp_item_get_image (GIMP_ITEM (drawable));
  success = @{[shift]};
}
CODE
    );
}

# The defs

sub edit_cut {
    $blurb = 'Cut from the specified drawable.';

    $help = <<'HELP';
If there is a selection in the image, then the area specified by the selection
is cut from the specified drawable and placed in an internal GIMP edit buffer.
It can subsequently be retrieved using the 'gimp-edit-paste' command. If there
is no selection, then the specified drawable will be removed and its contents
stored in the internal GIMP edit buffer. The drawable MUST belong to the
specified image, or an error is returned.
HELP

    &std_pdb_misc;
    &inargs('cut from');
    &invoke('gimp_edit_cut (gimage, drawable) != NULL');
}

sub edit_copy {
    $blurb = 'Copy from the specified drawable.';

    $help = <<'HELP';
If there is a selection in the image, then the area specified by the selection
is copied from the specified drawable and placed in an internal GIMP edit
buffer. It can subsequently be retrieved using the 'gimp-edit-paste' command.
If there is no selection, then the specified drawable's contents will be stored
in the internal GIMP edit buffer. The drawable MUST belong to the specified
image, or an error is returned.
HELP

    &std_pdb_misc;
    &inargs('copy from');
    &invoke('gimp_edit_copy (gimage, drawable) != NULL');
}

sub edit_paste {
    $blurb = 'Paste buffer to the specified drawable.';

    $help = <<'HELP';
This procedure pastes a copy of the internal GIMP edit buffer to the specified
drawable. The GIMP edit buffer will be empty unless a call was previously made
to either 'gimp-edit-cut' or 'gimp-edit-copy'. The "paste_into" option
specifies whether to clear the current image selection, or to paste the buffer
"behind" the selection. This allows the selection to act as a mask for the
pasted buffer. Anywhere that the selection mask is non-zero, the pasted buffer
will show through. The pasted buffer will be a new layer in the image which is
designated as the image floating selection. If the image has a floating
selection at the time of pasting, the old floating selection will be anchored
to it's drawable before the new floating selection is added. This procedure
returns the new floating layer. The resulting floating selection will already
be attached to the specified drawable, and a subsequent call to
floating_sel_attach is not needed.
HELP

    &std_pdb_misc;

    &inargs('paste to');
    push @inargs, { name => 'paste_into', type => 'boolean',
		    desc => 'Clear selection, or paste behind it?' };

    @outargs = (
	{ name  => 'floating_sel', type  => 'layer',
	  desc  => 'The new floating selection', alias => 'layer', init => 1 }
    );

    %invoke = (
	headers => [ qw("core/gimp.h") ],
	code => <<CODE
{
  GimpImage *gimage = gimp_item_get_image (GIMP_ITEM (drawable));

  success = gimp_image_owns_item (gimage, GIMP_ITEM (drawable));

  if (success)
    {
      layer = gimp_edit_paste (gimage, drawable, gimp->global_buffer,
                               paste_into, -1, -1, -1, -1);
      if (! layer)
        success = FALSE;
    }
}
CODE
    )
}

sub edit_clear {
    $blurb = 'Clear selected area of drawable.';

    $help = <<'HELP';
This procedure clears the specified drawable. If the drawable has an alpha
channel, the cleared pixels will become transparent. If the drawable does not
have an alpha channel, cleared pixels will be set to the background color. This
procedure only affects regions within a selection if there is a selection
active.
HELP

    &std_pdb_misc;
    &inargs('clear from');
    &invoke('gimp_edit_clear (gimage, drawable)');
}

sub edit_fill {
    $blurb = 'Fill selected area of drawable.';

    $help = <<'HELP';
This procedure fills the specified drawable with the fill mode. If the fill
mode is foreground, the current foreground color is used. If the fill mode is
background, the current background color is used. Other fill modes should not
be used. This procedure only affects regions within a selection if there is a
selection active.
HELP

    &std_pdb_misc;
    $author .= ' & Raphael Quinet';
    $date = '1995-2000';
    @inargs = (
	{ name => 'drawable', type => 'drawable',
	  desc => "The drawable to fill to" },
	{ name => 'fill_type', type => 'enum GimpFillType',
	  desc => 'The type of fill: %%desc%%' }
    );
    &invoke('gimp_edit_fill (gimage, drawable, (GimpFillType) fill_type)');
}

sub edit_bucket_fill {
    $blurb = <<'BLURB';
Fill the area specified either by the current selection if there is one, or by
a seed fill starting at the specified coordinates.
BLURB

    $help = <<'HELP';
This tool requires information on the paint application mode, and the
fill mode, which can either be in the foreground color, or in the
currently active pattern. If there is no selection, a seed fill is
executed at the specified coordinates and extends outward in keeping
with the threshold parameter. If there is a selection in the target
image, the threshold, sample merged, x, and y arguments are unused. If
the sample_merged parameter is non-zero, the data of the composite
image will be used instead of that for the specified drawable.  This
is equivalent to sampling for colors after merging all visible
layers. In the case of merged sampling, the x and y coordinates are
relative to the image's origin; otherwise, they are relative to the
drawable's origin.
HELP

    &std_pdb_misc;

    my $validity = 'This parameter is only valid when there is no selection in
		    the specified image.';

    @inargs = (
	&drawable_arg,
	{ name => 'fill_mode', type => 'enum GimpBucketFillMode',
	  desc => 'The type of fill: { %%desc%% }' },
	{ name => paint_mode, type => 'enum GimpLayerModeEffects',
	  desc => 'The paint application mode: { %%desc%% }' },
	{ name => 'opacity', type => '0 <= float <= 100',
	  desc => 'The opacity of the final bucket fill (%%desc%%)' },
	{ name => 'threshold', type => '0 <= float <= 255',
	  desc => "The threshold determines how extensive the seed fill will
		   be. It's value is specified in terms of intensity levels
		   (%%desc%%). $validity" },
	&sample_merged_arg
    );

    foreach (qw(x y)) {
	push @inargs, { name => $_, type => 'float',
			desc => "The $_ coordinate of this bucket fill's
				 application. $validity" }
    }

    %invoke = (
        headers => [ qw ("core/gimpdrawable-bucket-fill.h"
	                 "core/gimpchannel.h") ],
	code => <<'CODE'
{
  GimpImage *gimage = gimp_item_get_image (GIMP_ITEM (drawable));

  if (! gimage)
    {
      success = FALSE;
    }
  else
    {
      gboolean do_seed_fill;

      do_seed_fill = gimp_channel_is_empty (gimp_image_get_mask (gimage));

      gimp_drawable_bucket_fill (drawable, fill_mode,
                                 paint_mode, opacity / 100.0,
                                 do_seed_fill,
                                 FALSE /* don't fill transparent */,
	                         threshold, sample_merged, x, y);
    }
}
CODE
    );
}

sub edit_blend {
    $blurb = <<'BLURB';
Blend between the starting and ending coordinates with the specified blend mode
and gradient type.
BLURB

    $help = <<'HELP';
This tool requires information on the paint application mode, the blend mode,
and the gradient type. It creates the specified variety of blend using the
starting and ending coordinates as defined for each gradient type.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
        { name => 'blend_mode', type => 'enum GimpBlendMode',
	  desc => 'The type of blend: { %%desc%% }' },
	{ name => 'paint_mode', type => 'enum GimpLayerModeEffects',
	  desc => 'The paint application mode: { %%desc%% }' },
	{ name => 'gradient_type',  type => 'enum GimpGradientType',
	  desc => 'The type of gradient: { %%desc%% }' },
	{ name => 'opacity', type => '0 <= float <= 100',
	  desc => 'The opacity of the final blend (%%desc%%)' },
	{ name => 'offset', type => '0 <= float',
	  desc => 'Offset relates to the starting and ending coordinates
		   specified for the blend. This parameter is mode dependent
		   (%%desc%%)' },
	{ name => 'repeat', type => 'enum GimpRepeatMode',
	  desc => 'Repeat mode: { %%desc%% }' },
	{ name => 'reverse', type => 'boolean',
	  desc => 'Use the reverse gradient (%%desc%%)' },
	{ name => 'supersample', type => 'boolean',
	  desc => 'Do adaptive supersampling (%%desc%%)' },
	{ name => 'max_depth', type => '1 <= int32 <= 9',
	  desc => 'Maximum recursion levels for supersampling',
	  cond => [ 'supersample' ] },
	{ name => 'threshold', type => '0 <= float <= 4',
	  desc => 'Supersampling threshold',
	  cond => [ 'supersample' ] },
	{ name => 'dither', type => 'boolean',
	  desc => 'Use dithering to reduce banding (%%desc%%)' },
	{ name => 'x1', type => 'float',
	  desc => "The x coordinate of this blend's starting point" },
	{ name => 'y1', type => 'float',
	  desc => "The y coordinate of this blend's starting point" },
	{ name => 'x2', type => 'float',
	  desc => "The x coordinate of this blend's ending point" },
	{ name => 'y2', type => 'float',
	  desc => "The y coordinate of this blend's ending point" }
    );

    %invoke = (
        headers => [ qw("core/gimpdrawable-blend.h") ],
	code => <<'CODE'
{
  if (! gimp_item_get_image (GIMP_ITEM (drawable)))
    {
      success = FALSE;
    }
  else
    {
      gimp_drawable_blend (drawable,
                           blend_mode,
                           paint_mode,
                           gradient_type,
                           opacity / 100.0,
	                   offset, repeat, reverse,
                           supersample, max_depth,
                           threshold, dither,
                           x1, y1, x2, y2,
	                   NULL, NULL);
    }
}
CODE
    );
}

sub edit_stroke {
    $blurb = 'Stroke the current selection';

    $help = <<'HELP';
This procedure strokes the current selection, painting along the selection
boundary with the active brush and foreground color. The paint is applied to
the specified drawable regardless of the active selection.
HELP

    &std_pdb_misc;
    &inargs('stroke to');

    %invoke = (
	headers => [ qw("core/gimpcontext.h" "core/gimptoolinfo.h") ],
	code => <<'CODE'
{
  GimpImage    *gimage;
  GimpToolInfo *tool_info;

  gimage = gimp_item_get_image (GIMP_ITEM (drawable));

  tool_info = gimp_context_get_tool (gimp_get_current_context (gimp));

  success = gimp_item_stroke (GIMP_ITEM (gimp_image_get_mask (gimage)),
                              drawable,
                              GIMP_OBJECT (tool_info->paint_info),
                              TRUE /* use defaults, not tool option values */);
}
CODE
    );
}

@headers = qw("core/gimpimage.h" "core/gimp-edit.h");

@procs = qw(edit_cut edit_copy edit_paste edit_clear
            edit_fill edit_bucket_fill edit_blend edit_stroke);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Edit procedures';

1;
