# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Andy Thomas <alt@gimp.org>

sub path_list {
    $blurb = 'List the paths associated with the passed image.';

    $help = <<'HELP';
List the paths associated with the passed image.
HELP

    &andy_pdb_misc('1999');

    @inargs = ( &std_image_arg );
    $inargs[0]->{desc} = 'The ID of the image to list the paths from';

    @outargs = (
	{ name => 'path_list', type => 'stringarray',
	  desc => 'List of the paths belonging to this image.',
	  array => { name => 'num_paths',
		     desc => 'The number of paths returned.' },
	  init => 1 }
    );

    %invoke = (
	code => 'path_list = gimp_container_get_name_array (gimage->vectors, &num_paths);'
    );
}

sub path_get_points {
    $blurb = 'List the points associated with the named path.';

    $help = <<'HELP';
List the points associated with the named path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path whose points should be listed.' }
    );
    $inargs[0]->{desc} = 'The ID of the image to list the paths from.';

    @outargs = (
	{ name => 'path_type', type => 'int32', init => 1,
	  desc => 'The type of the path. Currently only one type (1 = Bezier)
		   is supported' },
	{ name => 'path_closed', type => 'int32', init => 1,
	  desc => 'Return if the path is closed. (0 = path open, 1 = path
		   closed)' },
	{ name => 'points_pairs', type => 'floatarray',
	  desc => 'The points in the path represented as 3 floats. The first is
		   the x pos, next is the y pos, last is the type of the pnt.
		   The type field is dependant on the path type. For beziers
		   (type 1 paths) the type can either be (1.0 = BEZIER_ANCHOR,
		   2.0 = BEZIER_CONTROL, 3.0 = BEZIER_MOVE). Note all points
		   are returned in pixel resolution.',
	  init => 1,
	  array => { name => 'num_path_point_details',
		     desc => 'The number of points returned. Each point is
			      made up of (x, y, pnt_type) of floats.',
		     alias => 'num_point_details', init => 1 } }
    );

    %invoke = (
	vars => [ 'GimpVectors *vectors' ],
	code => <<'CODE'
{
  vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    {
      GimpVectorsCompatPoint *points;
      gint num_points;

      path_type = 1; /* BEZIER (1.2 compat) */

      points = gimp_vectors_compat_get_points (vectors, &num_points,
                                               &path_closed);

      num_point_details = num_points * 3;

      if (points)
        {
          gdouble *curr_point;
          gint     i;

          points_pairs = g_new0 (gdouble, num_point_details);

          for (i = 0, curr_point = points_pairs;
               i < num_points;
               i++, curr_point += 3)
            {
              curr_point[0] = points[i].x;
              curr_point[1] = points[i].y;
              curr_point[2] = points[i].type;
            }

          g_free (points);
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub path_get_current {
    $blurb = 'The name of the current path. Error if no paths.';

    $help = <<'HELP';
The name of the current path. Error if no paths.
HELP

    &andy_pdb_misc('1999');

    @inargs = ( &std_image_arg );
    $inargs[0]->{desc} = 'The ID of the image to get the current path from.';

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => 'The name of the current path.',
	  init => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_active_vectors (gimage);

  if (vectors)
    name = g_strdup (gimp_object_get_name (GIMP_OBJECT (vectors)));
  else
    success = FALSE;
}
CODE
    );
}

sub path_set_current {
    $blurb = 'Sets the current path associated with the passed image.';

    $help = <<'HELP';
Sets a named path as the current path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path to make current.' }
    );
    $inargs[0]->{desc} = 'The ID of the image in which a path will become current.';

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    gimp_image_set_active_vectors (gimage, vectors);
  else
    success = FALSE;
}
CODE
    );
}

sub path_set_points {
    $blurb = 'Set the points associated with the named path.';

    $help = <<'HELP';
Set the points associated with the named path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path to create. If it exists then a unique
		   name will be created - query the list of paths if you want
		   to make sure that the name of the path you create is 
		   unique. This will be set as the current path.',
	  init => 1 },
	{ name => 'ptype', type => 'int32',
	  desc => 'The type of the path. Currently only one type (1 = Bezier)
		   is supported.' },
	{ name => 'points_pairs', type => 'floatarray',
	  desc => 'The points in the path represented as 3 floats. The first is
		   the x pos, next is the y pos, last is the type of the pnt.
		   The type field is dependant on the path type. For beziers
		   (type 1 paths) the type can either be (1.0 = BEZIER_ANCHOR,
		   2.0 = BEZIER_CONTROL, 3.0= BEZIER_MOVE). Note all points are
		   returned in pixel resolution.',
	  array => { name => 'num_path_points',
		     desc => 'The number of elements in the array, i.e. the number
			      of points in the path * 3. Each point is
			      made up of (x, y, type) of floats. Currently only
			      the creation of bezier curves is allowed. The type
			      parameter must be set to (1) to indicate a BEZIER
			      type curve. Note that for BEZIER curves, points
			      must be given in the following order: ACCACCAC...
			      If the path is not closed the last control
			      point is missed off. Points consist of three
			      control points (control/anchor/control) so for a
			      curve that is not closed there must be at least
			      two points passed (2 x,y pairs). If
			      (num_path_points/3) % 3 = 0 then the path is
			      assumed to be closed and the points are
			      ACCACCACCACC.',
		     init => 1 } }
    );
    $inargs[0]->{desc} = 'The ID of the image to set the paths in.';

    %invoke = (
	code  => <<'CODE'
{
  gboolean closed = FALSE;

  if ((num_path_points / 3) % 3 == 0)
    closed = TRUE;
  else if ((num_path_points / 3) % 3 != 2)
    success = FALSE;

  if (success)
    {
      GimpVectors            *vectors;
      gdouble                *curr_point_pair;
      GimpVectorsCompatPoint *points;
      gint                    n_points;
      gint                    i;

      n_points = num_path_points / 3;

      points = g_new0 (GimpVectorsCompatPoint, n_points);

      for (i = 0, curr_point_pair = points_pairs;
           i < n_points;
           i++, curr_point_pair += 3)
        {
          points[i].x    = curr_point_pair[0];
          points[i].y    = curr_point_pair[1];
          points[i].type = curr_point_pair[2];
        }

      vectors = gimp_vectors_compat_new (gimage, name, points, n_points,
                                         closed);

      g_free (points);

      if (vectors)
        gimp_image_add_vectors (gimage, vectors, 0);
      else
        success = FALSE;
    }
}
CODE
    );
}

sub path_stroke_current {
    $blurb = 'Stroke the current path in the passed image.';

    $help = <<'HELP';
Stroke the current path in the passed image.
HELP

    &andy_pdb_misc('1999');

    @inargs = ( &std_image_arg );
    $inargs[0]->{desc} = 'The ID of the image which contains the path to
			  stroke.';

    %invoke = (
	headers => [ qw("core/gimpstrokedesc.h") ],
	code => <<'CODE'
{
  GimpVectors  *vectors  = gimp_image_get_active_vectors (gimage);
  GimpDrawable *drawable = gimp_image_active_drawable (gimage);

  if (vectors && drawable)
    {
      GimpStrokeDesc *desc = gimp_stroke_desc_new (gimp, context);

      g_object_set (desc, "method", GIMP_STROKE_METHOD_PAINT_CORE, NULL);

      success = gimp_item_stroke (GIMP_ITEM (vectors),
                                  drawable, context, desc, TRUE);

      g_object_unref (desc);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub  path_get_point_at_dist {
    $blurb = 'Get point on a path at a specified distance along the path.';

    $help = <<'HELP';
This will return the x,y position of a point at a given distance along the
bezier curve. The distance will be obtained by first digitizing the 
curve internally and then walking along the curve. For a closed curve the
start of the path is the first point on the path that was created. This might
not be obvious. Note the current path is used.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'distance', type => 'float',
	  desc => 'The distance along the path.' }
    );
    $inargs[0]->{desc} = 'The ID of the image the paths belongs to';

    @outargs = (
	{ name => 'x_point', type => 'int32',
	  desc => 'The x position of the point.', init => 1 },
	{ name => 'y_point', type => 'int32',
	  desc => 'The y position of the point.', init => 1 },
	{ name => 'slope', type => 'float',
	  desc => 'The slope (dy / dx) at the specified point.', init => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors;
  GimpStroke  *stroke;
  gdouble      distance_along;
  gdouble      stroke_length;
  gdouble      stroke_distance;
  GimpCoords   position;

  vectors = gimp_image_get_active_vectors (gimage);

  if (vectors)
    {
      distance_along = 0.0;
      stroke = gimp_vectors_stroke_get_next (vectors, NULL);

      while (stroke != NULL )
        {
          stroke_length = gimp_stroke_get_length (stroke, 0.5);

          if (distance_along + stroke_length < distance)
            {
              distance_along += stroke_length;
            }
          else
            {
              stroke_distance = distance - distance_along;
              stroke_distance = stroke_distance < 0 ? 0: stroke_distance;

              if (!gimp_stroke_get_point_at_dist (stroke, stroke_distance, 0.5,
	                                          &position, &slope))
                {
                  success = FALSE;
                  break;
                }
              else
                {
                  success = TRUE;
                  x_point = ROUND (position.x);
                  y_point = ROUND (position.y);
                  break;
                }
            }

          stroke = gimp_vectors_stroke_get_next (vectors, stroke);
        }
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub path_get_tattoo {
    $blurb = 'Returns the tattoo associated with the name path.';

    $help = <<'HELP';
This procedure returns the tattoo associated with the specified path.  A
tattoo is a unique and permanent identifier attached to a path that can
be used to uniquely identify a path within an image even between sessions.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path whose tattoo should be obtained.' }
    );

    @outargs = (
	{ name => 'tattoo', type => 'int32',
	  desc => 'The tattoo associated with the named path.', init => 1  }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    tattoo = gimp_item_get_tattoo (GIMP_ITEM (vectors));
  else
    success = FALSE;
}
CODE
    );
}

sub path_set_tattoo {
    $blurb = 'Sets the tattoo associated with the named path.';

    $help = <<'HELP';
This procedure sets the tattoo associated with the specified path.  A
tattoo is a unique and permenant identifier attached to a path that
can be used to uniquely identify a path within an image even between
sessions. Note that the value passed to this function must have been
obtained from a previous call to path_get_tattoo.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'the name of the path whose tattoo should be set' },
        { name => 'tattovalue', type => 'int32',
	  desc => "The tattoo associated with the name path. Only values
		   returned from 'path_get_tattoo' should be used here",
		   init => 1  }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    gimp_item_set_tattoo (GIMP_ITEM (vectors), tattovalue);
  else
    success = FALSE;
}
CODE
    );
}


sub get_path_by_tattoo {
    $blurb = 'Return the name of the path with the given tattoo.';

    $help = <<'HELP';
The procedure returns the name of the path in the specified image
which has the passed tattoo. The tattoos are unique within the image
and will be preserved across sessions and through renaming of the path.
An error is returned if no path with the specified tattoo can be found.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'tattoo', type => 'int32',
	  desc => 'The tattoo of the required path.' }
    );

    @outargs = (
	{ name => 'name', type => 'string', init => 1,
	  desc => 'The name of the path with the specified tattoo.' }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_tattoo (gimage, tattoo);

  if (vectors)
    name = g_strdup (gimp_object_get_name (GIMP_OBJECT (vectors)));
  else
    success = FALSE;
}
CODE
    );
}

sub path_delete {
    $blurb = 'Delete the named path associated with the passed image.';

    $help = <<'HELP';
Delete the named path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path to delete.' }
    );
    $inargs[0]->{desc} = 'The ID of the image to delete the path from.';

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    gimp_image_remove_vectors (gimage, vectors);
  else
    success = FALSE;
}
CODE
    );
}

sub path_get_locked {
    $blurb = 'Returns the locked status associated with the named path.';

    $help = <<'HELP';
This procedure returns the lock status associated with the specified
path.  A path can be "locked" which means that the transformation
tool operations will also apply to the path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path whose locked status should be
		   obtained.' }
    );

    @outargs = (
	{ name => 'locked', type => 'boolean',
	  desc => 'TRUE if the path is locked, FALSE otherwise', init => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    locked = gimp_item_get_linked (GIMP_ITEM (vectors));
  else
    success = FALSE;
}
CODE
    );
}

sub path_set_locked {
    $blurb = 'Set the locked status associated with the named path.';

    $help = <<'HELP';
This procedure sets the lock status associated with the specified path.  A
path can be "locked" which means that the transformation tool operations
will also apply to the path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'the name of the path whose locked status should be set' },
	{ name => 'locked', type => 'boolean',
	  desc => 'Whether the path is locked', init => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    gimp_item_set_linked (GIMP_ITEM (vectors), locked, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub path_get_visible {
    $blurb = 'Get the visibility of the named path.';

    $help = <<'HELP';
This procedure returns the visibility of the specified path.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path whose visibility should be obtained.' }
    );

    @outargs = (
	{ name => 'visible', type => 'boolean',
	  desc => 'TRUE if the path is visible, FALSE otherwise', init => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    visible = gimp_item_get_visible (GIMP_ITEM (vectors));
  else
    success = FALSE;
}
CODE
    );
}

sub path_set_visible {
    $blurb = 'Sets the visibility of the named path.';

    $help = <<'HELP';
This procedure sets the specified path's visibility.
HELP

    &neo_pdb_misc('2005', '2.4');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path whose visibility should be set' },
	{ name => 'visible', type => 'boolean',
	  desc => 'The new path visibility', init => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    gimp_item_set_visible (GIMP_ITEM (vectors), visible, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub path_to_selection {
    $blurb = 'Transforms the active path into a selection';

    $help = <<'HELP';
This procedure renders the desired path into the current selection.
HELP

    &joao_pdb_misc('2003');

    @inargs = (
	&std_image_arg,
	{ name => 'name', type => 'string',
	  desc => 'The name of the path which should be made into selection.' },
        { name => 'op', type => 'enum GimpChannelOps',
	  desc => 'The desired operation with current selection.' },
	{ name => 'antialias', type => 'boolean',
	  desc => 'Antialias selection.' },
	{ name => 'feather', type => 'boolean',
	  desc => 'Feather selection.' },
	{ name => 'feather_radius_x', type => 'float',
	  desc => 'Feather radius x.'  },
	{ name => 'feather_radius_y', type => 'float',
	  desc => 'Feather radius y.'  }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpVectors *vectors = gimp_image_get_vectors_by_name (gimage, name);

  if (vectors)
    gimp_channel_select_vectors (gimp_image_get_mask (gimage),
                                 _("Path to Selection"),
                                 vectors,
                                 op,
                                 antialias,
                                 feather,
                                 feather_radius_x,
                                 feather_radius_y);
  else
    success = FALSE;
}
CODE
    );
}

sub path_import {
    $blurb = 'Import paths from an SVG file.';

    $help = <<'HELP';
This procedure imports paths from an SVG file. SVG elements other than
paths and basic shapes are ignored.
HELP

    &neo_pdb_misc('2003');

    @inargs = (
	&std_image_arg,
	{ name => 'filename', type => 'string', no_validate => 1,
	  desc => 'The name of the SVG file to import.' },
	{ name => 'merge', type => 'boolean',
	  desc => 'Merge paths into a single vectors object.' },
	{ name => 'scale', type => 'boolean',
	  desc => 'Scale the SVG to image dimensions.' }
    );

    %invoke = (
        headers => [ qw("vectors/gimpvectors-import.h") ],
	code    => 'success = gimp_vectors_import_file (gimage, filename, merge, scale, -1, NULL);'
    );
}

sub path_import_string {
    $blurb = 'Import paths from an SVG string.';

    $help = <<'HELP';
This procedure works like gimp_path_import() but takes a string rather
than reading the SVG from a file. This allows you to write scripts that
generate SVG and feed it to GIMP.
HELP

    &neo_pdb_misc('2005', '2.4');

    @inargs = (
	&std_image_arg,
	{ name => 'string', type => 'string', no_validate => 1,
	  desc => 'A string that must be a complete and valid SVG document.' },
	{ name => 'length', type => 'int32',
	  desc => 'Number of bytes in string or -1 if the string is NULL terminated.' },
	{ name => 'merge', type => 'boolean',
	  desc => 'Merge paths into a single vectors object.' },
	{ name => 'scale', type => 'boolean',
	  desc => 'Scale the SVG to image dimensions.' }
    );

    %invoke = (
        headers => [ qw("vectors/gimpvectors-import.h") ],
	code    => 'success = gimp_vectors_import_buffer (gimage, string, length, merge, scale, -1, NULL);'
    );
}

@headers = qw(<string.h> "core/gimp.h" "core/gimplist.h"
              "core/gimpchannel-select.h"
              "vectors/gimpanchor.h" "vectors/gimpbezierstroke.h"
              "vectors/gimpvectors.h" "vectors/gimpvectors-compat.h"
              "gimp-intl.h");

@procs = qw(path_list path_get_current path_set_current path_delete
	    path_get_points path_set_points
            path_stroke_current path_get_point_at_dist
	    path_get_tattoo path_set_tattoo get_path_by_tattoo
            path_get_locked path_set_locked
            path_get_visible path_set_visible
            path_to_selection path_import path_import_string);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Paths';

1;
