# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub color_blurb {
    $blurb = "@{[shift]} the current GIMP @{[shift]}ground color.";
}

sub palette_arg () {{
    name => 'name',
    type => 'string',
    desc => 'The palette name'
}}

sub dim_args () {
    my @args;
    foreach (qw(num_colors)) {
        push @args, { name => $_, type => 'int32', desc => "The palette $_" };
    }
    @args;
}

sub palette_outargs {
    foreach (@outargs) {
        my $alias;
        if ($_->{type} eq 'string') {
            $alias = "GIMP_OBJECT (palette)->$_->{name}";
        } else {
            $alias = "palette->$_->{name}";
        }
        $alias = "g_strdup ($alias)" if $_->{type} eq 'string';
        $alias =~ s/num_colors/n_colors/ if $_->{name} =~ /num_colors/;
        $_->{alias} = $alias;
        $_->{no_declare} = 1;
    }
}

sub color_arg {
    my $ground = (shift) . "ground";
    {
	name     => $ground,
	type     => 'color',
	desc     => "The $ground color",
	alias    => 'color',
	void_ret => 1
    }
}

sub invoke_get {
    %invoke = (
	code => <<CODE
{
  gimp_context_get_@{[shift]}ground (gimp_get_current_context (gimp), &color);
}
CODE
    );
}

sub invoke_set {
    %invoke = (
	code => <<CODE
{
  gimp_rgb_set_alpha (&color, 1.0);
  gimp_context_set_@{[shift]}ground (gimp_get_current_context (gimp), &color);
}
CODE
    );
}

sub palette_get_foreground {
    &color_blurb('Get', 'fore');

    $help = <<'HELP';
This procedure retrieves the current GIMP foreground color. The foreground
color is used in a variety of tools such as paint tools, blending, and bucket
fill.
HELP

    &std_pdb_misc;
    @outargs = ( &color_arg('fore') );
    &invoke_get('fore');
}

sub palette_get_background {
    &color_blurb('Get', 'back');

    $help = <<'HELP';
This procedure retrieves the current GIMP background color. The background
color is used in a variety of tools such as blending, erasing (with non-alpha
images), and image filling.
HELP

    &std_pdb_misc;
    @outargs = ( &color_arg('back') );
    &invoke_get('back');
}

sub palette_set_foreground {
    &color_blurb('Set', 'fore');

    $help = <<'HELP';
This procedure sets the current GIMP foreground color. After this is set,
operations which use foreground such as paint tools, blending, and bucket fill
will use the new value.
HELP

    &std_pdb_misc;
    @inargs = ( &color_arg('fore') );
    &invoke_set('fore');
}

sub palette_set_background {
    &color_blurb('Set', 'back');

    $help = <<'HELP';
This procedure sets the current GIMP background color. After this is set,
operations which use background such as blending, filling images, clearing,
and erasing (in non-alpha images) will use the new value.
HELP

    &std_pdb_misc;
    @inargs = ( &color_arg('back') );
    &invoke_set('back');
}

sub palette_set_default_colors {
    $blurb = <<'BLURB';
Set the current GIMP foreground and background colors to black and white.
BLURB

    $help = <<'HELP';
This procedure sets the current GIMP foreground and background colors to their
initial default values, black and white.
HELP

    &std_pdb_misc;

    %invoke = ( code => 'gimp_context_set_default_colors (gimp_get_current_context (gimp));' );
}

sub palette_swap_colors {
    $blurb = 'Swap the current GIMP foreground and background colors.';

    $help = <<'HELP';
This procedure swaps the current GIMP foreground and background colors, so that
the new foreground color becomes the old background color and vice versa.
HELP

    &std_pdb_misc;

    %invoke = ( code => 'gimp_context_swap_colors (gimp_get_current_context (gimp));' );
}

sub palette_refresh {
    $blurb = 'Refreshes current palettes.';

    $help = <<'HELP';
This procedure incorporates all palettes currently in the users palette path.
HELP

    $author = 'Adrian Likins <adrian@gimp.org>';
    $copyright = 'Adrian Likins';
    $date = '1998';

    %invoke = (
	code => <<'CODE'
{
  /* FIXME: I've hardcoded success to be TRUE, because brushes_init() is a 
   *        void function right now.  It'd be nice if it returned a value at 
   *        some future date, so we could tell if things blew up when reparsing
   *        the list (for whatever reason). 
   *                       - Seth "Yes, this is a kludge" Burgess
   *                         <sjburges@ou.edu>
   *   -and shamelessly stolen by Adrian Likins for use here...
   */

  gimp_data_factory_data_init (gimp->palette_factory, FALSE);
}
CODE
    );
}

sub palette_list {
	$blurb = 'Retrieves a list of all of the available patterns';

	    $help = <<'HELP';
This procedure returns a complete listing of available palettes. Each name
returned can be used as input to the command 'gimp_palette_set_palette'.
HELP

    $author = 'Nathan Summers <rock@gimp.org>';
    $copyright = 'Nathan Summers';
    $date = '2001';

    @outargs = (
        { name => 'palette_list', type => 'stringarray',
          desc => 'The list of palette names',
          alias => 'palettes',
          array => { name => 'num_palettes',
                     desc => 'The number of palettes in the list',
                     alias => 'gimp->palette_factory->container->num_children', no_declare => 1 } }
    );

    %invoke = (
        vars => [ 'GList *list = NULL', 'gint i = 0' ],
        code => <<'CODE'
{
  palettes = g_new (gchar *, gimp->palette_factory->container->num_children);

  success = ((list = GIMP_LIST (gimp->palette_factory->container)->list) != NULL);

  while (list)
    {
      palettes[i++] = g_strdup (GIMP_OBJECT (list->data)->name);
      list = list->next;
    }
}
CODE
    );
}

sub palette_get_palette {
    $blurb = 'Retrieve information about the currently active palette.';

    $help = <<'HELP';
This procedure retrieves information about the currently active palette. This
includes the name, and the number of colors.
HELP

    $author = 'Nathan Summers <rock@gimp.org>';
    $copyright = 'Nathan Summers';
    $date = '2001';

    @outargs = (
        &palette_arg,
        &dim_args,
    );

    &palette_outargs;

    %invoke = (
        vars => [ 'GimpPalette *palette' ],
        code => 'success = (palette = gimp_context_get_palette (gimp_get_current_context (gimp))) != NULL;'
    );
}


sub palette_set_palette {
    $blurb = 'Set the specified palette as the active palette.';

    $help = <<'HELP';
This procedure allows the active palette to be set by specifying its name.
The name is simply a string which corresponds to one of the names of the
installed palettes. If no matching palette is found, this procedure will
return an error. Otherwise, the specified palette becomes active and will be
used in all subsequent palette operations.
HELP

    $author = 'Nathan Summers <rock@gimp.org>';
    $copyright = 'Nathan Summers';
    $date = '2001';

    @inargs = ( &palette_arg );

    %invoke = (
        vars => [ 'GimpPalette *palette', 'GList *list' ],
        code => <<'CODE'
{
  success = FALSE;

  for (list = GIMP_LIST (gimp->palette_factory->container)->list;
       list;
       list = g_list_next (list))
    {
      palette = (GimpPalette *) list->data;

      if (! strcmp (GIMP_OBJECT (palette)->name, name))
        {
          gimp_context_set_palette (gimp_get_current_context (gimp), palette);
          success = TRUE;
          break;
        }
    }
}
CODE
    );
}
	
sub palette_get_entry {
    $blurb = 'Gets the specified palette entry from the currently active palette.';

    $help = <<'HELP';
This procedure retrieves the color of the zero-based entry specifed for the current palette.
It returns an error if the entry does not exist.
HELP

    $author = 'Nathan Summers <rock@gimp.org>';
    $copyright = 'Nathan Summers';
    $date = '2001';

    @inargs = (
        { name => 'entry_num', type => 'int32',
          desc => 'The entry to retrieve',
          alias => 'entry'}
    );
    @outargs = (
        { name => 'color', type => 'color', void_ret => 1,
          desc => 'The color requested',
          alias => 'color'}
    );

    %invoke = (
	vars => [ 'GimpPalette *palette'],
	code => <<'CODE'
{
  success = TRUE;

  palette = gimp_context_get_palette (gimp_get_current_context(gimp));

  if (entry < 0 || entry >= palette->n_colors) 
    {
      success = FALSE;
    }
  else
    {
      color=*(GimpRGB *) g_list_nth(palette->colors, entry)->data;
    }
}
CODE
    );
}
 


@headers = qw("core/gimp.h" "core/gimpcontext.h"
              "core/gimpdatafactory.h" "core/gimplist.h" "core/gimppalette.h");

@procs = qw(palette_get_foreground palette_get_background
	    palette_set_foreground palette_set_background
	    palette_set_default_colors palette_swap_colors
	    palette_refresh
	    palette_list
	    palette_get_palette palette_set_palette
	    palette_get_entry);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Palette';

1;
