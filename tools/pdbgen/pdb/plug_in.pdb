# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

# The defs

sub plugins_query {
    $blurb = 'Queries the plugin database for its contents.';

    $help = 'This procedure queries the contents of the plugin database.';

    $author = $copyright = 'Andy Thomas';
    $date = '1998';

    @inargs = (
	{ name  => 'search_string', type => 'string',
	  desc  => 'If not an empty string then use this as a search pattern',
	  alias => 'search_str', no_success => 1 }
    );

    @outargs = (
	{ name => 'menu_path', type => 'stringarray',
	  desc => 'The menu path of the plugin',
	  alias => 'menu_strs' },
	{ name => 'plugin_accelerator', type => 'stringarray',
	  desc => 'String representing keyboard accelerator (could be empty
		   string)',
	  alias => 'accel_strs' },
	{ name => 'plugin_location', type => 'stringarray',
	  desc => 'Location of the plugin program',
	  alias => 'prog_strs' },
	{ name => 'plugin_image_type', type => 'stringarray',
	  desc => 'Type of image that this plugin will work on',
	  alias => 'types_strs' },
	{ name => 'plugin_install_time', type => 'int32array',
	  desc => 'Time that the plugin was installed',
	  alias => 'time_ints' },
	{ name => 'plugin_real_name', type => 'stringarray',
	  desc => 'The internal name of the plugin',
	  alias => 'realname_strs' }
    );

    foreach (@outargs) {
	$_->{array} = { name => 'num_plugins', no_declare => 1,
			desc => 'The number of plugins' }
    }

    $outargs[0]->{array}->{init} = 1;
    delete $outargs[0]->{array}->{no_declare};

    %invoke = (
	headers => [ qw("libgimpbase/gimpbase.h") ],
	vars => [ 'GSList *list', 'gint i = 0', 'regex_t sregex' ],
	code => <<'CODE'
{
  if (search_str && strlen (search_str))
    regcomp (&sregex, search_str, REG_ICASE);
  else
    search_str = NULL;

  /* count number of plugin entries, then allocate arrays of correct size
   * where we can store the strings.
   */

  for (list = gimp->plug_in_proc_defs; list; list = g_slist_next (list))
    {
      PlugInProcDef *proc_def = list->data;

      if (proc_def->prog && proc_def->menu_paths)
	{
	  gchar *name;

          if (proc_def->menu_label)
            {
              name = proc_def->menu_label;
            }
          else
            {
              name = strrchr (proc_def->menu_paths->data, '/');

              if (name)
                name = name + 1;
              else
                name = proc_def->menu_paths->data;
            }

	  if (search_str && match_strings (&sregex, name))
	    continue;

	  num_plugins++;
	}
    }

  menu_strs     = g_new (gchar *, num_plugins);
  accel_strs    = g_new (gchar *, num_plugins);
  prog_strs     = g_new (gchar *, num_plugins);
  types_strs    = g_new (gchar *, num_plugins);
  realname_strs = g_new (gchar *, num_plugins);
  time_ints     = g_new (gint   , num_plugins);

  for (list = gimp->plug_in_proc_defs; list; list = g_slist_next (list))
    {
      PlugInProcDef *proc_def = list->data;

      if (i > num_plugins)
	g_error ("Internal error counting plugins");

      if (proc_def->prog && proc_def->menu_paths)
	{
	  ProcRecord *pr = &proc_def->db_info;
	  gchar      *name;

          if (proc_def->menu_label)
            {
              name = proc_def->menu_label;
            }
          else
            {
              name = strrchr (proc_def->menu_paths->data, '/');

              if (name)
                name = name + 1;
              else
                name = proc_def->menu_paths->data;
            }

	  if (search_str && match_strings (&sregex, name))
	    continue;

          if (proc_def->menu_label)
            name = g_strdup_printf ("%s/%s",
                                    (gchar *) proc_def->menu_paths->data,
                                    proc_def->menu_label);
          else
            name = g_strdup (proc_def->menu_paths->data);

	  menu_strs[i]     = gimp_strip_uline (name);
	  accel_strs[i]    = NULL;
	  prog_strs[i]     = g_strdup (proc_def->prog);
	  types_strs[i]    = g_strdup (proc_def->image_types);
	  realname_strs[i] = g_strdup (pr->name);
	  time_ints[i]     = proc_def->mtime;

          g_free (name);

	  i++;
	}
    }

  if (search_str)
    regfree (&sregex);
}
CODE
    );
}

sub plugin_domain_register {
    $blurb = 'Registers a textdomain for localisation.';

    $help = <<'HELP';
This procedure adds a textdomain to the list of domains Gimp searches 
for strings when translating its menu entries. There is no need to 
call this function for plug-ins that have their strings included in 
the gimp-std-plugins domain as that is used by default. If the compiled 
message catalog is not in the standard location, you may specify an 
absolute path to another location. This procedure can only be called 
in the query function of a plug-in and it has to be called before any
procedure is installed.
HELP

    $author = $copyright = 'Sven Neumann';
    $date = '2000';

    @inargs = (
	{ name => 'domain_name', type => 'string',
	  desc => 'The name of the textdomain (must be unique)' },
	{ name => 'domain_path', type => 'string',
	  desc => 'The absolute path to the compiled message catalog (may be
		   NULL)',
	  no_success => 1 },
    );

    %invoke = (
	code => <<'CODE',
{
  if (gimp->current_plug_in && gimp->current_plug_in->query)
    {
      plug_in_def_set_locale_domain_name (gimp->current_plug_in->plug_in_def,
                                          domain_name);
      plug_in_def_set_locale_domain_path (gimp->current_plug_in->plug_in_def,
	                                  domain_path);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plugin_help_register {
    $blurb = "Register a help path for a plug-in.";

    $help = <<HELP;
This procedure changes the help rootdir for the plug-in which calls it. All
subsequent calls of gimp_help from this plug-in will be interpreted relative
to this rootdir.
HELP

    $author = $copyright = 'Michael Natterer <mitch@gimp.org>';
    $date = '2000';

    @inargs = (
	{ name => 'domain_name', type => 'string',
	  desc => "The XML namespace of the plug-in's help pages" },
	{ name => 'domain_uri', type => 'string',
	  desc => "The root URI of the plug-in's help pages" }
    );

    %invoke = (
        code => <<'CODE',
{
  if (gimp->current_plug_in && gimp->current_plug_in->query)
    {
      plug_in_def_set_help_domain_name (gimp->current_plug_in->plug_in_def,
                                        domain_name);
      plug_in_def_set_help_domain_uri (gimp->current_plug_in->plug_in_def,
                                       domain_uri);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plugin_menu_register {
    $blurb = "Register an additional menu path for a plug-in procedure.";

    $help = <<HELP;
This procedure installs an additional menu entry for the given procedure.
HELP

    $author = $copyright = 'Michael Natterer <mitch@gimp.org>';
    $date = '2004';
    $since = '2.2';

    @inargs = (
	{ name => 'procedure_name', type => 'string',
	  desc => 'The procedure for which to install the menu path' },
	{ name => 'menu_path', type => 'string',
	  desc => "The procedure's additional menu path" }
    );

    %invoke = (
        code => <<'CODE',
{
  if (gimp->current_plug_in)
    {
      PlugInProcDef *proc_def = NULL;
      GSList        *list;

      if (gimp->current_plug_in->plug_in_def)
        {
          for (list = gimp->current_plug_in->plug_in_def->proc_defs;
               list;
               list = g_slist_next (list))
            {
              PlugInProcDef *pd = list->data;

              if (! strcmp (procedure_name, pd->db_info.name))
                {
                  proc_def = pd;
                  break;
                }
            }
        }

      if (! proc_def)
        {
          for (list = gimp->current_plug_in->temp_proc_defs;
               list;
               list = g_slist_next (list))
            {
              PlugInProcDef *pd = list->data;

              if (! strcmp (procedure_name, pd->db_info.name))
                {
                  proc_def = pd;
                  break;
                }
            }
        }

      if (proc_def)
        {
          if (proc_def->menu_label)
            {
              GError *error = NULL;

              if (! plug_in_proc_args_check (gimp->current_plug_in->name,
                                             gimp->current_plug_in->prog,
                                             procedure_name,
                                             menu_path,
                                             proc_def->db_info.args,
                                             proc_def->db_info.num_args,
                                             proc_def->db_info.values,
                                             proc_def->db_info.num_values,
                                             &error))
                {
                  g_message (error->message);
                  g_clear_error (&error);

                  success = FALSE;
                }
              else
                {
                  switch (proc_def->db_info.proc_type)
                    {
                    case GIMP_INTERNAL:
                      success = FALSE;
                      break;

                    case GIMP_PLUGIN:
                    case GIMP_EXTENSION:
                      if (! gimp->current_plug_in->query &&
                          ! gimp->current_plug_in->init)
                        success = FALSE;
                      break;

                    case GIMP_TEMPORARY:
                      break;
                    }

                  if (success)
                    {
                      proc_def->menu_paths = g_list_append (proc_def->menu_paths,
                                                            g_strdup (menu_path));

                      if (! gimp->no_interface &&
                          proc_def->db_info.proc_type == GIMP_TEMPORARY)
                        {
                          gimp_menus_create_entry (gimp, proc_def, menu_path);
                        }
                    }
                }
            }
          else
            {
              g_message ("Plug-In \"%s\"\n(%s)\n\n"
                         "attempted to install additional menu_path \"%s\"\n"
                         "for procedure \"%s\".\n"
                         "However the menu_path given in "
                         "gimp_install_procedure() already contained "
                         "a path. To make this work, pass just the menu's "
                         "label to gimp_install_procedure().",
                         gimp_filename_to_utf8 (gimp->current_plug_in->name),
                         gimp_filename_to_utf8 (gimp->current_plug_in->prog),
                         menu_path, procedure_name);

              success = FALSE;
            }
        }
      else
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plugin_icon_register {
    $blurb = "Register an icon for a plug-in procedure.";

    $help = <<HELP;
This procedure installs an icon for the given procedure.
HELP

    $author = $copyright = 'Michael Natterer <mitch@gimp.org>';
    $date = '2004';
    $since = '2.2';

    @inargs = (
	{ name => 'procedure_name', type => 'string', wrap => 1,
	  desc => 'The procedure for which to install the icon' },
        { name => 'icon_type', type => 'enum GimpIconType',
          desc => 'The type of the icon' },
	{ name => 'icon_data', type => 'int8array',
	  desc => "The procedure's icon. The format depends on the 'icon_type' parameter",
	  array => { name => 'icon_data_length', type => '0 < int32',
                     desc => "The length of 'icon_data': %%desc%%" } }
    );

    %invoke = (
        code => <<'CODE',
{
  if (gimp->current_plug_in && gimp->current_plug_in->query)
    {
      GSList *list;

      for (list = gimp->current_plug_in->plug_in_def->proc_defs;
           list;
           list = g_slist_next (list))
        {
          PlugInProcDef *proc_def = list->data;

          if (! strcmp (procedure_name, proc_def->db_info.name))
            {
              if (proc_def->icon_data)
                {
                  g_free (proc_def->icon_data);
                  proc_def->icon_data_length = -1;
                  proc_def->icon_data        = NULL;
                }

              proc_def->icon_type = icon_type;

              switch (proc_def->icon_type)
                {
                case GIMP_ICON_TYPE_STOCK_ID:
                case GIMP_ICON_TYPE_IMAGE_FILE:
                  proc_def->icon_data_length = -1;
                  proc_def->icon_data        = g_strdup (icon_data);
                  break;

                case GIMP_ICON_TYPE_INLINE_PIXBUF:
                  proc_def->icon_data_length = icon_data_length;
                  proc_def->icon_data        = g_memdup (icon_data,
                                                         icon_data_length);
                  break;
                }

              break;
            }
        }

      if (! list)
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}


$extra{app}->{code} = <<'CODE';
static int
match_strings (regex_t *preg,
               gchar   *a)
{
  return regexec (preg, a, 0, NULL, 0);
}
CODE

@headers = qw(<string.h> <stdlib.h> "regexrepl/regex.h"
              "libgimpbase/gimpprotocol.h" "core/gimp.h" 
              "plug-in/plug-in.h" "plug-in/plug-ins.h"
              "plug-in/plug-in-def.h" "plug-in/plug-in-params.h"
              "plug-in/plug-in-proc-def.h");

@procs = qw(plugins_query
	    plugin_domain_register plugin_help_register
            plugin_menu_register plugin_icon_register);
%exports = (app => [@procs], lib => [@procs[1,2,3,4]]);

$desc = 'Plug-in';

1;
