# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub simple_inargs {
    @inargs = (
	&std_image_arg
    );
}

sub simple_invoke {
    my $type = shift;
    %invoke = (
	code => <<CODE
if ((success = (gimp_image_base_type (gimage) != $type)))
  convert_image ((void *) gimage, $type, 0, 0, 0, 1, 0);
CODE
    );
}

sub convert_rgb {
    $blurb = 'Convert specified image to RGB color';

    $help = <<'HELP';
This procedure converts the specified image to RGB color. This process requires
an image of type GRAY or INDEXED. No image content is lost in this process
aside from the colormap for an indexed image.
HELP

    &std_pdb_misc;
    &simple_inargs;
    &simple_invoke('RGB');
}

sub convert_grayscale {
    $blurb = 'Convert specified image to grayscale (256 intensity levels)';

    $help = <<'HELP';
This procedure converts the specified image to grayscale with 8 bits per pixel
(256 intensity levels). This process requires an image of type RGB or INDEXED.
HELP

    &std_pdb_misc;
    &simple_inargs;
    &simple_invoke('GRAY');
}

sub convert_indexed {
    $blurb = 'Convert specified image to and Indexed image';

    $help = <<'HELP';
This procedure converts the specified image to 'indexed' color. This process
requires an image of type GRAY or RGB. The 'palette_type' specifies what kind
of palette to use, A type of '0' means to use an optimal palette of 'num_cols'
generated from the colors in the image. A type of '1' means to re-use the
previous palette (not currently implemented). A type of '2' means to use the so-called WWW-optimized palette. Type
'3' means to use only black and white colors. A type of '4' means to use a
palette from the gimp palettes directories.  The 'dither type' specifies
what kind of dithering to use.  '0' means no dithering, '1' means standard Floyd-Steinberg error diffusion, '2' means Floyd-Steinberg error diffusion with reduced bleeding, '3' means dithering based on pixel location ('Fixed' dithering).
HELP

    &std_pdb_misc;

    @inargs = (
	&std_image_arg,
	{ name => 'dither_type', type => 'enum ConvertDitherType',
	  desc => 'dither type (0=none, 1=fs, 2=fs/low-bleed 3=fixed)' },
	{ name => 'palette_type', type => 'enum ConvertPaletteType',
	  desc => 'The type of palette to use: { %%desc%% }', no_success => 1 },
	{ name => 'num_cols', type => 'int32',
	  desc => 'the number of colors to quantize to, ignored unless
		   (palette_type == MAKE_PALETTE)' },
	{ name => 'alpha_dither', type => 'boolean',
	  desc => 'dither transparency to fake partial opacity' },
	{ name => 'remove_unused', type => 'boolean',
	  desc => 'remove unused or duplicate colour entries from final
		   palette, ignored if (palette_type == MAKE_PALETTE)' },
	{ name => 'palette', type => 'string',
	  desc => 'The name of the custom palette to use, ignored unless
		   (palette_type == CUSTOM_PALETTE)',
	  alias => 'palette_name' }
    );

    %invoke = (
	headers => [ qw(<string.h> "palette.h") ],
	code => <<'CODE'
{
  if ((success = (gimp_image_base_type (gimage) != INDEXED)))
    {
      GimpPalette *palette = NULL;

      switch (dither_type)
        {
	case NO_DITHER:
	case FS_DITHER:
	case FSLOWBLEED_DITHER:
	case FIXED_DITHER:
	  break;
	default:
	  success = FALSE;
	  break;
        }
      
      switch (palette_type)
	{
	case MAKE_PALETTE:
	  if (num_cols < 1 || num_cols > MAXNUMCOLORS)
	    success = FALSE;
	  break;

	case REUSE_PALETTE:
	case WEB_PALETTE:
	case MONO_PALETTE:
	  break;

	case CUSTOM_PALETTE:
	  if (! global_palette_factory->container->num_children)
	    palettes_init (FALSE);

          palette = (GimpPalette *)
            gimp_container_get_child_by_name (global_palette_factory->container,
                                              palette_name);

	  if (palette == NULL)
	    success = FALSE;
	  else
	    theCustomPalette = palette;

	  break;

	default:
	  success = FALSE;
	}
    }

  if (success)
    convert_image ((void *) gimage, INDEXED, num_cols, dither_type,
		   alpha_dither, remove_unused, palette_type);
}
CODE
    );
}

@headers = qw("context_manager.h" "gimpcontainer.h" "gimpimage.h"
	      "gimpdatafactory.h" "gimppalette.h" "palettes.h" "convert.h");

@procs = qw(convert_rgb convert_grayscale convert_indexed);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Convert';

1;
