# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub simple_inargs {
    @inargs = (
	&std_image_arg
    );
}

sub simple_invoke {
    my $type = shift;
    %invoke = (
	headers => [ qw("gimage.h" "convert.h") ],
	code => <<CODE
if (success = (gimage_base_type (gimage) != $type))
  convert_image ((void *) gimage, $type, 0, 0, 0);
CODE
    );
}

sub convert_rgb {
    $blurb = 'Convert specified image to RGB color';

    $help = <<'HELP';
This procedure converts the specified image to RGB color. This process requires
an image of type GRAY or INDEXED. No image content is lost in this process
aside from the colormap for an indexed image.
HELP

    &std_pdb_misc;
    &simple_inargs;
    &simple_invoke('RGB');
}

sub convert_grayscale {
    $blurb = 'Convert specified image to grayscale (256 intensity levels)';

    $help = <<'HELP';
This procedure converts the specified image to grayscale with 8 bits per pixel
(256 intensity levels). This process requires an image of type RGB or INDEXED.
HELP

    &std_pdb_misc;
    &simple_inargs;
    &simple_invoke('GRAY');
}

sub convert_indexed {
    $blurb = 'Convert specified image to indexed color';

    $help = <<'HELP';
This procedure converts the specified image to indexed color. This process
requires an image of type GRAY or RGB. The 'num_cols' arguments specifies how
many colors the resulting image should be quantized to (1-256).
HELP

    &std_pdb_misc;

    @inargs = (
	&std_image_arg,
	{ name => 'dither', type => 'boolean',
	  desc => 'Floyd-Steinberg dithering' },
	{ name => 'num_cols', type => 'int32',
	  desc => 'the number of colors to quantize to' }
    );

    %invoke = (
	headers => [ qw("gimage.h" "convert.h") ],
	code => <<'CODE'
{
  success = (gimage_base_type (gimage) != INDEXED);

  if (num_cols < 1 || num_cols > MAXNUMCOLORS)
    success = FALSE;

  if (success)
    convert_image ((void *) gimage, INDEXED, num_cols, dither, 0);
}
CODE
    );
}

sub convert_indexed_palette {
    $blurb = 'Convert specified image to indexed color';

    $help = <<'HELP';
This procedure converts the specified image to indexed color. This process
requires an image of type GRAY or RGB. The 'palette_type' specifies what kind
of palette to use, A type of '0' means to use an optimal palette of 'num_cols'
generated from the colors in the image. A type of '1' means to re-use the
previous palette. A type of '2' means to use the WWW-optimized palette. Type
'3' means to use only black and white colors. A type of '4' means to use a
palette from the gimp palettes directories.
HELP

    &std_pdb_misc;

    @inargs = (
	&std_image_arg,
	{ name => 'dither', type => 'boolean',
	  desc => 'Floyd-Steinberg dithering' },
	{ name => 'palette_type', type => 'enum ConvertPaletteType',
	  desc => 'The type of palette to use: %%desc%%' },
	{ name => 'num_cols', type => 'int32',
	  desc => 'the number of colors to quantize to, ignored unless
		   (palette_type == MAKE_PALETTE)' },
	{ name => 'palette', type => 'string',
	  desc => 'The name of the custom palette to use, ignored unless
		   (palette_type == CUSTOM_PALETTE)' }
    );

    %invoke = (
	headers => [ qw("gimage.h" "convert.h" "palette.h") ],
	code => <<'CODE'
{
  if (success = (gimage_base_type (gimage) != INDEXED))
    {
      PaletteEntriesP entries, the_palette = NULL;
      GSList *list;

      switch (palette_type)
	{
	case MAKE_PALETTE:
  	  if (num_cols < 1 || num_cols > MAXNUMCOLORS)
	    success = FALSE;
	  break;

	case REUSE_PALETTE:
	case WEB_PALETTE:
	case MONO_PALETTE:
	  break;

	case CUSTOM_PALETTE:
	  if (!palette_entries_list)
	    palette_init_palettes (FALSE);

	  for (list = palette_entries_list; list; list = g_slist_next (list))
	    {
	      entries = (PaletteEntriesP) list->data;
	      if (strcmp (palette_name, entries->name) == 0)
		{
		  the_palette = entries;
		  break;
		}
	    }

	  if (the_palette == NULL)
	    success = FALSE;
	  else
	    theCustomPalette = the_palette;

	  break;

	default:
	  success = FALSE;
	}
    }

  if (success)
    convert_image ((void *) gimage, INDEXED, num_cols, dither, palette_type);
}
CODE
    );
}

@procs = qw(convert_rgb convert_grayscale convert_indexed
	    convert_indexed_palette);
%exports = (app => [@procs]);

$desc = 'Convert';

1;
