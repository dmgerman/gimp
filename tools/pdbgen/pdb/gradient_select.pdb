# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub pdb_misc {
    $author = $copyright = 'Andy Thomas';
    $date = '1998';
}

sub sample_size_arg {{
    name => 'sample_size',
    type => '0 < int32 <= 10000',
    desc => 'Size of the sample to return when the gradient is changed
	    (%%desc%%)',
    on_fail => 'sample_size = GRADIENT_SAMPLE_SIZE;',
    no_success => 1
}}

sub gradients_popup {
    $blurb = 'Invokes the Gimp gradients selection.';

    $help = 'This procedure popups the gradients selection dialog.';

    &pdb_misc;

    @inargs = (
	{ name => 'gradients_callback', type => 'string', alias => 'name',
	  desc => 'The callback PDB proc to call when gradient selection is
		   made' },
	{ name => 'popup_title', type => 'string', alias => 'title',
	  desc => 'Title to give the gradient popup window' },
	{ name => 'initial_gradient', type => 'string',
	  desc => 'The name of the pattern to set as the first selected',
	  no_success => 1 },
	&sample_size_arg
    );

    %invoke = (
	vars => [ 'ProcRecord *prec', 'GradientSelect *newdialog' ],
	code => <<'CODE'
{
  if ((prec = procedural_db_lookup (name)))
    {
      if (initial_gradient && strlen (initial_gradient))
	newdialog = gradient_select_new (title, initial_gradient);
      else
	newdialog = gradient_select_new (title, NULL);

      newdialog->callback_name = g_strdup (name);
      newdialog->sample_size   = sample_size;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradients_close_popup {
    $blurb = 'Popdown the Gimp gradient selection.';

    $help = 'This procedure closes an opened gradient selection dialog.';

    &pdb_misc;

    @inargs = (
	{ name => 'gradients_callback', type => 'string', alias => 'name',
	  desc => 'The name of the callback registered for this popup' }
    );

    %invoke = (
	vars => [ 'ProcRecord *prec', 'GradientSelect *gsp' ],
	code => <<'CODE'
{
  if ((prec = procedural_db_lookup (name)) &&
      (gsp = gradients_get_gradientselect (name)))
    {
      if (GTK_WIDGET_VISIBLE (gsp->shell))
	gtk_widget_hide (gsp->shell);

      /* Free memory if poping down dialog which is not the main one */
      if (gsp != gradient_select_dialog)
	{
	  /* Send data back */
	  gtk_widget_destroy (gsp->shell);
	  gradient_select_free (gsp);
	}
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradients_set_popup {
    $blurb = 'Sets the current gradient selection in a popup.';

    $help = $blurb;

    &pdb_misc;

    @inargs = (
	{ name => 'gradients_callback', type => 'string', alias => 'pdbname',
	  desc => 'The name of the callback registered for this popup' },
	{ name => 'gradient_name', type => 'string',
	  desc => 'The name of the gradient to set as selected' }
    );

    %invoke = (
	vars => [ 'ProcRecord *prec', 'GradientSelect *gsp' ],
	code => <<'CODE'
{
  if ((prec = procedural_db_lookup (pdbname)) &&
      (gsp = gradients_get_gradientselect (pdbname)))
    {
      GimpGradient *active = NULL;

      active = (GimpGradient *)
        gimp_container_get_child_by_name (global_gradient_list,
                                          gradient_name);

      if (active)
        {
	  gimp_context_set_gradient (gsp->context, active);
	  success = TRUE;
	}
      else
	success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradients_get_gradient_data {
    $blurb = <<'BLURB';
Retrieve information about the specified gradient (including data).
BLURB

    $help = <<'HELP';
This procedure retrieves information about the gradient. This includes the
gradient name, and the sample data for the gradient.
HELP

    &pdb_misc;

    @inargs = (
	{ name => 'name', type => 'string',
	  desc => 'The gradient name ("" means current active gradient)' },
	&sample_size_arg
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => 'The gradient name',
	  alias => 'g_strdup (GIMP_OBJECT (gradient)->name)', no_declare => 1 },
	{ name => 'grad_data', type => 'floatarray', alias => 'values',
	  desc => 'The gradient sample data', init => 1, wrap => 1,
	  array => { name => 'width',
		     desc => 'The gradient sample width (r,g,b,a)',
		     alias => 'sample_size * 4', no_declare => 1 } }
    );

    %invoke = (
	vars => [ 'GimpGradient *gradient = NULL' ],
	code => <<'CODE'
{
  if (strlen (name))
    {
      success = FALSE;

      gradient = (GimpGradient *)
        gimp_container_get_child_by_name (global_gradient_list, name);

      if (gradient)
        success = TRUE;
    }
  else
    success = (gradient = gimp_context_get_gradient (NULL)) != NULL;

  if (success)
    {
      gdouble *pv;
      gdouble  pos, delta;
      GimpRGB  color;
      gint     i;

      i     = sample_size;
      pos   = 0.0;
      delta = 1.0 / (i - 1);

      pv = values = g_new (gdouble, i * 4);

      while (i--)
	{
	  gimp_gradient_get_color_at (gradient, pos, &color);

	  *pv++ = color.r;
	  *pv++ = color.g;
	  *pv++ = color.b;
	  *pv++ = color.a;

	  pos += delta;
	}
    }
}
CODE
    );
}

@headers = qw(<string.h> "context_manager.h" "gimpcontext.h"
	      "gimpcontainer.h" "gradients.h" "gimpgradient.h"
	      "gradient_select.h");

$extra{app}->{code} = <<'CODE';
static GradientSelect *
gradients_get_gradientselect (gchar *name)
{
  GSList *list;
  GradientSelect *gsp;

  for (list = gradient_active_dialogs; list; list = g_slist_next (list))
    {
      gsp = (GradientSelect *) list->data;
      
      if (gsp->callback_name && !strcmp (name, gsp->callback_name))
	return gsp;
    }

  return NULL;
}
CODE

@procs = qw(gradients_popup gradients_close_popup gradients_set_popup
	    gradients_get_gradient_data);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Gradient UI';

1;
