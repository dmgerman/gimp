# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub brush_arg () {{
    name => 'name',
    type => 'string',
    desc => 'The brush name'
}}

sub dim_args () {
    my @args;
    foreach (qw(width height)) {
	push @args, { name => $_, type => 'int32', desc => "The brush $_" };
    }
    @args;
}

sub opacity_arg () {{
    name => 'opacity',
    type => '0 <= float <= 100',
    desc => 'The brush opacity: %%desc%%'
}}

sub spacing_arg () {{
    name => 'spacing',
    type => '0 <= int32 <= 1000',
    desc => 'The brush spacing: %%desc%%'
}}

sub paint_mode_arg () {{
    name => 'paint_mode', type => 'enum LayerModeEffects',
    desc => 'The paint mode: { %%desc%% }'
}}


sub brush_outargs {
    foreach (@outargs) {
	my $alias = ($_->{type} eq 'string') ?
	            "GIMP_OBJECT (brush)->$_->{name}" : "brush->$_->{name}";
	$alias = "g_strdup ($alias)" if $_->{type} eq 'string';
	$alias =~ s/brush/brush->mask/ if $_->{name} =~ /width|height/;
	$_->{alias} = $alias;
	$_->{no_declare} = 1;
    }
}

# The defs

sub brushes_refresh {
    $blurb = 'Refresh current brushes.';

    $help = <<'HELP';
This procedure retrieves all brushes currently in the user's brush path
and updates the brush dialog accordingly.
HELP

    $author = $copyright = 'Seth Burgess';
    $date = '1997';

    %invoke = (
	code => <<'CODE'
{
  /* FIXME: I've hardcoded success to be 1, because brushes_init() is a 
   *        void function right now.  It'd be nice if it returned a value at 
   *        some future date, so we could tell if things blew up when reparsing
   *        the list (for whatever reason). 
   *                       - Seth "Yes, this is a kludge" Burgess
   *                         <sjburges@gimp.org>
   */

  gimp_data_factory_data_save (gimp->brush_factory);
  gimp_data_factory_data_init (gimp->brush_factory, FALSE);
}
CODE
    );
}

sub brushes_get_brush {
    $blurb = 'Retrieve information about the currently active brush mask.';

    $help = <<'HELP';
This procedure retrieves information about the currently active brush mask.
This includes the brush name, the width and height, and the brush spacing
paramter. All paint operations and stroke operations use this mask to control
the application of paint to the image.
HELP

    &std_pdb_misc;

    @outargs = (
	&brush_arg,
	&dim_args,
	&spacing_arg
    );

    &brush_outargs;

    %invoke = (
	vars => [ 'GimpBrush *brush' ],
	code => 'success = (brush = gimp_context_get_brush (NULL)) != NULL;'
    );
}

sub brushes_set_brush {
    $blurb = 'Set the specified brush as the active brush.';

    $help = <<'HELP';
This procedure allows the active brush mask to be set by specifying its name.
The name is simply a string which corresponds to one of the names of the
installed brushes. If there is no matching brush found, this procedure will
return an error.  Otherwise, the specified brush becomes active and will be
used in all subsequent paint operations.
HELP

    &std_pdb_misc;

    @inargs = ( &brush_arg );

    %invoke = (
	vars => [ 'GimpObject *object' ],
	code => <<'CODE'
{
  object = gimp_container_get_child_by_name (gimp->brush_factory->container,
					     name);

  if (object)
    gimp_context_set_brush (NULL, GIMP_BRUSH (object));
  else
    success = FALSE;
}
CODE
    );
}

sub brushes_get_opacity {
    $blurb = 'Get the brush opacity.';

    $help = <<'HELP';
This procedure returns the opacity setting for brushes. This value is set
globally and will remain the same even if the brush mask is changed. The return
value is a floating point number between 0 and 100.
HELP

    &std_pdb_misc;

    @outargs = ( &opacity_arg );
    $outargs[0]->{alias} = 'gimp_context_get_opacity (NULL) * 100.0';
    $outargs[0]->{no_declare} = 1;
}

sub brushes_set_opacity {
    $blurb = 'Set the brush opacity.';

    $help = <<'HELP';
This procedure modifies the opacity setting for brushes. This value is set
globally and will remain the same even if the brush mask is changed. The value
should be a floating point number between 0 and 100.
HELP

    &std_pdb_misc;

    @inargs = ( &opacity_arg );

    %invoke = ( code => 'gimp_context_set_opacity (NULL, opacity / 100.0);' );
}

sub brushes_get_spacing {
    $blurb = 'Get the brush spacing.';

    $help = <<'HELP';
This procedure returns the spacing setting for brushes. This value is set per
brush and will change if a different brush is selected. The return value is an
integer between 0 and 1000 which represents percentage of the maximum of the
width and height of the mask.
HELP

    &std_pdb_misc;

    @outargs = ( &spacing_arg );
    $outargs[0]->{alias} = 'gimp_brush_get_spacing (gimp_context_get_brush (NULL))';
    $outargs[0]->{no_declare} = 1;
}

sub brushes_set_spacing {
    $blurb = 'Set the brush spacing.';

    $help = <<'HELP';
This procedure modifies the spacing setting for the current brush. This value
is set on a per-brush basis and will change if a different brush mask is
selected. The value should be a integer between 0 and 1000.
HELP

    &std_pdb_misc;

    @inargs = ( &spacing_arg );

    %invoke = (
	code => 'gimp_brush_set_spacing (gimp_context_get_brush (NULL), spacing);'
    );
}

sub brushes_get_paint_mode {
    $blurb = 'Get the brush paint mode.';

    $help = <<'HELP';
This procedure returns the paint-mode setting for brushes. This value is set
globally and will not change if a different brush is selected. The return value
is an integer which corresponds to the values listed in the argument
description.
HELP

    &std_pdb_misc;

    @outargs = ( &paint_mode_arg );
    $outargs[0]->{alias} = 'gimp_context_get_paint_mode (NULL)';
    $outargs[0]->{no_declare} = 1;
}

sub brushes_set_paint_mode {
    $blurb = 'Set the brush paint mode.';

    $help = <<'HELP';
This procedure modifies the paint_mode setting for the current brush. This
value is set globally and will not change if a different brush mask is
selected.
HELP

    &std_pdb_misc;

    @inargs = ( &paint_mode_arg );

    %invoke = ( code => 'gimp_context_set_paint_mode (NULL, paint_mode);' );
}

sub brushes_list {
    $blurb = 'Retrieve a complete listing of the available brushes.';

    $help = <<'HELP';
This procedure returns a complete listing of available GIMP brushes. Each name
returned can be used as input to the 'gimp_brushes_set_brush'.
HELP

    &std_pdb_misc;

    @outargs = (
	{ name => 'brush_list', type => 'stringarray',
	  desc => 'The list of brush names',
	  alias => 'brushes',
	  array => { name => 'num_brushes',
		     desc => 'The number of brushes in the brush list',
		     alias => 'gimp->brush_factory->container->num_children', no_declare => 1 } }
    );

    %invoke = (
	vars => [ 'GList *list = NULL', 'int i = 0' ],
	code => <<'CODE'
{
  brushes = g_new (char *, gimp->brush_factory->container->num_children);

  success = (list = GIMP_LIST (gimp->brush_factory->container)->list) != NULL;

  while (list)
    {
      brushes[i++] = g_strdup (GIMP_OBJECT (list->data)->name);
      list = list->next;
    }
}
CODE
    );
}

sub brushes_get_brush_data {
    $blurb = <<'BLURB';
Retrieve information about the currently active brush (including data).
BLURB

    $help = <<'HELP';
This procedure retrieves information about the currently active brush. This
includes the brush name, and the brush extents (width and height). It also
returns the brush data.
HELP

    $author = $copyright = 'Andy Thomas';
    $date = '1998';

    @inargs = ( &brush_arg );
    $inargs[0]->{desc} = 'the brush name ("" means current active pattern)';

    @outargs = (
	&brush_arg,
	&opacity_arg,
	&spacing_arg,
	&paint_mode_arg,
	&dim_args,
    );

    &brush_outargs;

    $outargs[1]->{alias} = '1.0';
    $outargs[3]->{alias} = '0';

    push @outargs, { name => 'mask_data', type => 'int8array', init => 1,
		     desc => 'The brush mask data',
		     array => { name => 'length', init => 1,
				desc => 'Length of brush mask data' } };
    
    %invoke = (
	headers => [ qw(<string.h>) ],
	vars => [ 'GimpBrush *brush = NULL' ],
	code => <<'CODE'
{
  if (strlen (name))
    {
      GList *list;

      success = FALSE;

      for (list = GIMP_LIST (gimp->brush_factory->container)->list;
           list;
           list = g_list_next (list))
	{
	  brush = (GimpBrush *) list->data;

	  if (!strcmp (GIMP_OBJECT (brush)->name, name))
	    {
	      success = TRUE;
	      break;
	    }
	}
    }
  else
    success = (brush = gimp_context_get_brush (NULL)) != NULL;

  if (success)
    {
      length = brush->mask->height * brush->mask->width;
      mask_data = g_new (guint8, length);
      g_memmove (mask_data, temp_buf_data (brush->mask), length);
    }
}
CODE
    );
}

@headers = qw("core/gimp.h" "core/gimplist.h" "core/gimpbrush.h"
              "core/gimpcontext.h" "core/gimpdatafactory.h" "base/temp-buf.h");

@procs = qw(brushes_refresh brushes_get_brush brushes_set_brush
	    brushes_get_opacity brushes_set_opacity brushes_get_spacing
	    brushes_set_spacing brushes_get_paint_mode brushes_set_paint_mode
	    brushes_list brushes_get_brush_data);
%exports = (app => [@procs], lib => [$procs[10]]);

$desc = 'Brushes';

1;
