# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

# Misc Tools

# shortcuts

sub drawable_arg () {{
    name => 'drawable',
    type => 'drawable',
    desc => 'The affected drawable',
}}

sub drawable_out_arg {
    my $type = shift;
    my $arg = &drawable_arg;
    $arg->{desc} = "The $type drawable";
    $arg->{no_declare} = 1;
    $arg;
}

sub sample_merged_arg () {{
    name => 'sample_merged',
    type => 'boolean',
    desc => 'Use the composite image, not the drawable'
}}

sub threshold_arg () {{
    name => 'threshold',
    type => '0 <= int32 <= 255',
    desc => 'Threshold in intensity levels %%desc%%'
}}


# The defs

sub blend {
    $blurb = <<'BLURB';
Blend between the starting and ending coordinates with the specified blend mode
and gradient type.
BLURB

    $help = <<'HELP';
This tool requires information on the paint application mode, the blend mode,
and the gradient type. It creates the specified variety of blend using the
starting and ending coordinates as defined for each gradient type.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
        { name => 'blend_mode', type => 'enum GimpBlendMode',
	  desc => 'The type of blend: { %%desc%% }' },
	{ name => 'paint_mode', type => 'enum GimpLayerModeEffects',
	  desc => 'The paint application mode: { %%desc%% }' },
	{ name => 'gradient_type',  type => 'enum GimpGradientType',
	  desc => 'The type of gradient: { %%desc%% }' },
	{ name => 'opacity', type => '0 <= float <= 100',
	  desc => 'The opacity of the final blend (%%desc%%)' },
	{ name => 'offset', type => '0 <= float',
	  desc => 'Offset relates to the starting and ending coordinates
		   specified for the blend. This parameter is mode dependent
		   (%%desc%%)' },
	{ name => 'repeat', type => 'enum GimpRepeatMode',
	  desc => 'Repeat mode: { %%desc%% }' },
	{ name => 'reverse', type => 'boolean',
	  desc => 'Use the reverse gradient (%%desc%%)' },
	{ name => 'supersample', type => 'boolean',
	  desc => 'Do adaptive supersampling (%%desc%%)' },
	{ name => 'max_depth', type => '1 <= int32 <= 9',
	  desc => 'Maximum recursion levels for supersampling',
	  cond => [ 'supersample' ] },
	{ name => 'threshold', type => '0 <= float <= 4',
	  desc => 'Supersampling threshold',
	  cond => [ 'supersample' ] },
	{ name => 'dither', type => 'boolean',
	  desc => 'Use dithering to reduce banding (%%desc%%)' },
	{ name => 'x1', type => 'float',
	  desc => "The x coordinate of this blend's starting point" },
	{ name => 'y1', type => 'float',
	  desc => "The y coordinate of this blend's starting point" },
	{ name => 'x2', type => 'float',
	  desc => "The x coordinate of this blend's ending point" },
	{ name => 'y2', type => 'float',
	  desc => "The y coordinate of this blend's ending point" }
    );

    %invoke = (
        headers => [ qw("core/gimpdrawable-blend.h") ],
	code => <<'CODE'
{
  if (! gimp_item_get_image (GIMP_ITEM (drawable)))
    {
      success = FALSE;
    }
  else
    {
      gimp_drawable_blend (drawable,
                           blend_mode,
                           paint_mode,
                           gradient_type,
                           opacity / 100.0,
	                   offset, repeat, reverse,
                           supersample, max_depth,
                           threshold, dither,
                           x1, y1, x2, y2,
	                   NULL, NULL);
    }
}
CODE
    );
}

sub bucket_fill {
    $blurb = <<'BLURB';
Fill the area specified either by the current selection if there is one, or by
a seed fill starting at the specified coordinates.
BLURB

    $help = <<'HELP';
This tool requires information on the paint application mode, and the fill
mode, which can either be in the foreground color, or in the currently active
pattern. If there is no selection, a seed fill is executed at the specified
coordinates and extends outward in keeping with the threshold parameter. If
there is a selection in the target image, the threshold, sample merged, x, and
y arguments are unused. If the sample_merged parameter is non-zero, the data of
the composite image will be used instead of that for the specified drawable.
This is equivalent to sampling for colors after merging all visible layers. In
the case of merged sampling, the x,y coordinates are relative to the image's
origin; otherwise, they are relative to the drawable's origin.
HELP

    &std_pdb_misc;

    my $validity = 'This parameter is only valid when there is no selection in
		    the specified image.';

    @inargs = (
	&drawable_arg,
	{ name => 'fill_mode', type => 'enum GimpBucketFillMode',
	  desc => 'The type of fill: { %%desc%% }' },
	{ name => paint_mode, type => 'enum GimpLayerModeEffects',
	  desc => 'The paint application mode: { %%desc%% }' },
	{ name => 'opacity', type => '0 <= float <= 100',
	  desc => 'The opacity of the final bucket fill (%%desc%%)' },
	{ name => 'threshold', type => '0 <= float <= 255',
	  desc => "The threshold determines how extensive the seed fill will
		   be. It's value is specified in terms of intensity levels
		   (%%desc%%). $validity" },
	&sample_merged_arg,
    );

    foreach (qw(x y)) {
	push @inargs, { name => $_, type => 'float',
			desc => "The $_ coordinate of this bucket fill's
				 application. $validity" }
    }

    %invoke = (
        headers => [ qw ("core/gimpdrawable-bucket-fill.h"
	                 "core/gimpchannel.h") ],
	code => <<'CODE'
{
  GimpImage *gimage = gimp_item_get_image (GIMP_ITEM (drawable));

  if (! gimage)
    {
      success = FALSE;
    }
  else
    {
      gboolean do_seed_fill;

      do_seed_fill = gimp_channel_is_empty (gimp_image_get_mask (gimage));

      gimp_drawable_bucket_fill (drawable, fill_mode,
                                 paint_mode, opacity / 100.0,
                                 do_seed_fill,
                                 FALSE /* don't fill transparent */,
	                         threshold, sample_merged, x, y);
    }
}
CODE
    );
}


sub color_picker {
    $blurb = <<'BLURB';
Determine the color at the given drawable coordinates
BLURB

    $help = <<'HELP';
This tool determines the color at the specified coordinates. The returned color
is an RGB triplet even for grayscale and indexed drawables. If the coordinates
lie outside of the extents of the specified drawable, then an error is
returned. If the drawable has an alpha channel, the algorithm examines the
alpha value of the drawable at the coordinates. If the alpha value is
completely transparent (0), then an error is returned. If the sample_merged
parameter is non-zero, the data of the composite image will be used instead of
that for the specified drawable. This is equivalent to sampling for colors
after merging all visible layers. In the case of a merged sampling, the
supplied drawable is ignored.
HELP

    &std_pdb_misc;

    @inargs = (
	&std_image_arg,
	&drawable_arg,
	{ name => 'x', type => 'float',
	  desc => 'x coordinate of upper-left corner of rectangle' },
	{ name => 'y', type => 'float',
	  desc => 'y coordinate of upper-left corner of rectangle' },
	&sample_merged_arg,
	{ name => 'sample_average', type => 'boolean',
	  desc => 'Average the color of all the pixels in a specified
		   radius' },
	{ name => 'average_radius', type => '0 < float',
	  desc => 'The radius of pixels to average',
	  cond => [ 'sample_average' ] }
    );
    $inargs[1]->{no_success} = 1;

    @outargs = (
	{ name => 'color', type => 'color', void_ret => 1,
	  desc => 'The return color', init => 1 }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-pick-color.h") ],
	code => <<'CODE'
{
  if (!sample_merged)
    if (!drawable || (gimp_item_get_image (GIMP_ITEM (drawable)) != gimage))
      success = FALSE;

  if (success)
    success = gimp_image_pick_color (gimage,
                                     drawable,
                                     (gint) x, (gint) y,
			             sample_merged,
                                     sample_average,
                                     average_radius,
                                     NULL,
                                     &color,
                                     NULL);
}
CODE
    );
}


@headers = qw("libgimpmath/gimpmath.h" "core/gimpdrawable.h");

@procs = qw(blend bucket_fill color_picker);

%exports = (app => [@procs], lib => [@procs]);

$desc = 'Misc Tool procedures';

1;
