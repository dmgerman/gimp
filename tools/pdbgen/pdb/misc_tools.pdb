# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

# Tools

# shortcuts

sub tool_init_args {
    (image => ['image', 'The image'],
     drawable => ['drawable', 'The affected drawable']);
}

sub sample_merged_arg {
    (sample_merged => ['boolean', 'Use the composite image, not the drawable']);
}

sub antialias_arg {
    (antialias => ['boolean', 'Antialiasing $desc']);
}

sub feather_select_args {
    (feather => ['boolean', 'Feather option for selections'],
     feather_radius => ['float', 'Radius for feather operation']);
}

sub stroke_args {
    (num_strokes => ['0 < int32', 
		     'number of stroke control points (count each coordinate as
		      2 points)'],
     strokes => ['floatarray',
		 'array of stroke coordinates: { s1.x, s1.y, s2.x, s2.y, ...,
		 sn.x, sn.y }']);
}

# The defs

sub airbrush {
    $blurb  = <<'BLURB';
Paint in the current brush with varying pressure. Paint application is
time-dependent.
BLURB

    $help = <<'HELP';
This tool simulates the use of an airbrush. Paint pressure represents the
relative intensity of the paint application. High pressure results in a thicker
layer of paint while low pressure results in a thinner layer.
HELP;

    &std_pdb_misc;

    %inargs = (
	&tool_init_args,
	pressure => ['0 <= float <= 100',
		     'The pressure of the airbrush strokes $desc'],
	&stroke_args
    );

    @invoke = (
	'airbrush.h',
	'airbrush_non_gui (drawable, pressure, num_strokes, strokes);'
    );
}

sub blend {
    $blurb = <<'BLURB';
Blend between the starting and ending coordinates with the specified blend mode
and gradient type.
BLURB

    $help = <<'HELP';
This tool requires information on the paint application mode, the blend mode,
and the gradient type. It creates the specified variety of blend using the
starting and ending coordinates as defined for each gradient type.
HELP

    &std_pdb_misc;

    %inargs = (
	&tool_init_args,
        blend_mode => ['enum BlendMode',
		       'The type of blend: $desc'],
	gradient_type => ['enum PaintMode',
			  'The paint application mode: $desc'],
	opacity => ['0 <= float <= 100',
		    'The opacity of the final blend $desc'],
	offset => ['0 <= float',
		   'Offset relates to the starting and ending coordinates
		    specified for the blend. This parameter is mode dependent
		    $desc'],
	repeat => ['enum RepeatMode', 'Repeat mode: $desc'],
        supersample => ['boolean', 'Do adaptive supersampling $desc'],
	max_depth => ['1 <= int32 <= 9',
		      'Maximum recursion levels for supersampling',
		      'attach supersample'],
	threshold => ['0 <= float <= 4',
		      'Supersampling threshold',
		      'attach supersample'],
	x1 => ['float', 'The x coordinate of this blend's starting point'],
	y1 => ['float', 'The y coordinate of this blend's starting point'],
	x2 => ['float', 'The x coordinate of this blend's ending point'],
	y2 => ['float', 'The y coordinate of this blend's ending point']
    );

    @invoke = (
        'blend.h',
	'blend (image, drawable, blend_mode, paint_mode, gradient_type, opacity, offset, repeat, supersample, max_depth, threshold, x1, y1, x2, y2);'
    );
}

sub bucket_fill {
    $blurb = <<'BLURB';
Fill the area specified either by the current selection if there is one, or by
a seed fill starting at the specified coordinates.
BLURB

    $help = <<'HELP'
This tool requires information on the paint application mode, and the fill
mode, which can either be in the foreground color, or in the currently active
pattern. If there is no selection, a seed fill is executed at the specified
coordinates and extends outward in keeping with the threshold parameter. If
there is a selection in the target image, the threshold, sample merged, x, and
y arguments are unused. If the sample_merged parameter is non-zero, the data of
the composite image will be used instead of that for the specified drawable.
This is equivalent to sampling for colors after merging all visible layers. In
the case of merged sampling, the x,y coordinates are relative to the image's
origin; otherwise, they are relative to the drawable's origin.
HELP;

    &std_pdb_misc;

    my $validity = 'This parameter is only valid when there is no selection in the specified image.'
    my $coord = "The \$a coordinate of this bucket fill's application. $validity";

    %inargs = (
	&tool_init_args,
	fill_mode => ['enum FillMode', 'The type of fill: $desc'],
	paint_mode => ['enum PaintMode', 'The paint application mode: $desc'],
	opacity => ['0 <= float <= 100',
		    'The opacity of the final bucket fill $desc'],
	threshold => ['0 <= float <= 255',
		      "The threshold determines how extensive the seed fill
		       will be. It's value is specified in terms of intensity
		       levels \$desc. $validity'],
	&sample_merged_arg,
	x => ['float', eval qq/{\$a = 'x';"$coord";}/],
	y => ['float', eval qq/{\$a = 'y';"$coord";}/]
    );

    @invoke = (
        'bucket_fill.h',
	'bucket_fill (image, drawable, fill_mode, paint_mode, opacity, threshold, sample_merged, x, y);'
    );
}

sub by_color_select {
    $blurb = <<'BLURB'
Create a selection by selecting all pixels (in the specified drawable) with the
same (or similar) color to that specified.
BLURB

    $help = <<'HELP'
This tool creates a selection over the specified image. A by-color selection is
determined by the supplied color under the constraints of the specified
threshold. Essentially, all pixels (in the drawable) that have color
sufficiently close to the specified color (as determined by the threshold
value) are included in the selection. The antialiasing parameter allows the
final selection mask to contain intermediate values based on close misses to
the threshold bar. Feathering can be enabled optionally and is controlled with
the \"feather_radius\" parameter. If the sample_merged parameter is non-zero,
the data of the composite image will be used instead of that for the specified
drawable. This is equivalent to sampling for colors after merging all visible
layers. In the case of a merged sampling, the supplied drawable is ignored.
HELP

    &std_pdb_misc;

    %inargs = (
	&tool_init_args,
	color => ['color', 'The color to select'],
	threshold => ['0 <= int32 <= 255',
		      'Threshold in intensity levels $desc'],
	operation => ['enum Operation', 'The selection operation: $desc'],
	&antialias_arg,
	&feather_select_args,
	&sample_merged_arg
    );

    @invoke = (
        'by_color_select.h',
	'by_color_select (image, drawable, color, threshold, operation, antialias, feather, feather_radius, sample_merged);'
    );
}

sub clone {
    $blurb = <<'BLURB'
Clone from the source to the dest drawable using the current brush
BLURB

    $help = <<'HELP'
This tool clones (copies) from the source drawable starting at the specified 
source coordinates to the dest drawable. If the \"clone_type\" argument is set 
to PATTERN-CLONE, then the current pattern is used as the source and the
\"src_drawable\" argument is ignored. Pattern cloning assumes a tileable
pattern and mods the sum of the src coordinates and subsequent stroke offsets
with the width and height of the pattern. For image cloning, if the sum of the
src coordinates and subsequent stroke offsets exceeds the extents of the src
drawable, then no paint is transferred. The clone tool is capable of
transforming between any image types including RGB->Indexed--although
converting from any type to indexed is significantly slower.
HELP

    &std_pdb_misc;

    %inargs = (
	&tool_init_args,
	src_drawable => ['drawable', "The source drawable"],
	clone_type => ['enum CloneType', 'The type of clone: $desc'],
	src_x => ['float', 'The x coordinate in the source image'],
	src_y => ['float', 'The y coordinate in the source image'],
	&stroke_args
    );

    @invoke = (
	'clone.h',
	'clone_non_gui (drawable, src_drawable, clone_type, src_x, src_y, num_strokes, strokes);'
    );
}

sub color_picker {
    $blurb = <<'BLURB';
Determine the color at the given drawable coordinates
BLURB

    $help = <<'HELP';
This tool determines the color at the specified coordinates. The returned color
is an RGB triplet even for grayscale and indexed drawables. If the coordinates
lie outside of the extents of the specified drawable, then an error is
returned. If the drawable has an alpha channel, the algorithm examines the
alpha value of the drawable at the coordinates. If the alpha value is
completely transparent (0), then an error is returned. If the sample_merged
parameter is non-zero, the data of the composite image will be used instead of
that for the specified drawable. This is equivalent to sampling for colors
after merging all visible layers. In the case of a merged sampling, the
supplied drawable is ignored.
HELP

    &std_pdb_misc;

    %inargs = (
	&tool_init_args,
	x => ['float', 'x coordinate of upper-left corner of rectangle'],
	y => ['float', 'y coordinate of upper-left corner of rectangle'],
	&sample_merged_arg,
	save_color => ['boolean', 'Save the color to the active palette']
    );

    %outargs = (
	color => ['color', 'The return color']
    );

    %invoke = (
	'color_picker.h',
	'
}
