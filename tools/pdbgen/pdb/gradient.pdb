# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

sub shlomi_misc {
    $author = $copyright = 'Shlomi Fish';
    $date   = '2003';
    $since  = '2.2';
}

my $get_gradient_from_name = <<'CODE';
  if (strlen (name))
    {
      gradient = (GimpGradient *)
        gimp_container_get_child_by_name (gimp->gradient_factory->container,
                                          name);
    }
  else
    {
      gradient = gimp_context_get_gradient (context);
    }
CODE

sub _gen_gradient_search_for_segment_code
{
    my $action_on_success = shift;

    chomp $action_on_success;

    $action_on_success =~ /^(\s*)/;
    my $indent = $1;

    $action_on_success =~ s/^$indent/' ' x 10/meg;

    return <<"CODE";
{
$get_gradient_from_name

  success = (gradient != NULL);

  if (success)
    {
      GimpGradientSegment *seg;

      seg = gimp_gradient_segment_get_nth (gradient->segments, segment);

      success = (seg != NULL);

      if (success)
        {
$action_on_success
        }
    }
}

CODE
}

sub other_side
{
    my $side = shift;

    return ($side eq "left") ? "right" : "left";
}

sub _grad_and_seg_params
{
    return
        ( { name => 'name', type => 'string',
            desc => 'The name of the gradient to operate on' },
          { name => 'segment', type => '0 <= int32',
            desc => 'The index of the segment within the gradient' }
        );
}

sub _gen_gradient_set_side_color
{
    my $side = shift;

    my $other_side = other_side($side);

    $blurb = "Retrieves the $side endpoint color of the specified gradient and segment";

    $help = <<"HELP";
This procedure retrieves the $side endpoint color of the specified segment of
the specified gradient.
HELP

    &shlomi_misc;

    @inargs = (
        &_grad_and_seg_params,
        { name => 'color', type => 'color',
          desc => "The color to set" },
        { name => "opacity", type => '0 <= float <= 100.0',
          desc => "The opacity to set for the endpoint" }
    );

    @outargs = (
    );

    my @blend_params = ("&color","&(seg->${other_side}_color)");

    if ($side eq "right") {
        @blend_params = reverse(@blend_params);
    }

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => &_gen_gradient_search_for_segment_code(<<"CODE"),
color.a = opacity / 100.0;
gimp_gradient_segment_set_${side}_color (gradient, seg, &color);
CODE
    );
}

sub _gen_gradient_get_side_color
{
    my $side = shift;

    $blurb = "Retrieves the $side endpoint color of the specified gradient and segment";

    $help = <<"HELP";
This procedure retrieves the $side endpoint color of the specified segment of
the specified gradient.
HELP

    &shlomi_misc;

    @inargs = (
        &_grad_and_seg_params,
    );

    @outargs = (
        { name => 'color', type => 'color',
          desc => "The return color", void_ret => 1, init => 1 },
        { name => "opacity", type => 'float', init => 1,
          desc => "The opacity of the endpoint" }
    );

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => &_gen_gradient_search_for_segment_code(<<"CODE"),
gimp_gradient_segment_get_${side}_color (gradient, seg, &color);
opacity = color.a * 100.0;
CODE
    );
}

sub _gen_gradient_get_pos
{
    my $side = shift;

    my $side_endpoint =
        (($side eq "middle") ?
            "middle point" :
            "$side endpoint"
        );

    $blurb = "Retrieves the $side_endpoint position of the specified gradient and segment";

    $help = <<"HELP";
This procedure retrieves the $side_endpoint position of the specified segment of
the specified gradient.
HELP

    &shlomi_misc;

    @inargs = &_grad_and_seg_params;

    @outargs = (
        { name => 'pos', type => 'float',
          desc => "The return position", void_ret => 1, init => 1 }
    );

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => &_gen_gradient_search_for_segment_code(<<"CODE"),
pos = gimp_gradient_segment_get_${side}_pos (gradient, seg);
CODE
    );
}

sub _gen_gradient_set_pos
{
    my $side = shift;

    my $side_endpoint =
        (($side eq "middle") ?
            "middle point" :
            "$side endpoint"
        );

    $blurb = "Sets the $side_endpoint position of the specified gradient and segment";

    my %betweens =
    (
        'left' =>  ("the position of the middle point to the left to " .
                   "the middle point of the current segement"),
        'right' => ("the position of the middle point of the current " .
                    "segment and the middle point of the segment to " .
                    "the right"),
        'middle' => ("the two endpoints of the segment"),
    );

    $help = <<"HELP";
This procedure sets the $side_endpoint position of the specified segment of
the specified gradient. The final position will be between $betweens{$side}.

This procedure returns the final position.
HELP

    &shlomi_misc;

    @inargs = (
        &_grad_and_seg_params,
        { name => 'pos', type => "0.0 <= float <= 1.0",
          desc => "The position to set the guidepoint in." }
    );

    @outargs = (
        { name => 'final_pos', type => 'float',
          desc => "The return position", void_ret => 1, init => 1 }
    );

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => &_gen_gradient_search_for_segment_code(<<"CODE"),
final_pos =
  gimp_gradient_segment_set_${side}_pos (gradient, seg, pos);
CODE
    );
}


# The defs

sub gradient_new {
    $blurb = "Creates a new gradient";
    $help  = "This procedure creates a new, uninitialized gradient";

    &shlomi_misc;

    @inargs = (
	{ name => 'name', type => 'string',
	  desc => 'The requested name of the new gradient' }
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => 'The actual new gradient name',
	  alias => 'g_strdup (GIMP_OBJECT (gradient)->name)', no_declare => 1 },
    );

    %invoke = (
        vars => [ 'GimpGradient * gradient = NULL'],
        code => <<'CODE'
{
  gradient = (GimpGradient *)
    gimp_data_factory_data_new (gimp->gradient_factory, name);
}
CODE
    );
}

sub gradient_duplicate {
    $blurb = "Duplicates a gradient";
    $help  = "This procedure creates an identical gradient by a different name";

    &shlomi_misc;

    @inargs = (
        { name => 'name', type => 'string',
          desc => "The name of the gradient to duplicate" }
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => "The name of the gradient's copy",
	  alias => 'g_strdup (GIMP_OBJECT (gradient_copy)->name)',
          no_declare => 1 }
    );

    %invoke = (
	vars => [ 'GimpGradient *gradient = NULL',
                  'GimpGradient *gradient_copy = NULL' ],
        code => <<"CODE"
{
  $get_gradient_from_name

  if (gradient)
    {
      gradient_copy = (GimpGradient *)
        gimp_data_factory_data_duplicate (gimp->gradient_factory,
                                          GIMP_DATA (gradient));

      success = (gradient_copy != NULL);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradient_rename {
    $blurb = "Rename a gradient";
    $help  = "This procedure renames a gradient";

    &shlomi_misc;

    @inargs = (
        { name => 'name', type => 'string',
          desc => "The name of the gradient to rename" },
        { name => 'new_name', type => 'string',
          desc => "The new name of the gradient" }
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => "The actual new name of the gradient",
	  alias => 'g_strdup (GIMP_OBJECT (gradient)->name)', no_declare => 1 }
    );

    %invoke = (
	vars => [ 'GimpGradient *gradient = NULL' ],
	code => <<"CODE"
{
  $get_gradient_from_name

  if (gradient && GIMP_DATA (gradient)->writable)
    gimp_object_set_name (GIMP_OBJECT (gradient), new_name);
  else
    success = FALSE;
}
CODE
    );
}

sub gradient_delete {
    $blurb = "Deletes a gradient";
    $help  = "This procedure deletes a gradient";

    &shlomi_misc;

    @inargs = (
        { name => 'name', type => 'string',
          desc => "The name of the gradient to delete" }
    );

    %invoke = (
	vars => [ 'GimpGradient *gradient = NULL' ],
	code => <<"CODE"
{
  $get_gradient_from_name

  if (gradient && GIMP_DATA (gradient)->deletable)
    {
      GError *error = NULL;

      success = gimp_data_factory_data_delete (gimp->gradient_factory,
                                               GIMP_DATA (gradient),
                                               TRUE, &error);

      if (! success)
        {
          g_message (error->message);
          g_clear_error (&error);
        }
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradient_segment_get_left_color
{
    &_gen_gradient_get_side_color("left");
}

sub gradient_segment_get_right_color
{
    &_gen_gradient_get_side_color("right");
}

sub gradient_segment_set_left_color
{
    &_gen_gradient_set_side_color("left");
}

sub gradient_segment_set_right_color
{
    &_gen_gradient_set_side_color("right");
}

sub gradient_segment_get_left_pos
{
    &_gen_gradient_get_pos("left");
}

sub gradient_segment_get_right_pos
{
    &_gen_gradient_get_pos("right");
}

sub gradient_segment_get_middle_pos
{
    &_gen_gradient_get_pos("middle");
}

sub gradient_segment_set_left_pos
{
    &_gen_gradient_set_pos("left");
}

sub gradient_segment_set_right_pos
{
    &_gen_gradient_set_pos("right");
}

sub gradient_segment_set_middle_pos
{
    &_gen_gradient_set_pos("middle");
}

sub gradient_segment_get_blending_function
{
    $blurb = "Retrieves the gradient segment's blending function";

    $help = <<'HELP';
This procedure retrieves the blending function of the segment at the
specified gradient name and segment index.
HELP

    &shlomi_misc;

    @inargs = &_grad_and_seg_params;

    @outargs = (
        { name => 'blend_func', type => 'enum GimpGradientSegmentType',
          desc => "The blending function of the segment: { %%desc%% }",
          void_ret => 1, init => 1 }
    );

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => &_gen_gradient_search_for_segment_code(<<"CODE"),
blend_func =
  gimp_gradient_segment_get_blending_function (gradient, seg);
CODE
    );
}

sub gradient_segment_get_coloring_type
{
    $blurb = "Retrieves the gradient segment's coloring type";

    $help = <<'HELP';
This procedure retrieves the coloring type of the segment at the
specified gradient name and segment index.
HELP

    &shlomi_misc;

    @inargs = &_grad_and_seg_params;

    @outargs = (
        { name => 'coloring_type', type => 'enum GimpGradientSegmentColor',
          desc => "The coloring type of the segment: { %%desc%% }",
          void_ret => 1, init => 1 }
    );

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => &_gen_gradient_search_for_segment_code(<<"CODE"),
coloring_type =
  gimp_gradient_segment_get_coloring_type (gradient, seg);
CODE
    );
}

sub _gen_gradient_operate_on_segments_range
{
    my %args = (@_);

    $blurb = $args{blurb};

    $help = $args{help};

    &shlomi_misc;

    @inargs = (
        { name => 'name', type => 'string',
          desc => 'The name of the gradient to operate on.' },
        { name => 'start_segment', type => '0 <= int32',
          desc => 'The index of the first segment to operate on' },
        { name => 'end_segment', type => 'int32',
          desc => 'The index of the last segment to operate on. If negative, the selection will extend to the end of the string.' },
        @{$args{inargs}},
    );

    @outargs = @{$args{outargs}};

    my $action_on_success = $args{action_on_success};
    chomp $action_on_success;

    $action_on_success =~ /^(\s*)/;
    my $indent = $1;

    $action_on_success =~ s/^$indent/' ' x 14/meg;

    %invoke = (
        vars => [ 'GimpGradient *gradient = NULL' ],
        code => <<"CODE",
{
$get_gradient_from_name

  if (gradient)
    {
      GimpGradientSegment *start_seg, *end_seg;
      start_seg = gimp_gradient_segment_get_nth (gradient->segments,
                                                 start_segment);
      if (start_seg)
        {
          if ((end_segment < start_segment) && (end_segment >= 0))
            {
              /* Do Nothing */
              success = FALSE;
            }
          else
            {
              if (end_segment < 0)
                {
                  end_seg = NULL;
                }
              else
                {
                  end_seg = gimp_gradient_segment_get_nth (start_seg,
                                                           end_segment -
                                                           start_segment);
                }

              /* Success */
$action_on_success
            }
        }
      else
        {
          success = FALSE;
        }
    }
}
CODE
    );
}

sub gradient_segment_range_set_blending_function
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Change the blending function of a segments range",
        'help' => <<'HELP',
This function changes the blending function of a segment range to the
specified blending function.
HELP
        'inargs' => [
             { name => "blending_function",
               type => 'enum GimpGradientSegmentType',
               desc => "The Blending Function: { %%desc%% }" }
        ],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_set_blending_function (gradient,
                                                   start_seg,
                                                   end_seg,
                                                   blending_function);
CODE
    );
}

sub gradient_segment_range_set_coloring_type
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Change the coloring type of a segments range",
        'help' => <<'HELP',
This function changes the coloring type of a segment range to the
specified coloring type.
HELP
        'inargs' => [
            { name => "coloring_type", type => 'enum GimpGradientSegmentColor',
              desc => "The Coloring Type: { %%desc%% }" }
        ],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_set_coloring_type (gradient,
                                               start_seg,
                                               end_seg,
                                               coloring_type);
CODE
    );
}

sub gradient_segment_range_flip
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Flip the segment range",
        'help' => <<'HELP',
This function flips a segment range.
HELP
        'inargs' => [],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_flip (gradient,
                                  start_seg,
                                  end_seg,
                                  NULL, NULL);
CODE
    );
}

sub gradient_segment_range_replicate
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Replicate the segment range",
        'help' => <<'HELP',
This function replicates a segment range a given number of times. Instead
of the original segment range, several smaller scaled copies of it
will appear in equal widths.
HELP
        'inargs' => [
            { 'name' => "replicate_times", 'type' => "2 <= int32 <= 20",
              'desc' => "The number of times to replicate" }
        ],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_replicate (gradient,
                                       start_seg,
                                       end_seg,
                                       replicate_times,
                                       NULL, NULL);
CODE
    );
}

sub gradient_segment_range_split_midpoint
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Splits each segment in the segment range at midpoint",
        'help' => <<'HELP',
This function splits each segment in the segment range at its midpoint.
HELP
        'inargs' => [],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_split_midpoint (gradient,
                                            start_seg,
                                            end_seg,
                                            NULL, NULL);
CODE
    );
}

sub gradient_segment_range_split_uniform
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Splits each segment in the segment range uniformly",
        'help' => <<'HELP',
This function splits each segment in the segment range uniformly according
to the number of times specified by the parameter.
HELP
        'inargs' => [
            { 'name' => "split_parts", 'type' => "2 <= int32 <= 20",
              'desc' => "The number of uniform divisions to split each segment to" }
        ],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_split_uniform (gradient,
                                           start_seg,
                                           end_seg,
                                           split_parts,
                                           NULL, NULL);
CODE
    );
}

sub gradient_segment_range_delete
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Delete the segment range",
        'help' => <<'HELP',
This function deletes a segment range.
HELP
        'inargs' => [],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_delete (gradient,
                                    start_seg,
                                    end_seg,
                                    NULL, NULL);
CODE
    );
}

sub gradient_segment_range_redistribute_handles
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Uniformly redistribute the segment range's handles",
        'help' => <<'HELP',
This function redistributes the handles of the specified segment range of the
specified gradient, so they'll be evenly spaced.
HELP
        'inargs' => [],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_redistribute_handles (gradient,
                                                  start_seg,
                                                  end_seg);
CODE
    );
}

sub gradient_segment_range_blend_colors
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Blend the colors of the segment range.",
        'help' => <<'HELP',
This function blends the colors (but not the opacity) of the segments'
range of the gradient. Using it, the colors' transition will be uniform
across the range.
HELP
        'inargs' => [],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_blend (gradient,
                                   start_seg, end_seg,
                                   &start_seg->left_color,
                                   &end_seg->right_color,
                                   TRUE, FALSE);
CODE
    );
}

sub gradient_segment_range_blend_opacity
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Blend the opacity of the segment range.",
        'help' => <<'HELP',
This function blends the opacity (but not the colors) of the segments'
range of the gradient. Using it, the opacity's transition will be uniform
across the range.
HELP
        'inargs' => [],
        'outargs' => [],
        'action_on_success' => <<'CODE',
gimp_gradient_segment_range_blend (gradient,
                                   start_seg, end_seg,
                                   &start_seg->left_color,
                                   &end_seg->right_color,
                                   FALSE, TRUE);
CODE
    );
}

sub gradient_segment_range_move
{
    &_gen_gradient_operate_on_segments_range(
        'blurb' => "Move the position of an entire segment range by a delta.",
        'help' => <<'HELP',
This funtions moves the position of an entire segment range by a delta. The
actual delta (which is returned) will be limited by the control points of the
neighboring segments.
HELP
        'inargs' => [
            { 'name' => "delta", 'type' => "-1.0 <= float <= 1.0",
              'desc' => "The delta to move the segment range" },
            { 'name' => "control_compress", 'type' => "boolean",
              'desc' => "Whether or not to compress the neighboring segments" }
        ],
        'outargs' => [
            { 'name' => "final_delta", 'type' => "float", init => 1,
              'desc' => "The final delta by which the range moved" }
        ],
        'action_on_success' => <<'CODE',
final_delta = gimp_gradient_segment_range_move (gradient,
                                                start_seg,
                                                end_seg,
                                                delta,
                                                control_compress);

CODE
    );
}

@headers = qw(<string.h> "core/gimp.h" "core/gimpcontext.h"
              "core/gimpgradient.h" "core/gimpcontainer.h"
              "core/gimpdatafactory.h" "core/gimplist.h");

@procs = qw(gradient_new gradient_duplicate gradient_rename gradient_delete
            gradient_segment_get_left_color gradient_segment_set_left_color
            gradient_segment_get_right_color gradient_segment_set_right_color
            gradient_segment_get_left_pos gradient_segment_set_left_pos
            gradient_segment_get_middle_pos gradient_segment_set_middle_pos
            gradient_segment_get_right_pos gradient_segment_set_right_pos
            gradient_segment_get_blending_function
            gradient_segment_get_coloring_type
            gradient_segment_range_set_blending_function 
            gradient_segment_range_set_coloring_type
            gradient_segment_range_flip
            gradient_segment_range_replicate
            gradient_segment_range_split_midpoint
            gradient_segment_range_split_uniform
            gradient_segment_range_delete
            gradient_segment_range_redistribute_handles
            gradient_segment_range_blend_colors
            gradient_segment_range_blend_opacity
            gradient_segment_range_move);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Gradient';

1;
