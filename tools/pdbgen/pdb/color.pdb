# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub drawable_arg () {{
    name => 'drawable',
    type => 'drawable',
    desc => 'The drawable',
}}

sub channel_arg () {{
    name => 'channel',
    type => 'enum GimpHistogramChannel',
    desc => 'The channel to modify: { %%desc%% }'
}}

sub brightness_contrast {
    $blurb = 'Modify brightness/contrast in the specified drawable.';

    $help = <<'HELP';
This procedures allows the brightness and contrast of the specified drawable to
be modified.  Both 'brightness' and 'contrast' parameters are defined between
-127 and 127.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = ( &drawable_arg );
    foreach (qw( brightness contrast)) {
	push @inargs, { name => $_, type => '-127 <= int32 <= 127',
			desc => "\u$_ adjustment: (%%desc%%)" }
    }

    %invoke = (
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          GimpLut     *lut;
          PixelRegion  srcPR, destPR;

          lut = brightness_contrast_lut_new (brightness / 255.0,
                                             contrast / 127.0,
                                             gimp_drawable_bytes (drawable));

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc)
                                          gimp_lut_process,
                                          lut, 2, &srcPR, &destPR);

          gimp_lut_free (lut);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Brightness-Contrast"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub levels {
    $blurb = 'Modifies intensity levels in the specified drawable.';

    $help = <<'HELP';
This tool allows intensity levels in the specified drawable to be remapped
according to a set of parameters. The low/high input levels specify an initial
mapping from the source intensities. The gamma value determines how intensities
between the low and high input intensities are interpolated. A gamma value of
1.0 results in a linear interpolation. Higher gamma values result in more
high-level intensities. Lower gamma values result in more low-level
intensities. The low/high output levels constrain the final intensity
mapping--that is, no final intensity will be lower than the low output level
and no final intensity will be higher than the high output level. This tool is
only valid on RGB color and grayscale images. It will not operate on indexed
drawables.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	&channel_arg
    );

    foreach $arg (qw(input output)) {
	foreach (qw(low high)) {
	    push @inargs, { name => "${_}_$arg", type => '0 <= int32 <= 255',
			    desc => "Intensity of ${_}est $arg: (%%desc%%)" }
	}
	push @inargs, { name => 'gamma', type => '0.1 <= float <= 10',
			desc => 'Gamma correction factor: (%%desc%%)' }
    }
    $#inargs--;

    %invoke = (
	headers => [ qw("base/levels.h"
                        "core/gimpdrawable-levels.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable) ||
      (! gimp_drawable_has_alpha (drawable) &&
       channel == GIMP_HISTOGRAM_ALPHA) ||
      (gimp_drawable_is_gray (drawable) &&
       channel != GIMP_HISTOGRAM_VALUE && channel != GIMP_HISTOGRAM_ALPHA))
    success = FALSE;

  if (success)
    gimp_drawable_levels (drawable, context,
                          channel,
                          low_input,
                          high_input,
                          gamma,
                          low_output,
                          high_output);
}
CODE
    );
}

sub levels_stretch {
    $blurb = 'Automatically modifies intensity levels in the specified drawable.';

    $help = <<'HELP';
This procedure allows intensity levels in the specified drawable to be
remapped according to a set of guessed parameters. It is equivalent to
clicking the "Auto" button in the Levels tool. This procedure is
only valid on RGB color and grayscale images. It will not operate on
indexed drawables.
HELP

    $author = $copyright = 'Joao S.O. Bueno, Shawn Willden';
    $date = '2003';

    @inargs = ( &drawable_arg );

    %invoke = (
        headers => [ qw("base/levels.h"
                        "base/gimphistogram.h"
                        "core/gimpdrawable-histogram.h"
                        "core/gimpdrawable-levels.h") ],
        code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    gimp_drawable_levels_stretch (drawable, context);
}
CODE
    );
}



sub levels_auto {
    &std_pdb_deprecated ('gimp_levels_stretch');

    @inargs = ( &drawable_arg );

    %invoke = (
        headers => [ qw("base/levels.h"
                        "base/gimphistogram.h"
                        "core/gimpdrawable-histogram.h"
                        "core/gimpdrawable-levels.h") ],
        code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    gimp_drawable_levels_stretch (drawable, context);
}
CODE
    );
}

sub posterize {
    $blurb = 'Posterize the specified drawable.';

    $help = <<'HELP';
This procedures reduces the number of shades allows in each intensity channel
to the specified 'levels' parameter.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	&drawable_arg,
	{ name => 'levels', type => '2 <= int32 <= 255',
	  desc => 'Levels of posterization: (%%desc%%)' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          GimpLut     *lut;
          PixelRegion  srcPR, destPR;

          lut = posterize_lut_new (levels, gimp_drawable_bytes (drawable)); 

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc)
                                          gimp_lut_process,
                                          lut, 2, &srcPR, &destPR);

          gimp_lut_free (lut);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Posterize"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub desaturate {
    $blurb = 'Desaturate the contents of the specified drawable.';

    $help = <<'HELP';
This procedure desaturates the contents of the specified drawable. This
procedure only works on drawables of type RGB color.
HELP

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    %invoke = (
	headers => [ qw("core/gimpdrawable-desaturate.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      ! gimp_drawable_is_rgb (drawable))
    success = FALSE;

  if (success)
    gimp_drawable_desaturate (drawable, GIMP_DESATURATE_LIGHTNESS);
}
CODE
    );
}

sub desaturate_full {
    $blurb = 'Desaturate the contents of the specified drawable, with the specified formula.';

    $help = <<'HELP';
This procedure desaturates the contents of the specified drawable, with the specified
formula. This procedure only works on drawables of type RGB color.
HELP

    $author = $copyright = 'Karine Delvare';
    $date = '2005';
    $since = '2.4';

    @inargs = (
        &drawable_arg,
	{ name => 'desaturate_mode', type => 'enum GimpDesaturateMode',
	  desc => 'The formula to use to desaturate' }
    );

    %invoke = (
	headers => [ qw("core/gimpdrawable-desaturate.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      ! gimp_drawable_is_rgb (drawable))
    success = FALSE;

  if (success)
    gimp_drawable_desaturate (drawable, (GimpDesaturateMode) desaturate_mode);
}
CODE
    );
}

sub equalize {
    $blurb = 'Equalize the contents of the specified drawable.';

    $help = <<'HELP';
This procedure equalizes the contents of the specified drawable. Each intensity
channel is equalizeed independently. The equalized intensity is given as inten'
= (255 - inten). Indexed color drawables are not valid for this operation. The
'mask_only' option specifies whether to adjust only the area of the image
within the selection bounds, or the entire image based on the histogram of the
selected area. If there is no selection, the entire image is adjusted based on
the histogram for the entire image.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	{ name => 'mask_only', type => 'boolean',
	  desc => 'Equalization option' }
    );

    %invoke = (
	headers => [ qw("core/gimpdrawable-equalize.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    gimp_drawable_equalize (drawable, mask_only);
}
CODE
    );
}

sub invert {
    $blurb = 'Invert the contents of the specified drawable.';

    $help = <<'HELP';
This procedure inverts the contents of the specified drawable. Each intensity
channel is inverted independently. The inverted intensity is given as inten' =
(255 - inten). Indexed color drawables are not valid for this operation.
HELP

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    %invoke = (
	headers => [ qw("core/gimpdrawable-invert.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    gimp_drawable_invert (drawable);
}
CODE
    );
}

sub curves_spline {
    $blurb = 'Modifies the intensity curve(s) for specified drawable.';

    $help = <<'HELP';
Modifies the intensity mapping for one channel in the specified drawable. The
drawable must be either grayscale or RGB, and the channel can be either an
intensity component, or the value. The 'control_pts' parameter is an array of
integers which define a set of control points which describe a Catmull Rom
spline which yields the final intensity curve. Use the 'gimp_curves_explicit'
function to explicitly modify intensity levels.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	&channel_arg,
	{ name => 'control_pts', type => 'int8array',
	  desc => 'The spline control points: { cp1.x, cp1.y, cp2.x, cp2.y,
		   ... }',
	  array => { name => 'num_points', type => '3 < int32 <= 34',
		     desc => 'The number of values in the control point array
			      (%%desc%%)' } }
    );

    %invoke = (
	headers => [ qw("base/curves.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable) || (num_points & 1) ||
      (! gimp_drawable_has_alpha (drawable) &&
       channel == GIMP_HISTOGRAM_ALPHA) ||
      (gimp_drawable_is_gray (drawable) &&
       channel != GIMP_HISTOGRAM_VALUE && channel != GIMP_HISTOGRAM_ALPHA))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          Curves       c;
          gint         j;
          PixelRegion  srcPR, destPR;
          GimpLut     *lut;

          /* FIXME: hack */
          if (gimp_drawable_is_gray (drawable) &&
              channel == GIMP_HISTOGRAM_ALPHA)
            channel = 1;

          lut = gimp_lut_new ();

          curves_init (&c);

          /*  unset the last point  */
          c.points[channel][CURVES_NUM_POINTS - 1][0] = -1;
          c.points[channel][CURVES_NUM_POINTS - 1][1] = -1;

          for (j = 0; j < num_points / 2; j++)
            {
              c.points[channel][j][0] = control_pts[j * 2];
              c.points[channel][j][1] = control_pts[j * 2 + 1];
            }

          curves_calculate_curve (&c, channel);

          gimp_lut_setup (lut,
                          (GimpLutFunc) curves_lut_func,
                          &c,
                          gimp_drawable_bytes (drawable));

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc)
                                          gimp_lut_process,
                                          lut, 2, &srcPR, &destPR);

          gimp_lut_free (lut);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Curves"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub curves_explicit {
    $blurb = 'Modifies the intensity curve(s) for specified drawable.';

    $help = <<'HELP';
Modifies the intensity mapping for one channel in the specified drawable. The
drawable must be either grayscale or RGB, and the channel can be either an
intensity component, or the value. The 'curve' parameter is an array of bytes
which explicitly defines how each pixel value in the drawable will be modified.
Use the 'gimp_curves_spline' function to modify intensity levels with Catmull
Rom splines.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	&channel_arg,
	{ name => 'curve', type => 'int8array',
	  desc => 'The explicit curve',
	  array => { name => 'num_bytes',
		     desc => 'The number of bytes in the new curve (always
			      256)' } }
    );

    %invoke = (
	headers => [ qw("base/curves.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable) || (num_bytes != 256) ||
      (! gimp_drawable_has_alpha (drawable) &&
       channel == GIMP_HISTOGRAM_ALPHA) ||
      (gimp_drawable_is_gray (drawable) &&
       channel != GIMP_HISTOGRAM_VALUE && channel != GIMP_HISTOGRAM_ALPHA))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          Curves       c;
          gint         j;
          PixelRegion  srcPR, destPR;
          GimpLut     *lut;

          /* FIXME: hack */
          if (gimp_drawable_is_gray (drawable) &&
              channel == GIMP_HISTOGRAM_ALPHA)
            channel = 1;

          lut = gimp_lut_new ();

          curves_init (&c);

          for (j = 0; j < 256; j++)
            c.curve[channel][j] = curve[j];

          gimp_lut_setup (lut,
                          (GimpLutFunc) curves_lut_func,
                          &c,
                          gimp_drawable_bytes (drawable));
      
          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc)
                                          gimp_lut_process,
                                          lut, 2, &srcPR, &destPR);

          gimp_lut_free (lut);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Curves"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub color_balance {
    $blurb = 'Modify the color balance of the specified drawable.';

    $help = <<'HELP';
Modify the color balance of the specified drawable. There are three axis which
can be modified: cyan-red, magenta-green, and yellow-blue. Negative values
increase the amount of the former, positive values increase the amount of the
latter. Color balance can be controlled with the 'transfer_mode' setting, which
allows shadows, midtones, and highlights in an image to be affected
differently. The 'preserve_lum' parameter, if non-zero, ensures that the
luminosity of each pixel remains fixed.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	&drawable_arg,
	{ name => 'transfer_mode', type => 'enum GimpTransferMode',
	  desc => 'Transfer mode: { %%desc%% }' },
	{ name => 'preserve_lum', type => 'boolean',
	  desc => 'Preserve luminosity values at each pixel' }
    );

    foreach (qw(cyan_red magenta_green yellow_blue)) {
	my $arg = { name => $_, type => '-100 <= float <= 100' };
        ($arg->{desc} = ucfirst $_) =~ s/_(.)/-\U$1\E/;
	 $arg->{desc} .= ' color balance: (%%desc%%)';
	push @inargs, $arg;
    }

    %invoke = (
	headers => [ qw("base/color-balance.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          ColorBalance  cb;
          PixelRegion   srcPR, destPR;

          color_balance_init (&cb);

          cb.preserve_luminosity = preserve_lum;

          cb.cyan_red[transfer_mode]      = cyan_red;
          cb.magenta_green[transfer_mode] = magenta_green;
          cb.yellow_blue[transfer_mode]   = yellow_blue;

          color_balance_create_lookup_tables (&cb);

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc) color_balance,
                                          &cb, 2, &srcPR, &destPR);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Color Balance"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub colorize {
    $blurb = 'Render the drawable as a grayscale image seen through a colored glass.';

    $help = <<'HELP';
Desatures the drawable, then tints it with the specified color. This tool is
only valid on RGB color images. It will not operate on grayscale or indexed
drawables.
HELP

    &std_pdb_misc;
    $date = '2004';
    $since = '2.2';

    @inargs = (
	&drawable_arg,
	{ name => 'hue', type => '0 <= float <= 360',
	  desc => 'Hue in degrees: (%%desc%%)' },
	{ name => 'saturation', type => '0 <= float <= 100',
	  desc => 'Saturation in percent: (%%desc%%)' },
	{ name => 'lightness', type => '-100 <= float <= 100',
	  desc => 'Lightness in percent: (%%desc%%)' }
    );

    %invoke = (
	headers => [ qw("base/colorize.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      ! gimp_drawable_is_rgb (drawable))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          Colorize     colors;
          PixelRegion  srcPR, destPR;

          colorize_init (&colors);

          colors.hue        = hue;
          colors.saturation = saturation;
          colors.lightness  = lightness;

          colorize_calculate (&colors);

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc) colorize,
                                          &colors, 2, &srcPR, &destPR);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Colorize"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub histogram {
    $blurb = <<'BLURB';
Returns information on the intensity histogram for the specified drawable.
BLURB

    $help = <<'HELP';
This tool makes it possible to gather information about the intensity histogram
of a drawable. A channel to examine is first specified. This can be either
value, red, green, or blue, depending on whether the drawable is of type color
or grayscale. The drawable may not be indexed. Second, a range of intensities
are specified. The gimp_histogram function returns statistics based on the
pixels in the drawable that fall under this range of values. Mean, standard
deviation, median, number of pixels, and percentile are all returned.
Additionally, the total count of pixels in the image is returned. Counts of
pixels are weighted by any associated alpha values and by the current selection
mask. That is, pixels that lie outside an active selection mask will not be
counted. Similarly, pixels with transparent alpha values will not be counted.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	&channel_arg,
    );

    foreach (qw(start end)) {
	push @inargs, { name => "${_}_range", type => '0 <= int32 < 256',
			desc => "\u$_ of the intensity measurement range" }
    }

    @outargs = (
	{ name => 'mean', void_ret => 1, init => 1,
	  desc => 'Mean intensity value' },
	{ name => 'std_dev', init => 1,
	  desc => 'Standard deviation of intensity values' },
	{ name => 'median', init => 1,
	  desc => 'Median intensity value' },
	{ name => 'pixels', init => 1,
	  desc => 'Alpha-weighted pixel count for entire image' },
	{ name => 'count', init => 1,
	  desc => 'Alpha-weighted pixel count for range' },
	{ name => 'percentile', init => 1,
	  desc => 'Percentile that range falls under' }
    );

    foreach (@outargs) {
       @$_{qw(type alias)} = ('float', "$_->{name}", 1)
    }

    %invoke = (
	headers => [ qw("core/gimp.h" "core/gimpdrawable-histogram.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable) ||
      (! gimp_drawable_has_alpha (drawable) &&
       channel == GIMP_HISTOGRAM_ALPHA) ||
      (gimp_drawable_is_gray (drawable) &&
       channel != GIMP_HISTOGRAM_VALUE && channel != GIMP_HISTOGRAM_ALPHA))
    success = FALSE;

  if (success)
    {
      GimpHistogram *histogram = gimp_histogram_new ();

      gimp_drawable_calculate_histogram (drawable, histogram);

      mean       = gimp_histogram_get_mean (histogram, channel,
		 			    start_range, end_range);
      std_dev    = gimp_histogram_get_std_dev (histogram, channel,
					       start_range, end_range);
      median     = gimp_histogram_get_median (histogram, channel,
					      start_range, end_range);
      pixels     = gimp_histogram_get_count (histogram, channel, 0, 255);
      count      = gimp_histogram_get_count (histogram, channel,
                                             start_range, end_range);
      percentile = count / pixels;

      gimp_histogram_free (histogram);
    }
}
CODE
    );
}

sub hue_saturation {
    $blurb = <<'BLURB';
Modify hue, lightness, and saturation in the specified drawable.
BLURB

    $help = <<'HELP';
This procedures allows the hue, lightness, and saturation in the specified
drawable to be modified. The 'hue_range' parameter provides the capability to
limit range of affected hues.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	&drawable_arg,
	{ name => 'hue_range', type => 'enum GimpHueRange',
	  desc => 'Range of affected hues: { %%desc%% }' },
	{ name => 'hue_offset', type => '-180 <= float <= 180',
	  desc => 'Hue offset in degrees: (%%desc%%)' }
    );

    foreach (qw(lightness saturation)) {
	push @inargs, { name => $_, type => '-100 <= float <= 100',
			desc => "$_ modification: (%%desc%%)" }
    }

    %invoke = (
	headers => [ qw("base/hue-saturation.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          HueSaturation  hs;
          PixelRegion    srcPR, destPR;

          hue_saturation_init (&hs);

          hs.hue[hue_range]        = hue_offset;
          hs.lightness[hue_range]  = lightness;
          hs.saturation[hue_range] = saturation;

          /* Calculate the transfer arrays */
          hue_saturation_calculate_transfers (&hs);

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

	  pixel_regions_process_parallel ((PixelProcessorFunc) hue_saturation,
                                          &hs, 2, &srcPR, &destPR);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Hue-Saturation"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

sub threshold {
    $blurb = 'Threshold the specified drawable.';

    $help = <<'HELP';
This procedures generates a threshold map of the specified drawable. All pixels
between the values of 'low_threshold' and 'high_threshold' are replaced with
white, and all other pixels with black.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = ( &drawable_arg );
    foreach (qw(low high)) {
	push @inargs, { name => "${_}_threshold", type => '0 <= int32 <= 255',
			desc => "The $_ threshold value: %%desc%%" }
    }

    %invoke = (
	headers => [ qw("base/threshold.h") ],
	code => <<'CODE'
{
  if (! gimp_item_is_attached (GIMP_ITEM (drawable)) ||
      gimp_drawable_is_indexed (drawable) ||
      (low_threshold >= high_threshold))
    success = FALSE;

  if (success)
    {
      gint x, y, width, height;

      /* The application should occur only within selection bounds */
      if (gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height))
        {
          Threshold   tr;
          PixelRegion srcPR, destPR;

          tr.color          = gimp_drawable_is_rgb (drawable);
          tr.low_threshold  = low_threshold;
          tr.high_threshold = high_threshold;

          pixel_region_init (&srcPR, gimp_drawable_data (drawable),
                             x, y, width, height, FALSE);
          pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
                             x, y, width, height, TRUE);

          pixel_regions_process_parallel ((PixelProcessorFunc) threshold,
                                          &tr, 2, &srcPR, &destPR);

          gimp_drawable_merge_shadow (drawable, TRUE, _("Threshold"));
          gimp_drawable_update (drawable, x, y, width, height);
        }
    }
}
CODE
    );
}

@headers = qw("base/gimphistogram.h"
              "base/gimplut.h" "base/lut-funcs.h"
	      "base/pixel-region.h" "base/pixel-processor.h"
              "core/gimpdrawable.h" "core/gimpimage.h"
              "gimp-intl.h");

@procs = qw(brightness_contrast levels levels_auto levels_stretch posterize
            desaturate desaturate_full equalize invert curves_spline
            curves_explicit color_balance colorize histogram hue_saturation
            threshold);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Color';

1;
