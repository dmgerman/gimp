begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function
DECL|function|p_c_ident (Id id)
name|PNode
modifier|*
name|p_c_ident
parameter_list|(
name|Id
name|id
parameter_list|)
block|{
name|PNode
modifier|*
name|n
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
name|GString
modifier|*
name|s
init|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|id
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|i
operator|&&
name|isupper
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|g_string_append_c
argument_list|(
name|s
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
condition|)
name|g_string_append_c
argument_list|(
name|s
argument_list|,
name|tolower
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|p_str
argument_list|(
name|s
operator|->
name|str
argument_list|)
expr_stmt|;
name|g_string_free
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
DECL|function|p_c_macro (Id id)
name|PNode
modifier|*
name|p_c_macro
parameter_list|(
name|Id
name|id
parameter_list|)
block|{
name|PNode
modifier|*
name|n
decl_stmt|;
name|gint
name|i
init|=
literal|0
decl_stmt|;
name|GString
modifier|*
name|s
init|=
name|g_string_new
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|id
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|i
operator|&&
name|isupper
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|g_string_append_c
argument_list|(
name|s
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
condition|)
name|g_string_append_c
argument_list|(
name|s
argument_list|,
name|toupper
argument_list|(
name|id
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|p_str
argument_list|(
name|s
operator|->
name|str
argument_list|)
expr_stmt|;
name|g_string_free
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
DECL|function|p_param (FunParams * p,ParamOptions * o)
name|PNode
modifier|*
name|p_param
parameter_list|(
name|FunParams
modifier|*
name|p
parameter_list|,
name|ParamOptions
modifier|*
name|o
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"~~~~~~"
argument_list|,
name|o
operator|->
name|first
condition|?
name|p_nil
else|:
name|p_str
argument_list|(
literal|","
argument_list|)
argument_list|,
operator|!
name|o
operator|->
name|first
operator|&&
operator|!
operator|(
name|o
operator|->
name|types
operator|&&
name|o
operator|->
name|names
operator|)
condition|?
name|p_str
argument_list|(
literal|" "
argument_list|)
else|:
name|p_nil
argument_list|,
operator|(
name|o
operator|->
name|types
operator|&&
name|o
operator|->
name|names
operator|)
condition|?
name|p_str
argument_list|(
literal|"\n\t"
argument_list|)
else|:
name|p_nil
argument_list|,
name|o
operator|->
name|types
condition|?
name|p_type
argument_list|(
operator|&
name|p
operator|->
name|type
argument_list|)
else|:
name|p_nil
argument_list|,
name|o
operator|->
name|types
operator|&&
name|o
operator|->
name|names
condition|?
name|p_str
argument_list|(
literal|" "
argument_list|)
else|:
name|p_nil
argument_list|,
name|o
operator|->
name|names
condition|?
name|p
operator|->
name|name
else|:
name|p_nil
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_header (Module * m,Id suffix)
name|PNode
modifier|*
name|p_header
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|,
name|Id
name|suffix
parameter_list|)
block|{
name|Id
name|base
init|=
name|m
operator|->
name|package
operator|->
name|headerbase
decl_stmt|;
name|Id
name|hdr
init|=
name|m
operator|->
name|header
decl_stmt|;
name|Id
name|name
init|=
name|m
operator|->
name|package
operator|->
name|name
decl_stmt|;
return|return
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|base
condition|?
operator|(
name|base
index|[
literal|0
index|]
condition|?
name|p_fmt
argument_list|(
literal|"~/"
argument_list|,
name|p_str
argument_list|(
name|base
argument_list|)
argument_list|)
else|:
name|p_nil
operator|)
else|:
operator|(
operator|(
name|name
operator|&&
name|name
index|[
literal|0
index|]
operator|)
condition|?
name|p_fmt
argument_list|(
literal|"~/"
argument_list|,
name|p_c_ident
argument_list|(
name|name
argument_list|)
argument_list|)
else|:
name|p_nil
operator|)
argument_list|,
name|hdr
condition|?
name|p_str
argument_list|(
name|hdr
argument_list|)
else|:
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|p_c_ident
argument_list|(
name|m
operator|->
name|name
argument_list|)
argument_list|,
name|p_str
argument_list|(
name|suffix
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_prot_header (Module * m)
name|PNode
modifier|*
name|p_prot_header
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
return|return
name|p_header
argument_list|(
name|m
argument_list|,
literal|".p.h"
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_type_header (Module * m)
name|PNode
modifier|*
name|p_type_header
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
return|return
name|p_header
argument_list|(
name|m
argument_list|,
literal|".t.h"
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_func_header (Module * m)
name|PNode
modifier|*
name|p_func_header
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
return|return
name|p_header
argument_list|(
name|m
argument_list|,
literal|".h"
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_import_header (Module * m)
name|PNode
modifier|*
name|p_import_header
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|header
condition|)
return|return
name|p_nil
return|;
else|else
return|return
name|p_header
argument_list|(
name|m
argument_list|,
literal|".i.h"
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_type_include (Module * m)
name|PNode
modifier|*
name|p_type_include
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"#include<~>\n"
argument_list|,
name|p_type_header
argument_list|(
name|m
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_prot_include (Module * m)
name|PNode
modifier|*
name|p_prot_include
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"#include<~>\n"
argument_list|,
name|p_prot_header
argument_list|(
name|m
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_func_include (Module * m)
name|PNode
modifier|*
name|p_func_include
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"#include<~>\n"
argument_list|,
name|p_func_header
argument_list|(
name|m
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_import_include (Module * m)
name|PNode
modifier|*
name|p_import_include
parameter_list|(
name|Module
modifier|*
name|m
parameter_list|)
block|{
name|PNode
modifier|*
name|hdr
init|=
name|p_import_header
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdr
operator|==
name|p_nil
condition|)
return|return
name|p_nil
return|;
else|else
return|return
name|p_fmt
argument_list|(
literal|"#include<~>\n"
argument_list|,
name|hdr
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_params (FunParams * args,ParamOptions * opt)
name|PNode
modifier|*
name|p_params
parameter_list|(
name|FunParams
modifier|*
name|args
parameter_list|,
name|ParamOptions
modifier|*
name|opt
parameter_list|)
block|{
name|ParamOptions
name|o
init|=
operator|*
name|opt
decl_stmt|;
name|PNode
modifier|*
name|n
init|=
name|p_nil
decl_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|n
operator|=
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|n
argument_list|,
name|p_param
argument_list|(
name|args
argument_list|,
operator|&
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|args
operator|->
name|next
expr_stmt|;
name|o
operator|.
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|p_nil
condition|)
if|if
condition|(
name|opt
operator|->
name|first
condition|)
return|return
name|p_str
argument_list|(
literal|"void"
argument_list|)
return|;
else|else
return|return
name|p_nil
return|;
else|else
return|return
name|n
return|;
block|}
end_function

begin_function
DECL|function|p_prim_varname (PrimType * t)
name|PNode
modifier|*
name|p_prim_varname
parameter_list|(
name|PrimType
modifier|*
name|t
parameter_list|)
block|{
return|return
name|p_c_ident
argument_list|(
name|t
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_primtype (PrimType * t)
name|PNode
modifier|*
name|p_primtype
parameter_list|(
name|PrimType
modifier|*
name|t
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|p_str
argument_list|(
name|t
operator|->
name|module
operator|->
name|package
operator|->
name|name
argument_list|)
argument_list|,
name|p_str
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_cast (PNode * force_type,PNode * expression)
name|PNode
modifier|*
name|p_cast
parameter_list|(
name|PNode
modifier|*
name|force_type
parameter_list|,
name|PNode
modifier|*
name|expression
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"((~)~)"
argument_list|,
name|force_type
argument_list|,
name|expression
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_type (Type * t)
name|PNode
modifier|*
name|p_type
parameter_list|(
name|Type
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|prim
condition|)
block|{
name|PNode
modifier|*
name|node
decl_stmt|;
name|gint
name|i
init|=
name|t
operator|->
name|indirection
decl_stmt|;
name|node
operator|=
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|t
operator|->
name|is_const
condition|?
name|p_str
argument_list|(
literal|"const "
argument_list|)
else|:
name|p_nil
argument_list|,
name|p_primtype
argument_list|(
name|t
operator|->
name|prim
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|node
operator|=
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|node
argument_list|,
name|p_str
argument_list|(
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* file_add_dep(s, t->prim->decl_header);*/
return|return
name|node
return|;
block|}
else|else
return|return
name|p_str
argument_list|(
literal|"void"
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_self_type (ObjectDef * o,PBool const_self)
name|PNode
modifier|*
name|p_self_type
parameter_list|(
name|ObjectDef
modifier|*
name|o
parameter_list|,
name|PBool
name|const_self
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"~~*"
argument_list|,
operator|(
name|const_self
condition|?
name|p_str
argument_list|(
literal|"const "
argument_list|)
else|:
name|p_nil
operator|)
argument_list|,
name|p_primtype
argument_list|(
name|DEF
argument_list|(
name|o
argument_list|)
operator|->
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_varname (PrimType * t,PNode * name)
name|PNode
modifier|*
name|p_varname
parameter_list|(
name|PrimType
modifier|*
name|t
parameter_list|,
name|PNode
modifier|*
name|name
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"~_~_~"
argument_list|,
name|p_c_ident
argument_list|(
name|t
operator|->
name|module
operator|->
name|package
operator|->
name|name
argument_list|)
argument_list|,
name|p_c_ident
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_internal_varname (PrimType * t,PNode * name)
name|PNode
modifier|*
name|p_internal_varname
parameter_list|(
name|PrimType
modifier|*
name|t
parameter_list|,
name|PNode
modifier|*
name|name
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"_~"
argument_list|,
name|p_varname
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_type_guard (Type * t,PNode * var)
name|PNode
modifier|*
name|p_type_guard
parameter_list|(
name|Type
modifier|*
name|t
parameter_list|,
name|PNode
modifier|*
name|var
parameter_list|)
block|{
name|PrimType
modifier|*
name|p
init|=
name|t
operator|->
name|prim
decl_stmt|;
comment|/* 	if(t->notnull&& (p->indirection>1 || p->kind!=GTK_TYPE_OBJECT)) 		return p_fmt("\tg_assert (~);\n", var); 	else if(p->kind==GTK_TYPE_OBJECT) 		return p_fmt("\tg_assert (~ 	 		kind != 	*/
return|return
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
operator|(
name|t
operator|->
name|indirection
operator|&&
name|t
operator|->
name|notnull
condition|?
name|p_fmt
argument_list|(
literal|"\tg_assert (~);\n"
argument_list|,
name|var
argument_list|)
else|:
name|p_nil
operator|)
argument_list|,
operator|(
operator|(
name|t
operator|->
name|indirection
operator|==
literal|1
operator|&&
name|p
operator|->
name|kind
operator|==
name|TYPE_OBJECT
operator|)
condition|?
operator|(
name|t
operator|->
name|notnull
condition|?
name|p_fmt
argument_list|(
literal|"\tg_assert (~(~));\n"
argument_list|,
name|p_macro_name
argument_list|(
name|p
argument_list|,
literal|"is"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|var
argument_list|)
else|:
name|p_fmt
argument_list|(
literal|"\tg_assert (!~ || ~(~));\n"
argument_list|,
name|var
argument_list|,
name|p_macro_name
argument_list|(
name|p
argument_list|,
literal|"is"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|var
argument_list|)
operator|)
else|:
operator|(
name|t
operator|->
name|indirection
operator|==
literal|0
condition|?
operator|(
operator|(
name|p
operator|->
name|kind
operator|==
name|TYPE_ENUM
operator|)
condition|?
name|p_fmt
argument_list|(
literal|"\tg_assert (~<= ~);\n"
argument_list|,
name|var
argument_list|,
name|p_macro_name
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"last"
argument_list|)
argument_list|)
else|:
operator|(
operator|(
name|p
operator|->
name|kind
operator|==
name|TYPE_FLAGS
operator|)
condition|?
name|p_fmt
argument_list|(
literal|"\tg_assert ((~<< 1)< ~);\n"
argument_list|,
name|var
argument_list|,
name|p_macro_name
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|"last"
argument_list|)
argument_list|)
else|:
name|p_nil
operator|)
operator|)
else|:
name|p_nil
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|p_type_guards (FunParams * args)
name|PNode
modifier|*
name|p_type_guards
parameter_list|(
name|FunParams
modifier|*
name|args
parameter_list|)
block|{
name|PNode
modifier|*
name|p
init|=
name|p_nil
decl_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|p
operator|=
name|p_fmt
argument_list|(
literal|"~~"
argument_list|,
name|p
argument_list|,
name|p_type_guard
argument_list|(
operator|&
name|args
operator|->
name|type
argument_list|,
name|args
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|args
operator|->
name|next
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
DECL|function|p_prototype (Type * rettype,PNode * name,PNode * args1,FunParams * args2)
name|PNode
modifier|*
name|p_prototype
parameter_list|(
name|Type
modifier|*
name|rettype
parameter_list|,
name|PNode
modifier|*
name|name
parameter_list|,
name|PNode
modifier|*
name|args1
parameter_list|,
name|FunParams
modifier|*
name|args2
parameter_list|)
block|{
name|ParamOptions
name|o
decl_stmt|;
name|o
operator|.
name|first
operator|=
operator|!
name|args1
operator|||
name|args1
operator|==
name|p_nil
expr_stmt|;
name|o
operator|.
name|names
operator|=
name|TRUE
expr_stmt|;
name|o
operator|.
name|types
operator|=
name|TRUE
expr_stmt|;
return|return
name|p_fmt
argument_list|(
literal|"~ ~ (~~)"
argument_list|,
name|p_type
argument_list|(
name|rettype
argument_list|)
argument_list|,
name|name
argument_list|,
name|args1
argument_list|,
name|p_params
argument_list|(
name|args2
argument_list|,
operator|&
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|output_var_alias (PRoot * out,PrimType * t,PNode * basename)
name|void
name|output_var_alias
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|PrimType
modifier|*
name|t
parameter_list|,
name|PNode
modifier|*
name|basename
parameter_list|)
block|{
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"import_alias"
argument_list|,
name|p_fmt
argument_list|(
literal|"#define ~ ~_~\n"
argument_list|,
name|basename
argument_list|,
name|p_c_ident
argument_list|(
name|t
operator|->
name|module
operator|->
name|package
operator|->
name|name
argument_list|)
argument_list|,
name|basename
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|output_type_alias (PRoot * out,PrimType * t,PNode * basename)
name|void
name|output_type_alias
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|PrimType
modifier|*
name|t
parameter_list|,
name|PNode
modifier|*
name|basename
parameter_list|)
block|{
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"import_alias"
argument_list|,
name|p_fmt
argument_list|(
literal|"typedef ~~ ~;\n"
argument_list|,
name|p_str
argument_list|(
name|t
operator|->
name|module
operator|->
name|package
operator|->
name|name
argument_list|)
argument_list|,
name|basename
argument_list|,
name|basename
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|output_func (PRoot * out,Id tag,Type * rettype,PNode * name,PNode * args1,FunParams * args2,PNode * body)
name|void
name|output_func
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|Id
name|tag
parameter_list|,
name|Type
modifier|*
name|rettype
parameter_list|,
name|PNode
modifier|*
name|name
parameter_list|,
name|PNode
modifier|*
name|args1
parameter_list|,
name|FunParams
modifier|*
name|args2
parameter_list|,
name|PNode
modifier|*
name|body
parameter_list|)
block|{
name|pr_put
argument_list|(
name|out
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|"source_head"
argument_list|,
name|p_fmt
argument_list|(
literal|"~~;\n"
argument_list|,
name|tag
condition|?
name|p_nil
else|:
name|p_str
argument_list|(
literal|"static "
argument_list|)
argument_list|,
name|p_prototype
argument_list|(
name|rettype
argument_list|,
name|name
argument_list|,
name|args1
argument_list|,
name|args2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"source"
argument_list|,
name|p_fmt
argument_list|(
literal|"~~{\n"
literal|"~"
literal|"~"
literal|"}\n\n"
argument_list|,
name|tag
condition|?
name|p_nil
else|:
name|p_str
argument_list|(
literal|"static "
argument_list|)
argument_list|,
name|p_prototype
argument_list|(
name|rettype
argument_list|,
name|name
argument_list|,
name|args1
argument_list|,
name|args2
argument_list|)
argument_list|,
name|p_type_guards
argument_list|(
name|args2
argument_list|)
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|p_macro_name (PrimType * t,Id mid,Id post)
name|PNode
modifier|*
name|p_macro_name
parameter_list|(
name|PrimType
modifier|*
name|t
parameter_list|,
name|Id
name|mid
parameter_list|,
name|Id
name|post
parameter_list|)
block|{
return|return
name|p_fmt
argument_list|(
literal|"~~_~~"
argument_list|,
name|p_c_macro
argument_list|(
name|t
operator|->
name|module
operator|->
name|package
operator|->
name|name
argument_list|)
argument_list|,
name|mid
condition|?
name|p_fmt
argument_list|(
literal|"_~"
argument_list|,
name|p_c_macro
argument_list|(
name|mid
argument_list|)
argument_list|)
else|:
name|p_nil
argument_list|,
name|p_c_macro
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|post
condition|?
name|p_fmt
argument_list|(
literal|"_~"
argument_list|,
name|p_c_macro
argument_list|(
name|post
argument_list|)
argument_list|)
else|:
name|p_nil
argument_list|)
return|;
block|}
end_function

begin_function
DECL|function|output_var (PRoot * out,Id tag,PNode * type,PNode * name)
name|void
name|output_var
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|Id
name|tag
parameter_list|,
name|PNode
modifier|*
name|type
parameter_list|,
name|PNode
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|tag
condition|)
name|pr_put
argument_list|(
name|out
argument_list|,
name|tag
argument_list|,
name|p_fmt
argument_list|(
literal|"extern ~ ~;\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"source_head"
argument_list|,
name|p_fmt
argument_list|(
literal|"~~ ~;\n"
argument_list|,
name|tag
condition|?
name|p_nil
else|:
name|p_str
argument_list|(
literal|"static "
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|output_def (PRoot * out,Def * d)
name|void
name|output_def
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|Def
modifier|*
name|d
parameter_list|)
block|{
name|PrimType
modifier|*
name|t
init|=
name|d
operator|->
name|type
decl_stmt|;
name|PNode
modifier|*
name|type_var
init|=
name|p_internal_varname
argument_list|(
name|t
argument_list|,
name|p_str
argument_list|(
literal|"type"
argument_list|)
argument_list|)
decl_stmt|;
comment|/* GTK_TYPE_FOO macro */
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"type"
argument_list|,
name|p_str
argument_list|(
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"source"
argument_list|,
name|p_str
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"protected"
argument_list|,
name|p_str
argument_list|(
literal|"\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"source_head"
argument_list|,
name|p_str
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"type"
argument_list|,
name|p_fmt
argument_list|(
literal|"#define ~ \\\n"
literal|" (~ ? (void)0 : ~ (), ~)\n"
argument_list|,
name|p_macro_name
argument_list|(
name|t
argument_list|,
literal|"type"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|type_var
argument_list|,
name|p_internal_varname
argument_list|(
name|t
argument_list|,
name|p_str
argument_list|(
literal|"init_type"
argument_list|)
argument_list|)
argument_list|,
name|type_var
argument_list|)
argument_list|)
expr_stmt|;
name|output_macro_import
argument_list|(
name|out
argument_list|,
name|t
argument_list|,
literal|"type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|output_type_import
argument_list|(
name|out
argument_list|,
name|t
operator|->
name|module
operator|->
name|package
argument_list|,
name|p_str
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|output_var
argument_list|(
name|out
argument_list|,
literal|"type"
argument_list|,
name|p_str
argument_list|(
literal|"GtkType"
argument_list|)
argument_list|,
name|type_var
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
operator|->
name|kind
condition|)
block|{
case|case
name|TYPE_OBJECT
case|:
name|output_object
argument_list|(
name|out
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_ENUM
case|:
name|output_enum
argument_list|(
name|out
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_FLAGS
case|:
name|output_flags
argument_list|(
name|out
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
DECL|function|output_type_import (PRoot * out,Package * pkg,PNode * body)
name|void
name|output_type_import
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|Package
modifier|*
name|pkg
parameter_list|,
name|PNode
modifier|*
name|body
parameter_list|)
block|{
if|#
directive|if
literal|1
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"import_alias"
argument_list|,
name|p_fmt
argument_list|(
literal|"#define ~ ~~\n"
argument_list|,
name|body
argument_list|,
name|p_str
argument_list|(
name|pkg
operator|->
name|name
argument_list|)
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"import_alias"
argument_list|,
name|p_fmt
argument_list|(
literal|"typedef ~~ ~;\n"
argument_list|,
name|p_str
argument_list|(
name|pkg
operator|->
name|name
argument_list|)
argument_list|,
name|body
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
DECL|function|output_macro_import (PRoot * out,PrimType * t,Id mid,Id post)
name|void
name|output_macro_import
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|PrimType
modifier|*
name|t
parameter_list|,
name|Id
name|mid
parameter_list|,
name|Id
name|post
parameter_list|)
block|{
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"import_alias"
argument_list|,
name|p_fmt
argument_list|(
literal|"#define ~~~ ~\n"
argument_list|,
name|mid
condition|?
name|p_fmt
argument_list|(
literal|"~_"
argument_list|,
name|p_c_macro
argument_list|(
name|mid
argument_list|)
argument_list|)
else|:
name|p_nil
argument_list|,
name|p_c_macro
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|post
condition|?
name|p_fmt
argument_list|(
literal|"_~"
argument_list|,
name|p_c_macro
argument_list|(
name|post
argument_list|)
argument_list|)
else|:
name|p_nil
argument_list|,
name|p_macro_name
argument_list|(
name|t
argument_list|,
name|mid
argument_list|,
name|post
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|function|output_var_import (PRoot * out,PrimType * t,PNode * body)
name|void
name|output_var_import
parameter_list|(
name|PRoot
modifier|*
name|out
parameter_list|,
name|PrimType
modifier|*
name|t
parameter_list|,
name|PNode
modifier|*
name|body
parameter_list|)
block|{
name|pr_put
argument_list|(
name|out
argument_list|,
literal|"import_alias"
argument_list|,
name|p_fmt
argument_list|(
literal|"#define ~_~ ~\n"
argument_list|,
name|p_c_ident
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|body
argument_list|,
name|p_varname
argument_list|(
name|t
argument_list|,
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* void add_dep(PRoot* out, Id tag, PrimType* type){ 	pr_put(out, tag, type->module); }  PNode* p_deps(Id tag){ 	return p_col(tag, p_dep, NULL); } */
end_comment

end_unit

